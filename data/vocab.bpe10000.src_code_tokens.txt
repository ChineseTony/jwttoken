void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
int __xstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _xstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
int iswalnum ( wint_t @@wc@@ ) { return iswalnum ( @@wc@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
int iconv_close ( iconv_t @@cd@@ ) { return iconv_close ( @@cd@@ ) ; }
char * nl_langinfo ( nl_item @@item@@ ) { return nl_langinfo ( @@item@@ ) ; }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
int __fxstat ( int @@ver@@ , int @@fildes@@ , struct stat * @@stat_buf@@ ) { return _fxstat ( @@ver@@ , @@fildes@@ , @@stat_buf@@ ) ; }
int iswspace ( wint_t @@wc@@ ) { return iswspace ( @@wc@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
char * strdup ( const char * @@s@@ ) { return strdup ( @@s@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
size_t __fastcall strnlen1 ( const void * @@a1@@ , size_t @@a2@@ ) { _BYTE * @@v2@@ ; __int64 @@v3@@ ; bool @@v4@@ ; size_t @@result@@ ; @@v2@@ = memchr ( @@a1@@ , Number , @@a2@@ ) ; @@v3@@ = @@v2@@ - ( _BYTE * ) @@a1@@ + Number ; @@v4@@ = @@v2@@ == Number L ; @@result@@ = @@a2@@ ; if ( ! @@v4@@ ) @@result@@ = @@v3@@ ; return @@result@@ ; }
const char * __fastcall proper_name ( char * @@s@@ ) { char * @@v1@@ ; const char * @@v2@@ ; size_t @@v4@@ ; size_t @@v5@@ ; __int64 @@v6@@ ; @@v1@@ = dcgettext ( Number L , @@s@@ , Number ) ; @@v2@@ = @@v1@@ ; if ( @@s@@ == @@v1@@ || ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@v1@@ , ( __int64 ) @@s@@ ) ) { return @@v2@@ ; } @@v4@@ = strlen ( @@v2@@ ) ; @@v5@@ = strlen ( @@s@@ ) ; @@v6@@ = xmalloc ( @@v4@@ + @@v5@@ + Number ) ; __sprintf_chk ( ) ; return ( const char * ) @@v6@@ ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; FILE * @@v11@@ ; char * @@v12@@ ; FILE * @@v13@@ ; char * @@v14@@ ; FILE * @@v15@@ ; char * @@v16@@ ; FILE * @@v17@@ ; char * @@v18@@ ; FILE * @@v19@@ ; char * @@v20@@ ; FILE * @@v21@@ ; char * @@v22@@ ; char * @@v23@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String String String String String String String String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = stdout ; @@v10@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; @@v11@@ = stdout ; @@v12@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v12@@ , @@v11@@ ) ; @@v13@@ = stdout ; @@v14@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v14@@ , @@v13@@ ) ; @@v15@@ = stdout ; @@v16@@ = dcgettext ( Number L , String String String , Number ) ; fputs_unlocked ( @@v16@@ , @@v15@@ ) ; @@v17@@ = stdout ; @@v18@@ = dcgettext ( Number L , String String String String , Number ) ; fputs_unlocked ( @@v18@@ , @@v17@@ ) ; @@v19@@ = stdout ; @@v20@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v20@@ , @@v19@@ ) ; last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v21@@ = stdout ; @@v22@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v22@@ , @@v21@@ ) ; @@v23@@ = setlocale ( Number , Number L ) ; if ( @@v23@@ ) { if ( strncmp ( @@v23@@ , String , Number ) ) { last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
char * __fastcall str_iconv ( char * @@s@@ , char * @@fromcode@@ , char * @@tocode@@ ) { char * @@v4@@ ; iconv_t @@v6@@ ; void * @@v7@@ ; int * @@v8@@ ; int @@v9@@ ; int * @@v10@@ ; int * @@v11@@ ; int @@v12@@ ; int * @@v13@@ ; if ( * @@s@@ && ( unsigned int ) c_strcasecmp ( ( unsigned __int8 * ) @@fromcode@@ , ( unsigned __int8 * ) @@tocode@@ ) ) { @@v6@@ = iconv_open ( @@tocode@@ , @@fromcode@@ ) ; @@v7@@ = @@v6@@ ; if ( @@v6@@ == ( iconv_t ) Number ) return Number L ; @@v4@@ = str_cd_iconv ( @@s@@ , @@v6@@ ) ; if ( @@v4@@ ) { if ( iconv_close ( @@v7@@ ) < Number ) { @@v8@@ = __errno_location ( ) ; @@v9@@ = * @@v8@@ ; @@v10@@ = @@v8@@ ; free ( @@v4@@ ) ; @@v4@@ = Number L ; * @@v10@@ = @@v9@@ ; } } else { @@v11@@ = __errno_location ( ) ; @@v12@@ = * @@v11@@ ; @@v13@@ = @@v11@@ ; iconv_close ( @@v7@@ ) ; * @@v13@@ = @@v12@@ ; } return @@v4@@ ; } @@v4@@ = strdup ( @@s@@ ) ; if ( @@v4@@ ) return @@v4@@ ; * __errno_location ( ) = Number ; return Number L ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_20C1F0 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20C1D0 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20C1E0 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_20C1F0 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20C1D0 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_20C1E0 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
char * __fastcall mmalloca ( __int64 @@a1@@ ) { bool @@v1@@ ; size_t @@v2@@ ; _DWORD * @@v3@@ ; char * @@v4@@ ; unsigned __int64 @@v5@@ ; __int64 @@v6@@ ; @@v1@@ = __CFADD__ ( @@a1@@ , Number L ) ; @@v2@@ = @@a1@@ + Number ; if ( @@v1@@ ) return Number L ; @@v3@@ = malloc ( @@v2@@ ) ; @@v4@@ = Number L ; if ( @@v3@@ ) { @@v3@@ [ Number ] = Number ; @@v4@@ = ( char * ) ( @@v3@@ + Number ) ; @@v5@@ = ( unsigned __int64 ) ( @@v3@@ + Number ) % Number ; @@v6@@ = mmalloca_results [ @@v5@@ ] ; mmalloca_results [ @@v5@@ ] = @@v3@@ + Number ; * ( _QWORD * ) @@v3@@ = @@v6@@ ; } return @@v4@@ ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
__int64 __fastcall c_strcasecmp ( unsigned __int8 * @@a1@@ , unsigned __int8 * @@a2@@ ) { __int64 @@result@@ ; int @@v3@@ ; int @@v4@@ ; @@result@@ = Number L ; if ( @@a1@@ != @@a2@@ ) { do { @@v3@@ = * @@a1@@ ; if ( ( unsigned int ) ( @@v3@@ - Number ) < Number ) LOBYTE ( @@v3@@ ) = @@v3@@ + Number ; @@v4@@ = * @@a2@@ ; if ( ( unsigned int ) ( @@v4@@ - Number ) < Number ) LOBYTE ( @@v4@@ ) = @@v4@@ + Number ; if ( ! ( _BYTE ) @@v3@@ ) break ; ++ @@a1@@ ; ++ @@a2@@ ; } while ( ( _BYTE ) @@v3@@ == ( _BYTE ) @@v4@@ ) ; @@result@@ = ( unsigned __int8 ) @@v3@@ - ( unsigned int ) ( unsigned __int8 ) @@v4@@ ; } return @@result@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
size_t __fastcall mbslen ( char * @@s@@ ) { __int64 @@i@@ ; int @@v3@@ ; wchar_t @@v4@@ ; size_t @@v5@@ ; size_t @@v6@@ ; size_t @@v7@@ ; size_t @@v8@@ ; char @@v9@@ ; mbstate_t @@v10@@ ; char @@v11@@ ; char * @@sa@@ ; size_t @@v13@@ ; char @@v14@@ ; wchar_t @@v15@@ [ Number ] ; unsigned __int64 @@v16@@ ; @@v16@@ = __readfsqword ( Number ) ; if ( __ctype_get_mb_cur_max ( ) > Number ) { @@sa@@ = @@s@@ ; @@v9@@ = Number ; @@v10@@ = Number L ; @@v11@@ = Number ; for ( @@i@@ = Number L ; ; ++ @@i@@ ) { if ( ! @@v9@@ ) { @@v3@@ = is_basic_table [ ( ( unsigned __int8 ) * @@sa@@ >> Number ) & Number ] ; if ( _bittest ( & @@v3@@ , ( unsigned __int8 ) * @@sa@@ ) ) { @@v13@@ = Number L ; @@v4@@ = * @@sa@@ ; @@v14@@ = Number ; @@v11@@ = Number ; @@v15@@ [ Number ] = @@v4@@ ; goto LABEL_7 ; } if ( ! mbsinit ( & @@v10@@ ) ) __assert_fail ( String , String , Number , String ) ; @@v9@@ = Number ; } @@v5@@ = __ctype_get_mb_cur_max ( ) ; @@v6@@ = strnlen1 ( @@sa@@ , @@v5@@ ) ; @@v7@@ = mbrtowc ( @@v15@@ , @@sa@@ , @@v6@@ , & @@v10@@ ) ; @@v13@@ = @@v7@@ ; switch ( @@v7@@ ) { case Number : @@v13@@ = Number L ; @@v14@@ = Number ; goto LABEL_8 ; case Number : @@v8@@ = strlen ( @@sa@@ ) ; @@v14@@ = Number ; @@v13@@ = @@v8@@ ; goto LABEL_8 ; case Number : @@v13@@ = Number L ; if ( * @@sa@@ ) __assert_fail ( String , String , Number , String ) ; if ( @@v15@@ [ Number ] ) __assert_fail ( String , String , Number , String ) ; break ; } @@v14@@ = Number ; if ( mbsinit ( & @@v10@@ ) ) @@v9@@ = Number ; @@v11@@ = Number ; LABEL_7 : if ( ! @@v15@@ [ Number ] ) return @@i@@ ; LABEL_8 : @@sa@@ += @@v13@@ ; @@v11@@ = Number ; } } return strlen ( @@s@@ ) ; }
__int64 __fastcall knuth_morris_pratt_unibyte ( unsigned __int8 * @@a1@@ , const char * @@a2@@ , unsigned __int8 * * @@a3@@ ) { const char * @@v4@@ ; size_t @@v6@@ ; void * @@v7@@ ; __int64 * @@v8@@ ; __int64 @@v9@@ ; __int64 @@i@@ ; char @@v11@@ ; __int64 @@v12@@ ; unsigned __int8 * @@v13@@ ; __int64 @@v14@@ ; __int64 @@v16@@ ; @@v4@@ = @@a2@@ ; @@v6@@ = strlen ( @@a2@@ ) ; if ( @@v6@@ > Number ) return Number L ; if ( Number * @@v6@@ > Number ) { @@v8@@ = ( __int64 * ) mmalloca ( ) ; } else { @@v7@@ = alloca ( Number * @@v6@@ + Number ) ; @@v8@@ = & @@v16@@ ; } if ( ! @@v8@@ ) return Number L ; @@v8@@ [ Number ] = Number L ; if ( @@v6@@ > Number ) { @@v9@@ = Number L ; for ( @@i@@ = Number L ; @@i@@ != @@v6@@ ; ++ @@i@@ ) { @@v11@@ = @@a2@@ [ @@i@@ - Number ] ; if ( @@v11@@ == @@a2@@ [ @@v9@@ ] ) { LABEL_23 : ++ @@v9@@ ; @@v8@@ [ @@i@@ ] = @@i@@ - @@v9@@ ; } else { while ( @@v9@@ ) { @@v9@@ -= @@v8@@ [ @@v9@@ ] ; if ( @@v11@@ == @@a2@@ [ @@v9@@ ] ) goto LABEL_23 ; } @@v8@@ [ @@i@@ ] = @@i@@ ; @@v9@@ = Number L ; } } } * @@a3@@ = Number L ; @@v12@@ = * @@a1@@ ; @@v13@@ = @@a1@@ ; @@v14@@ = Number L ; LABEL_14 : while ( Number ) { if ( ( _BYTE ) @@v12@@ ) { while ( @@v4@@ [ @@v14@@ ] != ( _BYTE ) @@v12@@ ) { if ( ! @@v14@@ ) { @@v12@@ = @@v13@@ [ Number ] ; ++ @@a1@@ ; ++ @@v13@@ ; goto LABEL_14 ; } @@a2@@ = ( const char * ) @@v8@@ [ @@v14@@ ] ; @@a1@@ = & @@a1@@ [ ( _QWORD ) @@a2@@ ] ; @@v14@@ -= ( __int64 ) @@a2@@ ; } ++ @@v14@@ ; @@a2@@ = ( const char * ) ( @@v13@@ + Number ) ; if ( @@v6@@ != @@v14@@ ) { @@v12@@ = * ++ @@v13@@ ; continue ; } * @@a3@@ = @@a1@@ ; } break ; } freea ( @@v8@@ , @@a2@@ , @@v12@@ , @@v13@@ ) ; return Number L ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
void __fastcall freea ( unsigned __int64 @@a1@@ ) { __int64 @@v1@@ ; __int64 @@v2@@ ; _QWORD * @@v3@@ ; if ( @@a1@@ ) { if ( * ( _DWORD * ) ( @@a1@@ - Number ) == Number ) { @@v1@@ = mmalloca_results [ @@a1@@ % Number ] ; if ( @@v1@@ ) { if ( @@v1@@ == @@a1@@ ) { @@v3@@ = & mmalloca_results [ @@a1@@ % Number ] ; LABEL_12 : * @@v3@@ = * ( _QWORD * ) ( @@a1@@ - Number ) ; free ( ( void * ) ( @@a1@@ - Number ) ) ; } else { while ( Number ) { @@v2@@ = * ( _QWORD * ) ( @@v1@@ - Number ) ; if ( ! @@v2@@ ) break ; if ( @@a1@@ == @@v2@@ ) { @@v3@@ = ( _QWORD * ) ( @@v1@@ - Number ) ; goto LABEL_12 ; } @@v1@@ = * ( _QWORD * ) ( @@v1@@ - Number ) ; } } } } } }
int __cdecl __noreturn main ( int @@argc@@ , const char * * @@argv@@ , const char * * envp ) { const char * @@v3@@ ; size_t @@v4@@ ; char * @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; char * @@v9@@ ; set_program_name ( * @@argv@@ ) ; setlocale ( Number , String ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; parse_long_options ( @@argc@@ , ( _DWORD ) @@argv@@ , ( unsigned int ) String , ( unsigned int ) & unk_3C3E , ( _DWORD ) Version , ( unsigned int ) usage , String , String , Number L ) ; if ( getopt_long ( @@argc@@ , ( char * const * ) @@argv@@ , String , Number L , Number L ) == Number ) { if ( optind < @@argc@@ ) { if ( optind + Number >= @@argc@@ ) { @@v3@@ = @@argv@@ [ optind ] ; @@v4@@ = dir_len ( @@v3@@ ) ; if ( @@v4@@ ) { fwrite_unlocked ( @@v3@@ , Number , @@v4@@ , stdout ) ; } else { @@v9@@ = stdout -> _IO_write_ptr ; if ( @@v9@@ >= stdout -> _IO_write_end ) { __overflow ( stdout , Number ) ; } else { stdout -> _IO_write_ptr = @@v9@@ + Number ; * @@v9@@ = Number ; } } @@v5@@ = stdout -> _IO_write_ptr ; if ( @@v5@@ >= stdout -> _IO_write_end ) { __overflow ( stdout , Number ) ; } else { stdout -> _IO_write_ptr = @@v5@@ + Number ; * @@v5@@ = Number ; } exit ( Number ) ; } @@v7@@ = quote ( @@argv@@ [ optind + Number ] ) ; @@v8@@ = dcgettext ( Number L , String , Number ) ; error ( Number , Number , @@v8@@ , @@v7@@ ) ; usage ( Number ) ; } @@v6@@ = dcgettext ( Number L , String , Number ) ; error ( Number , Number , @@v6@@ ) ; } usage ( Number ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
_BYTE * __fastcall mdir_name ( void * @@src@@ ) { __int64 @@v1@@ ; _BYTE * @@v2@@ ; _BYTE * @@v3@@ ; _BYTE * @@v4@@ ; @@v1@@ = dir_len ( @@src@@ ) ; @@v2@@ = malloc ( @@v1@@ + ( @@v1@@ == Number ) + Number ) ; @@v3@@ = @@v2@@ ; if ( @@v2@@ ) { @@v4@@ = memcpy ( @@v2@@ , @@src@@ , @@v1@@ ) ; @@v3@@ = @@v4@@ ; if ( ! @@v1@@ ) { * @@v4@@ = Number ; @@v1@@ = Number L ; } @@v4@@ [ @@v1@@ ] = Number ; } return @@v3@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
__int64 __fastcall dir_len ( _BYTE * @@a1@@ ) { unsigned __int64 @@v1@@ ; _BYTE * @@v2@@ ; __int64 @@v3@@ ; @@v1@@ = * @@a1@@ == Number ; @@v2@@ = last_component ( @@a1@@ ) ; if ( @@v2@@ - @@a1@@ <= @@v1@@ ) return @@v2@@ - @@a1@@ ; @@v3@@ = @@v2@@ - @@a1@@ - Number ; if ( * ( @@v2@@ - Number ) != Number ) return @@v2@@ - @@a1@@ ; while ( @@v1@@ != @@v3@@ && @@a1@@ [ @@v3@@ - Number ] == Number ) -- @@v3@@ ; return @@v3@@ ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; char * @@v10@@ ; char * @@v11@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String String String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; last_component ( program_name , @@v7@@ ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v8@@ = stdout ; @@v9@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = Number L ; @@v11@@ = setlocale ( Number , Number L ) ; if ( @@v11@@ ) { @@v10@@ = String ; if ( strncmp ( @@v11@@ , String , Number ) ) { last_component ( program_name , String ) ; @@v10@@ = dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name , @@v10@@ ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
void __fastcall base64_decode_ctx_init ( _DWORD * @@a1@@ ) { * @@a1@@ = Number ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_2061F0 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061D0 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_2061E0 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_2061F0 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061D0 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061E0 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall base64_encode_alloc ( char * @@a1@@ , unsigned __int64 @@a2@@ , _QWORD * @@a3@@ ) { unsigned __int64 @@v4@@ ; __int64 @@v5@@ ; unsigned __int64 @@v6@@ ; _BYTE * @@v8@@ ; @@v4@@ = ( @@a2@@ + Number ) / Number ; @@v5@@ = Number * @@v4@@ ; @@v6@@ = Number * @@v4@@ + Number ; if ( @@a2@@ > @@v6@@ ) { * @@a3@@ = Number L ; return Number L ; } @@v8@@ = malloc ( Number * @@v4@@ + Number ) ; * @@a3@@ = @@v8@@ ; if ( ! @@v8@@ ) return @@v6@@ ; base64_encode ( @@a1@@ , @@a2@@ , @@v8@@ , @@v6@@ ) ; return @@v5@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
char __fastcall isbase64 ( unsigned __int8 @@a1@@ ) { return ( unsigned __int8 ) ~ b64 [ @@a1@@ ] >> Number ; }
void __fastcall put_space ( int @@a1@@ ) { int @@v1@@ ; int @@v2@@ ; int @@v3@@ ; int @@v4@@ ; char * @@v5@@ ; int @@v6@@ ; char * @@v7@@ ; @@v1@@ = out_column ; @@v2@@ = out_column + @@a1@@ ; if ( tabs ) { @@v3@@ = @@v2@@ + Number ; if ( @@v2@@ >= Number ) @@v3@@ = out_column + @@a1@@ ; @@v4@@ = @@v3@@ >> Number ; if ( out_column + Number < Number * @@v4@@ && out_column < Number * @@v4@@ ) { do { @@v5@@ = stdout -> _IO_write_ptr ; if ( @@v5@@ >= stdout -> _IO_write_end ) { __overflow ( stdout , Number ) ; } else { stdout -> _IO_write_ptr = @@v5@@ + Number ; * @@v5@@ = Number ; } @@v6@@ = out_column / Number + Number ; @@v1@@ = Number * @@v6@@ ; out_column = Number * @@v6@@ ; } while ( @@v4@@ > @@v6@@ ) ; } } if ( @@v2@@ > @@v1@@ ) { do { @@v7@@ = stdout -> _IO_write_ptr ; if ( @@v7@@ >= stdout -> _IO_write_end ) { __overflow ( stdout , Number ) ; } else { stdout -> _IO_write_ptr = @@v7@@ + Number ; * @@v7@@ = Number ; } ++ out_column ; } while ( out_column < @@v2@@ ) ; } }
char __fastcall base64_decode_alloc_ctx ( _DWORD * @@a1@@ , unsigned __int8 * @@a2@@ , unsigned __int64 @@a3@@ , void * * @@a4@@ , _QWORD * @@a5@@ ) { _BYTE * @@v8@@ ; char @@result@@ ; size_t @@v10@@ [ Number ] ; @@v10@@ [ Number ] = __readfsqword ( Number ) ; @@v10@@ [ Number ] = Number * ( @@a3@@ >> Number ) + Number ; @@v8@@ = malloc ( @@v10@@ [ Number ] ) ; * @@a4@@ = @@v8@@ ; if ( ! @@v8@@ ) return Number ; @@result@@ = base64_decode_ctx ( @@a1@@ , @@a2@@ , @@a3@@ , @@v8@@ , @@v10@@ ) ; if ( @@result@@ ) { if ( @@a5@@ ) { * @@a5@@ = @@v10@@ [ Number ] ; return @@result@@ ; } return Number ; } free ( * @@a4@@ ) ; * @@a4@@ = Number L ; return Number ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; FILE * @@v11@@ ; char * @@v12@@ ; char * @@v13@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String String String String String String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = stdout ; @@v10@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v11@@ = stdout ; @@v12@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v12@@ , @@v11@@ ) ; @@v13@@ = setlocale ( Number , Number L ) ; if ( @@v13@@ ) { if ( strncmp ( @@v13@@ , String , Number ) ) { last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
void __fastcall base64_encode ( char * @@a1@@ , __int64 @@a2@@ , _BYTE * @@a3@@ , __int64 @@a4@@ ) { unsigned __int8 @@v4@@ ; char @@v5@@ ; unsigned __int8 @@v6@@ ; char @@v7@@ ; char @@v8@@ ; while ( @@a2@@ && @@a4@@ ) { @@v7@@ = * @@a1@@ ; * @@a3@@ = b64str_2996 [ ( ( unsigned __int8 ) * @@a1@@ >> Number ) & Number ] ; if ( @@a4@@ == Number ) return ; @@v8@@ = Number * @@v7@@ ; if ( @@a2@@ == Number ) { @@a3@@ [ Number ] = b64str_2996 [ @@v8@@ & Number ] ; if ( @@a4@@ == Number ) return ; @@a3@@ [ Number ] = Number ; if ( @@a4@@ == Number ) return ; goto LABEL_15 ; } @@v4@@ = @@a1@@ [ Number ] ; @@a3@@ [ Number ] = b64str_2996 [ ( ( @@v4@@ >> Number ) + @@v8@@ ) & Number ] ; if ( @@a4@@ == Number ) return ; @@v5@@ = Number * @@v4@@ ; if ( @@a2@@ == Number ) { @@a3@@ [ Number ] = b64str_2996 [ @@v5@@ & Number ] ; if ( @@a4@@ == Number ) return ; LABEL_15 : @@a3@@ [ Number ] = Number ; if ( @@a4@@ == Number ) return ; @@a2@@ = Number L ; goto LABEL_8 ; } @@v6@@ = @@a1@@ [ Number ] ; @@a3@@ [ Number ] = b64str_2996 [ ( ( @@v6@@ >> Number ) + @@v5@@ ) & Number ] ; if ( @@a4@@ == Number ) return ; @@a3@@ [ Number ] = b64str_2996 [ @@v6@@ & Number ] ; if ( @@a4@@ == Number ) return ; @@a2@@ -= Number L ; if ( @@a2@@ ) @@a1@@ += Number ; LABEL_8 : @@a3@@ += Number ; @@a4@@ -= Number L ; } if ( @@a4@@ ) * @@a3@@ = Number ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_213250 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_213230 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_213240 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_2071F0 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2071D0 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_2071E0 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
__int64 __fastcall head_bytes ( __int64 @@a1@@ , int @@a2@@ , size_t @@a3@@ ) { size_t @@v3@@ ; size_t @@v4@@ ; unsigned __int64 @@v5@@ ; unsigned __int64 @@v6@@ ; char * @@v7@@ ; int * @@v8@@ ; __int64 @@v10@@ ; char * @@v11@@ ; int * @@v12@@ ; char @@ptr@@ [ Number ] ; unsigned __int64 @@v14@@ ; @@v14@@ = __readfsqword ( Number ) ; if ( ! @@a3@@ ) return Number L ; @@v3@@ = @@a3@@ ; @@v4@@ = Number ; while ( Number ) { if ( @@v4@@ > @@v3@@ ) @@v4@@ = @@v3@@ ; @@v5@@ = safe_read ( @@a2@@ , @@ptr@@ , @@v4@@ ) ; @@v6@@ = @@v5@@ ; if ( @@v5@@ == Number ) break ; if ( ! @@v5@@ ) return Number L ; if ( @@v5@@ <= fwrite_unlocked ( @@ptr@@ , Number , @@v5@@ , stdout ) ) { @@v3@@ -= @@v6@@ ; if ( ! @@v3@@ ) return Number L ; } else { @@v7@@ = dcgettext ( Number L , String , Number ) ; @@v8@@ = __errno_location ( ) ; error ( Number , * @@v8@@ , @@v7@@ ) ; @@v3@@ -= @@v6@@ ; if ( ! @@v3@@ ) return Number L ; } } @@v10@@ = quote ( @@a1@@ ) ; @@v11@@ = dcgettext ( Number L , String , Number ) ; @@v12@@ = __errno_location ( ) ; error ( Number , * @@v12@@ , @@v11@@ , @@v10@@ ) ; return Number L ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; program_invocation_short_name = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
int __fastcall get_prefix ( _IO_FILE * @@a1@@ ) { char * @@v1@@ ; bool @@v2@@ ; int @@v3@@ ; int @@result@@ ; char * @@v5@@ ; int @@v6@@ ; int @@v7@@ ; int @@v8@@ ; char * @@v9@@ ; int @@v10@@ ; @@v1@@ = @@a1@@ -> _IO_read_ptr ; @@v2@@ = @@v1@@ < @@a1@@ -> _IO_read_end ; in_column = Number ; if ( @@v2@@ ) { @@a1@@ -> _IO_read_ptr = @@v1@@ + Number ; @@v3@@ = ( unsigned __int8 ) * @@v1@@ ; } else { @@v3@@ = __uflow ( @@a1@@ ) ; } @@result@@ = get_space ( @@a1@@ , @@v3@@ ) ; if ( prefix_length ) { @@v5@@ = prefix ; @@v6@@ = in_column ; @@v7@@ = ( unsigned __int8 ) * prefix ; next_prefix_indent = in_column ; if ( ( _BYTE ) @@v7@@ ) { if ( @@result@@ == @@v7@@ ) { while ( Number ) { @@v9@@ = @@a1@@ -> _IO_read_ptr ; @@v2@@ = @@v9@@ < @@a1@@ -> _IO_read_end ; in_column = @@v6@@ + Number ; if ( @@v2@@ ) { ++ @@v5@@ ; @@a1@@ -> _IO_read_ptr = @@v9@@ + Number ; @@v8@@ = ( unsigned __int8 ) * @@v5@@ ; @@result@@ = ( unsigned __int8 ) * @@v9@@ ; if ( ! ( _BYTE ) @@v8@@ ) goto LABEL_12 ; } else { ++ @@v5@@ ; @@result@@ = __uflow ( @@a1@@ ) ; @@v8@@ = ( unsigned __int8 ) * @@v5@@ ; if ( ! ( _BYTE ) @@v8@@ ) goto LABEL_12 ; } if ( @@v8@@ != @@result@@ ) return @@result@@ ; @@v6@@ = in_column ; } } } else { LABEL_12 : @@result@@ = get_space ( @@a1@@ , @@result@@ ) ; } } else { @@v10@@ = prefix_lead_space ; if ( in_column <= prefix_lead_space ) @@v10@@ = in_column ; next_prefix_indent = @@v10@@ ; } return @@result@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_2071F0 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2071D0 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2071E0 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
__int64 __fastcall set_other_indent ( char @@a1@@ ) { __int64 @@result@@ ; if ( split ) { @@result@@ = ( unsigned int ) first_indent ; other_indent = first_indent ; } else if ( crown ) { @@result@@ = ( unsigned int ) in_column ; if ( ! @@a1@@ ) @@result@@ = ( unsigned int ) first_indent ; other_indent = @@result@@ ; } else { @@result@@ = ( unsigned int ) first_indent ; if ( tagged ) { if ( ! @@a1@@ || in_column == first_indent ) { if ( other_indent == first_indent ) { @@result@@ = first_indent == Number ? Number : Number ; other_indent = first_indent == Number ? Number : Number ; } } else { other_indent = in_column ; } } else { other_indent = first_indent ; } } return @@result@@ ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
__int64 __fastcall put_word_isra_1 ( unsigned __int8 * @@a1@@ , unsigned int * @@a2@@ ) { __int64 @@result@@ ; __int64 @@v3@@ ; unsigned __int8 * @@v5@@ ; int @@v6@@ ; char * @@v7@@ ; @@result@@ = * @@a2@@ ; if ( ( _DWORD ) @@result@@ ) { @@v3@@ = ( __int64 ) & @@a1@@ [ ( unsigned int ) ( @@result@@ - Number ) + Number ] ; @@v5@@ = @@a1@@ ; do { @@v6@@ = * @@v5@@ ++ ; @@v7@@ = stdout -> _IO_write_ptr ; if ( @@v7@@ >= stdout -> _IO_write_end ) { __overflow ( stdout , @@v6@@ ) ; } else { stdout -> _IO_write_ptr = @@v7@@ + Number ; * @@v7@@ = @@v6@@ ; } } while ( @@v5@@ != ( unsigned __int8 * ) @@v3@@ ) ; @@result@@ = * @@a2@@ ; out_column += @@result@@ ; } return @@result@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
size_t flush_paragraph ( ) { __int64 @@v0@@ ; __int64 @@v1@@ ; __int64 @@v2@@ ; __int64 * @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; __int64 @@v10@@ ; __int64 * @@i@@ ; size_t @@result@@ ; @@v0@@ = word_limit ; if ( ( _UNKNOWN * ) word_limit == & unused_word_type ) { @@result@@ = fwrite_unlocked ( & parabuf , Number , wptr - ( _QWORD ) & parabuf , stdout ) ; wptr = ( __int64 ) & parabuf ; } else { fmt_paragraph ( ) ; @@v1@@ = qword_208100 ; if ( @@v0@@ == qword_208100 ) { @@v3@@ = ( __int64 * ) @@v0@@ ; } else { @@v2@@ = * ( _QWORD * ) ( qword_208100 + Number ) ; @@v3@@ = ( __int64 * ) @@v0@@ ; @@v4@@ = Number ; do { @@v5@@ = * ( _QWORD * ) ( @@v1@@ + Number ) ; @@v6@@ = @@v2@@ - * ( _QWORD * ) ( @@v5@@ + Number ) ; if ( @@v6@@ < @@v4@@ ) { @@v4@@ = @@v6@@ ; @@v3@@ = ( __int64 * ) @@v1@@ ; } @@v1@@ = * ( _QWORD * ) ( @@v1@@ + Number ) ; if ( @@v4@@ <= Number ) @@v4@@ += Number L ; @@v2@@ = * ( _QWORD * ) ( @@v5@@ + Number ) ; } while ( @@v0@@ != @@v5@@ ) ; } put_paragraph ( ( __int64 ) @@v3@@ ) ; @@v7@@ = wptr ; __memmove_chk ( ) ; @@v8@@ = * @@v3@@ ; @@v9@@ = word_limit ; @@v10@@ = - ( __int64 ) ( int ) ( * @@v3@@ - ( unsigned int ) & parabuf ) ; wptr = @@v7@@ - ( int ) ( * @@v3@@ - ( unsigned int ) & parabuf ) ; if ( ( unsigned __int64 ) @@v3@@ <= word_limit ) { for ( @@i@@ = @@v3@@ ; ; @@v8@@ = * @@i@@ ) { @@i@@ += Number ; * ( @@i@@ - Number ) = @@v10@@ + @@v8@@ ; if ( ( unsigned __int64 ) @@i@@ > @@v9@@ ) break ; } } @@result@@ = __memmove_chk ( ) ; word_limit = @@v9@@ - ( ( char * ) @@v3@@ - ( char * ) & unused_word_type ) ; } return @@result@@ ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; FILE * @@v11@@ ; char * @@v12@@ ; FILE * @@v13@@ ; char * @@v14@@ ; FILE * @@v15@@ ; char * @@v16@@ ; char * @@v17@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String String String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String String String String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = stdout ; @@v10@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; @@v11@@ = stdout ; @@v12@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v12@@ , @@v11@@ ) ; @@v13@@ = stdout ; @@v14@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v14@@ , @@v13@@ ) ; last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v15@@ = stdout ; @@v16@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v16@@ , @@v15@@ ) ; @@v17@@ = setlocale ( Number , Number L ) ; if ( @@v17@@ ) { if ( strncmp ( @@v17@@ , String , Number ) ) { last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
int __fastcall get_space ( _IO_FILE * @@a1@@ , int @@a2@@ ) { int @@result@@ ; char * @@v3@@ ; for ( @@result@@ = @@a2@@ ; ; @@result@@ = ( unsigned __int8 ) * @@v3@@ ) { while ( @@result@@ == Number ) { ++ in_column ; @@v3@@ = @@a1@@ -> _IO_read_ptr ; if ( @@v3@@ < @@a1@@ -> _IO_read_end ) goto LABEL_4 ; LABEL_7 : @@result@@ = __uflow ( @@a1@@ ) ; } if ( @@result@@ != Number ) break ; tabs = Number ; in_column = Number * ( in_column / Number ) + Number ; @@v3@@ = @@a1@@ -> _IO_read_ptr ; if ( @@v3@@ >= @@a1@@ -> _IO_read_end ) goto LABEL_7 ; LABEL_4 : @@a1@@ -> _IO_read_ptr = @@v3@@ + Number ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
int __fastcall put_line ( __int64 @@a1@@ , int @@a2@@ ) { int @@v3@@ ; __int64 @@v4@@ ; unsigned int * @@v5@@ ; unsigned __int64 @@v6@@ ; unsigned __int8 * @@v7@@ ; unsigned int * @@v8@@ ; char * @@v9@@ ; out_column = Number ; put_space ( prefix_indent ) ; fputs_unlocked ( prefix , stdout ) ; @@v3@@ = @@a2@@ - ( out_column + prefix_length ) ; out_column += prefix_length ; put_space ( @@v3@@ ) ; @@v4@@ = * ( _QWORD * ) ( @@a1@@ + Number ) - Number L ; if ( @@a1@@ != @@v4@@ ) { @@v5@@ = ( unsigned int * ) ( @@a1@@ + Number ) ; @@v6@@ = ( Number * ( ( unsigned __int64 ) ( @@v4@@ - ( @@a1@@ + Number ) ) >> Number ) ) & Number ; do { @@v7@@ = ( unsigned __int8 * ) * ( ( _QWORD * ) @@v5@@ - Number ) ; @@v8@@ = @@v5@@ ; @@v5@@ += Number ; put_word_isra_1 ( @@v7@@ , @@v8@@ ) ; put_space ( * ( @@v5@@ - Number ) ) ; } while ( @@v5@@ != ( unsigned int * ) ( @@a1@@ + Number * @@v6@@ + Number ) ) ; @@v4@@ = @@a1@@ + Number * ( Number * @@v6@@ + Number ) ; } put_word_isra_1 ( * ( unsigned __int8 * * ) @@v4@@ , ( unsigned int * ) ( @@v4@@ + Number ) ) ; last_line_length = out_column ; @@v9@@ = stdout -> _IO_write_ptr ; if ( @@v9@@ >= stdout -> _IO_write_end ) { LODWORD ( @@v9@@ ) = __overflow ( stdout , Number ) ; } else { stdout -> _IO_write_ptr = @@v9@@ + Number ; * @@v9@@ = Number ; } return ( int ) @@v9@@ ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
int utmpxname ( const char * @@file@@ ) { return utmpxname ( @@file@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall elide_tail_lines_seekable ( __int64 @@a1@@ , int @@a2@@ , __int64 @@a3@@ , __off_t @@a4@@ , __int64 @@a5@@ ) { int @@v6@@ ; __int64 @@v7@@ ; __off_t @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; size_t @@v13@@ ; __int64 @@v14@@ ; _BYTE * @@v15@@ ; __int64 @@v17@@ ; char * @@v18@@ ; int * @@v19@@ ; __int64 @@v20@@ ; char * @@v21@@ ; int * @@v22@@ ; int @@v23@@ ; __int64 @@v24@@ ; int * @@v25@@ ; char @@v27@@ [ Number ] ; char @@s@@ [ Number ] ; unsigned __int64 @@v29@@ ; @@v6@@ = @@a2@@ ; @@v7@@ = Number ; @@v29@@ = __readfsqword ( Number ) ; if ( ( @@a5@@ - @@a4@@ ) % Number ) @@v7@@ = ( @@a5@@ - @@a4@@ ) % Number ; @@v10@@ = @@a5@@ - @@v7@@ ; @@v11@@ = @@s@@ ; if ( lseek ( @@a2@@ , @@a5@@ - @@v7@@ , Number ) < Number ) goto LABEL_20 ; @@v12@@ = safe_read ( @@v6@@ , @@s@@ , @@v7@@ ) ; @@v13@@ = @@v12@@ ; if ( @@v12@@ == Number ) { LABEL_21 : @@v20@@ = quote ( @@a1@@ ) ; @@v21@@ = dcgettext ( Number L , String , Number ) ; @@v22@@ = __errno_location ( ) ; error ( Number , * @@v22@@ , @@v21@@ , @@v20@@ ) ; return Number L ; } if ( @@v12@@ ) { if ( @@v27@@ [ @@v12@@ + Number ] != Number ) -- @@a3@@ ; goto LABEL_12 ; } LABEL_6 : if ( @@v10@@ == @@a4@@ ) return Number L ; @@v10@@ -= Number ; if ( lseek ( @@v6@@ , @@v10@@ , Number ) < Number ) { @@v11@@ = @@v27@@ ; LABEL_20 : @@v17@@ = offtostr ( @@v10@@ , @@v11@@ ) ; @@v18@@ = dcgettext ( Number L , String , Number ) ; @@v19@@ = __errno_location ( ) ; error ( Number , * @@v19@@ , @@v18@@ , @@a1@@ , @@v17@@ ) ; return Number L ; } @@v14@@ = safe_read ( @@v6@@ , @@s@@ , Number ) ; @@v13@@ = @@v14@@ ; if ( @@v14@@ == Number ) goto LABEL_21 ; if ( @@v14@@ ) { while ( Number ) { @@v15@@ = memrchr ( @@s@@ , Number , @@v13@@ ) ; if ( ! @@v15@@ ) goto LABEL_6 ; @@v13@@ = @@v15@@ - @@s@@ ; if ( ! @@a3@@ ) break ; -- @@a3@@ ; LABEL_12 : if ( ! @@v13@@ ) goto LABEL_6 ; } if ( @@v10@@ <= @@a4@@ ) goto LABEL_16 ; if ( lseek ( @@v6@@ , @@a4@@ , Number ) >= Number ) { @@v23@@ = copy_fd ( @@v6@@ , stdout , @@v10@@ - @@a4@@ ) ; if ( @@v23@@ ) { diagnose_copy_fd_failure ( @@v23@@ , @@a1@@ ) ; return Number L ; } LABEL_16 : fwrite_unlocked ( @@s@@ , Number , @@v13@@ + Number , stdout ) ; return Number L ; } @@v24@@ = quote ( @@a1@@ ) ; @@v25@@ = __errno_location ( ) ; error ( Number , * @@v25@@ , String , @@v24@@ ) ; return Number L ; } return Number L ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; char * @@v7@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String String String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = setlocale ( Number , Number L ) ; if ( @@v7@@ ) { if ( strncmp ( @@v7@@ , String , Number ) ) { last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 __fastcall copy_fd ( int @@fd@@ , FILE * @@stream@@ , size_t @@nbytes@@ ) { size_t @@v3@@ ; size_t @@v4@@ ; unsigned __int64 @@v5@@ ; _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; if ( ! @@nbytes@@ ) return Number L ; @@v3@@ = @@nbytes@@ ; while ( Number ) { @@v4@@ = Number ; if ( @@v3@@ <= Number ) @@v4@@ = @@v3@@ ; @@v5@@ = safe_read ( @@fd@@ , @@v7@@ , @@v4@@ ) ; if ( @@v5@@ == Number ) return Number L ; @@v3@@ -= @@v5@@ ; if ( ! @@v5@@ ) { if ( @@v3@@ ) break ; } if ( @@v5@@ > fwrite_unlocked ( @@v7@@ , Number , @@v5@@ , @@stream@@ ) ) return Number L ; if ( ! @@v3@@ ) return Number L ; } return Number L ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
__int64 __fastcall string_to_integer ( char @@a1@@ , char * @@a2@@ ) { int @@v2@@ ; char * @@v4@@ ; char * @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; @@v2@@ = xstrtoumax ( @@a2@@ ) ; if ( @@v2@@ == Number ) { if ( @@a1@@ ) @@v4@@ = dcgettext ( Number L , String , Number ) ; else @@v4@@ = dcgettext ( Number L , String , Number ) ; @@v5@@ = dcgettext ( Number L , String , Number ) ; error ( Number , Number , @@v5@@ , @@a2@@ , @@v4@@ ) ; } else if ( ! @@v2@@ ) { return @@v7@@ ; } if ( @@a1@@ ) @@v6@@ = dcgettext ( Number L , String , Number ) ; else @@v6@@ = dcgettext ( Number L , String , Number ) ; error ( Number , Number , String , @@a2@@ , @@v6@@ ) ; return @@v7@@ ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_213250 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_213230 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_213240 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
__int64 __fastcall head_lines ( __int64 @@a1@@ , int @@a2@@ , __int64 @@a3@@ ) { __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; size_t @@v5@@ ; char * @@v6@@ ; int * @@v7@@ ; __int64 @@v9@@ ; char * @@v10@@ ; int * @@v11@@ ; int @@v12@@ ; char * @@v13@@ ; __int64 @@v14@@ ; struct stat @@v15@@ ; char @@ptr@@ [ Number ] ; unsigned __int64 @@v17@@ ; @@v17@@ = __readfsqword ( Number ) ; if ( ! @@a3@@ ) return Number L ; @@v3@@ = @@a3@@ ; LABEL_3 : while ( Number ) { @@v4@@ = safe_read ( @@a2@@ , @@ptr@@ , Number ) ; if ( @@v4@@ != Number ) { if ( @@v4@@ ) { @@v5@@ = Number L ; while ( * ( ( _BYTE * ) & @@v15@@ . __unused [ Number ] + ++ @@v5@@ + Number ) != Number || -- @@v3@@ ) { if ( @@v4@@ == @@v5@@ ) { if ( @@v4@@ <= fwrite_unlocked ( @@ptr@@ , Number , @@v4@@ , stdout ) ) goto LABEL_3 ; goto LABEL_11 ; } } if ( lseek ( @@a2@@ , @@v5@@ - @@v4@@ , Number ) < Number ) { @@v12@@ = * __errno_location ( ) ; if ( __fxstat ( Number , @@a2@@ , & @@v15@@ ) || ( @@v15@@ . st_mode & Number ) == Number ) { @@v14@@ = quote ( @@a1@@ ) ; @@v13@@ = dcgettext ( Number L , String , Number ) ; error ( Number , @@v12@@ , @@v13@@ , @@v14@@ ) ; } } if ( fwrite_unlocked ( @@ptr@@ , Number , @@v5@@ , stdout ) >= @@v5@@ ) return Number L ; LABEL_11 : @@v6@@ = dcgettext ( Number L , String , Number ) ; @@v7@@ = __errno_location ( ) ; error ( Number , * @@v7@@ , @@v6@@ ) ; if ( @@v3@@ ) continue ; } return Number L ; } break ; } @@v9@@ = quote ( @@a1@@ ) ; @@v10@@ = dcgettext ( Number L , String , Number ) ; @@v11@@ = __errno_location ( ) ; error ( Number , * @@v11@@ , @@v10@@ , @@v9@@ ) ; return Number L ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall full_read ( int @@fd@@ , void * @@buf@@ , size_t @@nbytes@@ ) { size_t @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; if ( ! @@nbytes@@ ) return Number L ; @@v4@@ = @@nbytes@@ ; @@v5@@ = Number L ; do { @@v6@@ = safe_read ( @@fd@@ , @@buf@@ , @@v4@@ ) ; if ( @@v6@@ == Number ) break ; if ( ! @@v6@@ ) { * __errno_location ( ) = Number ; return @@v5@@ ; } @@v5@@ += @@v6@@ ; @@buf@@ = ( char * ) @@buf@@ + @@v6@@ ; @@v4@@ -= @@v6@@ ; } while ( @@v4@@ ) ; return @@v5@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
int __fxstat ( int @@ver@@ , int @@fildes@@ , struct stat * @@stat_buf@@ ) { return _fxstat ( @@ver@@ , @@fildes@@ , @@stat_buf@@ ) ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_208210 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2081F0 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_208200 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
__int64 __fastcall offtostr ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; __int64 @@result@@ ; int @@v4@@ ; bool @@v5@@ ; @@v2@@ = @@a2@@ + Number ; * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; if ( @@a1@@ < Number ) { while ( Number ) { @@v4@@ = Number * ( @@a1@@ / Number ) + Number - @@a1@@ ; @@v5@@ = ( __int64 ) ( ( unsigned __int128 ) ( Number * ( __int128 ) @@a1@@ ) >> Number ) >> Number == @@a1@@ >> Number ; @@a1@@ /= Number L ; * ( _BYTE * ) ( @@v2@@ - Number ) = @@v4@@ ; if ( @@v5@@ ) break ; -- @@v2@@ ; } * ( _BYTE * ) ( @@v2@@ - Number ) = Number ; @@result@@ = @@v2@@ - Number ; } else { do { * ( _BYTE * ) -- @@v2@@ = @@a1@@ % Number + Number ; @@a1@@ /= Number ; } while ( @@a1@@ ) ; @@result@@ = @@v2@@ ; } return @@result@@ ; }
void __fastcall diagnose_copy_fd_failure ( int @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; const char * @@v3@@ ; __int64 @@v4@@ ; char * @@v5@@ ; int * @@v6@@ ; switch ( @@a1@@ ) { case Number : @@v4@@ = quote ( @@a2@@ ) ; @@v3@@ = String ; break ; case Number : @@v2@@ = quote ( @@a2@@ ) ; @@v3@@ = String ; @@v4@@ = @@v2@@ ; break ; case Number : @@v4@@ = quote ( @@a2@@ ) ; @@v3@@ = String ; break ; default : abort ( ) ; } @@v5@@ = dcgettext ( Number L , @@v3@@ , Number ) ; @@v6@@ = __errno_location ( ) ; error ( Number , * @@v6@@ , @@v5@@ , @@v4@@ ) ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
unsigned __int64 __fastcall print_factors_single ( unsigned __int64 @@a1@@ ) { unsigned __int8 * @@v1@@ ; unsigned __int64 @@v2@@ ; unsigned __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; unsigned __int64 @@v6@@ ; char * @@v7@@ ; __int64 * @@v8@@ ; __int64 @@v9@@ ; char * @@v10@@ ; __int64 @@v12@@ [ Number ] ; char @@v13@@ [ Number ] ; unsigned __int64 @@v14@@ ; @@v14@@ = __readfsqword ( Number ) ; if ( @@a1@@ <= Number ) { umaxtostr ( @@a1@@ , @@v13@@ ) ; __printf_chk ( ) ; } else { @@v1@@ = ( unsigned __int8 * ) & wheel_tab ; @@v2@@ = @@a1@@ ; @@v3@@ = Number L ; @@v4@@ = Number L ; do { @@v5@@ = @@v2@@ / @@v4@@ ; if ( @@v2@@ / @@v4@@ * @@v4@@ == @@v2@@ ) { if ( @@v3@@ > Number ) LABEL_25 : __assert_fail ( String , String , Number , String ) ; while ( Number ) { @@v12@@ [ @@v3@@ ++ ] = @@v4@@ ; @@v6@@ = @@v5@@ / @@v4@@ ; if ( @@v5@@ / @@v4@@ * @@v4@@ != @@v5@@ ) break ; @@v5@@ /= @@v4@@ ; if ( @@v3@@ == Number ) goto LABEL_25 ; } @@v2@@ = @@v5@@ ; } else { @@v6@@ = @@v2@@ / @@v4@@ ; } @@v7@@ = ( char * ) ( @@v1@@ + Number ) ; @@v4@@ += * @@v1@@ ; if ( @@v1@@ + Number == ( unsigned __int8 * ) ( ( char * ) & wheel_tab + Number ) ) @@v7@@ = ( char * ) & wheel_tab + Number ; @@v1@@ = ( unsigned __int8 * ) @@v7@@ ; } while ( @@v4@@ <= @@v6@@ ) ; if ( @@v2@@ != Number ) { if ( @@v3@@ > Number ) __assert_fail ( String , String , Number , String ) ; @@v12@@ [ @@v3@@ ++ ] = @@v2@@ ; umaxtostr ( @@a1@@ , @@v13@@ ) ; __printf_chk ( ) ; goto LABEL_15 ; } umaxtostr ( @@a1@@ , @@v13@@ ) ; __printf_chk ( ) ; if ( @@v3@@ ) { LABEL_15 : @@v8@@ = @@v12@@ ; do { @@v9@@ = * @@v8@@ ++ ; umaxtostr ( @@v9@@ , @@v13@@ ) ; __printf_chk ( ) ; } while ( & @@v12@@ [ @@v3@@ ] != @@v8@@ ) ; goto LABEL_17 ; } } LABEL_17 : @@v10@@ = stdout -> _IO_write_ptr ; if ( @@v10@@ >= stdout -> _IO_write_end ) { __overflow ( stdout , Number ) ; } else { stdout -> _IO_write_ptr = @@v10@@ + Number ; * @@v10@@ = Number ; } return __readfsqword ( Number ) ^ @@v14@@ ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; FILE * @@v11@@ ; char * @@v12@@ ; FILE * @@v13@@ ; char * @@v14@@ ; FILE * @@v15@@ ; char * @@v16@@ ; char * @@v17@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String String String String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String String String String String String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = stdout ; @@v10@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; @@v11@@ = stdout ; @@v12@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v12@@ , @@v11@@ ) ; @@v13@@ = stdout ; @@v14@@ = dcgettext ( Number L , String String String String , Number ) ; fputs_unlocked ( @@v14@@ , @@v13@@ ) ; last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v15@@ = stdout ; @@v16@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v16@@ , @@v15@@ ) ; @@v17@@ = setlocale ( Number , Number L ) ; if ( @@v17@@ ) { if ( strncmp ( @@v17@@ , String , Number ) ) { last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
int __cdecl __noreturn main ( int @@argc@@ , const char * * @@argv@@ , const char * * envp ) { __int64 @@v3@@ ; char * @@v4@@ ; set_program_name ( * @@argv@@ ) ; setlocale ( Number , String ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; parse_long_options ( @@argc@@ , ( _DWORD ) @@argv@@ , ( unsigned int ) String , ( unsigned int ) & unk_4050 , ( _DWORD ) Version , ( unsigned int ) usage , String , String , Number L ) ; if ( getopt_long ( @@argc@@ , ( char * const * ) @@argv@@ , String , Number L , Number L ) == Number ) { if ( @@argc@@ == optind ) { users ( String , Number L ) ; LABEL_5 : exit ( Number ) ; } if ( @@argc@@ - optind == Number ) { users ( @@argv@@ [ optind ] , Number L ) ; goto LABEL_5 ; } @@v3@@ = quote ( @@argv@@ [ optind + Number ] ) ; @@v4@@ = dcgettext ( Number L , String , Number ) ; error ( Number , Number , @@v4@@ , @@v3@@ ) ; } usage ( Number ) ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_208210 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2081F0 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_208200 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_2071F0 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2071D0 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2071E0 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall umaxtostr ( unsigned __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; @@v2@@ = @@a2@@ + Number ; * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; do { * ( _BYTE * ) -- @@v2@@ = @@a1@@ % Number + Number ; @@a1@@ /= Number ; } while ( @@a1@@ ) ; return @@v2@@ ; }
void * __fastcall xzalloc ( size_t @@n@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@n@@ ) ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) _frame_dummy_init_array_entry [ @@i@@ ] ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
ssize_t __fastcall safe_read ( int @@fd@@ , void * @@buf@@ , size_t @@nbytes@@ ) { ssize_t @@v4@@ ; int @@v5@@ ; while ( Number ) { @@v4@@ = read ( @@fd@@ , @@buf@@ , @@nbytes@@ ) ; if ( @@v4@@ >= Number ) break ; @@v5@@ = * __errno_location ( ) ; if ( @@v5@@ != Number ) { if ( @@nbytes@@ <= Number || @@v5@@ != Number ) return @@v4@@ ; @@nbytes@@ = Number L ; } } return @@v4@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
int __fastcall userid_compare ( const void * @@a1@@ , const void * @@a2@@ ) { return strcmp ( * ( const char * * ) @@a1@@ , * ( const char * * ) @@a2@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_2061F0 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061D0 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061E0 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
char * __fastcall extract_trimmed_name ( __int64 @@a1@@ ) { char * @@v1@@ ; char * @@v2@@ ; @@v1@@ = ( char * ) xmalloc ( Number L ) ; strncpy ( @@v1@@ , ( const char * ) ( @@a1@@ + Number ) , Number ) ; @@v1@@ [ Number ] = Number ; @@v2@@ = & @@v1@@ [ strlen ( @@v1@@ ) ] ; if ( @@v1@@ < @@v2@@ ) { do { if ( * ( @@v2@@ - Number ) != Number ) break ; * -- @@v2@@ = Number ; } while ( @@v1@@ != @@v2@@ ) ; } return @@v1@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
unsigned __int64 __fastcall users ( const char * @@a1@@ , unsigned int @@a2@@ ) { int * @@v2@@ ; unsigned __int64 @@v3@@ ; char * @@v4@@ ; size_t @@v5@@ ; __int64 @@v6@@ ; _QWORD * @@v7@@ ; _QWORD * @@v8@@ ; size_t @@v9@@ ; size_t @@i@@ ; char * @@v11@@ ; void * * @@v12@@ ; void * * @@v13@@ ; void * @@v14@@ ; unsigned __int64 @@v16@@ ; void * @@ptr@@ ; unsigned __int64 @@v18@@ ; @@v18@@ = __readfsqword ( Number ) ; if ( ( unsigned int ) read_utmp ( @@a1@@ , & @@v16@@ , & @@ptr@@ , @@a2@@ ) ) { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@a1@@ ) ; } @@v3@@ = @@v16@@ ; @@v4@@ = ( char * ) @@ptr@@ ; if ( ! is_mul_ok ( @@v16@@ , Number ) ) xalloc_die ( ) ; @@v5@@ = Number L ; @@v6@@ = @@v16@@ - Number ; @@v7@@ = ( _QWORD * ) xmalloc ( Number * @@v16@@ ) ; @@v8@@ = @@v7@@ ; if ( @@v3@@ ) { do { if ( @@v4@@ [ Number ] && * ( _WORD * ) @@v4@@ == Number ) @@v8@@ [ @@v5@@ ++ ] = extract_trimmed_name ( @@v4@@ ) ; -- @@v6@@ ; @@v4@@ += Number ; } while ( @@v6@@ != Number ) ; qsort ( @@v8@@ , @@v5@@ , Number , userid_compare ) ; if ( @@v5@@ ) { @@v9@@ = @@v5@@ - Number ; for ( @@i@@ = Number L ; @@i@@ != @@v5@@ ; ++ @@i@@ ) { fputs_unlocked ( ( const char * ) @@v8@@ [ @@i@@ ] , stdout ) ; @@v11@@ = stdout -> _IO_write_ptr ; if ( @@v11@@ >= stdout -> _IO_write_end ) { __overflow ( stdout , @@i@@ < @@v9@@ ? Number : Number ) ; } else { stdout -> _IO_write_ptr = @@v11@@ + Number ; * @@v11@@ = @@i@@ < @@v9@@ ? Number : Number ; } } @@v12@@ = ( void * * ) & @@v8@@ [ @@i@@ ] ; @@v13@@ = ( void * * ) @@v8@@ ; do { @@v14@@ = * @@v13@@ ++ ; free ( @@v14@@ ) ; } while ( @@v13@@ != @@v12@@ ) ; } } else { qsort ( @@v7@@ , Number L , Number , userid_compare ) ; } free ( @@v8@@ ) ; free ( @@ptr@@ ) ; return __readfsqword ( Number ) ^ @@v18@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_2061F0 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061D0 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_2061E0 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
int __cdecl __noreturn main ( int @@argc@@ , const char * * @@argv@@ , const char * * envp ) { const char * @@v4@@ ; int @@v5@@ ; __int64 @@v6@@ ; int @@v7@@ ; char @@v8@@ [ Number ] ; void * @@ptr@@ ; unsigned __int64 @@v10@@ ; @@v4@@ = * @@argv@@ ; @@v10@@ = __readfsqword ( Number ) ; set_program_name ( @@v4@@ ) ; setlocale ( Number , String ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; while ( Number ) { @@v5@@ = getopt_long ( @@argc@@ , ( char * const * ) @@argv@@ , String , & long_options , Number L ) ; if ( @@v5@@ == Number ) break ; if ( @@v5@@ == Number ) usage ( Number ) ; if ( @@v5@@ != Number ) { if ( @@v5@@ != Number ) usage ( Number ) ; version_etc ( ( _DWORD ) stdout , ( unsigned int ) String , ( unsigned int ) & unk_4448 , ( _DWORD ) Version , ( unsigned int ) String , Number , @@v8@@ [ Number ] ) ; exit ( Number ) ; } } @@v6@@ = optind ; if ( optind >= @@argc@@ ) { @@v7@@ = Number ; init_tokenbuffer ( @@v8@@ ) ; while ( readtoken ( stdin ) != Number ) @@v7@@ &= print_factors ( @@ptr@@ ) ; free ( @@ptr@@ ) ; } else { LOBYTE ( @@v7@@ ) = Number ; do { if ( ! ( unsigned __int8 ) print_factors ( @@argv@@ [ @@v6@@ ] ) ) LOBYTE ( @@v7@@ ) = Number ; ++ @@v6@@ ; } while ( @@argc@@ > ( int ) @@v6@@ ) ; } exit ( ( unsigned __int8 ) @@v7@@ ^ Number ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
__int64 __fastcall print_factors ( char * @@a1@@ ) { int @@v1@@ ; const char * @@v2@@ ; __int64 @@v3@@ ; char * @@v4@@ ; __int64 @@result@@ ; unsigned __int64 @@v6@@ ; @@v1@@ = xstrtoumax ( @@a1@@ ) ; if ( @@v1@@ ) { if ( @@v1@@ == Number ) { @@v3@@ = quote ( @@a1@@ , Number L ) ; @@v2@@ = String ; } else { @@v2@@ = String ; @@v3@@ = quote ( @@a1@@ , Number L ) ; } @@v4@@ = dcgettext ( Number L , @@v2@@ , Number ) ; error ( Number , Number , @@v4@@ , @@v3@@ ) ; @@result@@ = Number L ; } else { dcgettext ( Number L , String , Number ) ; print_factors_single ( @@v6@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; char * @@v9@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String String String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = setlocale ( Number , Number L ) ; if ( @@v9@@ ) { if ( strncmp ( @@v9@@ , String , Number ) ) { last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_207210 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2071F0 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_207200 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
unsigned __int64 __fastcall readtokens ( _IO_FILE * @@a1@@ , _BYTE * @@a2@@ , _BYTE * @@a3@@ , unsigned __int64 @@a4@@ , __int64 * @@a5@@ , __int64 * @@a6@@ ) { unsigned __int64 @@v6@@ ; unsigned __int128 @@v7@@ ; unsigned __int64 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 * @@v10@@ ; void * * @@v11@@ ; void * @@v12@@ ; void * @@v13@@ ; unsigned __int64 @@v14@@ ; __int64 @@v15@@ ; void * @@v16@@ ; __int64 @@v18@@ ; _IO_FILE * @@v19@@ ; __int64 @@v24@@ ; void * @@src@@ ; unsigned __int64 @@v26@@ ; @@v6@@ = ( unsigned __int64 ) ( @@a2@@ + Number ) ; @@v26@@ = __readfsqword ( Number ) ; if ( ! @@a2@@ ) @@v6@@ = Number L ; @@v19@@ = @@a1@@ ; @@v7@@ = @@v6@@ * ( unsigned __int128 ) Number ; if ( ! is_mul_ok ( @@v6@@ , Number ) ) LABEL_19 : xalloc_die ( @@a1@@ , @@a2@@ , * ( ( _QWORD * ) & @@v7@@ + Number ) , @@a4@@ ) ; @@v8@@ = Number L ; @@v9@@ = xmalloc ( Number * @@v6@@ ) ; @@v18@@ = xmalloc ( Number * @@v6@@ ) ; @@v24@@ = Number L ; @@src@@ = Number L ; while ( Number ) { @@a2@@ = @@a3@@ ; @@a1@@ = @@v19@@ ; @@v14@@ = readtoken ( @@v19@@ , @@a3@@ , @@a4@@ , & @@v24@@ ) ; if ( @@v8@@ < @@v6@@ ) goto LABEL_5 ; if ( @@v9@@ ) { if ( @@v6@@ > Number ) goto LABEL_19 ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v15@@ = Number L ; @@v6@@ = Number L ; goto LABEL_12 ; } @@v15@@ = Number * @@v6@@ ; LABEL_12 : @@a1@@ = ( _IO_FILE * ) @@v9@@ ; @@a2@@ = ( _BYTE * ) @@v15@@ ; @@v9@@ = xrealloc ( @@v9@@ , @@v15@@ ) ; @@v7@@ = @@v6@@ * ( unsigned __int128 ) Number ; if ( ! is_mul_ok ( @@v6@@ , Number ) ) goto LABEL_19 ; @@v18@@ = xrealloc ( @@v18@@ , @@v15@@ ) ; LABEL_5 : @@v10@@ = ( unsigned __int64 * ) ( @@v18@@ + Number * @@v8@@ ) ; @@v11@@ = ( void * * ) ( @@v9@@ + Number * @@v8@@ ) ; if ( @@v14@@ == Number ) break ; ++ @@v8@@ ; @@v12@@ = ( void * ) xmalloc ( @@v14@@ + Number ) ; @@v13@@ = @@src@@ ; * @@v10@@ = @@v14@@ ; * @@v11@@ = memcpy ( @@v12@@ , @@v13@@ , @@v14@@ + Number ) ; } * @@v11@@ = Number L ; @@v16@@ = @@src@@ ; * @@v10@@ = Number L ; free ( @@v16@@ ) ; * @@a5@@ = @@v9@@ ; if ( @@a6@@ ) * @@a6@@ = @@v18@@ ; return @@v8@@ ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
void __fastcall init_tokenbuffer ( _QWORD * @@a1@@ ) { * @@a1@@ = Number L ; @@a1@@ [ Number ] = Number L ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@result@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ , @@v4@@ ) ; } return @@result@@ ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
__int64 __fastcall umaxtostr ( unsigned __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; @@v2@@ = @@a2@@ + Number ; * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; do { * ( _BYTE * ) -- @@v2@@ = @@a1@@ % Number + Number ; @@a1@@ /= Number ; } while ( @@a1@@ ) ; return @@v2@@ ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_2071F0 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2071D0 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_2071E0 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ , @@v4@@ ) ; } return @@result@@ ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ , __int64 a3 , __int64 @@a4@@ ) { size_t @@v4@@ ; size_t @@v5@@ ; void * @@result@@ ; @@v4@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v4@@ > Number ) xalloc_die ( @@a1@@ , @@a2@@ , Number , @@a4@@ ) ; @@v5@@ = ( ( @@v4@@ + Number ) >> Number ) + @@v4@@ ; * @@a2@@ = @@v5@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v5@@ ) ; } else { if ( ! @@v4@@ ) @@v4@@ = Number L ; * @@a2@@ = @@v4@@ ; @@result@@ = xrealloc ( Number L , @@v4@@ ) ; } return @@result@@ ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
FILE * __fastcall freopen_safer ( const char * @@a1@@ , const char * @@a2@@ , FILE * @@a3@@ ) { int @@v4@@ ; int * @@v5@@ ; char @@v6@@ ; char @@v7@@ ; char @@v8@@ ; FILE * @@v9@@ ; int @@v10@@ ; @@v4@@ = fileno ( @@a3@@ ) ; @@v5@@ = __errno_location ( ) ; if ( @@v4@@ == Number ) { @@v6@@ = Number ; @@v7@@ = Number ; } else { if ( @@v4@@ == Number ) { @@v6@@ = Number ; } else { if ( ! @@v4@@ ) { @@v6@@ = Number ; @@v7@@ = Number ; @@v8@@ = Number ; LABEL_11 : @@v9@@ = freopen ( @@a1@@ , @@a2@@ , @@a3@@ ) ; goto LABEL_12 ; } @@v6@@ = dup2 ( Number , Number ) != Number ; } @@v7@@ = dup2 ( Number , Number ) != Number ; } if ( ! dup2 ( Number , Number ) ) { @@v8@@ = Number ; if ( ! @@v7@@ ) goto LABEL_9 ; goto LABEL_20 ; } @@v8@@ = protect_fd ( Number ) ; if ( ! @@v8@@ ) { @@v8@@ = Number ; @@v9@@ = Number L ; LABEL_12 : @@v10@@ = * @@v5@@ ; if ( ! @@v6@@ ) goto LABEL_13 ; goto LABEL_26 ; } if ( @@v7@@ ) { LABEL_20 : @@v7@@ = protect_fd ( Number ) ; if ( ! @@v7@@ ) { @@v9@@ = Number L ; @@v10@@ = * @@v5@@ ; if ( @@v6@@ ) close ( Number ) ; LABEL_23 : close ( Number ) ; if ( ! @@v8@@ ) goto LABEL_15 ; goto LABEL_24 ; } } LABEL_9 : if ( ! @@v6@@ ) goto LABEL_11 ; @@v6@@ = protect_fd ( Number ) ; if ( @@v6@@ ) goto LABEL_11 ; @@v10@@ = * @@v5@@ ; @@v9@@ = Number L ; LABEL_26 : close ( Number ) ; LABEL_13 : if ( @@v7@@ ) goto LABEL_23 ; if ( ! @@v8@@ ) goto LABEL_15 ; LABEL_24 : close ( Number ) ; LABEL_15 : if ( ! @@v9@@ ) * @@v5@@ = @@v10@@ ; return @@v9@@ ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ , @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ , @@v4@@ ) ; return @@result@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
int puts ( const char * @@s@@ ) { return puts ( @@s@@ ) ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_207230 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_207210 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_207220 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ , __int64 a3 , __int64 @@a4@@ ) { size_t @@v4@@ ; size_t @@v5@@ ; void * @@result@@ ; @@v4@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v4@@ > Number ) xalloc_die ( @@a1@@ , @@a2@@ , Number , @@a4@@ ) ; @@v5@@ = ( ( @@v4@@ + Number ) >> Number ) + @@v4@@ ; * @@a2@@ = @@v5@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v5@@ ) ; } else { if ( ! @@v4@@ ) @@v4@@ = Number L ; * @@a2@@ = @@v4@@ ; @@result@@ = xrealloc ( Number L , @@v4@@ ) ; } return @@result@@ ; }
int __cdecl __noreturn main ( int @@argc@@ , const char * * @@argv@@ , const char * * envp ) { __int64 @@v3@@ ; char * @@v4@@ ; char * @@v5@@ ; char * @@v6@@ ; set_program_name ( * @@argv@@ ) ; setlocale ( Number , String ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; parse_long_options ( @@argc@@ , ( _DWORD ) @@argv@@ , ( unsigned int ) String , ( unsigned int ) & unk_39E2 , ( _DWORD ) Version , ( unsigned int ) usage , String , Number L ) ; if ( getopt_long ( @@argc@@ , ( char * const * ) @@argv@@ , String , Number L , Number L ) == Number ) { if ( optind >= @@argc@@ ) { @@v5@@ = getlogin ( ) ; if ( @@v5@@ ) { puts ( @@v5@@ ) ; exit ( Number ) ; } @@v6@@ = dcgettext ( Number L , String , Number ) ; error ( Number , Number , @@v6@@ ) ; exit ( Number ) ; } @@v3@@ = quote ( @@argv@@ [ optind ] ) ; @@v4@@ = dcgettext ( Number L , String , Number ) ; error ( Number , Number , @@v4@@ , @@v3@@ ) ; } usage ( Number ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; char * @@v9@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = setlocale ( Number , Number L ) ; if ( @@v9@@ ) { if ( strncmp ( @@v9@@ , String , Number ) ) { last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
int endmntent ( FILE * @@stream@@ ) { return endmntent ( @@stream@@ ) ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
int __xstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _xstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
int iconv_close ( iconv_t @@cd@@ ) { return iconv_close ( @@cd@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_2061F0 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061D0 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061E0 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; FILE * @@v11@@ ; char * @@v12@@ ; FILE * @@v13@@ ; char * @@v14@@ ; FILE * @@v15@@ ; char * @@v16@@ ; FILE * @@v17@@ ; char * @@v18@@ ; char * @@v19@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String String String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = stdout ; @@v10@@ = dcgettext ( Number L , String String String String String String , Number ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; @@v11@@ = stdout ; @@v12@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v12@@ , @@v11@@ ) ; @@v13@@ = stdout ; @@v14@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v14@@ , @@v13@@ ) ; dcgettext ( Number L , String String String String , Number ) ; __printf_chk ( ) ; @@v15@@ = stdout ; @@v16@@ = dcgettext ( Number L , String String String , Number ) ; fputs_unlocked ( @@v16@@ , @@v15@@ ) ; last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v17@@ = stdout ; @@v18@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v18@@ , @@v17@@ ) ; @@v19@@ = setlocale ( Number , Number L ) ; if ( @@v19@@ ) { if ( strncmp ( @@v19@@ , String , Number ) ) { last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_2061F0 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061D0 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_2061E0 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
__int64 __fastcall human_options ( char * @@nptr@@ , int * @@a2@@ , __int64 * @@a3@@ ) { char * @@v4@@ ; int @@v5@@ ; int @@v6@@ ; int @@v7@@ ; __int64 @@result@@ ; __int64 @@v9@@ ; char * @@v10@@ ; @@v4@@ = @@nptr@@ ; if ( @@nptr@@ || ( @@v4@@ = getenv ( String ) ) != Number L || ( @@v4@@ = getenv ( String ) ) != Number L ) { @@v5@@ = Number ; if ( * @@v4@@ == Number ) { ++ @@v4@@ ; @@v5@@ = Number ; } @@v6@@ = argmatch ( @@v4@@ , block_size_args , block_size_opts , Number L ) ; if ( @@v6@@ >= Number ) { * @@a3@@ = Number L ; @@v7@@ = block_size_opts [ @@v6@@ ] | @@v5@@ ; @@result@@ = Number L ; * @@a2@@ = @@v7@@ ; return @@result@@ ; } @@result@@ = xstrtoumax ( @@v4@@ ) ; if ( ( _DWORD ) @@result@@ ) { @@v9@@ = * @@a3@@ ; * @@a2@@ = Number ; LABEL_15 : if ( ! @@v9@@ ) { * @@a3@@ = getenv ( String ) == Number L ? Number L : Number L ; @@result@@ = Number L ; } return @@result@@ ; } if ( ( unsigned __int8 ) ( * @@v4@@ - Number ) > Number ) { if ( @@v4@@ != @@v10@@ ) { while ( ( unsigned __int8 ) ( * ++ @@v4@@ - Number ) > Number ) { if ( @@v4@@ == @@v10@@ ) goto LABEL_22 ; } goto LABEL_13 ; } LABEL_22 : if ( * ( @@v10@@ - Number ) == Number ) { @@v5@@ |= Number ; if ( * ( @@v10@@ - Number ) != Number ) goto LABEL_13 ; } else { LOBYTE ( @@v5@@ ) = @@v5@@ | Number ; } @@v5@@ |= Number ; } LABEL_13 : @@v9@@ = * @@a3@@ ; * @@a2@@ = @@v5@@ ; goto LABEL_15 ; } if ( getenv ( String ) ) * @@a3@@ = Number L ; else * @@a3@@ = Number L ; @@result@@ = Number L ; * @@a2@@ = Number ; return @@result@@ ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
int setuid ( __uid_t @@uid@@ ) { return setuid ( @@uid@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_210290 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_210270 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_210280 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
struct passwd * getpwuid ( __uid_t @@uid@@ ) { return getpwuid ( @@uid@@ ) ; }
struct passwd * getpwnam ( const char * @@name@@ ) { return getpwnam ( @@name@@ ) ; }
int setgid ( __gid_t @@gid@@ ) { return setgid ( @@gid@@ ) ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; char * @@v11@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String String String String String String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v9@@ = stdout ; @@v10@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; @@v11@@ = setlocale ( Number , Number L ) ; if ( @@v11@@ ) { if ( strncmp ( @@v11@@ , String , Number ) ) { last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void __fastcall free_cwd ( __int64 @@a1@@ ) { int @@v2@@ ; @@v2@@ = * ( _DWORD * ) @@a1@@ ; if ( @@v2@@ >= Number ) close ( @@v2@@ ) ; free ( * ( void * * ) ( @@a1@@ + Number ) ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; char * @@v7@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String String String String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = setlocale ( Number , Number L ) ; if ( @@v7@@ ) { if ( strncmp ( @@v7@@ , String , Number ) ) { last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
__int64 __fastcall protect_fd ( int @@a1@@ ) { unsigned int @@v1@@ ; int @@v2@@ ; @@v1@@ = Number ; @@v2@@ = open ( String , Number ) ; if ( @@a1@@ != @@v2@@ ) { @@v1@@ = Number ; if ( @@v2@@ >= Number ) { close ( @@v2@@ ) ; * __errno_location ( ) = Number ; } } return @@v1@@ ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
void __fastcall __noreturn xstrtol_fatal ( unsigned int @@a1@@ , int @@a2@@ , char @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ ) { int @@v7@@ ; const char * @@v8@@ ; char * @@v9@@ ; char * @@v10@@ ; char * @@v11@@ ; char @@v12@@ [ Number ] ; unsigned __int64 @@v13@@ ; @@v13@@ = __readfsqword ( Number ) ; @@v7@@ = exit_failure ; if ( @@a1@@ > Number ) { @@v8@@ = String ; if ( @@a1@@ != Number ) goto LABEL_7 ; } else if ( @@a1@@ >= Number ) { @@v8@@ = String ; } else { @@v8@@ = String ; if ( @@a1@@ != Number ) goto LABEL_7 ; } if ( @@a2@@ < Number ) { @@v12@@ [ Number ] = @@a3@@ ; @@v12@@ [ Number ] = Number ; @@v10@@ = @@v12@@ ; @@v9@@ = & asc_D158 [ - @@a2@@ ] ; } else { @@v9@@ = String ; @@v10@@ = * ( char * * ) ( @@a4@@ + Number L * @@a2@@ ) ; } @@v11@@ = dcgettext ( Number L , @@v8@@ , Number ) ; error ( @@v7@@ , Number , @@v11@@ , @@v9@@ , @@v10@@ , @@a5@@ ) ; LABEL_7 : abort ( ) ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall _xargmatch_internal ( __int64 @@a1@@ , char * @@a2@@ , const char * * @@a3@@ , char * @@a4@@ , size_t @@a5@@ , void ( * @@a6@@ ) ( void ) ) { __int64 @@result@@ ; @@result@@ = argmatch ( @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; if ( @@result@@ < Number ) { argmatch_invalid ( @@a1@@ , ( wchar_t * ) @@a2@@ , @@result@@ ) ; argmatch_valid ( @@a3@@ , @@a4@@ , @@a5@@ ) ; @@a6@@ ( ) ; @@result@@ = Number ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_207210 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2071F0 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_207200 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
struct passwd * getpwuid ( __uid_t @@uid@@ ) { return getpwuid ( @@uid@@ ) ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
struct group * getgrgid ( __gid_t @@gid@@ ) { return getgrgid ( @@gid@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
int puts ( const char * @@s@@ ) { return puts ( @@s@@ ) ; }
int dirfd ( DIR * @@dirp@@ ) { return dirfd ( @@dirp@@ ) ; }
int fileno ( FILE * @@stream@@ ) { return fileno ( @@stream@@ ) ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
struct dirent * readdir ( DIR * @@dirp@@ ) { return readdir ( @@dirp@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@result@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ , @@v4@@ ) ; } return @@result@@ ; }
int fchdir ( int @@fd@@ ) { return fchdir ( @@fd@@ ) ; }
__int64 __fastcall scan_zeros ( _QWORD * @@a1@@ ) { if ( ! @@a1@@ [ Number ] && * @@a1@@ ) { if ( head ) * ( _QWORD * ) ( zeros + Number ) = @@a1@@ ; else head = ( __int64 ) @@a1@@ ; zeros = ( __int64 ) @@a1@@ ; } return Number L ; }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
void * __fastcall xzalloc ( size_t @@n@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@n@@ ) ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
void free ( void * @@ptr@@ ) { __imp_free ( @@ptr@@ ) ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ , @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
__int64 __fastcall new_item ( void * @@src@@ ) { void * @@v1@@ ; __int64 @@v2@@ ; __int64 @@result@@ ; @@v1@@ = @@src@@ ; @@v2@@ = xmalloc ( Number L ) ; if ( @@src@@ ) @@v1@@ = ( void * ) xstrdup ( @@src@@ ) ; * ( _QWORD * ) @@v2@@ = @@v1@@ ; * ( _QWORD * ) ( @@v2@@ + Number ) = Number L ; @@result@@ = @@v2@@ ; * ( _QWORD * ) ( @@v2@@ + Number ) = Number L ; * ( _DWORD * ) ( @@v2@@ + Number ) = Number ; * ( _QWORD * ) ( @@v2@@ + Number ) = Number L ; * ( _QWORD * ) ( @@v2@@ + Number ) = Number L ; * ( _QWORD * ) ( @@v2@@ + Number ) = Number L ; return @@result@@ ; }
_QWORD * __fastcall detect_loop ( _QWORD * @@a1@@ ) { _QWORD * @@result@@ ; _QWORD * @@v2@@ ; __int64 @@v3@@ ; _QWORD * @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; _QWORD * @@v7@@ ; _QWORD * @@v8@@ ; @@result@@ = Number L ; if ( @@a1@@ [ Number ] ) { @@v2@@ = @@a1@@ ; @@v3@@ = loop ; if ( loop ) { @@v4@@ = ( _QWORD * ) @@a1@@ [ Number ] ; if ( @@v4@@ ) { if ( loop == * @@v4@@ ) { @@v8@@ = @@a1@@ + Number ; LABEL_13 : if ( @@a1@@ [ Number ] ) { while ( Number ) { @@v5@@ = * ( _QWORD * ) ( @@v3@@ + Number ) ; __fprintf_chk ( ) ; if ( @@a1@@ == ( _QWORD * ) loop ) break ; * ( _QWORD * ) ( loop + Number ) = Number L ; loop = @@v5@@ ; @@v3@@ = @@v5@@ ; if ( ! @@v5@@ ) goto LABEL_20 ; } @@v6@@ = * ( _QWORD * ) ( * @@v8@@ + Number L ) ; -- * ( _QWORD * ) ( * ( _QWORD * ) * @@v8@@ + Number L ) ; * @@v8@@ = @@v6@@ ; do { @@v7@@ = ( _QWORD * ) @@v2@@ [ Number ] ; @@v2@@ [ Number ] = Number L ; @@v2@@ = @@v7@@ ; } while ( @@v7@@ ) ; loop = Number L ; LABEL_20 : @@result@@ = ( _QWORD * ) ( & dword_0 + Number ) ; } else { @@a1@@ [ Number ] = loop ; loop = ( __int64 ) @@a1@@ ; @@result@@ = Number L ; } } else { while ( Number ) { @@result@@ = ( _QWORD * ) @@v4@@ [ Number ] ; if ( ! @@result@@ ) break ; if ( loop == * @@result@@ ) { @@v8@@ = @@v4@@ + Number ; goto LABEL_13 ; } @@v4@@ = ( _QWORD * ) @@v4@@ [ Number ] ; } } } } else { loop = ( __int64 ) @@a1@@ ; } } return @@result@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; FILE * @@v11@@ ; char * @@v12@@ ; FILE * @@v13@@ ; char * @@v14@@ ; char * @@v15@@ ; FILE * @@v16@@ ; char * @@v17@@ ; char * @@v18@@ ; char * @@v19@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String String String String String String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String String String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = stdout ; @@v10@@ = dcgettext ( Number L , String String String String String String String String String String , Number ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; @@v11@@ = stdout ; @@v12@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v12@@ , @@v11@@ ) ; @@v13@@ = stdout ; @@v14@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v14@@ , @@v13@@ ) ; @@v15@@ = dcgettext ( Number L , String String String String , Number ) ; __printf_chk ( ) ; last_component ( program_name , @@v15@@ ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v16@@ = stdout ; @@v17@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v17@@ , @@v16@@ ) ; @@v18@@ = Number L ; @@v19@@ = setlocale ( Number , Number L ) ; if ( @@v19@@ ) { @@v18@@ = String ; if ( strncmp ( @@v19@@ , String , Number ) ) { last_component ( program_name , String ) ; @@v18@@ = dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name , @@v18@@ ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
void __fastcall cwd_advance_fd ( __int64 @@a1@@ , int @@a2@@ , char @@a3@@ ) { int @@v4@@ ; int @@v5@@ ; @@v4@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; if ( @@v4@@ == @@a2@@ && @@v4@@ != Number ) abort ( ) ; if ( @@a3@@ ) { @@v5@@ = i_ring_push ( @@a1@@ + Number ) ; if ( @@v5@@ < Number ) { LABEL_6 : * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; return ; } close ( @@v5@@ ) ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; } else { if ( ( * ( _BYTE * ) ( @@a1@@ + Number ) & Number ) != Number || @@v4@@ < Number ) goto LABEL_6 ; close ( @@v4@@ ) ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; } }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
__int64 __fastcall recurse_tree ( __int64 @@a1@@ , __int64 ( __fastcall * @@a2@@ ( ) ( item ) ) ( __int64 ) ) { __int64 @@v3@@ ; __int64 @@result@@ ; while ( Number ) { @@v3@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( ! @@v3@@ ) break ; if ( ( unsigned __int8 ) recurse_tree ( @@v3@@ , @@a2@@ ( ) ( item ) ) ) return Number L ; LABEL_3 : @@result@@ = @@a2@@ ( ) ( item ) ( @@a1@@ ) ; if ( ( _BYTE ) @@result@@ ) return Number L ; @@a1@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( ! @@a1@@ ) return @@result@@ ; } if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) goto LABEL_3 ; return @@a2@@ ( ) ( item ) ( @@a1@@ ) ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
__int64 __fastcall enter_dir_isra_11 ( __int16 @@a1@@ , _QWORD * @@a2@@ , __int64 @@a3@@ ) { _QWORD * @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; __int64 @@result@@ ; if ( ( @@a1@@ & Number ) != Number ) { @@v4@@ = malloc ( Number ) ; if ( @@v4@@ ) { @@v5@@ = * ( _QWORD * ) ( @@a3@@ + Number ) ; @@v6@@ = * @@a2@@ ; @@v4@@ [ Number ] = @@a3@@ ; * @@v4@@ = @@v5@@ ; @@v4@@ [ Number ] = * ( _QWORD * ) ( @@a3@@ + Number ) ; @@v7@@ = hash_insert ( @@v6@@ , @@v4@@ ) ; if ( @@v4@@ == ( _QWORD * ) @@v7@@ ) return Number L ; free ( @@v4@@ ) ; if ( @@v7@@ ) { @@v8@@ = * ( _QWORD * ) ( @@v7@@ + Number ) ; * ( _WORD * ) ( @@a3@@ + Number ) = Number ; * ( _QWORD * ) @@a3@@ = @@v8@@ ; return Number L ; } } @@result@@ = Number L ; } else { @@result@@ = cycle_check ( * @@a2@@ , @@a3@@ + Number ) ; if ( ! ( _BYTE ) @@result@@ ) return Number L ; * ( _QWORD * ) @@a3@@ = @@a3@@ ; * ( _WORD * ) ( @@a3@@ + Number ) = Number ; } return @@result@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
char * canonicalize_file_name ( const char * @@name@@ ) { return canonicalize_file_name ( @@name@@ ) ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
__int64 __fastcall check_tuning_isra_0 ( float * * @@a1@@ ) { float * @@v1@@ ; __int64 @@result@@ ; float @@v3@@ ; float @@v4@@ ; float @@v5@@ ; @@v1@@ = * @@a1@@ ; @@result@@ = Number L ; if ( * @@a1@@ != ( float * ) & default_tuning ) { @@v3@@ = @@v1@@ [ Number ] ; if ( @@v3@@ <= Number || @@v3@@ >= Number || @@v1@@ [ Number ] <= Number || * @@v1@@ < Number || ( @@v4@@ = * @@v1@@ + Number , @@v5@@ = @@v1@@ [ Number ] , @@v5@@ <= @@v4@@ ) || @@v5@@ > Number || @@v3@@ <= @@v4@@ ) { * @@a1@@ = ( float * ) & default_tuning ; @@result@@ = Number L ; } } return @@result@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_207230 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_207210 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_207220 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
__int64 __fastcall hash_lookup ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; _QWORD * @@v4@@ ; __int64 @@v5@@ ; @@v2@@ = * @@a1@@ ; @@v4@@ = ( _QWORD * ) ( Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) + @@v2@@ ) ; if ( @@a1@@ [ Number ] <= ( unsigned __int64 ) @@v4@@ ) abort ( ) ; @@v5@@ = * @@v4@@ ; if ( ! * @@v4@@ ) return Number L ; while ( @@v5@@ != @@a2@@ ) { if ( ( ( unsigned __int8 ( __fastcall * ) ( __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ ) ) return * @@v4@@ ; @@v4@@ = ( _QWORD * ) @@v4@@ [ Number ] ; if ( ! @@v4@@ ) return Number L ; @@v5@@ = * @@v4@@ ; } return @@v5@@ ; }
unsigned __int64 __fastcall readtokens ( _IO_FILE * @@a1@@ , _BYTE * @@a2@@ , _BYTE * @@a3@@ , unsigned __int64 @@a4@@ , __int64 * @@a5@@ , __int64 * @@a6@@ ) { unsigned __int64 @@v6@@ ; unsigned __int128 @@v7@@ ; unsigned __int64 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 * @@v10@@ ; void * * @@v11@@ ; void * @@v12@@ ; void * @@v13@@ ; unsigned __int64 @@v14@@ ; __int64 @@v15@@ ; void * @@v16@@ ; __int64 @@v18@@ ; _IO_FILE * @@v19@@ ; __int64 @@v24@@ ; void * @@src@@ ; unsigned __int64 @@v26@@ ; @@v6@@ = ( unsigned __int64 ) ( @@a2@@ + Number ) ; @@v26@@ = __readfsqword ( Number ) ; if ( ! @@a2@@ ) @@v6@@ = Number L ; @@v19@@ = @@a1@@ ; @@v7@@ = @@v6@@ * ( unsigned __int128 ) Number ; if ( ! is_mul_ok ( @@v6@@ , Number ) ) LABEL_19 : xalloc_die ( @@a1@@ , @@a2@@ , * ( ( _QWORD * ) & @@v7@@ + Number ) , @@a4@@ ) ; @@v8@@ = Number L ; @@v9@@ = xmalloc ( Number * @@v6@@ ) ; @@v18@@ = xmalloc ( Number * @@v6@@ ) ; @@v24@@ = Number L ; @@src@@ = Number L ; while ( Number ) { @@a2@@ = @@a3@@ ; @@a1@@ = @@v19@@ ; @@v14@@ = readtoken ( @@v19@@ , @@a3@@ , @@a4@@ , & @@v24@@ ) ; if ( @@v8@@ < @@v6@@ ) goto LABEL_5 ; if ( @@v9@@ ) { if ( @@v6@@ > Number ) goto LABEL_19 ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v15@@ = Number L ; @@v6@@ = Number L ; goto LABEL_12 ; } @@v15@@ = Number * @@v6@@ ; LABEL_12 : @@a1@@ = ( _IO_FILE * ) @@v9@@ ; @@a2@@ = ( _BYTE * ) @@v15@@ ; @@v9@@ = xrealloc ( @@v9@@ , @@v15@@ ) ; @@v7@@ = @@v6@@ * ( unsigned __int128 ) Number ; if ( ! is_mul_ok ( @@v6@@ , Number ) ) goto LABEL_19 ; @@v18@@ = xrealloc ( @@v18@@ , @@v15@@ ) ; LABEL_5 : @@v10@@ = ( unsigned __int64 * ) ( @@v18@@ + Number * @@v8@@ ) ; @@v11@@ = ( void * * ) ( @@v9@@ + Number * @@v8@@ ) ; if ( @@v14@@ == Number ) break ; ++ @@v8@@ ; @@v12@@ = ( void * ) xmalloc ( @@v14@@ + Number ) ; @@v13@@ = @@src@@ ; * @@v10@@ = @@v14@@ ; * @@v11@@ = memcpy ( @@v12@@ , @@v13@@ , @@v14@@ + Number ) ; } * @@v11@@ = Number L ; @@v16@@ = @@src@@ ; * @@v10@@ = Number L ; free ( @@v16@@ ) ; * @@a5@@ = @@v9@@ ; if ( @@a6@@ ) * @@a6@@ = @@v18@@ ; return @@v8@@ ; }
int iswspace ( wint_t @@wc@@ ) { return iswspace ( @@wc@@ ) ; }
char * nl_langinfo ( nl_item @@item@@ ) { return nl_langinfo ( @@item@@ ) ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
__int64 __fastcall hash_do_for_each ( __int64 @@a1@@ , unsigned __int8 ( __fastcall * @@a2@@ ) ( __int64 , __int64 ) , __int64 @@a3@@ ) { __int64 * @@v3@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 * @@v8@@ ; @@v3@@ = * ( __int64 * * ) @@a1@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= * ( _QWORD * ) @@a1@@ ) return Number L ; @@v6@@ = Number L ; while ( Number ) { @@v7@@ = * @@v3@@ ; if ( * @@v3@@ ) break ; LABEL_8 : @@v3@@ += Number ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= ( unsigned __int64 ) @@v3@@ ) return @@v6@@ ; } @@v8@@ = @@v3@@ ; while ( @@a2@@ ( @@v7@@ , @@a3@@ ) ) { @@v8@@ = ( __int64 * ) @@v8@@ [ Number ] ; ++ @@v6@@ ; if ( ! @@v8@@ ) goto LABEL_8 ; @@v7@@ = * @@v8@@ ; } return @@v6@@ ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
void __fastcall i_ring_init ( __int64 @@a1@@ , int @@a2@@ ) { * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; }
size_t __fastcall strnlen1 ( const void * @@a1@@ , size_t @@a2@@ ) { _BYTE * @@v2@@ ; __int64 @@v3@@ ; bool @@v4@@ ; size_t @@result@@ ; @@v2@@ = memchr ( @@a1@@ , Number , @@a2@@ ) ; @@v3@@ = @@v2@@ - ( _BYTE * ) @@a1@@ + Number ; @@v4@@ = @@v2@@ == Number L ; @@result@@ = @@a2@@ ; if ( ! @@v4@@ ) @@result@@ = @@v3@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; program_invocation_short_name = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
__int64 __fastcall i_ring_pop ( __int64 @@a1@@ ) { _DWORD * @@v1@@ ; int @@v2@@ ; __int64 @@result@@ ; if ( * ( _BYTE * ) ( @@a1@@ + Number ) ) abort ( ) ; @@v1@@ = ( _DWORD * ) ( @@a1@@ + Number L * * ( unsigned int * ) ( @@a1@@ + Number ) ) ; @@v2@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; @@result@@ = ( unsigned int ) * @@v1@@ ; * @@v1@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; if ( @@v2@@ == * ( _DWORD * ) ( @@a1@@ + Number ) ) * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; else * ( _DWORD * ) ( @@a1@@ + Number ) = ( ( _BYTE ) @@v2@@ + Number ) & Number ; return @@result@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
DIR * __fastcall opendir_safer ( const char * @@a1@@ ) { DIR * @@v1@@ ; DIR * @@v2@@ ; unsigned int @@v3@@ ; int @@v5@@ ; DIR * @@v6@@ ; int * @@v7@@ ; int @@v8@@ ; @@v1@@ = opendir ( @@a1@@ ) ; @@v2@@ = @@v1@@ ; if ( ! @@v1@@ ) return @@v2@@ ; @@v3@@ = dirfd ( @@v1@@ ) ; if ( @@v3@@ > Number ) return @@v2@@ ; @@v5@@ = dup_safer ( @@v3@@ ) ; @@v6@@ = fdopendir ( @@v5@@ ) ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; if ( ! @@v6@@ ) close ( @@v5@@ ) ; closedir ( @@v2@@ ) ; * @@v7@@ = @@v8@@ ; return @@v6@@ ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
void __fastcall init_tokenbuffer ( _QWORD * @@a1@@ ) { * @@a1@@ = Number L ; @@a1@@ [ Number ] = Number L ; }
__int64 __fastcall dir_len ( _BYTE * @@a1@@ ) { unsigned __int64 @@v1@@ ; _BYTE * @@v2@@ ; __int64 @@v3@@ ; @@v1@@ = * @@a1@@ == Number ; @@v2@@ = last_component ( @@a1@@ ) ; if ( @@v2@@ - @@a1@@ <= @@v1@@ ) return @@v2@@ - @@a1@@ ; @@v3@@ = @@v2@@ - @@a1@@ - Number ; if ( * ( @@v2@@ - Number ) != Number ) return @@v2@@ - @@a1@@ ; while ( @@v1@@ != @@v3@@ && @@a1@@ [ @@v3@@ - Number ] == Number ) -- @@v3@@ ; return @@v3@@ ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
__int64 __fastcall dir_name ( void * @@a1@@ ) { __int64 @@result@@ ; @@result@@ = mdir_name ( @@a1@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ , @@v4@@ ) ; } return @@result@@ ; }
int chdir ( const char * @@path@@ ) { return chdir ( @@path@@ ) ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
__int64 __fastcall get_fs_usage ( const char * @@a1@@ , __int64 a2 , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; struct statfs @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; if ( statfs ( @@a1@@ , & @@v6@@ ) < Number ) return Number ; * ( _QWORD * ) @@a3@@ = @@v6@@ . f_bsize ; * ( _QWORD * ) ( @@a3@@ + Number ) = @@v6@@ . f_blocks ; * ( _QWORD * ) ( @@a3@@ + Number ) = @@v6@@ . f_bfree ; @@v4@@ = @@v6@@ . f_bavail ; * ( _QWORD * ) ( @@a3@@ + Number ) = @@v6@@ . f_bavail ; * ( _BYTE * ) ( @@a3@@ + Number ) = @@v4@@ < Number ; * ( _QWORD * ) ( @@a3@@ + Number ) = @@v6@@ . f_files ; * ( _QWORD * ) ( @@a3@@ + Number ) = @@v6@@ . f_ffree ; return Number L ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ , @@v4@@ ) ; return @@result@@ ; }
int iswalnum ( wint_t @@wc@@ ) { return iswalnum ( @@wc@@ ) ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
int __fxstat ( int @@ver@@ , int @@fildes@@ , struct stat * @@stat_buf@@ ) { return _fxstat ( @@ver@@ , @@fildes@@ , @@stat_buf@@ ) ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
char * strdup ( const char * @@s@@ ) { return strdup ( @@s@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
char * __fastcall df_readable ( unsigned __int8 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v5@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; char * @@result@@ ; if ( @@a2@@ <= Number ) { @@v5@@ = ( unsigned int ) human_output_opts ; @@v6@@ = @@a1@@ + @@a3@@ ; if ( @@a1@@ ) goto LABEL_4 ; @@result@@ = ( char * ) human_readable ( @@a2@@ , @@v6@@ , ( unsigned int ) human_output_opts ) ; } else { if ( @@a1@@ ) { @@v5@@ = ( unsigned int ) human_output_opts ; @@v6@@ = @@a3@@ + Number ; LABEL_4 : @@v7@@ = human_readable ( - ( __int64 ) @@a2@@ , @@v6@@ , @@v5@@ ) ; * ( _BYTE * ) ( @@v7@@ - Number ) = Number ; return ( char * ) ( @@v7@@ - Number ) ; } @@result@@ = String ; } return @@result@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
struct mntent * getmntent ( FILE * @@stream@@ ) { return getmntent ( @@stream@@ ) ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
int fchdir ( int @@fd@@ ) { return fchdir ( @@fd@@ ) ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_210290 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_210270 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_210280 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
_BYTE * __fastcall mdir_name ( void * @@src@@ ) { __int64 @@v1@@ ; _BYTE * @@v2@@ ; _BYTE * @@v3@@ ; _BYTE * @@v4@@ ; @@v1@@ = dir_len ( @@src@@ ) ; @@v2@@ = malloc ( @@v1@@ + ( @@v1@@ == Number ) + Number ) ; @@v3@@ = @@v2@@ ; if ( @@v2@@ ) { @@v4@@ = memcpy ( @@v2@@ , @@src@@ , @@v1@@ ) ; @@v3@@ = @@v4@@ ; if ( ! @@v1@@ ) { * @@v4@@ = Number ; @@v1@@ = Number L ; } @@v4@@ [ @@v1@@ ] = Number ; } return @@v3@@ ; }
__ino_t * __fastcall get_root_dev_ino ( __ino_t * @@a1@@ ) { struct stat @@v2@@ ; unsigned __int64 @@v3@@ ; @@v3@@ = __readfsqword ( Number ) ; if ( __lxstat ( Number , String , & @@v2@@ ) ) return Number L ; * @@a1@@ = @@v2@@ . st_ino ; @@a1@@ [ Number ] = @@v2@@ . st_dev ; return @@a1@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
__int64 __fastcall c_strcasecmp ( unsigned __int8 * @@a1@@ , unsigned __int8 * @@a2@@ ) { __int64 @@result@@ ; int @@v3@@ ; int @@v4@@ ; @@result@@ = Number L ; if ( @@a1@@ != @@a2@@ ) { do { @@v3@@ = * @@a1@@ ; if ( ( unsigned int ) ( @@v3@@ - Number ) < Number ) LOBYTE ( @@v3@@ ) = @@v3@@ + Number ; @@v4@@ = * @@a2@@ ; if ( ( unsigned int ) ( @@v4@@ - Number ) < Number ) LOBYTE ( @@v4@@ ) = @@v4@@ + Number ; if ( ! ( _BYTE ) @@v3@@ ) break ; ++ @@a1@@ ; ++ @@a2@@ ; } while ( ( _BYTE ) @@v3@@ == ( _BYTE ) @@v4@@ ) ; @@result@@ = ( unsigned __int8 ) @@v3@@ - ( unsigned int ) ( unsigned __int8 ) @@v4@@ ; } return @@result@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
void __fastcall argmatch_invalid ( __int64 @@a1@@ , wchar_t * @@a2@@ , __int64 @@a3@@ ) { char * @@v3@@ ; __int64 @@v4@@ ; _BYTE * @@v5@@ ; if ( @@a3@@ == Number ) @@v3@@ = dcgettext ( Number L , String , Number ) ; else @@v3@@ = dcgettext ( Number L , String , Number ) ; @@v4@@ = quote_n ( Number L , @@a1@@ ) ; @@v5@@ = quotearg_n_style ( Number , Number , @@a2@@ ) ; error ( Number , Number , @@v3@@ , @@v5@@ , @@v4@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
__int64 __fastcall argmatch ( const char * @@a1@@ , const char * * @@a2@@ , char * @@a3@@ , size_t @@a4@@ ) { char * @@v5@@ ; size_t @@v6@@ ; const char * @@v7@@ ; size_t @@v8@@ ; __int64 @@v9@@ ; bool @@v10@@ ; char @@v11@@ ; __int64 @@v12@@ ; __int64 @@v14@@ ; char @@v15@@ ; @@v5@@ = @@a3@@ ; @@v6@@ = strlen ( @@a1@@ ) ; @@v7@@ = * @@a2@@ ; @@v14@@ = Number ; if ( ! * @@a2@@ ) return @@v14@@ ; @@v8@@ = @@v6@@ ; @@v15@@ = Number ; @@v9@@ = Number L ; do { while ( strncmp ( @@v7@@ , @@a1@@ , @@v8@@ ) ) { LABEL_7 : ++ @@v9@@ ; @@v5@@ += @@a4@@ ; @@v7@@ = @@a2@@ [ @@v9@@ ] ; if ( ! @@v7@@ ) goto LABEL_12 ; } if ( strlen ( @@v7@@ ) == @@v8@@ ) return @@v9@@ ; if ( @@v14@@ != Number ) { if ( @@a3@@ ) { @@v10@@ = memcmp ( & @@a3@@ [ @@a4@@ * @@v14@@ ] , @@v5@@ , @@a4@@ ) == Number ; @@v11@@ = @@v15@@ ; if ( ! @@v10@@ ) @@v11@@ = Number ; @@v15@@ = @@v11@@ ; } else { @@v15@@ = Number ; } goto LABEL_7 ; } @@v14@@ = @@v9@@ ++ ; @@v5@@ += @@a4@@ ; @@v7@@ = @@a2@@ [ @@v9@@ ] ; } while ( @@v7@@ ) ; LABEL_12 : @@v12@@ = Number ; if ( ! @@v15@@ ) @@v12@@ = @@v14@@ ; return @@v12@@ ; }
__int64 __fastcall fd_safer ( int @@fd@@ , __int64 @@a2@@ , __int64 @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { unsigned int @@v6@@ ; unsigned int @@v7@@ ; int * @@v8@@ ; int @@v9@@ ; int * @@v10@@ ; @@v6@@ = @@fd@@ ; if ( ( unsigned int ) @@fd@@ <= Number ) { @@v7@@ = dup_safer ( @@fd@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; @@v8@@ = __errno_location ( ) ; @@v9@@ = * @@v8@@ ; @@v10@@ = @@v8@@ ; close ( @@fd@@ ) ; @@v6@@ = @@v7@@ ; * @@v10@@ = @@v9@@ ; } return @@v6@@ ; }
const char * __fastcall proper_name ( char * @@s@@ ) { char * @@v1@@ ; const char * @@v2@@ ; size_t @@v4@@ ; size_t @@v5@@ ; __int64 @@v6@@ ; @@v1@@ = dcgettext ( Number L , @@s@@ , Number ) ; @@v2@@ = @@v1@@ ; if ( @@s@@ == @@v1@@ || ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@v1@@ , ( __int64 ) @@s@@ ) ) { return @@v2@@ ; } @@v4@@ = strlen ( @@v2@@ ) ; @@v5@@ = strlen ( @@s@@ ) ; @@v6@@ = xmalloc ( @@v4@@ + @@v5@@ + Number ) ; __sprintf_chk ( ) ; return ( const char * ) @@v6@@ ; }
__int64 __fastcall cdb_advance_fd ( int * @@a1@@ , const char * @@a2@@ ) { int @@v3@@ ; int @@v4@@ ; int @@v5@@ ; @@v3@@ = openat ( * @@a1@@ , @@a2@@ , Number ) ; if ( @@v3@@ < Number ) return Number ; @@v4@@ = * @@a1@@ ; @@v5@@ = @@v3@@ ; if ( @@v4@@ >= Number ) { if ( close ( @@v4@@ ) ) cdb_free_part_0 ( ) ; } * @@a1@@ = @@v5@@ ; return Number L ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 __fastcall argmatch_to_argument ( void * @@s1@@ , __int64 * @@a2@@ , char * @@a3@@ , size_t @@a4@@ ) { __int64 @@v4@@ ; __int64 * @@v7@@ ; @@v4@@ = * @@a2@@ ; if ( * @@a2@@ ) { @@v7@@ = @@a2@@ + Number ; do { if ( ! memcmp ( @@s1@@ , @@a3@@ , @@a4@@ ) ) break ; @@v4@@ = * @@v7@@ ; @@a3@@ += @@a4@@ ; ++ @@v7@@ ; } while ( @@v4@@ ) ; } return @@v4@@ ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
char * __fastcall mmalloca ( __int64 @@a1@@ ) { bool @@v1@@ ; size_t @@v2@@ ; _DWORD * @@v3@@ ; char * @@v4@@ ; unsigned __int64 @@v5@@ ; __int64 @@v6@@ ; @@v1@@ = __CFADD__ ( @@a1@@ , Number L ) ; @@v2@@ = @@a1@@ + Number ; if ( @@v1@@ ) return Number L ; @@v3@@ = malloc ( @@v2@@ ) ; @@v4@@ = Number L ; if ( @@v3@@ ) { @@v3@@ [ Number ] = Number ; @@v4@@ = ( char * ) ( @@v3@@ + Number ) ; @@v5@@ = ( unsigned __int64 ) ( @@v3@@ + Number ) % Number ; @@v6@@ = mmalloca_results [ @@v5@@ ] ; mmalloca_results [ @@v5@@ ] = @@v3@@ + Number ; * ( _QWORD * ) @@v3@@ = @@v6@@ ; } return @@v4@@ ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
__int64 __fastcall open_safer ( const char * @@a1@@ , char @@a2@@ , unsigned int @@a3@@ ) { __int64 @@v3@@ ; int @@v4@@ ; @@v3@@ = Number L ; if ( ( @@a2@@ & Number ) != Number ) @@v3@@ = @@a3@@ ; @@v4@@ = open ( @@a1@@ , @@a2@@ , @@v3@@ ) ; return fd_safer ( @@v4@@ ) ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
int __fxstatat ( int @@ver@@ , int @@fildes@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ , int @@flag@@ ) { return _fxstatat ( @@ver@@ , @@fildes@@ , @@filename@@ , @@stat_buf@@ , @@flag@@ ) ; }
struct group * getgrnam ( const char * @@name@@ ) { return getgrnam ( @@name@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
DIR * fdopendir ( int @@fd@@ ) { return fdopendir ( @@fd@@ ) ; }
size_t __fastcall mbslen ( char * @@s@@ ) { __int64 @@i@@ ; int @@v3@@ ; wchar_t @@v4@@ ; size_t @@v5@@ ; size_t @@v6@@ ; size_t @@v7@@ ; size_t @@v8@@ ; char @@v9@@ ; mbstate_t @@v10@@ ; char @@v11@@ ; char * @@sa@@ ; size_t @@v13@@ ; char @@v14@@ ; wchar_t @@v15@@ [ Number ] ; unsigned __int64 @@v16@@ ; @@v16@@ = __readfsqword ( Number ) ; if ( __ctype_get_mb_cur_max ( ) > Number ) { @@sa@@ = @@s@@ ; @@v9@@ = Number ; @@v10@@ = Number L ; @@v11@@ = Number ; for ( @@i@@ = Number L ; ; ++ @@i@@ ) { if ( ! @@v9@@ ) { @@v3@@ = is_basic_table [ ( ( unsigned __int8 ) * @@sa@@ >> Number ) & Number ] ; if ( _bittest ( & @@v3@@ , ( unsigned __int8 ) * @@sa@@ ) ) { @@v13@@ = Number L ; @@v4@@ = * @@sa@@ ; @@v14@@ = Number ; @@v11@@ = Number ; @@v15@@ [ Number ] = @@v4@@ ; goto LABEL_7 ; } if ( ! mbsinit ( & @@v10@@ ) ) __assert_fail ( String , String , Number , String ) ; @@v9@@ = Number ; } @@v5@@ = __ctype_get_mb_cur_max ( ) ; @@v6@@ = strnlen1 ( @@sa@@ , @@v5@@ ) ; @@v7@@ = mbrtowc ( @@v15@@ , @@sa@@ , @@v6@@ , & @@v10@@ ) ; @@v13@@ = @@v7@@ ; switch ( @@v7@@ ) { case Number : @@v13@@ = Number L ; @@v14@@ = Number ; goto LABEL_8 ; case Number : @@v8@@ = strlen ( @@sa@@ ) ; @@v14@@ = Number ; @@v13@@ = @@v8@@ ; goto LABEL_8 ; case Number : @@v13@@ = Number L ; if ( * @@sa@@ ) __assert_fail ( String , String , Number , String ) ; if ( @@v15@@ [ Number ] ) __assert_fail ( String , String , Number , String ) ; break ; } @@v14@@ = Number ; if ( mbsinit ( & @@v10@@ ) ) @@v9@@ = Number ; @@v11@@ = Number ; LABEL_7 : if ( ! @@v15@@ [ Number ] ) return @@i@@ ; LABEL_8 : @@sa@@ += @@v13@@ ; @@v11@@ = Number ; } } return strlen ( @@s@@ ) ; }
long double __fastcall adjust_value_part_0 ( int @@a1@@ , long double @@a2@@ ) { unsigned __int64 @@v7@@ ; long double @@v8@@ ; long double @@result@@ ; if ( @@a2@@ >= Number ) @@v7@@ = ( __int64 ) ( @@a2@@ - Number ) ^ Number ; else @@v7@@ = ( __int64 ) @@a2@@ ; @@v8@@ = ( long double ) @@v7@@ ; if ( @@a1@@ ) return @@v8@@ ; @@result@@ = @@v8@@ ; if ( @@a2@@ != @@v8@@ ) @@result@@ = ( long double ) ( @@v7@@ + Number ) ; return @@result@@ ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
__int64 __fastcall gid_to_name ( __gid_t @@a1@@ ) { struct group * @@v1@@ ; char * @@v2@@ ; _QWORD @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v1@@ = getgrgid ( @@a1@@ ) ; if ( @@v1@@ ) @@v2@@ = @@v1@@ -> gr_name ; else @@v2@@ = ( char * ) umaxtostr ( @@a1@@ , @@v4@@ ) ; return xstrdup ( @@v2@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int64 __fastcall save_cwd ( __int64 @@a1@@ , __int64 a2 , int @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { int @@v6@@ ; __int64 @@result@@ ; __int64 @@v8@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; @@v6@@ = open_safer ( ( unsigned int ) String , Number , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; * ( _DWORD * ) @@a1@@ = @@v6@@ ; @@result@@ = Number L ; if ( @@v6@@ < Number ) { @@v8@@ = xgetcwd ( ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v8@@ ; @@result@@ = ( unsigned int ) - ( @@v8@@ == Number ) ; } return @@result@@ ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
unsigned __int64 __fastcall LCO_hash ( _QWORD * @@a1@@ , unsigned __int64 @@a2@@ ) { return * @@a1@@ % @@a2@@ ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
__int64 __fastcall knuth_morris_pratt_unibyte ( unsigned __int8 * @@a1@@ , const char * @@a2@@ , unsigned __int8 * * @@a3@@ ) { const char * @@v4@@ ; size_t @@v6@@ ; void * @@v7@@ ; __int64 * @@v8@@ ; __int64 @@v9@@ ; __int64 @@i@@ ; char @@v11@@ ; __int64 @@v12@@ ; unsigned __int8 * @@v13@@ ; __int64 @@v14@@ ; __int64 @@v16@@ ; @@v4@@ = @@a2@@ ; @@v6@@ = strlen ( @@a2@@ ) ; if ( @@v6@@ > Number ) return Number L ; if ( Number * @@v6@@ > Number ) { @@v8@@ = ( __int64 * ) mmalloca ( ) ; } else { @@v7@@ = alloca ( Number * @@v6@@ + Number ) ; @@v8@@ = & @@v16@@ ; } if ( ! @@v8@@ ) return Number L ; @@v8@@ [ Number ] = Number L ; if ( @@v6@@ > Number ) { @@v9@@ = Number L ; for ( @@i@@ = Number L ; @@i@@ != @@v6@@ ; ++ @@i@@ ) { @@v11@@ = @@a2@@ [ @@i@@ - Number ] ; if ( @@v11@@ == @@a2@@ [ @@v9@@ ] ) { LABEL_23 : ++ @@v9@@ ; @@v8@@ [ @@i@@ ] = @@i@@ - @@v9@@ ; } else { while ( @@v9@@ ) { @@v9@@ -= @@v8@@ [ @@v9@@ ] ; if ( @@v11@@ == @@a2@@ [ @@v9@@ ] ) goto LABEL_23 ; } @@v8@@ [ @@i@@ ] = @@i@@ ; @@v9@@ = Number L ; } } } * @@a3@@ = Number L ; @@v12@@ = * @@a1@@ ; @@v13@@ = @@a1@@ ; @@v14@@ = Number L ; LABEL_14 : while ( Number ) { if ( ( _BYTE ) @@v12@@ ) { while ( @@v4@@ [ @@v14@@ ] != ( _BYTE ) @@v12@@ ) { if ( ! @@v14@@ ) { @@v12@@ = @@v13@@ [ Number ] ; ++ @@a1@@ ; ++ @@v13@@ ; goto LABEL_14 ; } @@a2@@ = ( const char * ) @@v8@@ [ @@v14@@ ] ; @@a1@@ = & @@a1@@ [ ( _QWORD ) @@a2@@ ] ; @@v14@@ -= ( __int64 ) @@a2@@ ; } ++ @@v14@@ ; @@a2@@ = ( const char * ) ( @@v13@@ + Number ) ; if ( @@v6@@ != @@v14@@ ) { @@v12@@ = * ++ @@v13@@ ; continue ; } * @@a3@@ = @@a1@@ ; } break ; } freea ( @@v8@@ , @@a2@@ , @@v12@@ , @@v13@@ ) ; return Number L ; }
__int64 __fastcall fts_stat ( __int64 @@a1@@ , __int64 @@a2@@ , char @@a3@@ ) { struct stat * @@v4@@ ; bool @@v5@@ ; int @@v6@@ ; const char * @@v7@@ ; int * @@v8@@ ; int @@v9@@ ; int * @@v10@@ ; __int64 @@result@@ ; int @@v12@@ ; __int64 @@v13@@ ; @@v4@@ = ( struct stat * ) ( @@a2@@ + Number ) ; @@v5@@ = * ( _QWORD * ) ( @@a2@@ + Number ) == Number L ; @@v6@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; @@v7@@ = * ( const char * * ) ( @@a2@@ + Number ) ; if ( @@v5@@ && ( @@v6@@ & Number ) != Number || ( @@v6@@ & Number ) != Number || @@a3@@ ) { if ( ! __xstat ( Number , @@v7@@ , @@v4@@ ) ) goto LABEL_11 ; @@v8@@ = __errno_location ( ) ; @@v9@@ = * @@v8@@ ; @@v10@@ = @@v8@@ ; if ( * @@v8@@ == Number && ! __lxstat ( Number , * ( const char * * ) ( @@a2@@ + Number ) , @@v4@@ ) ) { * @@v10@@ = Number ; return Number L ; } * ( _DWORD * ) ( @@a2@@ + Number ) = @@v9@@ ; LABEL_6 : * ( _QWORD * ) ( @@a2@@ + Number ) = Number L ; @@v4@@ -> __unused [ Number ] = Number L ; memset ( ( void * ) ( ( unsigned __int64 ) & @@v4@@ -> st_ino & Number ) , Number , Number L * ( ( ( unsigned int ) @@v4@@ - ( ( ( _DWORD ) @@v4@@ + Number ) & Number ) + Number ) >> Number ) ) ; return Number L ; } if ( __fxstatat ( Number , * ( _DWORD * ) ( @@a1@@ + Number ) , @@v7@@ , @@v4@@ , Number ) ) { * ( _DWORD * ) ( @@a2@@ + Number ) = * __errno_location ( ) ; goto LABEL_6 ; } LABEL_11 : @@v12@@ = * ( _DWORD * ) ( @@a2@@ + Number ) & Number ; if ( @@v12@@ == Number ) { @@v13@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( ( * ( _BYTE * ) ( @@a1@@ + Number ) & Number ) == Number ) @@v13@@ -= Number L ; @@v5@@ = * ( _BYTE * ) ( @@a2@@ + Number ) == Number ; * ( _QWORD * ) ( @@a2@@ + Number ) = @@v13@@ ; @@result@@ = Number L ; if ( @@v5@@ && ( ! * ( _BYTE * ) ( @@a2@@ + Number ) || ( * ( _DWORD * ) ( @@a2@@ + Number ) & Number ) == Number ) ) { @@result@@ = * ( _QWORD * ) ( @@a2@@ + Number ) == Number L ? Number : Number ; } } else if ( @@v12@@ == Number ) { @@result@@ = Number L ; } else { @@result@@ = Number * ( unsigned int ) ( @@v12@@ == Number ) + Number ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
void __fastcall freea ( unsigned __int64 @@a1@@ ) { __int64 @@v1@@ ; __int64 @@v2@@ ; _QWORD * @@v3@@ ; if ( @@a1@@ ) { if ( * ( _DWORD * ) ( @@a1@@ - Number ) == Number ) { @@v1@@ = mmalloca_results [ @@a1@@ % Number ] ; if ( @@v1@@ ) { if ( @@v1@@ == @@a1@@ ) { @@v3@@ = & mmalloca_results [ @@a1@@ % Number ] ; LABEL_12 : * @@v3@@ = * ( _QWORD * ) ( @@a1@@ - Number ) ; free ( ( void * ) ( @@a1@@ - Number ) ) ; } else { while ( Number ) { @@v2@@ = * ( _QWORD * ) ( @@v1@@ - Number ) ; if ( ! @@v2@@ ) break ; if ( @@a1@@ == @@v2@@ ) { @@v3@@ = ( _QWORD * ) ( @@v1@@ - Number ) ; goto LABEL_12 ; } @@v1@@ = * ( _QWORD * ) ( @@v1@@ - Number ) ; } } } } } }
__int64 __fastcall hash_get_n_buckets ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__int64 __fastcall hash_get_n_buckets_used ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
unsigned __int64 __fastcall AD_hash ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) % @@a2@@ ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
__int64 __fastcall hash_get_n_entries ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
DIR * opendir ( const char * @@name@@ ) { return opendir ( @@name@@ ) ; }
bool __fastcall LCO_compare ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { return * @@a1@@ == * @@a2@@ ; }
int __fastcall restore_cwd ( __int64 @@a1@@ ) { int @@result@@ ; if ( * ( int * ) @@a1@@ < Number ) @@result@@ = chdir_long ( * ( void * * ) ( @@a1@@ + Number ) ) ; else @@result@@ = fchdir ( * ( _DWORD * ) @@a1@@ ) ; return @@result@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
int __lxstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _lxstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
__int64 __fastcall fts_compare_ino ( __int64 @@a1@@ , __int64 @@a2@@ ) { unsigned __int64 @@v2@@ ; __int64 @@result@@ ; @@v2@@ = * ( _QWORD * ) ( * ( _QWORD * ) @@a2@@ + Number L ) ; if ( * ( _QWORD * ) ( * ( _QWORD * ) @@a1@@ + Number L ) < @@v2@@ ) @@result@@ = Number ; else @@result@@ = * ( _QWORD * ) ( * ( _QWORD * ) @@a1@@ + Number L ) > @@v2@@ ; return @@result@@ ; }
unsigned __int64 __fastcall hash_get_max_bucket_length ( __int64 @@a1@@ ) { _QWORD * @@v1@@ ; unsigned __int64 @@v2@@ ; unsigned __int64 @@result@@ ; __int64 @@v4@@ ; unsigned __int64 @@i@@ ; @@v1@@ = * ( _QWORD * * ) @@a1@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; for ( @@result@@ = Number L ; ( unsigned __int64 ) @@v1@@ < @@v2@@ ; @@v1@@ += Number ) { if ( * @@v1@@ ) { @@v4@@ = @@v1@@ [ Number ] ; for ( @@i@@ = Number L ; @@v4@@ ; ++ @@i@@ ) @@v4@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; if ( @@result@@ < @@i@@ ) @@result@@ = @@i@@ ; } } return @@result@@ ; }
__int64 __fastcall umaxtostr ( unsigned __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; @@v2@@ = @@a2@@ + Number ; * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; do { * ( _BYTE * ) -- @@v2@@ = @@a1@@ % Number + Number ; @@a1@@ /= Number ; } while ( @@a1@@ ) ; return @@v2@@ ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
int closedir ( DIR * @@dirp@@ ) { return closedir ( @@dirp@@ ) ; }
__int64 __fastcall fd_ring_clear ( __int64 @@a1@@ ) { int @@v1@@ ; __int64 @@result@@ ; while ( Number ) { @@result@@ = i_ring_empty ( @@a1@@ ) ; if ( ( _BYTE ) @@result@@ ) break ; @@v1@@ = i_ring_pop ( @@a1@@ ) ; if ( @@v1@@ >= Number ) close ( @@v1@@ ) ; } return @@result@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 __fastcall hash_get_first ( __int64 @@a1@@ ) { __int64 * @@v1@@ ; unsigned __int64 @@v2@@ ; __int64 @@result@@ ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; @@v1@@ = * ( __int64 * * ) @@a1@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( * ( _QWORD * ) @@a1@@ >= @@v2@@ ) goto LABEL_9 ; @@result@@ = * @@v1@@ ; if ( ! * @@v1@@ ) { while ( Number ) { @@v1@@ += Number ; if ( ( unsigned __int64 ) @@v1@@ >= @@v2@@ ) break ; @@result@@ = * @@v1@@ ; if ( * @@v1@@ ) return @@result@@ ; } LABEL_9 : abort ( ) ; } return @@result@@ ; }
int __xstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _xstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
int fgetc ( FILE * @@stream@@ ) { return fgetc ( @@stream@@ ) ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 __fastcall fts_palloc_isra_2 ( void * * @@a1@@ , size_t * @@a2@@ , __int64 @@a3@@ ) { void * @@v4@@ ; size_t @@v5@@ ; void * @@v6@@ ; __int64 @@result@@ ; @@v4@@ = * @@a1@@ ; @@v5@@ = * @@a2@@ + @@a3@@ + Number ; if ( * @@a2@@ > @@v5@@ ) { free ( @@v4@@ ) ; * @@a1@@ = Number L ; * __errno_location ( ) = Number ; @@result@@ = Number L ; } else { * @@a2@@ = @@v5@@ ; @@v6@@ = realloc ( @@v4@@ , @@v5@@ ) ; if ( @@v6@@ ) { * @@a1@@ = @@v6@@ ; @@result@@ = Number L ; } else { free ( * @@a1@@ ) ; * @@a1@@ = Number L ; @@result@@ = Number L ; } } return @@result@@ ; }
int __fxstat ( int @@ver@@ , int @@fildes@@ , struct stat * @@stat_buf@@ ) { return _fxstat ( @@ver@@ , @@fildes@@ , @@stat_buf@@ ) ; }
char * __fastcall str_iconv ( char * @@s@@ , char * @@fromcode@@ , char * @@tocode@@ ) { char * @@v4@@ ; iconv_t @@v6@@ ; void * @@v7@@ ; int * @@v8@@ ; int @@v9@@ ; int * @@v10@@ ; int * @@v11@@ ; int @@v12@@ ; int * @@v13@@ ; if ( * @@s@@ && ( unsigned int ) c_strcasecmp ( ( unsigned __int8 * ) @@fromcode@@ , ( unsigned __int8 * ) @@tocode@@ ) ) { @@v6@@ = iconv_open ( @@tocode@@ , @@fromcode@@ ) ; @@v7@@ = @@v6@@ ; if ( @@v6@@ == ( iconv_t ) Number ) return Number L ; @@v4@@ = str_cd_iconv ( @@s@@ , @@v6@@ ) ; if ( @@v4@@ ) { if ( iconv_close ( @@v7@@ ) < Number ) { @@v8@@ = __errno_location ( ) ; @@v9@@ = * @@v8@@ ; @@v10@@ = @@v8@@ ; free ( @@v4@@ ) ; @@v4@@ = Number L ; * @@v10@@ = @@v9@@ ; } } else { @@v11@@ = __errno_location ( ) ; @@v12@@ = * @@v11@@ ; @@v13@@ = @@v11@@ ; iconv_close ( @@v7@@ ) ; * @@v13@@ = @@v12@@ ; } return @@v4@@ ; } @@v4@@ = strdup ( @@s@@ ) ; if ( @@v4@@ ) return @@v4@@ ; * __errno_location ( ) = Number ; return Number L ; }
__int64 __fastcall compare_ranges ( const void * @@a1@@ , const void * @@a2@@ ) { __int64 @@result@@ ; if ( * ( _DWORD * ) @@a1@@ < * ( _DWORD * ) @@a2@@ ) @@result@@ = Number ; else @@result@@ = * ( _DWORD * ) @@a1@@ > * ( _DWORD * ) @@a2@@ ; return @@result@@ ; }
unsigned __int64 __fastcall hash_string ( unsigned __int8 * @@a1@@ , unsigned __int64 @@a2@@ ) { __int64 @@v2@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@v4@@ ; @@v2@@ = * @@a1@@ ; for ( @@i@@ = Number L ; ( _BYTE ) @@v2@@ ; @@i@@ = @@v4@@ % @@a2@@ ) { ++ @@a1@@ ; @@v4@@ = @@v2@@ + Number * @@i@@ ; @@v2@@ = * @@a1@@ ; } return @@i@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 __fastcall fts_set ( __int64 a1 , __int64 @@a2@@ , unsigned int @@a3@@ ) { __int64 @@result@@ ; if ( @@a3@@ > Number ) { * __errno_location ( ) = Number ; @@result@@ = Number L ; } else { * ( _WORD * ) ( @@a2@@ + Number ) = @@a3@@ ; @@result@@ = Number L ; } return @@result@@ ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
int __fastcall argmatch_valid ( _QWORD * @@a1@@ , char * @@a2@@ , size_t @@a3@@ ) { const void * @@v5@@ ; __int64 @@v6@@ ; char * @@v7@@ ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; if ( * @@a1@@ ) { @@v5@@ = Number L ; @@v6@@ = Number L ; do { while ( ! @@v6@@ || memcmp ( @@v5@@ , @@a2@@ , @@a3@@ ) ) { ++ @@v6@@ ; @@v5@@ = @@a2@@ ; __fprintf_chk ( ) ; @@a2@@ += @@a3@@ ; if ( ! @@a1@@ [ @@v6@@ ] ) goto LABEL_7 ; } ++ @@v6@@ ; @@a2@@ += @@a3@@ ; __fprintf_chk ( ) ; } while ( @@a1@@ [ @@v6@@ ] ) ; } LABEL_7 : @@v7@@ = stderr -> _IO_write_ptr ; if ( @@v7@@ >= stderr -> _IO_write_end ) { LODWORD ( @@v7@@ ) = __overflow ( stderr , Number ) ; } else { stderr -> _IO_write_ptr = @@v7@@ + Number ; * @@v7@@ = Number ; } return ( int ) @@v7@@ ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
__int64 __fastcall uid_to_name ( __uid_t @@a1@@ ) { struct passwd * @@v1@@ ; char * @@v2@@ ; _QWORD @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v1@@ = getpwuid ( @@a1@@ ) ; if ( @@v1@@ ) @@v2@@ = @@v1@@ -> pw_name ; else @@v2@@ = ( char * ) umaxtostr ( @@a1@@ , @@v4@@ ) ; return xstrdup ( @@v2@@ ) ; }
unsigned __int64 __fastcall next_prime ( unsigned __int64 @@a1@@ ) { unsigned __int64 @@v1@@ ; unsigned __int64 @@v2@@ ; __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; if ( @@a1@@ < Number ) @@a1@@ = Number L ; @@v1@@ = @@a1@@ | Number ; if ( @@v1@@ != Number ) { while ( Number ) { @@v2@@ = @@v1@@ % Number ; if ( @@v1@@ <= Number ) goto LABEL_9 ; if ( @@v1@@ % Number ) break ; LABEL_10 : @@v1@@ += Number L ; if ( @@v1@@ == Number ) return @@v1@@ ; } @@v3@@ = Number L ; @@v4@@ = Number L ; @@v5@@ = Number L ; while ( Number ) { @@v5@@ += Number L ; @@v4@@ += @@v3@@ ; @@v2@@ = @@v1@@ % @@v5@@ ; if ( @@v4@@ >= @@v1@@ ) break ; @@v3@@ += Number L ; if ( ! ( @@v1@@ % @@v5@@ ) ) goto LABEL_10 ; } LABEL_9 : if ( @@v2@@ ) return @@v1@@ ; goto LABEL_10 ; } return @@v1@@ ; }
_QWORD * __fastcall hash_initialize ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 ( __fastcall * @@a3@@ ) ( __int64 a1 , unsigned __int64 a2 ) , bool ( __fastcall * @@a4@@ ) ( __int64 a1 , __int64 a2 ) , __int64 @@a5@@ ) { unsigned __int64 ( __fastcall * @@v5@@ ) ( __int64 , unsigned __int64 ) ; bool ( __fastcall * @@v6@@ ) ( __int64 , __int64 ) ; char * @@v9@@ ; _QWORD * @@v10@@ ; float * * @@v11@@ ; float @@v12@@ ; float @@v13@@ ; float @@v14@@ ; unsigned __int64 @@v15@@ ; char * @@v16@@ ; void * @@v17@@ ; @@v5@@ = @@a3@@ ; @@v6@@ = @@a4@@ ; if ( ! @@a3@@ ) @@v5@@ = raw_hasher ; if ( ! @@a4@@ ) @@v6@@ = raw_comparator ; @@v9@@ = ( char * ) malloc ( Number ) ; @@v10@@ = @@v9@@ ; if ( @@v9@@ ) { @@v11@@ = ( float * * ) ( @@v9@@ + Number ) ; if ( @@a2@@ ) { * ( ( _QWORD * ) @@v9@@ + Number ) = @@a2@@ ; if ( ! ( unsigned __int8 ) check_tuning_isra_0 ( @@v11@@ ) ) goto LABEL_20 ; if ( * ( _BYTE * ) ( @@a2@@ + Number ) ) { LABEL_15 : @@v15@@ = next_prime ( @@a1@@ ) ; if ( @@v15@@ <= Number ) { @@v10@@ [ Number ] = @@v15@@ ; if ( @@v15@@ ) { @@v16@@ = ( char * ) calloc ( @@v15@@ , Number ) ; * @@v10@@ = @@v16@@ ; if ( @@v16@@ ) { @@v10@@ [ Number ] = Number L ; @@v10@@ [ Number ] = Number L ; @@v10@@ [ Number ] = @@v5@@ ; @@v10@@ [ Number ] = @@v6@@ ; @@v10@@ [ Number ] = & @@v16@@ [ Number * @@v15@@ ] ; @@v10@@ [ Number ] = @@a5@@ ; @@v10@@ [ Number ] = Number L ; return @@v10@@ ; } } } LABEL_20 : @@v17@@ = @@v10@@ ; @@v10@@ = Number L ; free ( @@v17@@ ) ; return @@v10@@ ; } @@v12@@ = * ( float * ) ( @@a2@@ + Number ) ; } else { * ( ( _QWORD * ) @@v9@@ + Number ) = & default_tuning ; @@v12@@ = Number ; if ( ! ( unsigned __int8 ) check_tuning_isra_0 ( @@v11@@ ) ) goto LABEL_20 ; } if ( @@a1@@ < Number ) @@v13@@ = ( float ) ( @@a1@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@a1@@ >> Number ) ) + ( float ) ( @@a1@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@a1@@ >> Number ) ) ; else @@v13@@ = ( float ) ( int ) @@a1@@ ; @@v14@@ = @@v13@@ / @@v12@@ ; if ( @@v14@@ >= Number ) goto LABEL_20 ; if ( @@v14@@ < Number ) @@a1@@ = ( unsigned int ) ( int ) @@v14@@ ; else @@a1@@ = ( unsigned int ) ( int ) ( float ) ( @@v14@@ - Number ) ^ Number ; goto LABEL_15 ; } return @@v10@@ ; }
__int64 __fastcall dup_safer ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ , char @@a7@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ , @@a7@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
__int64 __fastcall hash_print_statistics ( __int64 @@a1@@ ) { unsigned __int64 @@v1@@ ; _QWORD * @@v2@@ ; unsigned __int64 @@i@@ ; __int64 @@v4@@ ; unsigned __int64 @@j@@ ; @@v1@@ = Number L ; @@v2@@ = * ( _QWORD * * ) @@a1@@ ; for ( @@i@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; ( unsigned __int64 ) @@v2@@ < @@i@@ ; @@v2@@ += Number ) { if ( * @@v2@@ ) { @@v4@@ = @@v2@@ [ Number ] ; for ( @@j@@ = Number L ; @@v4@@ ; ++ @@j@@ ) @@v4@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; if ( @@v1@@ < @@j@@ ) @@v1@@ = @@j@@ ; } } __fprintf_chk ( ) ; __fprintf_chk ( ) ; __fprintf_chk ( ) ; return __fprintf_chk ( ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
bool __fastcall hash_table_ok ( __int64 @@a1@@ ) { _QWORD * @@v1@@ ; unsigned __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; bool @@result@@ ; @@v1@@ = * ( _QWORD * * ) @@a1@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v3@@ = Number L ; @@v4@@ = Number L ; if ( * ( _QWORD * ) @@a1@@ < @@v2@@ ) { do { if ( * @@v1@@ ) { @@v5@@ = @@v1@@ [ Number ] ; ++ @@v4@@ ; ++ @@v3@@ ; for ( ; @@v5@@ ; ++ @@v3@@ ) @@v5@@ = * ( _QWORD * ) ( @@v5@@ + Number ) ; } @@v1@@ += Number ; } while ( ( unsigned __int64 ) @@v1@@ < @@v2@@ ) ; } @@result@@ = Number ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) == @@v4@@ ) @@result@@ = * ( _QWORD * ) ( @@a1@@ + Number ) == @@v3@@ ; return @@result@@ ; }
__int64 __fastcall rpl_fcntl ( int @@a1@@ , int @@a2@@ , __int64 @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { int @@v6@@ ; int @@v8@@ ; int @@v9@@ ; int @@v10@@ ; int @@v11@@ ; int * @@v12@@ ; int @@v13@@ ; int * @@v14@@ ; int @@v15@@ ; @@v15@@ = @@a3@@ ; if ( @@a2@@ != Number ) return ( unsigned int ) fcntl ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( have_dupfd_cloexec_3202 < Number ) { @@v6@@ = ( ( __int64 ( __fastcall * ) ( int , _DWORD , _DWORD , int , int , int , char ) ) rpl_fcntl ) ( @@a1@@ , Number , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ , Number ) ; if ( @@v6@@ < Number || have_dupfd_cloexec_3202 != Number ) return ( unsigned int ) @@v6@@ ; } else { @@v6@@ = fcntl ( @@a1@@ , Number , ( unsigned int ) @@a3@@ ) ; if ( @@v6@@ >= Number || * __errno_location ( ) != Number ) { have_dupfd_cloexec_3202 = Number ; return ( unsigned int ) @@v6@@ ; } @@v6@@ = ( ( __int64 ( __fastcall * ) ( int , _DWORD , int , int , int , int , char ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v15@@ , @@v8@@ , @@v9@@ , @@v10@@ , Number ) ; if ( @@v6@@ < Number ) return ( unsigned int ) @@v6@@ ; have_dupfd_cloexec_3202 = Number ; } @@v11@@ = fcntl ( @@v6@@ , Number ) ; if ( @@v11@@ < Number || fcntl ( @@v6@@ , Number , @@v11@@ | Number ) == Number ) { @@v12@@ = __errno_location ( ) ; @@v13@@ = * @@v12@@ ; @@v14@@ = @@v12@@ ; close ( @@v6@@ ) ; @@v6@@ = Number ; * @@v14@@ = @@v13@@ ; } return ( unsigned int ) @@v6@@ ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
__int64 __fastcall hash_get_next ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; __int64 * @@v6@@ ; _QWORD * @@v7@@ ; __int64 @@v8@@ ; __int64 @@result@@ ; @@v2@@ = * @@a1@@ ; @@v4@@ = ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) ; @@v5@@ = @@a1@@ [ Number ] ; @@v6@@ = ( __int64 * ) ( @@v2@@ + Number * @@v4@@ ) ; if ( @@v5@@ <= ( unsigned __int64 ) @@v6@@ ) abort ( ) ; if ( ! @@v6@@ ) goto LABEL_10 ; @@v7@@ = ( _QWORD * ) @@v6@@ [ Number ] ; if ( * @@v6@@ != @@a2@@ ) { do { if ( ! @@v7@@ ) goto LABEL_10 ; @@v8@@ = * @@v7@@ ; @@v7@@ = ( _QWORD * ) @@v7@@ [ Number ] ; } while ( @@v8@@ != @@a2@@ ) ; } if ( @@v7@@ ) return * @@v7@@ ; LABEL_10 : while ( Number ) { @@v6@@ += Number ; if ( @@v5@@ <= ( unsigned __int64 ) @@v6@@ ) break ; @@result@@ = * @@v6@@ ; if ( * @@v6@@ ) return @@result@@ ; } return Number L ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_20D1F0 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20D1D0 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_20D1E0 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
__int64 __fastcall hash_get_next ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; __int64 * @@v6@@ ; _QWORD * @@v7@@ ; __int64 @@v8@@ ; __int64 @@result@@ ; @@v2@@ = * @@a1@@ ; @@v4@@ = ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) ; @@v5@@ = @@a1@@ [ Number ] ; @@v6@@ = ( __int64 * ) ( @@v2@@ + Number * @@v4@@ ) ; if ( @@v5@@ <= ( unsigned __int64 ) @@v6@@ ) abort ( ) ; if ( ! @@v6@@ ) goto LABEL_10 ; @@v7@@ = ( _QWORD * ) @@v6@@ [ Number ] ; if ( * @@v6@@ != @@a2@@ ) { do { if ( ! @@v7@@ ) goto LABEL_10 ; @@v8@@ = * @@v7@@ ; @@v7@@ = ( _QWORD * ) @@v7@@ [ Number ] ; } while ( @@v8@@ != @@a2@@ ) ; } if ( @@v7@@ ) return * @@v7@@ ; LABEL_10 : while ( Number ) { @@v6@@ += Number ; if ( @@v5@@ <= ( unsigned __int64 ) @@v6@@ ) break ; @@result@@ = * @@v6@@ ; if ( * @@v6@@ ) return @@result@@ ; } return Number L ; }
void __fastcall chopt_init ( __int64 @@a1@@ ) { * ( _DWORD * ) @@a1@@ = Number ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; }
bool __fastcall AD_compare ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@result@@ ; @@result@@ = Number ; if ( @@a1@@ [ Number ] == @@a2@@ [ Number ] ) @@result@@ = * @@a1@@ == * @@a2@@ ; return @@result@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
void __fastcall hash_free ( void * @@ptr@@ ) { _QWORD * @@v2@@ ; unsigned __int64 @@v3@@ ; _QWORD * @@v4@@ ; _QWORD * @@v5@@ ; _QWORD * @@v6@@ ; _QWORD * @@v7@@ ; _QWORD * @@v8@@ ; @@v2@@ = * ( _QWORD * * ) @@ptr@@ ; @@v3@@ = * ( ( _QWORD * ) @@ptr@@ + Number ) ; if ( * ( ( _QWORD * ) @@ptr@@ + Number ) && * ( ( _QWORD * ) @@ptr@@ + Number ) ) { if ( ( unsigned __int64 ) @@v2@@ >= @@v3@@ ) goto LABEL_14 ; do { if ( * @@v2@@ ) { @@v4@@ = @@v2@@ ; do { ( * ( ( void ( * * ) ( void ) ) @@ptr@@ + Number ) ) ( ) ; @@v4@@ = ( _QWORD * ) @@v4@@ [ Number ] ; } while ( @@v4@@ ) ; @@v3@@ = * ( ( _QWORD * ) @@ptr@@ + Number ) ; } @@v2@@ += Number ; } while ( @@v3@@ > ( unsigned __int64 ) @@v2@@ ) ; @@v2@@ = * ( _QWORD * * ) @@ptr@@ ; } if ( ( unsigned __int64 ) @@v2@@ < @@v3@@ ) { do { @@v5@@ = ( _QWORD * ) @@v2@@ [ Number ] ; if ( @@v5@@ ) { do { @@v6@@ = ( _QWORD * ) @@v5@@ [ Number ] ; free ( @@v5@@ ) ; @@v5@@ = @@v6@@ ; } while ( @@v6@@ ) ; } @@v2@@ += Number ; } while ( * ( ( _QWORD * ) @@ptr@@ + Number ) > ( unsigned __int64 ) @@v2@@ ) ; } LABEL_14 : @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@ptr@@ + Number ) ; if ( @@v7@@ ) { do { @@v8@@ = ( _QWORD * ) @@v7@@ [ Number ] ; free ( @@v7@@ ) ; @@v7@@ = @@v8@@ ; } while ( @@v8@@ ) ; } free ( * ( void * * ) @@ptr@@ ) ; free ( @@ptr@@ ) ; }
__int64 __fastcall set_cloexec_flag ( int @@a1@@ , char @@a2@@ , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { int @@v6@@ ; int @@v7@@ ; int @@v8@@ ; int @@v9@@ ; int @@v10@@ ; unsigned int @@v11@@ ; __int64 @@result@@ ; @@v6@@ = rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( @@v6@@ < Number ) return Number ; @@v9@@ = @@v6@@ ; @@v10@@ = @@v6@@ | Number ; @@v11@@ = @@v9@@ & Number ; if ( @@a2@@ ) @@v11@@ = @@v10@@ ; @@result@@ = Number L ; if ( @@v11@@ != @@v9@@ ) @@result@@ = ( unsigned int ) - ( ( unsigned int ) rpl_fcntl ( @@a1@@ , Number , @@v11@@ , @@v9@@ , @@v7@@ , @@v8@@ ) == Number ) ; return @@result@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
_QWORD * __fastcall hash_initialize ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 ( __fastcall * @@a3@@ ) ( __int64 a1 , unsigned __int64 a2 ) , bool ( __fastcall * @@a4@@ ) ( __int64 a1 , __int64 a2 ) , __int64 @@a5@@ ) { unsigned __int64 ( __fastcall * @@v5@@ ) ( __int64 , unsigned __int64 ) ; bool ( __fastcall * @@v6@@ ) ( __int64 , __int64 ) ; char * @@v9@@ ; _QWORD * @@v10@@ ; float * * @@v11@@ ; float @@v12@@ ; float @@v13@@ ; float @@v14@@ ; unsigned __int64 @@v15@@ ; char * @@v16@@ ; void * @@v17@@ ; @@v5@@ = @@a3@@ ; @@v6@@ = @@a4@@ ; if ( ! @@a3@@ ) @@v5@@ = raw_hasher ; if ( ! @@a4@@ ) @@v6@@ = raw_comparator ; @@v9@@ = ( char * ) malloc ( Number ) ; @@v10@@ = @@v9@@ ; if ( @@v9@@ ) { @@v11@@ = ( float * * ) ( @@v9@@ + Number ) ; if ( @@a2@@ ) { * ( ( _QWORD * ) @@v9@@ + Number ) = @@a2@@ ; if ( ! ( unsigned __int8 ) check_tuning_isra_0 ( @@v11@@ ) ) goto LABEL_20 ; if ( * ( _BYTE * ) ( @@a2@@ + Number ) ) { LABEL_15 : @@v15@@ = next_prime ( @@a1@@ ) ; if ( @@v15@@ <= Number ) { @@v10@@ [ Number ] = @@v15@@ ; if ( @@v15@@ ) { @@v16@@ = ( char * ) calloc ( @@v15@@ , Number ) ; * @@v10@@ = @@v16@@ ; if ( @@v16@@ ) { @@v10@@ [ Number ] = Number L ; @@v10@@ [ Number ] = Number L ; @@v10@@ [ Number ] = @@v5@@ ; @@v10@@ [ Number ] = @@v6@@ ; @@v10@@ [ Number ] = & @@v16@@ [ Number * @@v15@@ ] ; @@v10@@ [ Number ] = @@a5@@ ; @@v10@@ [ Number ] = Number L ; return @@v10@@ ; } } } LABEL_20 : @@v17@@ = @@v10@@ ; @@v10@@ = Number L ; free ( @@v17@@ ) ; return @@v10@@ ; } @@v12@@ = * ( float * ) ( @@a2@@ + Number ) ; } else { * ( ( _QWORD * ) @@v9@@ + Number ) = & default_tuning ; @@v12@@ = Number ; if ( ! ( unsigned __int8 ) check_tuning_isra_0 ( @@v11@@ ) ) goto LABEL_20 ; } if ( @@a1@@ < Number ) @@v13@@ = ( float ) ( @@a1@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@a1@@ >> Number ) ) + ( float ) ( @@a1@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@a1@@ >> Number ) ) ; else @@v13@@ = ( float ) ( int ) @@a1@@ ; @@v14@@ = @@v13@@ / @@v12@@ ; if ( @@v14@@ >= Number ) goto LABEL_20 ; if ( @@v14@@ < Number ) @@a1@@ = ( unsigned int ) ( int ) @@v14@@ ; else @@a1@@ = ( unsigned int ) ( int ) ( float ) ( @@v14@@ - Number ) ^ Number ; goto LABEL_15 ; } return @@v10@@ ; }
__int64 __fastcall fts_sort ( _QWORD * @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { __int64 @@v5@@ ; bool @@v6@@ ; int ( * @@v7@@ ) ( const void * , const void * ) ; void * @@v8@@ ; void * @@v9@@ ; _QWORD * @@v10@@ ; __int64 * @@v11@@ ; size_t @@v12@@ ; __int64 @@result@@ ; __int64 @@v14@@ ; __int64 * @@i@@ ; __int64 @@v16@@ ; __int64 @@v17@@ ; @@v5@@ = @@a2@@ ; @@v6@@ = @@a1@@ [ Number ] < @@a3@@ ; @@v7@@ = ( int ( * ) ( const void * , const void * ) ) @@a1@@ [ Number ] ; @@v8@@ = ( void * ) @@a1@@ [ Number ] ; if ( ! @@v6@@ ) goto LABEL_5 ; @@a1@@ [ Number ] = @@a3@@ + Number ; if ( @@a3@@ + Number > Number ) { LABEL_15 : free ( @@v8@@ ) ; @@a1@@ [ Number ] = Number L ; @@a1@@ [ Number ] = Number L ; return @@a2@@ ; } @@v9@@ = realloc ( @@v8@@ , Number * ( @@a3@@ + Number ) ) ; @@v8@@ = @@v9@@ ; if ( ! @@v9@@ ) { @@v8@@ = ( void * ) @@a1@@ [ Number ] ; goto LABEL_15 ; } @@a1@@ [ Number ] = @@v9@@ ; LABEL_5 : if ( @@a2@@ ) { @@v10@@ = @@v8@@ ; do { * @@v10@@ ++ = @@v5@@ ; @@v5@@ = * ( _QWORD * ) ( @@v5@@ + Number ) ; } while ( @@v5@@ ) ; } qsort ( @@v8@@ , @@a3@@ , Number , @@v7@@ ) ; @@v11@@ = ( __int64 * ) @@a1@@ [ Number ] ; @@v12@@ = @@a3@@ - Number ; @@result@@ = * @@v11@@ ; if ( @@a3@@ == Number ) { @@v17@@ = * @@v11@@ ; } else { @@v14@@ = * @@v11@@ ; for ( @@i@@ = ( __int64 * ) @@a1@@ [ Number ] ; ; @@v14@@ = * @@i@@ ) { @@v16@@ = @@i@@ [ Number ] ; ++ @@i@@ ; -- @@v12@@ ; * ( _QWORD * ) ( @@v14@@ + Number ) = @@v16@@ ; if ( ! @@v12@@ ) break ; } @@v17@@ = @@v11@@ [ @@a3@@ - Number ] ; } * ( _QWORD * ) ( @@v17@@ + Number ) = Number L ; return @@result@@ ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
unsigned __int64 __fastcall raw_hasher ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return __ROR8__ ( @@a1@@ , Number ) % @@a2@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
char * __fastcall fts_alloc ( __int64 @@a1@@ , const void * @@a2@@ , size_t @@a3@@ ) { char * @@v4@@ ; char * @@v5@@ ; __int64 @@v6@@ ; @@v4@@ = ( char * ) malloc ( @@a3@@ + Number ) ; @@v5@@ = @@v4@@ ; if ( @@v4@@ ) { memcpy ( @@v4@@ + Number , @@a2@@ , @@a3@@ ) ; @@v6@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v5@@ [ @@a3@@ + Number ] = Number ; * ( ( _QWORD * ) @@v5@@ + Number ) = @@a3@@ ; * ( ( _QWORD * ) @@v5@@ + Number ) = @@a1@@ ; * ( ( _DWORD * ) @@v5@@ + Number ) = Number ; * ( _DWORD * ) ( @@v5@@ + Number ) = Number ; * ( ( _QWORD * ) @@v5@@ + Number ) = @@v6@@ ; * ( ( _QWORD * ) @@v5@@ + Number ) = Number L ; * ( ( _QWORD * ) @@v5@@ + Number ) = Number L ; } return @@v5@@ ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
int __cdecl __noreturn main ( int @@argc@@ , const char * * @@argv@@ , const char * * envp ) { char * @@v3@@ ; __int64 @@v4@@ ; char * @@v5@@ ; __int64 @@v6@@ ; char * @@v7@@ ; int * @@v8@@ ; set_program_name ( * @@argv@@ ) ; setlocale ( Number , String ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; parse_long_options ( @@argc@@ , ( _DWORD ) @@argv@@ , ( unsigned int ) String , ( unsigned int ) & unk_3A2E , ( _DWORD ) Version , ( unsigned int ) usage , String , Number L ) ; if ( getopt_long ( @@argc@@ , ( char * const * ) @@argv@@ , String , Number L , Number L ) == Number ) { if ( optind < @@argc@@ ) { if ( optind + Number >= @@argc@@ ) { if ( unlink ( @@argv@@ [ optind ] ) ) { @@v6@@ = quote ( @@argv@@ [ optind ] ) ; @@v7@@ = dcgettext ( Number L , String , Number ) ; @@v8@@ = __errno_location ( ) ; error ( Number , * @@v8@@ , @@v7@@ , @@v6@@ ) ; } exit ( Number ) ; } @@v4@@ = quote ( @@argv@@ [ optind + Number ] ) ; @@v5@@ = dcgettext ( Number L , String , Number ) ; error ( Number , Number , @@v5@@ , @@v4@@ ) ; usage ( Number ) ; } @@v3@@ = dcgettext ( Number L , String , Number ) ; error ( Number , Number , @@v3@@ ) ; } usage ( Number ) ; }
__int64 __fastcall hash_find_entry ( __int64 * @@a1@@ , __int64 @@a2@@ , __m128i * * @@a3@@ , char @@a4@@ ) { __int64 @@v5@@ ; __m128i * @@v8@@ ; __int64 @@v9@@ ; __int64 * @@v10@@ ; const __m128i * @@v12@@ ; @@v5@@ = * @@a1@@ ; @@v8@@ = ( __m128i * ) ( Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) + @@v5@@ ) ; if ( @@a1@@ [ Number ] <= ( unsigned __int64 ) @@v8@@ ) abort ( ) ; * @@a3@@ = @@v8@@ ; @@v9@@ = @@v8@@ -> m128i_i64 [ Number ] ; if ( @@v8@@ -> m128i_i64 [ Number ] ) { if ( @@v9@@ != @@a2@@ ) { if ( ! ( ( unsigned __int8 ( __fastcall * ) ( __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ ) ) { @@v10@@ = ( __int64 * ) @@v8@@ -> m128i_i64 [ Number ] ; if ( @@v10@@ ) { @@v9@@ = * @@v10@@ ; if ( @@a2@@ != * @@v10@@ ) { while ( ! ( ( unsigned __int8 ( __fastcall * ) ( __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ ) ) { @@v8@@ = ( __m128i * ) @@v8@@ -> m128i_i64 [ Number ] ; @@v10@@ = ( __int64 * ) @@v8@@ -> m128i_i64 [ Number ] ; if ( ! @@v10@@ ) return Number L ; @@v9@@ = * @@v10@@ ; if ( * @@v10@@ == @@a2@@ ) goto LABEL_12 ; } @@v10@@ = ( __int64 * ) @@v8@@ -> m128i_i64 [ Number ] ; @@v9@@ = * @@v10@@ ; } LABEL_12 : if ( @@a4@@ ) { @@v8@@ -> m128i_i64 [ Number ] = @@v10@@ [ Number ] ; * @@v10@@ = Number L ; @@v10@@ [ Number ] = @@a1@@ [ Number ] ; @@a1@@ [ Number ] = ( __int64 ) @@v10@@ ; } return @@v9@@ ; } return Number L ; } @@v9@@ = @@v8@@ -> m128i_i64 [ Number ] ; } if ( @@a4@@ ) { @@v12@@ = ( const __m128i * ) @@v8@@ -> m128i_i64 [ Number ] ; if ( @@v12@@ ) { * @@v8@@ = _mm_loadu_si128 ( @@v12@@ ) ; @@v12@@ -> m128i_i64 [ Number ] = Number L ; @@v12@@ -> m128i_i64 [ Number ] = @@a1@@ [ Number ] ; @@a1@@ [ Number ] = ( __int64 ) @@v12@@ ; return @@v9@@ ; } @@v8@@ -> m128i_i64 [ Number ] = Number L ; } return @@v9@@ ; } return Number L ; }
bool __fastcall setup_dir_isra_4 ( __int16 @@a1@@ , __int64 * @@a2@@ ) { __int64 @@v2@@ ; bool @@result@@ ; void * @@v4@@ ; if ( ( @@a1@@ & Number ) != Number ) { @@v2@@ = hash_initialize ( Number L , Number L , AD_hash , AD_compare , & free ) ; * @@a2@@ = @@v2@@ ; @@result@@ = @@v2@@ != Number ; } else { @@v4@@ = malloc ( Number ) ; * @@a2@@ = ( __int64 ) @@v4@@ ; @@result@@ = Number ; if ( @@v4@@ ) { cycle_check_init ( ) ; @@result@@ = Number ; } } return @@result@@ ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
__int64 __fastcall hash_reset_tuning ( __int64 @@a1@@ ) { __int64 @@result@@ ; * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; * ( _QWORD * ) @@a1@@ = Number ; @@result@@ = Number ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number ; return @@result@@ ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
unsigned __int64 __fastcall leave_dir_isra_14 ( __int16 @@a1@@ , __int64 * * @@a2@@ , _QWORD * @@a3@@ ) { __int64 * @@v3@@ ; __int64 * @@v4@@ ; __int64 * @@v6@@ ; void * @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v11@@ = __readfsqword ( Number ) ; if ( ( @@a1@@ & Number ) != Number ) { @@v6@@ = * @@a2@@ ; @@v10@@ [ Number ] = @@a3@@ [ Number ] ; @@v10@@ [ Number ] = @@a3@@ [ Number ] ; @@v7@@ = ( void * ) hash_delete ( @@v6@@ , @@v10@@ ) ; if ( @@v7@@ ) { free ( @@v7@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; } goto LABEL_11 ; } @@v3@@ = ( __int64 * ) @@a3@@ [ Number ] ; if ( ! @@v3@@ || @@v3@@ [ Number ] < Number ) return __readfsqword ( Number ) ^ @@v11@@ ; @@v4@@ = * @@a2@@ ; if ( ! ( * @@a2@@ ) [ Number ] ) LABEL_11 : abort ( ) ; if ( * @@v4@@ == @@a3@@ [ Number ] && @@v4@@ [ Number ] == @@a3@@ [ Number ] ) { @@v8@@ = @@v3@@ [ Number ] ; @@v9@@ = @@v3@@ [ Number ] ; @@v4@@ [ Number ] = @@v8@@ ; * @@v4@@ = @@v9@@ ; } return __readfsqword ( Number ) ^ @@v11@@ ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_20D1F0 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20D1D0 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20D1E0 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
void __fastcall hash_clear ( _QWORD * @@a1@@ ) { _QWORD * @@v1@@ ; _QWORD * @@v2@@ ; void ( __fastcall * @@v3@@ ) ( _QWORD ) ; _QWORD * @@v4@@ ; __int64 @@v5@@ ; @@v1@@ = ( _QWORD * ) * @@a1@@ ; if ( * @@a1@@ < @@a1@@ [ Number ] ) { do { if ( * @@v1@@ ) { @@v2@@ = ( _QWORD * ) @@v1@@ [ Number ] ; @@v3@@ = ( void ( __fastcall * ) ( _QWORD ) ) @@a1@@ [ Number ] ; if ( @@v2@@ ) { do { if ( @@v3@@ ) { @@v3@@ ( * @@v2@@ ) ; @@v3@@ = ( void ( __fastcall * ) ( _QWORD ) ) @@a1@@ [ Number ] ; } @@v4@@ = ( _QWORD * ) @@v2@@ [ Number ] ; @@v5@@ = @@a1@@ [ Number ] ; * @@v2@@ = Number L ; @@v2@@ [ Number ] = @@v5@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v2@@ = @@v4@@ ; } while ( @@v4@@ ) ; } if ( @@v3@@ ) @@v3@@ ( * @@v1@@ ) ; * @@v1@@ = Number L ; @@v1@@ [ Number ] = Number L ; } @@v1@@ += Number ; } while ( @@a1@@ [ Number ] > ( unsigned __int64 ) @@v1@@ ) ; } @@a1@@ [ Number ] = Number L ; @@a1@@ [ Number ] = Number L ; }
__int64 __fastcall freadahead ( __int64 @@a1@@ ) { __int64 @@result@@ ; @@result@@ = Number L ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= * ( _QWORD * ) ( @@a1@@ + Number ) ) { @@result@@ = * ( _QWORD * ) ( @@a1@@ + Number ) - * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( ( * ( _DWORD * ) @@a1@@ & Number ) != Number ) @@result@@ += * ( _QWORD * ) ( @@a1@@ + Number ) - * ( _QWORD * ) ( @@a1@@ + Number ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
bool __fastcall hash_table_ok ( __int64 @@a1@@ ) { _QWORD * @@v1@@ ; unsigned __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; bool @@result@@ ; @@v1@@ = * ( _QWORD * * ) @@a1@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v3@@ = Number L ; @@v4@@ = Number L ; if ( * ( _QWORD * ) @@a1@@ < @@v2@@ ) { do { if ( * @@v1@@ ) { @@v5@@ = @@v1@@ [ Number ] ; ++ @@v4@@ ; ++ @@v3@@ ; for ( ; @@v5@@ ; ++ @@v3@@ ) @@v5@@ = * ( _QWORD * ) ( @@v5@@ + Number ) ; } @@v1@@ += Number ; } while ( ( unsigned __int64 ) @@v1@@ < @@v2@@ ) ; } @@result@@ = Number ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) == @@v4@@ ) @@result@@ = * ( _QWORD * ) ( @@a1@@ + Number ) == @@v3@@ ; return @@result@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
__int64 __fastcall open_safer ( const char * @@a1@@ , char @@a2@@ , unsigned int @@a3@@ ) { __int64 @@v3@@ ; int @@v4@@ ; @@v3@@ = Number L ; if ( ( @@a2@@ & Number ) != Number ) @@v3@@ = @@a3@@ ; @@v4@@ = open ( @@a1@@ , @@a2@@ , @@v3@@ ) ; return fd_safer ( @@v4@@ ) ; }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
int unlink ( const char * @@name@@ ) { return unlink ( @@name@@ ) ; }
unsigned __int64 __fastcall hash_get_entries ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { _QWORD * @@v3@@ ; unsigned __int64 @@v4@@ ; _QWORD * @@v5@@ ; unsigned __int64 @@result@@ ; @@v3@@ = * ( _QWORD * * ) @@a1@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= * ( _QWORD * ) @@a1@@ ) return Number L ; @@v4@@ = Number L ; while ( ! * @@v3@@ ) { LABEL_9 : @@v3@@ += Number ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= ( unsigned __int64 ) @@v3@@ ) return @@v4@@ ; } if ( @@a3@@ <= @@v4@@ ) return @@v4@@ ; * ( _QWORD * ) ( @@a2@@ + Number * @@v4@@ ) = * @@v3@@ ; @@v5@@ = ( _QWORD * ) @@v3@@ [ Number ] ; @@result@@ = @@v4@@ + Number ; if ( ! @@v5@@ ) { LABEL_8 : @@v4@@ = @@result@@ ; goto LABEL_9 ; } while ( @@a3@@ != @@result@@ ) { ++ @@result@@ ; * ( _QWORD * ) ( @@a2@@ + Number * @@result@@ - Number ) = * @@v5@@ ; @@v5@@ = ( _QWORD * ) @@v5@@ [ Number ] ; if ( ! @@v5@@ ) goto LABEL_8 ; } return @@result@@ ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
bool __fastcall cycle_warning_required ( __int64 @@a1@@ , __int64 @@a2@@ ) { bool @@result@@ ; int @@v3@@ ; @@result@@ = Number ; @@v3@@ = * ( _DWORD * ) ( @@a1@@ + Number ) & Number ; if ( @@v3@@ != Number ) { @@result@@ = Number ; if ( @@v3@@ == Number ) @@result@@ = * ( _QWORD * ) ( @@a2@@ + Number ) != Number L ; } return @@result@@ ; }
__int64 __fastcall i_ring_empty ( __int64 @@a1@@ ) { return * ( unsigned __int8 * ) ( @@a1@@ + Number ) ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
__int64 __fastcall cycle_check ( __int64 @@a1@@ , __int64 * @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@result@@ ; __int64 @@v5@@ ; if ( * ( _DWORD * ) ( @@a1@@ + Number ) != Number ) __assert_fail ( String , String , Number , String ) ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v3@@ = @@a2@@ [ Number ] ; if ( ! @@v2@@ ) { * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; goto LABEL_7 ; } if ( * ( _QWORD * ) @@a1@@ == @@v3@@ && * @@a2@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ) { return Number L ; } @@result@@ = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v2@@ + Number ; if ( ( ( @@v2@@ + Number ) & @@v2@@ ) == Number ) { if ( @@v2@@ == Number ) return Number L ; LABEL_7 : @@v5@@ = * @@a2@@ ; * ( _QWORD * ) @@a1@@ = @@v3@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v5@@ ; @@result@@ = Number L ; } return @@result@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
int closedir ( DIR * @@dirp@@ ) { return closedir ( @@dirp@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
__int64 __fastcall i_ring_push ( __int64 @@a1@@ , int @@a2@@ ) { char @@v2@@ ; int @@v3@@ ; _DWORD * @@v4@@ ; __int64 @@result@@ ; int @@v6@@ ; @@v2@@ = * ( _BYTE * ) ( @@a1@@ + Number ) ^ Number ; @@v3@@ = ( @@v2@@ + ( unsigned __int8 ) * ( _DWORD * ) ( @@a1@@ + Number ) ) & Number ; @@v4@@ = ( _DWORD * ) ( @@a1@@ + Number L * ( ( @@v2@@ + ( unsigned __int8 ) * ( _DWORD * ) ( @@a1@@ + Number ) ) & Number ) ) ; @@result@@ = ( unsigned int ) * @@v4@@ ; * @@v4@@ = @@a2@@ ; @@v6@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@v3@@ ; if ( @@v6@@ == @@v3@@ ) * ( _DWORD * ) ( @@a1@@ + Number ) = ( ( _BYTE ) @@v6@@ + @@v2@@ ) & Number ; * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; return @@result@@ ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
int fileno ( FILE * @@stream@@ ) { return fileno ( @@stream@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int64 __fastcall openat_safer ( int @@a1@@ , const char * @@a2@@ , char @@a3@@ , unsigned int @@a4@@ ) { __int64 @@v4@@ ; int @@v5@@ ; @@v4@@ = Number L ; if ( ( @@a3@@ & Number ) != Number ) @@v4@@ = @@a4@@ ; @@v5@@ = openat ( @@a1@@ , @@a2@@ , @@a3@@ , @@v4@@ ) ; return fd_safer ( @@v5@@ ) ; }
DIR * fdopendir ( int @@fd@@ ) { return fdopendir ( @@fd@@ ) ; }
__int64 __fastcall xfts_open ( const char * * @@a1@@ , int @@a2@@ , __int64 @@a3@@ ) { __int64 @@result@@ ; @@result@@ = fts_open ( @@a1@@ , @@a2@@ | Number , @@a3@@ ) ; if ( ! @@result@@ ) { if ( * __errno_location ( ) != Number ) xalloc_die ( ) ; __assert_fail ( String , String , Number , String ) ; } return @@result@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; FILE * @@v11@@ ; char * @@v12@@ ; FILE * @@v13@@ ; char * @@v14@@ ; FILE * @@v15@@ ; char * @@v16@@ ; FILE * @@v17@@ ; char * @@v18@@ ; FILE * @@v19@@ ; char * @@v20@@ ; FILE * @@v21@@ ; char * @@v22@@ ; char * @@v23@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String String String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = stdout ; @@v10@@ = dcgettext ( Number L , String String , Number ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; @@v11@@ = stdout ; @@v12@@ = dcgettext ( Number L , String String String , Number ) ; fputs_unlocked ( @@v12@@ , @@v11@@ ) ; @@v13@@ = stdout ; @@v14@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v14@@ , @@v13@@ ) ; @@v15@@ = stdout ; @@v16@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v16@@ , @@v15@@ ) ; @@v17@@ = stdout ; @@v18@@ = dcgettext ( Number L , String String String String , Number ) ; fputs_unlocked ( @@v18@@ , @@v17@@ ) ; @@v19@@ = stdout ; @@v20@@ = dcgettext ( Number L , String String String String String String String String , Number ) ; fputs_unlocked ( @@v20@@ , @@v19@@ ) ; last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v21@@ = stdout ; @@v22@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v22@@ , @@v21@@ ) ; @@v23@@ = setlocale ( Number , Number L ) ; if ( @@v23@@ ) { if ( strncmp ( @@v23@@ , String , Number ) ) { last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
__int64 __fastcall dup_cloexec ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
void __fastcall cycle_check_init ( __int64 @@a1@@ ) { * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _DWORD * ) ( @@a1@@ + Number ) = Number ; }
unsigned __int64 __fastcall triple_hash_no_name ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) % @@a2@@ ; }
__int64 __fastcall dup_safer ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall hash_find_entry ( __int64 * @@a1@@ , __int64 @@a2@@ , __m128i * * @@a3@@ , char @@a4@@ ) { __int64 @@v5@@ ; __m128i * @@v8@@ ; __int64 @@v9@@ ; __int64 * @@v10@@ ; const __m128i * @@v12@@ ; @@v5@@ = * @@a1@@ ; @@v8@@ = ( __m128i * ) ( Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) + @@v5@@ ) ; if ( @@a1@@ [ Number ] <= ( unsigned __int64 ) @@v8@@ ) abort ( ) ; * @@a3@@ = @@v8@@ ; @@v9@@ = @@v8@@ -> m128i_i64 [ Number ] ; if ( @@v8@@ -> m128i_i64 [ Number ] ) { if ( @@v9@@ != @@a2@@ ) { if ( ! ( ( unsigned __int8 ( __fastcall * ) ( __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ ) ) { @@v10@@ = ( __int64 * ) @@v8@@ -> m128i_i64 [ Number ] ; if ( @@v10@@ ) { @@v9@@ = * @@v10@@ ; if ( @@a2@@ != * @@v10@@ ) { while ( ! ( ( unsigned __int8 ( __fastcall * ) ( __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ ) ) { @@v8@@ = ( __m128i * ) @@v8@@ -> m128i_i64 [ Number ] ; @@v10@@ = ( __int64 * ) @@v8@@ -> m128i_i64 [ Number ] ; if ( ! @@v10@@ ) return Number L ; @@v9@@ = * @@v10@@ ; if ( * @@v10@@ == @@a2@@ ) goto LABEL_12 ; } @@v10@@ = ( __int64 * ) @@v8@@ -> m128i_i64 [ Number ] ; @@v9@@ = * @@v10@@ ; } LABEL_12 : if ( @@a4@@ ) { @@v8@@ -> m128i_i64 [ Number ] = @@v10@@ [ Number ] ; * @@v10@@ = Number L ; @@v10@@ [ Number ] = @@a1@@ [ Number ] ; @@a1@@ [ Number ] = ( __int64 ) @@v10@@ ; } return @@v9@@ ; } return Number L ; } @@v9@@ = @@v8@@ -> m128i_i64 [ Number ] ; } if ( @@a4@@ ) { @@v12@@ = ( const __m128i * ) @@v8@@ -> m128i_i64 [ Number ] ; if ( @@v12@@ ) { * @@v8@@ = _mm_loadu_si128 ( @@v12@@ ) ; @@v12@@ -> m128i_i64 [ Number ] = Number L ; @@v12@@ -> m128i_i64 [ Number ] = @@a1@@ [ Number ] ; @@a1@@ [ Number ] = ( __int64 ) @@v12@@ ; return @@v9@@ ; } @@v8@@ -> m128i_i64 [ Number ] = Number L ; } return @@v9@@ ; } return Number L ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
__int64 __fastcall triple_compare ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { __int64 @@result@@ ; @@result@@ = Number L ; if ( @@a1@@ [ Number ] == @@a2@@ [ Number ] && @@a1@@ [ Number ] == @@a2@@ [ Number ] ) { @@result@@ = same_name ( * @@a1@@ , * @@a2@@ ) ; } return @@result@@ ; }
__int64 __fastcall rpl_fcntl ( int @@a1@@ , int @@a2@@ , __int64 @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { int @@v6@@ ; int @@v8@@ ; int @@v9@@ ; int @@v10@@ ; int @@v11@@ ; int * @@v12@@ ; int @@v13@@ ; int * @@v14@@ ; int @@v15@@ ; @@v15@@ = @@a3@@ ; if ( @@a2@@ != Number ) return ( unsigned int ) fcntl ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( have_dupfd_cloexec_3202 < Number ) { @@v6@@ = rpl_fcntl ( @@a1@@ , Number , ( unsigned int ) @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( @@v6@@ < Number || have_dupfd_cloexec_3202 != Number ) return ( unsigned int ) @@v6@@ ; } else { @@v6@@ = fcntl ( @@a1@@ , Number , ( unsigned int ) @@a3@@ ) ; if ( @@v6@@ >= Number || * __errno_location ( ) != Number ) { have_dupfd_cloexec_3202 = Number ; return ( unsigned int ) @@v6@@ ; } @@v6@@ = rpl_fcntl ( @@a1@@ , Number , @@v15@@ , @@v8@@ , @@v9@@ , @@v10@@ ) ; if ( @@v6@@ < Number ) return ( unsigned int ) @@v6@@ ; have_dupfd_cloexec_3202 = Number ; } @@v11@@ = fcntl ( @@v6@@ , Number ) ; if ( @@v11@@ < Number || fcntl ( @@v6@@ , Number , @@v11@@ | Number ) == Number ) { @@v12@@ = __errno_location ( ) ; @@v13@@ = * @@v12@@ ; @@v14@@ = @@v12@@ ; close ( @@v6@@ ) ; @@v6@@ = Number ; * @@v14@@ = @@v13@@ ; } return ( unsigned int ) @@v6@@ ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; program_invocation_short_name = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; char * @@v9@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = setlocale ( Number , Number L ) ; if ( @@v9@@ ) { if ( strncmp ( @@v9@@ , String , Number ) ) { last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall get_version ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; if ( @@a2@@ && * ( _BYTE * ) @@a2@@ ) @@result@@ = get_version_part_0 ( @@a1@@ , @@a2@@ ) ; else @@result@@ = Number L ; return @@result@@ ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall xget_version ( void * @@a1@@ , char * @@a2@@ ) { char * @@v2@@ ; if ( @@a2@@ && * @@a2@@ ) return get_version_part_0 ( ( __int64 ) @@a1@@ , ( __int64 ) @@a2@@ ) ; @@v2@@ = getenv ( String ) ; if ( @@v2@@ && * @@v2@@ ) { @@a1@@ = & unk_8920 ; @@a2@@ = @@v2@@ ; return get_version_part_0 ( ( __int64 ) @@a1@@ , ( __int64 ) @@a2@@ ) ; } return Number L ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__int64 __fastcall file_name_concat ( void * @@a1@@ , void * @@a2@@ ) { __int64 @@result@@ ; @@result@@ = mfile_name_concat ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
__int64 __fastcall umaxtostr ( unsigned __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; @@v2@@ = @@a2@@ + Number ; * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; do { * ( _BYTE * ) -- @@v2@@ = @@a1@@ % Number + Number ; @@a1@@ /= Number ; } while ( @@a1@@ ) ; return @@v2@@ ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_2061F0 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061D0 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_2061E0 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
unsigned __int64 __fastcall next_prime ( unsigned __int64 @@a1@@ ) { unsigned __int64 @@v1@@ ; unsigned __int64 @@v2@@ ; __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; if ( @@a1@@ < Number ) @@a1@@ = Number L ; @@v1@@ = @@a1@@ | Number ; if ( @@v1@@ != Number ) { while ( Number ) { @@v2@@ = @@v1@@ % Number ; if ( @@v1@@ <= Number ) goto LABEL_9 ; if ( @@v1@@ % Number ) break ; LABEL_10 : @@v1@@ += Number L ; if ( @@v1@@ == Number ) return @@v1@@ ; } @@v3@@ = Number L ; @@v4@@ = Number L ; @@v5@@ = Number L ; while ( Number ) { @@v5@@ += Number L ; @@v4@@ += @@v3@@ ; @@v2@@ = @@v1@@ % @@v5@@ ; if ( @@v4@@ >= @@v1@@ ) break ; @@v3@@ += Number L ; if ( ! ( @@v1@@ % @@v5@@ ) ) goto LABEL_10 ; } LABEL_9 : if ( @@v2@@ ) return @@v1@@ ; goto LABEL_10 ; } return @@v1@@ ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
bool __fastcall hash_table_ok ( __int64 @@a1@@ ) { _QWORD * @@v1@@ ; unsigned __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; bool @@result@@ ; @@v1@@ = * ( _QWORD * * ) @@a1@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v3@@ = Number L ; @@v4@@ = Number L ; if ( * ( _QWORD * ) @@a1@@ < @@v2@@ ) { do { if ( * @@v1@@ ) { @@v5@@ = @@v1@@ [ Number ] ; ++ @@v4@@ ; ++ @@v3@@ ; for ( ; @@v5@@ ; ++ @@v3@@ ) @@v5@@ = * ( _QWORD * ) ( @@v5@@ + Number ) ; } @@v1@@ += Number ; } while ( ( unsigned __int64 ) @@v1@@ < @@v2@@ ) ; } @@result@@ = Number ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) == @@v4@@ ) @@result@@ = * ( _QWORD * ) ( @@a1@@ + Number ) == @@v3@@ ; return @@result@@ ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
int __fastcall rpl_fseeko ( FILE * @@stream@@ , __off_t @@offset@@ , int @@whence@@ ) { int @@v5@@ ; int @@v6@@ ; if ( @@stream@@ -> _IO_read_end != @@stream@@ -> _IO_read_ptr || @@stream@@ -> _IO_write_ptr != @@stream@@ -> _IO_write_base || @@stream@@ -> _IO_save_base ) { return fseeko ( @@stream@@ , @@offset@@ , @@whence@@ ) ; } if ( @@whence@@ == Number && @@offset@@ > Number ) { @@v5@@ = fileno ( @@stream@@ ) ; if ( lseek ( @@v5@@ , Number L , Number ) != Number ) { @@stream@@ -> _flags &= Number ; return fseeko ( @@stream@@ , @@offset@@ , @@whence@@ ) ; } } else { @@v6@@ = fileno ( @@stream@@ ) ; if ( lseek ( @@v6@@ , @@offset@@ , @@whence@@ ) != Number ) { @@stream@@ -> _flags &= Number ; return Number ; } } return Number ; }
__int64 __fastcall hash_get_next ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; __int64 * @@v6@@ ; _QWORD * @@v7@@ ; __int64 @@v8@@ ; __int64 @@result@@ ; @@v2@@ = * @@a1@@ ; @@v4@@ = ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) ; @@v5@@ = @@a1@@ [ Number ] ; @@v6@@ = ( __int64 * ) ( @@v2@@ + Number * @@v4@@ ) ; if ( @@v5@@ <= ( unsigned __int64 ) @@v6@@ ) abort ( ) ; if ( ! @@v6@@ ) goto LABEL_10 ; @@v7@@ = ( _QWORD * ) @@v6@@ [ Number ] ; if ( * @@v6@@ != @@a2@@ ) { do { if ( ! @@v7@@ ) goto LABEL_10 ; @@v8@@ = * @@v7@@ ; @@v7@@ = ( _QWORD * ) @@v7@@ [ Number ] ; } while ( @@v8@@ != @@a2@@ ) ; } if ( @@v7@@ ) return * @@v7@@ ; LABEL_10 : while ( Number ) { @@v6@@ += Number ; if ( @@v5@@ <= ( unsigned __int64 ) @@v6@@ ) break ; @@result@@ = * @@v6@@ ; if ( * @@v6@@ ) return @@result@@ ; } return Number L ; }
int ferror ( FILE * @@stream@@ ) { return ferror ( @@stream@@ ) ; }
int unlink ( const char * @@name@@ ) { return unlink ( @@name@@ ) ; }
__int64 __fastcall mark_range_start ( __int64 @@a1@@ ) { __int64 @@result@@ ; @@result@@ = hash_insert ( range_start_ht , @@a1@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; if ( @@result@@ != @@a1@@ ) __assert_fail ( String , String , Number , String ) ; return @@result@@ ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
void __fastcall hash_clear ( _QWORD * @@a1@@ ) { _QWORD * @@v1@@ ; _QWORD * @@v2@@ ; void ( __fastcall * @@v3@@ ) ( _QWORD ) ; _QWORD * @@v4@@ ; __int64 @@v5@@ ; @@v1@@ = ( _QWORD * ) * @@a1@@ ; if ( * @@a1@@ < @@a1@@ [ Number ] ) { do { if ( * @@v1@@ ) { @@v2@@ = ( _QWORD * ) @@v1@@ [ Number ] ; @@v3@@ = ( void ( __fastcall * ) ( _QWORD ) ) @@a1@@ [ Number ] ; if ( @@v2@@ ) { do { if ( @@v3@@ ) { @@v3@@ ( * @@v2@@ ) ; @@v3@@ = ( void ( __fastcall * ) ( _QWORD ) ) @@a1@@ [ Number ] ; } @@v4@@ = ( _QWORD * ) @@v2@@ [ Number ] ; @@v5@@ = @@a1@@ [ Number ] ; * @@v2@@ = Number L ; @@v2@@ [ Number ] = @@v5@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v2@@ = @@v4@@ ; } while ( @@v4@@ ) ; } if ( @@v3@@ ) @@v3@@ ( * @@v1@@ ) ; * @@v1@@ = Number L ; @@v1@@ [ Number ] = Number L ; } @@v1@@ += Number ; } while ( @@a1@@ [ Number ] > ( unsigned __int64 ) @@v1@@ ) ; } @@a1@@ [ Number ] = Number L ; @@a1@@ [ Number ] = Number L ; }
void clearerr_unlocked ( FILE * @@stream@@ ) { clearerr_unlocked ( @@stream@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
DIR * opendir ( const char * @@name@@ ) { return opendir ( @@name@@ ) ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
int rpmatch ( const char * @@response@@ ) { return rpmatch ( @@response@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
int __xstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _xstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
int __freading ( FILE * @@fp@@ ) { return _freading ( @@fp@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; __m128i * @@v10@@ ; __int64 @@v11@@ ; unsigned __int64 * @@v12@@ ; _BYTE * @@v13@@ ; unsigned __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; _BYTE * @@v16@@ ; unsigned __int64 @@v19@@ ; int @@v20@@ ; int @@v21@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v20@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = Number * @@v8@@ ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v9@@ , @@v8@@ ) ; slotvec = @@v7@@ ; @@v11@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v10@@ = ( __m128i * ) xrealloc ( slotvec , @@v9@@ , @@v8@@ ) ; @@v11@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v10@@ ; slotvec = @@v10@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v11@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v12@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v13@@ = ( _BYTE * ) @@v12@@ [ Number ] ; @@v21@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v19@@ = * @@v12@@ ; @@v14@@ = quotearg_buffer_restyled ( @@v13@@ , * @@v12@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v21@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v19@@ <= @@v14@@ ) { @@v15@@ = @@v14@@ + Number ; * @@v12@@ = @@v14@@ + Number ; if ( @@v13@@ != ( _BYTE * ) & slot0 ) free ( @@v13@@ ) ; @@v16@@ = ( _BYTE * ) xmalloc ( @@v15@@ ) ; @@v12@@ [ Number ] = ( unsigned __int64 ) @@v16@@ ; @@v13@@ = @@v16@@ ; quotearg_buffer_restyled ( @@v16@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v21@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v20@@ ; return @@v13@@ ; }
bool __fastcall seen_file ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 * @@a3@@ ) { bool @@result@@ ; __int64 @@v4@@ ; __int64 @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; @@result@@ = Number ; if ( @@a1@@ ) { @@v4@@ = @@a3@@ [ Number ] ; @@v5@@ [ Number ] = @@a2@@ ; @@v5@@ [ Number ] = @@v4@@ ; @@v5@@ [ Number ] = * @@a3@@ ; @@result@@ = hash_lookup ( @@a1@@ , @@v5@@ ) != Number ; } return @@result@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
void __fastcall triple_free ( void * @@ptr@@ ) { free ( * ( void * * ) @@ptr@@ ) ; free ( @@ptr@@ ) ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
char * __fastcall xstrndup ( const char * @@a1@@ , size_t @@a2@@ ) { char * @@result@@ ; @@result@@ = strndup ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
unsigned __int64 __fastcall raw_hasher ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return __ROR8__ ( @@a1@@ , Number ) % @@a2@@ ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
__int64 __fastcall hash_get_n_buckets ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
__int64 __fastcall same_name ( _BYTE * @@a1@@ , _BYTE * @@a2@@ ) { unsigned int @@v2@@ ; const char * @@v3@@ ; const char * @@v4@@ ; size_t @@v5@@ ; char * @@v7@@ ; char * @@v8@@ ; int * @@v9@@ ; int * @@v10@@ ; struct stat @@v11@@ ; struct stat @@stat_buf@@ ; unsigned __int64 @@v13@@ ; @@v2@@ = Number ; @@v13@@ = __readfsqword ( Number ) ; @@v3@@ = last_component ( @@a1@@ ) ; @@v4@@ = last_component ( @@a2@@ ) ; @@v5@@ = base_len ( @@v3@@ ) ; if ( @@v5@@ == base_len ( @@v4@@ ) && ! memcmp ( @@v3@@ , @@v4@@ , @@v5@@ ) ) { @@v7@@ = ( char * ) dir_name ( @@a1@@ ) ; @@v8@@ = ( char * ) dir_name ( @@a2@@ ) ; if ( __xstat ( Number , @@v7@@ , & @@v11@@ ) ) { @@v10@@ = __errno_location ( ) ; error ( Number , * @@v10@@ , String , @@v7@@ ) ; } if ( __xstat ( Number , @@v8@@ , & @@stat_buf@@ ) ) { @@v9@@ = __errno_location ( ) ; error ( Number , * @@v9@@ , String , @@v8@@ ) ; } @@v2@@ = Number ; if ( @@v11@@ . st_ino == @@stat_buf@@ . st_ino ) LOBYTE ( @@v2@@ ) = @@v11@@ . st_dev == @@stat_buf@@ . st_dev ; free ( @@v7@@ ) ; free ( @@v8@@ ) ; } return @@v2@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
__int64 __fastcall hash_get_n_buckets_used ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
__int64 yesno ( ) { unsigned int @@v0@@ ; __ssize_t @@v1@@ ; char * @@lineptr@@ ; size_t @@n@@ [ Number ] ; @@v0@@ = Number ; @@lineptr@@ = Number L ; @@n@@ [ Number ] = __readfsqword ( Number ) ; @@n@@ [ Number ] = Number L ; @@v1@@ = __getdelim ( & @@lineptr@@ , @@n@@ , Number , stdin ) ; if ( @@v1@@ > Number ) { @@lineptr@@ [ @@v1@@ - Number ] = Number ; LOBYTE ( @@v0@@ ) = rpmatch ( @@lineptr@@ ) > Number ; } free ( @@lineptr@@ ) ; return @@v0@@ ; }
unsigned __int64 __fastcall next_prime ( unsigned __int64 @@a1@@ ) { unsigned __int64 @@v1@@ ; unsigned __int64 @@v2@@ ; __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; if ( @@a1@@ < Number ) @@a1@@ = Number L ; @@v1@@ = @@a1@@ | Number ; if ( @@v1@@ != Number ) { while ( Number ) { @@v2@@ = @@v1@@ % Number ; if ( @@v1@@ <= Number ) goto LABEL_9 ; if ( @@v1@@ % Number ) break ; LABEL_10 : @@v1@@ += Number L ; if ( @@v1@@ == Number ) return @@v1@@ ; } @@v3@@ = Number L ; @@v4@@ = Number L ; @@v5@@ = Number L ; while ( Number ) { @@v5@@ += Number L ; @@v4@@ += @@v3@@ ; @@v2@@ = @@v1@@ % @@v5@@ ; if ( @@v4@@ >= @@v1@@ ) break ; @@v3@@ += Number L ; if ( ! ( @@v1@@ % @@v5@@ ) ) goto LABEL_10 ; } LABEL_9 : if ( @@v2@@ ) return @@v1@@ ; goto LABEL_10 ; } return @@v1@@ ; }
__int64 __fastcall hash_get_n_entries ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
void __fastcall close_stdin_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
void __fastcall argmatch_invalid ( __int64 @@a1@@ , wchar_t * @@a2@@ , __int64 @@a3@@ ) { char * @@v3@@ ; __int64 @@v4@@ ; _BYTE * @@v5@@ ; if ( @@a3@@ == Number ) @@v3@@ = dcgettext ( Number L , String , Number ) ; else @@v3@@ = dcgettext ( Number L , String , Number ) ; @@v4@@ = quote_n ( Number L , @@a1@@ ) ; @@v5@@ = quotearg_n_style ( Number , Number , @@a2@@ ) ; error ( Number , Number , @@v3@@ , @@v5@@ , @@v4@@ ) ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
__int64 __fastcall hash_lookup ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; _QWORD * @@v4@@ ; __int64 @@v5@@ ; @@v2@@ = * @@a1@@ ; @@v4@@ = ( _QWORD * ) ( Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) + @@v2@@ ) ; if ( @@a1@@ [ Number ] <= ( unsigned __int64 ) @@v4@@ ) abort ( ) ; @@v5@@ = * @@v4@@ ; if ( ! * @@v4@@ ) return Number L ; while ( @@v5@@ != @@a2@@ ) { if ( ( ( unsigned __int8 ( __fastcall * ) ( __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ ) ) return * @@v4@@ ; @@v4@@ = ( _QWORD * ) @@v4@@ [ Number ] ; if ( ! @@v4@@ ) return Number L ; @@v5@@ = * @@v4@@ ; } return @@v5@@ ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name_0 = @@a1@@ ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
unsigned __int64 __fastcall hash_string ( unsigned __int8 * @@a1@@ , unsigned __int64 @@a2@@ ) { __int64 @@v2@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@v4@@ ; @@v2@@ = * @@a1@@ ; for ( @@i@@ = Number L ; ( _BYTE ) @@v2@@ ; @@i@@ = @@v4@@ % @@a2@@ ) { ++ @@a1@@ ; @@v4@@ = @@v2@@ + Number * @@i@@ ; @@v2@@ = * @@a1@@ ; } return @@i@@ ; }
int __fastcall argmatch_valid ( _QWORD * @@a1@@ , char * @@a2@@ , size_t @@a3@@ ) { const void * @@v5@@ ; __int64 @@v6@@ ; char * @@v7@@ ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; if ( * @@a1@@ ) { @@v5@@ = Number L ; @@v6@@ = Number L ; do { while ( ! @@v6@@ || memcmp ( @@v5@@ , @@a2@@ , @@a3@@ ) ) { ++ @@v6@@ ; @@v5@@ = @@a2@@ ; __fprintf_chk ( ) ; @@a2@@ += @@a3@@ ; if ( ! @@a1@@ [ @@v6@@ ] ) goto LABEL_7 ; } ++ @@v6@@ ; @@a2@@ += @@a3@@ ; __fprintf_chk ( ) ; } while ( @@a1@@ [ @@v6@@ ] ) ; } LABEL_7 : @@v7@@ = stderr -> _IO_write_ptr ; if ( @@v7@@ >= stderr -> _IO_write_end ) { LODWORD ( @@v7@@ ) = __overflow ( stderr , Number ) ; } else { stderr -> _IO_write_ptr = @@v7@@ + Number ; * @@v7@@ = Number ; } return ( int ) @@v7@@ ; }
unsigned __int64 __fastcall hash_get_max_bucket_length ( __int64 @@a1@@ ) { _QWORD * @@v1@@ ; unsigned __int64 @@v2@@ ; unsigned __int64 @@result@@ ; __int64 @@v4@@ ; unsigned __int64 @@i@@ ; @@v1@@ = * ( _QWORD * * ) @@a1@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; for ( @@result@@ = Number L ; ( unsigned __int64 ) @@v1@@ < @@v2@@ ; @@v1@@ += Number ) { if ( * @@v1@@ ) { @@v4@@ = @@v1@@ [ Number ] ; for ( @@i@@ = Number L ; @@v4@@ ; ++ @@i@@ ) @@v4@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; if ( @@result@@ < @@i@@ ) @@result@@ = @@i@@ ; } } return @@result@@ ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
int __fastcall rpl_fflush ( FILE * @@stream@@ ) { if ( ! @@stream@@ || ! __freading ( @@stream@@ ) || ( @@stream@@ -> _flags & Number ) == Number ) { return fflush ( @@stream@@ ) ; } rpl_fseeko ( @@stream@@ , Number L , Number ) ; return fflush ( @@stream@@ ) ; }
__int64 __fastcall hash_reset_tuning ( __int64 @@a1@@ ) { __int64 @@result@@ ; * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; * ( _QWORD * ) @@a1@@ = Number ; @@result@@ = Number ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number ; return @@result@@ ; }
__int64 __fastcall dup_safer ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ , char @@a7@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ , @@a7@@ ) ; }
__int64 __fastcall hash_get_first ( __int64 @@a1@@ ) { __int64 * @@v1@@ ; unsigned __int64 @@v2@@ ; __int64 @@result@@ ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; @@v1@@ = * ( __int64 * * ) @@a1@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( * ( _QWORD * ) @@a1@@ >= @@v2@@ ) goto LABEL_9 ; @@result@@ = * @@v1@@ ; if ( ! * @@v1@@ ) { while ( Number ) { @@v1@@ += Number ; if ( ( unsigned __int64 ) @@v1@@ >= @@v2@@ ) break ; @@result@@ = * @@v1@@ ; if ( * @@v1@@ ) return @@result@@ ; } LABEL_9 : abort ( ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_2061F0 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061D0 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061E0 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
void __fastcall hash_clear ( _QWORD * @@a1@@ ) { _QWORD * @@v1@@ ; _QWORD * @@v2@@ ; void ( __fastcall * @@v3@@ ) ( _QWORD ) ; _QWORD * @@v4@@ ; __int64 @@v5@@ ; @@v1@@ = ( _QWORD * ) * @@a1@@ ; if ( * @@a1@@ < @@a1@@ [ Number ] ) { do { if ( * @@v1@@ ) { @@v2@@ = ( _QWORD * ) @@v1@@ [ Number ] ; @@v3@@ = ( void ( __fastcall * ) ( _QWORD ) ) @@a1@@ [ Number ] ; if ( @@v2@@ ) { do { if ( @@v3@@ ) { @@v3@@ ( * @@v2@@ ) ; @@v3@@ = ( void ( __fastcall * ) ( _QWORD ) ) @@a1@@ [ Number ] ; } @@v4@@ = ( _QWORD * ) @@v2@@ [ Number ] ; @@v5@@ = @@a1@@ [ Number ] ; * @@v2@@ = Number L ; @@v2@@ [ Number ] = @@v5@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v2@@ = @@v4@@ ; } while ( @@v4@@ ) ; } if ( @@v3@@ ) @@v3@@ ( * @@v1@@ ) ; * @@v1@@ = Number L ; @@v1@@ [ Number ] = Number L ; } @@v1@@ += Number ; } while ( @@a1@@ [ Number ] > ( unsigned __int64 ) @@v1@@ ) ; } @@a1@@ [ Number ] = Number L ; @@a1@@ [ Number ] = Number L ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
int __fastcall rpl_fseeko ( FILE * @@stream@@ , __off_t @@offset@@ , int @@whence@@ ) { int @@v5@@ ; int @@v6@@ ; if ( @@stream@@ -> _IO_read_end != @@stream@@ -> _IO_read_ptr || @@stream@@ -> _IO_write_ptr != @@stream@@ -> _IO_write_base || @@stream@@ -> _IO_save_base ) { return fseeko ( @@stream@@ , @@offset@@ , @@whence@@ ) ; } if ( @@whence@@ == Number && @@offset@@ > Number ) { @@v5@@ = fileno ( @@stream@@ ) ; if ( lseek ( @@v5@@ , Number L , Number ) != Number ) { @@stream@@ -> _flags &= Number ; return fseeko ( @@stream@@ , @@offset@@ , @@whence@@ ) ; } } else { @@v6@@ = fileno ( @@stream@@ ) ; if ( lseek ( @@v6@@ , @@offset@@ , @@whence@@ ) != Number ) { @@stream@@ -> _flags &= Number ; return Number ; } } return Number ; }
__int64 __fastcall hash_do_for_each ( __int64 @@a1@@ , unsigned __int8 ( __fastcall * @@a2@@ ) ( __int64 , __int64 ) , __int64 @@a3@@ ) { __int64 * @@v3@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 * @@v8@@ ; @@v3@@ = * ( __int64 * * ) @@a1@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= * ( _QWORD * ) @@a1@@ ) return Number L ; @@v6@@ = Number L ; while ( Number ) { @@v7@@ = * @@v3@@ ; if ( * @@v3@@ ) break ; LABEL_8 : @@v3@@ += Number ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= ( unsigned __int64 ) @@v3@@ ) return @@v6@@ ; } @@v8@@ = @@v3@@ ; while ( @@a2@@ ( @@v7@@ , @@a3@@ ) ) { @@v8@@ = ( __int64 * ) @@v8@@ [ Number ] ; ++ @@v6@@ ; if ( ! @@v8@@ ) goto LABEL_8 ; @@v7@@ = * @@v8@@ ; } return @@v6@@ ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
__int64 __fastcall hash_get_n_buckets ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void __fastcall hash_free ( void * @@ptr@@ ) { _QWORD * @@v2@@ ; unsigned __int64 @@v3@@ ; _QWORD * @@v4@@ ; _QWORD * @@v5@@ ; _QWORD * @@v6@@ ; _QWORD * @@v7@@ ; _QWORD * @@v8@@ ; @@v2@@ = * ( _QWORD * * ) @@ptr@@ ; @@v3@@ = * ( ( _QWORD * ) @@ptr@@ + Number ) ; if ( * ( ( _QWORD * ) @@ptr@@ + Number ) && * ( ( _QWORD * ) @@ptr@@ + Number ) ) { if ( ( unsigned __int64 ) @@v2@@ >= @@v3@@ ) goto LABEL_14 ; do { if ( * @@v2@@ ) { @@v4@@ = @@v2@@ ; do { ( * ( ( void ( * * ) ( void ) ) @@ptr@@ + Number ) ) ( ) ; @@v4@@ = ( _QWORD * ) @@v4@@ [ Number ] ; } while ( @@v4@@ ) ; @@v3@@ = * ( ( _QWORD * ) @@ptr@@ + Number ) ; } @@v2@@ += Number ; } while ( @@v3@@ > ( unsigned __int64 ) @@v2@@ ) ; @@v2@@ = * ( _QWORD * * ) @@ptr@@ ; } if ( ( unsigned __int64 ) @@v2@@ < @@v3@@ ) { do { @@v5@@ = ( _QWORD * ) @@v2@@ [ Number ] ; if ( @@v5@@ ) { do { @@v6@@ = ( _QWORD * ) @@v5@@ [ Number ] ; free ( @@v5@@ ) ; @@v5@@ = @@v6@@ ; } while ( @@v6@@ ) ; } @@v2@@ += Number ; } while ( * ( ( _QWORD * ) @@ptr@@ + Number ) > ( unsigned __int64 ) @@v2@@ ) ; } LABEL_14 : @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@ptr@@ + Number ) ; if ( @@v7@@ ) { do { @@v8@@ = ( _QWORD * ) @@v7@@ [ Number ] ; free ( @@v7@@ ) ; @@v7@@ = @@v8@@ ; } while ( @@v8@@ ) ; } free ( * ( void * * ) @@ptr@@ ) ; free ( @@ptr@@ ) ; }
__int64 __fastcall hash_get_n_buckets_used ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
int fileno ( FILE * @@stream@@ ) { return fileno ( @@stream@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
unsigned __int64 __fastcall hash_get_max_bucket_length ( __int64 @@a1@@ ) { _QWORD * @@v1@@ ; unsigned __int64 @@v2@@ ; unsigned __int64 @@result@@ ; __int64 @@v4@@ ; unsigned __int64 @@i@@ ; @@v1@@ = * ( _QWORD * * ) @@a1@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; for ( @@result@@ = Number L ; ( unsigned __int64 ) @@v1@@ < @@v2@@ ; @@v1@@ += Number ) { if ( * @@v1@@ ) { @@v4@@ = @@v1@@ [ Number ] ; for ( @@i@@ = Number L ; @@v4@@ ; ++ @@i@@ ) @@v4@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; if ( @@result@@ < @@i@@ ) @@result@@ = @@i@@ ; } } return @@result@@ ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__int64 __fastcall print_kth ( unsigned __int64 @@a1@@ , bool * @@a2@@ ) { int @@v2@@ ; unsigned int @@v3@@ ; LOBYTE ( @@v2@@ ) = eol_range_start <= @@a1@@ && eol_range_start != Number ; if ( ! ( _BYTE ) @@v2@@ && max_range_endpoint >= @@a1@@ ) @@v2@@ = ( ( int ) * ( unsigned __int8 * ) ( printable_field + ( @@a1@@ >> Number ) ) >> ( @@a1@@ & Number ) ) & Number ; LOBYTE ( @@v2@@ ) = complement ^ @@v2@@ ; @@v3@@ = @@v2@@ ; if ( @@a2@@ && ( _BYTE ) @@v2@@ ) * @@a2@@ = hash_lookup ( range_start_ht , @@a1@@ ) != Number ; return @@v3@@ ; }
__int64 __fastcall hash_get_first ( __int64 @@a1@@ ) { __int64 * @@v1@@ ; unsigned __int64 @@v2@@ ; __int64 @@result@@ ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; @@v1@@ = * ( __int64 * * ) @@a1@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( * ( _QWORD * ) @@a1@@ >= @@v2@@ ) goto LABEL_9 ; @@result@@ = * @@v1@@ ; if ( ! * @@v1@@ ) { while ( Number ) { @@v1@@ += Number ; if ( ( unsigned __int64 ) @@v1@@ >= @@v2@@ ) break ; @@result@@ = * @@v1@@ ; if ( * @@v1@@ ) return @@result@@ ; } LABEL_9 : abort ( ) ; } return @@result@@ ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_20A250 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20A230 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_20A240 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
__mode_t umask ( __mode_t @@mask@@ ) { return umask ( @@mask@@ ) ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
__int64 __fastcall hash_do_for_each ( __int64 @@a1@@ , unsigned __int8 ( __fastcall * @@a2@@ ) ( __int64 , __int64 ) , __int64 @@a3@@ ) { __int64 * @@v3@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 * @@v8@@ ; @@v3@@ = * ( __int64 * * ) @@a1@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= * ( _QWORD * ) @@a1@@ ) return Number L ; @@v6@@ = Number L ; while ( Number ) { @@v7@@ = * @@v3@@ ; if ( * @@v3@@ ) break ; LABEL_8 : @@v3@@ += Number ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= ( unsigned __int64 ) @@v3@@ ) return @@v6@@ ; } @@v8@@ = @@v3@@ ; while ( @@a2@@ ( @@v7@@ , @@a3@@ ) ) { @@v8@@ = ( __int64 * ) @@v8@@ [ Number ] ; ++ @@v6@@ ; if ( ! @@v8@@ ) goto LABEL_8 ; @@v7@@ = * @@v8@@ ; } return @@v6@@ ; }
int __xstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _xstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
int __fastcall rpl_linkat ( int @@fd@@ , char * @@path@@ , int @@a3@@ , const char * @@a4@@ , int @@a5@@ ) { int @@v6@@ ; char * @@v8@@ ; int @@v9@@ ; char * @@v10@@ ; _BYTE * @@v11@@ ; void * @@v12@@ ; void * @@v13@@ ; int @@v14@@ ; int @@v15@@ ; int @@tofda@@ ; int * @@v19@@ ; if ( ! @@a5@@ ) return linkat ( @@fd@@ , @@path@@ , @@a3@@ , @@a4@@ , Number ) ; if ( ( @@a5@@ & Number ) != Number ) { @@v6@@ = Number ; * __errno_location ( ) = Number ; return @@v6@@ ; } if ( have_follow_really_4922 < Number ) { @@v19@@ = __errno_location ( ) ; } else { @@v6@@ = linkat ( @@fd@@ , @@path@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; if ( @@v6@@ != Number || ( @@v19@@ = __errno_location ( ) , * @@v19@@ != Number ) ) { have_follow_really_4922 = Number ; return @@v6@@ ; } have_follow_really_4922 = Number ; } @@v8@@ = @@path@@ ; @@v9@@ = Number ; while ( Number ) { @@v11@@ = ( _BYTE * ) areadlinkat ( @@fd@@ , @@v8@@ ) ; @@v12@@ = @@v11@@ ; if ( ! @@v11@@ ) break ; if ( * @@v11@@ != Number ) { @@v13@@ = ( void * ) mdir_name ( @@v8@@ ) ; if ( @@path@@ != @@v8@@ ) free ( @@v8@@ ) ; if ( ! @@v13@@ ) { @@v6@@ = Number ; free ( @@v12@@ ) ; * @@v19@@ = Number ; return @@v6@@ ; } @@v8@@ = ( char * ) mfile_name_concat ( @@v13@@ , @@v12@@ , Number L ) ; free ( @@v13@@ ) ; free ( @@v12@@ ) ; if ( ! @@v8@@ ) { @@v6@@ = Number ; * @@v19@@ = Number ; return @@v6@@ ; } goto LABEL_11 ; } if ( @@path@@ == @@v8@@ ) { -- @@v9@@ ; @@v8@@ = @@v11@@ ; if ( ! @@v9@@ ) { LABEL_20 : * @@v19@@ = Number ; @@v14@@ = Number ; goto LABEL_21 ; } } else { @@v10@@ = @@v8@@ ; @@v8@@ = @@v11@@ ; free ( @@v10@@ ) ; LABEL_11 : if ( ! -- @@v9@@ ) goto LABEL_20 ; } } @@v14@@ = * @@v19@@ ; if ( * @@v19@@ != Number ) { LABEL_21 : @@tofda@@ = @@v14@@ ; @@v6@@ = Number ; if ( @@path@@ != @@v8@@ ) { free ( @@v8@@ ) ; * @@v19@@ = @@tofda@@ ; } return @@v6@@ ; } @@v6@@ = linkat ( @@fd@@ , @@v8@@ , @@a3@@ , @@a4@@ , Number ) ; if ( @@path@@ != @@v8@@ ) { @@v15@@ = * @@v19@@ ; free ( @@v8@@ ) ; * @@v19@@ = @@v15@@ ; } return @@v6@@ ; }
__int64 __fastcall check_tuning_isra_0 ( float * * @@a1@@ ) { float * @@v1@@ ; __int64 @@result@@ ; float @@v3@@ ; float @@v4@@ ; float @@v5@@ ; @@v1@@ = * @@a1@@ ; @@result@@ = Number L ; if ( * @@a1@@ != ( float * ) & default_tuning ) { @@v3@@ = @@v1@@ [ Number ] ; if ( @@v3@@ <= Number || @@v3@@ >= Number || @@v1@@ [ Number ] <= Number || * @@v1@@ < Number || ( @@v4@@ = * @@v1@@ + Number , @@v5@@ = @@v1@@ [ Number ] , @@v5@@ <= @@v4@@ ) || @@v5@@ > Number || @@v3@@ <= @@v4@@ ) { * @@a1@@ = ( float * ) & default_tuning ; @@result@@ = Number L ; } } return @@result@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
__int64 __fastcall freadptr ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { __int64 @@result@@ ; __int64 @@v3@@ ; if ( @@a1@@ [ Number ] > @@a1@@ [ Number ] ) return Number L ; @@result@@ = @@a1@@ [ Number ] ; @@v3@@ = @@a1@@ [ Number ] - @@result@@ ; if ( ! @@v3@@ ) return Number L ; * @@a2@@ = @@v3@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall hash_print_statistics ( __int64 @@a1@@ ) { unsigned __int64 @@v1@@ ; _QWORD * @@v2@@ ; unsigned __int64 @@i@@ ; __int64 @@v4@@ ; unsigned __int64 @@j@@ ; @@v1@@ = Number L ; @@v2@@ = * ( _QWORD * * ) @@a1@@ ; for ( @@i@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; ( unsigned __int64 ) @@v2@@ < @@i@@ ; @@v2@@ += Number ) { if ( * @@v2@@ ) { @@v4@@ = @@v2@@ [ Number ] ; for ( @@j@@ = Number L ; @@v4@@ ; ++ @@j@@ ) @@v4@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; if ( @@v1@@ < @@j@@ ) @@v1@@ = @@j@@ ; } } __fprintf_chk ( ) ; __fprintf_chk ( ) ; __fprintf_chk ( ) ; return __fprintf_chk ( ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
__int64 __fastcall freadseek ( FILE * @@stream@@ , __off_t @@offset@@ ) { __int64 @@result@@ ; unsigned __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; int @@v6@@ ; unsigned __int64 @@v7@@ ; __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@result@@ = Number L ; if ( @@offset@@ ) { @@v3@@ = @@offset@@ ; @@v4@@ = freadahead ( ) ; if ( @@v4@@ ) { while ( Number ) { if ( freadptr ( @@stream@@ , @@v8@@ ) ) { @@v5@@ = @@v8@@ [ Number ] ; if ( @@v8@@ [ Number ] ) { if ( @@v8@@ [ Number ] > @@v3@@ ) @@v5@@ = @@v3@@ ; @@stream@@ -> _IO_read_ptr += @@v5@@ ; @@v3@@ -= @@v5@@ ; if ( ! @@v3@@ ) break ; @@v4@@ -= @@v5@@ ; if ( ! @@v4@@ ) goto LABEL_15 ; } } if ( fgetc ( @@stream@@ ) == Number ) goto LABEL_13 ; if ( ! -- @@v3@@ ) break ; if ( ! -- @@v4@@ ) goto LABEL_15 ; } LABEL_14 : @@result@@ = Number L ; } else { LABEL_15 : @@v6@@ = fileno ( @@stream@@ ) ; if ( @@v6@@ < Number || lseek ( @@v6@@ , Number L , Number ) < Number ) { while ( Number ) { @@v7@@ = Number L ; if ( @@v3@@ <= Number ) @@v7@@ = @@v3@@ ; if ( @@v7@@ > __fread_chk ( ) ) break ; @@v3@@ -= @@v7@@ ; if ( ! @@v3@@ ) goto LABEL_14 ; } LABEL_13 : @@result@@ = ( unsigned int ) - ( ferror ( @@stream@@ ) != Number ) ; } else { @@result@@ = rpl_fseeko ( @@stream@@ , @@v3@@ , Number ) ; } } } return @@result@@ ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
int fflush ( FILE * @@stream@@ ) { return fflush ( @@stream@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
unsigned __int64 __fastcall hash_get_entries ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { _QWORD * @@v3@@ ; unsigned __int64 @@v4@@ ; _QWORD * @@v5@@ ; unsigned __int64 @@result@@ ; @@v3@@ = * ( _QWORD * * ) @@a1@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= * ( _QWORD * ) @@a1@@ ) return Number L ; @@v4@@ = Number L ; while ( ! * @@v3@@ ) { LABEL_9 : @@v3@@ += Number ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= ( unsigned __int64 ) @@v3@@ ) return @@v4@@ ; } if ( @@a3@@ <= @@v4@@ ) return @@v4@@ ; * ( _QWORD * ) ( @@a2@@ + Number * @@v4@@ ) = * @@v3@@ ; @@v5@@ = ( _QWORD * ) @@v3@@ [ Number ] ; @@result@@ = @@v4@@ + Number ; if ( ! @@v5@@ ) { LABEL_8 : @@v4@@ = @@result@@ ; goto LABEL_9 ; } while ( @@a3@@ != @@result@@ ) { ++ @@result@@ ; * ( _QWORD * ) ( @@a2@@ + Number * @@result@@ - Number ) = * @@v5@@ ; @@v5@@ = ( _QWORD * ) @@v5@@ [ Number ] ; if ( ! @@v5@@ ) goto LABEL_8 ; } return @@result@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
unsigned __int64 __fastcall triple_hash ( _QWORD * @@a1@@ , unsigned __int64 @@a2@@ ) { return ( @@a1@@ [ Number ] ^ ( unsigned __int64 ) hash_pjw ( * @@a1@@ ) ) % @@a2@@ ; }
bool __fastcall strip_trailing_slashes ( char * @@a1@@ ) { const char * @@v1@@ ; const char * @@v2@@ ; bool @@v3@@ ; @@v1@@ = last_component ( @@a1@@ ) ; if ( ! * @@v1@@ ) @@v1@@ = @@a1@@ ; @@v2@@ = & @@v1@@ [ base_len ( @@v1@@ ) ] ; @@v3@@ = * @@v2@@ == Number ; * @@v2@@ = Number ; return ! @@v3@@ ; }
int __lxstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _lxstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
bool __fastcall triple_compare_ino_str ( __int64 @@a1@@ , __int64 @@a2@@ ) { bool @@result@@ ; @@result@@ = Number ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) == * ( _QWORD * ) ( @@a2@@ + Number ) && * ( _QWORD * ) ( @@a1@@ + Number ) == * ( _QWORD * ) ( @@a2@@ + Number ) ) { @@result@@ = strcmp ( * ( const char * * ) @@a1@@ , * ( const char * * ) @@a2@@ ) == Number ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
int dirfd ( DIR * @@dirp@@ ) { return dirfd ( @@dirp@@ ) ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
struct dirent * readdir ( DIR * @@dirp@@ ) { return readdir ( @@dirp@@ ) ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; FILE * @@v11@@ ; char * @@v12@@ ; FILE * @@v13@@ ; char * @@v14@@ ; FILE * @@v15@@ ; char * @@v16@@ ; char * @@v17@@ ; FILE * @@v18@@ ; char * @@v19@@ ; char * @@v20@@ ; char * @@v21@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = stdout ; @@v10@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; @@v11@@ = stdout ; @@v12@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v12@@ , @@v11@@ ) ; @@v13@@ = stdout ; @@v14@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v14@@ , @@v13@@ ) ; @@v15@@ = stdout ; @@v16@@ = dcgettext ( Number L , String String String String , Number ) ; fputs_unlocked ( @@v16@@ , @@v15@@ ) ; @@v17@@ = dcgettext ( Number L , String String String String , Number ) ; __printf_chk ( ) ; last_component ( program_name , @@v17@@ ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v18@@ = stdout ; @@v19@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v19@@ , @@v18@@ ) ; @@v20@@ = Number L ; @@v21@@ = setlocale ( Number , Number L ) ; if ( @@v21@@ ) { @@v20@@ = String ; if ( strncmp ( @@v21@@ , String , Number ) ) { last_component ( program_name , String ) ; @@v20@@ = dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name , @@v20@@ ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
__int64 __fastcall freadahead ( __int64 @@a1@@ ) { __int64 @@result@@ ; @@result@@ = Number L ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= * ( _QWORD * ) ( @@a1@@ + Number ) ) { @@result@@ = * ( _QWORD * ) ( @@a1@@ + Number ) - * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( ( * ( _DWORD * ) @@a1@@ & Number ) != Number ) @@result@@ += * ( _QWORD * ) ( @@a1@@ + Number ) - * ( _QWORD * ) ( @@a1@@ + Number ) ; } return @@result@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_20A250 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20A230 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20A240 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
unsigned __int64 __fastcall raw_hasher ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return __ROR8__ ( @@a1@@ , Number ) % @@a2@@ ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; FILE * @@v11@@ ; char * @@v12@@ ; FILE * @@v13@@ ; char * @@v14@@ ; FILE * @@v15@@ ; char * @@v16@@ ; FILE * @@v17@@ ; char * @@v18@@ ; FILE * @@v19@@ ; char * @@v20@@ ; char * @@v21@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String String String String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String String String String String String String String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String String String String String String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = stdout ; @@v10@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; @@v11@@ = stdout ; @@v12@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v12@@ , @@v11@@ ) ; @@v13@@ = stdout ; @@v14@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v14@@ , @@v13@@ ) ; @@v15@@ = stdout ; @@v16@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v16@@ , @@v15@@ ) ; dcgettext ( Number L , String String String , Number ) ; __printf_chk ( ) ; @@v17@@ = stdout ; @@v18@@ = dcgettext ( Number L , String String String String , Number ) ; fputs_unlocked ( @@v18@@ , @@v17@@ ) ; last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v19@@ = stdout ; @@v20@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v20@@ , @@v19@@ ) ; @@v21@@ = setlocale ( Number , Number L ) ; if ( @@v21@@ ) { if ( strncmp ( @@v21@@ , String , Number ) ) { last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
__int64 __fastcall check_tuning_isra_0 ( float * * @@a1@@ ) { float * @@v1@@ ; __int64 @@result@@ ; float @@v3@@ ; float @@v4@@ ; float @@v5@@ ; @@v1@@ = * @@a1@@ ; @@result@@ = Number L ; if ( * @@a1@@ != ( float * ) & default_tuning ) { @@v3@@ = @@v1@@ [ Number ] ; if ( @@v3@@ <= Number || @@v3@@ >= Number || @@v1@@ [ Number ] <= Number || * @@v1@@ < Number || ( @@v4@@ = * @@v1@@ + Number , @@v5@@ = @@v1@@ [ Number ] , @@v5@@ <= @@v4@@ ) || @@v5@@ > Number || @@v3@@ <= @@v4@@ ) { * @@a1@@ = ( float * ) & default_tuning ; @@result@@ = Number L ; } } return @@result@@ ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
void * __fastcall mfile_name_concat ( void * @@src@@ , void * @@a2@@ , _QWORD * @@a3@@ ) { const char * @@v4@@ ; const char * @@v5@@ ; size_t @@v6@@ ; size_t @@v7@@ ; _BOOL8 @@v8@@ ; void * @@v9@@ ; void * @@v10@@ ; _BYTE * @@v11@@ ; char * @@v12@@ ; size_t @@n@@ ; char @@v15@@ ; @@v4@@ = ( const char * ) @@a2@@ ; @@v5@@ = last_component ( @@src@@ ) ; @@v6@@ = base_len ( @@v5@@ ) ; @@v7@@ = @@v6@@ + @@v5@@ - ( _BYTE * ) @@src@@ ; @@v8@@ = @@v6@@ ; if ( @@v6@@ ) @@v8@@ = @@v5@@ [ @@v6@@ - Number ] != Number ; @@v15@@ = * ( _BYTE * ) @@a2@@ ; if ( * ( _BYTE * ) @@a2@@ == Number ) { do ++ @@v4@@ ; while ( * @@v4@@ == Number ) ; } @@n@@ = strlen ( @@v4@@ ) ; @@v9@@ = malloc ( @@n@@ + @@v8@@ + @@v7@@ + Number ) ; @@v10@@ = @@v9@@ ; if ( @@v9@@ ) { @@v11@@ = mempcpy ( @@v9@@ , @@src@@ , @@v7@@ ) ; * @@v11@@ = Number ; @@v12@@ = & @@v11@@ [ @@v8@@ ] ; if ( @@a3@@ ) * @@a3@@ = & @@v12@@ [ - ( @@v15@@ == Number ) ] ; * ( _BYTE * ) mempcpy ( @@v12@@ , @@v4@@ , @@n@@ ) = Number ; } return @@v10@@ ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
__int64 __fastcall hash_get_n_entries ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
__int64 __fastcall hash_lookup ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; _QWORD * @@v4@@ ; __int64 @@v5@@ ; @@v2@@ = * @@a1@@ ; @@v4@@ = ( _QWORD * ) ( Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) + @@v2@@ ) ; if ( @@a1@@ [ Number ] <= ( unsigned __int64 ) @@v4@@ ) abort ( ) ; @@v5@@ = * @@v4@@ ; if ( ! * @@v4@@ ) return Number L ; while ( @@v5@@ != @@a2@@ ) { if ( ( ( unsigned __int8 ( __fastcall * ) ( __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ ) ) return * @@v4@@ ; @@v4@@ = ( _QWORD * ) @@v4@@ [ Number ] ; if ( ! @@v4@@ ) return Number L ; @@v5@@ = * @@v4@@ ; } return @@v5@@ ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
__int64 __fastcall hash_print_statistics ( __int64 @@a1@@ ) { unsigned __int64 @@v1@@ ; _QWORD * @@v2@@ ; unsigned __int64 @@i@@ ; __int64 @@v4@@ ; unsigned __int64 @@j@@ ; @@v1@@ = Number L ; @@v2@@ = * ( _QWORD * * ) @@a1@@ ; for ( @@i@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; ( unsigned __int64 ) @@v2@@ < @@i@@ ; @@v2@@ += Number ) { if ( * @@v2@@ ) { @@v4@@ = @@v2@@ [ Number ] ; for ( @@j@@ = Number L ; @@v4@@ ; ++ @@j@@ ) @@v4@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; if ( @@v1@@ < @@j@@ ) @@v1@@ = @@j@@ ; } } __fprintf_chk ( ) ; __fprintf_chk ( ) ; __fprintf_chk ( ) ; return __fprintf_chk ( ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
unsigned __int64 __fastcall hash_string ( unsigned __int8 * @@a1@@ , unsigned __int64 @@a2@@ ) { __int64 @@v2@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@v4@@ ; @@v2@@ = * @@a1@@ ; for ( @@i@@ = Number L ; ( _BYTE ) @@v2@@ ; @@i@@ = @@v4@@ % @@a2@@ ) { ++ @@a1@@ ; @@v4@@ = @@v2@@ + Number * @@i@@ ; @@v2@@ = * @@a1@@ ; } return @@i@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
int rename ( const char * @@old@@ , const char * @@a2@@ ) { return rename ( @@old@@ , @@a2@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
void __fastcall record_file ( __int64 @@a1@@ , void * @@a2@@ , _QWORD * @@a3@@ ) { _QWORD * @@v4@@ ; __int64 @@v5@@ ; if ( @@a1@@ ) { @@v4@@ = ( _QWORD * ) xmalloc ( Number L ) ; * @@v4@@ = xstrdup ( @@a2@@ ) ; @@v4@@ [ Number ] = @@a3@@ [ Number ] ; @@v4@@ [ Number ] = * @@a3@@ ; @@v5@@ = hash_insert ( @@a1@@ , @@v4@@ ) ; if ( ! @@v5@@ ) xalloc_die ( ) ; if ( @@v4@@ != ( _QWORD * ) @@v5@@ ) triple_free ( @@v4@@ ) ; } }
unsigned __int64 __fastcall hash_get_entries ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { _QWORD * @@v3@@ ; unsigned __int64 @@v4@@ ; _QWORD * @@v5@@ ; unsigned __int64 @@result@@ ; @@v3@@ = * ( _QWORD * * ) @@a1@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= * ( _QWORD * ) @@a1@@ ) return Number L ; @@v4@@ = Number L ; while ( ! * @@v3@@ ) { LABEL_9 : @@v3@@ += Number ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= ( unsigned __int64 ) @@v3@@ ) return @@v4@@ ; } if ( @@a3@@ <= @@v4@@ ) return @@v4@@ ; * ( _QWORD * ) ( @@a2@@ + Number * @@v4@@ ) = * @@v3@@ ; @@v5@@ = ( _QWORD * ) @@v3@@ [ Number ] ; @@result@@ = @@v4@@ + Number ; if ( ! @@v5@@ ) { LABEL_8 : @@v4@@ = @@result@@ ; goto LABEL_9 ; } while ( @@a3@@ != @@result@@ ) { ++ @@result@@ ; * ( _QWORD * ) ( @@a2@@ + Number * @@result@@ - Number ) = * @@v5@@ ; @@v5@@ = ( _QWORD * ) @@v5@@ [ Number ] ; if ( ! @@v5@@ ) goto LABEL_8 ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
_QWORD * __fastcall hash_initialize ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 ( __fastcall * @@a3@@ ) ( __int64 a1 , unsigned __int64 a2 ) , bool ( __fastcall * @@a4@@ ) ( __int64 a1 , __int64 a2 ) , __int64 @@a5@@ ) { unsigned __int64 ( __fastcall * @@v5@@ ) ( __int64 , unsigned __int64 ) ; bool ( __fastcall * @@v6@@ ) ( __int64 , __int64 ) ; char * @@v9@@ ; _QWORD * @@v10@@ ; float * * @@v11@@ ; float @@v12@@ ; float @@v13@@ ; float @@v14@@ ; unsigned __int64 @@v15@@ ; char * @@v16@@ ; void * @@v17@@ ; @@v5@@ = @@a3@@ ; @@v6@@ = @@a4@@ ; if ( ! @@a3@@ ) @@v5@@ = raw_hasher ; if ( ! @@a4@@ ) @@v6@@ = raw_comparator ; @@v9@@ = ( char * ) malloc ( Number ) ; @@v10@@ = @@v9@@ ; if ( @@v9@@ ) { @@v11@@ = ( float * * ) ( @@v9@@ + Number ) ; if ( @@a2@@ ) { * ( ( _QWORD * ) @@v9@@ + Number ) = @@a2@@ ; if ( ! ( unsigned __int8 ) check_tuning_isra_0 ( @@v11@@ ) ) goto LABEL_20 ; if ( * ( _BYTE * ) ( @@a2@@ + Number ) ) { LABEL_15 : @@v15@@ = next_prime ( @@a1@@ ) ; if ( @@v15@@ <= Number ) { @@v10@@ [ Number ] = @@v15@@ ; if ( @@v15@@ ) { @@v16@@ = ( char * ) calloc ( @@v15@@ , Number ) ; * @@v10@@ = @@v16@@ ; if ( @@v16@@ ) { @@v10@@ [ Number ] = Number L ; @@v10@@ [ Number ] = Number L ; @@v10@@ [ Number ] = @@v5@@ ; @@v10@@ [ Number ] = @@v6@@ ; @@v10@@ [ Number ] = & @@v16@@ [ Number * @@v15@@ ] ; @@v10@@ [ Number ] = @@a5@@ ; @@v10@@ [ Number ] = Number L ; return @@v10@@ ; } } } LABEL_20 : @@v17@@ = @@v10@@ ; @@v10@@ = Number L ; free ( @@v17@@ ) ; return @@v10@@ ; } @@v12@@ = * ( float * ) ( @@a2@@ + Number ) ; } else { * ( ( _QWORD * ) @@v9@@ + Number ) = & default_tuning ; @@v12@@ = Number ; if ( ! ( unsigned __int8 ) check_tuning_isra_0 ( @@v11@@ ) ) goto LABEL_20 ; } if ( @@a1@@ < Number ) @@v13@@ = ( float ) ( @@a1@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@a1@@ >> Number ) ) + ( float ) ( @@a1@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@a1@@ >> Number ) ) ; else @@v13@@ = ( float ) ( int ) @@a1@@ ; @@v14@@ = @@v13@@ / @@v12@@ ; if ( @@v14@@ >= Number ) goto LABEL_20 ; if ( @@v14@@ < Number ) @@a1@@ = ( unsigned int ) ( int ) @@v14@@ ; else @@a1@@ = ( unsigned int ) ( int ) ( float ) ( @@v14@@ - Number ) ^ Number ; goto LABEL_15 ; } return @@v10@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
DIR * __fastcall opendir_safer ( const char * @@a1@@ ) { DIR * @@v1@@ ; DIR * @@v2@@ ; unsigned int @@v3@@ ; int @@v5@@ ; DIR * @@v6@@ ; int * @@v7@@ ; int @@v8@@ ; @@v1@@ = opendir ( @@a1@@ ) ; @@v2@@ = @@v1@@ ; if ( ! @@v1@@ ) return @@v2@@ ; @@v3@@ = dirfd ( @@v1@@ ) ; if ( @@v3@@ > Number ) return @@v2@@ ; @@v5@@ = dup_safer ( @@v3@@ ) ; @@v6@@ = fdopendir ( @@v5@@ ) ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; if ( ! @@v6@@ ) close ( @@v5@@ ) ; closedir ( @@v2@@ ) ; * @@v7@@ = @@v8@@ ; return @@v6@@ ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
__int64 __fastcall mode_create_from_ref ( char * @@filename@@ ) { __mode_t @@v1@@ ; __int64 @@result@@ ; struct stat @@v3@@ ; unsigned __int64 @@v4@@ ; @@v4@@ = __readfsqword ( Number ) ; if ( __xstat ( Number , @@filename@@ , & @@v3@@ ) ) return Number L ; @@v1@@ = @@v3@@ . st_mode ; @@result@@ = xmalloc ( Number L ) ; * ( _DWORD * ) ( @@result@@ + Number ) = Number ; * ( _DWORD * ) ( @@result@@ + Number ) = Number ; * ( _WORD * ) @@result@@ = Number ; * ( _DWORD * ) ( @@result@@ + Number ) = @@v1@@ ; * ( _BYTE * ) ( @@result@@ + Number ) = Number ; return @@result@@ ; }
__int64 __fastcall hash_find_entry ( __int64 * @@a1@@ , __int64 @@a2@@ , __m128i * * @@a3@@ , char @@a4@@ ) { __int64 @@v5@@ ; __m128i * @@v8@@ ; __int64 @@v9@@ ; __int64 * @@v10@@ ; const __m128i * @@v12@@ ; @@v5@@ = * @@a1@@ ; @@v8@@ = ( __m128i * ) ( Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) + @@v5@@ ) ; if ( @@a1@@ [ Number ] <= ( unsigned __int64 ) @@v8@@ ) abort ( ) ; * @@a3@@ = @@v8@@ ; @@v9@@ = @@v8@@ -> m128i_i64 [ Number ] ; if ( @@v8@@ -> m128i_i64 [ Number ] ) { if ( @@v9@@ != @@a2@@ ) { if ( ! ( ( unsigned __int8 ( __fastcall * ) ( __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ ) ) { @@v10@@ = ( __int64 * ) @@v8@@ -> m128i_i64 [ Number ] ; if ( @@v10@@ ) { @@v9@@ = * @@v10@@ ; if ( @@a2@@ != * @@v10@@ ) { while ( ! ( ( unsigned __int8 ( __fastcall * ) ( __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ ) ) { @@v8@@ = ( __m128i * ) @@v8@@ -> m128i_i64 [ Number ] ; @@v10@@ = ( __int64 * ) @@v8@@ -> m128i_i64 [ Number ] ; if ( ! @@v10@@ ) return Number L ; @@v9@@ = * @@v10@@ ; if ( * @@v10@@ == @@a2@@ ) goto LABEL_12 ; } @@v10@@ = ( __int64 * ) @@v8@@ -> m128i_i64 [ Number ] ; @@v9@@ = * @@v10@@ ; } LABEL_12 : if ( @@a4@@ ) { @@v8@@ -> m128i_i64 [ Number ] = @@v10@@ [ Number ] ; * @@v10@@ = Number L ; @@v10@@ [ Number ] = @@a1@@ [ Number ] ; @@a1@@ [ Number ] = ( __int64 ) @@v10@@ ; } return @@v9@@ ; } return Number L ; } @@v9@@ = @@v8@@ -> m128i_i64 [ Number ] ; } if ( @@a4@@ ) { @@v12@@ = ( const __m128i * ) @@v8@@ -> m128i_i64 [ Number ] ; if ( @@v12@@ ) { * @@v8@@ = _mm_loadu_si128 ( @@v12@@ ) ; @@v12@@ -> m128i_i64 [ Number ] = Number L ; @@v12@@ -> m128i_i64 [ Number ] = @@a1@@ [ Number ] ; @@a1@@ [ Number ] = ( __int64 ) @@v12@@ ; return @@v9@@ ; } @@v8@@ -> m128i_i64 [ Number ] = Number L ; } return @@v9@@ ; } return Number L ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
__int64 __fastcall hash_reset_tuning ( __int64 @@a1@@ ) { __int64 @@result@@ ; * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; * ( _QWORD * ) @@a1@@ = Number ; @@result@@ = Number ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number ; return @@result@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_20B230 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20B210 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_20B220 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ , @@v4@@ ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_20B230 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20B210 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20B220 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ , @@v4@@ ) ; return @@result@@ ; }
void __fastcall hash_free ( void * @@ptr@@ ) { _QWORD * @@v2@@ ; unsigned __int64 @@v3@@ ; _QWORD * @@v4@@ ; _QWORD * @@v5@@ ; _QWORD * @@v6@@ ; _QWORD * @@v7@@ ; _QWORD * @@v8@@ ; @@v2@@ = * ( _QWORD * * ) @@ptr@@ ; @@v3@@ = * ( ( _QWORD * ) @@ptr@@ + Number ) ; if ( * ( ( _QWORD * ) @@ptr@@ + Number ) && * ( ( _QWORD * ) @@ptr@@ + Number ) ) { if ( ( unsigned __int64 ) @@v2@@ >= @@v3@@ ) goto LABEL_14 ; do { if ( * @@v2@@ ) { @@v4@@ = @@v2@@ ; do { ( * ( ( void ( * * ) ( void ) ) @@ptr@@ + Number ) ) ( ) ; @@v4@@ = ( _QWORD * ) @@v4@@ [ Number ] ; } while ( @@v4@@ ) ; @@v3@@ = * ( ( _QWORD * ) @@ptr@@ + Number ) ; } @@v2@@ += Number ; } while ( @@v3@@ > ( unsigned __int64 ) @@v2@@ ) ; @@v2@@ = * ( _QWORD * * ) @@ptr@@ ; } if ( ( unsigned __int64 ) @@v2@@ < @@v3@@ ) { do { @@v5@@ = ( _QWORD * ) @@v2@@ [ Number ] ; if ( @@v5@@ ) { do { @@v6@@ = ( _QWORD * ) @@v5@@ [ Number ] ; free ( @@v5@@ ) ; @@v5@@ = @@v6@@ ; } while ( @@v6@@ ) ; } @@v2@@ += Number ; } while ( * ( ( _QWORD * ) @@ptr@@ + Number ) > ( unsigned __int64 ) @@v2@@ ) ; } LABEL_14 : @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@ptr@@ + Number ) ; if ( @@v7@@ ) { do { @@v8@@ = ( _QWORD * ) @@v7@@ [ Number ] ; free ( @@v7@@ ) ; @@v7@@ = @@v8@@ ; } while ( @@v8@@ ) ; } free ( * ( void * * ) @@ptr@@ ) ; free ( @@ptr@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
__int64 __fastcall argmatch ( const char * @@a1@@ , const char * * @@a2@@ , char * @@a3@@ , size_t @@a4@@ ) { char * @@v5@@ ; size_t @@v6@@ ; const char * @@v7@@ ; size_t @@v8@@ ; __int64 @@v9@@ ; bool @@v10@@ ; char @@v11@@ ; __int64 @@v12@@ ; __int64 @@v14@@ ; char @@v15@@ ; @@v5@@ = @@a3@@ ; @@v6@@ = strlen ( @@a1@@ ) ; @@v7@@ = * @@a2@@ ; @@v14@@ = Number ; if ( ! * @@a2@@ ) return @@v14@@ ; @@v8@@ = @@v6@@ ; @@v15@@ = Number ; @@v9@@ = Number L ; do { while ( strncmp ( @@v7@@ , @@a1@@ , @@v8@@ ) ) { LABEL_7 : ++ @@v9@@ ; @@v5@@ += @@a4@@ ; @@v7@@ = @@a2@@ [ @@v9@@ ] ; if ( ! @@v7@@ ) goto LABEL_12 ; } if ( strlen ( @@v7@@ ) == @@v8@@ ) return @@v9@@ ; if ( @@v14@@ != Number ) { if ( @@a3@@ ) { @@v10@@ = memcmp ( & @@a3@@ [ @@a4@@ * @@v14@@ ] , @@v5@@ , @@a4@@ ) == Number ; @@v11@@ = @@v15@@ ; if ( ! @@v10@@ ) @@v11@@ = Number ; @@v15@@ = @@v11@@ ; } else { @@v15@@ = Number ; } goto LABEL_7 ; } @@v14@@ = @@v9@@ ++ ; @@v5@@ += @@a4@@ ; @@v7@@ = @@a2@@ [ @@v9@@ ] ; } while ( @@v7@@ ) ; LABEL_12 : @@v12@@ = Number ; if ( ! @@v15@@ ) @@v12@@ = @@v14@@ ; return @@v12@@ ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; char * @@v11@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String String String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v9@@ = stdout ; @@v10@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; @@v11@@ = setlocale ( Number , Number L ) ; if ( @@v11@@ ) { if ( strncmp ( @@v11@@ , String , Number ) ) { last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
unsigned __int64 __fastcall hash_pjw ( char * @@a1@@ , unsigned __int64 @@a2@@ ) { __int64 @@v2@@ ; unsigned __int64 @@v3@@ ; @@v2@@ = * @@a1@@ ; if ( ! ( _BYTE ) @@v2@@ ) return Number L ; @@v3@@ = Number L ; do { ++ @@a1@@ ; @@v3@@ = @@v2@@ + __ROL8__ ( @@v3@@ , Number ) ; @@v2@@ = * @@a1@@ ; } while ( ( _BYTE ) @@v2@@ ) ; return @@v3@@ % @@a2@@ ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
__int64 __fastcall _xargmatch_internal ( __int64 @@a1@@ , char * @@a2@@ , const char * * @@a3@@ , char * @@a4@@ , size_t @@a5@@ , void ( * @@a6@@ ) ( void ) ) { __int64 @@result@@ ; @@result@@ = argmatch ( @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; if ( @@result@@ < Number ) { argmatch_invalid ( @@a1@@ , ( wchar_t * ) @@a2@@ , @@result@@ ) ; argmatch_valid ( @@a3@@ , @@a4@@ , @@a5@@ ) ; @@a6@@ ( ) ; @@result@@ = Number ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall argmatch_to_argument ( void * @@s1@@ , __int64 * @@a2@@ , char * @@a3@@ , size_t @@a4@@ ) { __int64 @@v4@@ ; __int64 * @@v7@@ ; @@v4@@ = * @@a2@@ ; if ( * @@a2@@ ) { @@v7@@ = @@a2@@ + Number ; do { if ( ! memcmp ( @@s1@@ , @@a3@@ , @@a4@@ ) ) break ; @@v4@@ = * @@v7@@ ; @@a3@@ += @@a4@@ ; ++ @@v7@@ ; } while ( @@v4@@ ) ; } return @@v4@@ ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
__int64 __fastcall dir_name ( void * @@a1@@ ) { __int64 @@result@@ ; @@result@@ = mdir_name ( @@a1@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_2061F0 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061D0 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_2061E0 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall dir_len ( _BYTE * @@a1@@ ) { unsigned __int64 @@v1@@ ; _BYTE * @@v2@@ ; __int64 @@v3@@ ; @@v1@@ = * @@a1@@ == Number ; @@v2@@ = last_component ( @@a1@@ ) ; if ( @@v2@@ - @@a1@@ <= @@v1@@ ) return @@v2@@ - @@a1@@ ; @@v3@@ = @@v2@@ - @@a1@@ - Number ; if ( * ( @@v2@@ - Number ) != Number ) return @@v2@@ - @@a1@@ ; while ( @@v1@@ != @@v3@@ && @@a1@@ [ @@v3@@ - Number ] == Number ) -- @@v3@@ ; return @@v3@@ ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_2071F0 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2071D0 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2071E0 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@result@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ , @@v4@@ ) ; } return @@result@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
void * __fastcall xzalloc ( size_t @@n@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@n@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ , __int64 a3 , __int64 @@a4@@ ) { size_t @@v4@@ ; size_t @@v5@@ ; void * @@result@@ ; @@v4@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v4@@ > Number ) xalloc_die ( @@a1@@ , @@a2@@ , Number , @@a4@@ ) ; @@v5@@ = ( ( @@v4@@ + Number ) >> Number ) + @@v4@@ ; * @@a2@@ = @@v5@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v5@@ ) ; } else { if ( ! @@v4@@ ) @@v4@@ = Number L ; * @@a2@@ = @@v4@@ ; @@result@@ = xrealloc ( Number L , @@v4@@ ) ; } return @@result@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ , @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
char * __fastcall areadlinkat ( int @@fd@@ , char * @@path@@ ) { int @@v2@@ ; size_t @@v3@@ ; char * @@v4@@ ; ssize_t @@v5@@ ; size_t @@v6@@ ; int * @@v7@@ ; char * @@v8@@ ; size_t @@v10@@ ; char * @@v11@@ ; char * @@v12@@ ; ssize_t @@v13@@ ; char @@ptr@@ [ Number ] ; unsigned __int64 @@v15@@ ; @@v2@@ = Number ; @@v3@@ = Number L ; @@v15@@ = __readfsqword ( Number ) ; @@v4@@ = @@ptr@@ ; while ( Number ) { @@v5@@ = readlinkat ( @@fd@@ , @@path@@ , @@v4@@ , @@v3@@ ) ; @@v6@@ = @@v5@@ ; if ( @@v5@@ < Number ) { @@v13@@ = @@v5@@ ; @@v7@@ = __errno_location ( ) ; @@v6@@ = @@v13@@ ; if ( * @@v7@@ != Number ) { if ( @@v4@@ != @@ptr@@ ) { @@v8@@ = @@v4@@ ; @@v4@@ = Number L ; free ( @@v8@@ ) ; return @@v4@@ ; } return Number L ; } } if ( @@v6@@ < @@v3@@ ) break ; if ( @@v4@@ != @@ptr@@ ) free ( @@v4@@ ) ; @@v3@@ *= Number L ; if ( ! -- @@v2@@ ) { @@v4@@ = Number L ; * __errno_location ( ) = Number ; return @@v4@@ ; } @@v4@@ = ( char * ) malloc ( @@v3@@ ) ; if ( ! @@v4@@ ) return Number L ; } @@v4@@ [ @@v6@@ ] = Number ; @@v10@@ = @@v6@@ + Number ; if ( @@v4@@ == @@ptr@@ ) { @@v12@@ = ( char * ) malloc ( @@v6@@ + Number ) ; @@v4@@ = @@v12@@ ; if ( @@v12@@ ) memcpy ( @@v12@@ , @@ptr@@ , @@v10@@ ) ; } else if ( @@v3@@ > @@v10@@ ) { @@v11@@ = ( char * ) realloc ( @@v4@@ , @@v6@@ + Number ) ; if ( @@v11@@ ) @@v4@@ = @@v11@@ ; } return @@v4@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
int puts ( const char * @@s@@ ) { return puts ( @@s@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_2061D0 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061B0 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061C0 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
__int64 sysconf ( int @@name@@ ) { return sysconf ( @@name@@ ) ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
_BYTE * __fastcall mdir_name ( void * @@src@@ ) { __int64 @@v1@@ ; _BYTE * @@v2@@ ; _BYTE * @@v3@@ ; _BYTE * @@v4@@ ; @@v1@@ = dir_len ( @@src@@ ) ; @@v2@@ = malloc ( @@v1@@ + ( @@v1@@ == Number ) + Number ) ; @@v3@@ = @@v2@@ ; if ( @@v2@@ ) { @@v4@@ = memcpy ( @@v2@@ , @@src@@ , @@v1@@ ) ; @@v3@@ = @@v4@@ ; if ( ! @@v1@@ ) { * @@v4@@ = Number ; @@v1@@ = Number L ; } @@v4@@ [ @@v1@@ ] = Number ; } return @@v3@@ ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
__int64 __fastcall rpl_fcntl ( int @@a1@@ , int @@a2@@ , __int64 @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { int @@v6@@ ; int @@v8@@ ; int @@v9@@ ; int @@v10@@ ; int @@v11@@ ; int * @@v12@@ ; int @@v13@@ ; int * @@v14@@ ; int @@v15@@ ; @@v15@@ = @@a3@@ ; if ( @@a2@@ != Number ) return ( unsigned int ) fcntl ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( have_dupfd_cloexec_3202 < Number ) { @@v6@@ = ( ( __int64 ( __fastcall * ) ( int , _DWORD , _DWORD , int , int , int , char ) ) rpl_fcntl ) ( @@a1@@ , Number , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ , Number ) ; if ( @@v6@@ < Number || have_dupfd_cloexec_3202 != Number ) return ( unsigned int ) @@v6@@ ; } else { @@v6@@ = fcntl ( @@a1@@ , Number , ( unsigned int ) @@a3@@ ) ; if ( @@v6@@ >= Number || * __errno_location ( ) != Number ) { have_dupfd_cloexec_3202 = Number ; return ( unsigned int ) @@v6@@ ; } @@v6@@ = ( ( __int64 ( __fastcall * ) ( int , _DWORD , int , int , int , int , char ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v15@@ , @@v8@@ , @@v9@@ , @@v10@@ , Number ) ; if ( @@v6@@ < Number ) return ( unsigned int ) @@v6@@ ; have_dupfd_cloexec_3202 = Number ; } @@v11@@ = fcntl ( @@v6@@ , Number ) ; if ( @@v11@@ < Number || fcntl ( @@v6@@ , Number , @@v11@@ | Number ) == Number ) { @@v12@@ = __errno_location ( ) ; @@v13@@ = * @@v12@@ ; @@v14@@ = @@v12@@ ; close ( @@v6@@ ) ; @@v6@@ = Number ; * @@v14@@ = @@v13@@ ; } return ( unsigned int ) @@v6@@ ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
__int64 __fastcall num_processors ( int @@a1@@ ) { __int64 @@result@@ ; char * @@v2@@ ; int @@v3@@ ; char @@v4@@ ; char * @@v5@@ ; char * @@endptr@@ ; cpu_set_t @@cpuset@@ ; unsigned __int64 @@v8@@ ; @@v8@@ = __readfsqword ( Number ) ; if ( @@a1@@ == Number ) { @@v2@@ = getenv ( String ) ; if ( @@v2@@ ) { while ( Number ) { @@v3@@ = * @@v2@@ ; if ( ! * @@v2@@ ) break ; if ( ( unsigned __int8 ) ( @@v3@@ - Number ) > Number && ( _BYTE ) @@v3@@ != Number ) { if ( ( unsigned int ) ( @@v3@@ - Number ) > Number ) break ; @@endptr@@ = Number L ; @@result@@ = strtoul ( @@v2@@ , & @@endptr@@ , Number ) ; if ( ! @@endptr@@ ) break ; @@v4@@ = * @@endptr@@ ; if ( ! * @@endptr@@ ) { LABEL_22 : if ( ! @@result@@ ) @@result@@ = Number L ; return @@result@@ ; } @@v5@@ = @@endptr@@ + Number ; while ( ( unsigned __int8 ) ( @@v4@@ - Number ) <= Number || @@v4@@ == Number ) { @@endptr@@ = @@v5@@ ++ ; @@v4@@ = * ( @@v5@@ - Number ) ; if ( ! @@v4@@ ) goto LABEL_22 ; } break ; } ++ @@v2@@ ; } } LABEL_3 : if ( sched_getaffinity ( Number , Number , & @@cpuset@@ ) || ( @@result@@ = __sched_cpucount ( Number , & @@cpuset@@ ) , ! ( _DWORD ) @@result@@ ) ) { @@result@@ = sysconf ( Number ) ; if ( @@result@@ <= Number ) return Number L ; } return @@result@@ ; } if ( @@a1@@ == Number ) goto LABEL_3 ; @@result@@ = sysconf ( Number ) ; if ( @@result@@ <= Number ) return Number L ; return @@result@@ ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_2071F0 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2071D0 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_2071E0 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; char * @@v10@@ ; char * @@v11@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String String String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = dcgettext ( Number L , String String String String , Number ) ; __printf_chk ( ) ; last_component ( program_name , @@v7@@ ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v8@@ = stdout ; @@v9@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = Number L ; @@v11@@ = setlocale ( Number , Number L ) ; if ( @@v11@@ ) { @@v10@@ = String ; if ( strncmp ( @@v11@@ , String , Number ) ) { last_component ( program_name , String ) ; @@v10@@ = dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name , @@v10@@ ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
int __cdecl __noreturn main ( int @@argc@@ , const char * * @@argv@@ , const char * * envp ) { unsigned int @@v3@@ ; int @@v4@@ ; char * @@v5@@ ; char * @@v6@@ ; @@v3@@ = Number ; set_program_name ( * @@argv@@ ) ; setlocale ( Number , String ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; while ( Number ) { @@v4@@ = getopt_long ( @@argc@@ , ( char * const * ) @@argv@@ , String , & longopts , Number L ) ; if ( @@v4@@ == Number ) { num_processors ( @@v3@@ ) ; __printf_chk ( ) ; exit ( Number ) ; } if ( @@v4@@ == Number ) usage ( Number ) ; if ( @@v4@@ <= Number ) break ; if ( @@v4@@ == Number ) { @@v3@@ = Number ; } else { if ( @@v4@@ != Number ) goto LABEL_12 ; if ( ( unsigned int ) xstrtoul ( optarg ) ) { @@v5@@ = optarg ; @@v6@@ = dcgettext ( Number L , String , Number ) ; error ( Number , Number , @@v6@@ , @@v5@@ ) ; usage ( Number ) ; } } } if ( @@v4@@ == Number ) { version_etc ( ( _DWORD ) stdout , ( unsigned int ) String , ( unsigned int ) & unk_40F5 , ( _DWORD ) Version , ( unsigned int ) String , Number , Number ) ; exit ( Number ) ; } LABEL_12 : usage ( Number ) ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_2061F0 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061D0 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_2061E0 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
int __fxstat ( int @@ver@@ , int @@fildes@@ , struct stat * @@stat_buf@@ ) { return _fxstat ( @@ver@@ , @@fildes@@ , @@stat_buf@@ ) ; }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; char * @@v9@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = setlocale ( Number , Number L ) ; if ( @@v9@@ ) { if ( strncmp ( @@v9@@ , String , Number ) ) { last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; char * @@v11@@ ; FILE * @@v12@@ ; char * @@v13@@ ; char * @@v14@@ ; char * @@v15@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String String String String String String String String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String String String String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = stdout ; @@v10@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; @@v11@@ = dcgettext ( Number L , String String String String , Number ) ; __printf_chk ( ) ; last_component ( program_name , @@v11@@ ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v12@@ = stdout ; @@v13@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v13@@ , @@v12@@ ) ; @@v14@@ = Number L ; @@v15@@ = setlocale ( Number , Number L ) ; if ( @@v15@@ ) { @@v14@@ = String ; if ( strncmp ( @@v15@@ , String , Number ) ) { last_component ( program_name , String ) ; @@v14@@ = dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name , @@v14@@ ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
int __cdecl __noreturn main ( int @@argc@@ , const char * * @@argv@@ , const char * * @@envp@@ ) { char * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; const char * @@v7@@ ; char * @@v8@@ ; const char * @@v9@@ ; set_program_name ( * @@argv@@ , @@argv@@ , @@envp@@ ) ; setlocale ( Number , String ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; parse_long_options ( @@argc@@ , ( _DWORD ) @@argv@@ , ( unsigned int ) String , ( unsigned int ) & unk_3C26 , ( _DWORD ) Version , ( unsigned int ) usage , String , Number L ) ; if ( getopt_long ( @@argc@@ , ( char * const * ) @@argv@@ , String , Number L , Number L ) == Number ) { if ( optind < @@argc@@ ) { if ( optind + Number < @@argc@@ ) { @@v5@@ = quote ( @@argv@@ [ optind + Number ] ) ; @@v6@@ = dcgettext ( Number L , String , Number ) ; error ( Number , Number , @@v6@@ , @@v5@@ ) ; usage ( Number ) ; } @@v3@@ = ( char * ) base_name ( @@argv@@ [ optind ] ) ; strip_trailing_slashes ( @@v3@@ ) ; if ( optind + Number == @@argc@@ && * @@v3@@ != Number ) { @@v7@@ = @@argv@@ [ optind + Number ] ; @@v8@@ = & @@v3@@ [ strlen ( @@v3@@ ) ] ; @@v9@@ = & @@v7@@ [ strlen ( @@v7@@ ) ] ; while ( @@v3@@ < @@v8@@ && @@v7@@ < @@v9@@ ) { if ( * -- @@v8@@ != * -- @@v9@@ ) goto LABEL_5 ; } if ( @@v3@@ < @@v8@@ ) * @@v8@@ = Number ; } LABEL_5 : puts ( @@v3@@ ) ; free ( @@v3@@ ) ; exit ( Number ) ; } @@v4@@ = dcgettext ( Number L , String , Number ) ; error ( Number , Number , @@v4@@ ) ; } usage ( Number ) ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_2061D0 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061B0 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_2061C0 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_2061F0 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061D0 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061E0 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_2061F0 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061D0 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061E0 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
int __cdecl __noreturn main ( int @@argc@@ , const char * * @@argv@@ , const char * * envp ) { int @@v4@@ ; int @@i@@ ; int @@v6@@ ; const char * * @@v7@@ ; int @@v8@@ ; char * @@v9@@ ; char * @@v10@@ ; int * @@v11@@ ; @@v4@@ = @@argc@@ ; set_program_name ( * @@argv@@ ) ; setlocale ( Number , String ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; parse_long_options ( @@argc@@ , ( _DWORD ) @@argv@@ , ( unsigned int ) String , ( unsigned int ) & unk_3A16 , ( _DWORD ) Version , ( unsigned int ) usage , String , Number L ) ; if ( getopt_long ( @@argc@@ , ( char * const * ) @@argv@@ , String , Number L , Number L ) != Number ) usage ( Number ) ; if ( optind >= @@argc@@ ) { optind = @@argc@@ ; @@v4@@ = @@argc@@ + Number ; @@argv@@ [ @@argc@@ ] = String ; } for ( @@i@@ = optind ; ; @@i@@ = optind ) { do @@v6@@ = @@i@@ ; while ( @@i@@ >= @@v4@@ ) ; @@v7@@ = & @@argv@@ [ @@i@@ ] ; do { if ( fputs_unlocked ( * @@v7@@ , stdout ) == Number ) { LABEL_14 : @@v10@@ = dcgettext ( Number L , String , Number ) ; @@v11@@ = __errno_location ( ) ; error ( Number , * @@v11@@ , @@v10@@ ) ; exit ( Number ) ; } @@v8@@ = Number ; if ( @@v4@@ - Number != @@v6@@ ) @@v8@@ = Number ; @@v9@@ = stdout -> _IO_write_ptr ; if ( @@v9@@ < stdout -> _IO_write_end ) { stdout -> _IO_write_ptr = @@v9@@ + Number ; * @@v9@@ = @@v8@@ ; } else if ( __overflow ( stdout , @@v8@@ ) == Number ) { goto LABEL_14 ; } ++ @@v6@@ ; ++ @@v7@@ ; } while ( @@v6@@ != @@v4@@ ) ; } }
__int64 __fastcall knuth_morris_pratt_unibyte ( unsigned __int8 * @@a1@@ , const char * @@a2@@ , unsigned __int8 * * @@a3@@ ) { const char * @@v4@@ ; size_t @@v6@@ ; void * @@v7@@ ; __int64 * @@v8@@ ; __int64 @@v9@@ ; __int64 @@i@@ ; char @@v11@@ ; __int64 @@v12@@ ; unsigned __int8 * @@v13@@ ; __int64 @@v14@@ ; __int64 @@v16@@ ; @@v4@@ = @@a2@@ ; @@v6@@ = strlen ( @@a2@@ ) ; if ( @@v6@@ > Number ) return Number L ; if ( Number * @@v6@@ > Number ) { @@v8@@ = ( __int64 * ) mmalloca ( ) ; } else { @@v7@@ = alloca ( Number * @@v6@@ + Number ) ; @@v8@@ = & @@v16@@ ; } if ( ! @@v8@@ ) return Number L ; @@v8@@ [ Number ] = Number L ; if ( @@v6@@ > Number ) { @@v9@@ = Number L ; for ( @@i@@ = Number L ; @@i@@ != @@v6@@ ; ++ @@i@@ ) { @@v11@@ = @@a2@@ [ @@i@@ - Number ] ; if ( @@v11@@ == @@a2@@ [ @@v9@@ ] ) { LABEL_23 : ++ @@v9@@ ; @@v8@@ [ @@i@@ ] = @@i@@ - @@v9@@ ; } else { while ( @@v9@@ ) { @@v9@@ -= @@v8@@ [ @@v9@@ ] ; if ( @@v11@@ == @@a2@@ [ @@v9@@ ] ) goto LABEL_23 ; } @@v8@@ [ @@i@@ ] = @@i@@ ; @@v9@@ = Number L ; } } } * @@a3@@ = Number L ; @@v12@@ = * @@a1@@ ; @@v13@@ = @@a1@@ ; @@v14@@ = Number L ; LABEL_14 : while ( Number ) { if ( ( _BYTE ) @@v12@@ ) { while ( @@v4@@ [ @@v14@@ ] != ( _BYTE ) @@v12@@ ) { if ( ! @@v14@@ ) { @@v12@@ = @@v13@@ [ Number ] ; ++ @@a1@@ ; ++ @@v13@@ ; goto LABEL_14 ; } @@a2@@ = ( const char * ) @@v8@@ [ @@v14@@ ] ; @@a1@@ = & @@a1@@ [ ( _QWORD ) @@a2@@ ] ; @@v14@@ -= ( __int64 ) @@a2@@ ; } ++ @@v14@@ ; @@a2@@ = ( const char * ) ( @@v13@@ + Number ) ; if ( @@v6@@ != @@v14@@ ) { @@v12@@ = * ++ @@v13@@ ; continue ; } * @@a3@@ = @@a1@@ ; } break ; } freea ( @@v8@@ , @@a2@@ , @@v12@@ , @@v13@@ ) ; return Number L ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; FILE * @@v11@@ ; char * @@v12@@ ; FILE * @@v13@@ ; char * @@v14@@ ; FILE * @@v15@@ ; char * @@v16@@ ; FILE * @@v17@@ ; char * @@v18@@ ; FILE * @@v19@@ ; char * @@v20@@ ; char * @@v21@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String String String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String String String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = stdout ; @@v10@@ = dcgettext ( Number L , String String , Number ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; @@v11@@ = stdout ; @@v12@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v12@@ , @@v11@@ ) ; @@v13@@ = stdout ; @@v14@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v14@@ , @@v13@@ ) ; @@v15@@ = stdout ; @@v16@@ = dcgettext ( Number L , String String String String , Number ) ; fputs_unlocked ( @@v16@@ , @@v15@@ ) ; @@v17@@ = stdout ; @@v18@@ = dcgettext ( Number L , String String String String String String String String String String String String String , Number ) ; fputs_unlocked ( @@v18@@ , @@v17@@ ) ; last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v19@@ = stdout ; @@v20@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v20@@ , @@v19@@ ) ; @@v21@@ = setlocale ( Number , Number L ) ; if ( @@v21@@ ) { if ( strncmp ( @@v21@@ , String , Number ) ) { last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
char * __fastcall xstrndup ( const char * @@a1@@ , size_t @@a2@@ ) { char * @@result@@ ; @@result@@ = strndup ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
const char * __fastcall proper_name ( char * @@s@@ ) { char * @@v1@@ ; const char * @@v2@@ ; size_t @@v4@@ ; size_t @@v5@@ ; __int64 @@v6@@ ; @@v1@@ = dcgettext ( Number L , @@s@@ , Number ) ; @@v2@@ = @@v1@@ ; if ( @@s@@ == @@v1@@ || ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@v1@@ , ( __int64 ) @@s@@ ) ) { return @@v2@@ ; } @@v4@@ = strlen ( @@v2@@ ) ; @@v5@@ = strlen ( @@s@@ ) ; @@v6@@ = xmalloc ( @@v4@@ + @@v5@@ + Number ) ; __sprintf_chk ( ) ; return ( const char * ) @@v6@@ ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
int iswalnum ( wint_t @@wc@@ ) { return iswalnum ( @@wc@@ ) ; }
int iconv_close ( iconv_t @@cd@@ ) { return iconv_close ( @@cd@@ ) ; }
char * strdup ( const char * @@s@@ ) { return strdup ( @@s@@ ) ; }
__int64 __fastcall preorder ( _QWORD * @@a1@@ , __int64 ( __fastcall * @@a2@@ ( ) ( void , bintreet0 ) ) ( __int64 , _QWORD * ) , __int64 @@a3@@ ) { _QWORD * @@v4@@ ; __int64 @@result@@ ; _QWORD * @@v6@@ ; _QWORD * @@v7@@ ; @@v4@@ = @@a1@@ ; for ( @@result@@ = @@a2@@ ( ) ( void , bintreet0 ) ( @@a3@@ , @@a1@@ ) ; ! ( _DWORD ) @@result@@ ; @@result@@ = @@a2@@ ( ) ( void , bintreet0 ) ( @@a3@@ , @@v6@@ ) ) { @@v6@@ = ( _QWORD * ) @@v4@@ [ Number ] ; @@v7@@ = Number L ; if ( ! @@v6@@ ) { while ( Number ) { @@v6@@ = ( _QWORD * ) @@v4@@ [ Number ] ; if ( @@v6@@ != @@v7@@ ) { if ( @@v6@@ ) break ; } @@v7@@ = @@v4@@ ; if ( ! * @@v4@@ ) return @@result@@ ; @@v4@@ = ( _QWORD * ) * @@v4@@ ; } } @@v4@@ = @@v6@@ ; } return @@result@@ ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
__int64 __fastcall full_write ( int @@fd@@ , void * @@buf@@ , size_t @@n@@ ) { size_t @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; if ( ! @@n@@ ) return Number L ; @@v4@@ = @@n@@ ; @@v5@@ = Number L ; do { @@v6@@ = safe_write ( @@fd@@ , @@buf@@ , @@v4@@ ) ; if ( @@v6@@ == Number ) break ; if ( ! @@v6@@ ) { * __errno_location ( ) = Number ; return @@v5@@ ; } @@v5@@ += @@v6@@ ; @@buf@@ = ( char * ) @@buf@@ + @@v6@@ ; @@v4@@ -= @@v6@@ ; } while ( @@v4@@ ) ; return @@v5@@ ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
_QWORD * __fastcall re_node_set_insert ( _QWORD * @@a1@@ , unsigned __int64 @@a2@@ ) { __int64 @@v3@@ ; unsigned __int64 * @@v4@@ ; _QWORD * @@result@@ ; unsigned __int64 * @@v6@@ ; unsigned __int64 @@v7@@ ; unsigned __int64 @@i@@ ; bool @@v9@@ ; if ( * @@a1@@ ) { @@v3@@ = @@a1@@ [ Number ] ; @@v4@@ = ( unsigned __int64 * ) @@a1@@ [ Number ] ; if ( ! @@v3@@ ) { * @@v4@@ = @@a2@@ ; ++ @@a1@@ [ Number ] ; return ( _QWORD * ) ( & dword_0 + Number ) ; } if ( * @@a1@@ != @@v3@@ ) { if ( @@a2@@ < * @@v4@@ ) goto LABEL_8 ; goto LABEL_12 ; } * @@a1@@ = Number * @@v3@@ ; @@v4@@ = ( unsigned __int64 * ) realloc ( @@v4@@ , Number * @@v3@@ ) ; if ( @@v4@@ ) { @@v9@@ = * @@v4@@ <= @@a2@@ ; @@a1@@ [ Number ] = @@v4@@ ; @@v3@@ = @@a1@@ [ Number ] ; if ( ! @@v9@@ ) { if ( ! @@v3@@ ) { LABEL_11 : * ( unsigned __int64 * ) ( ( char * ) @@v4@@ + @@v3@@ ) = @@a2@@ ; @@result@@ = ( _QWORD * ) ( & dword_0 + Number ) ; ++ @@a1@@ [ Number ] ; return @@result@@ ; } LABEL_8 : @@v6@@ = & @@v4@@ [ @@v3@@ ] ; do { @@v7@@ = * -- @@v6@@ ; @@v6@@ [ Number ] = @@v7@@ ; } while ( @@v6@@ != @@v4@@ ) ; @@v3@@ = Number L ; goto LABEL_11 ; } LABEL_12 : @@v3@@ *= Number L ; for ( @@i@@ = * ( unsigned __int64 * ) ( ( char * ) @@v4@@ + @@v3@@ - Number ) ; @@i@@ > @@a2@@ ; @@i@@ = * ( unsigned __int64 * ) ( ( char * ) @@v4@@ + @@v3@@ - Number ) ) { * ( unsigned __int64 * ) ( ( char * ) @@v4@@ + @@v3@@ ) = @@i@@ ; @@v3@@ -= Number L ; } goto LABEL_11 ; } @@result@@ = Number L ; } else { * @@a1@@ = Number L ; @@a1@@ [ Number ] = Number L ; @@result@@ = malloc ( Number ) ; @@a1@@ [ Number ] = @@result@@ ; if ( @@result@@ ) { * @@result@@ = @@a2@@ ; @@result@@ = ( _QWORD * ) ( & dword_0 + Number ) ; } else { @@a1@@ [ Number ] = Number L ; * @@a1@@ = Number L ; } } return @@result@@ ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
void __fastcall re_string_destruct ( __int64 @@a1@@ ) { free ( * ( void * * ) ( @@a1@@ + Number ) ) ; free ( * ( void * * ) ( @@a1@@ + Number ) ) ; if ( * ( _BYTE * ) ( @@a1@@ + Number ) ) free ( * ( void * * ) ( @@a1@@ + Number ) ) ; }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
unsigned __int64 __fastcall re_node_set_contains_isra_3 ( __int64 @@a1@@ , __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@result@@ ; __int64 @@v5@@ ; unsigned __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; unsigned __int64 @@v8@@ ; @@v3@@ = @@a1@@ - Number ; @@result@@ = Number L ; if ( @@v3@@ <= Number ) { @@v5@@ = * @@a2@@ ; @@v6@@ = Number L ; while ( @@v6@@ < @@v3@@ ) { @@v7@@ = ( @@v6@@ + @@v3@@ ) >> Number ; if ( @@a3@@ <= * ( _QWORD * ) ( @@v5@@ + Number * @@v7@@ ) ) { while ( @@v6@@ < @@v7@@ ) { @@v8@@ = ( @@v6@@ + @@v7@@ ) >> Number ; if ( * ( _QWORD * ) ( @@v5@@ + Number * @@v8@@ ) < @@a3@@ ) goto LABEL_11 ; @@v7@@ = ( @@v6@@ + @@v7@@ ) >> Number ; } break ; } @@v8@@ = ( @@v6@@ + @@v3@@ ) >> Number ; @@v7@@ = @@v3@@ ; LABEL_11 : @@v6@@ = @@v8@@ + Number ; @@v3@@ = @@v7@@ ; } @@result@@ = Number L ; if ( @@a3@@ == * ( _QWORD * ) ( @@v5@@ + Number * @@v6@@ ) ) @@result@@ = @@v6@@ + Number ; } return @@result@@ ; }
size_t __fastcall mbslen ( char * @@s@@ ) { __int64 @@i@@ ; int @@v3@@ ; wchar_t @@v4@@ ; size_t @@v5@@ ; size_t @@v6@@ ; size_t @@v7@@ ; size_t @@v8@@ ; char @@v9@@ ; mbstate_t @@v10@@ ; char @@v11@@ ; char * @@sa@@ ; size_t @@v13@@ ; char @@v14@@ ; wchar_t @@v15@@ [ Number ] ; unsigned __int64 @@v16@@ ; @@v16@@ = __readfsqword ( Number ) ; if ( __ctype_get_mb_cur_max ( ) > Number ) { @@sa@@ = @@s@@ ; @@v9@@ = Number ; @@v10@@ = Number L ; @@v11@@ = Number ; for ( @@i@@ = Number L ; ; ++ @@i@@ ) { if ( ! @@v9@@ ) { @@v3@@ = * ( ( _DWORD * ) & is_basic_table + ( ( ( unsigned __int8 ) * @@sa@@ >> Number ) & Number ) ) ; if ( _bittest ( & @@v3@@ , ( unsigned __int8 ) * @@sa@@ ) ) { @@v13@@ = Number L ; @@v4@@ = * @@sa@@ ; @@v14@@ = Number ; @@v11@@ = Number ; @@v15@@ [ Number ] = @@v4@@ ; goto LABEL_7 ; } if ( ! mbsinit ( & @@v10@@ ) ) __assert_fail ( String , String , Number , String ) ; @@v9@@ = Number ; } @@v5@@ = __ctype_get_mb_cur_max ( ) ; @@v6@@ = strnlen1 ( @@sa@@ , @@v5@@ ) ; @@v7@@ = mbrtowc ( @@v15@@ , @@sa@@ , @@v6@@ , & @@v10@@ ) ; @@v13@@ = @@v7@@ ; switch ( @@v7@@ ) { case Number : @@v13@@ = Number L ; @@v14@@ = Number ; goto LABEL_8 ; case Number : @@v8@@ = strlen ( @@sa@@ ) ; @@v14@@ = Number ; @@v13@@ = @@v8@@ ; goto LABEL_8 ; case Number : @@v13@@ = Number L ; if ( * @@sa@@ ) __assert_fail ( String , String , Number , String ) ; if ( @@v15@@ [ Number ] ) __assert_fail ( String , String , Number , String ) ; break ; } @@v14@@ = Number ; if ( mbsinit ( & @@v10@@ ) ) @@v9@@ = Number ; @@v11@@ = Number ; LABEL_7 : if ( ! @@v15@@ [ Number ] ) return @@i@@ ; LABEL_8 : @@sa@@ += @@v13@@ ; @@v11@@ = Number ; } } return strlen ( @@s@@ ) ; }
char * nl_langinfo ( nl_item @@item@@ ) { return nl_langinfo ( @@item@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
__int64 __fastcall check_arrival_expand_ecl ( _QWORD * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , unsigned int @@a4@@ ) { unsigned __int64 @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; __int64 @@v12@@ ; __int64 @@v13@@ ; __int64 @@v14@@ ; unsigned int @@v15@@ ; __m128i @@v16@@ ; __int64 @@result@@ ; unsigned int @@v18@@ ; __m128i @@v19@@ ; void * @@ptr@@ ; unsigned __int64 @@v21@@ ; @@v7@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@v21@@ = __readfsqword ( Number ) ; @@v19@@ = ( __m128i ) @@v7@@ ; @@ptr@@ = malloc ( Number * @@v7@@ ) ; if ( @@ptr@@ ) { if ( ! @@v7@@ ) { LABEL_12 : free ( * ( void * * ) ( @@a2@@ + Number ) ) ; @@v16@@ = _mm_load_si128 ( & @@v19@@ ) ; * ( _QWORD * ) ( @@a2@@ + Number ) = @@ptr@@ ; @@result@@ = Number L ; * ( __m128i * ) @@a2@@ = @@v16@@ ; return @@result@@ ; } @@v8@@ = Number L ; while ( Number ) { @@v9@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number * @@v8@@ ) ; @@v10@@ = @@a1@@ [ Number ] + Number * @@v9@@ ; @@v11@@ = * ( _QWORD * ) ( @@v10@@ + Number ) ; if ( ! @@v11@@ ) goto LABEL_13 ; @@v12@@ = * ( _QWORD * ) ( @@v10@@ + Number ) ; @@v13@@ = Number L ; while ( Number ) { @@v14@@ = * @@a1@@ + Number L * * ( _QWORD * ) ( @@v12@@ + Number * @@v13@@ ) ; if ( @@a4@@ == * ( unsigned __int8 * ) ( @@v14@@ + Number ) && @@a3@@ == * ( _QWORD * ) @@v14@@ ) { break ; } if ( @@v11@@ == ++ @@v13@@ ) goto LABEL_13 ; } if ( * ( _QWORD * ) ( @@v12@@ + Number * @@v13@@ ) == Number ) { LABEL_13 : @@v15@@ = re_node_set_merge ( ( __int64 ) & @@v19@@ , @@v10@@ ) ; if ( @@v15@@ ) { LABEL_14 : @@v18@@ = @@v15@@ ; free ( @@ptr@@ ) ; return @@v18@@ ; } } else { @@v15@@ = check_arrival_expand_ecl_sub ( @@a1@@ , & @@v19@@ , @@v9@@ , @@a3@@ , @@a4@@ ) ; if ( @@v15@@ ) goto LABEL_14 ; } if ( * ( _QWORD * ) ( @@a2@@ + Number ) <= ( unsigned __int64 ) ++ @@v8@@ ) goto LABEL_12 ; } } return Number L ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 __fastcall base_name ( __int64 @@a1@@ , __int64 @@a2@@ ) { _BYTE * @@v2@@ ; _BYTE * @@v3@@ ; __int64 @@v4@@ ; __int64 @@result@@ ; __int64 @@v6@@ ; @@v2@@ = ( _BYTE * ) last_component ( @@a1@@ , @@a2@@ ) ; if ( * @@v2@@ ) { @@v3@@ = @@v2@@ ; @@v4@@ = base_len ( @@v2@@ ) ; @@result@@ = xstrndup ( @@v3@@ , ( @@v3@@ [ @@v4@@ ] == Number ) + @@v4@@ ) ; } else { @@v6@@ = base_len ( @@a1@@ ) ; @@result@@ = xstrndup ( @@a1@@ , @@v6@@ ) ; } return @@result@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
__int64 __fastcall check_halt_state_context_isra_23 ( __int64 @@a1@@ , __int64 @@a2@@ , _QWORD * @@a3@@ , unsigned __int64 @@a4@@ ) { char @@v6@@ ; __int64 @@v7@@ ; int @@v8@@ ; int @@v9@@ ; int @@v10@@ ; __int64 @@result@@ ; __int64 @@v12@@ ; int @@v13@@ ; @@v6@@ = re_string_context_at ( @@a1@@ , @@a4@@ , * ( _DWORD * ) ( @@a1@@ + Number ) ) ; if ( @@a2@@ ) { @@v7@@ = Number L ; @@v8@@ = @@v6@@ & Number ; @@v9@@ = @@v6@@ & Number ; @@v10@@ = @@v6@@ & Number ; while ( Number ) { @@result@@ = * ( _QWORD * ) ( * @@a3@@ + Number * @@v7@@ ) ; @@v12@@ = * * ( _QWORD * * ) ( @@a1@@ + Number ) + Number * @@result@@ ; @@v13@@ = * ( _DWORD * ) ( @@v12@@ + Number ) >> Number ; if ( * ( _BYTE * ) ( @@v12@@ + Number ) != Number ) goto LABEL_3 ; if ( ( @@v13@@ & Number ) == Number ) return @@result@@ ; if ( ( @@v13@@ & Number ) != Number ) break ; if ( ( @@v13@@ & Number ) == Number ) goto LABEL_9 ; if ( @@v10@@ ) goto LABEL_3 ; if ( ( @@v13@@ & Number ) != Number ) { LABEL_10 : if ( ! @@v9@@ ) goto LABEL_3 ; } LABEL_11 : if ( ( @@v13@@ & Number ) == Number || @@v8@@ ) return @@result@@ ; LABEL_3 : if ( ++ @@v7@@ == @@a2@@ ) return Number L ; } if ( ! @@v10@@ || ( @@v13@@ & Number ) != Number ) goto LABEL_3 ; LABEL_9 : if ( ( @@v13@@ & Number ) != Number ) goto LABEL_10 ; goto LABEL_11 ; } return Number L ; }
size_t __fastcall strnlen1 ( const void * @@a1@@ , size_t @@a2@@ ) { _BYTE * @@v2@@ ; __int64 @@v3@@ ; bool @@v4@@ ; size_t @@result@@ ; @@v2@@ = memchr ( @@a1@@ , Number , @@a2@@ ) ; @@v3@@ = @@v2@@ - ( _BYTE * ) @@a1@@ + Number ; @@v4@@ = @@v2@@ == Number L ; @@result@@ = @@a2@@ ; if ( ! @@v4@@ ) @@result@@ = @@v3@@ ; return @@result@@ ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
__int64 __fastcall build_equiv_class_isra_29 ( __int64 @@a1@@ , const char * @@a2@@ ) { if ( strlen ( @@a2@@ ) != Number ) return Number L ; * ( _QWORD * ) ( @@a1@@ + ( ( ( unsigned __int64 ) * ( unsigned __int8 * ) @@a2@@ >> Number ) & Number ) ) |= Number L << ( * @@a2@@ & Number ) ; return Number L ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
char * __fastcall rpl_re_compile_pattern ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v3@@ ; int @@v4@@ ; char * @@result@@ ; @@v3@@ = rpl_re_syntax_options ; * ( _BYTE * ) ( @@a3@@ + Number ) = ( Number * ( ( rpl_re_syntax_options & Number ) != Number ) ) | * ( _BYTE * ) ( @@a3@@ + Number ) & Number | Number ; @@v4@@ = re_compile_internal ( @@a3@@ , @@a1@@ , @@a2@@ , @@v3@@ ) ; if ( @@v4@@ ) @@result@@ = dcgettext ( Number L , & _re_error_msgid [ _re_error_msgid_idx [ @@v4@@ ] ] , Number ) ; else @@result@@ = Number L ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 __fastcall rpl_re_set_syntax ( __int64 @@a1@@ ) { __int64 @@result@@ ; @@result@@ = rpl_re_syntax_options ; rpl_re_syntax_options = @@a1@@ ; return @@result@@ ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_20B210 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20B1F0 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_20B200 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
__int64 __fastcall re_search_2_stub ( __int64 @@a1@@ , const void * @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ , unsigned __int64 @@a6@@ , __int64 @@a7@@ , unsigned __int64 * @@a8@@ , __int64 @@a9@@ , char @@a10@@ ) { unsigned __int64 @@v10@@ ; unsigned __int64 @@v12@@ ; char * @@v13@@ ; __int64 @@v15@@ ; char * @@v17@@ ; const void * @@v18@@ ; @@v10@@ = @@a5@@ + @@a3@@ ; if ( __CFADD__ ( @@a5@@ , @@a3@@ ) ) return Number ; @@v12@@ = @@a6@@ ; if ( ! @@a5@@ ) { @@a4@@ = ( __int64 ) @@a2@@ ; @@v13@@ = Number L ; goto LABEL_4 ; } @@v13@@ = Number L ; if ( @@a3@@ ) { @@v17@@ = ( char * ) malloc ( @@a5@@ + @@a3@@ ) ; @@v13@@ = @@v17@@ ; if ( @@v17@@ ) { memcpy ( @@v17@@ , @@a2@@ , @@a3@@ ) ; @@v18@@ = ( const void * ) @@a4@@ ; @@a4@@ = ( __int64 ) @@v13@@ ; memcpy ( & @@v13@@ [ @@a3@@ ] , @@v18@@ , @@a5@@ ) ; @@v12@@ = @@a6@@ ; goto LABEL_4 ; } return Number ; } LABEL_4 : @@v15@@ = re_search_stub ( @@a1@@ , @@a4@@ , @@v10@@ , @@v12@@ , @@a7@@ , @@a9@@ , @@a8@@ , @@a10@@ ) ; free ( @@v13@@ ) ; return @@v15@@ ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_219690 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_219670 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_219680 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
void __fastcall rpl_regfree ( __int64 @@a1@@ ) { void * @@v2@@ ; void * @@v3@@ ; void * @@v4@@ ; @@v2@@ = * ( void * * ) @@a1@@ ; if ( @@v2@@ ) free_dfa_content ( @@v2@@ ) ; @@v3@@ = * ( void * * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) @@a1@@ = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; free ( @@v3@@ ) ; @@v4@@ = * ( void * * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; free ( @@v4@@ ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
__int64 __fastcall re_string_realloc_buffers ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { void * @@v3@@ ; void * @@v4@@ ; void * @@v5@@ ; void * @@v7@@ ; if ( * ( int * ) ( @@a1@@ + Number ) > Number ) { if ( ! is_mul_ok ( @@a2@@ , Number ) ) return Number L ; @@v3@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number * @@a2@@ ) ; if ( ! @@v3@@ ) return Number L ; @@v4@@ = * ( void * * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v3@@ ; if ( @@v4@@ ) { @@v5@@ = realloc ( @@v4@@ , Number * @@a2@@ ) ; if ( ! @@v5@@ ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v5@@ ; } } if ( ! * ( _BYTE * ) ( @@a1@@ + Number ) ) { LABEL_8 : * ( _QWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; return Number L ; } @@v7@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , @@a2@@ ) ; if ( @@v7@@ ) { * ( _QWORD * ) ( @@a1@@ + Number ) = @@v7@@ ; goto LABEL_8 ; } return Number L ; }
bool __fastcall strip_trailing_slashes ( char * @@a1@@ ) { const char * @@v1@@ ; const char * @@v2@@ ; bool @@v3@@ ; @@v1@@ = last_component ( @@a1@@ ) ; if ( ! * @@v1@@ ) @@v1@@ = @@a1@@ ; @@v2@@ = & @@v1@@ [ base_len ( @@v1@@ ) ] ; @@v3@@ = * @@v2@@ == Number ; * @@v2@@ = Number ; return ! @@v3@@ ; }
char * __fastcall mmalloca ( __int64 @@a1@@ ) { bool @@v1@@ ; size_t @@v2@@ ; _DWORD * @@v3@@ ; char * @@v4@@ ; unsigned __int64 @@v5@@ ; __int64 @@v6@@ ; @@v1@@ = __CFADD__ ( @@a1@@ , Number L ) ; @@v2@@ = @@a1@@ + Number ; if ( @@v1@@ ) return Number L ; @@v3@@ = malloc ( @@v2@@ ) ; @@v4@@ = Number L ; if ( @@v3@@ ) { @@v3@@ [ Number ] = Number ; @@v4@@ = ( char * ) ( @@v3@@ + Number ) ; @@v5@@ = ( unsigned __int64 ) ( @@v3@@ + Number ) % Number ; @@v6@@ = mmalloca_results [ @@v5@@ ] ; mmalloca_results [ @@v5@@ ] = @@v3@@ + Number ; * ( _QWORD * ) @@v3@@ = @@v6@@ ; } return @@v4@@ ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
__int64 __fastcall rpl_re_set_registers ( __int64 @@a1@@ , _QWORD * @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ ) { __int64 @@result@@ ; if ( @@a3@@ ) { @@result@@ = * ( _BYTE * ) ( @@a1@@ + Number ) & Number | Number ; * ( _BYTE * ) ( @@a1@@ + Number ) = * ( _BYTE * ) ( @@a1@@ + Number ) & Number | Number ; * @@a2@@ = @@a3@@ ; @@a2@@ [ Number ] = @@a4@@ ; @@a2@@ [ Number ] = @@a5@@ ; } else { * ( _BYTE * ) ( @@a1@@ + Number ) &= Number ; * @@a2@@ = Number L ; @@a2@@ [ Number ] = Number L ; @@a2@@ [ Number ] = Number L ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
__int64 __fastcall duplicate_node ( __int64 * @@a1@@ , __int64 @@a2@@ , __int16 @@a3@@ ) { __int64 @@v3@@ ; __int64 @@result@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; unsigned int @@v9@@ ; unsigned int @@v10@@ ; @@v3@@ = Number * @@a2@@ ; @@result@@ = re_dfa_add_node ( ( __int64 ) @@a1@@ , * ( _QWORD * ) ( * @@a1@@ + Number * @@a2@@ ) , * ( _QWORD * ) ( * @@a1@@ + Number * @@a2@@ + Number ) ) ; if ( @@result@@ != Number ) { @@v7@@ = * @@a1@@ ; @@v8@@ = * @@a1@@ + Number * @@result@@ ; @@v9@@ = ( ( @@a3@@ & Number ) << Number ) | * ( _DWORD * ) ( @@v8@@ + Number ) & Number ; * ( _DWORD * ) ( @@v8@@ + Number ) = @@v9@@ ; @@v10@@ = @@v9@@ & Number | ( ( ( @@a3@@ & Number | ( unsigned __int16 ) ( * ( _DWORD * ) ( @@v7@@ + @@v3@@ + Number ) >> Number ) ) & Number ) << Number ) ; * ( _DWORD * ) ( @@v8@@ + Number ) = @@v10@@ ; * ( _BYTE * ) ( @@v8@@ + Number ) = BYTE2 ( @@v10@@ ) | Number ; * ( _QWORD * ) ( @@a1@@ [ Number ] + Number * @@result@@ ) = @@a2@@ ; } return @@result@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
ssize_t __fastcall safe_write ( int @@fd@@ , void * @@buf@@ , size_t @@n@@ ) { ssize_t @@v4@@ ; int @@v5@@ ; while ( Number ) { @@v4@@ = write ( @@fd@@ , @@buf@@ , @@n@@ ) ; if ( @@v4@@ >= Number ) break ; @@v5@@ = * __errno_location ( ) ; if ( @@v5@@ != Number ) { if ( @@v5@@ != Number || @@n@@ <= Number ) return @@v4@@ ; @@n@@ = Number L ; } } return @@v4@@ ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
__int64 __fastcall clean_state_log_if_needed ( _QWORD * @@a1@@ , unsigned __int64 @@a2@@ ) { unsigned __int64 @@v2@@ ; unsigned __int64 @@v3@@ ; __int64 @@result@@ ; @@v2@@ = @@a1@@ [ Number ] ; if ( @@a1@@ [ Number ] > @@a2@@ && ( ( @@v3@@ = @@a1@@ [ Number ] , @@v3@@ > @@a2@@ ) || @@v3@@ >= @@a1@@ [ Number ] ) || ( @@result@@ = extend_buffers ( ( __int64 ) @@a1@@ ) , ! ( _DWORD ) @@result@@ ) ) { if ( @@v2@@ < @@a2@@ ) { memset ( ( void * ) ( @@a1@@ [ Number ] + Number * @@v2@@ + Number ) , Number , Number * ( @@a2@@ - @@v2@@ ) ) ; @@a1@@ [ Number ] = @@a2@@ ; } @@result@@ = Number L ; } return @@result@@ ; }
int iswspace ( wint_t @@wc@@ ) { return iswspace ( @@wc@@ ) ; }
int puts ( const char * @@s@@ ) { return puts ( @@s@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
void clearerr_unlocked ( FILE * @@stream@@ ) { clearerr_unlocked ( @@stream@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 __fastcall c_strcasecmp ( unsigned __int8 * @@a1@@ , unsigned __int8 * @@a2@@ ) { __int64 @@result@@ ; int @@v3@@ ; int @@v4@@ ; @@result@@ = Number L ; if ( @@a1@@ != @@a2@@ ) { do { @@v3@@ = * @@a1@@ ; if ( ( unsigned int ) ( @@v3@@ - Number ) < Number ) LOBYTE ( @@v3@@ ) = @@v3@@ + Number ; @@v4@@ = * @@a2@@ ; if ( ( unsigned int ) ( @@v4@@ - Number ) < Number ) LOBYTE ( @@v4@@ ) = @@v4@@ + Number ; if ( ! ( _BYTE ) @@v3@@ ) break ; ++ @@a1@@ ; ++ @@a2@@ ; } while ( ( _BYTE ) @@v3@@ == ( _BYTE ) @@v4@@ ) ; @@result@@ = ( unsigned __int8 ) @@v3@@ - ( unsigned int ) ( unsigned __int8 ) @@v4@@ ; } return @@result@@ ; }
__int64 __fastcall re_node_set_compare_part_2 ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; __int64 @@result@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@result@@ = Number L ; if ( @@v2@@ == * ( _QWORD * ) ( @@a2@@ + Number ) ) { @@v4@@ = Number * @@v2@@ - Number ; do { if ( ( unsigned __int64 ) -- @@v2@@ > Number ) return Number L ; @@v5@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@v4@@ ) ; @@v6@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + @@v4@@ ) ; @@v4@@ -= Number L ; } while ( @@v5@@ == @@v6@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; program_invocation_short_name = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
wctype_t wctype ( const char * @@property@@ ) { return wctype ( @@property@@ ) ; }
int __cdecl __noreturn main ( int @@argc@@ , const char * * @@argv@@ , const char * * @@envp@@ ) { int @@v3@@ ; char * @@v4@@ ; int @@v5@@ ; __int64 @@v6@@ ; char * @@v7@@ ; set_program_name ( * @@argv@@ , @@argv@@ , @@envp@@ ) ; setlocale ( Number , String ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; exit_failure = Number ; atexit ( close_stdout ) ; for ( silent = Number ; ; silent = Number ) { @@v3@@ = getopt_long ( @@argc@@ , ( char * const * ) @@argv@@ , shortopts , & longopts , Number L ) ; if ( @@v3@@ == Number ) break ; if ( @@v3@@ == Number ) usage ( Number ) ; if ( @@v3@@ != Number ) { if ( @@v3@@ != Number ) usage ( Number ) ; version_etc ( ( _DWORD ) stdout , ( unsigned int ) String , ( unsigned int ) & unk_3985 , ( _DWORD ) Version , ( unsigned int ) String , Number ) ; exit ( Number ) ; } } if ( optind < @@argc@@ ) { @@v6@@ = quote ( @@argv@@ [ optind ] ) ; @@v7@@ = dcgettext ( Number L , String , Number ) ; error ( Number , Number , @@v7@@ , @@v6@@ ) ; } @@v4@@ = ttyname ( Number ) ; if ( ! silent ) { if ( ! @@v4@@ ) @@v4@@ = dcgettext ( Number L , String , Number ) ; puts ( @@v4@@ ) ; } @@v5@@ = isatty ( Number ) ; exit ( @@v5@@ == Number ) ; }
void __fastcall freea ( unsigned __int64 @@a1@@ ) { __int64 @@v1@@ ; __int64 @@v2@@ ; _QWORD * @@v3@@ ; if ( @@a1@@ ) { if ( * ( _DWORD * ) ( @@a1@@ - Number ) == Number ) { @@v1@@ = mmalloca_results [ @@a1@@ % Number ] ; if ( @@v1@@ ) { if ( @@v1@@ == @@a1@@ ) { @@v3@@ = & mmalloca_results [ @@a1@@ % Number ] ; LABEL_12 : * @@v3@@ = * ( _QWORD * ) ( @@a1@@ - Number ) ; free ( ( void * ) ( @@a1@@ - Number ) ) ; } else { while ( Number ) { @@v2@@ = * ( _QWORD * ) ( @@v1@@ - Number ) ; if ( ! @@v2@@ ) break ; if ( @@a1@@ == @@v2@@ ) { @@v3@@ = ( _QWORD * ) ( @@v1@@ - Number ) ; goto LABEL_12 ; } @@v1@@ = * ( _QWORD * ) ( @@v1@@ - Number ) ; } } } } } }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
wint_t btowc ( int @@c@@ ) { return btowc ( @@c@@ ) ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
__int64 __fastcall optimize_subexps ( __int64 @@a1@@ , __int64 @@a2@@ ) { char @@v2@@ ; __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; _QWORD * @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; @@v2@@ = * ( _BYTE * ) ( @@a2@@ + Number ) ; if ( @@v2@@ != Number ) { if ( @@v2@@ == Number ) { @@v4@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( @@v4@@ ) { if ( * ( _BYTE * ) ( @@v4@@ + Number ) == Number ) { @@v5@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; @@v6@@ = * ( _QWORD * * ) ( @@v4@@ + Number ) ; * ( _QWORD * ) ( @@a2@@ + Number ) = @@v6@@ ; if ( @@v6@@ ) * @@v6@@ = @@a2@@ ; * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@v5@@ ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L * * ( _QWORD * ) ( @@a2@@ + Number ) ) ; if ( @@v5@@ <= Number ) * ( _QWORD * ) ( @@a1@@ + Number ) &= __ROL8__ ( Number , @@v5@@ ) ; } } } return Number L ; } @@v7@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( ! @@v7@@ ) return Number L ; @@v8@@ = * ( _QWORD * ) ( @@v7@@ + Number L * * ( int * ) ( @@a2@@ + Number ) ) ; * ( _QWORD * ) ( @@a2@@ + Number ) = @@v8@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) |= Number << @@v8@@ ; return Number L ; }
wint_t towupper ( wint_t @@wc@@ ) { return towupper ( @@wc@@ ) ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
__int64 __fastcall build_type_arg ( char * * @@a1@@ , _QWORD * @@a2@@ , __int64 @@a3@@ ) { char * @@v3@@ ; char @@v4@@ ; const char * @@v5@@ ; size_t @@v6@@ ; const char * @@v7@@ ; unsigned int @@v8@@ ; @@v3@@ = optarg ; @@v4@@ = * optarg ; if ( * optarg != Number ) { if ( @@v4@@ <= Number ) { if ( @@v4@@ != Number ) return Number ; } else { if ( @@v4@@ == Number ) { ++ optarg ; * @@a1@@ = @@v3@@ ; @@v5@@ = optarg ; * @@a2@@ = Number L ; @@a2@@ [ Number ] = @@a3@@ ; @@a2@@ [ Number ] = Number L ; @@a2@@ [ Number ] = Number L ; rpl_re_syntax_options = Number L ; @@v6@@ = strlen ( @@v5@@ ) ; @@v7@@ = ( const char * ) rpl_re_compile_pattern ( @@v5@@ , @@v6@@ , @@a2@@ ) ; @@v8@@ = Number ; if ( @@v7@@ ) { error ( Number , Number , String , @@v7@@ ) ; return Number L ; } return @@v8@@ ; } if ( @@v4@@ != Number ) return Number ; } } * @@a1@@ = optarg ; return Number L ; }
__int64 __fastcall lower_subexps ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; char * @@v5@@ ; char * @@v6@@ ; unsigned int @@v7@@ ; unsigned __int64 @@v8@@ ; @@v2@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@v8@@ = __readfsqword ( Number ) ; @@v7@@ = Number ; if ( @@v2@@ ) { if ( * ( _BYTE * ) ( @@v2@@ + Number ) == Number ) { @@v6@@ = lower_subexp ( & @@v7@@ , @@a1@@ , @@v2@@ ) ; * ( _QWORD * ) ( @@a2@@ + Number ) = @@v6@@ ; if ( @@v6@@ ) * ( _QWORD * ) @@v6@@ = @@a2@@ ; } } @@v3@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( @@v3@@ ) { if ( * ( _BYTE * ) ( @@v3@@ + Number ) == Number ) { @@v5@@ = lower_subexp ( & @@v7@@ , @@a1@@ , @@v3@@ ) ; * ( _QWORD * ) ( @@a2@@ + Number ) = @@v5@@ ; if ( @@v5@@ ) * ( _QWORD * ) @@v5@@ = @@a2@@ ; } } return @@v7@@ ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall check_node_accept ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int8 @@v4@@ ; __int64 @@result@@ ; unsigned int @@v6@@ ; unsigned int @@v7@@ ; unsigned int @@v8@@ ; unsigned int @@v9@@ ; unsigned int @@v10@@ ; __int64 @@v11@@ ; @@v3@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@a3@@ ) ; @@v4@@ = * ( _BYTE * ) ( @@a2@@ + Number ) ; if ( @@v4@@ == Number ) { @@v11@@ = * ( _QWORD * ) ( * ( _QWORD * ) @@a2@@ + Number * ( ( unsigned __int64 ) ( unsigned __int8 ) @@v3@@ >> Number ) ) ; @@result@@ = Number L ; if ( ! _bittest64 ( & @@v11@@ , @@v3@@ ) ) return @@result@@ ; goto LABEL_9 ; } if ( @@v4@@ <= Number ) { if ( @@v4@@ == Number ) { @@result@@ = Number L ; if ( * ( _BYTE * ) @@a2@@ != ( _BYTE ) @@v3@@ ) return @@result@@ ; goto LABEL_9 ; } return Number L ; } if ( @@v4@@ == Number ) goto LABEL_6 ; if ( @@v4@@ != Number ) return Number L ; @@result@@ = Number L ; if ( ( @@v3@@ & Number ) != Number L ) return @@result@@ ; LABEL_6 : if ( ( _BYTE ) @@v3@@ == Number ) { @@result@@ = Number L ; if ( ( * ( _BYTE * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L ) & Number ) == Number ) return @@result@@ ; } else if ( ! ( _BYTE ) @@v3@@ ) { @@result@@ = Number L ; if ( * ( char * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L ) < Number ) return @@result@@ ; } LABEL_9 : @@v6@@ = * ( _DWORD * ) ( @@a2@@ + Number ) ; @@result@@ = Number L ; if ( ( @@v6@@ & Number ) == Number ) return @@result@@ ; @@v7@@ = @@v6@@ >> Number ; @@v8@@ = re_string_context_at ( @@a1@@ , @@a3@@ , * ( _DWORD * ) ( @@a1@@ + Number ) ) ; @@v9@@ = @@v8@@ ; if ( ( @@v7@@ & Number ) != Number ) { @@result@@ = Number L ; if ( ( @@v9@@ & Number ) == Number || ( @@v7@@ & Number ) != Number ) return @@result@@ ; } else if ( ( @@v7@@ & Number ) != Number && ( @@v8@@ & Number ) != Number ) { return Number L ; } if ( ( @@v7@@ & Number ) == Number || ( @@result@@ = Number L , ( @@v9@@ & Number ) != Number ) ) { @@result@@ = Number L ; @@v10@@ = ( @@v9@@ >> Number ) & Number ; if ( ( @@v7@@ & Number ) != Number ) @@result@@ = @@v10@@ ; } return @@result@@ ; }
_QWORD * __fastcall readlinebuffer_delim ( _QWORD * @@a1@@ , _IO_FILE * @@a2@@ , char @@a3@@ ) { __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ ; int @@v7@@ ; char * @@v8@@ ; int @@v9@@ ; char @@v10@@ ; _BYTE * @@v11@@ ; __int64 @@v12@@ ; __int64 @@v13@@ ; __int64 @@v14@@ ; char * @@v15@@ ; _QWORD * @@result@@ ; int @@v17@@ ; char @@v18@@ ; __int64 @@v19@@ ; char @@v20@@ ; char @@v21@@ ; @@v3@@ = @@a1@@ [ Number ] ; @@v4@@ = @@v3@@ + * @@a1@@ ; if ( ( @@a2@@ -> _flags & Number ) == Number ) { @@v6@@ = @@a1@@ [ Number ] ; @@v7@@ = @@a3@@ ; while ( Number ) { @@v8@@ = @@a2@@ -> _IO_read_ptr ; if ( @@v8@@ >= @@a2@@ -> _IO_read_end ) { @@v21@@ = @@a3@@ ; @@v19@@ = @@v4@@ ; @@v17@@ = __uflow ( @@a2@@ ) ; @@v9@@ = @@v17@@ ; @@v4@@ = @@v19@@ ; @@a3@@ = @@v21@@ ; if ( @@v17@@ == Number ) { if ( @@v3@@ == @@v6@@ || ( @@a2@@ -> _flags & Number ) != Number ) return Number L ; if ( * ( _BYTE * ) ( @@v6@@ - Number ) == @@v21@@ ) { LABEL_8 : @@result@@ = @@a1@@ ; @@a1@@ [ Number ] = @@v6@@ - @@v3@@ ; return @@result@@ ; } @@v9@@ = @@v7@@ ; @@v10@@ = @@v21@@ ; } else { @@v10@@ = @@v17@@ ; } } else { @@a2@@ -> _IO_read_ptr = @@v8@@ + Number ; @@v9@@ = ( unsigned __int8 ) * @@v8@@ ; @@v10@@ = * @@v8@@ ; } @@v11@@ = ( _BYTE * ) @@v6@@ ; if ( @@v6@@ == @@v4@@ ) { @@v12@@ = * @@a1@@ ; @@v20@@ = @@a3@@ ; @@v18@@ = @@v10@@ ; @@v13@@ = x2realloc ( @@v3@@ , @@a1@@ ) ; @@v14@@ = * @@a1@@ ; @@v15@@ = ( char * ) ( @@v13@@ + @@v12@@ ) ; @@a1@@ [ Number ] = @@v13@@ ; @@v3@@ = @@v13@@ ; @@a3@@ = @@v20@@ ; @@v6@@ = @@v13@@ + @@v12@@ + Number ; @@v4@@ = @@v13@@ + @@v14@@ ; * @@v15@@ = @@v18@@ ; if ( @@v9@@ == @@v7@@ ) goto LABEL_8 ; } else { ++ @@v6@@ ; * @@v11@@ = @@v10@@ ; if ( @@v9@@ == @@v7@@ ) goto LABEL_8 ; } } } return Number L ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall rpl_re_compile_fastmap ( __int64 @@a1@@ ) { __m128i * @@v1@@ ; _QWORD * @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; @@v1@@ = * ( __m128i * * ) ( @@a1@@ + Number ) ; @@v2@@ = * ( _QWORD * * ) @@a1@@ ; @@v1@@ -> m128i_i64 [ Number ] = Number L ; @@v1@@ [ Number ] . m128i_i64 [ Number ] = Number L ; memset ( ( void * ) ( ( unsigned __int64 ) & @@v1@@ -> m128i_u64 [ Number ] & Number ) , Number , Number L * ( ( ( unsigned int ) @@v1@@ - ( ( ( _DWORD ) @@v1@@ + Number ) & Number ) + Number ) >> Number ) ) ; re_compile_fastmap_iter_isra_32 ( ( __int64 * ) @@a1@@ , ( _QWORD * ) ( @@v2@@ [ Number ] + Number L ) , ( _QWORD * ) ( @@v2@@ [ Number ] + Number L ) , @@v1@@ ) ; @@v3@@ = @@v2@@ [ Number ] ; if ( @@v2@@ [ Number ] != @@v3@@ ) { re_compile_fastmap_iter_isra_32 ( ( __int64 * ) @@a1@@ , ( _QWORD * ) ( @@v3@@ + Number ) , ( _QWORD * ) ( @@v3@@ + Number ) , @@v1@@ ) ; @@v3@@ = @@v2@@ [ Number ] ; } @@v4@@ = @@v2@@ [ Number ] ; if ( @@v4@@ != @@v3@@ ) { re_compile_fastmap_iter_isra_32 ( ( __int64 * ) @@a1@@ , ( _QWORD * ) ( @@v4@@ + Number ) , ( _QWORD * ) ( @@v4@@ + Number ) , @@v1@@ ) ; @@v3@@ = @@v2@@ [ Number ] ; } @@v5@@ = @@v2@@ [ Number ] ; if ( @@v5@@ != @@v3@@ ) re_compile_fastmap_iter_isra_32 ( ( __int64 * ) @@a1@@ , ( _QWORD * ) ( @@v5@@ + Number ) , ( _QWORD * ) ( @@v5@@ + Number ) , @@v1@@ ) ; * ( _BYTE * ) ( @@a1@@ + Number ) |= Number ; return Number L ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_2061D0 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061B0 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061C0 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall rpl_re_search ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ , unsigned __int64 @@a4@@ , __int64 @@a5@@ , unsigned __int64 * @@a6@@ ) { return re_search_stub ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a3@@ , @@a6@@ , Number ) ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_20B210 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20B1F0 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20B200 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
__int64 __fastcall rpl_re_search_2 ( __int64 @@a1@@ , const void * @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ , unsigned __int64 @@a6@@ , __int64 @@a7@@ , unsigned __int64 * @@a8@@ , __int64 @@a9@@ ) { return re_search_2_stub ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ , @@a7@@ , @@a8@@ , @@a9@@ , Number ) ; }
ssize_t __fastcall safe_read ( int @@fd@@ , void * @@buf@@ , size_t @@nbytes@@ ) { ssize_t @@v4@@ ; int @@v5@@ ; while ( Number ) { @@v4@@ = read ( @@fd@@ , @@buf@@ , @@nbytes@@ ) ; if ( @@v4@@ >= Number ) break ; @@v5@@ = * __errno_location ( ) ; if ( @@v5@@ != Number ) { if ( @@nbytes@@ <= Number || @@v5@@ != Number ) return @@v4@@ ; @@nbytes@@ = Number L ; } } return @@v4@@ ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
int __lxstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _lxstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
time_t mktime ( struct tm * @@tp@@ ) { return mktime ( @@tp@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 __fastcall mark_opt_subexp ( __int64 @@a1@@ , __int64 @@a2@@ ) { if ( * ( _BYTE * ) ( @@a2@@ + Number ) != Number || @@a1@@ != * ( _QWORD * ) ( @@a2@@ + Number ) ) { return Number L ; } * ( _BYTE * ) ( @@a2@@ + Number ) |= Number ; return Number L ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
int isatty ( int @@fd@@ ) { return isatty ( @@fd@@ ) ; }
char * __fastcall str_iconv ( char * @@s@@ , char * @@fromcode@@ , char * @@tocode@@ ) { char * @@v4@@ ; iconv_t @@v6@@ ; void * @@v7@@ ; int * @@v8@@ ; int @@v9@@ ; int * @@v10@@ ; int * @@v11@@ ; int @@v12@@ ; int * @@v13@@ ; if ( * @@s@@ && ( unsigned int ) c_strcasecmp ( ( unsigned __int8 * ) @@fromcode@@ , ( unsigned __int8 * ) @@tocode@@ ) ) { @@v6@@ = iconv_open ( @@tocode@@ , @@fromcode@@ ) ; @@v7@@ = @@v6@@ ; if ( @@v6@@ == ( iconv_t ) Number ) return Number L ; @@v4@@ = str_cd_iconv ( @@s@@ , @@v6@@ ) ; if ( @@v4@@ ) { if ( iconv_close ( @@v7@@ ) < Number ) { @@v8@@ = __errno_location ( ) ; @@v9@@ = * @@v8@@ ; @@v10@@ = @@v8@@ ; free ( @@v4@@ ) ; @@v4@@ = Number L ; * @@v10@@ = @@v9@@ ; } } else { @@v11@@ = __errno_location ( ) ; @@v12@@ = * @@v11@@ ; @@v13@@ = @@v11@@ ; iconv_close ( @@v7@@ ) ; * @@v13@@ = @@v12@@ ; } return @@v4@@ ; } @@v4@@ = strdup ( @@s@@ ) ; if ( @@v4@@ ) return @@v4@@ ; * __errno_location ( ) = Number ; return Number L ; }
__int64 __fastcall postorder ( _QWORD * @@a1@@ , __int64 ( __fastcall * @@a2@@ ( ) ( void , bintreet0 ) ) ( __int64 , _QWORD * ) , __int64 @@a3@@ ) { _QWORD * @@v5@@ ; __int64 @@result@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; while ( Number ) { @@v5@@ = ( _QWORD * ) @@a1@@ [ Number ] ; if ( ! @@v5@@ ) { @@v5@@ = ( _QWORD * ) @@a1@@ [ Number ] ; if ( ! @@v5@@ ) break ; } LABEL_2 : @@a1@@ = @@v5@@ ; } for ( @@result@@ = @@a2@@ ( ) ( void , bintreet0 ) ( @@a3@@ , @@a1@@ ) ; ! ( _DWORD ) @@result@@ ; @@result@@ = @@a2@@ ( ) ( void , bintreet0 ) ( @@a3@@ , @@v7@@ ) ) { @@v7@@ = ( _QWORD * ) * @@a1@@ ; if ( ! * @@a1@@ ) break ; @@v5@@ = ( _QWORD * ) @@v7@@ [ Number ] ; @@v8@@ = @@v5@@ == @@a1@@ ; @@a1@@ = ( _QWORD * ) * @@a1@@ ; if ( @@v5@@ != Number L && ! @@v8@@ ) goto LABEL_2 ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; program_invocation_short_name = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
int iswlower ( wint_t @@wc@@ ) { return iswlower ( @@wc@@ ) ; }
__int64 __fastcall register_state ( _QWORD * @@a1@@ , _QWORD * @@a2@@ , __int64 @@a3@@ ) { __int64 @@v4@@ ; void * @@v6@@ ; __int64 @@v7@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; _QWORD * @@v11@@ ; __int64 @@v12@@ ; @@v4@@ = @@a2@@ [ Number ] ; * @@a2@@ = @@a3@@ ; @@a2@@ [ Number ] = Number L ; @@a2@@ [ Number ] = @@v4@@ ; @@v6@@ = malloc ( Number * @@v4@@ ) ; @@a2@@ [ Number ] = @@v6@@ ; if ( ! @@v6@@ ) return Number L ; if ( @@v4@@ ) { @@v7@@ = Number L ; while ( ( * ( _BYTE * ) ( * @@a1@@ + Number L * * ( _QWORD * ) ( @@a2@@ [ Number ] + Number * @@v7@@ ) + Number ) & Number ) != Number || ( unsigned __int8 ) re_node_set_insert_last ( @@a2@@ + Number , * ( _QWORD * ) ( @@a2@@ [ Number ] + Number * @@v7@@ ) ) ) { if ( @@a2@@ [ Number ] <= ( unsigned __int64 ) ++ @@v7@@ ) goto LABEL_8 ; } return Number L ; } LABEL_8 : @@v9@@ = @@a1@@ [ Number ] + Number * ( @@a1@@ [ Number ] & @@a3@@ ) ; @@v10@@ = * ( _QWORD * ) @@v9@@ ; @@v11@@ = * ( _QWORD * * ) ( @@v9@@ + Number ) ; @@v12@@ = * ( _QWORD * ) @@v9@@ + Number L ; if ( * ( _QWORD * ) ( @@v9@@ + Number ) <= * ( _QWORD * ) @@v9@@ ) { @@v11@@ = realloc ( * ( void * * ) ( @@v9@@ + Number ) , Number * @@v12@@ ) ; if ( @@v11@@ ) { @@v10@@ = * ( _QWORD * ) @@v9@@ ; * ( _QWORD * ) ( @@v9@@ + Number ) = @@v11@@ ; * ( _QWORD * ) ( @@v9@@ + Number ) = Number * @@v12@@ ; @@v12@@ = @@v10@@ + Number ; goto LABEL_9 ; } return Number L ; } LABEL_9 : * ( _QWORD * ) @@v9@@ = @@v12@@ ; @@v11@@ [ @@v10@@ ] = @@a2@@ ; return Number L ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
void __fastcall free_charset ( void * @@ptr@@ ) { free ( * ( void * * ) @@ptr@@ ) ; free ( * ( ( void * * ) @@ptr@@ + Number ) ) ; free ( @@ptr@@ ) ; }
__int64 __fastcall filemodestring ( __int64 @@a1@@ , __int64 @@a2@@ ) { return strmode ( * ( _DWORD * ) ( @@a1@@ + Number ) , @@a2@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 __fastcall free_tree ( __int64 a1 , __int64 @@a2@@ ) { free_token ( @@a2@@ + Number ) ; return Number L ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
int iswalnum ( wint_t @@wc@@ ) { return iswalnum ( @@wc@@ ) ; }
char * nl_langinfo ( nl_item @@item@@ ) { return nl_langinfo ( @@item@@ ) ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
wint_t towlower ( wint_t @@wc@@ ) { return towlower ( @@wc@@ ) ; }
__int64 __fastcall peek_token_bracket ( _BYTE * @@a1@@ , __int64 @@a2@@ , char @@a3@@ ) { unsigned __int64 @@v3@@ ; __int64 @@v4@@ ; bool @@v5@@ ; char @@v6@@ ; __int64 @@result@@ ; char @@v8@@ ; char @@v9@@ ; @@v3@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) <= @@v3@@ ) { @@a1@@ [ Number ] = Number ; return Number L ; } @@v4@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@v5@@ = * ( _DWORD * ) ( @@a2@@ + Number ) <= Number ; @@v6@@ = * ( _BYTE * ) ( @@v4@@ + @@v3@@ ) ; * @@a1@@ = @@v6@@ ; if ( ! @@v5@@ && @@v3@@ != * ( _QWORD * ) ( @@a2@@ + Number ) && * ( _DWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number * @@v3@@ ) == Number ) { goto LABEL_19 ; } switch ( @@v6@@ ) { case String : if ( ( @@a3@@ & Number ) == Number || @@v3@@ + Number >= * ( _QWORD * ) ( @@a2@@ + Number ) ) { LABEL_19 : @@a1@@ [ Number ] = Number ; return Number L ; } * ( _QWORD * ) ( @@a2@@ + Number ) = @@v3@@ + Number ; @@v9@@ = * ( _BYTE * ) ( @@v4@@ + @@v3@@ + Number ) ; @@a1@@ [ Number ] = Number ; * @@a1@@ = @@v9@@ ; @@result@@ = Number L ; break ; case String : if ( @@v3@@ + Number < * ( _QWORD * ) ( @@a2@@ + Number ) ) { @@v8@@ = * ( _BYTE * ) ( @@v4@@ + @@v3@@ + Number ) ; * @@a1@@ = @@v8@@ ; switch ( @@v8@@ ) { case String : if ( ( @@a3@@ & Number ) != Number ) { @@a1@@ [ Number ] = Number ; return Number L ; } break ; case String : @@a1@@ [ Number ] = Number ; return Number L ; case String : @@a1@@ [ Number ] = Number ; return Number L ; } } @@a1@@ [ Number ] = Number ; * @@a1@@ = Number ; return Number L ; case String : @@a1@@ [ Number ] = Number ; @@result@@ = Number L ; break ; case String : @@a1@@ [ Number ] = Number ; @@result@@ = Number L ; break ; case String : @@a1@@ [ Number ] = Number ; return Number L ; default : goto LABEL_19 ; } return @@result@@ ; }
void __fastcall free_state ( void * @@ptr@@ ) { void * * @@v1@@ ; free ( * ( ( void * * ) @@ptr@@ + Number ) ) ; free ( * ( ( void * * ) @@ptr@@ + Number ) ) ; @@v1@@ = ( void * * ) * ( ( _QWORD * ) @@ptr@@ + Number ) ; if ( @@v1@@ != ( void * * ) ( ( char * ) @@ptr@@ + Number ) ) { free ( @@v1@@ [ Number ] ) ; free ( * ( ( void * * ) @@ptr@@ + Number ) ) ; } free ( * ( ( void * * ) @@ptr@@ + Number ) ) ; free ( * ( ( void * * ) @@ptr@@ + Number ) ) ; free ( * ( ( void * * ) @@ptr@@ + Number ) ) ; free ( @@ptr@@ ) ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
int iswlower ( wint_t @@wc@@ ) { return iswlower ( @@wc@@ ) ; }
__int64 __fastcall check_arrival_expand_ecl_sub ( _QWORD * @@a1@@ , _QWORD * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ , unsigned int @@a5@@ ) { __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; unsigned __int64 * @@v12@@ ; __int64 @@result@@ ; while ( Number ) { if ( re_node_set_contains_isra_3 ( @@a2@@ [ Number ] , @@a2@@ + Number , @@a3@@ ) ) return Number L ; @@v8@@ = * @@a1@@ + Number * @@a3@@ ; if ( * ( unsigned __int8 * ) ( @@v8@@ + Number ) == @@a5@@ && * ( _QWORD * ) @@v8@@ == @@a4@@ ) { break ; } if ( ! ( unsigned __int8 ) re_node_set_insert ( @@a2@@ , @@a3@@ ) ) return Number L ; @@v9@@ = Number * @@a3@@ ; @@v10@@ = @@v9@@ + @@a1@@ [ Number ] ; @@v11@@ = * ( _QWORD * ) ( @@v10@@ + Number ) ; if ( ! @@v11@@ ) return Number L ; @@v12@@ = * ( unsigned __int64 * * ) ( @@v10@@ + Number ) ; if ( @@v11@@ == Number ) { @@result@@ = check_arrival_expand_ecl_sub ( @@a1@@ , @@a2@@ , @@v12@@ [ Number ] , @@a4@@ , @@a5@@ ) ; if ( ( _DWORD ) @@result@@ ) return @@result@@ ; @@v12@@ = * ( unsigned __int64 * * ) ( @@a1@@ [ Number ] + @@v9@@ + Number ) ; } @@a3@@ = * @@v12@@ ; } if ( @@a5@@ != Number || ( unsigned __int8 ) re_node_set_insert ( @@a2@@ , @@a3@@ ) ) return Number L ; return Number L ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 __fastcall extend_buffers ( __int64 @@a1@@ ) { unsigned __int64 @@v1@@ ; unsigned int @@v3@@ ; void * @@v4@@ ; void * @@v5@@ ; int @@v6@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; @@v1@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( @@v1@@ > Number ) return Number L ; @@v3@@ = re_string_realloc_buffers ( @@a1@@ , Number * @@v1@@ ) ; if ( @@v3@@ ) return @@v3@@ ; @@v4@@ = * ( void * * ) ( @@a1@@ + Number ) ; if ( ! @@v4@@ ) goto LABEL_6 ; @@v5@@ = realloc ( @@v4@@ , Number L * * ( _QWORD * ) ( @@a1@@ + Number ) + Number ) ; if ( ! @@v5@@ ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v5@@ ; LABEL_6 : @@v6@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; if ( ! * ( _BYTE * ) ( @@a1@@ + Number ) ) { if ( @@v6@@ > Number ) { build_wcs_buffer ( @@a1@@ ) ; return Number L ; } @@v8@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( @@v8@@ ) { @@v9@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= @@v9@@ ) @@v9@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v10@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( @@v9@@ > @@v10@@ ) { while ( Number ) { * ( _BYTE * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@v10@@ ) = * ( _BYTE * ) ( @@v8@@ + * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@v10@@ + * ( _QWORD * ) @@a1@@ ) ) ; if ( @@v9@@ == ++ @@v10@@ ) break ; @@v8@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; } } * ( _QWORD * ) ( @@a1@@ + Number ) = @@v10@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v10@@ ; } return @@v3@@ ; } if ( @@v6@@ > Number ) return build_wcs_upper_buffer ( @@a1@@ ) ; build_upper_buffer ( ( _QWORD * ) @@a1@@ ) ; return Number L ; }
int iswalnum ( wint_t @@wc@@ ) { return iswalnum ( @@wc@@ ) ; }
char * __fastcall create_token_tree_isra_18 ( _QWORD * @@a1@@ , int * @@a2@@ , _QWORD * @@a3@@ , _QWORD * @@a4@@ , const __m128i * @@a5@@ ) { int @@v6@@ ; __int64 @@v7@@ ; int @@v8@@ ; _QWORD * @@v9@@ ; __int64 @@v10@@ ; char * @@result@@ ; __m128i * @@v12@@ ; _QWORD * @@v13@@ ; _QWORD * @@v14@@ ; _QWORD * @@v15@@ ; const __m128i * @@v16@@ ; @@v6@@ = * @@a2@@ ; if ( * @@a2@@ == Number ) { @@v16@@ = @@a5@@ ; @@v15@@ = @@a4@@ ; @@v14@@ = @@a3@@ ; @@v9@@ = malloc ( Number ) ; if ( ! @@v9@@ ) return Number L ; @@v13@@ = ( _QWORD * ) * @@a1@@ ; @@v8@@ = Number ; * @@a1@@ = @@v9@@ ; @@v7@@ = Number L ; @@a5@@ = @@v16@@ ; @@a4@@ = @@v15@@ ; @@a3@@ = @@v14@@ ; * @@v9@@ = @@v13@@ ; @@v10@@ = Number L ; } else { @@v7@@ = @@v6@@ ; @@v8@@ = @@v6@@ + Number ; @@v9@@ = ( _QWORD * ) * @@a1@@ ; @@v10@@ = ( ( __int64 ) @@v6@@ << Number ) + Number ; } * @@a2@@ = @@v8@@ ; @@result@@ = ( char * ) @@v9@@ + @@v10@@ ; @@v12@@ = ( __m128i * ) & @@v9@@ [ Number * @@v7@@ ] ; @@v12@@ -> m128i_i64 [ Number ] = Number L ; @@v12@@ [ Number ] . m128i_i64 [ Number ] = ( __int64 ) @@a3@@ ; @@v12@@ [ Number ] . m128i_i64 [ Number ] = ( __int64 ) @@a4@@ ; @@v12@@ [ Number ] = _mm_loadu_si128 ( @@a5@@ ) ; @@v12@@ [ Number ] . m128i_i8 [ Number ] &= Number ; @@v12@@ [ Number ] . m128i_i64 [ Number ] = Number L ; @@v12@@ [ Number ] . m128i_i64 [ Number ] = Number L ; @@v12@@ [ Number ] . m128i_i64 [ Number ] = Number ; if ( @@a3@@ ) * @@a3@@ = @@result@@ ; if ( @@a4@@ ) * @@a4@@ = @@result@@ ; return @@result@@ ; }
wint_t towlower ( wint_t @@wc@@ ) { return towlower ( @@wc@@ ) ; }
void __fastcall re_node_set_remove_at_isra_4_part_5 ( unsigned __int64 * @@a1@@ , __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { __int64 @@v3@@ ; if ( @@a3@@ < * @@a1@@ ) { @@v3@@ = * @@a2@@ ; do { ++ @@a3@@ ; * ( _QWORD * ) ( @@v3@@ + Number * @@a3@@ - Number ) = * ( _QWORD * ) ( @@v3@@ + Number * @@a3@@ ) ; } while ( @@a3@@ < * @@a1@@ ) ; } }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 __fastcall re_string_context_at ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , char @@a3@@ ) { wint_t @@v3@@ ; __int64 @@result@@ ; unsigned __int64 @@v5@@ ; __int64 @@v6@@ ; if ( @@a2@@ > Number ) return * ( unsigned int * ) ( @@a1@@ + Number ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) == @@a2@@ ) return ( @@a3@@ & Number ) == Number ? Number : Number ; if ( * ( int * ) ( @@a1@@ + Number ) <= Number ) { @@v5@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ ) ; @@v6@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * ( @@v5@@ >> Number ) ) ; @@result@@ = Number L ; if ( _bittest64 ( & @@v6@@ , @@v5@@ ) ) return @@result@@ ; @@result@@ = Number L ; if ( ( _BYTE ) @@v5@@ != Number ) return @@result@@ ; return Number * ( unsigned int ) ( * ( _BYTE * ) ( @@a1@@ + Number ) != Number ) ; } while ( Number ) { @@v3@@ = * ( _DWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@a2@@ ) ; if ( @@v3@@ != Number ) break ; if ( -- @@a2@@ > Number ) return * ( unsigned int * ) ( @@a1@@ + Number ) ; } if ( * ( _BYTE * ) ( @@a1@@ + Number ) && ( iswalnum ( @@v3@@ ) || @@v3@@ == Number ) ) return Number L ; @@result@@ = Number L ; if ( @@v3@@ == Number ) return Number * ( unsigned int ) ( * ( _BYTE * ) ( @@a1@@ + Number ) != Number ) ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_2061D0 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061B0 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_2061C0 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
void __fastcall initbuffer ( __int64 @@a1@@ ) { * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _OWORD * ) @@a1@@ = Number L ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
__int64 __fastcall calc_first ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { __int64 @@v2@@ ; __int64 @@result@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; if ( * ( ( _BYTE * ) @@a2@@ + Number ) == Number ) { @@v4@@ = @@a2@@ [ Number ] ; @@v5@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; @@v6@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; @@a2@@ [ Number ] = @@v5@@ ; @@a2@@ [ Number ] = @@v6@@ ; @@result@@ = Number L ; } else { @@a2@@ [ Number ] = @@a2@@ ; @@v2@@ = re_dfa_add_node ( ( __int64 ) @@a1@@ , @@a2@@ [ Number ] , @@a2@@ [ Number ] ) ; @@a2@@ [ Number ] = @@v2@@ ; if ( @@v2@@ == Number ) { @@result@@ = Number L ; } else { @@result@@ = Number L ; if ( * ( ( _BYTE * ) @@a2@@ + Number ) == Number ) * ( _DWORD * ) ( * @@a1@@ + Number * @@v2@@ + Number ) = ( ( @@a2@@ [ Number ] & Number ) << Number ) | * ( _DWORD * ) ( * @@a1@@ + Number * @@v2@@ + Number ) & Number ; } } return @@result@@ ; }
void __fastcall free_fail_stack_return_part_28 ( __int64 @@a1@@ ) { __int64 @@v2@@ ; unsigned __int64 @@v3@@ ; void * @@v4@@ ; if ( * ( _QWORD * ) @@a1@@ ) { @@v2@@ = Number L ; @@v3@@ = Number L ; do { ++ @@v3@@ ; free ( * ( void * * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@v2@@ + Number ) ) ; @@v4@@ = * ( void * * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@v2@@ + Number ) ; @@v2@@ += Number L ; free ( @@v4@@ ) ; } while ( @@v3@@ < * ( _QWORD * ) @@a1@@ ) ; } free ( * ( void * * ) ( @@a1@@ + Number ) ) ; }
__int64 __fastcall mpz_tdiv_r ( __int64 * @@a1@@ , __int64 * @@a2@@ , __int64 * @@a3@@ ) { __int64 @@result@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; @@result@@ = * @@a2@@ ; @@v4@@ = * @@a3@@ ; if ( * @@a2@@ == Number && @@v4@@ == Number ) { * @@a1@@ = Number L ; } else { @@v5@@ = @@result@@ % @@v4@@ ; @@result@@ /= @@v4@@ ; * @@a1@@ = @@v5@@ ; } return @@result@@ ; }
_QWORD * __fastcall readlinebuffer ( _QWORD * @@a1@@ , _IO_FILE * @@a2@@ ) { return readlinebuffer_delim ( @@a1@@ , @@a2@@ , Number ) ; }
char * __fastcall parse_branch ( __int64 * @@a1@@ , __int64 * @@a2@@ , __m128i * @@a3@@ , __int64 @@a4@@ , void * @@a5@@ , _DWORD * @@a6@@ ) { __int64 @@v10@@ ; char * @@v11@@ ; char * @@v12@@ ; __int64 @@v14@@ ; __m128i @@v15@@ ; unsigned __int64 @@v16@@ ; @@v16@@ = __readfsqword ( Number ) ; @@v14@@ = * @@a2@@ ; @@v10@@ = parse_expression ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; @@v11@@ = ( char * ) @@v10@@ ; if ( * @@a6@@ && ! @@v10@@ ) return Number L ; while ( ( @@a3@@ -> m128i_i8 [ Number ] & Number ) != Number && ( @@a3@@ -> m128i_i8 [ Number ] != Number || ! @@a5@@ ) ) { @@v12@@ = ( char * ) parse_expression ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( * @@a6@@ && ! @@v12@@ ) return Number L ; if ( @@v11@@ && @@v12@@ ) { @@v15@@ . m128i_i8 [ Number ] = Number ; @@v11@@ = create_token_tree_isra_18 ( ( _QWORD * ) ( @@v14@@ + Number ) , ( int * ) ( @@v14@@ + Number ) , @@v11@@ , @@v12@@ , & @@v15@@ ) ; if ( ! @@v11@@ ) { * @@a6@@ = Number ; return @@v11@@ ; } } else if ( ! @@v11@@ ) { @@v11@@ = @@v12@@ ; } } return @@v11@@ ; }
__int64 __fastcall re_node_set_init_copy_isra_19 ( _QWORD * @@a1@@ , __int64 * @@a2@@ , const void * * @@a3@@ ) { __int64 @@v3@@ ; __int64 @@v4@@ ; void * @@v6@@ ; __int64 @@result@@ ; @@v3@@ = * @@a2@@ ; @@a1@@ [ Number ] = * @@a2@@ ; @@v4@@ = * @@a2@@ ; if ( * @@a2@@ ) { * @@a1@@ = @@v3@@ ; @@v6@@ = malloc ( Number * @@v3@@ ) ; @@a1@@ [ Number ] = @@v6@@ ; if ( @@v6@@ ) { memcpy ( @@v6@@ , * @@a3@@ , Number * @@v4@@ ) ; @@result@@ = Number L ; } else { @@a1@@ [ Number ] = Number L ; * @@a1@@ = Number L ; @@result@@ = Number L ; } } else { @@a1@@ [ Number ] = Number L ; @@result@@ = Number L ; * ( _OWORD * ) @@a1@@ = Number L ; } return @@result@@ ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
void __fastcall freebuffer ( __int64 @@a1@@ ) { free ( * ( void * * ) ( @@a1@@ + Number ) ) ; }
struct passwd * getpwuid ( __uid_t @@uid@@ ) { return getpwuid ( @@uid@@ ) ; }
__int64 __fastcall mpz_mul ( __int64 * @@a1@@ , __int64 * @@a2@@ , __int64 * @@a3@@ ) { __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; __int64 @@result@@ ; @@v3@@ = * @@a2@@ ; @@v4@@ = * @@a3@@ ; @@v5@@ = * @@a3@@ * @@v3@@ ; if ( @@v3@@ ) { if ( @@v4@@ ) { if ( ( ( @@v4@@ < Number ) ^ ( @@v3@@ < Number ) ) != @@v5@@ < Number || ( @@result@@ = @@v5@@ / @@v3@@ , @@v5@@ / @@v3@@ != @@v4@@ ) ) { integer_overflow ( Number ) ; } } } * @@a1@@ = @@v5@@ ; return @@result@@ ; }
__int64 __fastcall rpl_regexec ( __int64 @@a1@@ , const char * @@a2@@ , unsigned __int64 @@a3@@ , __int64 * @@a4@@ , int @@a5@@ ) { size_t @@v8@@ ; unsigned __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; int @@v11@@ ; if ( ( @@a5@@ & Number ) == Number ) { if ( ( @@a5@@ & Number ) != Number ) { @@v9@@ = * @@a4@@ ; @@v10@@ = @@a4@@ [ Number ] ; if ( ( * ( _BYTE * ) ( @@a1@@ + Number ) & Number ) != Number ) goto LABEL_4 ; } else { @@v8@@ = strlen ( @@a2@@ ) ; @@v9@@ = Number L ; @@v10@@ = @@v8@@ ; if ( ( * ( _BYTE * ) ( @@a1@@ + Number ) & Number ) != Number ) { LABEL_4 : @@v11@@ = re_search_internal ( @@a1@@ , ( __int64 ) @@a2@@ , @@v10@@ , @@v9@@ , @@v10@@ , @@v10@@ , Number L , Number L , @@a5@@ ) ; return @@v11@@ != Number ; } } @@v11@@ = re_search_internal ( @@a1@@ , ( __int64 ) @@a2@@ , @@v10@@ , @@v9@@ , @@v10@@ , @@v10@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; return @@v11@@ != Number ; } return Number L ; }
int __xstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _xstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
__int64 __fastcall merge_state_array ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ ) { __int64 @@v8@@ ; __int64 @@result@@ ; _QWORD * @@v10@@ ; void * @@v11@@ ; __int64 @@v12@@ ; __int64 @@v13@@ ; unsigned int @@v14@@ ; void * @@v15@@ [ Number ] ; @@v15@@ [ Number ] = ( void * ) __readfsqword ( Number ) ; if ( ! @@a4@@ ) return Number L ; @@v8@@ = Number L ; while ( Number ) { while ( Number ) { @@v12@@ = * ( _QWORD * ) ( @@a2@@ + Number * @@v8@@ ) ; @@v13@@ = * ( _QWORD * ) ( @@a3@@ + Number * @@v8@@ ) ; if ( @@v12@@ ) break ; * ( _QWORD * ) ( @@a2@@ + Number * @@v8@@ ++ ) = @@v13@@ ; if ( @@a4@@ == @@v8@@ ) return Number L ; } if ( @@v13@@ ) { @@result@@ = re_node_set_init_union ( @@v15@@ , @@v12@@ + Number , @@v13@@ + Number ) ; @@v14@@ = @@result@@ ; if ( ( _DWORD ) @@result@@ ) break ; @@v10@@ = re_acquire_state ( & @@v14@@ , @@a1@@ , ( __int64 ) @@v15@@ ) ; @@v11@@ = @@v15@@ [ Number ] ; * ( _QWORD * ) ( @@a2@@ + Number * @@v8@@ ) = @@v10@@ ; free ( @@v11@@ ) ; @@result@@ = @@v14@@ ; if ( @@v14@@ ) break ; } if ( @@a4@@ == ++ @@v8@@ ) return Number L ; } return @@result@@ ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
__int64 __fastcall docolon ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; const char * @@v3@@ ; size_t @@v4@@ ; const char * @@v5@@ ; const char * @@v6@@ ; size_t @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; char * @@v11@@ ; int @@v12@@ ; __int64 @@v13@@ ; void * @@ptr@@ ; void * @@v15@@ ; __int64 @@v16@@ [ Number ] ; char * @@v17@@ ; __int64 @@v18@@ ; __int64 @@v19@@ ; char @@v20@@ ; char @@v21@@ ; unsigned __int64 @@v22@@ ; @@v22@@ = __readfsqword ( Number ) ; tostring ( @@a1@@ ) ; tostring ( @@a2@@ ) ; @@v3@@ = * ( const char * * ) ( @@a2@@ + Number ) ; @@v13@@ = Number L ; @@ptr@@ = Number L ; @@v15@@ = Number L ; @@v16@@ [ Number ] = Number L ; @@v16@@ [ Number ] = Number L ; @@v17@@ = & @@v21@@ ; @@v18@@ = Number L ; rpl_re_syntax_options = Number L ; @@v4@@ = strlen ( @@v3@@ ) ; @@v5@@ = ( const char * ) rpl_re_compile_pattern ( @@v3@@ , @@v4@@ , @@v16@@ ) ; if ( @@v5@@ ) error ( Number , Number , String , @@v5@@ ) ; @@v6@@ = * ( const char * * ) ( @@a1@@ + Number ) ; @@v20@@ &= Number ; @@v7@@ = strlen ( @@v6@@ ) ; @@v8@@ = rpl_re_match ( @@v16@@ , @@v6@@ , @@v7@@ , Number L , & @@v13@@ ) ; @@v9@@ = @@v8@@ ; if ( @@v8@@ < Number ) { if ( @@v8@@ == Number ) { if ( @@v19@@ ) { @@v2@@ = str_value ( ( void * ) String ) ; } else { @@v2@@ = xmalloc ( Number L ) ; * ( _DWORD * ) @@v2@@ = Number ; * ( _QWORD * ) ( @@v2@@ + Number ) = Number L ; } } else { @@v11@@ = dcgettext ( Number L , String , Number ) ; @@v12@@ = Number ; if ( @@v9@@ == Number ) @@v12@@ = * __errno_location ( ) ; error ( Number , @@v12@@ , @@v11@@ ) ; } } else if ( @@v19@@ ) { * ( _BYTE * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + * ( ( _QWORD * ) @@v15@@ + Number ) ) = Number ; @@v2@@ = str_value ( ( void * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + * ( ( _QWORD * ) @@ptr@@ + Number ) ) ) ; } else { @@v2@@ = xmalloc ( Number L ) ; * ( _DWORD * ) @@v2@@ = Number ; * ( _QWORD * ) ( @@v2@@ + Number ) = @@v9@@ ; } if ( @@v13@@ ) { free ( @@ptr@@ ) ; free ( @@v15@@ ) ; } @@v17@@ = Number L ; rpl_regfree ( @@v16@@ ) ; return @@v2@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 __fastcall pop_fail_stack_isra_26 ( unsigned __int64 * @@a1@@ , _QWORD * @@a2@@ , _QWORD * @@a3@@ , __int64 @@a4@@ , void * @@a5@@ , __int64 @@a6@@ ) { unsigned __int64 @@v6@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; @@v6@@ = * @@a1@@ - Number ; * @@a1@@ = @@v6@@ ; if ( @@v6@@ > Number ) __assert_fail ( String , String , Number , String ) ; @@v8@@ = Number * @@v6@@ ; @@v9@@ = Number * @@v6@@ + * @@a2@@ ; * @@a3@@ = * ( _QWORD * ) @@v9@@ ; memcpy ( @@a5@@ , * ( const void * * ) ( @@v9@@ + Number ) , Number * @@a4@@ ) ; free ( * ( void * * ) ( @@a6@@ + Number ) ) ; free ( * ( void * * ) ( * @@a2@@ + @@v8@@ + Number ) ) ; @@v10@@ = * @@a2@@ + @@v8@@ ; * ( __m128i * ) @@a6@@ = _mm_loadu_si128 ( ( const __m128i * ) ( @@v10@@ + Number ) ) ; * ( _QWORD * ) ( @@a6@@ + Number ) = * ( _QWORD * ) ( @@v10@@ + Number ) ; return * ( _QWORD * ) ( @@v10@@ + Number ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
char * __fastcall areadlink_with_size ( char * @@path@@ , unsigned __int64 @@a2@@ ) { size_t @@v2@@ ; char * @@v3@@ ; char * @@v4@@ ; ssize_t @@v5@@ ; char * @@v7@@ ; @@v2@@ = @@a2@@ + Number ; if ( @@a2@@ >= Number ) @@v2@@ = Number L ; while ( Number ) { @@v3@@ = ( char * ) malloc ( @@v2@@ ) ; @@v4@@ = @@v3@@ ; if ( @@v3@@ ) { while ( Number ) { @@v5@@ = readlink ( @@path@@ , @@v3@@ , @@v2@@ ) ; if ( @@v5@@ < Number && * __errno_location ( ) != Number ) { @@v7@@ = @@v4@@ ; @@v4@@ = Number L ; free ( @@v7@@ ) ; return @@v4@@ ; } if ( @@v2@@ > @@v5@@ ) { @@v4@@ [ @@v5@@ ] = Number ; return @@v4@@ ; } free ( @@v4@@ ) ; if ( @@v2@@ > Number ) break ; @@v2@@ *= Number L ; @@v3@@ = ( char * ) malloc ( @@v2@@ ) ; @@v4@@ = @@v3@@ ; if ( ! @@v3@@ ) return @@v4@@ ; } if ( @@v2@@ <= Number ) { @@v2@@ = Number ; continue ; } @@v4@@ = Number L ; * __errno_location ( ) = Number ; } break ; } return @@v4@@ ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
char * __fastcall parse_reg_exp ( __int64 * @@a1@@ , __int64 * @@a2@@ , __m128i * @@a3@@ , __int64 @@a4@@ , void * @@a5@@ , _DWORD * @@a6@@ ) { __int64 @@v9@@ ; char * @@v10@@ ; char * @@v11@@ ; char * @@v12@@ ; __m128i @@v15@@ ; unsigned __int64 @@v16@@ ; @@v9@@ = * @@a2@@ ; @@v16@@ = __readfsqword ( Number ) ; @@v10@@ = parse_branch ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; @@v11@@ = @@v10@@ ; if ( * @@a6@@ && ! @@v10@@ ) return Number L ; while ( @@a3@@ -> m128i_i8 [ Number ] == Number ) { @@a1@@ [ Number ] += ( int ) peek_token ( ( unsigned __int8 * ) @@a3@@ , @@a1@@ , @@a4@@ | Number ) ; if ( ( @@a3@@ -> m128i_i8 [ Number ] & Number ) == Number || @@a3@@ -> m128i_i8 [ Number ] == Number && @@a5@@ ) { @@v12@@ = Number L ; } else { @@v12@@ = parse_branch ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( * @@a6@@ && ! @@v12@@ ) return Number L ; } @@v15@@ . m128i_i8 [ Number ] = Number ; @@v11@@ = create_token_tree_isra_18 ( ( _QWORD * ) ( @@v9@@ + Number ) , ( int * ) ( @@v9@@ + Number ) , @@v11@@ , @@v12@@ , & @@v15@@ ) ; if ( ! @@v11@@ ) { * @@a6@@ = Number ; return @@v11@@ ; } } return @@v11@@ ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall rpl_regcomp ( __int64 @@a1@@ , const char * @@a2@@ , int @@a3@@ ) { __int64 @@v4@@ ; void * @@v5@@ ; __int64 @@v6@@ ; char @@v7@@ ; unsigned __int64 @@v8@@ ; unsigned int @@v9@@ ; unsigned int @@v10@@ ; * ( _QWORD * ) @@a1@@ = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; @@v4@@ = ( @@a3@@ & Number ) == Number ? Number L : Number L ; @@v5@@ = malloc ( Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v5@@ ; if ( @@v5@@ ) { @@v6@@ = @@v4@@ | ( @@a3@@ << Number ) & Number ; if ( ( @@a3@@ & Number ) != Number ) { * ( _BYTE * ) ( @@a1@@ + Number ) |= Number ; @@v6@@ = @@v6@@ & Number | Number ; } else { * ( _BYTE * ) ( @@a1@@ + Number ) &= Number ; } @@v7@@ = * ( _BYTE * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _BYTE * ) ( @@a1@@ + Number ) = @@v7@@ & Number | ( Number * ( ( @@a3@@ & Number ) != Number ) ) ; @@v8@@ = strlen ( @@a2@@ ) ; @@v9@@ = re_compile_internal ( @@a1@@ , ( __int64 ) @@a2@@ , @@v8@@ , @@v6@@ ) ; @@v10@@ = @@v9@@ ; if ( @@v9@@ == Number ) { @@v10@@ = Number ; } else if ( ! @@v9@@ ) { rpl_re_compile_fastmap ( @@a1@@ ) ; return @@v10@@ ; } free ( * ( void * * ) ( @@a1@@ + Number ) ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; return @@v10@@ ; } return Number L ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_219690 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_219670 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_219680 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 __fastcall check_dst_limits_calc_pos ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ , unsigned __int64 @@a5@@ , __int64 @@a6@@ ) { __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; unsigned __int64 @@v8@@ ; int @@v9@@ ; __int64 @@result@@ ; @@v6@@ = * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@a2@@ ; @@v7@@ = * ( _QWORD * ) ( @@v6@@ + Number ) ; if ( @@v7@@ > @@a5@@ ) return Number ; @@v8@@ = * ( _QWORD * ) ( @@v6@@ + Number ) ; if ( @@v8@@ < @@a5@@ ) return Number L ; @@v9@@ = ( @@v7@@ == @@a5@@ ) | Number ; if ( @@v8@@ == @@a5@@ ) return check_dst_limits_calc_pos_1 ( @@a1@@ , @@v9@@ , @@a3@@ , @@a4@@ , @@a6@@ ) ; @@result@@ = Number L ; if ( @@v7@@ == @@a5@@ ) { @@v9@@ = Number ; return check_dst_limits_calc_pos_1 ( @@a1@@ , @@v9@@ , @@a3@@ , @@a4@@ , @@a6@@ ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall re_node_set_insert_last ( _QWORD * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v3@@ ; void * @@v4@@ ; __int64 @@v6@@ ; @@v3@@ = @@a1@@ [ Number ] ; @@v4@@ = ( void * ) @@a1@@ [ Number ] ; if ( * @@a1@@ != @@v3@@ ) goto LABEL_2 ; @@v6@@ = @@v3@@ + Number ; * @@a1@@ = Number * @@v6@@ ; @@v4@@ = realloc ( @@v4@@ , Number * @@v6@@ ) ; if ( @@v4@@ ) { @@a1@@ [ Number ] = @@v4@@ ; @@v3@@ = @@a1@@ [ Number ] ; LABEL_2 : @@a1@@ [ Number ] = @@v3@@ + Number ; * ( ( _QWORD * ) @@v4@@ + @@v3@@ ) = @@a2@@ ; return Number L ; } return Number L ; }
char * ttyname ( int @@fd@@ ) { return ttyname ( @@fd@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
__int64 __fastcall peek_token_bracket ( _BYTE * @@a1@@ , __int64 @@a2@@ , char @@a3@@ ) { unsigned __int64 @@v3@@ ; __int64 @@v4@@ ; bool @@v5@@ ; char @@v6@@ ; __int64 @@result@@ ; char @@v8@@ ; char @@v9@@ ; @@v3@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) <= @@v3@@ ) { @@a1@@ [ Number ] = Number ; return Number L ; } @@v4@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@v5@@ = * ( _DWORD * ) ( @@a2@@ + Number ) <= Number ; @@v6@@ = * ( _BYTE * ) ( @@v4@@ + @@v3@@ ) ; * @@a1@@ = @@v6@@ ; if ( ! @@v5@@ && @@v3@@ != * ( _QWORD * ) ( @@a2@@ + Number ) && * ( _DWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number * @@v3@@ ) == Number ) { goto LABEL_19 ; } switch ( @@v6@@ ) { case String : if ( ( @@a3@@ & Number ) == Number || @@v3@@ + Number >= * ( _QWORD * ) ( @@a2@@ + Number ) ) { LABEL_19 : @@a1@@ [ Number ] = Number ; return Number L ; } * ( _QWORD * ) ( @@a2@@ + Number ) = @@v3@@ + Number ; @@v9@@ = * ( _BYTE * ) ( @@v4@@ + @@v3@@ + Number ) ; @@a1@@ [ Number ] = Number ; * @@a1@@ = @@v9@@ ; @@result@@ = Number L ; break ; case String : if ( @@v3@@ + Number < * ( _QWORD * ) ( @@a2@@ + Number ) ) { @@v8@@ = * ( _BYTE * ) ( @@v4@@ + @@v3@@ + Number ) ; * @@a1@@ = @@v8@@ ; switch ( @@v8@@ ) { case String : if ( ( @@a3@@ & Number ) != Number ) { @@a1@@ [ Number ] = Number ; return Number L ; } break ; case String : @@a1@@ [ Number ] = Number ; return Number L ; case String : @@a1@@ [ Number ] = Number ; return Number L ; } } @@a1@@ [ Number ] = Number ; * @@a1@@ = Number ; return Number L ; case String : @@a1@@ [ Number ] = Number ; @@result@@ = Number L ; break ; case String : @@a1@@ [ Number ] = Number ; @@result@@ = Number L ; break ; case String : @@a1@@ [ Number ] = Number ; return Number L ; default : goto LABEL_19 ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_20B270 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20B250 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_20B260 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
void __fastcall build_upper_buffer ( _QWORD * @@a1@@ ) { unsigned __int64 @@v1@@ ; unsigned __int64 @@v2@@ ; const unsigned __int16 * * @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; char @@v6@@ ; _BYTE * @@v7@@ ; @@v1@@ = @@a1@@ [ Number ] ; if ( @@a1@@ [ Number ] <= @@v1@@ ) @@v1@@ = @@a1@@ [ Number ] ; @@v2@@ = @@a1@@ [ Number ] ; if ( @@v1@@ > @@v2@@ ) { @@v3@@ = __ctype_b_loc ( ) ; do { while ( Number ) { @@v4@@ = @@a1@@ [ Number ] ; @@v5@@ = * ( unsigned __int8 * ) ( @@a1@@ [ Number ] + @@v2@@ + * @@a1@@ ) ; @@v6@@ = * ( _BYTE * ) ( @@a1@@ [ Number ] + @@v2@@ + * @@a1@@ ) ; if ( @@v4@@ ) { @@v5@@ = * ( unsigned __int8 * ) ( @@v4@@ + @@v5@@ ) ; @@v6@@ = @@v5@@ ; } @@v7@@ = ( _BYTE * ) ( @@v2@@ + @@a1@@ [ Number ] ) ; if ( ( ( * @@v3@@ ) [ @@v5@@ ] & Number ) == Number ) break ; ++ @@v2@@ ; * @@v7@@ = ( * __ctype_toupper_loc ( ) ) [ @@v5@@ ] ; if ( @@v1@@ == @@v2@@ ) goto LABEL_10 ; } ++ @@v2@@ ; * @@v7@@ = @@v6@@ ; } while ( @@v1@@ != @@v2@@ ) ; } LABEL_10 : @@a1@@ [ Number ] = @@v2@@ ; @@a1@@ [ Number ] = @@v2@@ ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
__int64 __fastcall extend_buffers ( __int64 @@a1@@ ) { unsigned __int64 @@v1@@ ; unsigned int @@v3@@ ; void * @@v4@@ ; void * @@v5@@ ; int @@v6@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; @@v1@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( @@v1@@ > Number ) return Number L ; @@v3@@ = re_string_realloc_buffers ( @@a1@@ , Number * @@v1@@ ) ; if ( @@v3@@ ) return @@v3@@ ; @@v4@@ = * ( void * * ) ( @@a1@@ + Number ) ; if ( ! @@v4@@ ) goto LABEL_6 ; @@v5@@ = realloc ( @@v4@@ , Number L * * ( _QWORD * ) ( @@a1@@ + Number ) + Number ) ; if ( ! @@v5@@ ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v5@@ ; LABEL_6 : @@v6@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; if ( ! * ( _BYTE * ) ( @@a1@@ + Number ) ) { if ( @@v6@@ > Number ) { build_wcs_buffer ( @@a1@@ ) ; return Number L ; } @@v8@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( @@v8@@ ) { @@v9@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= @@v9@@ ) @@v9@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v10@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( @@v9@@ > @@v10@@ ) { while ( Number ) { * ( _BYTE * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@v10@@ ) = * ( _BYTE * ) ( @@v8@@ + * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@v10@@ + * ( _QWORD * ) @@a1@@ ) ) ; if ( @@v9@@ == ++ @@v10@@ ) break ; @@v8@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; } } * ( _QWORD * ) ( @@a1@@ + Number ) = @@v10@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v10@@ ; } return @@v3@@ ; } if ( @@v6@@ > Number ) return build_wcs_upper_buffer ( @@a1@@ ) ; build_upper_buffer ( ( _QWORD * ) @@a1@@ ) ; return Number L ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
void __fastcall free_token ( __int64 @@a1@@ ) { int @@v1@@ ; @@v1@@ = * ( _DWORD * ) ( @@a1@@ + Number ) & Number ; if ( @@v1@@ == Number ) { free_charset ( * ( void * * ) @@a1@@ ) ; } else if ( @@v1@@ == Number ) { free ( * ( void * * ) @@a1@@ ) ; } }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
__int64 __fastcall optimize_subexps ( __int64 @@a1@@ , __int64 @@a2@@ ) { char @@v2@@ ; __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; _QWORD * @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; @@v2@@ = * ( _BYTE * ) ( @@a2@@ + Number ) ; if ( @@v2@@ != Number ) { if ( @@v2@@ == Number ) { @@v4@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( @@v4@@ ) { if ( * ( _BYTE * ) ( @@v4@@ + Number ) == Number ) { @@v5@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; @@v6@@ = * ( _QWORD * * ) ( @@v4@@ + Number ) ; * ( _QWORD * ) ( @@a2@@ + Number ) = @@v6@@ ; if ( @@v6@@ ) * @@v6@@ = @@a2@@ ; * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@v5@@ ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L * * ( _QWORD * ) ( @@a2@@ + Number ) ) ; if ( @@v5@@ <= Number ) * ( _QWORD * ) ( @@a1@@ + Number ) &= __ROL8__ ( Number , @@v5@@ ) ; } } } return Number L ; } @@v7@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( ! @@v7@@ ) return Number L ; @@v8@@ = * ( _QWORD * ) ( @@v7@@ + Number L * * ( int * ) ( @@a2@@ + Number ) ) ; * ( _QWORD * ) ( @@a2@@ + Number ) = @@v8@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) |= Number << @@v8@@ ; return Number L ; }
void __fastcall match_ctx_clean ( _QWORD * @@a1@@ ) { unsigned __int64 @@v1@@ ; __int64 @@v2@@ ; unsigned __int64 @@v3@@ ; void * * @@v4@@ ; __int64 @@v5@@ ; if ( @@a1@@ [ Number ] ) { @@v1@@ = Number L ; do { @@v2@@ = * ( _QWORD * ) ( @@a1@@ [ Number ] + Number * @@v1@@ ) ; if ( * ( _QWORD * ) ( @@v2@@ + Number ) ) { @@v3@@ = Number L ; do { @@v4@@ = * ( void * * * ) ( * ( _QWORD * ) ( @@v2@@ + Number ) + Number * @@v3@@ ++ ) ; free ( @@v4@@ [ Number ] ) ; free ( @@v4@@ ) ; } while ( * ( _QWORD * ) ( @@v2@@ + Number ) > @@v3@@ ) ; } free ( * ( void * * ) ( @@v2@@ + Number ) ) ; @@v5@@ = * ( _QWORD * ) ( @@v2@@ + Number ) ; if ( @@v5@@ ) { free ( * ( void * * ) ( @@v5@@ + Number ) ) ; free ( * ( void * * ) ( @@v2@@ + Number ) ) ; } ++ @@v1@@ ; free ( ( void * ) @@v2@@ ) ; } while ( @@a1@@ [ Number ] > @@v1@@ ) ; } @@a1@@ [ Number ] = Number L ; @@a1@@ [ Number ] = Number L ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
int puts ( const char * @@s@@ ) { return puts ( @@s@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
__int64 __fastcall re_node_set_init_copy_isra_19 ( _QWORD * @@a1@@ , __int64 * @@a2@@ , const void * * @@a3@@ ) { __int64 @@v3@@ ; __int64 @@v4@@ ; void * @@v6@@ ; __int64 @@result@@ ; @@v3@@ = * @@a2@@ ; @@a1@@ [ Number ] = * @@a2@@ ; @@v4@@ = * @@a2@@ ; if ( * @@a2@@ ) { * @@a1@@ = @@v3@@ ; @@v6@@ = malloc ( Number * @@v3@@ ) ; @@a1@@ [ Number ] = @@v6@@ ; if ( @@v6@@ ) { memcpy ( @@v6@@ , * @@a3@@ , Number * @@v4@@ ) ; @@result@@ = Number L ; } else { @@a1@@ [ Number ] = Number L ; * @@a1@@ = Number L ; @@result@@ = Number L ; } } else { @@a1@@ [ Number ] = Number L ; @@result@@ = Number L ; * ( _OWORD * ) @@a1@@ = Number L ; } return @@result@@ ; }
wctype_t wctype ( const char * @@property@@ ) { return wctype ( @@property@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
wint_t btowc ( int @@c@@ ) { return btowc ( @@c@@ ) ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
__int64 __fastcall calc_next ( __int64 a1 , __int64 @@a2@@ ) { char @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@result@@ ; __int64 @@v6@@ ; @@v2@@ = * ( _BYTE * ) ( @@a2@@ + Number ) ; @@v3@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( @@v2@@ == Number ) { * ( _QWORD * ) ( @@v3@@ + Number ) = @@a2@@ ; @@result@@ = Number L ; } else if ( @@v2@@ == Number ) { @@v6@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; * ( _QWORD * ) ( @@v3@@ + Number ) = * ( _QWORD * ) ( @@v6@@ + Number ) ; * ( _QWORD * ) ( @@v6@@ + Number ) = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@result@@ = Number L ; } else { if ( @@v3@@ ) * ( _QWORD * ) ( @@v3@@ + Number ) = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@v4@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( @@v4@@ ) * ( _QWORD * ) ( @@v4@@ + Number ) = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@result@@ = Number L ; } return @@result@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
bool __fastcall nextarg ( char * @@s2@@ ) { __int64 @@v1@@ ; bool @@result@@ ; @@v1@@ = args ; @@result@@ = Number ; if ( * ( _QWORD * ) args ) { @@result@@ = strcmp ( * ( const char * * ) args , @@s2@@ ) == Number ; args = @@v1@@ + Number L * @@result@@ ; } return @@result@@ ; }
__int64 __fastcall check_node_accept ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int8 @@v4@@ ; __int64 @@result@@ ; unsigned int @@v6@@ ; unsigned int @@v7@@ ; unsigned int @@v8@@ ; unsigned int @@v9@@ ; unsigned int @@v10@@ ; __int64 @@v11@@ ; @@v3@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@a3@@ ) ; @@v4@@ = * ( _BYTE * ) ( @@a2@@ + Number ) ; if ( @@v4@@ == Number ) { @@v11@@ = * ( _QWORD * ) ( * ( _QWORD * ) @@a2@@ + Number * ( ( unsigned __int64 ) ( unsigned __int8 ) @@v3@@ >> Number ) ) ; @@result@@ = Number L ; if ( ! _bittest64 ( & @@v11@@ , @@v3@@ ) ) return @@result@@ ; goto LABEL_9 ; } if ( @@v4@@ <= Number ) { if ( @@v4@@ == Number ) { @@result@@ = Number L ; if ( * ( _BYTE * ) @@a2@@ != ( _BYTE ) @@v3@@ ) return @@result@@ ; goto LABEL_9 ; } return Number L ; } if ( @@v4@@ == Number ) goto LABEL_6 ; if ( @@v4@@ != Number ) return Number L ; @@result@@ = Number L ; if ( ( @@v3@@ & Number ) != Number L ) return @@result@@ ; LABEL_6 : if ( ( _BYTE ) @@v3@@ == Number ) { @@result@@ = Number L ; if ( ( * ( _BYTE * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L ) & Number ) == Number ) return @@result@@ ; } else if ( ! ( _BYTE ) @@v3@@ ) { @@result@@ = Number L ; if ( * ( char * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L ) < Number ) return @@result@@ ; } LABEL_9 : @@v6@@ = * ( _DWORD * ) ( @@a2@@ + Number ) ; @@result@@ = Number L ; if ( ( @@v6@@ & Number ) == Number ) return @@result@@ ; @@v7@@ = @@v6@@ >> Number ; @@v8@@ = re_string_context_at ( @@a1@@ , @@a3@@ , * ( _DWORD * ) ( @@a1@@ + Number ) ) ; @@v9@@ = @@v8@@ ; if ( ( @@v7@@ & Number ) != Number ) { @@result@@ = Number L ; if ( ( @@v9@@ & Number ) == Number || ( @@v7@@ & Number ) != Number ) return @@result@@ ; } else if ( ( @@v7@@ & Number ) != Number && ( @@v8@@ & Number ) != Number ) { return Number L ; } if ( ( @@v7@@ & Number ) == Number || ( @@result@@ = Number L , ( @@v9@@ & Number ) != Number ) ) { @@result@@ = Number L ; @@v10@@ = ( @@v9@@ >> Number ) & Number ; if ( ( @@v7@@ & Number ) != Number ) @@result@@ = @@v10@@ ; } return @@result@@ ; }
char * __fastcall duplicate_tree ( _QWORD * * @@a1@@ , __int64 @@a2@@ ) { _QWORD * * @@v2@@ ; _QWORD * @@v3@@ ; __int64 * @@v4@@ ; char * @@result@@ ; _QWORD * * @@v6@@ ; _QWORD * @@v7@@ ; __int64 @@v8@@ [ Number ] ; @@v2@@ = @@a1@@ ; @@v3@@ = * @@a1@@ ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ = @@v8@@ ; while ( Number ) { @@result@@ = create_token_tree_isra_18 ( ( _QWORD * ) ( @@a2@@ + Number ) , ( int * ) ( @@a2@@ + Number ) , Number L , Number L , ( const __m128i * ) ( @@v2@@ + Number ) ) ; * @@v4@@ = ( __int64 ) @@result@@ ; if ( ! @@result@@ ) break ; * ( _QWORD * ) @@result@@ = @@v3@@ ; @@v3@@ = ( _QWORD * ) * @@v4@@ ; * ( _BYTE * ) ( * @@v4@@ + Number ) |= Number ; if ( @@v2@@ [ Number ] ) { @@v4@@ = @@v3@@ + Number ; @@v2@@ = ( _QWORD * * ) @@v2@@ [ Number ] ; } else { @@v6@@ = Number L ; while ( Number ) { @@v7@@ = @@v2@@ [ Number ] ; if ( @@v7@@ ) { if ( @@v7@@ != @@v6@@ ) break ; } @@v3@@ = ( _QWORD * ) * @@v3@@ ; @@v6@@ = @@v2@@ ; if ( ! * @@v2@@ ) return ( char * ) @@v8@@ [ Number ] ; @@v2@@ = ( _QWORD * * ) * @@v2@@ ; } @@v4@@ = @@v3@@ + Number ; @@v2@@ = ( _QWORD * * ) @@v2@@ [ Number ] ; } } return @@result@@ ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
__int64 __fastcall mpz_tdiv_q ( __int64 * @@a1@@ , _QWORD * @@a2@@ , __int64 * @@a3@@ ) { __int64 @@v3@@ ; __int64 @@result@@ ; @@v3@@ = * @@a3@@ ; if ( * @@a2@@ == Number && @@v3@@ == Number ) integer_overflow ( Number ) ; @@result@@ = * @@a2@@ / @@v3@@ ; * @@a1@@ = @@result@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
__int64 __fastcall check_subexp_matching_top_isra_21 ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , _QWORD * @@a3@@ , __int64 @@a4@@ ) { _QWORD * @@v4@@ ; unsigned __int64 @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; __int64 @@v12@@ ; _QWORD * @@v13@@ ; _QWORD * @@v14@@ ; bool @@v15@@ ; _QWORD * @@v17@@ ; __int64 @@v18@@ ; __int64 @@v19@@ ; _QWORD * @@v20@@ ; __int64 @@v21@@ ; __int64 @@v22@@ ; @@v4@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; if ( ! * @@a2@@ ) return Number L ; @@v7@@ = Number L ; while ( Number ) { while ( Number ) { @@v8@@ = * ( _QWORD * ) ( * @@a3@@ + Number * @@v7@@ ) ; @@v9@@ = * @@v4@@ + Number * @@v8@@ ; if ( * ( _BYTE * ) ( @@v9@@ + Number ) == Number ) { @@v10@@ = * ( _QWORD * ) @@v9@@ ; if ( @@v10@@ <= Number ) { @@v11@@ = @@v4@@ [ Number ] ; if ( _bittest64 ( & @@v11@@ , @@v10@@ ) ) break ; } } if ( ++ @@v7@@ >= * @@a2@@ ) return Number L ; } @@v12@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v13@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; if ( @@v12@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ) break ; LABEL_8 : @@v20@@ = @@v13@@ ; @@v18@@ = @@v12@@ ; @@v22@@ = @@a4@@ ; @@v14@@ = calloc ( Number , Number ) ; @@v20@@ [ @@v18@@ ] = @@v14@@ ; if ( ! @@v14@@ ) return Number L ; ++ @@v7@@ ; @@a4@@ = @@v22@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v18@@ + Number ; @@v15@@ = @@v7@@ < * @@a2@@ ; @@v14@@ [ Number ] = @@v8@@ ; * @@v14@@ = @@v22@@ ; if ( ! @@v15@@ ) return Number L ; } @@v19@@ = @@a4@@ ; @@v21@@ = Number * @@v12@@ ; @@v17@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number * @@v12@@ ) ; @@v13@@ = @@v17@@ ; @@a4@@ = @@v19@@ ; if ( @@v17@@ ) { * ( _QWORD * ) ( @@a1@@ + Number ) = @@v17@@ ; @@v12@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v21@@ ; goto LABEL_8 ; } return Number L ; }
char * __fastcall rpl_re_compile_pattern ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v3@@ ; int @@v4@@ ; char * @@result@@ ; @@v3@@ = rpl_re_syntax_options ; * ( _BYTE * ) ( @@a3@@ + Number ) = ( Number * ( ( rpl_re_syntax_options & Number ) != Number ) ) | * ( _BYTE * ) ( @@a3@@ + Number ) & Number | Number ; @@v4@@ = re_compile_internal ( @@a3@@ , @@a1@@ , @@a2@@ , @@v3@@ ) ; if ( @@v4@@ ) @@result@@ = dcgettext ( Number L , & _re_error_msgid [ _re_error_msgid_idx [ @@v4@@ ] ] , Number ) ; else @@result@@ = Number L ; return @@result@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
__int64 __fastcall out_file_context ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { int * @@v4@@ ; int * @@v5@@ ; __int64 @@v6@@ ; char * @@v7@@ ; @@v4@@ = __errno_location ( ) ; * @@v4@@ = Number ; @@v5@@ = @@v4@@ ; @@v6@@ = quote ( @@a1@@ ) ; @@v7@@ = dcgettext ( Number L , String , Number ) ; error ( Number , * @@v5@@ , @@v7@@ , @@v6@@ ) ; * ( _WORD * ) ( @@a2@@ + @@a3@@ ) = Number ; return __printf_chk ( ) ; }
_BOOL4 __fastcall null ( __int64 @@a1@@ ) { _BYTE * @@v1@@ ; _BOOL4 @@result@@ ; char * @@v3@@ ; char @@v4@@ ; if ( ! * ( _DWORD * ) @@a1@@ ) return * ( _QWORD * ) ( @@a1@@ + Number ) == Number L ; if ( * ( _DWORD * ) @@a1@@ != Number ) abort ( ) ; @@v1@@ = * ( _BYTE * * ) ( @@a1@@ + Number ) ; @@result@@ = Number ; if ( * @@v1@@ ) { @@v3@@ = & @@v1@@ [ * @@v1@@ == Number ] ; @@v4@@ = * @@v3@@ ; do { if ( @@v4@@ != Number ) return Number ; @@v4@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; @@result@@ = Number ; } return @@result@@ ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
__int64 __fastcall fetch_number ( __int64 * @@a1@@ , unsigned __int8 * @@a2@@ , __int64 @@a3@@ ) { unsigned __int64 @@v4@@ ; unsigned __int8 @@v5@@ ; __int64 @@v6@@ ; @@v4@@ = Number ; while ( Number ) { @@a1@@ [ Number ] += ( int ) peek_token ( @@a2@@ , @@a1@@ , @@a3@@ ) ; @@v5@@ = @@a2@@ [ Number ] ; @@v6@@ = * @@a2@@ ; if ( @@v5@@ == Number ) break ; if ( ( _BYTE ) @@v6@@ == Number || @@v5@@ == Number ) return @@v4@@ ; if ( @@v5@@ != Number || ( unsigned __int8 ) ( @@v6@@ - Number ) > Number || @@v4@@ == Number ) { @@v4@@ = Number ; } else if ( @@v4@@ == Number ) { @@v4@@ = ( unsigned __int8 ) @@v6@@ - Number ; } else { @@v4@@ = @@v6@@ + Number * @@v4@@ - Number ; if ( @@v4@@ >= Number ) @@v4@@ = Number ; } } return Number ; }
_QWORD * __fastcall eval1 ( unsigned __int8 @@a1@@ ) { _QWORD * @@v2@@ ; bool @@v3@@ ; _QWORD * @@v4@@ ; __int64 @@v5@@ ; @@v2@@ = eval2 ( @@a1@@ ) ; while ( nextarg ( String ) ) { while ( Number ) { @@v3@@ = Number ; if ( @@a1@@ ) @@v3@@ = ! null ( ( __int64 ) @@v2@@ ) ; @@v4@@ = eval2 ( @@v3@@ ) ; if ( ! null ( ( __int64 ) @@v2@@ ) && ! null ( ( __int64 ) @@v4@@ ) ) break ; freev ( @@v2@@ ) ; freev ( @@v4@@ ) ; @@v5@@ = xmalloc ( Number L ) ; * ( _DWORD * ) @@v5@@ = Number ; * ( _QWORD * ) ( @@v5@@ + Number ) = Number L ; @@v2@@ = ( _QWORD * ) @@v5@@ ; if ( ! nextarg ( String ) ) return @@v2@@ ; } freev ( @@v4@@ ) ; } return @@v2@@ ; }
__int64 __fastcall rpl_regcomp ( __int64 @@a1@@ , const char * @@a2@@ , int @@a3@@ ) { __int64 @@v4@@ ; void * @@v5@@ ; __int64 @@v6@@ ; char @@v7@@ ; unsigned __int64 @@v8@@ ; unsigned int @@v9@@ ; unsigned int @@v10@@ ; * ( _QWORD * ) @@a1@@ = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; @@v4@@ = ( @@a3@@ & Number ) == Number ? Number L : Number L ; @@v5@@ = malloc ( Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v5@@ ; if ( @@v5@@ ) { @@v6@@ = @@v4@@ | ( @@a3@@ << Number ) & Number ; if ( ( @@a3@@ & Number ) != Number ) { * ( _BYTE * ) ( @@a1@@ + Number ) |= Number ; @@v6@@ = @@v6@@ & Number | Number ; } else { * ( _BYTE * ) ( @@a1@@ + Number ) &= Number ; } @@v7@@ = * ( _BYTE * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _BYTE * ) ( @@a1@@ + Number ) = @@v7@@ & Number | ( Number * ( ( @@a3@@ & Number ) != Number ) ) ; @@v8@@ = strlen ( @@a2@@ ) ; @@v9@@ = re_compile_internal ( @@a1@@ , ( __int64 ) @@a2@@ , @@v8@@ , @@v6@@ ) ; @@v10@@ = @@v9@@ ; if ( @@v9@@ == Number ) { @@v10@@ = Number ; } else if ( ! @@v9@@ ) { rpl_re_compile_fastmap ( @@a1@@ ) ; return @@v10@@ ; } free ( * ( void * * ) ( @@a1@@ + Number ) ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; return @@v10@@ ; } return Number L ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
size_t __fastcall rpl_regerror ( unsigned int @@a1@@ , __int64 a2 , char * @@a3@@ , size_t @@a4@@ ) { char * @@v6@@ ; size_t @@v7@@ ; size_t @@v8@@ ; size_t @@v9@@ ; if ( @@a1@@ > Number ) abort ( ) ; @@v6@@ = dcgettext ( Number L , & _re_error_msgid [ _re_error_msgid_idx [ @@a1@@ ] ] , Number ) ; @@v7@@ = strlen ( @@v6@@ ) ; @@v8@@ = @@v7@@ + Number ; if ( @@a4@@ ) { @@v9@@ = @@v7@@ + Number ; if ( @@v8@@ > @@a4@@ ) { @@v9@@ = @@a4@@ - Number ; @@a3@@ [ @@a4@@ - Number ] = Number ; } memcpy ( @@a3@@ , @@v6@@ , @@v9@@ ) ; } return @@v8@@ ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 __fastcall rpl_re_match ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ , unsigned __int64 @@a4@@ , unsigned __int64 * @@a5@@ ) { return re_search_stub ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , Number L , @@a3@@ , @@a5@@ , Number ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
struct tm * localtime ( const time_t * @@timer@@ ) { return localtime ( @@timer@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
char * __fastcall file_type ( __int64 @@a1@@ ) { int @@v1@@ ; char * @@result@@ ; @@v1@@ = * ( _DWORD * ) ( @@a1@@ + Number ) & Number ; switch ( @@v1@@ ) { case Number : if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) @@result@@ = dcgettext ( Number L , String , Number ) ; else @@result@@ = dcgettext ( Number L , String , Number ) ; break ; case Number : @@result@@ = dcgettext ( Number L , String , Number ) ; break ; case Number : @@result@@ = dcgettext ( Number L , String , Number ) ; break ; case Number : @@result@@ = dcgettext ( Number L , String , Number ) ; break ; case Number : @@result@@ = dcgettext ( Number L , String , Number ) ; break ; case Number : @@result@@ = dcgettext ( Number L , String , Number ) ; break ; case Number : @@result@@ = dcgettext ( Number L , String , Number ) ; break ; default : @@result@@ = dcgettext ( Number L , String , Number ) ; break ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 __fastcall rpl_re_match_2 ( __int64 @@a1@@ , const void * @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ , unsigned __int64 @@a6@@ , unsigned __int64 * @@a7@@ , __int64 @@a8@@ ) { return re_search_2_stub ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ , Number L , @@a7@@ , @@a8@@ , Number ) ; }
struct group * getgrgid ( __gid_t @@gid@@ ) { return getgrgid ( @@gid@@ ) ; }
int fileno ( FILE * @@stream@@ ) { return fileno ( @@stream@@ ) ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
int __fxstat ( int @@ver@@ , int @@fildes@@ , struct stat * @@stat_buf@@ ) { return _fxstat ( @@ver@@ , @@fildes@@ , @@stat_buf@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_2191F0 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2191D0 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_2191E0 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; program_invocation_short_name = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
__int64 __fastcall re_string_realloc_buffers ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { void * @@v3@@ ; void * @@v4@@ ; void * @@v5@@ ; void * @@v7@@ ; if ( * ( int * ) ( @@a1@@ + Number ) > Number ) { if ( ! is_mul_ok ( @@a2@@ , Number ) ) return Number L ; @@v3@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number * @@a2@@ ) ; if ( ! @@v3@@ ) return Number L ; @@v4@@ = * ( void * * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v3@@ ; if ( @@v4@@ ) { @@v5@@ = realloc ( @@v4@@ , Number * @@a2@@ ) ; if ( ! @@v5@@ ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v5@@ ; } } if ( ! * ( _BYTE * ) ( @@a1@@ + Number ) ) { LABEL_8 : * ( _QWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; return Number L ; } @@v7@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , @@a2@@ ) ; if ( @@v7@@ ) { * ( _QWORD * ) ( @@a1@@ + Number ) = @@v7@@ ; goto LABEL_8 ; } return Number L ; }
_QWORD * __fastcall randread_new ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { FILE * @@v2@@ ; __int64 @@v3@@ ; size_t @@v4@@ ; _QWORD * @@result@@ ; _QWORD * @@v6@@ ; if ( @@a2@@ ) { if ( @@a1@@ ) { @@v2@@ = ( FILE * ) fopen_safer ( @@a1@@ , & off_8E43 ) ; if ( @@v2@@ ) { @@v3@@ = xmalloc ( Number L ) ; * ( _QWORD * ) @@v3@@ = @@v2@@ ; @@v4@@ = Number L ; if ( @@a2@@ <= Number ) @@v4@@ = @@a2@@ ; * ( _QWORD * ) ( @@v3@@ + Number ) = randread_error ; * ( _QWORD * ) ( @@v3@@ + Number ) = @@a1@@ ; setvbuf ( @@v2@@ , ( char * ) ( @@v3@@ + Number ) , Number , @@v4@@ ) ; } else { @@v3@@ = Number L ; } @@result@@ = ( _QWORD * ) @@v3@@ ; } else { @@v6@@ = ( _QWORD * ) xmalloc ( Number L ) ; * @@v6@@ = Number L ; @@v6@@ [ Number ] = Number L ; @@v6@@ [ Number ] = Number L ; @@v6@@ [ Number ] = randread_error ; isaac_seed ( @@v6@@ + Number ) ; @@result@@ = @@v6@@ ; } } else { @@result@@ = ( _QWORD * ) xmalloc ( Number L ) ; * @@result@@ = Number L ; @@result@@ [ Number ] = Number L ; @@result@@ [ Number ] = randread_error ; } return @@result@@ ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
void __fastcall build_upper_buffer ( _QWORD * @@a1@@ ) { unsigned __int64 @@v1@@ ; unsigned __int64 @@v2@@ ; const unsigned __int16 * * @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; char @@v6@@ ; _BYTE * @@v7@@ ; @@v1@@ = @@a1@@ [ Number ] ; if ( @@a1@@ [ Number ] <= @@v1@@ ) @@v1@@ = @@a1@@ [ Number ] ; @@v2@@ = @@a1@@ [ Number ] ; if ( @@v1@@ > @@v2@@ ) { @@v3@@ = __ctype_b_loc ( ) ; do { while ( Number ) { @@v4@@ = @@a1@@ [ Number ] ; @@v5@@ = * ( unsigned __int8 * ) ( @@a1@@ [ Number ] + @@v2@@ + * @@a1@@ ) ; @@v6@@ = * ( _BYTE * ) ( @@a1@@ [ Number ] + @@v2@@ + * @@a1@@ ) ; if ( @@v4@@ ) { @@v5@@ = * ( unsigned __int8 * ) ( @@v4@@ + @@v5@@ ) ; @@v6@@ = @@v5@@ ; } @@v7@@ = ( _BYTE * ) ( @@v2@@ + @@a1@@ [ Number ] ) ; if ( ( ( * @@v3@@ ) [ @@v5@@ ] & Number ) == Number ) break ; ++ @@v2@@ ; * @@v7@@ = ( * __ctype_toupper_loc ( ) ) [ @@v5@@ ] ; if ( @@v1@@ == @@v2@@ ) goto LABEL_10 ; } ++ @@v2@@ ; * @@v7@@ = @@v6@@ ; } while ( @@v1@@ != @@v2@@ ) ; } LABEL_10 : @@a1@@ [ Number ] = @@v2@@ ; @@a1@@ [ Number ] = @@v2@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__int64 __fastcall imaxtostr ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; __int64 @@result@@ ; int @@v4@@ ; bool @@v5@@ ; @@v2@@ = @@a2@@ + Number ; * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; if ( @@a1@@ < Number ) { while ( Number ) { @@v4@@ = Number * ( @@a1@@ / Number ) + Number - @@a1@@ ; @@v5@@ = ( __int64 ) ( ( unsigned __int128 ) ( Number * ( __int128 ) @@a1@@ ) >> Number ) >> Number == @@a1@@ >> Number ; @@a1@@ /= Number L ; * ( _BYTE * ) ( @@v2@@ - Number ) = @@v4@@ ; if ( @@v5@@ ) break ; -- @@v2@@ ; } * ( _BYTE * ) ( @@v2@@ - Number ) = Number ; @@result@@ = @@v2@@ - Number ; } else { do { * ( _BYTE * ) -- @@v2@@ = @@a1@@ % Number + Number ; @@a1@@ /= Number ; } while ( @@a1@@ ) ; @@result@@ = @@v2@@ ; } return @@result@@ ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
__int64 __fastcall memcpy_uppcase ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v3@@ ; const __int32_t * * @@v4@@ ; if ( @@a3@@ ) { @@v3@@ = @@a3@@ - Number ; @@v4@@ = __ctype_toupper_loc ( ) ; do { * ( _BYTE * ) ( @@a1@@ + @@v3@@ ) = ( * @@v4@@ ) [ * ( unsigned __int8 * ) ( @@a2@@ + @@v3@@ ) ] ; -- @@v3@@ ; } while ( @@v3@@ != Number ) ; } return @@a1@@ ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
void __fastcall free_token ( __int64 @@a1@@ ) { int @@v1@@ ; @@v1@@ = * ( _DWORD * ) ( @@a1@@ + Number ) & Number ; if ( @@v1@@ == Number ) { free_charset ( * ( void * * ) @@a1@@ ) ; } else if ( @@v1@@ == Number ) { free ( * ( void * * ) @@a1@@ ) ; } }
__int64 __fastcall dir_len ( _BYTE * @@a1@@ ) { unsigned __int64 @@v1@@ ; _BYTE * @@v2@@ ; __int64 @@v3@@ ; @@v1@@ = * @@a1@@ == Number ; @@v2@@ = last_component ( @@a1@@ ) ; if ( @@v2@@ - @@a1@@ <= @@v1@@ ) return @@v2@@ - @@a1@@ ; @@v3@@ = @@v2@@ - @@a1@@ - Number ; if ( * ( @@v2@@ - Number ) != Number ) return @@v2@@ - @@a1@@ ; while ( @@v1@@ != @@v3@@ && @@a1@@ [ @@v3@@ - Number ] == Number ) -- @@v3@@ ; return @@v3@@ ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
__int64 __fastcall open_safer ( const char * @@a1@@ , char @@a2@@ , unsigned int @@a3@@ ) { __int64 @@v3@@ ; int @@v4@@ ; @@v3@@ = Number L ; if ( ( @@a2@@ & Number ) != Number ) @@v3@@ = @@a3@@ ; @@v4@@ = open ( @@a1@@ , @@a2@@ , @@v3@@ ) ; return fd_safer ( @@v4@@ ) ; }
__int64 __fastcall check_arrival_expand_ecl_sub ( _QWORD * @@a1@@ , _QWORD * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ , unsigned int @@a5@@ ) { __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; unsigned __int64 * @@v12@@ ; __int64 @@result@@ ; while ( Number ) { if ( re_node_set_contains_isra_3 ( @@a2@@ [ Number ] , @@a2@@ + Number , @@a3@@ ) ) return Number L ; @@v8@@ = * @@a1@@ + Number * @@a3@@ ; if ( * ( unsigned __int8 * ) ( @@v8@@ + Number ) == @@a5@@ && * ( _QWORD * ) @@v8@@ == @@a4@@ ) { break ; } if ( ! ( unsigned __int8 ) re_node_set_insert ( @@a2@@ , @@a3@@ ) ) return Number L ; @@v9@@ = Number * @@a3@@ ; @@v10@@ = @@v9@@ + @@a1@@ [ Number ] ; @@v11@@ = * ( _QWORD * ) ( @@v10@@ + Number ) ; if ( ! @@v11@@ ) return Number L ; @@v12@@ = * ( unsigned __int64 * * ) ( @@v10@@ + Number ) ; if ( @@v11@@ == Number ) { @@result@@ = check_arrival_expand_ecl_sub ( @@a1@@ , @@a2@@ , @@v12@@ [ Number ] , @@a4@@ , @@a5@@ ) ; if ( ( _DWORD ) @@result@@ ) return @@result@@ ; @@v12@@ = * ( unsigned __int64 * * ) ( @@a1@@ [ Number ] + @@v9@@ + Number ) ; } @@a3@@ = * @@v12@@ ; } if ( @@a5@@ != Number || ( unsigned __int8 ) re_node_set_insert ( @@a2@@ , @@a3@@ ) ) return Number L ; return Number L ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; char * @@v9@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String String String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = setlocale ( Number , Number L ) ; if ( @@v9@@ ) { if ( strncmp ( @@v9@@ , String , Number ) ) { last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_20B270 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20B250 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20B260 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
char * nl_langinfo ( nl_item @@item@@ ) { return nl_langinfo ( @@item@@ ) ; }
__int64 __fastcall check_arrival_expand_ecl ( _QWORD * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , unsigned int @@a4@@ ) { unsigned __int64 @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; __int64 @@v12@@ ; __int64 @@v13@@ ; __int64 @@v14@@ ; unsigned int @@v15@@ ; __m128i @@v16@@ ; __int64 @@result@@ ; unsigned int @@v18@@ ; __m128i @@v19@@ ; void * @@ptr@@ ; unsigned __int64 @@v21@@ ; @@v7@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@v21@@ = __readfsqword ( Number ) ; @@v19@@ = ( __m128i ) @@v7@@ ; @@ptr@@ = malloc ( Number * @@v7@@ ) ; if ( @@ptr@@ ) { if ( ! @@v7@@ ) { LABEL_12 : free ( * ( void * * ) ( @@a2@@ + Number ) ) ; @@v16@@ = _mm_load_si128 ( & @@v19@@ ) ; * ( _QWORD * ) ( @@a2@@ + Number ) = @@ptr@@ ; @@result@@ = Number L ; * ( __m128i * ) @@a2@@ = @@v16@@ ; return @@result@@ ; } @@v8@@ = Number L ; while ( Number ) { @@v9@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number * @@v8@@ ) ; @@v10@@ = @@a1@@ [ Number ] + Number * @@v9@@ ; @@v11@@ = * ( _QWORD * ) ( @@v10@@ + Number ) ; if ( ! @@v11@@ ) goto LABEL_13 ; @@v12@@ = * ( _QWORD * ) ( @@v10@@ + Number ) ; @@v13@@ = Number L ; while ( Number ) { @@v14@@ = * @@a1@@ + Number L * * ( _QWORD * ) ( @@v12@@ + Number * @@v13@@ ) ; if ( @@a4@@ == * ( unsigned __int8 * ) ( @@v14@@ + Number ) && @@a3@@ == * ( _QWORD * ) @@v14@@ ) { break ; } if ( @@v11@@ == ++ @@v13@@ ) goto LABEL_13 ; } if ( * ( _QWORD * ) ( @@v12@@ + Number * @@v13@@ ) == Number ) { LABEL_13 : @@v15@@ = re_node_set_merge ( ( __int64 ) & @@v19@@ , @@v10@@ ) ; if ( @@v15@@ ) { LABEL_14 : @@v18@@ = @@v15@@ ; free ( @@ptr@@ ) ; return @@v18@@ ; } } else { @@v15@@ = check_arrival_expand_ecl_sub ( @@a1@@ , & @@v19@@ , @@v9@@ , @@a3@@ , @@a4@@ ) ; if ( @@v15@@ ) goto LABEL_14 ; } if ( * ( _QWORD * ) ( @@a2@@ + Number ) <= ( unsigned __int64 ) ++ @@v8@@ ) goto LABEL_12 ; } } return Number L ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
__int64 __fastcall nstrftime ( char * @@a1@@ , __int64 @@a2@@ , const char * @@a3@@ , const __m128i * @@a4@@ , unsigned int @@a5@@ , unsigned int @@a6@@ ) { return strftime_case_ ( Number , @@a1@@ , @@a2@@ , ( char * ) @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall argmatch ( const char * @@a1@@ , const char * * @@a2@@ , char * @@a3@@ , size_t @@a4@@ ) { char * @@v5@@ ; size_t @@v6@@ ; const char * @@v7@@ ; size_t @@v8@@ ; __int64 @@v9@@ ; bool @@v10@@ ; char @@v11@@ ; __int64 @@v12@@ ; __int64 @@v14@@ ; char @@v15@@ ; @@v5@@ = @@a3@@ ; @@v6@@ = strlen ( @@a1@@ ) ; @@v7@@ = * @@a2@@ ; @@v14@@ = Number ; if ( ! * @@a2@@ ) return @@v14@@ ; @@v8@@ = @@v6@@ ; @@v15@@ = Number ; @@v9@@ = Number L ; do { while ( strncmp ( @@v7@@ , @@a1@@ , @@v8@@ ) ) { LABEL_7 : ++ @@v9@@ ; @@v5@@ += @@a4@@ ; @@v7@@ = @@a2@@ [ @@v9@@ ] ; if ( ! @@v7@@ ) goto LABEL_12 ; } if ( strlen ( @@v7@@ ) == @@v8@@ ) return @@v9@@ ; if ( @@v14@@ != Number ) { if ( @@a3@@ ) { @@v10@@ = memcmp ( & @@a3@@ [ @@a4@@ * @@v14@@ ] , @@v5@@ , @@a4@@ ) == Number ; @@v11@@ = @@v15@@ ; if ( ! @@v10@@ ) @@v11@@ = Number ; @@v15@@ = @@v11@@ ; } else { @@v15@@ = Number ; } goto LABEL_7 ; } @@v14@@ = @@v9@@ ++ ; @@v5@@ += @@a4@@ ; @@v7@@ = @@a2@@ [ @@v9@@ ] ; } while ( @@v7@@ ) ; LABEL_12 : @@v12@@ = Number ; if ( ! @@v15@@ ) @@v12@@ = @@v14@@ ; return @@v12@@ ; }
void __fastcall __noreturn integer_overflow ( char @@a1@@ ) { error ( Number , Number , String , ( unsigned int ) @@a1@@ ) ; abort ( ) ; }
__int64 __fastcall re_string_context_at ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , char @@a3@@ ) { wint_t @@v3@@ ; __int64 @@result@@ ; unsigned __int64 @@v5@@ ; __int64 @@v6@@ ; if ( @@a2@@ > Number ) return * ( unsigned int * ) ( @@a1@@ + Number ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) == @@a2@@ ) return ( @@a3@@ & Number ) == Number ? Number : Number ; if ( * ( int * ) ( @@a1@@ + Number ) <= Number ) { @@v5@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ ) ; @@v6@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * ( @@v5@@ >> Number ) ) ; @@result@@ = Number L ; if ( _bittest64 ( & @@v6@@ , @@v5@@ ) ) return @@result@@ ; @@result@@ = Number L ; if ( ( _BYTE ) @@v5@@ != Number ) return @@result@@ ; return Number * ( unsigned int ) ( * ( _BYTE * ) ( @@a1@@ + Number ) != Number ) ; } while ( Number ) { @@v3@@ = * ( _DWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@a2@@ ) ; if ( @@v3@@ != Number ) break ; if ( -- @@a2@@ > Number ) return * ( unsigned int * ) ( @@a1@@ + Number ) ; } if ( * ( _BYTE * ) ( @@a1@@ + Number ) && ( iswalnum ( @@v3@@ ) || @@v3@@ == Number ) ) return Number L ; @@result@@ = Number L ; if ( @@v3@@ == Number ) return Number * ( unsigned int ) ( * ( _BYTE * ) ( @@a1@@ + Number ) != Number ) ; return @@result@@ ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
int __cdecl __noreturn main ( int @@argc@@ , const char * * @@argv@@ , const char * * envp ) { const char * * @@v4@@ ; const char * @@v5@@ ; __int64 @@v6@@ ; unsigned __int8 @@v7@@ ; FILE * @@v8@@ ; const char * @@v9@@ ; char * @@v10@@ ; char * @@v11@@ ; _QWORD @@v12@@ [ Number ] ; @@v4@@ = @@argv@@ ; @@v5@@ = * @@argv@@ ; @@v12@@ [ Number ] = __readfsqword ( Number ) ; set_program_name ( @@v5@@ ) ; setlocale ( Number , String ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; exit_failure = Number ; atexit ( close_stdout ) ; parse_long_options ( @@argc@@ , ( _DWORD ) @@argv@@ , ( unsigned int ) String , ( unsigned int ) & unk_14401 , ( unsigned int ) String , ( unsigned int ) usage , ( char ) String ) ; if ( @@argc@@ > Number ) { if ( strcmp ( @@argv@@ [ Number ] , String ) ) goto LABEL_5 ; if ( @@argc@@ != Number ) { @@v4@@ = @@argv@@ + Number ; LABEL_5 : args = ( __int64 ) ( @@v4@@ + Number ) ; @@v6@@ = eval ( Number L ) ; if ( * ( _QWORD * ) args ) syntax_error ( ) ; if ( * ( _DWORD * ) @@v6@@ ) { if ( * ( _DWORD * ) @@v6@@ != Number ) abort ( ) ; puts ( * ( const char * * ) ( @@v6@@ + Number ) ) ; } else { @@v8@@ = stdout ; @@v9@@ = ( const char * ) imaxtostr ( * ( _QWORD * ) ( @@v6@@ + Number ) , @@v12@@ ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = stdout -> _IO_write_ptr ; if ( @@v10@@ >= stdout -> _IO_write_end ) { __overflow ( stdout , Number ) ; } else { stdout -> _IO_write_ptr = @@v10@@ + Number ; * @@v10@@ = Number ; } } @@v7@@ = null ( @@v6@@ ) ; exit ( @@v7@@ ) ; } } @@v11@@ = dcgettext ( Number L , String , Number ) ; error ( Number , Number , @@v11@@ ) ; usage ( Number ) ; }
unsigned __int64 __fastcall mpz_sub ( _QWORD * @@a1@@ , _QWORD * @@a2@@ , unsigned __int64 * @@a3@@ ) { unsigned __int64 @@v3@@ ; __int64 @@v4@@ ; unsigned __int64 @@result@@ ; @@v3@@ = * @@a3@@ ; @@v4@@ = * @@a2@@ - * @@a3@@ ; @@result@@ = @@v3@@ >> Number ; if ( * @@a2@@ < @@v4@@ != ( _BYTE ) @@result@@ ) integer_overflow ( Number ) ; * @@a1@@ = @@v4@@ ; return @@result@@ ; }
__int64 __fastcall eval4 ( unsigned __int8 @@a1@@ ) { __int64 @@v1@@ ; int @@v2@@ ; __int64 * @@v3@@ ; char * @@v4@@ ; __int64 ( __fastcall * @@v5@@ ) ( __int64 * , __int64 * , __int64 * ) ; char * @@v7@@ ; @@v1@@ = eval5 ( @@a1@@ ) ; while ( nextarg ( String ) ) { @@v2@@ = Number ; LABEL_4 : @@v3@@ = ( __int64 * ) eval5 ( @@a1@@ ) ; if ( ! @@a1@@ ) goto LABEL_5 ; LABEL_9 : if ( ! ( unsigned __int8 ) toarith ( @@v1@@ ) || ! ( unsigned __int8 ) toarith ( ( __int64 ) @@v3@@ ) ) { @@v4@@ = dcgettext ( Number L , String , Number ) ; error ( Number , Number , @@v4@@ ) ; } @@v5@@ = mpz_mul ; if ( @@v2@@ ) { if ( ! @@v3@@ [ Number ] ) { @@v7@@ = dcgettext ( Number L , String , Number ) ; error ( Number , Number , @@v7@@ ) ; } @@v5@@ = mpz_tdiv_r ; if ( @@v2@@ == Number ) @@v5@@ = mpz_tdiv_q ; } @@v5@@ ( ( __int64 * ) ( @@v1@@ + Number ) , ( __int64 * ) ( @@v1@@ + Number ) , @@v3@@ + Number ) ; LABEL_5 : freev ( @@v3@@ ) ; } if ( nextarg ( String ) ) { @@v2@@ = Number ; @@v3@@ = ( __int64 * ) eval5 ( @@a1@@ ) ; if ( ! @@a1@@ ) goto LABEL_5 ; goto LABEL_9 ; } if ( nextarg ( String ) ) { @@v2@@ = Number ; goto LABEL_4 ; } return @@v1@@ ; }
void __fastcall free_fail_stack_return_part_28 ( __int64 @@a1@@ ) { __int64 @@v2@@ ; unsigned __int64 @@v3@@ ; void * @@v4@@ ; if ( * ( _QWORD * ) @@a1@@ ) { @@v2@@ = Number L ; @@v3@@ = Number L ; do { ++ @@v3@@ ; free ( * ( void * * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@v2@@ + Number ) ) ; @@v4@@ = * ( void * * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@v2@@ + Number ) ; @@v2@@ += Number L ; free ( @@v4@@ ) ; } while ( @@v3@@ < * ( _QWORD * ) @@a1@@ ) ; } free ( * ( void * * ) ( @@a1@@ + Number ) ) ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
__int64 __fastcall str_value ( void * @@src@@ ) { __int64 @@v1@@ ; @@v1@@ = xmalloc ( Number L ) ; * ( _DWORD * ) @@v1@@ = Number ; * ( _QWORD * ) ( @@v1@@ + Number ) = xstrdup ( @@src@@ ) ; return @@v1@@ ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__int64 __fastcall fetch_number ( __int64 * @@a1@@ , unsigned __int8 * @@a2@@ , __int64 @@a3@@ ) { unsigned __int64 @@v4@@ ; unsigned __int8 @@v5@@ ; __int64 @@v6@@ ; @@v4@@ = Number ; while ( Number ) { @@a1@@ [ Number ] += ( int ) peek_token ( @@a2@@ , @@a1@@ , @@a3@@ ) ; @@v5@@ = @@a2@@ [ Number ] ; @@v6@@ = * @@a2@@ ; if ( @@v5@@ == Number ) break ; if ( ( _BYTE ) @@v6@@ == Number || @@v5@@ == Number ) return @@v4@@ ; if ( @@v5@@ != Number || ( unsigned __int8 ) ( @@v6@@ - Number ) > Number || @@v4@@ == Number ) { @@v4@@ = Number ; } else if ( @@v4@@ == Number ) { @@v4@@ = ( unsigned __int8 ) @@v6@@ - Number ; } else { @@v4@@ = @@v6@@ + Number * @@v4@@ - Number ; if ( @@v4@@ >= Number ) @@v4@@ = Number ; } } return Number ; }
void __fastcall freev ( void * @@ptr@@ ) { if ( * ( _DWORD * ) @@ptr@@ == Number ) free ( * ( ( void * * ) @@ptr@@ + Number ) ) ; free ( @@ptr@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
__int64 __fastcall imaxtostr ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; __int64 @@result@@ ; int @@v4@@ ; bool @@v5@@ ; @@v2@@ = @@a2@@ + Number ; * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; if ( @@a1@@ < Number ) { while ( Number ) { @@v4@@ = Number * ( @@a1@@ / Number ) + Number - @@a1@@ ; @@v5@@ = ( __int64 ) ( ( unsigned __int128 ) ( Number * ( __int128 ) @@a1@@ ) >> Number ) >> Number == @@a1@@ >> Number ; @@a1@@ /= Number L ; * ( _BYTE * ) ( @@v2@@ - Number ) = @@v4@@ ; if ( @@v5@@ ) break ; -- @@v2@@ ; } * ( _BYTE * ) ( @@v2@@ - Number ) = Number ; @@result@@ = @@v2@@ - Number ; } else { do { * ( _BYTE * ) -- @@v2@@ = @@a1@@ % Number + Number ; @@a1@@ /= Number ; } while ( @@a1@@ ) ; @@result@@ = @@v2@@ ; } return @@result@@ ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
unsigned __int64 __fastcall tostring ( __int64 @@a1@@ ) { void * @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; @@v5@@ = __readfsqword ( Number ) ; if ( * ( _DWORD * ) @@a1@@ ) { if ( * ( _DWORD * ) @@a1@@ != Number ) abort ( ) ; } else { @@v2@@ = ( void * ) imaxtostr ( * ( _QWORD * ) ( @@a1@@ + Number ) , & @@v4@@ ) ; @@v3@@ = xstrdup ( @@v2@@ ) ; * ( _DWORD * ) @@a1@@ = Number ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v3@@ ; } return __readfsqword ( Number ) ^ @@v5@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
__int64 __fastcall rpl_re_compile_fastmap ( __int64 @@a1@@ ) { __m128i * @@v1@@ ; _QWORD * @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; @@v1@@ = * ( __m128i * * ) ( @@a1@@ + Number ) ; @@v2@@ = * ( _QWORD * * ) @@a1@@ ; @@v1@@ -> m128i_i64 [ Number ] = Number L ; @@v1@@ [ Number ] . m128i_i64 [ Number ] = Number L ; memset ( ( void * ) ( ( unsigned __int64 ) & @@v1@@ -> m128i_u64 [ Number ] & Number ) , Number , Number L * ( ( ( unsigned int ) @@v1@@ - ( ( ( _DWORD ) @@v1@@ + Number ) & Number ) + Number ) >> Number ) ) ; re_compile_fastmap_iter_isra_32 ( ( __int64 * ) @@a1@@ , ( _QWORD * ) ( @@v2@@ [ Number ] + Number L ) , ( _QWORD * ) ( @@v2@@ [ Number ] + Number L ) , @@v1@@ ) ; @@v3@@ = @@v2@@ [ Number ] ; if ( @@v2@@ [ Number ] != @@v3@@ ) { re_compile_fastmap_iter_isra_32 ( ( __int64 * ) @@a1@@ , ( _QWORD * ) ( @@v3@@ + Number ) , ( _QWORD * ) ( @@v3@@ + Number ) , @@v1@@ ) ; @@v3@@ = @@v2@@ [ Number ] ; } @@v4@@ = @@v2@@ [ Number ] ; if ( @@v4@@ != @@v3@@ ) { re_compile_fastmap_iter_isra_32 ( ( __int64 * ) @@a1@@ , ( _QWORD * ) ( @@v4@@ + Number ) , ( _QWORD * ) ( @@v4@@ + Number ) , @@v1@@ ) ; @@v3@@ = @@v2@@ [ Number ] ; } @@v5@@ = @@v2@@ [ Number ] ; if ( @@v5@@ != @@v3@@ ) re_compile_fastmap_iter_isra_32 ( ( __int64 * ) @@a1@@ , ( _QWORD * ) ( @@v5@@ + Number ) , ( _QWORD * ) ( @@v5@@ + Number ) , @@v1@@ ) ; * ( _BYTE * ) ( @@a1@@ + Number ) |= Number ; return Number L ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
__int64 __fastcall eval3 ( unsigned __int8 @@a1@@ ) { __int64 @@v1@@ ; int @@v2@@ ; unsigned __int64 * @@v3@@ ; char * @@v4@@ ; unsigned __int64 ( __fastcall * @@v5@@ ) ( _QWORD * , _QWORD * , unsigned __int64 * ) ; @@v1@@ = eval4 ( @@a1@@ ) ; while ( Number ) { if ( nextarg ( String ) ) { @@v2@@ = Number ; @@v3@@ = ( unsigned __int64 * ) eval4 ( @@a1@@ ) ; if ( ! @@a1@@ ) goto LABEL_4 ; goto LABEL_7 ; } if ( ! nextarg ( ( char * ) String ) ) return @@v1@@ ; @@v2@@ = Number ; @@v3@@ = ( unsigned __int64 * ) eval4 ( @@a1@@ ) ; if ( ! @@a1@@ ) goto LABEL_4 ; LABEL_7 : if ( ! ( unsigned __int8 ) toarith ( @@v1@@ ) || ! ( unsigned __int8 ) toarith ( ( __int64 ) @@v3@@ ) ) { @@v4@@ = dcgettext ( Number L , String , Number ) ; error ( Number , Number , @@v4@@ ) ; } @@v5@@ = mpz_sub ; if ( ! @@v2@@ ) @@v5@@ = mpz_add ; @@v5@@ ( ( _QWORD * ) ( @@v1@@ + Number ) , ( _QWORD * ) ( @@v1@@ + Number ) , @@v3@@ + Number ) ; LABEL_4 : freev ( @@v3@@ ) ; } }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_2191F0 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2191D0 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2191E0 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
__int64 __fastcall postorder ( _QWORD * @@a1@@ , __int64 ( __fastcall * @@a2@@ ( ) ( void , bintreet0 ) ) ( __int64 , _QWORD * ) , __int64 @@a3@@ ) { _QWORD * @@v5@@ ; __int64 @@result@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; while ( Number ) { @@v5@@ = ( _QWORD * ) @@a1@@ [ Number ] ; if ( ! @@v5@@ ) { @@v5@@ = ( _QWORD * ) @@a1@@ [ Number ] ; if ( ! @@v5@@ ) break ; } LABEL_2 : @@a1@@ = @@v5@@ ; } for ( @@result@@ = @@a2@@ ( ) ( void , bintreet0 ) ( @@a3@@ , @@a1@@ ) ; ! ( _DWORD ) @@result@@ ; @@result@@ = @@a2@@ ( ) ( void , bintreet0 ) ( @@a3@@ , @@v7@@ ) ) { @@v7@@ = ( _QWORD * ) * @@a1@@ ; if ( ! * @@a1@@ ) break ; @@v5@@ = ( _QWORD * ) @@v7@@ [ Number ] ; @@v8@@ = @@v5@@ == @@a1@@ ; @@a1@@ = ( _QWORD * ) * @@a1@@ ; if ( @@v5@@ != Number L && ! @@v8@@ ) goto LABEL_2 ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_2061F0 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061D0 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061E0 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
void __fastcall print_stat ( __int64 @@a1@@ , __int64 @@a2@@ , char @@a3@@ , char * @@a4@@ , __int64 @@a5@@ ) { char * @@v5@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; int * @@v9@@ ; char * @@patha@@ ; __int64 @@v13@@ ; switch ( @@a3@@ ) { case String : filemodestring ( @@a5@@ , & modebuf_6774 ) ; byte_20B0FA = Number ; goto LABEL_3 ; case String : case String : case String : case String : case String : case String : case String : case String : case String : out_uint ( @@a1@@ , @@a2@@ ) ; return ; case String : out_file_context ( ( __int64 ) @@a4@@ , @@a1@@ , @@a2@@ ) ; return ; case String : case String : case String : case String : out_uint_x ( @@a1@@ , @@a2@@ ) ; return ; case String : file_type ( @@a5@@ ) ; goto LABEL_3 ; case String : setgrent ( ) ; getgrgid ( * ( _DWORD * ) ( @@a5@@ + Number ) ) ; goto LABEL_3 ; case String : @@v13@@ = @@a5@@ ; quote ( @@a4@@ ) ; out_string ( @@a1@@ , @@a2@@ ) ; if ( ( * ( _DWORD * ) ( @@v13@@ + Number ) & Number ) != Number ) return ; @@v6@@ = areadlink_with_size ( @@a4@@ ) ; if ( @@v6@@ ) { __printf_chk ( ) ; quote ( @@v6@@ ) ; LABEL_3 : out_string ( @@a1@@ , @@a2@@ ) ; } else { @@v7@@ = quote ( @@a4@@ ) ; @@v8@@ = dcgettext ( Number L , String , Number ) ; @@v9@@ = __errno_location ( ) ; error ( Number , * @@v9@@ , @@v8@@ , @@v7@@ ) ; } return ; case String : @@patha@@ = ( char * ) @@a5@@ ; setpwent ( ) ; getpwuid ( * ( ( _DWORD * ) @@patha@@ + Number ) ) ; goto LABEL_3 ; case String : case String : case String : out_int ( @@a1@@ , @@a2@@ ) ; return ; case String : strcpy ( ( char * ) ( @@a1@@ + @@a2@@ ) , String ) ; __printf_chk ( ) ; return ; case String : goto LABEL_3 ; case String : human_time ( * ( _QWORD * ) ( @@a5@@ + Number ) , * ( _QWORD * ) ( @@a5@@ + Number ) ) ; goto LABEL_3 ; case String : human_time ( * ( _QWORD * ) ( @@a5@@ + Number ) , * ( _QWORD * ) ( @@a5@@ + Number ) ) ; goto LABEL_3 ; case String : human_time ( * ( _QWORD * ) ( @@a5@@ + Number ) , * ( _QWORD * ) ( @@a5@@ + Number ) ) ; goto LABEL_3 ; default : @@v5@@ = stdout -> _IO_write_ptr ; if ( @@v5@@ >= stdout -> _IO_write_end ) { __overflow ( stdout , Number ) ; } else { stdout -> _IO_write_ptr = @@v5@@ + Number ; * @@v5@@ = Number ; } return ; } }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ , @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
_QWORD * __fastcall re_node_set_insert ( _QWORD * @@a1@@ , unsigned __int64 @@a2@@ ) { __int64 @@v3@@ ; unsigned __int64 * @@v4@@ ; _QWORD * @@result@@ ; unsigned __int64 * @@v6@@ ; unsigned __int64 @@v7@@ ; unsigned __int64 @@i@@ ; bool @@v9@@ ; if ( * @@a1@@ ) { @@v3@@ = @@a1@@ [ Number ] ; @@v4@@ = ( unsigned __int64 * ) @@a1@@ [ Number ] ; if ( ! @@v3@@ ) { * @@v4@@ = @@a2@@ ; ++ @@a1@@ [ Number ] ; return ( _QWORD * ) ( & dword_0 + Number ) ; } if ( * @@a1@@ != @@v3@@ ) { if ( @@a2@@ < * @@v4@@ ) goto LABEL_8 ; goto LABEL_12 ; } * @@a1@@ = Number * @@v3@@ ; @@v4@@ = ( unsigned __int64 * ) realloc ( @@v4@@ , Number * @@v3@@ ) ; if ( @@v4@@ ) { @@v9@@ = * @@v4@@ <= @@a2@@ ; @@a1@@ [ Number ] = @@v4@@ ; @@v3@@ = @@a1@@ [ Number ] ; if ( ! @@v9@@ ) { if ( ! @@v3@@ ) { LABEL_11 : * ( unsigned __int64 * ) ( ( char * ) @@v4@@ + @@v3@@ ) = @@a2@@ ; @@result@@ = ( _QWORD * ) ( & dword_0 + Number ) ; ++ @@a1@@ [ Number ] ; return @@result@@ ; } LABEL_8 : @@v6@@ = & @@v4@@ [ @@v3@@ ] ; do { @@v7@@ = * -- @@v6@@ ; @@v6@@ [ Number ] = @@v7@@ ; } while ( @@v6@@ != @@v4@@ ) ; @@v3@@ = Number L ; goto LABEL_11 ; } LABEL_12 : @@v3@@ *= Number L ; for ( @@i@@ = * ( unsigned __int64 * ) ( ( char * ) @@v4@@ + @@v3@@ - Number ) ; @@i@@ > @@a2@@ ; @@i@@ = * ( unsigned __int64 * ) ( ( char * ) @@v4@@ + @@v3@@ - Number ) ) { * ( unsigned __int64 * ) ( ( char * ) @@v4@@ + @@v3@@ ) = @@i@@ ; @@v3@@ -= Number L ; } goto LABEL_11 ; } @@result@@ = Number L ; } else { * @@a1@@ = Number L ; @@a1@@ [ Number ] = Number L ; @@result@@ = malloc ( Number ) ; @@a1@@ [ Number ] = @@result@@ ; if ( @@result@@ ) { * @@result@@ = @@a2@@ ; @@result@@ = ( _QWORD * ) ( & dword_0 + Number ) ; } else { @@a1@@ [ Number ] = Number L ; * @@a1@@ = Number L ; } } return @@result@@ ; }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
int fdatasync ( int @@fildes@@ ) { return fdatasync ( @@fildes@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void __fastcall re_string_destruct ( __int64 @@a1@@ ) { free ( * ( void * * ) ( @@a1@@ + Number ) ) ; free ( * ( void * * ) ( @@a1@@ + Number ) ) ; if ( * ( _BYTE * ) ( @@a1@@ + Number ) ) free ( * ( void * * ) ( @@a1@@ + Number ) ) ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
int clock_gettime ( clockid_t @@clock_id@@ , struct timespec * @@tp@@ ) { return clock_gettime ( @@clock_id@@ , @@tp@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
_QWORD * __fastcall add_field_list ( char * @@s@@ ) { __int64 @@v2@@ ; char * @@v3@@ ; int @@v4@@ ; unsigned int @@v5@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; _QWORD * @@result@@ ; _QWORD * @@v9@@ ; char * @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; __int64 @@v13@@ ; char * @@v14@@ ; __int64 @@v15@@ ; char * @@v16@@ ; while ( Number ) { @@v10@@ = Number L ; @@v11@@ = strpbrk ( @@s@@ , String ) ; if ( @@v11@@ ) { @@v10@@ = @@v11@@ + Number ; * @@v11@@ = Number ; } @@v4@@ = * @@s@@ ; if ( * @@s@@ == Number ) { if ( @@s@@ [ Number ] ) { @@v13@@ = quote ( @@s@@ , String , @@v12@@ ) ; @@v14@@ = dcgettext ( Number L , String , Number ) ; error ( Number , Number , @@v14@@ , @@v13@@ ) ; } @@v7@@ = Number L ; @@v5@@ = Number ; } else { if ( * @@s@@ < Number || ( char ) @@v4@@ > Number ) { @@v15@@ = quote ( @@s@@ , String , @@v12@@ ) ; @@v16@@ = dcgettext ( Number L , String , Number ) ; error ( Number , Number , @@v16@@ , @@v15@@ ) ; abort ( ) ; } if ( @@s@@ [ Number ] != Number ) { @@v2@@ = quote ( @@s@@ , String , @@v12@@ ) ; @@v3@@ = dcgettext ( Number L , String , Number ) ; error ( Number , Number , @@v3@@ , @@v2@@ ) ; @@v4@@ = * @@s@@ ; } @@v5@@ = @@v4@@ - Number ; @@v6@@ = string_to_join_field ( @@s@@ + Number ) ; @@v7@@ = @@v6@@ ; if ( @@v5@@ > Number ) __assert_fail ( String , String , Number , String ) ; if ( ! @@v5@@ && @@v6@@ ) __assert_fail ( String , String , Number , String ) ; } @@result@@ = ( _QWORD * ) xmalloc ( Number L ) ; @@v9@@ = outlist_end ; * ( _DWORD * ) @@result@@ = @@v5@@ ; @@result@@ [ Number ] = @@v7@@ ; @@result@@ [ Number ] = Number L ; outlist_end = @@result@@ ; @@v9@@ [ Number ] = @@result@@ ; if ( ! @@v10@@ ) break ; @@s@@ = @@v10@@ ; } return @@result@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall check_dst_limits_calc_pos ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ , unsigned __int64 @@a5@@ , __int64 @@a6@@ ) { __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; unsigned __int64 @@v8@@ ; int @@v9@@ ; __int64 @@result@@ ; @@v6@@ = * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@a2@@ ; @@v7@@ = * ( _QWORD * ) ( @@v6@@ + Number ) ; if ( @@v7@@ > @@a5@@ ) return Number ; @@v8@@ = * ( _QWORD * ) ( @@v6@@ + Number ) ; if ( @@v8@@ < @@a5@@ ) return Number L ; @@v9@@ = ( @@v7@@ == @@a5@@ ) | Number ; if ( @@v8@@ == @@a5@@ ) return check_dst_limits_calc_pos_1 ( @@a1@@ , @@v9@@ , @@a3@@ , @@a4@@ , @@a6@@ ) ; @@result@@ = Number L ; if ( @@v7@@ == @@a5@@ ) { @@v9@@ = Number ; return check_dst_limits_calc_pos_1 ( @@a1@@ , @@v9@@ , @@a3@@ , @@a4@@ , @@a6@@ ) ; } return @@result@@ ; }
void __fastcall match_ctx_clean ( _QWORD * @@a1@@ ) { unsigned __int64 @@v1@@ ; __int64 @@v2@@ ; unsigned __int64 @@v3@@ ; void * * @@v4@@ ; __int64 @@v5@@ ; if ( @@a1@@ [ Number ] ) { @@v1@@ = Number L ; do { @@v2@@ = * ( _QWORD * ) ( @@a1@@ [ Number ] + Number * @@v1@@ ) ; if ( * ( _QWORD * ) ( @@v2@@ + Number ) ) { @@v3@@ = Number L ; do { @@v4@@ = * ( void * * * ) ( * ( _QWORD * ) ( @@v2@@ + Number ) + Number * @@v3@@ ++ ) ; free ( @@v4@@ [ Number ] ) ; free ( @@v4@@ ) ; } while ( * ( _QWORD * ) ( @@v2@@ + Number ) > @@v3@@ ) ; } free ( * ( void * * ) ( @@v2@@ + Number ) ) ; @@v5@@ = * ( _QWORD * ) ( @@v2@@ + Number ) ; if ( @@v5@@ ) { free ( * ( void * * ) ( @@v5@@ + Number ) ) ; free ( * ( void * * ) ( @@v2@@ + Number ) ) ; } ++ @@v1@@ ; free ( ( void * ) @@v2@@ ) ; } while ( @@a1@@ [ Number ] > @@v1@@ ) ; } @@a1@@ [ Number ] = Number L ; @@a1@@ [ Number ] = Number L ; }
_QWORD * __fastcall readlinebuffer ( _QWORD * @@a1@@ , _IO_FILE * @@a2@@ ) { return readlinebuffer_delim ( @@a1@@ , @@a2@@ , Number ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
__int64 __fastcall re_node_set_insert_last ( _QWORD * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v3@@ ; void * @@v4@@ ; __int64 @@v6@@ ; @@v3@@ = @@a1@@ [ Number ] ; @@v4@@ = ( void * ) @@a1@@ [ Number ] ; if ( * @@a1@@ != @@v3@@ ) goto LABEL_2 ; @@v6@@ = @@v3@@ + Number ; * @@a1@@ = Number * @@v6@@ ; @@v4@@ = realloc ( @@v4@@ , Number * @@v6@@ ) ; if ( @@v4@@ ) { @@a1@@ [ Number ] = @@v4@@ ; @@v3@@ = @@a1@@ [ Number ] ; LABEL_2 : @@a1@@ [ Number ] = @@v3@@ + Number ; * ( ( _QWORD * ) @@v4@@ + @@v3@@ ) = @@a2@@ ; return Number L ; } return Number L ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
void __fastcall freebuffer ( __int64 @@a1@@ ) { free ( * ( void * * ) ( @@a1@@ + Number ) ) ; }
_QWORD * __fastcall randint_new ( __int64 @@a1@@ ) { _QWORD * @@result@@ ; @@result@@ = ( _QWORD * ) xmalloc ( Number L ) ; * @@result@@ = @@a1@@ ; @@result@@ [ Number ] = Number L ; @@result@@ [ Number ] = Number L ; return @@result@@ ; }
__int64 __fastcall calc_first ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { __int64 @@v2@@ ; __int64 @@result@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; if ( * ( ( _BYTE * ) @@a2@@ + Number ) == Number ) { @@v4@@ = @@a2@@ [ Number ] ; @@v5@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; @@v6@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; @@a2@@ [ Number ] = @@v5@@ ; @@a2@@ [ Number ] = @@v6@@ ; @@result@@ = Number L ; } else { @@a2@@ [ Number ] = @@a2@@ ; @@v2@@ = re_dfa_add_node ( ( __int64 ) @@a1@@ , @@a2@@ [ Number ] , @@a2@@ [ Number ] ) ; @@a2@@ [ Number ] = @@v2@@ ; if ( @@v2@@ == Number ) { @@result@@ = Number L ; } else { @@result@@ = Number L ; if ( * ( ( _BYTE * ) @@a2@@ + Number ) == Number ) * ( _DWORD * ) ( * @@a1@@ + Number * @@v2@@ + Number ) = ( ( @@a2@@ [ Number ] & Number ) << Number ) | * ( _DWORD * ) ( * @@a1@@ + Number * @@v2@@ + Number ) & Number ; } } return @@result@@ ; }
__int64 __fastcall duplicate_node ( __int64 * @@a1@@ , __int64 @@a2@@ , __int16 @@a3@@ ) { __int64 @@v3@@ ; __int64 @@result@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; unsigned int @@v9@@ ; unsigned int @@v10@@ ; @@v3@@ = Number * @@a2@@ ; @@result@@ = re_dfa_add_node ( ( __int64 ) @@a1@@ , * ( _QWORD * ) ( * @@a1@@ + Number * @@a2@@ ) , * ( _QWORD * ) ( * @@a1@@ + Number * @@a2@@ + Number ) ) ; if ( @@result@@ != Number ) { @@v7@@ = * @@a1@@ ; @@v8@@ = * @@a1@@ + Number * @@result@@ ; @@v9@@ = ( ( @@a3@@ & Number ) << Number ) | * ( _DWORD * ) ( @@v8@@ + Number ) & Number ; * ( _DWORD * ) ( @@v8@@ + Number ) = @@v9@@ ; @@v10@@ = @@v9@@ & Number | ( ( ( @@a3@@ & Number | ( unsigned __int16 ) ( * ( _DWORD * ) ( @@v7@@ + @@v3@@ + Number ) >> Number ) ) & Number ) << Number ) ; * ( _DWORD * ) ( @@v8@@ + Number ) = @@v10@@ ; * ( _BYTE * ) ( @@v8@@ + Number ) = BYTE2 ( @@v10@@ ) | Number ; * ( _QWORD * ) ( @@a1@@ [ Number ] + Number * @@result@@ ) = @@a2@@ ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 __fastcall randint_get_source ( __int64 @@a1@@ ) { return * ( _QWORD * ) @@a1@@ ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
char * __fastcall duplicate_tree ( _QWORD * * @@a1@@ , __int64 @@a2@@ ) { _QWORD * * @@v2@@ ; _QWORD * @@v3@@ ; __int64 * @@v4@@ ; char * @@result@@ ; _QWORD * * @@v6@@ ; _QWORD * @@v7@@ ; __int64 @@v8@@ [ Number ] ; @@v2@@ = @@a1@@ ; @@v3@@ = * @@a1@@ ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ = @@v8@@ ; while ( Number ) { @@result@@ = create_token_tree_isra_18 ( ( _QWORD * ) ( @@a2@@ + Number ) , ( int * ) ( @@a2@@ + Number ) , Number L , Number L , ( const __m128i * ) ( @@v2@@ + Number ) ) ; * @@v4@@ = ( __int64 ) @@result@@ ; if ( ! @@result@@ ) break ; * ( _QWORD * ) @@result@@ = @@v3@@ ; @@v3@@ = ( _QWORD * ) * @@v4@@ ; * ( _BYTE * ) ( * @@v4@@ + Number ) |= Number ; if ( @@v2@@ [ Number ] ) { @@v4@@ = @@v3@@ + Number ; @@v2@@ = ( _QWORD * * ) @@v2@@ [ Number ] ; } else { @@v6@@ = Number L ; while ( Number ) { @@v7@@ = @@v2@@ [ Number ] ; if ( @@v7@@ ) { if ( @@v7@@ != @@v6@@ ) break ; } @@v3@@ = ( _QWORD * ) * @@v3@@ ; @@v6@@ = @@v2@@ ; if ( ! * @@v2@@ ) return ( char * ) @@v8@@ [ Number ] ; @@v2@@ = ( _QWORD * * ) * @@v2@@ ; } @@v4@@ = @@v3@@ + Number ; @@v2@@ = ( _QWORD * * ) @@v2@@ [ Number ] ; } } return @@result@@ ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
__int64 __fastcall clean_state_log_if_needed ( _QWORD * @@a1@@ , unsigned __int64 @@a2@@ ) { unsigned __int64 @@v2@@ ; unsigned __int64 @@v3@@ ; __int64 @@result@@ ; @@v2@@ = @@a1@@ [ Number ] ; if ( @@a1@@ [ Number ] > @@a2@@ && ( ( @@v3@@ = @@a1@@ [ Number ] , @@v3@@ > @@a2@@ ) || @@v3@@ >= @@a1@@ [ Number ] ) || ( @@result@@ = extend_buffers ( ( __int64 ) @@a1@@ ) , ! ( _DWORD ) @@result@@ ) ) { if ( @@v2@@ < @@a2@@ ) { memset ( ( void * ) ( @@a1@@ [ Number ] + Number * @@v2@@ + Number ) , Number , Number * ( @@a2@@ - @@v2@@ ) ) ; @@a1@@ [ Number ] = @@a2@@ ; } @@result@@ = Number L ; } return @@result@@ ; }
unsigned __int64 __fastcall randint_genmax ( __int64 * @@a1@@ , unsigned __int64 @@a2@@ , __int64 a3 , __int64 @@a4@@ , __int64 @@a5@@ ) { unsigned __int64 @@v5@@ ; unsigned __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; unsigned __int64 @@v8@@ ; __int64 @@v9@@ ; char * @@v10@@ ; __int64 @@v11@@ ; __int64 @@v13@@ ; char @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; @@v5@@ = @@a2@@ + Number ; @@v6@@ = @@a1@@ [ Number ] ; @@v7@@ = @@a1@@ [ Number ] ; @@v15@@ = __readfsqword ( Number ) ; @@v13@@ = * @@a1@@ ; while ( Number ) { if ( @@v7@@ >= @@a2@@ ) { if ( @@v7@@ == @@a2@@ ) goto LABEL_11 ; } else { @@v8@@ = @@v7@@ ; @@v9@@ = Number L ; do { ++ @@v9@@ ; @@v8@@ = ( @@v8@@ << Number ) + Number ; } while ( @@a2@@ > @@v8@@ ) ; randread ( @@v13@@ , @@v14@@ , @@v9@@ , @@a4@@ , @@a5@@ ) ; @@v10@@ = @@v14@@ ; do { @@v11@@ = ( unsigned __int8 ) * @@v10@@ ; @@v7@@ = ( @@v7@@ << Number ) + Number ; ++ @@v10@@ ; @@v6@@ = @@v11@@ + ( @@v6@@ << Number ) ; } while ( @@a2@@ > @@v7@@ ) ; if ( @@v7@@ == @@a2@@ ) { LABEL_11 : @@a1@@ [ Number ] = Number L ; @@a1@@ [ Number ] = Number L ; return @@v6@@ ; } } if ( @@v6@@ <= @@v7@@ - ( @@v7@@ - @@a2@@ ) % @@v5@@ ) break ; @@v7@@ = ( @@v7@@ - @@a2@@ ) % @@v5@@ - Number ; @@v6@@ %= @@v5@@ ; } @@a1@@ [ Number ] = @@v6@@ / @@v5@@ ; @@a1@@ [ Number ] = ( @@v7@@ - @@a2@@ ) / @@v5@@ ; @@v6@@ %= @@v5@@ ; return @@v6@@ ; }
__int64 __fastcall xmemcoll ( void * @@a1@@ , size_t @@a2@@ , void * @@a3@@ , __int64 @@a4@@ ) { unsigned int @@v6@@ ; int @@v7@@ ; char * @@v8@@ ; char * @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; char * @@v12@@ ; @@v6@@ = memcoll ( @@a1@@ , @@a2@@ , @@a3@@ ) ; @@v7@@ = * __errno_location ( ) ; if ( @@v7@@ ) { @@v8@@ = dcgettext ( Number L , String , Number ) ; error ( Number , @@v7@@ , @@v8@@ ) ; @@v9@@ = dcgettext ( Number L , String , Number ) ; error ( Number , Number , @@v9@@ ) ; @@v10@@ = quotearg_n_style_mem ( Number L , Number L , @@a3@@ , @@a4@@ ) ; @@v11@@ = quotearg_n_style_mem ( Number L , Number L , @@a1@@ , @@a2@@ ) ; @@v12@@ = dcgettext ( Number L , String , Number ) ; error ( exit_failure , Number , @@v12@@ , @@v11@@ , @@v10@@ ) ; } return @@v6@@ ; }
__int64 __fastcall memcpy_lowcase ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v3@@ ; const __int32_t * * @@v4@@ ; if ( @@a3@@ ) { @@v3@@ = @@a3@@ - Number ; @@v4@@ = __ctype_tolower_loc ( ) ; do { * ( _BYTE * ) ( @@a1@@ + @@v3@@ ) = ( * @@v4@@ ) [ * ( unsigned __int8 * ) ( @@a2@@ + @@v3@@ ) ] ; -- @@v3@@ ; } while ( @@v3@@ != Number ) ; } return @@a1@@ ; }
__int64 __fastcall check_halt_state_context_isra_23 ( __int64 @@a1@@ , __int64 @@a2@@ , _QWORD * @@a3@@ , unsigned __int64 @@a4@@ ) { char @@v6@@ ; __int64 @@v7@@ ; int @@v8@@ ; int @@v9@@ ; int @@v10@@ ; __int64 @@result@@ ; __int64 @@v12@@ ; int @@v13@@ ; @@v6@@ = re_string_context_at ( @@a1@@ , @@a4@@ , * ( _DWORD * ) ( @@a1@@ + Number ) ) ; if ( @@a2@@ ) { @@v7@@ = Number L ; @@v8@@ = @@v6@@ & Number ; @@v9@@ = @@v6@@ & Number ; @@v10@@ = @@v6@@ & Number ; while ( Number ) { @@result@@ = * ( _QWORD * ) ( * @@a3@@ + Number * @@v7@@ ) ; @@v12@@ = * * ( _QWORD * * ) ( @@a1@@ + Number ) + Number * @@result@@ ; @@v13@@ = * ( _DWORD * ) ( @@v12@@ + Number ) >> Number ; if ( * ( _BYTE * ) ( @@v12@@ + Number ) != Number ) goto LABEL_3 ; if ( ( @@v13@@ & Number ) == Number ) return @@result@@ ; if ( ( @@v13@@ & Number ) != Number ) break ; if ( ( @@v13@@ & Number ) == Number ) goto LABEL_9 ; if ( @@v10@@ ) goto LABEL_3 ; if ( ( @@v13@@ & Number ) != Number ) { LABEL_10 : if ( ! @@v9@@ ) goto LABEL_3 ; } LABEL_11 : if ( ( @@v13@@ & Number ) == Number || @@v8@@ ) return @@result@@ ; LABEL_3 : if ( ++ @@v7@@ == @@a2@@ ) return Number L ; } if ( ! @@v10@@ || ( @@v13@@ & Number ) != Number ) goto LABEL_3 ; LABEL_9 : if ( ( @@v13@@ & Number ) != Number ) goto LABEL_10 ; goto LABEL_11 ; } return Number L ; }
__int64 __fastcall re_node_set_compare_part_2 ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; __int64 @@result@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@result@@ = Number L ; if ( @@v2@@ == * ( _QWORD * ) ( @@a2@@ + Number ) ) { @@v4@@ = Number * @@v2@@ - Number ; do { if ( ( unsigned __int64 ) -- @@v2@@ > Number ) return Number L ; @@v5@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@v4@@ ) ; @@v6@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + @@v4@@ ) ; @@v4@@ -= Number L ; } while ( @@v5@@ == @@v6@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
__int64 __fastcall memcasecmp ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { const __int32_t * * @@v4@@ ; __int64 @@v5@@ ; const __int32_t * @@v6@@ ; __int64 @@result@@ ; if ( ! @@a3@@ ) return Number L ; @@v4@@ = __ctype_toupper_loc ( ) ; @@v5@@ = Number L ; @@v6@@ = * @@v4@@ ; do { @@result@@ = ( unsigned int ) ( @@v6@@ [ * ( unsigned __int8 * ) ( @@a1@@ + @@v5@@ ) ] - @@v6@@ [ * ( unsigned __int8 * ) ( @@a2@@ + @@v5@@ ) ] ) ; if ( ( _DWORD ) @@result@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != @@a3@@ ) ; return @@result@@ ; }
__int64 __fastcall build_equiv_class_isra_29 ( __int64 @@a1@@ , const char * @@a2@@ ) { if ( strlen ( @@a2@@ ) != Number ) return Number L ; * ( _QWORD * ) ( @@a1@@ + ( ( ( unsigned __int64 ) * ( unsigned __int8 * ) @@a2@@ >> Number ) & Number ) ) |= Number L << ( * @@a2@@ & Number ) ; return Number L ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
void __fastcall re_node_set_remove_at_isra_4_part_5 ( unsigned __int64 * @@a1@@ , __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { __int64 @@v3@@ ; if ( @@a3@@ < * @@a1@@ ) { @@v3@@ = * @@a2@@ ; do { ++ @@a3@@ ; * ( _QWORD * ) ( @@v3@@ + Number * @@a3@@ - Number ) = * ( _QWORD * ) ( @@v3@@ + Number * @@a3@@ ) ; } while ( @@a3@@ < * @@a1@@ ) ; } }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
__int64 __fastcall calc_next ( __int64 a1 , __int64 @@a2@@ ) { char @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@result@@ ; __int64 @@v6@@ ; @@v2@@ = * ( _BYTE * ) ( @@a2@@ + Number ) ; @@v3@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( @@v2@@ == Number ) { * ( _QWORD * ) ( @@v3@@ + Number ) = @@a2@@ ; @@result@@ = Number L ; } else if ( @@v2@@ == Number ) { @@v6@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; * ( _QWORD * ) ( @@v3@@ + Number ) = * ( _QWORD * ) ( @@v6@@ + Number ) ; * ( _QWORD * ) ( @@v6@@ + Number ) = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@result@@ = Number L ; } else { if ( @@v3@@ ) * ( _QWORD * ) ( @@v3@@ + Number ) = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@v4@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( @@v4@@ ) * ( _QWORD * ) ( @@v4@@ + Number ) = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@result@@ = Number L ; } return @@result@@ ; }
char * __fastcall parse_reg_exp ( __int64 * @@a1@@ , __int64 * @@a2@@ , __m128i * @@a3@@ , __int64 @@a4@@ , void * @@a5@@ , _DWORD * @@a6@@ ) { __int64 @@v9@@ ; char * @@v10@@ ; char * @@v11@@ ; char * @@v12@@ ; __m128i @@v15@@ ; unsigned __int64 @@v16@@ ; @@v9@@ = * @@a2@@ ; @@v16@@ = __readfsqword ( Number ) ; @@v10@@ = parse_branch ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; @@v11@@ = @@v10@@ ; if ( * @@a6@@ && ! @@v10@@ ) return Number L ; while ( @@a3@@ -> m128i_i8 [ Number ] == Number ) { @@a1@@ [ Number ] += ( int ) peek_token ( ( unsigned __int8 * ) @@a3@@ , @@a1@@ , @@a4@@ | Number ) ; if ( ( @@a3@@ -> m128i_i8 [ Number ] & Number ) == Number || @@a3@@ -> m128i_i8 [ Number ] == Number && @@a5@@ ) { @@v12@@ = Number L ; } else { @@v12@@ = parse_branch ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( * @@a6@@ && ! @@v12@@ ) return Number L ; } @@v15@@ . m128i_i8 [ Number ] = Number ; @@v11@@ = create_token_tree_isra_18 ( ( _QWORD * ) ( @@v9@@ + Number ) , ( int * ) ( @@v9@@ + Number ) , @@v11@@ , @@v12@@ , & @@v15@@ ) ; if ( ! @@v11@@ ) { * @@a6@@ = Number ; return @@v11@@ ; } } return @@v11@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
FILE * __fastcall fopen_safer ( const char * @@a1@@ , const char * @@a2@@ ) { FILE * @@v2@@ ; FILE * @@v3@@ ; unsigned int @@v4@@ ; int @@v6@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; int * @@v10@@ ; int @@v11@@ ; int * @@v12@@ ; @@v2@@ = fopen ( @@a1@@ , @@a2@@ ) ; @@v3@@ = @@v2@@ ; if ( @@v2@@ ) { @@v4@@ = fileno ( @@v2@@ ) ; if ( @@v4@@ <= Number ) { @@v6@@ = dup_safer ( @@v4@@ ) ; if ( @@v6@@ < Number ) { @@v10@@ = __errno_location ( ) ; @@v11@@ = * @@v10@@ ; @@v12@@ = @@v10@@ ; fclose ( @@v3@@ ) ; @@v3@@ = Number L ; * @@v12@@ = @@v11@@ ; } else if ( fclose ( @@v3@@ ) || ( @@v3@@ = fdopen ( @@v6@@ , @@a2@@ ) ) == Number L ) { @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; close ( @@v6@@ ) ; * @@v9@@ = @@v8@@ ; @@v3@@ = Number L ; } } } return @@v3@@ ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall lower_subexps ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; char * @@v5@@ ; char * @@v6@@ ; unsigned int @@v7@@ ; unsigned __int64 @@v8@@ ; @@v2@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@v8@@ = __readfsqword ( Number ) ; @@v7@@ = Number ; if ( @@v2@@ ) { if ( * ( _BYTE * ) ( @@v2@@ + Number ) == Number ) { @@v6@@ = lower_subexp ( & @@v7@@ , @@a1@@ , @@v2@@ ) ; * ( _QWORD * ) ( @@a2@@ + Number ) = @@v6@@ ; if ( @@v6@@ ) * ( _QWORD * ) @@v6@@ = @@a2@@ ; } } @@v3@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( @@v3@@ ) { if ( * ( _BYTE * ) ( @@v3@@ + Number ) == Number ) { @@v5@@ = lower_subexp ( & @@v7@@ , @@a1@@ , @@v3@@ ) ; * ( _QWORD * ) ( @@a2@@ + Number ) = @@v5@@ ; if ( @@v5@@ ) * ( _QWORD * ) @@v5@@ = @@a2@@ ; } } return @@v7@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
void __fastcall rpl_regfree ( __int64 @@a1@@ ) { void * @@v2@@ ; void * @@v3@@ ; void * @@v4@@ ; @@v2@@ = * ( void * * ) @@a1@@ ; if ( @@v2@@ ) free_dfa_content ( @@v2@@ ) ; @@v3@@ = * ( void * * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) @@a1@@ = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; free ( @@v3@@ ) ; @@v4@@ = * ( void * * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; free ( @@v4@@ ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
wint_t towupper ( wint_t @@wc@@ ) { return towupper ( @@wc@@ ) ; }
__int64 __fastcall check_subexp_matching_top_isra_21 ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , _QWORD * @@a3@@ , __int64 @@a4@@ ) { _QWORD * @@v4@@ ; unsigned __int64 @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; __int64 @@v12@@ ; _QWORD * @@v13@@ ; _QWORD * @@v14@@ ; bool @@v15@@ ; _QWORD * @@v17@@ ; __int64 @@v18@@ ; __int64 @@v19@@ ; _QWORD * @@v20@@ ; __int64 @@v21@@ ; __int64 @@v22@@ ; @@v4@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; if ( ! * @@a2@@ ) return Number L ; @@v7@@ = Number L ; while ( Number ) { while ( Number ) { @@v8@@ = * ( _QWORD * ) ( * @@a3@@ + Number * @@v7@@ ) ; @@v9@@ = * @@v4@@ + Number * @@v8@@ ; if ( * ( _BYTE * ) ( @@v9@@ + Number ) == Number ) { @@v10@@ = * ( _QWORD * ) @@v9@@ ; if ( @@v10@@ <= Number ) { @@v11@@ = @@v4@@ [ Number ] ; if ( _bittest64 ( & @@v11@@ , @@v10@@ ) ) break ; } } if ( ++ @@v7@@ >= * @@a2@@ ) return Number L ; } @@v12@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v13@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; if ( @@v12@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ) break ; LABEL_8 : @@v20@@ = @@v13@@ ; @@v18@@ = @@v12@@ ; @@v22@@ = @@a4@@ ; @@v14@@ = calloc ( Number , Number ) ; @@v20@@ [ @@v18@@ ] = @@v14@@ ; if ( ! @@v14@@ ) return Number L ; ++ @@v7@@ ; @@a4@@ = @@v22@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v18@@ + Number ; @@v15@@ = @@v7@@ < * @@a2@@ ; @@v14@@ [ Number ] = @@v8@@ ; * @@v14@@ = @@v22@@ ; if ( ! @@v15@@ ) return Number L ; } @@v19@@ = @@a4@@ ; @@v21@@ = Number * @@v12@@ ; @@v17@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number * @@v12@@ ) ; @@v13@@ = @@v17@@ ; @@a4@@ = @@v19@@ ; if ( @@v17@@ ) { * ( _QWORD * ) ( @@a1@@ + Number ) = @@v17@@ ; @@v12@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v21@@ ; goto LABEL_8 ; } return Number L ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall rpl_re_match_2 ( __int64 @@a1@@ , const void * @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ , unsigned __int64 @@a6@@ , unsigned __int64 * @@a7@@ , __int64 @@a8@@ ) { return re_search_2_stub ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ , Number L , @@a7@@ , @@a8@@ , Number ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall rpl_re_set_registers ( __int64 @@a1@@ , _QWORD * @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ ) { __int64 @@result@@ ; if ( @@a3@@ ) { @@result@@ = * ( _BYTE * ) ( @@a1@@ + Number ) & Number | Number ; * ( _BYTE * ) ( @@a1@@ + Number ) = * ( _BYTE * ) ( @@a1@@ + Number ) & Number | Number ; * @@a2@@ = @@a3@@ ; @@a2@@ [ Number ] = @@a4@@ ; @@a2@@ [ Number ] = @@a5@@ ; } else { * ( _BYTE * ) ( @@a1@@ + Number ) &= Number ; * @@a2@@ = Number L ; @@a2@@ [ Number ] = Number L ; @@a2@@ [ Number ] = Number L ; } return @@result@@ ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
unsigned __int64 __fastcall mpz_add ( _QWORD * @@a1@@ , _QWORD * @@a2@@ , unsigned __int64 * @@a3@@ ) { unsigned __int64 @@v3@@ ; __int64 @@v4@@ ; unsigned __int64 @@result@@ ; @@v3@@ = * @@a3@@ ; @@v4@@ = * @@a2@@ + * @@a3@@ ; @@result@@ = @@v3@@ >> Number ; if ( * @@a2@@ > @@v4@@ != ( _BYTE ) @@result@@ ) integer_overflow ( Number ) ; * @@a1@@ = @@v4@@ ; return @@result@@ ; }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
char * __fastcall parse_branch ( __int64 * @@a1@@ , __int64 * @@a2@@ , __m128i * @@a3@@ , __int64 @@a4@@ , void * @@a5@@ , _DWORD * @@a6@@ ) { __int64 @@v10@@ ; char * @@v11@@ ; char * @@v12@@ ; __int64 @@v14@@ ; __m128i @@v15@@ ; unsigned __int64 @@v16@@ ; @@v16@@ = __readfsqword ( Number ) ; @@v14@@ = * @@a2@@ ; @@v10@@ = parse_expression ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; @@v11@@ = ( char * ) @@v10@@ ; if ( * @@a6@@ && ! @@v10@@ ) return Number L ; while ( ( @@a3@@ -> m128i_i8 [ Number ] & Number ) != Number && ( @@a3@@ -> m128i_i8 [ Number ] != Number || ! @@a5@@ ) ) { @@v12@@ = ( char * ) parse_expression ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( * @@a6@@ && ! @@v12@@ ) return Number L ; if ( @@v11@@ && @@v12@@ ) { @@v15@@ . m128i_i8 [ Number ] = Number ; @@v11@@ = create_token_tree_isra_18 ( ( _QWORD * ) ( @@v14@@ + Number ) , ( int * ) ( @@v14@@ + Number ) , @@v11@@ , @@v12@@ , & @@v15@@ ) ; if ( ! @@v11@@ ) { * @@a6@@ = Number ; return @@v11@@ ; } } else if ( ! @@v11@@ ) { @@v11@@ = @@v12@@ ; } } return @@v11@@ ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
__int64 __fastcall eval5 ( unsigned __int8 @@a1@@ ) { unsigned __int8 @@v1@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; void * @@v5@@ ; void * @@v6@@ ; @@v1@@ = @@a1@@ ; @@v3@@ = eval6 ( @@a1@@ ) ; while ( nextarg ( String ) ) { @@v4@@ = eval6 ( @@a1@@ ) ; @@v5@@ = ( void * ) @@v4@@ ; if ( @@v1@@ ) { @@v6@@ = ( void * ) @@v3@@ ; @@v3@@ = docolon ( @@v3@@ , @@v4@@ ) ; freev ( @@v6@@ ) ; } freev ( @@v5@@ ) ; } return @@v3@@ ; }
int isatty ( int @@fd@@ ) { return isatty ( @@fd@@ ) ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
size_t __fastcall rpl_regerror ( unsigned int @@a1@@ , __int64 a2 , char * @@a3@@ , size_t @@a4@@ ) { char * @@v6@@ ; size_t @@v7@@ ; size_t @@v8@@ ; size_t @@v9@@ ; if ( @@a1@@ > Number ) abort ( ) ; @@v6@@ = dcgettext ( Number L , & _re_error_msgid [ _re_error_msgid_idx [ @@a1@@ ] ] , Number ) ; @@v7@@ = strlen ( @@v6@@ ) ; @@v8@@ = @@v7@@ + Number ; if ( @@a4@@ ) { @@v9@@ = @@v7@@ + Number ; if ( @@v8@@ > @@a4@@ ) { @@v9@@ = @@a4@@ - Number ; @@a3@@ [ @@a4@@ - Number ] = Number ; } memcpy ( @@a3@@ , @@v6@@ , @@v9@@ ) ; } return @@v8@@ ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
_QWORD * __fastcall eval ( unsigned __int8 @@a1@@ ) { _QWORD * @@v2@@ ; unsigned __int8 @@v3@@ ; _QWORD * @@v4@@ ; void * @@v5@@ ; __int64 @@v6@@ ; @@v2@@ = eval1 ( @@a1@@ ) ; LABEL_2 : while ( nextarg ( String ) ) { while ( Number ) { @@v3@@ = Number ; if ( @@a1@@ ) @@v3@@ = null ( ( __int64 ) @@v2@@ ) ; @@v4@@ = eval1 ( @@v3@@ ) ; if ( ! null ( ( __int64 ) @@v2@@ ) ) break ; @@v5@@ = @@v2@@ ; @@v2@@ = @@v4@@ ; freev ( @@v5@@ ) ; if ( ! null ( ( __int64 ) @@v4@@ ) ) goto LABEL_2 ; freev ( @@v4@@ ) ; @@v6@@ = xmalloc ( Number L ) ; * ( _DWORD * ) @@v6@@ = Number ; * ( _QWORD * ) ( @@v6@@ + Number ) = Number L ; @@v2@@ = ( _QWORD * ) @@v6@@ ; if ( ! nextarg ( String ) ) return @@v2@@ ; } freev ( @@v4@@ ) ; } return @@v2@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
time_t time ( time_t * @@timer@@ ) { return time ( @@timer@@ ) ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall rpl_regexec ( __int64 @@a1@@ , const char * @@a2@@ , unsigned __int64 @@a3@@ , __int64 * @@a4@@ , int @@a5@@ ) { size_t @@v8@@ ; unsigned __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; int @@v11@@ ; if ( ( @@a5@@ & Number ) == Number ) { if ( ( @@a5@@ & Number ) != Number ) { @@v9@@ = * @@a4@@ ; @@v10@@ = @@a4@@ [ Number ] ; if ( ( * ( _BYTE * ) ( @@a1@@ + Number ) & Number ) != Number ) goto LABEL_4 ; } else { @@v8@@ = strlen ( @@a2@@ ) ; @@v9@@ = Number L ; @@v10@@ = @@v8@@ ; if ( ( * ( _BYTE * ) ( @@a1@@ + Number ) & Number ) != Number ) { LABEL_4 : @@v11@@ = re_search_internal ( @@a1@@ , ( __int64 ) @@a2@@ , @@v10@@ , @@v9@@ , @@v10@@ , @@v10@@ , Number L , Number L , @@a5@@ ) ; return @@v11@@ != Number ; } } @@v11@@ = re_search_internal ( @@a1@@ , ( __int64 ) @@a2@@ , @@v10@@ , @@v9@@ , @@v10@@ , @@v10@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; return @@v11@@ != Number ; } return Number L ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
int __fxstat ( int @@ver@@ , int @@fildes@@ , struct stat * @@stat_buf@@ ) { return _fxstat ( @@ver@@ , @@fildes@@ , @@stat_buf@@ ) ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall umaxtostr ( unsigned __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; @@v2@@ = @@a2@@ + Number ; * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; do { * ( _BYTE * ) -- @@v2@@ = @@a1@@ % Number + Number ; @@a1@@ /= Number ; } while ( @@a1@@ ) ; return @@v2@@ ; }
__int64 __fastcall direct_mode ( int @@a1@@ , char @@a2@@ , int @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { __int64 @@result@@ ; int @@v7@@ ; int @@v8@@ ; int @@v9@@ ; int @@v10@@ ; @@result@@ = rpl_fcntl ( @@a1@@ , Number , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( ( int ) @@result@@ > Number ) { @@v9@@ = @@result@@ ; @@v10@@ = @@result@@ ; BYTE1 ( @@v9@@ ) = BYTE1 ( @@result@@ ) | Number ; BYTE1 ( @@v10@@ ) = BYTE1 ( @@result@@ ) & Number ; if ( @@a2@@ ) @@v10@@ = @@v9@@ ; if ( @@v10@@ != ( _DWORD ) @@result@@ ) @@result@@ = rpl_fcntl ( @@a1@@ , Number , @@v10@@ , @@v9@@ , @@v7@@ , @@v8@@ ) ; } return @@result@@ ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
__int64 __fastcall randint_all_free ( void * @@ptr@@ ) { unsigned int @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = randread_free ( * ( _QWORD * ) @@ptr@@ ) ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; randint_free ( @@ptr@@ ) ; @@result@@ = @@v1@@ ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
int rename ( const char * @@old@@ , const char * @@a2@@ ) { return rename ( @@old@@ , @@a2@@ ) ; }
__int64 __fastcall argmatch_to_argument ( void * @@s1@@ , __int64 * @@a2@@ , char * @@a3@@ , size_t @@a4@@ ) { __int64 @@v4@@ ; __int64 * @@v7@@ ; @@v4@@ = * @@a2@@ ; if ( * @@a2@@ ) { @@v7@@ = @@a2@@ + Number ; do { if ( ! memcmp ( @@s1@@ , @@a3@@ , @@a4@@ ) ) break ; @@v4@@ = * @@v7@@ ; @@a3@@ += @@a4@@ ; ++ @@v7@@ ; } while ( @@v4@@ ) ; } return @@v4@@ ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
int __fastcall randread_free ( FILE * * @@a1@@ ) { FILE * @@v1@@ ; int @@result@@ ; @@v1@@ = * @@a1@@ ; free ( @@a1@@ ) ; if ( @@v1@@ ) @@result@@ = fclose ( @@v1@@ ) ; else @@result@@ = Number ; return @@result@@ ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
_BYTE * __fastcall quote_n ( int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number , @@a2@@ ) ; }
_BYTE * __fastcall quote ( wchar_t * @@a1@@ ) { return quotearg_n_style ( Number , Number , @@a1@@ ) ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
__int64 * randint_all_new ( ) { __int64 @@v0@@ ; __int64 @@v1@@ ; __int64 * @@result@@ ; @@v0@@ = randread_new ( ) ; if ( ! @@v0@@ ) return Number L ; @@v1@@ = @@v0@@ ; @@result@@ = ( __int64 * ) xmalloc ( Number L ) ; * @@result@@ = @@v1@@ ; @@result@@ [ Number ] = Number L ; @@result@@ [ Number ] = Number L ; return @@result@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
void randint_free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
unsigned __int64 __fastcall isaac_seed ( __m128i * @@a1@@ ) { __int64 * @@v2@@ ; __m128i @@v3@@ ; unsigned __int64 @@result@@ ; __int64 @@v5@@ ; unsigned __int64 @@v6@@ ; @@v2@@ = & @@a1@@ -> m128i_i64 [ Number ] ; @@v6@@ = __readfsqword ( Number ) ; * ( @@v2@@ - Number ) = Number L ; @@v2@@ [ Number ] = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) & iv_3359 ) ; memset ( ( void * ) ( ( unsigned __int64 ) @@v2@@ & Number ) , Number , Number L * ( ( ( unsigned int ) @@a1@@ - ( ( unsigned int ) @@v2@@ & Number ) + Number ) >> Number ) ) ; @@a1@@ [ Number ] = @@v3@@ ; @@a1@@ [ Number ] . m128i_i64 [ Number ] = Number L ; @@a1@@ [ Number ] . m128i_i32 [ Number ] = Number ; @@a1@@ [ Number ] = _mm_load_si128 ( ( const __m128i * ) & xmmword_8E70 ) ; LODWORD ( @@v5@@ ) = getpid ( ) ; isaac_seed_data ( ( unsigned int * ) @@a1@@ , ( __int64 ) & @@v5@@ , Number ) ; LODWORD ( @@v5@@ ) = getppid ( ) ; isaac_seed_data ( ( unsigned int * ) @@a1@@ , ( __int64 ) & @@v5@@ , Number ) ; LODWORD ( @@v5@@ ) = getuid ( ) ; isaac_seed_data ( ( unsigned int * ) @@a1@@ , ( __int64 ) & @@v5@@ , Number ) ; LODWORD ( @@v5@@ ) = getgid ( ) ; isaac_seed_data ( ( unsigned int * ) @@a1@@ , ( __int64 ) & @@v5@@ , Number ) ; @@v5@@ = gethrxtime ( ) ; isaac_seed_data ( ( unsigned int * ) @@a1@@ , ( __int64 ) & @@v5@@ , Number ) ; isaac_mix ( ( unsigned int * ) @@a1@@ , @@a1@@ ) ; isaac_mix ( ( unsigned int * ) @@a1@@ , @@a1@@ ) ; @@result@@ = __readfsqword ( Number ) ^ @@v6@@ ; @@a1@@ [ Number ] . m128i_i32 [ Number ] = Number ; return @@result@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 __fastcall mark_opt_subexp ( __int64 @@a1@@ , __int64 @@a2@@ ) { if ( * ( _BYTE * ) ( @@a2@@ + Number ) != Number || @@a1@@ != * ( _QWORD * ) ( @@a2@@ + Number ) ) { return Number L ; } * ( _BYTE * ) ( @@a2@@ + Number ) |= Number ; return Number L ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
void __fastcall __noreturn randread_error ( __int64 @@a1@@ ) { __int64 @@v1@@ ; int * @@v2@@ ; const char * @@v3@@ ; char * @@v4@@ ; if ( @@a1@@ ) { @@v1@@ = quotearg_colon ( @@a1@@ ) ; @@v2@@ = __errno_location ( ) ; @@v3@@ = String ; if ( * @@v2@@ ) @@v3@@ = String ; @@v4@@ = dcgettext ( Number L , @@v3@@ , Number ) ; error ( exit_failure , * @@v2@@ , @@v4@@ , @@v1@@ ) ; } abort ( ) ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
char * nl_langinfo ( nl_item @@item@@ ) { return nl_langinfo ( @@item@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
__int64 __fastcall preorder ( _QWORD * @@a1@@ , __int64 ( __fastcall * @@a2@@ ( ) ( void , bintreet0 ) ) ( __int64 , _QWORD * ) , __int64 @@a3@@ ) { _QWORD * @@v4@@ ; __int64 @@result@@ ; _QWORD * @@v6@@ ; _QWORD * @@v7@@ ; @@v4@@ = @@a1@@ ; for ( @@result@@ = @@a2@@ ( ) ( void , bintreet0 ) ( @@a3@@ , @@a1@@ ) ; ! ( _DWORD ) @@result@@ ; @@result@@ = @@a2@@ ( ) ( void , bintreet0 ) ( @@a3@@ , @@v6@@ ) ) { @@v6@@ = ( _QWORD * ) @@v4@@ [ Number ] ; @@v7@@ = Number L ; if ( ! @@v6@@ ) { while ( Number ) { @@v6@@ = ( _QWORD * ) @@v4@@ [ Number ] ; if ( @@v6@@ != @@v7@@ ) { if ( @@v6@@ ) break ; } @@v7@@ = @@v4@@ ; if ( ! * @@v4@@ ) return @@result@@ ; @@v4@@ = ( _QWORD * ) * @@v4@@ ; } } @@v4@@ = @@v6@@ ; } return @@result@@ ; }
__int64 __fastcall isaac_seed_data ( unsigned int * @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { __int64 @@v4@@ ; unsigned __int64 @@v6@@ ; unsigned __int64 @@i@@ ; __int64 @@result@@ ; @@v4@@ = @@a1@@ [ Number ] ; @@v6@@ = Number - @@v4@@ ; if ( Number - @@v4@@ >= @@a3@@ ) { @@v6@@ = @@a1@@ [ Number ] ; } else if ( @@v6@@ ) { do { for ( @@i@@ = Number L ; @@i@@ < @@v6@@ ; ++ @@i@@ ) { * ( ( _BYTE * ) @@a1@@ + @@v4@@ + @@i@@ ) ^= * ( _BYTE * ) ( @@a2@@ + @@i@@ ) ; } @@a3@@ -= @@v6@@ ; isaac_mix ( @@a1@@ , @@a1@@ ) ; @@a2@@ += @@v6@@ ; @@v4@@ = Number L ; @@a1@@ [ Number ] = Number ; @@v6@@ = Number L ; } while ( @@a3@@ > Number ) ; @@v6@@ = Number L ; } else { isaac_mix ( @@a1@@ , @@a1@@ ) ; @@a1@@ [ Number ] = Number ; } @@result@@ = Number L ; do { * ( ( _BYTE * ) @@a1@@ + @@v6@@ + @@result@@ ) ^= * ( _BYTE * ) ( @@a2@@ + @@result@@ ) ; ++ @@result@@ ; } while ( @@result@@ != @@a3@@ ) ; @@a1@@ [ Number ] = @@result@@ ; return @@result@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; FILE * @@v11@@ ; char * @@v12@@ ; FILE * @@v13@@ ; char * @@v14@@ ; char * @@v15@@ ; FILE * @@v16@@ ; char * @@v17@@ ; char * @@v18@@ ; char * @@v19@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = stdout ; @@v10@@ = dcgettext ( Number L , String String String String String String String String String String , Number ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; @@v11@@ = stdout ; @@v12@@ = dcgettext ( Number L , String String String String , Number ) ; fputs_unlocked ( @@v12@@ , @@v11@@ ) ; @@v13@@ = stdout ; @@v14@@ = dcgettext ( Number L , String String String String String String , Number ) ; fputs_unlocked ( @@v14@@ , @@v13@@ ) ; @@v15@@ = dcgettext ( Number L , String String String String , Number ) ; __printf_chk ( ) ; last_component ( program_name , @@v15@@ ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v16@@ = stdout ; @@v17@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v17@@ , @@v16@@ ) ; @@v18@@ = Number L ; @@v19@@ = setlocale ( Number , Number L ) ; if ( @@v19@@ ) { @@v18@@ = String ; if ( strncmp ( @@v19@@ , String , Number ) ) { last_component ( program_name , String ) ; @@v18@@ = dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name , @@v18@@ ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
__syscall_slong_t gethrxtime ( ) { struct timespec @@v1@@ ; unsigned __int64 @@v2@@ ; @@v2@@ = __readfsqword ( Number ) ; if ( clock_gettime ( Number , & @@v1@@ ) ) gettime ( & @@v1@@ ) ; return @@v1@@ . tv_nsec + Number * @@v1@@ . tv_sec ; }
__int64 __fastcall xfprintf ( FILE * @@a1@@ ) { return xvfprintf ( @@a1@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
__int64 __fastcall register_state ( _QWORD * @@a1@@ , _QWORD * @@a2@@ , __int64 @@a3@@ ) { __int64 @@v4@@ ; void * @@v6@@ ; __int64 @@v7@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; _QWORD * @@v11@@ ; __int64 @@v12@@ ; @@v4@@ = @@a2@@ [ Number ] ; * @@a2@@ = @@a3@@ ; @@a2@@ [ Number ] = Number L ; @@a2@@ [ Number ] = @@v4@@ ; @@v6@@ = malloc ( Number * @@v4@@ ) ; @@a2@@ [ Number ] = @@v6@@ ; if ( ! @@v6@@ ) return Number L ; if ( @@v4@@ ) { @@v7@@ = Number L ; while ( ( * ( _BYTE * ) ( * @@a1@@ + Number L * * ( _QWORD * ) ( @@a2@@ [ Number ] + Number * @@v7@@ ) + Number ) & Number ) != Number || ( unsigned __int8 ) re_node_set_insert_last ( @@a2@@ + Number , * ( _QWORD * ) ( @@a2@@ [ Number ] + Number * @@v7@@ ) ) ) { if ( @@a2@@ [ Number ] <= ( unsigned __int64 ) ++ @@v7@@ ) goto LABEL_8 ; } return Number L ; } LABEL_8 : @@v9@@ = @@a1@@ [ Number ] + Number * ( @@a1@@ [ Number ] & @@a3@@ ) ; @@v10@@ = * ( _QWORD * ) @@v9@@ ; @@v11@@ = * ( _QWORD * * ) ( @@v9@@ + Number ) ; @@v12@@ = * ( _QWORD * ) @@v9@@ + Number L ; if ( * ( _QWORD * ) ( @@v9@@ + Number ) <= * ( _QWORD * ) @@v9@@ ) { @@v11@@ = realloc ( * ( void * * ) ( @@v9@@ + Number ) , Number * @@v12@@ ) ; if ( @@v11@@ ) { @@v10@@ = * ( _QWORD * ) @@v9@@ ; * ( _QWORD * ) ( @@v9@@ + Number ) = @@v11@@ ; * ( _QWORD * ) ( @@v9@@ + Number ) = Number * @@v12@@ ; @@v12@@ = @@v10@@ + Number ; goto LABEL_9 ; } return Number L ; } LABEL_9 : * ( _QWORD * ) @@v9@@ = @@v12@@ ; @@v11@@ [ @@v10@@ ] = @@a2@@ ; return Number L ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
long double __fastcall adjust_value_part_0 ( int @@a1@@ , long double @@a2@@ ) { unsigned __int64 @@v7@@ ; long double @@v8@@ ; long double @@result@@ ; if ( @@a2@@ >= Number ) @@v7@@ = ( __int64 ) ( @@a2@@ - Number ) ^ Number ; else @@v7@@ = ( __int64 ) @@a2@@ ; @@v8@@ = ( long double ) @@v7@@ ; if ( @@a1@@ ) return @@v8@@ ; @@result@@ = @@v8@@ ; if ( @@a2@@ != @@v8@@ ) @@result@@ = ( long double ) ( @@v7@@ + Number ) ; return @@result@@ ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
void __fastcall free_charset ( void * @@ptr@@ ) { free ( * ( void * * ) @@ptr@@ ) ; free ( * ( ( void * * ) @@ptr@@ + Number ) ) ; free ( @@ptr@@ ) ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
__int64 __fastcall mode_create_from_ref ( char * @@filename@@ ) { __mode_t @@v1@@ ; __int64 @@result@@ ; struct stat @@v3@@ ; unsigned __int64 @@v4@@ ; @@v4@@ = __readfsqword ( Number ) ; if ( __xstat ( Number , @@filename@@ , & @@v3@@ ) ) return Number L ; @@v1@@ = @@v3@@ . st_mode ; @@result@@ = xmalloc ( Number L ) ; * ( _DWORD * ) ( @@result@@ + Number ) = Number ; * ( _DWORD * ) ( @@result@@ + Number ) = Number ; * ( _WORD * ) @@result@@ = Number ; * ( _DWORD * ) ( @@result@@ + Number ) = @@v1@@ ; * ( _BYTE * ) ( @@result@@ + Number ) = Number ; return @@result@@ ; }
__int64 __fastcall free_tree ( __int64 a1 , __int64 @@a2@@ ) { free_token ( @@a2@@ + Number ) ; return Number L ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall rpl_fcntl ( int @@a1@@ , int @@a2@@ , __int64 @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { int @@v6@@ ; int @@v8@@ ; int @@v9@@ ; int @@v10@@ ; int @@v11@@ ; int * @@v12@@ ; int @@v13@@ ; int * @@v14@@ ; int @@v15@@ ; @@v15@@ = @@a3@@ ; if ( @@a2@@ != Number ) return ( unsigned int ) fcntl ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( have_dupfd_cloexec_3202 < Number ) { @@v6@@ = rpl_fcntl ( @@a1@@ , Number , ( unsigned int ) @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( @@v6@@ < Number || have_dupfd_cloexec_3202 != Number ) return ( unsigned int ) @@v6@@ ; } else { @@v6@@ = fcntl ( @@a1@@ , Number , ( unsigned int ) @@a3@@ ) ; if ( @@v6@@ >= Number || * __errno_location ( ) != Number ) { have_dupfd_cloexec_3202 = Number ; return ( unsigned int ) @@v6@@ ; } @@v6@@ = rpl_fcntl ( @@a1@@ , Number , @@v15@@ , @@v8@@ , @@v9@@ , @@v10@@ ) ; if ( @@v6@@ < Number ) return ( unsigned int ) @@v6@@ ; have_dupfd_cloexec_3202 = Number ; } @@v11@@ = fcntl ( @@v6@@ , Number ) ; if ( @@v11@@ < Number || fcntl ( @@v6@@ , Number , @@v11@@ | Number ) == Number ) { @@v12@@ = __errno_location ( ) ; @@v13@@ = * @@v12@@ ; @@v14@@ = @@v12@@ ; close ( @@v6@@ ) ; @@v6@@ = Number ; * @@v14@@ = @@v13@@ ; } return ( unsigned int ) @@v6@@ ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
void __fastcall free_state ( void * @@ptr@@ ) { void * * @@v1@@ ; free ( * ( ( void * * ) @@ptr@@ + Number ) ) ; free ( * ( ( void * * ) @@ptr@@ + Number ) ) ; @@v1@@ = ( void * * ) * ( ( _QWORD * ) @@ptr@@ + Number ) ; if ( @@v1@@ != ( void * * ) ( ( char * ) @@ptr@@ + Number ) ) { free ( @@v1@@ [ Number ] ) ; free ( * ( ( void * * ) @@ptr@@ + Number ) ) ; } free ( * ( ( void * * ) @@ptr@@ + Number ) ) ; free ( * ( ( void * * ) @@ptr@@ + Number ) ) ; free ( * ( ( void * * ) @@ptr@@ + Number ) ) ; free ( @@ptr@@ ) ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; int @@v13@@ ; _BYTE * @@v14@@ ; __int64 @@v15@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v13@@ = * @@v6@@ ; @@v15@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v14@@ = ( _BYTE * ) xmalloc ( @@v15@@ + Number , @@v15@@ + Number , @@v8@@ , @@v9@@ , @@v10@@ , @@v11@@ ) ; quotearg_buffer_restyled ( @@v14@@ , @@v15@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v13@@ ; if ( @@a3@@ ) * @@a3@@ = @@v15@@ ; return @@v14@@ ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
unsigned __int64 __fastcall re_node_set_contains_isra_3 ( __int64 @@a1@@ , __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@result@@ ; __int64 @@v5@@ ; unsigned __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; unsigned __int64 @@v8@@ ; @@v3@@ = @@a1@@ - Number ; @@result@@ = Number L ; if ( @@v3@@ <= Number ) { @@v5@@ = * @@a2@@ ; @@v6@@ = Number L ; while ( @@v6@@ < @@v3@@ ) { @@v7@@ = ( @@v6@@ + @@v3@@ ) >> Number ; if ( @@a3@@ <= * ( _QWORD * ) ( @@v5@@ + Number * @@v7@@ ) ) { while ( @@v6@@ < @@v7@@ ) { @@v8@@ = ( @@v6@@ + @@v7@@ ) >> Number ; if ( * ( _QWORD * ) ( @@v5@@ + Number * @@v8@@ ) < @@a3@@ ) goto LABEL_11 ; @@v7@@ = ( @@v6@@ + @@v7@@ ) >> Number ; } break ; } @@v8@@ = ( @@v6@@ + @@v3@@ ) >> Number ; @@v7@@ = @@v3@@ ; LABEL_11 : @@v6@@ = @@v8@@ + Number ; @@v3@@ = @@v7@@ ; } @@result@@ = Number L ; if ( @@a3@@ == * ( _QWORD * ) ( @@v5@@ + Number * @@v6@@ ) ) @@result@@ = @@v6@@ + Number ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__int64 __fastcall rpl_vprintf ( __int64 @@a1@@ , __int64 @@a2@@ ) { return rpl_vfprintf ( stdout , @@a1@@ , @@a2@@ ) ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_20C210 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20C1F0 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_20C200 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ , @@v4@@ ) ; } return @@result@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
char * __fastcall create_token_tree_isra_18 ( _QWORD * @@a1@@ , int * @@a2@@ , _QWORD * @@a3@@ , _QWORD * @@a4@@ , const __m128i * @@a5@@ ) { int @@v6@@ ; __int64 @@v7@@ ; int @@v8@@ ; _QWORD * @@v9@@ ; __int64 @@v10@@ ; char * @@result@@ ; __m128i * @@v12@@ ; _QWORD * @@v13@@ ; _QWORD * @@v14@@ ; _QWORD * @@v15@@ ; const __m128i * @@v16@@ ; @@v6@@ = * @@a2@@ ; if ( * @@a2@@ == Number ) { @@v16@@ = @@a5@@ ; @@v15@@ = @@a4@@ ; @@v14@@ = @@a3@@ ; @@v9@@ = malloc ( Number ) ; if ( ! @@v9@@ ) return Number L ; @@v13@@ = ( _QWORD * ) * @@a1@@ ; @@v8@@ = Number ; * @@a1@@ = @@v9@@ ; @@v7@@ = Number L ; @@a5@@ = @@v16@@ ; @@a4@@ = @@v15@@ ; @@a3@@ = @@v14@@ ; * @@v9@@ = @@v13@@ ; @@v10@@ = Number L ; } else { @@v7@@ = @@v6@@ ; @@v8@@ = @@v6@@ + Number ; @@v9@@ = ( _QWORD * ) * @@a1@@ ; @@v10@@ = ( ( __int64 ) @@v6@@ << Number ) + Number ; } * @@a2@@ = @@v8@@ ; @@result@@ = ( char * ) @@v9@@ + @@v10@@ ; @@v12@@ = ( __m128i * ) & @@v9@@ [ Number * @@v7@@ ] ; @@v12@@ -> m128i_i64 [ Number ] = Number L ; @@v12@@ [ Number ] . m128i_i64 [ Number ] = ( __int64 ) @@a3@@ ; @@v12@@ [ Number ] . m128i_i64 [ Number ] = ( __int64 ) @@a4@@ ; @@v12@@ [ Number ] = _mm_loadu_si128 ( @@a5@@ ) ; @@v12@@ [ Number ] . m128i_i8 [ Number ] &= Number ; @@v12@@ [ Number ] . m128i_i64 [ Number ] = Number L ; @@v12@@ [ Number ] . m128i_i64 [ Number ] = Number L ; @@v12@@ [ Number ] . m128i_i64 [ Number ] = Number ; if ( @@a3@@ ) * @@a3@@ = @@result@@ ; if ( @@a4@@ ) * @@a4@@ = @@result@@ ; return @@result@@ ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
void * __fastcall xzalloc ( size_t @@n@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@n@@ ) ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
int __fastcall argmatch_valid ( _QWORD * @@a1@@ , char * @@a2@@ , size_t @@a3@@ ) { const void * @@v5@@ ; __int64 @@v6@@ ; char * @@v7@@ ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; if ( * @@a1@@ ) { @@v5@@ = Number L ; @@v6@@ = Number L ; do { while ( ! @@v6@@ || memcmp ( @@v5@@ , @@a2@@ , @@a3@@ ) ) { ++ @@v6@@ ; @@v5@@ = @@a2@@ ; __fprintf_chk ( ) ; @@a2@@ += @@a3@@ ; if ( ! @@a1@@ [ @@v6@@ ] ) goto LABEL_7 ; } ++ @@v6@@ ; @@a2@@ += @@a3@@ ; __fprintf_chk ( ) ; } while ( @@a1@@ [ @@v6@@ ] ) ; } LABEL_7 : @@v7@@ = stderr -> _IO_write_ptr ; if ( @@v7@@ >= stderr -> _IO_write_end ) { LODWORD ( @@v7@@ ) = __overflow ( stderr , Number ) ; } else { stderr -> _IO_write_ptr = @@v7@@ + Number ; * @@v7@@ = Number ; } return ( int ) @@v7@@ ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
__int64 __fastcall _xargmatch_internal ( __int64 @@a1@@ , char * @@a2@@ , const char * * @@a3@@ , char * @@a4@@ , size_t @@a5@@ , void ( * @@a6@@ ) ( void ) ) { __int64 @@result@@ ; @@result@@ = argmatch ( @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; if ( @@result@@ < Number ) { argmatch_invalid ( @@a1@@ , ( wchar_t * ) @@a2@@ , @@result@@ ) ; argmatch_valid ( @@a3@@ , @@a4@@ , @@a5@@ ) ; @@a6@@ ( ) ; @@result@@ = Number ; } return @@result@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
void __fastcall fseterr ( _DWORD * @@a1@@ ) { * @@a1@@ |= Number ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall dup_safer ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number L , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall merge_state_array ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ ) { __int64 @@v8@@ ; __int64 @@result@@ ; _QWORD * @@v10@@ ; void * @@v11@@ ; __int64 @@v12@@ ; __int64 @@v13@@ ; unsigned int @@v14@@ ; void * @@v15@@ [ Number ] ; @@v15@@ [ Number ] = ( void * ) __readfsqword ( Number ) ; if ( ! @@a4@@ ) return Number L ; @@v8@@ = Number L ; while ( Number ) { while ( Number ) { @@v12@@ = * ( _QWORD * ) ( @@a2@@ + Number * @@v8@@ ) ; @@v13@@ = * ( _QWORD * ) ( @@a3@@ + Number * @@v8@@ ) ; if ( @@v12@@ ) break ; * ( _QWORD * ) ( @@a2@@ + Number * @@v8@@ ++ ) = @@v13@@ ; if ( @@a4@@ == @@v8@@ ) return Number L ; } if ( @@v13@@ ) { @@result@@ = re_node_set_init_union ( @@v15@@ , @@v12@@ + Number , @@v13@@ + Number ) ; @@v14@@ = @@result@@ ; if ( ( _DWORD ) @@result@@ ) break ; @@v10@@ = re_acquire_state ( & @@v14@@ , @@a1@@ , ( __int64 ) @@v15@@ ) ; @@v11@@ = @@v15@@ [ Number ] ; * ( _QWORD * ) ( @@a2@@ + Number * @@v8@@ ) = @@v10@@ ; free ( @@v11@@ ) ; @@result@@ = @@v14@@ ; if ( @@v14@@ ) break ; } if ( @@a4@@ == ++ @@v8@@ ) return Number L ; } return @@result@@ ; }
int __xstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _xstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
__int64 __fastcall fd_safer ( int @@fd@@ , __int64 @@a2@@ , __int64 @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { unsigned int @@v6@@ ; unsigned int @@v7@@ ; int * @@v8@@ ; int @@v9@@ ; int * @@v10@@ ; @@v6@@ = @@fd@@ ; if ( ( unsigned int ) @@fd@@ <= Number ) { @@v7@@ = dup_safer ( @@fd@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; @@v8@@ = __errno_location ( ) ; @@v9@@ = * @@v8@@ ; @@v10@@ = @@v8@@ ; close ( @@fd@@ ) ; @@v6@@ = @@v7@@ ; * @@v10@@ = @@v9@@ ; } return @@v6@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 __fastcall pop_fail_stack_isra_26 ( unsigned __int64 * @@a1@@ , _QWORD * @@a2@@ , _QWORD * @@a3@@ , __int64 @@a4@@ , void * @@a5@@ , __int64 @@a6@@ ) { unsigned __int64 @@v6@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; @@v6@@ = * @@a1@@ - Number ; * @@a1@@ = @@v6@@ ; if ( @@v6@@ > Number ) __assert_fail ( String , String , Number , String ) ; @@v8@@ = Number * @@v6@@ ; @@v9@@ = Number * @@v6@@ + * @@a2@@ ; * @@a3@@ = * ( _QWORD * ) @@v9@@ ; memcpy ( @@a5@@ , * ( const void * * ) ( @@v9@@ + Number ) , Number * @@a4@@ ) ; free ( * ( void * * ) ( @@a6@@ + Number ) ) ; free ( * ( void * * ) ( * @@a2@@ + @@v8@@ + Number ) ) ; @@v10@@ = * @@a2@@ + @@v8@@ ; * ( __m128i * ) @@a6@@ = _mm_loadu_si128 ( ( const __m128i * ) ( @@v10@@ + Number ) ) ; * ( _QWORD * ) ( @@a6@@ + Number ) = * ( _QWORD * ) ( @@v10@@ + Number ) ; return * ( _QWORD * ) ( @@v10@@ + Number ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
__int64 __fastcall rpl_re_set_syntax ( __int64 @@a1@@ ) { __int64 @@result@@ ; @@result@@ = rpl_re_syntax_options ; rpl_re_syntax_options = @@a1@@ ; return @@result@@ ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; char * @@v9@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = setlocale ( Number , Number L ) ; if ( @@v9@@ ) { if ( strncmp ( @@v9@@ , String , Number ) ) { last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
__mode_t umask ( __mode_t @@mask@@ ) { return umask ( @@mask@@ ) ; }
__int64 __fastcall re_search_2_stub ( __int64 @@a1@@ , const void * @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ , unsigned __int64 @@a6@@ , __int64 @@a7@@ , unsigned __int64 * @@a8@@ , __int64 @@a9@@ , char @@a10@@ ) { unsigned __int64 @@v10@@ ; unsigned __int64 @@v12@@ ; char * @@v13@@ ; __int64 @@v15@@ ; char * @@v17@@ ; const void * @@v18@@ ; @@v10@@ = @@a5@@ + @@a3@@ ; if ( __CFADD__ ( @@a5@@ , @@a3@@ ) ) return Number ; @@v12@@ = @@a6@@ ; if ( ! @@a5@@ ) { @@a4@@ = ( __int64 ) @@a2@@ ; @@v13@@ = Number L ; goto LABEL_4 ; } @@v13@@ = Number L ; if ( @@a3@@ ) { @@v17@@ = ( char * ) malloc ( @@a5@@ + @@a3@@ ) ; @@v13@@ = @@v17@@ ; if ( @@v17@@ ) { memcpy ( @@v17@@ , @@a2@@ , @@a3@@ ) ; @@v18@@ = ( const void * ) @@a4@@ ; @@a4@@ = ( __int64 ) @@v13@@ ; memcpy ( & @@v13@@ [ @@a3@@ ] , @@v18@@ , @@a5@@ ) ; @@v12@@ = @@a6@@ ; goto LABEL_4 ; } return Number ; } LABEL_4 : @@v15@@ = re_search_stub ( @@a1@@ , @@a4@@ , @@v10@@ , @@v12@@ , @@a7@@ , @@a9@@ , @@a8@@ , @@a10@@ ) ; free ( @@v13@@ ) ; return @@v15@@ ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
__int64 __fastcall rpl_re_match ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ , unsigned __int64 @@a4@@ , unsigned __int64 * @@a5@@ ) { return re_search_stub ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , Number L , @@a3@@ , @@a5@@ , Number ) ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
__int64 __fastcall rpl_re_search ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ , unsigned __int64 @@a4@@ , __int64 @@a5@@ , unsigned __int64 * @@a6@@ ) { return re_search_stub ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a3@@ , @@a6@@ , Number ) ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_2061F0 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061D0 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_2061E0 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
int __fastcall keycmp_isra_3 ( unsigned __int64 @@a1@@ , _QWORD * @@a2@@ , unsigned __int64 @@a3@@ , _QWORD * @@a4@@ , unsigned __int64 @@a5@@ , unsigned __int64 @@a6@@ ) { __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; _QWORD * @@v8@@ ; const void * @@v9@@ ; unsigned __int64 @@v10@@ ; const void * @@v11@@ ; size_t @@v12@@ ; int @@result@@ ; __int64 @@v14@@ ; if ( @@a5@@ >= @@a1@@ ) { if ( @@a6@@ >= @@a3@@ ) return Number ; @@v10@@ = * ( _QWORD * ) ( * @@a4@@ + Number * @@a6@@ + Number ) ; return - ( @@v10@@ != Number ) ; } @@v6@@ = * @@a2@@ + Number * @@a5@@ ; @@v7@@ = * ( _QWORD * ) ( @@v6@@ + Number ) ; if ( @@a6@@ >= @@a3@@ ) return @@v7@@ != Number ; @@v8@@ = ( _QWORD * ) ( * @@a4@@ + Number * @@a6@@ ) ; @@v9@@ = ( const void * ) * @@v8@@ ; @@v10@@ = @@v8@@ [ Number ] ; if ( ! @@v7@@ ) return - ( @@v10@@ != Number ) ; if ( ! @@v10@@ ) return Number ; @@v11@@ = * ( const void * * ) @@v6@@ ; if ( ignore_case ) { @@v14@@ = @@v8@@ [ Number ] ; if ( @@v7@@ <= @@v10@@ ) @@v14@@ = * ( _QWORD * ) ( @@v6@@ + Number ) ; @@result@@ = memcasecmp ( @@v11@@ , @@v9@@ , @@v14@@ ) ; } else { if ( hard_LC_COLLATE ) return xmemcoll ( @@v11@@ , * ( _QWORD * ) ( @@v6@@ + Number ) , * @@v8@@ , @@v8@@ [ Number ] ) ; @@v12@@ = @@v8@@ [ Number ] ; if ( @@v7@@ <= @@v10@@ ) @@v12@@ = * ( _QWORD * ) ( @@v6@@ + Number ) ; @@result@@ = memcmp ( @@v11@@ , @@v9@@ , @@v12@@ ) ; } if ( ! @@result@@ ) { if ( @@v7@@ < @@v10@@ ) @@result@@ = Number ; else @@result@@ = @@v7@@ != @@v10@@ ; } return @@result@@ ; }
__int64 __fastcall rpl_re_search_2 ( __int64 @@a1@@ , const void * @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ , unsigned __int64 @@a6@@ , __int64 @@a7@@ , unsigned __int64 * @@a8@@ , __int64 @@a9@@ ) { return re_search_2_stub ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ , @@a7@@ , @@a8@@ , @@a9@@ , Number ) ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; FILE * @@v11@@ ; char * @@v12@@ ; FILE * @@v13@@ ; char * @@v14@@ ; char * @@v15@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = stdout ; @@v10@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; @@v11@@ = stdout ; @@v12@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v12@@ , @@v11@@ ) ; last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v13@@ = stdout ; @@v14@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v14@@ , @@v13@@ ) ; @@v15@@ = setlocale ( Number , Number L ) ; if ( @@v15@@ ) { if ( strncmp ( @@v15@@ , String , Number ) ) { last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
int __xstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _xstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
bool __fastcall binop ( const char * @@a1@@ ) { bool @@result@@ ; @@result@@ = Number ; if ( strcmp ( @@a1@@ , String ) && strcmp ( @@a1@@ , String ) && strcmp ( @@a1@@ , String ) && strcmp ( @@a1@@ , String ) && strcmp ( @@a1@@ , String ) && strcmp ( @@a1@@ , String ) && strcmp ( @@a1@@ , String ) && strcmp ( @@a1@@ , String ) && strcmp ( @@a1@@ , String ) ) { if ( strcmp ( @@a1@@ , String ) ) @@result@@ = strcmp ( @@a1@@ , String ) == Number ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
int unlink ( const char * @@name@@ ) { return unlink ( @@name@@ ) ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ , @@v4@@ ) ; return @@result@@ ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
int __lxstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _lxstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
int fsync ( int @@fd@@ ) { return fsync ( @@fd@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
int fileno ( FILE * @@stream@@ ) { return fileno ( @@stream@@ ) ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_2061F0 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061D0 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_2061E0 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
__int64 __fastcall dosync ( int @@fd@@ , __int64 @@a2@@ ) { int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; int @@v5@@ ; char * @@v6@@ ; char * @@v8@@ ; if ( ! fdatasync ( @@fd@@ ) ) return Number L ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ( unsigned int ) ( * @@v2@@ - Number ) <= Number || @@v3@@ == Number ) { if ( fsync ( @@fd@@ ) ) { @@v5@@ = * @@v4@@ ; if ( ( unsigned int ) ( * @@v4@@ - Number ) > Number && @@v5@@ != Number ) { @@v6@@ = dcgettext ( Number L , String , Number ) ; error ( Number , @@v5@@ , @@v6@@ , @@a2@@ ) ; * @@v4@@ = @@v5@@ ; return Number ; } sync ( ) ; } return Number L ; } @@v8@@ = dcgettext ( Number L , String , Number ) ; error ( Number , @@v3@@ , @@v8@@ , @@a2@@ ) ; * @@v4@@ = @@v3@@ ; return Number ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
__int64 __fastcall randread ( __int64 @@a1@@ , char * @@a2@@ , size_t @@a3@@ ) { size_t @@v4@@ ; int * @@v6@@ ; FILE * @@v7@@ ; int * @@v8@@ ; __int64 @@v9@@ ; int @@v10@@ ; __int64 @@result@@ ; size_t @@v12@@ ; __int64 @@v13@@ ; void * @@v14@@ ; size_t @@v15@@ ; __int64 @@v16@@ ; char * @@v17@@ ; FILE * @@src@@ ; char * @ @ VAR_441 @ @ srca @ @ $41FE09B6257987CAFC80CA7C5973CF25 ; @@v4@@ = @@a3@@ ; @@src@@ = * ( FILE * * ) @@a1@@ ; if ( * ( _QWORD * ) @@a1@@ ) { @@v6@@ = __errno_location ( ) ; @@v7@@ = @@src@@ ; @@v8@@ = @@v6@@ ; while ( Number ) { @@result@@ = fread_unlocked ( @@a2@@ , Number , @@v4@@ , @@v7@@ ) ; @@a2@@ += @@result@@ ; @@v4@@ -= @@result@@ ; if ( ! @@v4@@ ) break ; @@v9@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v10@@ = * * ( _DWORD * * ) @@a1@@ & Number ; if ( @@v10@@ ) @@v10@@ = * @@v8@@ ; * @@v8@@ = @@v10@@ ; ( * ( void ( __fastcall * * ) ( __int64 ) ) ( @@a1@@ + Number ) ) ( @@v9@@ ) ; @@v7@@ = * ( FILE * * ) @@a1@@ ; } } else { @@v12@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v13@@ = @@a1@@ + Number ; @ @ VAR_441 @ @ srca @ @ $41FE09B6257987CAFC80CA7C5973CF25 = ( char * ) ( @@a1@@ + Number ) ; if ( @@a3@@ <= @@v12@@ ) { @ @ VAR_441 @ @ srca @ @ $41FE09B6257987CAFC80CA7C5973CF25 = ( char * ) ( @@a1@@ + Number - @@v12@@ + Number ) ; LABEL_18 : @@result@@ = ( __int64 ) memcpy ( @@a2@@ , @ @ VAR_441 @ @ srca @ @ $41FE09B6257987CAFC80CA7C5973CF25 , @@v4@@ ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v12@@ - @@v4@@ ; } else { while ( Number ) { @@v14@@ = @@a2@@ ; @@a2@@ += @@v12@@ ; @@v4@@ -= @@v12@@ ; memcpy ( @@v14@@ , & @ @ VAR_441 @ @ srca @ @ $41FE09B6257987CAFC80CA7C5973CF25 [ Number - @@v12@@ ] , @@v12@@ ) ; if ( ( ( unsigned __int8 ) @@a2@@ & Number ) == Number ) break ; LABEL_16 : @@v12@@ = Number L ; isaac_refill ( @@v13@@ , @ @ VAR_441 @ @ srca @ @ $41FE09B6257987CAFC80CA7C5973CF25 ) ; if ( @@v4@@ <= Number ) goto LABEL_17 ; } if ( @@v4@@ <= Number ) { isaac_refill ( @@v13@@ , @ @ VAR_441 @ @ srca @ @ $41FE09B6257987CAFC80CA7C5973CF25 ) ; LABEL_17 : @@v12@@ = Number L ; goto LABEL_18 ; } @@v15@@ = @@v4@@ - Number ; @@v16@@ = ( ( _WORD ) @@v4@@ - Number ) & Number ; while ( Number ) { @@v17@@ = @@a2@@ ; @@a2@@ += Number ; @@result@@ = isaac_refill ( @@v13@@ , @@v17@@ ) ; @@v4@@ = @@v15@@ ; if ( ! @@v15@@ ) break ; if ( @@v15@@ == @@v16@@ ) goto LABEL_16 ; @@v15@@ -= Number L ; } * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; } } return @@result@@ ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
__int64 __fastcall string_to_join_field ( char * @@a1@@ ) { int @@v1@@ ; __int64 @@v2@@ ; __int64 @@v3@@ ; char * @@v4@@ ; __int64 @@v6@@ ; @@v1@@ = xstrtoul ( @@a1@@ ) ; @@v2@@ = Number ; if ( @@v1@@ != Number ) { if ( ! @@v1@@ && ( @@v2@@ = @@v6@@ ) != Number ) { @@v2@@ = @@v6@@ - Number ; } else { @@v3@@ = quote ( @@a1@@ , Number L , @@v2@@ ) ; @@v4@@ = dcgettext ( Number L , String , Number ) ; error ( Number , Number , @@v4@@ , @@v3@@ ) ; @@v2@@ = @@v6@@ - Number ; } } return @@v2@@ ; }
void __fastcall delseq_isra_2 ( unsigned __int64 * @@a1@@ , void * * @@a2@@ ) { _QWORD * @@v2@@ ; unsigned __int64 @@v3@@ ; void * * @@v4@@ ; _QWORD * @@v5@@ ; @@v2@@ = * @@a2@@ ; if ( * @@a1@@ ) { @@v3@@ = Number L ; do { @@v4@@ = ( void * * ) @@v2@@ [ @@v3@@ ] ; if ( @@v4@@ ) { if ( @@v4@@ [ Number ] ) { free ( @@v4@@ [ Number ] ) ; free ( @@v4@@ [ Number ] ) ; @@v5@@ = * @@a2@@ ; @@v4@@ [ Number ] = Number L ; @@v4@@ = ( void * * ) @@v5@@ [ @@v3@@ ] ; } free ( @@v4@@ ) ; @@v2@@ = * @@a2@@ ; } ++ @@v3@@ ; } while ( @@v3@@ < * @@a1@@ ) ; free ( @@v2@@ ) ; } else { free ( * @@a2@@ ) ; } }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 __fastcall dir_name ( void * @@a1@@ ) { __int64 @@result@@ ; @@result@@ = mdir_name ( @@a1@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
_QWORD * __fastcall extract_field ( _QWORD * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { unsigned __int64 @@v5@@ ; unsigned __int64 @@v6@@ ; __int64 @@v7@@ ; _QWORD * @@result@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; @@v5@@ = @@a1@@ [ Number ] ; @@v6@@ = @@a1@@ [ Number ] ; @@v7@@ = @@a1@@ [ Number ] ; if ( @@v5@@ >= @@v6@@ ) { if ( @@v7@@ ) { if ( @@v6@@ > Number ) xalloc_die ( ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v9@@ = Number L ; @@v6@@ = Number L ; goto LABEL_7 ; } @@v9@@ = Number * @@v6@@ ; LABEL_7 : @@a1@@ [ Number ] = @@v6@@ ; @@v10@@ = @@a3@@ ; @@v7@@ = xrealloc ( @@v7@@ , @@v9@@ ) ; @@v5@@ = @@a1@@ [ Number ] ; @@a1@@ [ Number ] = @@v7@@ ; @@a3@@ = @@v10@@ ; } @@result@@ = ( _QWORD * ) ( Number * @@v5@@ + @@v7@@ ) ; * @@result@@ = @@a2@@ ; @@result@@ [ Number ] = @@a3@@ ; @@a1@@ [ Number ] = @@v5@@ + Number ; return @@result@@ ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; FILE * @@v11@@ ; char * @@v12@@ ; FILE * @@v13@@ ; char * @@v14@@ ; char * @@v15@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String String String String String String String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String String String String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String String String String String String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = stdout ; @@v10@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; @@v11@@ = stdout ; @@v12@@ = dcgettext ( Number L , String String String String String String String String String String String String String , Number ) ; fputs_unlocked ( @@v12@@ , @@v11@@ ) ; last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v13@@ = stdout ; @@v14@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v14@@ , @@v13@@ ) ; @@v15@@ = setlocale ( Number , Number L ) ; if ( @@v15@@ ) { if ( strncmp ( @@v15@@ , String , Number ) ) { last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
_BYTE * __fastcall mdir_name ( void * @@src@@ ) { __int64 @@v1@@ ; _BYTE * @@v2@@ ; _BYTE * @@v3@@ ; _BYTE * @@v4@@ ; @@v1@@ = dir_len ( @@src@@ ) ; @@v2@@ = malloc ( @@v1@@ + ( @@v1@@ == Number ) + Number ) ; @@v3@@ = @@v2@@ ; if ( @@v2@@ ) { @@v4@@ = memcpy ( @@v2@@ , @@src@@ , @@v1@@ ) ; @@v3@@ = @@v4@@ ; if ( ! @@v1@@ ) { * @@v4@@ = Number ; @@v1@@ = Number L ; } @@v4@@ [ @@v1@@ ] = Number ; } return @@v3@@ ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_2081D0 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2081B0 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_2081C0 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_2092D0 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2092B0 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_2092C0 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
_DWORD * __fastcall add_file_name ( __int64 @@a1@@ , _QWORD * @@a2@@ , _DWORD * @@a3@@ , _DWORD * @@a4@@ , _DWORD * @@a5@@ , _DWORD * @@a6@@ , _DWORD * @@a7@@ ) { int @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; _DWORD * @@result@@ ; int @@v12@@ ; _BOOL8 @@v13@@ ; char * @@v14@@ ; int @@v15@@ ; __int64 @@v16@@ ; __int64 @@v17@@ ; __int64 @@v18@@ ; char * @@v19@@ ; _DWORD * @@v20@@ ; _DWORD * @@v21@@ ; _DWORD * @@v22@@ ; _DWORD * @@v23@@ ; _DWORD * @@v24@@ ; _DWORD * @@v25@@ ; _DWORD * @@v26@@ ; _DWORD * @@v27@@ ; _DWORD * @@v28@@ ; @@v8@@ = * @@a5@@ ; if ( * @@a5@@ == Number ) { @@v12@@ = * @@a3@@ ; @@v13@@ = * @@a3@@ == Number ; @@v14@@ = ( char * ) @@a2@@ [ @@v13@@ ] ; @@v15@@ = @@a3@@ [ @@v13@@ ] ; if ( @@v15@@ == Number ) { -- * @@a4@@ ; @@v28@@ = @@a6@@ ; @@v25@@ = @@a5@@ ; @@v22@@ = @@a3@@ ; @@v17@@ = string_to_join_field ( @@v14@@ ) ; set_join_field ( & join_field_1 , @@v17@@ ) ; @@a3@@ = @@v22@@ ; @@a5@@ = @@v25@@ ; @@a6@@ = @@v28@@ ; } else if ( @@v15@@ <= Number ) { if ( ! @@v15@@ ) { @@v18@@ = quote ( @@a1@@ , @@a2@@ , @@a3@@ ) ; @@v19@@ = dcgettext ( Number L , String , Number ) ; error ( Number , Number , @@v19@@ , @@v18@@ ) ; usage ( Number ) ; } } else if ( @@v15@@ == Number ) { -- @@a4@@ [ Number ] ; @@v27@@ = @@a6@@ ; @@v24@@ = @@a5@@ ; @@v21@@ = @@a3@@ ; @@v16@@ = string_to_join_field ( @@v14@@ ) ; set_join_field ( & join_field_2 , @@v16@@ ) ; @@a3@@ = @@v21@@ ; @@a5@@ = @@v24@@ ; @@a6@@ = @@v27@@ ; } else if ( @@v15@@ == Number ) { @@v26@@ = @@a6@@ ; @@v23@@ = @@a5@@ ; @@v20@@ = @@a3@@ ; add_field_list ( @@v14@@ ) ; @@a6@@ = @@v26@@ ; @@a5@@ = @@v23@@ ; @@a3@@ = @@v20@@ ; } if ( @@v12@@ ) { @@v10@@ = Number L ; * @@a3@@ = @@a3@@ [ Number ] ; * @@a2@@ = @@a2@@ [ Number ] ; @@result@@ = ( _DWORD * ) & byte_8 ; } else { @@result@@ = ( _DWORD * ) & byte_8 ; @@v10@@ = Number L ; } } else { @@v9@@ = @@v8@@ ++ ; @@v10@@ = @@v9@@ ; @@result@@ = ( _DWORD * ) ( Number * @@v9@@ ) ; } @@a3@@ [ @@v10@@ ] = * @@a6@@ ; * ( _QWORD * ) ( ( char * ) @@result@@ + ( _QWORD ) @@a2@@ ) = @@a1@@ ; * @@a5@@ = @@v8@@ ; if ( * @@a6@@ == Number ) { @@result@@ = @@a7@@ ; * @@a7@@ = Number ; } return @@result@@ ; }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
__int64 __fastcall human_options ( char * @@nptr@@ , int * @@a2@@ , unsigned __int64 * @@a3@@ ) { char * @@v4@@ ; int @@v5@@ ; int @@v6@@ ; int @@v7@@ ; __int64 @@result@@ ; unsigned __int64 @@v9@@ ; char * @@v10@@ [ Number ] ; @@v4@@ = @@nptr@@ ; @@v10@@ [ Number ] = ( char * ) __readfsqword ( Number ) ; if ( @@nptr@@ || ( @@v4@@ = getenv ( String ) ) != Number L || ( @@v4@@ = getenv ( String ) ) != Number L ) { @@v5@@ = Number ; if ( * @@v4@@ == Number ) { ++ @@v4@@ ; @@v5@@ = Number ; } @@v6@@ = argmatch ( @@v4@@ , block_size_args , block_size_opts , Number L ) ; if ( @@v6@@ >= Number ) { * @@a3@@ = Number L ; @@v7@@ = block_size_opts [ @@v6@@ ] | @@v5@@ ; @@result@@ = Number L ; * @@a2@@ = @@v7@@ ; return @@result@@ ; } @@result@@ = xstrtoumax ( @@v4@@ , @@v10@@ , Number , @@a3@@ , String ) ; if ( ( _DWORD ) @@result@@ ) { @@v9@@ = * @@a3@@ ; * @@a2@@ = Number ; LABEL_15 : if ( ! @@v9@@ ) { * @@a3@@ = getenv ( String ) == Number L ? Number L : Number L ; @@result@@ = Number L ; } return @@result@@ ; } if ( ( unsigned __int8 ) ( * @@v4@@ - Number ) > Number ) { if ( @@v4@@ != @@v10@@ [ Number ] ) { while ( ( unsigned __int8 ) ( * ++ @@v4@@ - Number ) > Number ) { if ( @@v4@@ == @@v10@@ [ Number ] ) goto LABEL_22 ; } goto LABEL_13 ; } LABEL_22 : if ( * ( @@v10@@ [ Number ] - Number ) == Number ) { @@v5@@ |= Number ; if ( * ( @@v10@@ [ Number ] - Number ) != Number ) goto LABEL_13 ; } else { LOBYTE ( @@v5@@ ) = @@v5@@ | Number ; } @@v5@@ |= Number ; } LABEL_13 : @@v9@@ = * @@a3@@ ; * @@a2@@ = @@v5@@ ; goto LABEL_15 ; } if ( getenv ( String ) ) * @@a3@@ = Number L ; else * @@a3@@ = Number L ; @@result@@ = Number L ; * @@a2@@ = Number ; return @@result@@ ; }
__int64 __fastcall rpl_fcntl ( int @@a1@@ , int @@a2@@ , __int64 @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { int @@v6@@ ; int @@v8@@ ; int @@v9@@ ; int @@v10@@ ; int @@v11@@ ; int * @@v12@@ ; int @@v13@@ ; int * @@v14@@ ; int @@v15@@ ; @@v15@@ = @@a3@@ ; if ( @@a2@@ != Number ) return ( unsigned int ) fcntl ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( have_dupfd_cloexec_3202 < Number ) { @@v6@@ = ( ( __int64 ( __fastcall * ) ( int , _DWORD , _DWORD , int , int , int , char ) ) rpl_fcntl ) ( @@a1@@ , Number , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ , Number ) ; if ( @@v6@@ < Number || have_dupfd_cloexec_3202 != Number ) return ( unsigned int ) @@v6@@ ; } else { @@v6@@ = fcntl ( @@a1@@ , Number , ( unsigned int ) @@a3@@ ) ; if ( @@v6@@ >= Number || * __errno_location ( ) != Number ) { have_dupfd_cloexec_3202 = Number ; return ( unsigned int ) @@v6@@ ; } @@v6@@ = ( ( __int64 ( __fastcall * ) ( int , _DWORD , int , int , int , int , char ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v15@@ , @@v8@@ , @@v9@@ , @@v10@@ , Number ) ; if ( @@v6@@ < Number ) return ( unsigned int ) @@v6@@ ; have_dupfd_cloexec_3202 = Number ; } @@v11@@ = fcntl ( @@v6@@ , Number ) ; if ( @@v11@@ < Number || fcntl ( @@v6@@ , Number , @@v11@@ | Number ) == Number ) { @@v12@@ = __errno_location ( ) ; @@v13@@ = * @@v12@@ ; @@v14@@ = @@v12@@ ; close ( @@v6@@ ) ; @@v6@@ = Number ; * @@v14@@ = @@v13@@ ; } return ( unsigned int ) @@v6@@ ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
unsigned int alarm ( unsigned int @@seconds@@ ) { return alarm ( @@seconds@@ ) ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
int __fastcall memcoll ( void * @@s1@@ , size_t @@n@@ , void * @@s2@@ , __int64 @@a4@@ ) { const char * @@v5@@ ; int * @@v7@@ ; size_t @@v8@@ ; char * @@v9@@ ; __int64 @@v10@@ ; char @@v11@@ ; size_t @@v12@@ ; size_t @@v13@@ ; int @@result@@ ; __int64 @@v15@@ ; __int64 @@v16@@ ; int @@v17@@ ; char @@v18@@ ; char @@v19@@ ; @@v5@@ = ( const char * ) @@s1@@ ; @@v7@@ = __errno_location ( ) ; if ( @@n@@ != @@a4@@ || ( @@result@@ = memcmp ( @@s1@@ , @@s2@@ , @@n@@ ) ) != Number ) { @@v8@@ = @@n@@ + Number ; @@v18@@ = * ( ( _BYTE * ) @@s1@@ + @@n@@ ) ; @@v9@@ = ( char * ) @@s2@@ + @@a4@@ ; @@v10@@ = @@a4@@ + Number ; @@v11@@ = * @@v9@@ ; * ( ( _BYTE * ) @@s1@@ + @@n@@ ) = Number ; * @@v9@@ = Number ; @@v19@@ = @@v11@@ ; do { * @@v7@@ = Number ; @@result@@ = strcoll ( @@v5@@ , ( const char * ) @@s2@@ ) ; if ( @@result@@ ) { @@v15@@ = @@v8@@ - Number ; @@v16@@ = @@v10@@ - Number ; goto LABEL_7 ; } @@v12@@ = strlen ( @@v5@@ ) + Number ; @@v13@@ = strlen ( ( const char * ) @@s2@@ ) + Number ; @@v5@@ += @@v12@@ ; @@s2@@ = ( char * ) @@s2@@ + @@v13@@ ; @@v10@@ -= @@v13@@ ; @@v8@@ -= @@v12@@ ; if ( ! @@v8@@ ) { @@v15@@ = Number ; @@v17@@ = @@v10@@ != Number ; @@v16@@ = @@v10@@ - Number ; @@result@@ = - @@v17@@ ; goto LABEL_7 ; } } while ( @@v10@@ ) ; @@v15@@ = @@v8@@ - Number ; @@v16@@ = Number ; @@result@@ = Number ; LABEL_7 : @@v5@@ [ @@v15@@ ] = @@v18@@ ; * ( ( _BYTE * ) @@s2@@ + @@v16@@ ) = @@v19@@ ; } else { * @@v7@@ = Number ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_20C210 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20C1F0 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20C200 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
FILE * __fastcall fopen_safer ( const char * @@a1@@ , const char * @@a2@@ ) { FILE * @@v2@@ ; FILE * @@v3@@ ; unsigned int @@v4@@ ; int @@v6@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; int * @@v10@@ ; int @@v11@@ ; int * @@v12@@ ; @@v2@@ = fopen ( @@a1@@ , @@a2@@ ) ; @@v3@@ = @@v2@@ ; if ( @@v2@@ ) { @@v4@@ = fileno ( @@v2@@ ) ; if ( @@v4@@ <= Number ) { @@v6@@ = dup_safer ( @@v4@@ ) ; if ( @@v6@@ < Number ) { @@v10@@ = __errno_location ( ) ; @@v11@@ = * @@v10@@ ; @@v12@@ = @@v10@@ ; fclose ( @@v3@@ ) ; @@v3@@ = Number L ; * @@v12@@ = @@v11@@ ; } else if ( fclose ( @@v3@@ ) || ( @@v3@@ = fdopen ( @@v6@@ , @@a2@@ ) ) == Number L ) { @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; close ( @@v6@@ ) ; * @@v9@@ = @@v8@@ ; @@v3@@ = Number L ; } } } return @@v3@@ ; }
__int64 __fastcall operand2sig ( char * @@nptr@@ , __int64 @@a2@@ ) { int * @@v2@@ ; int * @@v3@@ ; __int64 @@v4@@ ; int @@v5@@ ; char * @@v6@@ ; char * @@v8@@ ; char @@v9@@ ; char * @@v10@@ ; char * @@v11@@ ; unsigned int @@v12@@ ; char * @@endptr@@ [ Number ] ; @@endptr@@ [ Number ] = ( char * ) __readfsqword ( Number ) ; if ( ( unsigned int ) ( * @@nptr@@ - Number ) > Number ) { @@v8@@ = ( char * ) xstrdup ( @@nptr@@ ) ; @@v9@@ = * @@v8@@ ; @@v10@@ = @@v8@@ ; if ( * @@v8@@ ) { @@v11@@ = @@v8@@ ; do { if ( strchr ( String , @@v9@@ ) ) * @@v11@@ = @@v9@@ - Number ; @@v9@@ = * ++ @@v11@@ ; } while ( * @@v11@@ ) ; } if ( ( unsigned int ) str2sig ( @@v10@@ ) && ( * @@v10@@ != Number || @@v10@@ [ Number ] != Number || @@v10@@ [ Number ] != Number || ( unsigned int ) str2sig ( @@v10@@ + Number ) ) ) { free ( @@v10@@ ) ; LABEL_6 : @@v6@@ = dcgettext ( Number L , String , Number ) ; error ( Number , Number , @@v6@@ , @@nptr@@ ) ; return Number ; } @@v5@@ = @@v12@@ ; free ( @@v10@@ ) ; } else { @@v2@@ = __errno_location ( ) ; * @@v2@@ = Number ; @@v3@@ = @@v2@@ ; @@v4@@ = strtol ( @@nptr@@ , @@endptr@@ , Number ) ; if ( @@endptr@@ [ Number ] == @@nptr@@ ) goto LABEL_6 ; if ( * @@endptr@@ [ Number ] ) goto LABEL_6 ; if ( * @@v3@@ ) goto LABEL_6 ; @@v5@@ = @@v4@@ ; if ( ( int ) @@v4@@ != @@v4@@ ) goto LABEL_6 ; if ( ( char ) ( ( @@v4@@ & Number ) + Number ) > Number ) @@v5@@ = @@v4@@ & Number ; @@v12@@ = @@v5@@ ; } if ( @@v5@@ < Number || ( unsigned int ) sig2str ( ( unsigned int ) @@v5@@ , @@a2@@ ) ) goto LABEL_6 ; return @@v12@@ ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
void __fastcall argmatch_invalid ( __int64 @@a1@@ , wchar_t * @@a2@@ , __int64 @@a3@@ ) { char * @@v3@@ ; __int64 @@v4@@ ; _BYTE * @@v5@@ ; if ( @@a3@@ == Number ) @@v3@@ = dcgettext ( Number L , String , Number ) ; else @@v3@@ = dcgettext ( Number L , String , Number ) ; @@v4@@ = quote_n ( Number L , @@a1@@ ) ; @@v5@@ = quotearg_n_style ( Number , Number , @@a2@@ ) ; error ( Number , Number , @@v3@@ , @@v5@@ , @@v4@@ ) ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 __fastcall dup_safer ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ , char @@a7@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ , @@a7@@ ) ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__locale_t newlocale ( int @@category_mask@@ , const char * @@locale@@ , __locale_t @@base@@ ) { return newlocale ( @@category_mask@@ , @@locale@@ , @@base@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
int __lxstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _lxstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_20C510 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20C4F0 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20C500 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
__int64 __fastcall fwrite_success_callback ( const void * @@a1@@ , size_t @@a2@@ , FILE * @@a3@@ ) { fwrite ( @@a1@@ , Number , @@a2@@ , @@a3@@ ) ; return Number L ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
__int64 __fastcall exit_failure_callback ( unsigned int @@a1@@ , const char * @@a2@@ ) { char * @@v2@@ ; char * @@v3@@ ; char * @@v5@@ ; if ( @@a2@@ ) { @@v2@@ = dcgettext ( Number L , @@a2@@ , Number ) ; @@v3@@ = dcgettext ( Number L , String , Number ) ; error ( Number , Number , @@v3@@ , @@a1@@ , @@v2@@ ) ; } else { @@v5@@ = dcgettext ( Number L , String , Number ) ; error ( Number , Number , @@v5@@ , @@a1@@ ) ; } return Number ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
char * __fastcall str_iconv ( char * @@s@@ , char * @@fromcode@@ , char * @@tocode@@ ) { char * @@v4@@ ; iconv_t @@v6@@ ; void * @@v7@@ ; int * @@v8@@ ; int @@v9@@ ; int * @@v10@@ ; int * @@v11@@ ; int @@v12@@ ; int * @@v13@@ ; if ( * @@s@@ && ( unsigned int ) c_strcasecmp ( ( unsigned __int8 * ) @@fromcode@@ , ( unsigned __int8 * ) @@tocode@@ ) ) { @@v6@@ = iconv_open ( @@tocode@@ , @@fromcode@@ ) ; @@v7@@ = @@v6@@ ; if ( @@v6@@ == ( iconv_t ) Number ) return Number L ; @@v4@@ = str_cd_iconv ( @@s@@ , @@v6@@ ) ; if ( @@v4@@ ) { if ( iconv_close ( @@v7@@ ) < Number ) { @@v8@@ = __errno_location ( ) ; @@v9@@ = * @@v8@@ ; @@v10@@ = @@v8@@ ; free ( @@v4@@ ) ; @@v4@@ = Number L ; * @@v10@@ = @@v9@@ ; } } else { @@v11@@ = __errno_location ( ) ; @@v12@@ = * @@v11@@ ; @@v13@@ = @@v11@@ ; iconv_close ( @@v7@@ ) ; * @@v13@@ = @@v12@@ ; } return @@v4@@ ; } @@v4@@ = strdup ( @@s@@ ) ; if ( @@v4@@ ) return @@v4@@ ; * __errno_location ( ) = Number ; return Number L ; }
__int64 __fastcall u8_uctomb_aux ( _BYTE * @@a1@@ , unsigned int @@a2@@ , int @@a3@@ ) { __int64 @@result@@ ; char @@v4@@ ; char @@v5@@ ; if ( @@a2@@ <= Number ) return Number L ; if ( @@a2@@ <= Number ) { if ( @@a3@@ > Number ) { @@result@@ = Number L ; goto LABEL_8 ; } return Number L ; } if ( @@a2@@ > Number ) { if ( @@a2@@ <= Number ) { if ( @@a3@@ > Number ) { @@v5@@ = @@a2@@ ; @@a2@@ = ( @@a2@@ >> Number ) | Number ; @@a1@@ [ Number ] = @@v5@@ & Number | Number ; @@result@@ = Number L ; goto LABEL_7 ; } return Number L ; } } else if ( @@a2@@ - Number > Number ) { if ( @@a3@@ > Number ) { @@result@@ = Number L ; LABEL_7 : @@v4@@ = @@a2@@ ; @@a2@@ = ( @@a2@@ >> Number ) | Number ; @@a1@@ [ Number ] = @@v4@@ & Number | Number ; LABEL_8 : * @@a1@@ = ( @@a2@@ >> Number ) | Number ; @@a1@@ [ Number ] = @@a2@@ & Number | Number ; return @@result@@ ; } return Number L ; } return Number ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
size_t __fastcall mbslen ( char * @@s@@ ) { __int64 @@i@@ ; int @@v3@@ ; wchar_t @@v4@@ ; size_t @@v5@@ ; size_t @@v6@@ ; size_t @@v7@@ ; size_t @@v8@@ ; char @@v9@@ ; mbstate_t @@v10@@ ; char @@v11@@ ; char * @@sa@@ ; size_t @@v13@@ ; char @@v14@@ ; wchar_t @@v15@@ [ Number ] ; unsigned __int64 @@v16@@ ; @@v16@@ = __readfsqword ( Number ) ; if ( __ctype_get_mb_cur_max ( ) > Number ) { @@sa@@ = @@s@@ ; @@v9@@ = Number ; @@v10@@ = Number L ; @@v11@@ = Number ; for ( @@i@@ = Number L ; ; ++ @@i@@ ) { if ( ! @@v9@@ ) { @@v3@@ = * ( ( _DWORD * ) & is_basic_table + ( ( ( unsigned __int8 ) * @@sa@@ >> Number ) & Number ) ) ; if ( _bittest ( & @@v3@@ , ( unsigned __int8 ) * @@sa@@ ) ) { @@v13@@ = Number L ; @@v4@@ = * @@sa@@ ; @@v14@@ = Number ; @@v11@@ = Number ; @@v15@@ [ Number ] = @@v4@@ ; goto LABEL_7 ; } if ( ! mbsinit ( & @@v10@@ ) ) __assert_fail ( String , String , Number , String ) ; @@v9@@ = Number ; } @@v5@@ = __ctype_get_mb_cur_max ( ) ; @@v6@@ = strnlen1 ( @@sa@@ , @@v5@@ ) ; @@v7@@ = mbrtowc ( @@v15@@ , @@sa@@ , @@v6@@ , & @@v10@@ ) ; @@v13@@ = @@v7@@ ; switch ( @@v7@@ ) { case Number : @@v13@@ = Number L ; @@v14@@ = Number ; goto LABEL_8 ; case Number : @@v8@@ = strlen ( @@sa@@ ) ; @@v14@@ = Number ; @@v13@@ = @@v8@@ ; goto LABEL_8 ; case Number : @@v13@@ = Number L ; if ( * @@sa@@ ) __assert_fail ( String , String , Number , String ) ; if ( @@v15@@ [ Number ] ) __assert_fail ( String , String , Number , String ) ; break ; } @@v14@@ = Number ; if ( mbsinit ( & @@v10@@ ) ) @@v9@@ = Number ; @@v11@@ = Number ; LABEL_7 : if ( ! @@v15@@ [ Number ] ) return @@i@@ ; LABEL_8 : @@sa@@ += @@v13@@ ; @@v11@@ = Number ; } } return strlen ( @@s@@ ) ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
long double __fastcall c_strtold ( char * @@nptr@@ , char * * @@endptr@@ ) { if ( ! c_locale_cache ) c_locale_cache = newlocale ( Number , String , Number L ) ; if ( c_locale_cache ) return strtold_l ( @@nptr@@ , @@endptr@@ , c_locale_cache ) ; if ( @@endptr@@ ) * @@endptr@@ = @@nptr@@ ; return Number ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@result@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ , @@v4@@ ) ; } return @@result@@ ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ , __int64 a3 , __int64 @@a4@@ ) { size_t @@v4@@ ; size_t @@v5@@ ; void * @@result@@ ; @@v4@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v4@@ > Number ) xalloc_die ( @@a1@@ , @@a2@@ , Number , @@a4@@ ) ; @@v5@@ = ( ( @@v4@@ + Number ) >> Number ) + @@v4@@ ; * @@a2@@ = @@v5@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v5@@ ) ; } else { if ( ! @@v4@@ ) @@v4@@ = Number L ; * @@a2@@ = @@v4@@ ; @@result@@ = xrealloc ( Number L , @@v4@@ ) ; } return @@result@@ ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; char * @@v9@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = setlocale ( Number , Number L ) ; if ( @@v9@@ ) { if ( strncmp ( @@v9@@ , String , Number ) ) { last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
int __fastcall argmatch_valid ( _QWORD * @@a1@@ , char * @@a2@@ , size_t @@a3@@ ) { const void * @@v5@@ ; __int64 @@v6@@ ; char * @@v7@@ ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; if ( * @@a1@@ ) { @@v5@@ = Number L ; @@v6@@ = Number L ; do { while ( ! @@v6@@ || memcmp ( @@v5@@ , @@a2@@ , @@a3@@ ) ) { ++ @@v6@@ ; @@v5@@ = @@a2@@ ; __fprintf_chk ( ) ; @@a2@@ += @@a3@@ ; if ( ! @@a1@@ [ @@v6@@ ] ) goto LABEL_7 ; } ++ @@v6@@ ; @@a2@@ += @@a3@@ ; __fprintf_chk ( ) ; } while ( @@a1@@ [ @@v6@@ ] ) ; } LABEL_7 : @@v7@@ = stderr -> _IO_write_ptr ; if ( @@v7@@ >= stderr -> _IO_write_end ) { LODWORD ( @@v7@@ ) = __overflow ( stderr , Number ) ; } else { stderr -> _IO_write_ptr = @@v7@@ + Number ; * @@v7@@ = Number ; } return ( int ) @@v7@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
unsigned __int64 __fastcall AD_hash ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) % @@a2@@ ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
unsigned __int64 __fastcall LCO_hash ( _QWORD * @@a1@@ , unsigned __int64 @@a2@@ ) { return * @@a1@@ % @@a2@@ ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_2061D0 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061B0 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061C0 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
__int64 __fastcall fts_compare_ino ( __int64 @@a1@@ , __int64 @@a2@@ ) { unsigned __int64 @@v2@@ ; __int64 @@result@@ ; @@v2@@ = * ( _QWORD * ) ( * ( _QWORD * ) @@a2@@ + Number L ) ; if ( * ( _QWORD * ) ( * ( _QWORD * ) @@a1@@ + Number L ) < @@v2@@ ) @@result@@ = Number ; else @@result@@ = * ( _QWORD * ) ( * ( _QWORD * ) @@a1@@ + Number L ) > @@v2@@ ; return @@result@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
__int64 __fastcall rpl_vfprintf ( FILE * @@s@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { char * @@v3@@ ; size_t @@v4@@ ; char * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; size_t @@n@@ ; char @@v11@@ [ Number ] ; unsigned __int64 @@v12@@ ; @@n@@ = Number L ; @@v12@@ = __readfsqword ( Number ) ; @@v3@@ = ( char * ) vasnprintf ( @@v11@@ , & @@n@@ , @@a2@@ , @@a3@@ ) ; @@v4@@ = @@n@@ ; if ( ! @@v3@@ ) goto LABEL_10 ; @@v5@@ = @@v3@@ ; if ( fwrite ( @@v3@@ , Number , @@n@@ , @@s@@ ) >= @@v4@@ ) { if ( @@v5@@ != @@v11@@ ) free ( @@v5@@ ) ; if ( @@v4@@ <= Number ) return ( unsigned int ) @@v4@@ ; * __errno_location ( ) = Number ; LABEL_10 : LODWORD ( @@v4@@ ) = Number ; fseterr ( @@s@@ ) ; return ( unsigned int ) @@v4@@ ; } LODWORD ( @@v4@@ ) = Number ; if ( @@v5@@ != @@v11@@ ) { @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; free ( @@v5@@ ) ; * @@v9@@ = @@v8@@ ; } return ( unsigned int ) @@v4@@ ; }
void __fastcall set_join_field ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; char * @@v3@@ ; @@v2@@ = * @@a1@@ ; if ( * @@a1@@ != Number && @@v2@@ != @@a2@@ ) { @@v3@@ = dcgettext ( Number L , String , Number ) ; error ( Number , Number , @@v3@@ , @@v2@@ + Number , @@a2@@ + Number ) ; } * @@a1@@ = @@a2@@ ; }
__int64 __fastcall fd_ring_clear ( __int64 @@a1@@ ) { int @@v1@@ ; __int64 @@result@@ ; while ( Number ) { @@result@@ = i_ring_empty ( @@a1@@ ) ; if ( ( _BYTE ) @@result@@ ) break ; @@v1@@ = i_ring_pop ( @@a1@@ ) ; if ( @@v1@@ >= Number ) close ( @@v1@@ ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
void __fastcall cwd_advance_fd ( __int64 @@a1@@ , int @@a2@@ , char @@a3@@ ) { int @@v4@@ ; int @@v5@@ ; @@v4@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; if ( @@v4@@ == @@a2@@ && @@v4@@ != Number ) abort ( ) ; if ( @@a3@@ ) { @@v5@@ = i_ring_push ( @@a1@@ + Number ) ; if ( @@v5@@ < Number ) { LABEL_6 : * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; return ; } close ( @@v5@@ ) ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; } else { if ( ( * ( _BYTE * ) ( @@a1@@ + Number ) & Number ) != Number || @@v4@@ < Number ) goto LABEL_6 ; close ( @@v4@@ ) ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; } }
int __fastcall prfield_isra_4 ( unsigned __int64 @@a1@@ , unsigned __int64 @@a2@@ , _QWORD * @@a3@@ ) { __int64 @@v3@@ ; size_t @@v4@@ ; int @@result@@ ; if ( @@a1@@ < @@a2@@ ) { @@v3@@ = * @@a3@@ + Number * @@a1@@ ; @@v4@@ = * ( _QWORD * ) ( @@v3@@ + Number ) ; if ( @@v4@@ ) return fwrite_unlocked ( * ( const void * * ) @@v3@@ , Number , @@v4@@ , stdout ) ; } if ( empty_filler ) @@result@@ = fputs_unlocked ( empty_filler , stdout ) ; return @@result@@ ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_2061D0 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061B0 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_2061C0 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
__int64 __fastcall enter_dir_isra_11 ( __int16 @@a1@@ , _QWORD * @@a2@@ , __int64 @@a3@@ ) { _QWORD * @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; __int64 @@result@@ ; if ( ( @@a1@@ & Number ) != Number ) { @@v4@@ = malloc ( Number ) ; if ( @@v4@@ ) { @@v5@@ = * ( _QWORD * ) ( @@a3@@ + Number ) ; @@v6@@ = * @@a2@@ ; @@v4@@ [ Number ] = @@a3@@ ; * @@v4@@ = @@v5@@ ; @@v4@@ [ Number ] = * ( _QWORD * ) ( @@a3@@ + Number ) ; @@v7@@ = hash_insert ( @@v6@@ , @@v4@@ ) ; if ( @@v4@@ == ( _QWORD * ) @@v7@@ ) return Number L ; free ( @@v4@@ ) ; if ( @@v7@@ ) { @@v8@@ = * ( _QWORD * ) ( @@v7@@ + Number ) ; * ( _WORD * ) ( @@a3@@ + Number ) = Number ; * ( _QWORD * ) @@a3@@ = @@v8@@ ; return Number L ; } } @@result@@ = Number L ; } else { @@result@@ = cycle_check ( * @@a2@@ , @@a3@@ + Number ) ; if ( ! ( _BYTE ) @@result@@ ) return Number L ; * ( _QWORD * ) @@a3@@ = @@a3@@ ; * ( _WORD * ) ( @@a3@@ + Number ) = Number ; } return @@result@@ ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
__int64 __fastcall hash_get_n_buckets ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
__int64 __fastcall hash_get_n_buckets_used ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
__int64 __fastcall getseq ( _BYTE * @@a1@@ , unsigned __int64 * @@a2@@ , unsigned int @@a3@@ ) { unsigned __int64 @@v4@@ ; __int64 @@v5@@ ; __int64 @@result@@ ; __int64 @@v7@@ ; unsigned __int64 @@v8@@ ; _QWORD * @@v9@@ ; _QWORD * @@v10@@ ; unsigned int @@v11@@ ; @@v4@@ = * @@a2@@ ; @@v5@@ = @@a2@@ [ Number ] ; if ( * @@a2@@ != @@a2@@ [ Number ] ) goto LABEL_2 ; if ( @@v5@@ ) { if ( @@v4@@ > Number ) xalloc_die ( ) ; @@v4@@ += ( @@v4@@ + Number ) >> Number ; goto LABEL_8 ; } if ( @@v4@@ ) { LABEL_8 : @@v7@@ = Number * @@v4@@ ; goto LABEL_9 ; } @@v7@@ = Number L ; @@v4@@ = Number L ; LABEL_9 : @@a2@@ [ Number ] = @@v4@@ ; @@v11@@ = @@a3@@ ; @@v5@@ = xrealloc ( @@v5@@ , @@v7@@ ) ; @@v4@@ = * @@a2@@ ; @@v8@@ = @@a2@@ [ Number ] ; @@a2@@ [ Number ] = @@v5@@ ; @@a3@@ = @@v11@@ ; if ( @@v4@@ < @@v8@@ ) { @@v9@@ = ( _QWORD * ) ( @@v5@@ + Number * @@v4@@ ) ; @@v10@@ = ( _QWORD * ) ( @@v5@@ + Number * @@v8@@ ) ; do * @@v9@@ ++ = Number L ; while ( @@v9@@ != @@v10@@ ) ; } LABEL_2 : @@result@@ = get_line ( @@a1@@ , ( _OWORD * * ) ( @@v5@@ + Number * @@v4@@ ) , @@a3@@ ) ; if ( ( _BYTE ) @@result@@ ) ++ * @@a2@@ ; return @@result@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void __fastcall initbuffer ( __int64 @@a1@@ ) { * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _OWORD * ) @@a1@@ = Number L ; }
__int64 __fastcall hash_get_n_entries ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
__int64 __fastcall vstrtoimax ( char * @@nptr@@ ) { __int64 @@v1@@ ; char * @@v3@@ ; char * @@v4@@ [ Number ] ; @@v4@@ [ Number ] = ( char * ) __readfsqword ( Number ) ; if ( * @@nptr@@ == Number || * @@nptr@@ == Number ) { @@v1@@ = ( unsigned __int8 ) @@nptr@@ [ Number ] ; if ( @@nptr@@ [ Number ] && ! posixly_correct ) { @@v3@@ = dcgettext ( Number L , String , Number ) ; error ( Number , Number , @@v3@@ , @@nptr@@ + Number ) ; } } else { * __errno_location ( ) = Number ; @@v1@@ = __strtol_internal ( @@nptr@@ , @@v4@@ , Number , Number ) ; verify_numeric ( @@nptr@@ , @@v4@@ [ Number ] ) ; } return @@v1@@ ; }
bool __fastcall hash_table_ok ( __int64 @@a1@@ ) { _QWORD * @@v1@@ ; unsigned __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; bool @@result@@ ; @@v1@@ = * ( _QWORD * * ) @@a1@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v3@@ = Number L ; @@v4@@ = Number L ; if ( * ( _QWORD * ) @@a1@@ < @@v2@@ ) { do { if ( * @@v1@@ ) { @@v5@@ = @@v1@@ [ Number ] ; ++ @@v4@@ ; ++ @@v3@@ ; for ( ; @@v5@@ ; ++ @@v3@@ ) @@v5@@ = * ( _QWORD * ) ( @@v5@@ + Number ) ; } @@v1@@ += Number ; } while ( ( unsigned __int64 ) @@v1@@ < @@v2@@ ) ; } @@result@@ = Number ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) == @@v4@@ ) @@result@@ = * ( _QWORD * ) ( @@a1@@ + Number ) == @@v3@@ ; return @@result@@ ; }
int __cdecl __noreturn main ( int @@argc@@ , const char * * @@argv@@ , const char * * @@envp@@ ) { const char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; char * @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; char * @@v10@@ ; int * @@v11@@ ; set_program_name ( * @@argv@@ , @@argv@@ , @@envp@@ ) ; setlocale ( Number , String ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; parse_long_options ( @@argc@@ , ( _DWORD ) @@argv@@ , ( unsigned int ) String , ( unsigned int ) & unk_3A7E , ( _DWORD ) Version , ( unsigned int ) usage , String , Number L ) ; if ( getopt_long ( @@argc@@ , ( char * const * ) @@argv@@ , String , Number L , Number L ) == Number ) { if ( optind + Number < @@argc@@ ) { if ( optind + Number >= @@argc@@ ) { if ( link ( @@argv@@ [ optind ] , @@argv@@ [ optind + Number ] ) ) { @@v8@@ = quote_n ( Number L , @@argv@@ [ optind ] ) ; @@v9@@ = quote_n ( Number L , @@argv@@ [ optind + Number ] ) ; @@v10@@ = dcgettext ( Number L , String , Number ) ; @@v11@@ = __errno_location ( ) ; error ( Number , * @@v11@@ , @@v10@@ , @@v9@@ , @@v8@@ ) ; } exit ( Number ) ; } @@v5@@ = quote ( @@argv@@ [ optind + Number ] ) ; @@v4@@ = String ; goto LABEL_5 ; } if ( optind < @@argc@@ ) { @@v4@@ = String ; @@v5@@ = quote ( @@argv@@ [ optind ] ) ; LABEL_5 : @@v6@@ = dcgettext ( Number L , @@v4@@ , Number ) ; error ( Number , Number , @@v6@@ , @@v5@@ ) ; goto LABEL_6 ; } @@v7@@ = dcgettext ( Number L , String , Number ) ; error ( Number , Number , @@v7@@ ) ; } LABEL_6 : usage ( Number ) ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
_QWORD * __fastcall readlinebuffer_delim ( _QWORD * @@a1@@ , _IO_FILE * @@a2@@ , char @@a3@@ ) { __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ ; int @@v7@@ ; char * @@v8@@ ; int @@v9@@ ; char @@v10@@ ; _BYTE * @@v11@@ ; __int64 @@v12@@ ; __int64 @@v13@@ ; __int64 @@v14@@ ; char * @@v15@@ ; _QWORD * @@result@@ ; int @@v17@@ ; char @@v18@@ ; __int64 @@v19@@ ; char @@v20@@ ; char @@v21@@ ; @@v3@@ = @@a1@@ [ Number ] ; @@v4@@ = @@v3@@ + * @@a1@@ ; if ( ( @@a2@@ -> _flags & Number ) == Number ) { @@v6@@ = @@a1@@ [ Number ] ; @@v7@@ = @@a3@@ ; while ( Number ) { @@v8@@ = @@a2@@ -> _IO_read_ptr ; if ( @@v8@@ >= @@a2@@ -> _IO_read_end ) { @@v21@@ = @@a3@@ ; @@v19@@ = @@v4@@ ; @@v17@@ = __uflow ( @@a2@@ ) ; @@v9@@ = @@v17@@ ; @@v4@@ = @@v19@@ ; @@a3@@ = @@v21@@ ; if ( @@v17@@ == Number ) { if ( @@v3@@ == @@v6@@ || ( @@a2@@ -> _flags & Number ) != Number ) return Number L ; if ( * ( _BYTE * ) ( @@v6@@ - Number ) == @@v21@@ ) { LABEL_8 : @@result@@ = @@a1@@ ; @@a1@@ [ Number ] = @@v6@@ - @@v3@@ ; return @@result@@ ; } @@v9@@ = @@v7@@ ; @@v10@@ = @@v21@@ ; } else { @@v10@@ = @@v17@@ ; } } else { @@a2@@ -> _IO_read_ptr = @@v8@@ + Number ; @@v9@@ = ( unsigned __int8 ) * @@v8@@ ; @@v10@@ = * @@v8@@ ; } @@v11@@ = ( _BYTE * ) @@v6@@ ; if ( @@v6@@ == @@v4@@ ) { @@v12@@ = * @@a1@@ ; @@v20@@ = @@a3@@ ; @@v18@@ = @@v10@@ ; @@v13@@ = x2realloc ( @@v3@@ , @@a1@@ ) ; @@v14@@ = * @@a1@@ ; @@v15@@ = ( char * ) ( @@v13@@ + @@v12@@ ) ; @@a1@@ [ Number ] = @@v13@@ ; @@v3@@ = @@v13@@ ; @@a3@@ = @@v20@@ ; @@v6@@ = @@v13@@ + @@v12@@ + Number ; @@v4@@ = @@v13@@ + @@v14@@ ; * @@v15@@ = @@v18@@ ; if ( @@v9@@ == @@v7@@ ) goto LABEL_8 ; } else { ++ @@v6@@ ; * @@v11@@ = @@v10@@ ; if ( @@v9@@ == @@v7@@ ) goto LABEL_8 ; } } } return Number L ; }
__int64 __fastcall print_unicode_char ( __int64 @@a1@@ , unsigned int @@a2@@ , int @@a3@@ ) { bool @@v3@@ ; __int64 ( __fastcall * @@v4@@ ) ( unsigned int , const char * ) ; @@v3@@ = @@a3@@ == Number ; @@v4@@ = exit_failure_callback ; if ( @@v3@@ ) @@v4@@ = ( __int64 ( __fastcall * ) ( unsigned int , const char * ) ) fallback_failure_callback ; return unicode_to_mb ( @@a2@@ , ( __int64 ( __fastcall * ) ( char * , size_t , __int64 ) ) fwrite_success_callback , ( __int64 ( __fastcall * ) ( _QWORD , const char * , __int64 ) ) @@v4@@ , @@a1@@ ) ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
unsigned __int64 __fastcall hash_get_entries ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { _QWORD * @@v3@@ ; unsigned __int64 @@v4@@ ; _QWORD * @@v5@@ ; unsigned __int64 @@result@@ ; @@v3@@ = * ( _QWORD * * ) @@a1@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= * ( _QWORD * ) @@a1@@ ) return Number L ; @@v4@@ = Number L ; while ( ! * @@v3@@ ) { LABEL_9 : @@v3@@ += Number ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= ( unsigned __int64 ) @@v3@@ ) return @@v4@@ ; } if ( @@a3@@ <= @@v4@@ ) return @@v4@@ ; * ( _QWORD * ) ( @@a2@@ + Number * @@v4@@ ) = * @@v3@@ ; @@v5@@ = ( _QWORD * ) @@v3@@ [ Number ] ; @@result@@ = @@v4@@ + Number ; if ( ! @@v5@@ ) { LABEL_8 : @@v4@@ = @@result@@ ; goto LABEL_9 ; } while ( @@a3@@ != @@result@@ ) { ++ @@result@@ ; * ( _QWORD * ) ( @@a2@@ + Number * @@result@@ - Number ) = * @@v5@@ ; @@v5@@ = ( _QWORD * ) @@v5@@ [ Number ] ; if ( ! @@v5@@ ) goto LABEL_8 ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
__int64 __fastcall i_ring_empty ( __int64 @@a1@@ ) { return * ( unsigned __int8 * ) ( @@a1@@ + Number ) ; }
bool __fastcall hard_locale ( int @@a1@@ ) { char * @@v1@@ ; bool @@result@@ ; @@v1@@ = setlocale ( @@a1@@ , Number L ) ; @@result@@ = Number ; if ( @@v1@@ ) { @@result@@ = Number ; if ( strcmp ( @@v1@@ , String ) ) @@result@@ = strcmp ( @@v1@@ , String ) != Number ; } return @@result@@ ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
__int64 __fastcall i_ring_push ( __int64 @@a1@@ , int @@a2@@ ) { char @@v2@@ ; int @@v3@@ ; _DWORD * @@v4@@ ; __int64 @@result@@ ; int @@v6@@ ; @@v2@@ = * ( _BYTE * ) ( @@a1@@ + Number ) ^ Number ; @@v3@@ = ( @@v2@@ + ( unsigned __int8 ) * ( _DWORD * ) ( @@a1@@ + Number ) ) & Number ; @@v4@@ = ( _DWORD * ) ( @@a1@@ + Number L * ( ( @@v2@@ + ( unsigned __int8 ) * ( _DWORD * ) ( @@a1@@ + Number ) ) & Number ) ) ; @@result@@ = ( unsigned int ) * @@v4@@ ; * @@v4@@ = @@a2@@ ; @@v6@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@v3@@ ; if ( @@v6@@ == @@v3@@ ) * ( _DWORD * ) ( @@a1@@ + Number ) = ( ( _BYTE ) @@v6@@ + @@v2@@ ) & Number ; * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; return @@result@@ ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall xvfprintf ( FILE * @@stream@@ ) { int @@v1@@ ; char * @@v3@@ ; int * @@v4@@ ; @@v1@@ = rpl_vfprintf ( @@stream@@ ) ; if ( @@v1@@ < Number && ! ferror ( @@stream@@ ) ) { @@v3@@ = dcgettext ( Number L , String , Number ) ; @@v4@@ = __errno_location ( ) ; error ( exit_failure , * @@v4@@ , @@v3@@ ) ; } return ( unsigned int ) @@v1@@ ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall openat_safer ( int @@a1@@ , const char * @@a2@@ , char @@a3@@ , unsigned int @@a4@@ ) { __int64 @@v4@@ ; int @@v5@@ ; @@v4@@ = Number L ; if ( ( @@a3@@ & Number ) != Number ) @@v4@@ = @@a4@@ ; @@v5@@ = openat ( @@a1@@ , @@a2@@ , @@a3@@ , @@v4@@ ) ; return fd_safer ( @@v5@@ ) ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_2061F0 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061D0 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061E0 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_20B1F0 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20B1D0 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20B1E0 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; __int64 @@v14@@ ; __int64 @@v15@@ ; __int64 @@v16@@ ; __int64 @@v17@@ ; unsigned __int64 @@v18@@ ; _BYTE * @@v19@@ ; unsigned __int64 @@v22@@ ; int @@v23@@ ; int @@v24@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v23@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v24@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v22@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v24@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v22@@ <= @@v13@@ ) { @@v18@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v19@@ = ( _BYTE * ) xmalloc ( @@v18@@ , @@v18@@ , @@v14@@ , @@v15@@ , @@v16@@ , @@v17@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v19@@ ; @@v12@@ = @@v19@@ ; quotearg_buffer_restyled ( @@v19@@ , @@v18@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v24@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v23@@ ; return @@v12@@ ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_2092D0 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2092B0 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2092C0 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
int fflush_unlocked ( FILE * @@stream@@ ) { return fflush_unlocked ( @@stream@@ ) ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
bool __fastcall test_unop_part_1 ( __int64 @@a1@@ ) { bool @@result@@ ; @@result@@ = Number ; if ( ( unsigned __int8 ) ( * ( _BYTE * ) ( @@a1@@ + Number ) - Number ) <= Number ) @@result@@ = ( ( Number L << ( * ( _BYTE * ) ( @@a1@@ + Number ) - Number ) ) & Number ) != Number ; return @@result@@ ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_20E210 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20E1F0 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20E200 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
__int64 __fastcall set_cloexec_flag ( int @@a1@@ , char @@a2@@ , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { int @@v6@@ ; int @@v7@@ ; int @@v8@@ ; int @@v9@@ ; int @@v10@@ ; unsigned int @@v11@@ ; __int64 @@result@@ ; @@v6@@ = rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( @@v6@@ < Number ) return Number ; @@v9@@ = @@v6@@ ; @@v10@@ = @@v6@@ | Number ; @@v11@@ = @@v9@@ & Number ; if ( @@a2@@ ) @@v11@@ = @@v10@@ ; @@result@@ = Number L ; if ( @@v11@@ != @@v9@@ ) @@result@@ = ( unsigned int ) - ( ( unsigned int ) rpl_fcntl ( @@a1@@ , Number , @@v11@@ , @@v9@@ , @@v7@@ , @@v8@@ ) == Number ) ; return @@result@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
struct dirent * readdir ( DIR * @@dirp@@ ) { return readdir ( @@dirp@@ ) ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
DIR * fdopendir ( int @@fd@@ ) { return fdopendir ( @@fd@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall ignorable_failure ( unsigned int @@a1@@ , const char * @@a2@@ ) { unsigned int @@v2@@ ; int @@v3@@ ; int @@v4@@ ; DIR * @@v5@@ ; int * @@v6@@ ; struct dirent * @@v7@@ ; char @@v8@@ ; if ( ignore_fail_on_non_empty ) { LOBYTE ( @@v2@@ ) = @@a1@@ == Number || @@a1@@ == Number ; if ( ( _BYTE ) @@v2@@ ) return @@v2@@ ; if ( @@a1@@ <= Number && ( ( Number L << @@a1@@ ) & Number ) != Number ) { @@v3@@ = openat ( Number , @@a2@@ , Number ) ; @@v4@@ = @@v3@@ ; if ( @@v3@@ >= Number ) { @@v5@@ = fdopendir ( @@v3@@ ) ; if ( @@v5@@ ) { @@v6@@ = __errno_location ( ) ; * @@v6@@ = Number ; while ( Number ) { @@v7@@ = readdir ( @@v5@@ ) ; if ( ! @@v7@@ ) break ; if ( @@v7@@ -> d_name [ Number ] == Number ) { @@v8@@ = @@v7@@ -> d_name [ ( @@v7@@ -> d_name [ Number ] == Number ) + Number ] ; if ( ! @@v8@@ || @@v8@@ == Number ) continue ; } closedir ( @@v5@@ ) ; return @@v2@@ ; } @@v2@@ = * @@v6@@ ; closedir ( @@v5@@ ) ; LOBYTE ( @@v2@@ ) = @@v2@@ == Number ; } else { close ( @@v4@@ ) ; } return @@v2@@ ; } } } return Number L ; }
int iswalnum ( wint_t @@wc@@ ) { return iswalnum ( @@wc@@ ) ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
int iswspace ( wint_t @@wc@@ ) { return iswspace ( @@wc@@ ) ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; FILE * @@v11@@ ; char * @@v12@@ ; FILE * @@v13@@ ; char * @@v14@@ ; char * @@v15@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String String String String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String String String String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = stdout ; @@v10@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; @@v11@@ = stdout ; @@v12@@ = dcgettext ( Number L , String String String String String String , Number ) ; fputs_unlocked ( @@v12@@ , @@v11@@ ) ; last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v13@@ = stdout ; @@v14@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v14@@ , @@v13@@ ) ; @@v15@@ = setlocale ( Number , Number L ) ; if ( @@v15@@ ) { if ( strncmp ( @@v15@@ , String , Number ) ) { last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
char __fastcall two_arguments ( ) { bool @@v0@@ ; bool @@v1@@ ; const char * @@v2@@ ; __int64 @@v3@@ ; const char * @@v4@@ ; __int64 @@v5@@ ; const char * @@v6@@ ; __int64 @@v7@@ ; char @@result@@ ; _BYTE * @@v9@@ ; @@v2@@ = String ; @@v3@@ = Number L ; @@v4@@ = * ( const char * * ) ( argv + Number L * pos ) ; @@v5@@ = Number L * pos ; @@v6@@ = @@v4@@ ; do { if ( ! @@v3@@ ) break ; @@v0@@ = * @@v6@@ < ( unsigned int ) * @@v2@@ ; @@v1@@ = * @@v6@@ ++ == * @@v2@@ ++ ; -- @@v3@@ ; } while ( @@v1@@ ) ; if ( ( ! @@v0@@ && ! @@v1@@ ) == @@v0@@ ) { @@v9@@ = * ( _BYTE * * ) ( argv + @@v5@@ + Number ) ; pos += Number ; @@result@@ = * @@v9@@ == Number ; } else { if ( * @@v4@@ != Number || ! @@v4@@ [ Number ] || @@v4@@ [ Number ] ) beyond ( @@v2@@ , @@v6@@ , pos , @@v3@@ , argv , @@v5@@ ) ; @@v7@@ = * ( _QWORD * ) ( argv + Number L * pos ) ; if ( ! test_unop_part_1 ( @@v7@@ ) ) { dcgettext ( Number L , String , Number ) ; test_syntax_error ( ) ; } @@result@@ = unary_operator ( @@v7@@ , @@v6@@ ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
int ferror ( FILE * @@stream@@ ) { return ferror ( @@stream@@ ) ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
_BYTE * __fastcall find_int ( _BYTE * @@a1@@ ) { const unsigned __int16 * @@v1@@ ; _BYTE * @@result@@ ; __int64 @@v3@@ ; char * @@v4@@ ; unsigned __int8 * @@v5@@ ; int @@i@@ ; @@v1@@ = * __ctype_b_loc ( ) ; for ( @@result@@ = @@a1@@ ; ; ++ @@result@@ ) { @@v3@@ = ( unsigned __int8 ) * @@result@@ ; if ( ( @@v1@@ [ @@v3@@ ] & Number ) == Number ) break ; } if ( ( _BYTE ) @@v3@@ == Number ) @@v4@@ = ++ @@result@@ ; else @@v4@@ = & @@result@@ [ * @@result@@ == Number ] ; @@v5@@ = ( unsigned __int8 * ) ( @@v4@@ + Number ) ; if ( ( unsigned int ) ( * @@v4@@ - Number ) > Number ) goto LABEL_14 ; for ( @@i@@ = @@v4@@ [ Number ] ; ( unsigned int ) ( @@i@@ - Number ) <= Number ; @@i@@ = ( char ) * @@v5@@ ) { ++ @@v5@@ ; } if ( ( @@v1@@ [ ( unsigned __int8 ) @@i@@ ] & Number ) != Number ) { do LOBYTE ( @@i@@ ) = * ++ @@v5@@ ; while ( ( @@v1@@ [ * @@v5@@ ] & Number ) != Number ) ; } if ( ( _BYTE ) @@i@@ ) { LABEL_14 : quote ( @@a1@@ ) ; dcgettext ( Number L , String , Number ) ; test_syntax_error ( ) ; } return @@result@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
void __fastcall verify_numeric ( const char * @@a1@@ , const char * @@a2@@ ) { int @@v3@@ ; char * @@v4@@ ; const char * @@v5@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@v3@@ ) { error ( Number , @@v3@@ , String , @@a1@@ ) ; exit_status = Number ; } else if ( * @@a2@@ ) { if ( @@a2@@ == @@a1@@ ) { @@v4@@ = dcgettext ( Number L , String , Number ) ; @@v5@@ = @@a2@@ ; } else { @@v4@@ = dcgettext ( Number L , String , Number ) ; @@v5@@ = @@a1@@ ; } error ( Number , Number , @@v4@@ , @@v5@@ ) ; exit_status = Number ; } }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_2081D0 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2081B0 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2081C0 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
__int64 __fastcall unicode_to_mb ( unsigned int @@a1@@ , __int64 ( __fastcall * @@a2@@ ( ) ( constchar , sizet , void ) ) ( char * , size_t , __int64 ) , __int64 ( __fastcall * @@a3@@ ( ) ( unsignedint , constchar , void ) ) ( _QWORD , const char * , __int64 ) , __int64 @@a4@@ ) { int @@v7@@ ; __int64 @@result@@ ; size_t @@v9@@ ; int @@v10@@ ; const char * @@v11@@ ; bool @@v12@@ ; size_t @@v13@@ ; char * @@inbuf@@ ; size_t @@inbytesleft@@ ; char * @@outbuf@@ ; size_t @@outbytesleft@@ ; char @@v18@@ [ Number ] ; char @@v19@@ [ Number ] ; unsigned __int64 @@v20@@ ; @@v20@@ = __readfsqword ( Number ) ; if ( initialized_3686 ) { @@v7@@ = is_utf8_3687 ; } else { @@v11@@ = ( const char * ) locale_charset ( ) ; @@v12@@ = strcmp ( @@v11@@ , String ) == Number ; @@v7@@ = @@v12@@ ; is_utf8_3687 = @@v7@@ ; if ( ! @@v12@@ ) { utf8_to_local_3688 = iconv_open ( @@v11@@ , String ) ; if ( utf8_to_local_3688 == ( iconv_t ) Number ) utf8_to_local_3688 = iconv_open ( String , String ) ; @@v7@@ = is_utf8_3687 ; } initialized_3686 = Number ; } if ( ! @@v7@@ && utf8_to_local_3688 == ( iconv_t ) Number ) return @@a3@@ ( ) ( unsignedint , constchar , void ) ( @@a1@@ , String , @@a4@@ ) ; if ( @@a1@@ > Number ) { @@v10@@ = u8_uctomb_aux ( @@v18@@ , @@a1@@ , Number L ) ; if ( @@v10@@ < Number ) return @@a3@@ ( ) ( unsignedint , constchar , void ) ( @@a1@@ , String , @@a4@@ ) ; @@v7@@ = is_utf8_3687 ; @@v9@@ = @@v10@@ ; } else { @@v18@@ [ Number ] = @@a1@@ ; @@v9@@ = Number L ; } if ( @@v7@@ ) return @@a2@@ ( ) ( constchar , sizet , void ) ( @@v18@@ , @@v9@@ , @@a4@@ ) ; @@inbuf@@ = @@v18@@ ; @@inbytesleft@@ = @@v9@@ ; @@outbuf@@ = @@v19@@ ; @@outbytesleft@@ = Number L ; @@v13@@ = iconv ( utf8_to_local_3688 , & @@inbuf@@ , & @@inbytesleft@@ , & @@outbuf@@ , & @@outbytesleft@@ ) ; if ( @@inbytesleft@@ || @@v13@@ == Number || iconv ( utf8_to_local_3688 , Number L , Number L , & @@outbuf@@ , & @@outbytesleft@@ ) == Number ) { @@result@@ = @@a3@@ ( ) ( unsignedint , constchar , void ) ( @@a1@@ , Number L , @@a4@@ ) ; } else { @@result@@ = @@a2@@ ( ) ( constchar , sizet , void ) ( @@v19@@ , @@outbuf@@ - @@v19@@ , @@a4@@ ) ; } return @@result@@ ; }
__int64 __fastcall str2sig ( char * @@s2@@ , _DWORD * @@a2@@ ) { __int64 @@v3@@ ; const char * @@v5@@ ; __int64 @@v7@@ ; int @@v8@@ ; int @@v9@@ ; int @@v10@@ ; char * @@v11@@ [ Number ] ; @@v3@@ = Number L ; @@v5@@ = nptr ; @@v11@@ [ Number ] = ( char * ) __readfsqword ( Number ) ; if ( ( unsigned int ) ( * @@s2@@ - Number ) > Number ) { do { if ( ! strcmp ( @@v5@@ , @@s2@@ ) ) { LODWORD ( @@v7@@ ) = * ( ( _DWORD * ) & numname_table + Number * @@v3@@ ) ; goto LABEL_6 ; } @@v3@@ = ( unsigned int ) ( @@v3@@ + Number ) ; @@v5@@ += Number ; } while ( ( _DWORD ) @@v3@@ != Number ) ; @@v8@@ = __libc_current_sigrtmin ( ) ; @@v9@@ = __libc_current_sigrtmax ( ) ; @@v10@@ = @@v9@@ ; if ( @@v8@@ > Number && ! memcmp ( @@s2@@ , String , Number ) ) { @@v7@@ = strtol ( @@s2@@ + Number , @@v11@@ , Number ) ; if ( * @@v11@@ [ Number ] || @@v7@@ < Number || @@v7@@ > @@v10@@ - @@v8@@ ) { goto LABEL_9 ; } LODWORD ( @@v7@@ ) = @@v8@@ + @@v7@@ ; } else { if ( @@v9@@ <= Number ) goto LABEL_9 ; if ( memcmp ( @@s2@@ , String , Number ) ) goto LABEL_9 ; @@v7@@ = strtol ( @@s2@@ + Number , @@v11@@ , Number ) ; if ( * @@v11@@ [ Number ] || @@v7@@ < @@v8@@ - @@v10@@ || @@v7@@ > Number ) { goto LABEL_9 ; } LODWORD ( @@v7@@ ) = @@v10@@ + @@v7@@ ; } LABEL_6 : * @@a2@@ = @@v7@@ ; return ( unsigned int ) ( ( int ) @@v7@@ >> Number ) ; } @@v7@@ = strtol ( @@s2@@ , @@v11@@ , Number ) ; if ( ! * @@v11@@ [ Number ] && @@v7@@ <= Number ) goto LABEL_6 ; LABEL_9 : * @@a2@@ = Number ; return Number ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
__int64 __fastcall umaxtostr ( unsigned __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; @@v2@@ = @@a2@@ + Number ; * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; do { * ( _BYTE * ) -- @@v2@@ = @@a1@@ % Number + Number ; @@a1@@ /= Number ; } while ( @@a1@@ ) ; return @@v2@@ ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; char * @@v7@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String String String String String String String String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = setlocale ( Number , Number L ) ; if ( @@v7@@ ) { if ( strncmp ( @@v7@@ , String , Number ) ) { last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
char * nl_langinfo ( nl_item @@item@@ ) { return nl_langinfo ( @@item@@ ) ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
int __fxstatat ( int @@ver@@ , int @@fildes@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ , int @@flag@@ ) { return _fxstatat ( @@ver@@ , @@fildes@@ , @@filename@@ , @@stat_buf@@ , @@flag@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
int fileno ( FILE * @@stream@@ ) { return fileno ( @@stream@@ ) ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
int fflush ( FILE * @@stream@@ ) { return fflush ( @@stream@@ ) ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
int __fastcall cleanup ( int @@sig@@ ) { int @@v1@@ ; _DWORD * @@v2@@ ; @@v1@@ = @@sig@@ ; if ( @@sig@@ == Number ) { @@v1@@ = term_signal ; timed_out = Number ; } if ( ! monitored_pid ) _exit ( @@v1@@ + Number ) ; @@v2@@ = sigs_to_ignore ; if ( sigs_to_ignore [ @@v1@@ ] ) { sigs_to_ignore [ @@v1@@ ] = Number ; } else { sigs_to_ignore [ @@v1@@ ] = Number ; LODWORD ( @@v2@@ ) = kill ( Number , @@v1@@ ) ; if ( @@v1@@ != Number && @@v1@@ != Number ) { dword_20C2E8 = Number ; LODWORD ( @@v2@@ ) = kill ( Number , Number ) ; } } return ( int ) @@v2@@ ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_20B1F0 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20B1D0 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_20B1E0 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
DIR * fdopendir ( int @@fd@@ ) { return fdopendir ( @@fd@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
const char * __fastcall proper_name ( char * @@s@@ ) { char * @@v1@@ ; const char * @@v2@@ ; size_t @@v4@@ ; size_t @@v5@@ ; __int64 @@v6@@ ; @@v1@@ = dcgettext ( Number L , @@s@@ , Number ) ; @@v2@@ = @@v1@@ ; if ( @@s@@ == @@v1@@ || ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@v1@@ , ( __int64 ) @@s@@ ) ) { return @@v2@@ ; } @@v4@@ = strlen ( @@v2@@ ) ; @@v5@@ = strlen ( @@s@@ ) ; @@v6@@ = xmalloc ( @@v4@@ + @@v5@@ + Number ) ; __sprintf_chk ( ) ; return ( const char * ) @@v6@@ ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
size_t __fastcall strnlen1 ( const void * @@a1@@ , size_t @@a2@@ ) { _BYTE * @@v2@@ ; __int64 @@v3@@ ; bool @@v4@@ ; size_t @@result@@ ; @@v2@@ = memchr ( @@a1@@ , Number , @@a2@@ ) ; @@v3@@ = @@v2@@ - ( _BYTE * ) @@a1@@ + Number ; @@v4@@ = @@v2@@ == Number L ; @@result@@ = @@a2@@ ; if ( ! @@v4@@ ) @@result@@ = @@v3@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) _frame_dummy_init_array_entry [ @@i@@ ] ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; FILE * @@v11@@ ; char * @@v12@@ ; FILE * @@v13@@ ; char * @@v14@@ ; FILE * @@v15@@ ; char * @@v16@@ ; FILE * @@v17@@ ; char * @@v18@@ ; char * @@v19@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String String String String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String String String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = stdout ; @@v10@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; @@v11@@ = stdout ; @@v12@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v12@@ , @@v11@@ ) ; @@v13@@ = stdout ; @@v14@@ = dcgettext ( Number L , String String String , Number ) ; fputs_unlocked ( @@v14@@ , @@v13@@ ) ; dcgettext ( Number L , String String String String String String , Number ) ; __printf_chk ( ) ; @@v15@@ = stdout ; @@v16@@ = dcgettext ( Number L , String String String String , Number ) ; fputs_unlocked ( @@v16@@ , @@v15@@ ) ; last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v17@@ = stdout ; @@v18@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v18@@ , @@v17@@ ) ; @@v19@@ = setlocale ( Number , Number L ) ; if ( @@v19@@ ) { if ( strncmp ( @@v19@@ , String , Number ) ) { last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
__int64 __fastcall argmatch_to_argument ( void * @@s1@@ , __int64 * @@a2@@ , char * @@a3@@ , size_t @@a4@@ ) { __int64 @@v4@@ ; __int64 * @@v7@@ ; @@v4@@ = * @@a2@@ ; if ( * @@a2@@ ) { @@v7@@ = @@a2@@ + Number ; do { if ( ! memcmp ( @@s1@@ , @@a3@@ , @@a4@@ ) ) break ; @@v4@@ = * @@v7@@ ; @@a3@@ += @@a4@@ ; ++ @@v7@@ ; } while ( @@v4@@ ) ; } return @@v4@@ ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
void __fastcall close_stdin_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 __fastcall knuth_morris_pratt_unibyte ( unsigned __int8 * @@a1@@ , const char * @@a2@@ , unsigned __int8 * * @@a3@@ ) { const char * @@v4@@ ; size_t @@v6@@ ; void * @@v7@@ ; __int64 * @@v8@@ ; __int64 @@v9@@ ; __int64 @@i@@ ; char @@v11@@ ; __int64 @@v12@@ ; unsigned __int8 * @@v13@@ ; __int64 @@v14@@ ; __int64 @@v16@@ ; @@v4@@ = @@a2@@ ; @@v6@@ = strlen ( @@a2@@ ) ; if ( @@v6@@ > Number ) return Number L ; if ( Number * @@v6@@ > Number ) { @@v8@@ = ( __int64 * ) mmalloca ( ) ; } else { @@v7@@ = alloca ( Number * @@v6@@ + Number ) ; @@v8@@ = & @@v16@@ ; } if ( ! @@v8@@ ) return Number L ; @@v8@@ [ Number ] = Number L ; if ( @@v6@@ > Number ) { @@v9@@ = Number L ; for ( @@i@@ = Number L ; @@i@@ != @@v6@@ ; ++ @@i@@ ) { @@v11@@ = @@a2@@ [ @@i@@ - Number ] ; if ( @@v11@@ == @@a2@@ [ @@v9@@ ] ) { LABEL_23 : ++ @@v9@@ ; @@v8@@ [ @@i@@ ] = @@i@@ - @@v9@@ ; } else { while ( @@v9@@ ) { @@v9@@ -= @@v8@@ [ @@v9@@ ] ; if ( @@v11@@ == @@a2@@ [ @@v9@@ ] ) goto LABEL_23 ; } @@v8@@ [ @@i@@ ] = @@i@@ ; @@v9@@ = Number L ; } } } * @@a3@@ = Number L ; @@v12@@ = * @@a1@@ ; @@v13@@ = @@a1@@ ; @@v14@@ = Number L ; LABEL_14 : while ( Number ) { if ( ( _BYTE ) @@v12@@ ) { while ( @@v4@@ [ @@v14@@ ] != ( _BYTE ) @@v12@@ ) { if ( ! @@v14@@ ) { @@v12@@ = @@v13@@ [ Number ] ; ++ @@a1@@ ; ++ @@v13@@ ; goto LABEL_14 ; } @@a2@@ = ( const char * ) @@v8@@ [ @@v14@@ ] ; @@a1@@ = & @@a1@@ [ ( _QWORD ) @@a2@@ ] ; @@v14@@ -= ( __int64 ) @@a2@@ ; } ++ @@v14@@ ; @@a2@@ = ( const char * ) ( @@v13@@ + Number ) ; if ( @@v6@@ != @@v14@@ ) { @@v12@@ = * ++ @@v13@@ ; continue ; } * @@a3@@ = @@a1@@ ; } break ; } freea ( @@v8@@ , @@a2@@ , @@v12@@ , @@v13@@ ) ; return Number L ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name_0 = @@a1@@ ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
int group_member ( __gid_t @@gid@@ ) { return group_member ( @@gid@@ ) ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
DIR * opendir ( const char * @@name@@ ) { return opendir ( @@name@@ ) ; }
int __fastcall rpl_fflush ( FILE * @@stream@@ ) { if ( ! @@stream@@ || ! __freading ( @@stream@@ ) || ( @@stream@@ -> _flags & Number ) == Number ) { return fflush ( @@stream@@ ) ; } rpl_fseeko ( @@stream@@ , Number L , Number ) ; return fflush ( @@stream@@ ) ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_2061F0 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061D0 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061E0 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
__int64 __fastcall sig2str ( int @@a1@@ , char * @@a2@@ ) { __int64 @@v2@@ ; _DWORD * @@v3@@ ; int @@v5@@ ; int @@v6@@ ; @@v2@@ = Number L ; @@v3@@ = & numname_table ; do { if ( * @@v3@@ == @@a1@@ ) { strcpy ( @@a2@@ , ( const char * ) & numname_table + Number * @@v2@@ + Number ) ; return Number L ; } @@v2@@ = ( unsigned int ) ( @@v2@@ + Number ) ; @@v3@@ += Number ; } while ( ( _DWORD ) @@v2@@ != Number ) ; @@v5@@ = __libc_current_sigrtmin ( ) ; @@v6@@ = __libc_current_sigrtmax ( ) ; if ( @@v5@@ > @@a1@@ || @@v6@@ < @@a1@@ ) return Number ; __sprintf_chk ( ) ; return Number L ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
char * __fastcall file_type ( __int64 @@a1@@ ) { int @@v1@@ ; char * @@result@@ ; @@v1@@ = * ( _DWORD * ) ( @@a1@@ + Number ) & Number ; switch ( @@v1@@ ) { case Number : if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) @@result@@ = dcgettext ( Number L , String , Number ) ; else @@result@@ = dcgettext ( Number L , String , Number ) ; break ; case Number : @@result@@ = dcgettext ( Number L , String , Number ) ; break ; case Number : @@result@@ = dcgettext ( Number L , String , Number ) ; break ; case Number : @@result@@ = dcgettext ( Number L , String , Number ) ; break ; case Number : @@result@@ = dcgettext ( Number L , String , Number ) ; break ; case Number : @@result@@ = dcgettext ( Number L , String , Number ) ; break ; case Number : @@result@@ = dcgettext ( Number L , String , Number ) ; break ; default : @@result@@ = dcgettext ( Number L , String , Number ) ; break ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
int __xstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _xstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
int fchdir ( int @@fd@@ ) { return fchdir ( @@fd@@ ) ; }
bool __fastcall setup_dir_isra_4 ( __int16 @@a1@@ , __int64 * @@a2@@ ) { __int64 @@v2@@ ; bool @@result@@ ; void * @@v4@@ ; if ( ( @@a1@@ & Number ) != Number ) { @@v2@@ = hash_initialize ( Number L , Number L , AD_hash , AD_compare , & free ) ; * @@a2@@ = @@v2@@ ; @@result@@ = @@v2@@ != Number ; } else { @@v4@@ = malloc ( Number ) ; * @@a2@@ = ( __int64 ) @@v4@@ ; @@result@@ = Number ; if ( @@v4@@ ) { cycle_check_init ( ) ; @@result@@ = Number ; } } return @@result@@ ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_2061F0 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061D0 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_2061E0 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
__int64 __fastcall c_strcasecmp ( unsigned __int8 * @@a1@@ , unsigned __int8 * @@a2@@ ) { __int64 @@result@@ ; int @@v3@@ ; int @@v4@@ ; @@result@@ = Number L ; if ( @@a1@@ != @@a2@@ ) { do { @@v3@@ = * @@a1@@ ; if ( ( unsigned int ) ( @@v3@@ - Number ) < Number ) LOBYTE ( @@v3@@ ) = @@v3@@ + Number ; @@v4@@ = * @@a2@@ ; if ( ( unsigned int ) ( @@v4@@ - Number ) < Number ) LOBYTE ( @@v4@@ ) = @@v4@@ + Number ; if ( ! ( _BYTE ) @@v3@@ ) break ; ++ @@a1@@ ; ++ @@a2@@ ; } while ( ( _BYTE ) @@v3@@ == ( _BYTE ) @@v4@@ ) ; @@result@@ = ( unsigned __int8 ) @@v3@@ - ( unsigned int ) ( unsigned __int8 ) @@v4@@ ; } return @@result@@ ; }
unsigned __int64 __fastcall leave_dir_isra_14 ( __int16 @@a1@@ , __int64 * * @@a2@@ , _QWORD * @@a3@@ ) { __int64 * @@v3@@ ; __int64 * @@v4@@ ; __int64 * @@v6@@ ; void * @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v11@@ = __readfsqword ( Number ) ; if ( ( @@a1@@ & Number ) != Number ) { @@v6@@ = * @@a2@@ ; @@v10@@ [ Number ] = @@a3@@ [ Number ] ; @@v10@@ [ Number ] = @@a3@@ [ Number ] ; @@v7@@ = ( void * ) hash_delete ( @@v6@@ , @@v10@@ ) ; if ( @@v7@@ ) { free ( @@v7@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; } goto LABEL_11 ; } @@v3@@ = ( __int64 * ) @@a3@@ [ Number ] ; if ( ! @@v3@@ || @@v3@@ [ Number ] < Number ) return __readfsqword ( Number ) ^ @@v11@@ ; @@v4@@ = * @@a2@@ ; if ( ! ( * @@a2@@ ) [ Number ] ) LABEL_11 : abort ( ) ; if ( * @@v4@@ == @@a3@@ [ Number ] && @@v4@@ [ Number ] == @@a3@@ [ Number ] ) { @@v8@@ = @@v3@@ [ Number ] ; @@v9@@ = @@v3@@ [ Number ] ; @@v4@@ [ Number ] = @@v8@@ ; * @@v4@@ = @@v9@@ ; } return __readfsqword ( Number ) ^ @@v11@@ ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__int64 __fastcall hash_print_statistics ( __int64 @@a1@@ ) { unsigned __int64 @@v1@@ ; _QWORD * @@v2@@ ; unsigned __int64 @@i@@ ; __int64 @@v4@@ ; unsigned __int64 @@j@@ ; @@v1@@ = Number L ; @@v2@@ = * ( _QWORD * * ) @@a1@@ ; for ( @@i@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; ( unsigned __int64 ) @@v2@@ < @@i@@ ; @@v2@@ += Number ) { if ( * @@v2@@ ) { @@v4@@ = @@v2@@ [ Number ] ; for ( @@j@@ = Number L ; @@v4@@ ; ++ @@j@@ ) @@v4@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; if ( @@v1@@ < @@j@@ ) @@v1@@ = @@j@@ ; } } __fprintf_chk ( ) ; __fprintf_chk ( ) ; __fprintf_chk ( ) ; return __fprintf_chk ( ) ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; program_invocation_short_name = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
__int64 __fastcall hash_get_next ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; __int64 * @@v6@@ ; _QWORD * @@v7@@ ; __int64 @@v8@@ ; __int64 @@result@@ ; @@v2@@ = * @@a1@@ ; @@v4@@ = ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) ; @@v5@@ = @@a1@@ [ Number ] ; @@v6@@ = ( __int64 * ) ( @@v2@@ + Number * @@v4@@ ) ; if ( @@v5@@ <= ( unsigned __int64 ) @@v6@@ ) abort ( ) ; if ( ! @@v6@@ ) goto LABEL_10 ; @@v7@@ = ( _QWORD * ) @@v6@@ [ Number ] ; if ( * @@v6@@ != @@a2@@ ) { do { if ( ! @@v7@@ ) goto LABEL_10 ; @@v8@@ = * @@v7@@ ; @@v7@@ = ( _QWORD * ) @@v7@@ [ Number ] ; } while ( @@v8@@ != @@a2@@ ) ; } if ( @@v7@@ ) return * @@v7@@ ; LABEL_10 : while ( Number ) { @@v6@@ += Number ; if ( @@v5@@ <= ( unsigned __int64 ) @@v6@@ ) break ; @@result@@ = * @@v6@@ ; if ( * @@v6@@ ) return @@result@@ ; } return Number L ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
void __fastcall freea ( unsigned __int64 @@a1@@ ) { __int64 @@v1@@ ; __int64 @@v2@@ ; _QWORD * @@v3@@ ; if ( @@a1@@ ) { if ( * ( _DWORD * ) ( @@a1@@ - Number ) == Number ) { @@v1@@ = mmalloca_results [ @@a1@@ % Number ] ; if ( @@v1@@ ) { if ( @@v1@@ == @@a1@@ ) { @@v3@@ = & mmalloca_results [ @@a1@@ % Number ] ; LABEL_12 : * @@v3@@ = * ( _QWORD * ) ( @@a1@@ - Number ) ; free ( ( void * ) ( @@a1@@ - Number ) ) ; } else { while ( Number ) { @@v2@@ = * ( _QWORD * ) ( @@v1@@ - Number ) ; if ( ! @@v2@@ ) break ; if ( @@a1@@ == @@v2@@ ) { @@v3@@ = ( _QWORD * ) ( @@v1@@ - Number ) ; goto LABEL_12 ; } @@v1@@ = * ( _QWORD * ) ( @@v1@@ - Number ) ; } } } } } }
void __fastcall hash_free ( void * @@ptr@@ ) { _QWORD * @@v2@@ ; unsigned __int64 @@v3@@ ; _QWORD * @@v4@@ ; _QWORD * @@v5@@ ; _QWORD * @@v6@@ ; _QWORD * @@v7@@ ; _QWORD * @@v8@@ ; @@v2@@ = * ( _QWORD * * ) @@ptr@@ ; @@v3@@ = * ( ( _QWORD * ) @@ptr@@ + Number ) ; if ( * ( ( _QWORD * ) @@ptr@@ + Number ) && * ( ( _QWORD * ) @@ptr@@ + Number ) ) { if ( ( unsigned __int64 ) @@v2@@ >= @@v3@@ ) goto LABEL_14 ; do { if ( * @@v2@@ ) { @@v4@@ = @@v2@@ ; do { ( * ( ( void ( * * ) ( void ) ) @@ptr@@ + Number ) ) ( ) ; @@v4@@ = ( _QWORD * ) @@v4@@ [ Number ] ; } while ( @@v4@@ ) ; @@v3@@ = * ( ( _QWORD * ) @@ptr@@ + Number ) ; } @@v2@@ += Number ; } while ( @@v3@@ > ( unsigned __int64 ) @@v2@@ ) ; @@v2@@ = * ( _QWORD * * ) @@ptr@@ ; } if ( ( unsigned __int64 ) @@v2@@ < @@v3@@ ) { do { @@v5@@ = ( _QWORD * ) @@v2@@ [ Number ] ; if ( @@v5@@ ) { do { @@v6@@ = ( _QWORD * ) @@v5@@ [ Number ] ; free ( @@v5@@ ) ; @@v5@@ = @@v6@@ ; } while ( @@v6@@ ) ; } @@v2@@ += Number ; } while ( * ( ( _QWORD * ) @@ptr@@ + Number ) > ( unsigned __int64 ) @@v2@@ ) ; } LABEL_14 : @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@ptr@@ + Number ) ; if ( @@v7@@ ) { do { @@v8@@ = ( _QWORD * ) @@v7@@ [ Number ] ; free ( @@v7@@ ) ; @@v7@@ = @@v8@@ ; } while ( @@v8@@ ) ; } free ( * ( void * * ) @@ptr@@ ) ; free ( @@ptr@@ ) ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall _xargmatch_internal ( __int64 @@a1@@ , const char * @@a2@@ , const char * * @@a3@@ , char * @@a4@@ , size_t @@a5@@ , void ( * @@a6@@ ) ( void ) ) { __int64 @@result@@ ; @@result@@ = argmatch ( @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; if ( @@result@@ < Number ) { argmatch_invalid ( @@a1@@ , ( __int64 ) @@a2@@ , @@result@@ ) ; argmatch_valid ( @@a3@@ , @@a4@@ , @@a5@@ ) ; @@a6@@ ( ) ; @@result@@ = Number ; } return @@result@@ ; }
int __lxstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _lxstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
int isatty ( int @@fd@@ ) { return isatty ( @@fd@@ ) ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
int dirfd ( DIR * @@dirp@@ ) { return dirfd ( @@dirp@@ ) ; }
int __lxstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _lxstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
struct dirent * readdir ( DIR * @@dirp@@ ) { return readdir ( @@dirp@@ ) ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
int __fxstat ( int @@ver@@ , int @@fildes@@ , struct stat * @@stat_buf@@ ) { return _fxstat ( @@ver@@ , @@fildes@@ , @@stat_buf@@ ) ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall xnanosleep ( double @@a1@@ ) { __int64 @@v1@@ ; char @@v2@@ ; signed __int64 @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; unsigned __int64 @@v8@@ ; @@v8@@ = __readfsqword ( Number ) ; if ( @@a1@@ < Number ) __assert_fail ( String , String , Number , String ) ; if ( @@a1@@ > Number ) { @@v2@@ = Number ; } else { @@v1@@ = ( unsigned int ) ( int ) @@a1@@ ; @@v6@@ = @@v1@@ ; @@v2@@ = Number ; @@v3@@ = ( unsigned int ) ( int ) ( ( @@a1@@ - ( double ) ( int ) @@v1@@ ) * Number ) + ( unsigned __int64 ) ( ( @@a1@@ - ( double ) ( int ) @@v1@@ ) * Number > ( double ) ( int ) ( ( @@a1@@ - ( double ) ( int ) @@v1@@ ) * Number ) ) ; @@v7@@ = @@v3@@ ; if ( @@v3@@ > Number ) { @@v6@@ = @@v1@@ + Number ; @@v7@@ = @@v3@@ - Number ; } } @@v4@@ = __errno_location ( ) ; while ( Number ) { if ( @@v2@@ ) { @@v6@@ = Number ; @@v7@@ = Number L ; } * @@v4@@ = Number ; @@result@@ = rpl_nanosleep ( & @@v6@@ , Number L ) ; if ( ! ( _DWORD ) @@result@@ ) break ; if ( ( * @@v4@@ & Number ) != Number ) return Number ; } return @@result@@ ; }
void free ( void * @@ptr@@ ) { __imp_free ( @@ptr@@ ) ; }
int __fastcall rpl_fseeko ( FILE * @@stream@@ , __off_t @@offset@@ , int @@whence@@ ) { int @@v5@@ ; int @@v6@@ ; if ( @@stream@@ -> _IO_read_end != @@stream@@ -> _IO_read_ptr || @@stream@@ -> _IO_write_ptr != @@stream@@ -> _IO_write_base || @@stream@@ -> _IO_save_base ) { return fseeko ( @@stream@@ , @@offset@@ , @@whence@@ ) ; } if ( @@whence@@ == Number && @@offset@@ > Number ) { @@v5@@ = fileno ( @@stream@@ ) ; if ( lseek ( @@v5@@ , Number L , Number ) != Number ) { @@stream@@ -> _flags &= Number ; return fseeko ( @@stream@@ , @@offset@@ , @@whence@@ ) ; } } else { @@v6@@ = fileno ( @@stream@@ ) ; if ( lseek ( @@v6@@ , @@offset@@ , @@whence@@ ) != Number ) { @@stream@@ -> _flags &= Number ; return Number ; } } return Number ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
int __cdecl __noreturn main ( int @@argc@@ , const char * * @@argv@@ , const char * * envp ) { unsigned __int8 @@v3@@ ; __int64 @@v4@@ ; char * @@v5@@ ; char * @@v6@@ ; const char * @@v7@@ ; set_program_name ( * @@argv@@ ) ; setlocale ( Number , String ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; exit_failure = Number ; atexit ( close_stdout ) ; argv = ( __int64 ) @@argv@@ ; if ( @@argc@@ == Number ) { @@v7@@ = @@argv@@ [ Number ] ; if ( ! strcmp ( @@v7@@ , String ) ) usage ( Number ) ; if ( ! strcmp ( @@v7@@ , String ) ) { version_etc ( ( _DWORD ) stdout , ( unsigned int ) String , ( unsigned int ) & unk_539C , ( _DWORD ) Version , ( unsigned int ) String , ( unsigned int ) String , Number ) ; exit ( Number ) ; } if ( ! strcmp ( @@v7@@ , String ) ) { argc = Number ; pos = Number ; exit ( Number ) ; } } else if ( @@argc@@ > Number && ! strcmp ( @@argv@@ [ @@argc@@ - Number ] , String ) ) { pos = Number ; argc = @@argc@@ - Number ; @@v3@@ = posixtest ( ( unsigned int ) ( @@argc@@ - Number ) ) ; if ( pos != argc ) { @@v4@@ = quote ( * ( _QWORD * ) ( argv + Number L * pos ) ) ; @@v5@@ = dcgettext ( Number L , String , Number ) ; test_syntax_error ( @@v5@@ , @@v4@@ ) ; } exit ( @@v3@@ ^ Number ) ; } @@v6@@ = dcgettext ( Number L , String , Number ) ; test_syntax_error ( @@v6@@ , Number L ) ; }
bool __fastcall xstrtod ( __int64 @@a1@@ , _QWORD * @@a2@@ , double * @@a3@@ , void ( __fastcall * @@a4@@ ( ) ( constchar , char ) ) ( __int64 , __int64 * ) , double @@a5@@ ) { int * @@v7@@ ; bool @@result@@ ; __int64 @@v9@@ [ Number ] ; @@v9@@ [ Number ] = __readfsqword ( Number ) ; @@v7@@ = __errno_location ( ) ; * @@v7@@ = Number ; @@a4@@ ( ) ( constchar , char ) ( @@a1@@ , @@v9@@ ) ; if ( @@v9@@ [ Number ] == @@a1@@ ) { @@result@@ = Number ; } else { if ( @@a2@@ ) { @@result@@ = Number ; if ( @@a5@@ == Number ) { LABEL_6 : * @@a2@@ = @@v9@@ [ Number ] ; goto LABEL_7 ; } } else { @@result@@ = Number ; if ( * ( _BYTE * ) @@v9@@ [ Number ] ) goto LABEL_7 ; if ( @@a5@@ == Number ) { @@result@@ = Number ; goto LABEL_7 ; } } @@result@@ = * @@v7@@ != Number ; } if ( @@a2@@ ) goto LABEL_6 ; LABEL_7 : * @@a3@@ = @@a5@@ ; return @@result@@ ; }
__int64 __fastcall excise ( __int64 @@a1@@ , __int64 @@a2@@ , _BYTE * @@a3@@ , char @@a4@@ ) { const char * @@v8@@ ; int @@v9@@ ; __int64 @@result@@ ; int * @@v11@@ ; int @@v12@@ ; __int64 @@v13@@ ; char * @@v14@@ ; _QWORD * @@i@@ ; struct stat @@v16@@ ; unsigned __int64 @@v17@@ ; @@v8@@ = * ( const char * * ) ( @@a2@@ + Number ) ; @@v9@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; @@v17@@ = __readfsqword ( Number ) ; if ( unlinkat ( @@v9@@ , @@v8@@ , ( @@a4@@ != Number ) << Number ) ) { @@v11@@ = __errno_location ( ) ; @@v12@@ = * @@v11@@ ; if ( * @@v11@@ == Number ) { if ( __fxstatat ( Number , * ( _DWORD * ) ( @@a1@@ + Number ) , * ( const char * * ) ( @@a2@@ + Number ) , & @@v16@@ , Number ) && * @@v11@@ == Number ) { @@result@@ = Number L ; if ( * @@a3@@ ) return @@result@@ ; } else { * @@v11@@ = Number ; } } else if ( * @@a3@@ && ( @@v12@@ == Number || @@v12@@ == Number ) ) { return Number L ; } if ( * ( _WORD * ) ( @@a2@@ + Number ) == Number ) * @@v11@@ = * ( _DWORD * ) ( @@a2@@ + Number ) ; @@v13@@ = quote ( * ( _QWORD * ) ( @@a2@@ + Number ) ) ; @@v14@@ = dcgettext ( Number L , String , Number ) ; error ( Number , * @@v11@@ , @@v14@@ , @@v13@@ ) ; for ( @@i@@ = * ( _QWORD * * ) ( @@a2@@ + Number ) ; ( __int64 ) @@i@@ [ Number ] >= Number ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { if ( @@i@@ [ Number ] ) break ; @@i@@ [ Number ] = Number L ; } @@result@@ = Number L ; } else { @@result@@ = Number L ; if ( @@a3@@ [ Number ] ) { quote ( * ( _QWORD * ) ( @@a2@@ + Number ) ) ; if ( @@a4@@ ) dcgettext ( Number L , String , Number ) ; else dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@result@@ = Number L ; } } return @@result@@ ; }
char can_write_any_file ( ) { char @@result@@ ; __uid_t @@v1@@ ; if ( initialized_2987 ) return can_write_2988 ; @@v1@@ = geteuid ( ) ; initialized_2987 = Number ; @@result@@ = @@v1@@ == Number ; can_write_2988 = @@result@@ ; return @@result@@ ; }
char * __fastcall fts_alloc ( __int64 @@a1@@ , const void * @@a2@@ , size_t @@a3@@ ) { char * @@v4@@ ; char * @@v5@@ ; __int64 @@v6@@ ; @@v4@@ = ( char * ) malloc ( @@a3@@ + Number ) ; @@v5@@ = @@v4@@ ; if ( @@v4@@ ) { memcpy ( @@v4@@ + Number , @@a2@@ , @@a3@@ ) ; @@v6@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v5@@ [ @@a3@@ + Number ] = Number ; * ( ( _QWORD * ) @@v5@@ + Number ) = @@a3@@ ; * ( ( _QWORD * ) @@v5@@ + Number ) = @@a1@@ ; * ( ( _DWORD * ) @@v5@@ + Number ) = Number ; * ( _DWORD * ) ( @@v5@@ + Number ) = Number ; * ( ( _QWORD * ) @@v5@@ + Number ) = @@v6@@ ; * ( ( _QWORD * ) @@v5@@ + Number ) = Number L ; * ( ( _QWORD * ) @@v5@@ + Number ) = Number L ; } return @@v5@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
void __fastcall argmatch_invalid ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v3@@ ; __int64 @@v4@@ ; char * @@v5@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; if ( @@a3@@ == Number ) @@v5@@ = dcgettext ( Number L , String , Number ) ; else @@v5@@ = dcgettext ( Number L , String , Number ) ; @@v6@@ = quote_n ( Number L , @@a1@@ , @@v3@@ , @@v4@@ ) ; @@v7@@ = quotearg_n_style ( Number L , Number L , @@a2@@ ) ; error ( Number , Number , @@v5@@ , @@v7@@ , @@v6@@ ) ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
__int64 __fastcall fts_palloc_isra_2 ( void * * @@a1@@ , size_t * @@a2@@ , __int64 @@a3@@ ) { void * @@v4@@ ; size_t @@v5@@ ; void * @@v6@@ ; __int64 @@result@@ ; @@v4@@ = * @@a1@@ ; @@v5@@ = * @@a2@@ + @@a3@@ + Number ; if ( * @@a2@@ > @@v5@@ ) { free ( @@v4@@ ) ; * @@a1@@ = Number L ; * __errno_location ( ) = Number ; @@result@@ = Number L ; } else { * @@a2@@ = @@v5@@ ; @@v6@@ = realloc ( @@v4@@ , @@v5@@ ) ; if ( @@v6@@ ) { * @@a1@@ = @@v6@@ ; @@result@@ = Number L ; } else { free ( * @@a1@@ ) ; * @@a1@@ = Number L ; @@result@@ = Number L ; } } return @@result@@ ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
__int64 __fastcall xfts_open ( const char * * @@a1@@ , int @@a2@@ , __int64 @@a3@@ ) { __int64 @@result@@ ; @@result@@ = fts_open ( @@a1@@ , @@a2@@ | Number , @@a3@@ ) ; if ( ! @@result@@ ) { if ( * __errno_location ( ) != Number ) xalloc_die ( ) ; __assert_fail ( String , String , Number , String ) ; } return @@result@@ ; }
unsigned __int64 __fastcall next_prime ( unsigned __int64 @@a1@@ ) { unsigned __int64 @@v1@@ ; unsigned __int64 @@v2@@ ; __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; if ( @@a1@@ < Number ) @@a1@@ = Number L ; @@v1@@ = @@a1@@ | Number ; if ( @@v1@@ != Number ) { while ( Number ) { @@v2@@ = @@v1@@ % Number ; if ( @@v1@@ <= Number ) goto LABEL_9 ; if ( @@v1@@ % Number ) break ; LABEL_10 : @@v1@@ += Number L ; if ( @@v1@@ == Number ) return @@v1@@ ; } @@v3@@ = Number L ; @@v4@@ = Number L ; @@v5@@ = Number L ; while ( Number ) { @@v5@@ += Number L ; @@v4@@ += @@v3@@ ; @@v2@@ = @@v1@@ % @@v5@@ ; if ( @@v4@@ >= @@v1@@ ) break ; @@v3@@ += Number L ; if ( ! ( @@v1@@ % @@v5@@ ) ) goto LABEL_10 ; } LABEL_9 : if ( @@v2@@ ) return @@v1@@ ; goto LABEL_10 ; } return @@v1@@ ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
bool __fastcall AD_compare ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@result@@ ; @@result@@ = Number ; if ( @@a1@@ [ Number ] == @@a2@@ [ Number ] ) @@result@@ = * @@a1@@ == * @@a2@@ ; return @@result@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
__int64 __fastcall freadahead ( __int64 @@a1@@ ) { __int64 @@result@@ ; @@result@@ = Number L ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= * ( _QWORD * ) ( @@a1@@ + Number ) ) { @@result@@ = * ( _QWORD * ) ( @@a1@@ + Number ) - * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( ( * ( _DWORD * ) @@a1@@ & Number ) != Number ) @@result@@ += * ( _QWORD * ) ( @@a1@@ + Number ) - * ( _QWORD * ) ( @@a1@@ + Number ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
unsigned __int64 __fastcall hash_get_max_bucket_length ( __int64 @@a1@@ ) { _QWORD * @@v1@@ ; unsigned __int64 @@v2@@ ; unsigned __int64 @@result@@ ; __int64 @@v4@@ ; unsigned __int64 @@i@@ ; @@v1@@ = * ( _QWORD * * ) @@a1@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; for ( @@result@@ = Number L ; ( unsigned __int64 ) @@v1@@ < @@v2@@ ; @@v1@@ += Number ) { if ( * @@v1@@ ) { @@v4@@ = @@v1@@ [ Number ] ; for ( @@i@@ = Number L ; @@v4@@ ; ++ @@i@@ ) @@v4@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; if ( @@result@@ < @@i@@ ) @@result@@ = @@i@@ ; } } return @@result@@ ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
__int64 __fastcall fts_stat ( __int64 @@a1@@ , __int64 @@a2@@ , char @@a3@@ ) { struct stat * @@v4@@ ; bool @@v5@@ ; int @@v6@@ ; const char * @@v7@@ ; int * @@v8@@ ; int @@v9@@ ; int * @@v10@@ ; __int64 @@result@@ ; int @@v12@@ ; __int64 @@v13@@ ; @@v4@@ = ( struct stat * ) ( @@a2@@ + Number ) ; @@v5@@ = * ( _QWORD * ) ( @@a2@@ + Number ) == Number L ; @@v6@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; @@v7@@ = * ( const char * * ) ( @@a2@@ + Number ) ; if ( @@v5@@ && ( @@v6@@ & Number ) != Number || ( @@v6@@ & Number ) != Number || @@a3@@ ) { if ( ! __xstat ( Number , @@v7@@ , @@v4@@ ) ) goto LABEL_11 ; @@v8@@ = __errno_location ( ) ; @@v9@@ = * @@v8@@ ; @@v10@@ = @@v8@@ ; if ( * @@v8@@ == Number && ! __lxstat ( Number , * ( const char * * ) ( @@a2@@ + Number ) , @@v4@@ ) ) { * @@v10@@ = Number ; return Number L ; } * ( _DWORD * ) ( @@a2@@ + Number ) = @@v9@@ ; LABEL_6 : * ( _QWORD * ) ( @@a2@@ + Number ) = Number L ; @@v4@@ -> __unused [ Number ] = Number L ; memset ( ( void * ) ( ( unsigned __int64 ) & @@v4@@ -> st_ino & Number ) , Number , Number L * ( ( ( unsigned int ) @@v4@@ - ( ( ( _DWORD ) @@v4@@ + Number ) & Number ) + Number ) >> Number ) ) ; return Number L ; } if ( __fxstatat ( Number , * ( _DWORD * ) ( @@a1@@ + Number ) , @@v7@@ , @@v4@@ , Number ) ) { * ( _DWORD * ) ( @@a2@@ + Number ) = * __errno_location ( ) ; goto LABEL_6 ; } LABEL_11 : @@v12@@ = * ( _DWORD * ) ( @@a2@@ + Number ) & Number ; if ( @@v12@@ == Number ) { @@v13@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( ( * ( _BYTE * ) ( @@a1@@ + Number ) & Number ) == Number ) @@v13@@ -= Number L ; @@v5@@ = * ( _BYTE * ) ( @@a2@@ + Number ) == Number ; * ( _QWORD * ) ( @@a2@@ + Number ) = @@v13@@ ; @@result@@ = Number L ; if ( @@v5@@ && ( ! * ( _BYTE * ) ( @@a2@@ + Number ) || ( * ( _DWORD * ) ( @@a2@@ + Number ) & Number ) == Number ) ) { @@result@@ = * ( _QWORD * ) ( @@a2@@ + Number ) == Number L ? Number : Number ; } } else if ( @@v12@@ == Number ) { @@result@@ = Number L ; } else { @@result@@ = Number * ( unsigned int ) ( @@v12@@ == Number ) + Number ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
__int64 __fastcall rpl_fcntl ( int @@a1@@ , int @@a2@@ , __int64 @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { int @@v6@@ ; int @@v8@@ ; int @@v9@@ ; int @@v10@@ ; int @@v11@@ ; int * @@v12@@ ; int @@v13@@ ; int * @@v14@@ ; int @@v15@@ ; @@v15@@ = @@a3@@ ; if ( @@a2@@ != Number ) return ( unsigned int ) fcntl ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( have_dupfd_cloexec_3202 < Number ) { @@v6@@ = rpl_fcntl ( @@a1@@ , Number , ( unsigned int ) @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( @@v6@@ < Number || have_dupfd_cloexec_3202 != Number ) return ( unsigned int ) @@v6@@ ; } else { @@v6@@ = fcntl ( @@a1@@ , Number , ( unsigned int ) @@a3@@ ) ; if ( @@v6@@ >= Number || * __errno_location ( ) != Number ) { have_dupfd_cloexec_3202 = Number ; return ( unsigned int ) @@v6@@ ; } @@v6@@ = rpl_fcntl ( @@a1@@ , Number , @@v15@@ , @@v8@@ , @@v9@@ , @@v10@@ ) ; if ( @@v6@@ < Number ) return ( unsigned int ) @@v6@@ ; have_dupfd_cloexec_3202 = Number ; } @@v11@@ = fcntl ( @@v6@@ , Number ) ; if ( @@v11@@ < Number || fcntl ( @@v6@@ , Number , @@v11@@ | Number ) == Number ) { @@v12@@ = __errno_location ( ) ; @@v13@@ = * @@v12@@ ; @@v14@@ = @@v12@@ ; close ( @@v6@@ ) ; @@v6@@ = Number ; * @@v14@@ = @@v13@@ ; } return ( unsigned int ) @@v6@@ ; }
__int64 __fastcall hash_lookup ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; _QWORD * @@v4@@ ; __int64 @@v5@@ ; @@v2@@ = * @@a1@@ ; @@v4@@ = ( _QWORD * ) ( Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) + @@v2@@ ) ; if ( @@a1@@ [ Number ] <= ( unsigned __int64 ) @@v4@@ ) abort ( ) ; @@v5@@ = * @@v4@@ ; if ( ! * @@v4@@ ) return Number L ; while ( @@v5@@ != @@a2@@ ) { if ( ( ( unsigned __int8 ( __fastcall * ) ( __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ ) ) return * @@v4@@ ; @@v4@@ = ( _QWORD * ) @@v4@@ [ Number ] ; if ( ! @@v4@@ ) return Number L ; @@v5@@ = * @@v4@@ ; } return @@v5@@ ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
__int64 __fastcall check_tuning_isra_0 ( float * * @@a1@@ ) { float * @@v1@@ ; __int64 @@result@@ ; float @@v3@@ ; float @@v4@@ ; float @@v5@@ ; @@v1@@ = * @@a1@@ ; @@result@@ = Number L ; if ( * @@a1@@ != ( float * ) & default_tuning ) { @@v3@@ = @@v1@@ [ Number ] ; if ( @@v3@@ <= Number || @@v3@@ >= Number || @@v1@@ [ Number ] <= Number || * @@v1@@ < Number || ( @@v4@@ = * @@v1@@ + Number , @@v5@@ = @@v1@@ [ Number ] , @@v5@@ <= @@v4@@ ) || @@v5@@ > Number || @@v3@@ <= @@v4@@ ) { * @@a1@@ = ( float * ) & default_tuning ; @@result@@ = Number L ; } } return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
__int64 __fastcall hash_do_for_each ( __int64 @@a1@@ , unsigned __int8 ( __fastcall * @@a2@@ ) ( __int64 , __int64 ) , __int64 @@a3@@ ) { __int64 * @@v3@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 * @@v8@@ ; @@v3@@ = * ( __int64 * * ) @@a1@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= * ( _QWORD * ) @@a1@@ ) return Number L ; @@v6@@ = Number L ; while ( Number ) { @@v7@@ = * @@v3@@ ; if ( * @@v3@@ ) break ; LABEL_8 : @@v3@@ += Number ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= ( unsigned __int64 ) @@v3@@ ) return @@v6@@ ; } @@v8@@ = @@v3@@ ; while ( @@a2@@ ( @@v7@@ , @@a3@@ ) ) { @@v8@@ = ( __int64 * ) @@v8@@ [ Number ] ; ++ @@v6@@ ; if ( ! @@v8@@ ) goto LABEL_8 ; @@v7@@ = * @@v8@@ ; } return @@v6@@ ; }
int __fastcall rpl_nanosleep ( __time_t * @@a1@@ , struct timespec * @@a2@@ ) { __time_t @@v2@@ ; int @@result@@ ; __syscall_slong_t @@v4@@ ; __time_t @@v5@@ ; bool @@v6@@ ; __syscall_slong_t @@v7@@ ; struct timespec @@v8@@ ; unsigned __int64 @@v9@@ ; @@v2@@ = * @@a1@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v8@@ . tv_nsec = Number L ; if ( @@v2@@ > Number ) { while ( Number ) { @@v8@@ . tv_sec = Number L ; @@v2@@ -= Number L ; @@result@@ = nanosleep ( & @@v8@@ , @@a2@@ ) ; if ( @@result@@ ) break ; if ( @@v2@@ <= Number ) goto LABEL_8 ; } if ( @@a2@@ ) { @@v4@@ = @@a2@@ -> tv_nsec + @@a1@@ [ Number ] ; @@v5@@ = @@a2@@ -> tv_sec + @@v2@@ ; @@a2@@ -> tv_nsec = @@v4@@ ; @@v6@@ = @@a1@@ [ Number ] <= Number ; @@a2@@ -> tv_sec = @@v5@@ ; if ( ! @@v6@@ ) { @@a2@@ -> tv_sec = @@v5@@ + Number ; @@a2@@ -> tv_nsec = @@v4@@ - Number ; } } } else { LABEL_8 : @@v7@@ = @@a1@@ [ Number ] ; @@v8@@ . tv_sec = @@v2@@ ; @@v8@@ . tv_nsec = @@v7@@ ; @@result@@ = nanosleep ( & @@v8@@ , @@a2@@ ) ; } return @@result@@ ; }
__int64 __fastcall hash_get_first ( __int64 @@a1@@ ) { __int64 * @@v1@@ ; unsigned __int64 @@v2@@ ; __int64 @@result@@ ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; @@v1@@ = * ( __int64 * * ) @@a1@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( * ( _QWORD * ) @@a1@@ >= @@v2@@ ) goto LABEL_9 ; @@result@@ = * @@v1@@ ; if ( ! * @@v1@@ ) { while ( Number ) { @@v1@@ += Number ; if ( ( unsigned __int64 ) @@v1@@ >= @@v2@@ ) break ; @@result@@ = * @@v1@@ ; if ( * @@v1@@ ) return @@result@@ ; } LABEL_9 : abort ( ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
void __fastcall i_ring_init ( __int64 @@a1@@ , int @@a2@@ ) { * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
unsigned __int64 __fastcall hash_string ( unsigned __int8 * @@a1@@ , unsigned __int64 @@a2@@ ) { __int64 @@v2@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@v4@@ ; @@v2@@ = * @@a1@@ ; for ( @@i@@ = Number L ; ( _BYTE ) @@v2@@ ; @@i@@ = @@v4@@ % @@a2@@ ) { ++ @@a1@@ ; @@v4@@ = @@v2@@ + Number * @@i@@ ; @@v2@@ = * @@a1@@ ; } return @@i@@ ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
__int64 __fastcall i_ring_pop ( __int64 @@a1@@ ) { _DWORD * @@v1@@ ; int @@v2@@ ; __int64 @@result@@ ; if ( * ( _BYTE * ) ( @@a1@@ + Number ) ) abort ( ) ; @@v1@@ = ( _DWORD * ) ( @@a1@@ + Number L * * ( unsigned int * ) ( @@a1@@ + Number ) ) ; @@v2@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; @@result@@ = ( unsigned int ) * @@v1@@ ; * @@v1@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; if ( @@v2@@ == * ( _DWORD * ) ( @@a1@@ + Number ) ) * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; else * ( _DWORD * ) ( @@a1@@ + Number ) = ( ( _BYTE ) @@v2@@ + Number ) & Number ; return @@result@@ ; }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
void __fastcall hash_clear ( _QWORD * @@a1@@ ) { _QWORD * @@v1@@ ; _QWORD * @@v2@@ ; void ( __fastcall * @@v3@@ ) ( _QWORD ) ; _QWORD * @@v4@@ ; __int64 @@v5@@ ; @@v1@@ = ( _QWORD * ) * @@a1@@ ; if ( * @@a1@@ < @@a1@@ [ Number ] ) { do { if ( * @@v1@@ ) { @@v2@@ = ( _QWORD * ) @@v1@@ [ Number ] ; @@v3@@ = ( void ( __fastcall * ) ( _QWORD ) ) @@a1@@ [ Number ] ; if ( @@v2@@ ) { do { if ( @@v3@@ ) { @@v3@@ ( * @@v2@@ ) ; @@v3@@ = ( void ( __fastcall * ) ( _QWORD ) ) @@a1@@ [ Number ] ; } @@v4@@ = ( _QWORD * ) @@v2@@ [ Number ] ; @@v5@@ = @@a1@@ [ Number ] ; * @@v2@@ = Number L ; @@v2@@ [ Number ] = @@v5@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v2@@ = @@v4@@ ; } while ( @@v4@@ ) ; } if ( @@v3@@ ) @@v3@@ ( * @@v1@@ ) ; * @@v1@@ = Number L ; @@v1@@ [ Number ] = Number L ; } @@v1@@ += Number ; } while ( @@a1@@ [ Number ] > ( unsigned __int64 ) @@v1@@ ) ; } @@a1@@ [ Number ] = Number L ; @@a1@@ [ Number ] = Number L ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
struct tm * localtime ( const time_t * @@timer@@ ) { return localtime ( @@timer@@ ) ; }
__int64 __fastcall open_safer ( const char * @@a1@@ , char @@a2@@ , unsigned int @@a3@@ ) { __int64 @@v3@@ ; int @@v4@@ ; @@v3@@ = Number L ; if ( ( @@a2@@ & Number ) != Number ) @@v3@@ = @@a3@@ ; @@v4@@ = open ( @@a1@@ , @@a2@@ , @@v3@@ ) ; return fd_safer ( @@v4@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) _frame_dummy_init_array_entry [ @@i@@ ] ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
int iswcntrl ( wint_t @@wc@@ ) { return iswcntrl ( @@wc@@ ) ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
DIR * __fastcall opendir_safer ( const char * @@a1@@ ) { DIR * @@v1@@ ; DIR * @@v2@@ ; unsigned int @@v3@@ ; int @@v5@@ ; DIR * @@v6@@ ; int * @@v7@@ ; int @@v8@@ ; @@v1@@ = opendir ( @@a1@@ ) ; @@v2@@ = @@v1@@ ; if ( ! @@v1@@ ) return @@v2@@ ; @@v3@@ = dirfd ( @@v1@@ ) ; if ( @@v3@@ > Number ) return @@v2@@ ; @@v5@@ = dup_safer ( @@v3@@ ) ; @@v6@@ = fdopendir ( @@v5@@ ) ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; if ( ! @@v6@@ ) close ( @@v5@@ ) ; closedir ( @@v2@@ ) ; * @@v7@@ = @@v8@@ ; return @@v6@@ ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
int clock_gettime ( clockid_t @@clock_id@@ , struct timespec * @@tp@@ ) { return clock_gettime ( @@clock_id@@ , @@tp@@ ) ; }
char * __fastcall separator_string ( char * @@src@@ ) { col_sep_length = strlen ( @@src@@ ) ; col_sep_string = ( void * ) xmalloc ( col_sep_length + Number ) ; return strcpy ( ( char * ) col_sep_string , @@src@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
int sigemptyset ( sigset_t * @@set@@ ) { return sigemptyset ( @@set@@ ) ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
int iconv_close ( iconv_t @@cd@@ ) { return iconv_close ( @@cd@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
char * strdup ( const char * @@s@@ ) { return strdup ( @@s@@ ) ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
__pid_t wait ( __WAIT_STATUS @@stat_loc@@ ) { return wait ( @@stat_loc@@ ) ; }
bool __fastcall strip_trailing_slashes ( char * @@a1@@ ) { const char * @@v1@@ ; const char * @@v2@@ ; bool @@v3@@ ; @@v1@@ = last_component ( @@a1@@ ) ; if ( ! * @@v1@@ ) @@v1@@ = @@a1@@ ; @@v2@@ = & @@v1@@ [ base_len ( @@v1@@ ) ] ; @@v3@@ = * @@v2@@ == Number ; * @@v2@@ = Number ; return ! @@v3@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; program_invocation_short_name = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
unsigned __int64 __fastcall init_header ( const char * @@a1@@ , int @@a2@@ ) { int @@v2@@ ; unsigned int @@v3@@ ; struct tm * @@v4@@ ; struct tm * @@v5@@ ; __int64 @@v6@@ ; void * @@v7@@ ; char * @@v8@@ ; int @@v9@@ ; int @@v10@@ ; int @@v11@@ ; unsigned __int64 @@result@@ ; timespec @@v13@@ ; struct stat @@stat_buf@@ ; unsigned __int64 @@v15@@ ; @@v2@@ = @@a2@@ ; @@v15@@ = __readfsqword ( Number ) ; if ( ! strcmp ( @@a1@@ , String ) ) { @@v2@@ = Number ; if ( timespec_6743 . tv_sec ) goto LABEL_4 ; goto LABEL_11 ; } if ( @@a2@@ >= Number && ! __fxstat ( Number , @@a2@@ , & @@stat_buf@@ ) ) { @@v3@@ = @@stat_buf@@ . st_mtim . tv_nsec ; @@v13@@ = @@stat_buf@@ . st_mtim ; @@v4@@ = localtime ( & @@v13@@ . tv_sec ) ; @@v5@@ = @@v4@@ ; if ( ! @@v4@@ ) goto LABEL_14 ; goto LABEL_5 ; } if ( ! timespec_6743 . tv_sec ) LABEL_11 : gettime ( & timespec_6743 ) ; LABEL_4 : @@v13@@ = ( timespec ) _mm_load_si128 ( ( const __m128i * ) & timespec_6743 ) ; @@v3@@ = @@v13@@ . tv_nsec ; @@v4@@ = localtime ( & @@v13@@ . tv_sec ) ; @@v5@@ = @@v4@@ ; if ( ! @@v4@@ ) { LABEL_14 : @@v7@@ = ( void * ) xmalloc ( Number L ) ; __sprintf_chk ( ) ; goto LABEL_6 ; } LABEL_5 : @@v6@@ = nstrftime ( Number L , Number , date_format , @@v4@@ , Number L , @@v3@@ ) + Number ; @@v7@@ = ( void * ) xmalloc ( @@v6@@ ) ; nstrftime ( @@v7@@ , @@v6@@ , date_format , @@v5@@ , Number L , @@v3@@ ) ; LABEL_6 : free ( date_text ) ; @@v8@@ = ( char * ) custom_header ; date_text = @@v7@@ ; if ( ! custom_header ) { @@v8@@ = String ; if ( @@v2@@ >= Number ) @@v8@@ = ( char * ) @@a1@@ ; } @@v9@@ = chars_per_line ; file_text = @@v8@@ ; @@v10@@ = @@v9@@ - gnu_mbswidth ( ( char * ) @@v7@@ ) ; @@v11@@ = @@v10@@ - gnu_mbswidth ( file_text ) ; @@result@@ = __readfsqword ( Number ) ^ @@v15@@ ; header_width_available = @@v11@@ ; return @@result@@ ; }
int fileno ( FILE * @@stream@@ ) { return fileno ( @@stream@@ ) ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
int wcwidth ( wchar_t @@c@@ ) { return wcwidth ( @@c@@ ) ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
int __fxstat ( int @@ver@@ , int @@fildes@@ , struct stat * @@stat_buf@@ ) { return _fxstat ( @@ver@@ , @@fildes@@ , @@stat_buf@@ ) ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
time_t mktime ( struct tm * @@tp@@ ) { return mktime ( @@tp@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
void __fastcall pad_across_to ( int @@a1@@ ) { int @@v1@@ ; char * @@v2@@ ; @@v1@@ = output_position ; if ( tabify_output ) { spaces_not_printed = @@a1@@ - output_position ; } else { while ( ++ @@v1@@ <= @@a1@@ ) { while ( Number ) { @@v2@@ = stdout -> _IO_write_ptr ; if ( @@v2@@ >= stdout -> _IO_write_end ) break ; ++ @@v1@@ ; stdout -> _IO_write_ptr = @@v2@@ + Number ; * @@v2@@ = Number ; if ( @@v1@@ > @@a1@@ ) goto LABEL_5 ; } __overflow ( stdout , Number ) ; } LABEL_5 : output_position = @@a1@@ ; } }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
bool __fastcall euidaccess_stat ( _DWORD * @@a1@@ , char @@a2@@ ) { __uid_t @@v3@@ ; unsigned int @@v4@@ ; __gid_t @@v5@@ ; __gid_t @@v6@@ ; if ( ( @@a2@@ & Number ) == Number ) return Number ; @@v3@@ = geteuid ( ) ; if ( @@v3@@ ) { @@v4@@ = @@a1@@ [ Number ] ; } else { if ( ( @@a2@@ & Number ) == Number ) return Number ; @@v4@@ = @@a1@@ [ Number ] ; if ( ( @@v4@@ & Number ) != Number ) return Number ; } if ( @@a1@@ [ Number ] == @@v3@@ ) { @@v4@@ >>= Number ; } else { @@v5@@ = getegid ( ) ; @@v6@@ = @@a1@@ [ Number ] ; if ( @@v6@@ == @@v5@@ || group_member ( @@v6@@ ) ) @@v4@@ >>= Number ; } return ( @@a2@@ & Number & ~ @@v4@@ ) == Number ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
unsigned __int64 print_header ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char @@v3@@ [ Number ] ; unsigned __int64 @@v4@@ ; output_position = Number ; @@v4@@ = __readfsqword ( Number ) ; pad_across_to ( chars_per_margin ) ; print_white_space ( ) ; @@v0@@ = page_number ; if ( ! page_number ) { @@v1@@ = dcgettext ( Number L , String , Number ) ; error ( Number , Number , @@v1@@ ) ; @@v0@@ = page_number ; } page_number = @@v0@@ + Number ; dcgettext ( Number L , String , Number ) ; __sprintf_chk ( ) ; gnu_mbswidth ( @@v3@@ ) ; __printf_chk ( ) ; print_a_header = Number ; output_position = Number ; return __readfsqword ( Number ) ^ @@v4@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_20E210 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20E1F0 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_20E200 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
__int64 __fastcall dup_safer ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
__int64 __fastcall char_to_clump ( char @@a1@@ ) { char * @@v1@@ ; int @@v2@@ ; int @@v3@@ ; __int64 @@result@@ ; int @@v5@@ ; int @@v6@@ ; char * @@v7@@ ; int @@v8@@ ; char @@v9@@ ; char @@v10@@ ; char @@v11@@ ; @@v1@@ = ( char * ) clump_buff ; @@v2@@ = chars_per_input_tab ; if ( input_tab_char != @@a1@@ ) { if ( @@a1@@ != Number ) { if ( ( ( * __ctype_b_loc ( ) ) [ ( unsigned __int8 ) @@a1@@ ] & Number ) != Number ) { * @@v1@@ = @@a1@@ ; @@v3@@ = input_position ; @@result@@ = Number L ; @@v5@@ = Number ; goto LABEL_11 ; } if ( use_esc_sequence ) goto LABEL_22 ; if ( use_cntrl_prefix ) { if ( @@a1@@ >= Number ) { * @@v1@@ = Number ; @@v3@@ = input_position ; @@v1@@ [ Number ] = @@a1@@ ^ Number ; @@result@@ = Number L ; @@v5@@ = Number ; LABEL_11 : input_position = @@v3@@ + @@v5@@ ; return @@result@@ ; } LABEL_22 : * @@v1@@ = Number ; __sprintf_chk ( ) ; @@v3@@ = input_position ; @@v5@@ = Number ; @@v1@@ [ Number ] = @@v9@@ ; @@v1@@ [ Number ] = @@v10@@ ; @@v1@@ [ Number ] = @@v11@@ ; @@result@@ = Number L ; goto LABEL_11 ; } @@v3@@ = input_position ; if ( @@a1@@ != Number ) { * @@v1@@ = @@a1@@ ; @@result@@ = Number L ; @@v5@@ = Number ; goto LABEL_11 ; } * @@v1@@ = Number ; if ( @@v3@@ ) { @@v8@@ = Number ; @@result@@ = Number L ; @@v5@@ = Number ; goto LABEL_18 ; } LABEL_21 : input_position = Number ; return Number L ; } @@v2@@ = Number ; } @@v3@@ = input_position ; @@v6@@ = @@v2@@ - input_position % @@v2@@ ; @@v5@@ = @@v6@@ ; if ( untabify_input ) { if ( ! @@v6@@ ) { @@result@@ = Number L ; goto LABEL_11 ; } @@v7@@ = ( char * ) clump_buff + ( unsigned int ) ( @@v6@@ - Number ) + Number ; do * @@v1@@ ++ = Number ; while ( @@v7@@ != @@v1@@ ) ; @@result@@ = ( unsigned int ) @@v6@@ ; if ( @@v6@@ >= Number ) goto LABEL_11 ; } else { * ( _BYTE * ) clump_buff = @@a1@@ ; @@result@@ = Number L ; if ( @@v6@@ >= Number ) goto LABEL_11 ; } if ( ! @@v3@@ ) goto LABEL_21 ; @@v8@@ = - @@v6@@ ; LABEL_18 : if ( @@v8@@ < @@v3@@ ) goto LABEL_11 ; input_position = Number ; return @@result@@ ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
__int64 __fastcall fd_safer ( int @@fd@@ , __int64 @@a2@@ , __int64 @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { unsigned int @@v6@@ ; unsigned int @@v7@@ ; int * @@v8@@ ; int @@v9@@ ; int * @@v10@@ ; @@v6@@ = @@fd@@ ; if ( ( unsigned int ) @@fd@@ <= Number ) { @@v7@@ = dup_safer ( @@fd@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; @@v8@@ = __errno_location ( ) ; @@v9@@ = * @@v8@@ ; @@v10@@ = @@v8@@ ; close ( @@fd@@ ) ; @@v6@@ = @@v7@@ ; * @@v10@@ = @@v9@@ ; } return @@v6@@ ; }
bool __fastcall cycle_warning_required ( __int64 @@a1@@ , __int64 @@a2@@ ) { bool @@result@@ ; int @@v3@@ ; @@result@@ = Number ; @@v3@@ = * ( _DWORD * ) ( @@a1@@ + Number ) & Number ; if ( @@v3@@ != Number ) { @@result@@ = Number ; if ( @@v3@@ == Number ) @@result@@ = * ( _QWORD * ) ( @@a2@@ + Number ) != Number L ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_20C510 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20C4F0 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_20C500 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
int rmdir ( const char * @@path@@ ) { return rmdir ( @@path@@ ) ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
__int64 cols_ready_to_print ( ) { _DWORD * @@v0@@ ; __int64 @@result@@ ; if ( columns <= Number ) return Number L ; @@v0@@ = ( char * ) column_vector + Number ; @@result@@ = Number L ; do { if ( * @@v0@@ <= Number || storing_columns && ( int ) @@v0@@ [ Number ] > Number && ( int ) @@v0@@ [ Number ] > Number ) @@result@@ = ( unsigned int ) ( @@result@@ + Number ) ; @@v0@@ += Number ; } while ( @@v0@@ != ( _DWORD * ) ( ( char * ) column_vector + Number * ( unsigned __int64 ) ( unsigned int ) ( columns - Number ) + Number ) ) ; return @@result@@ ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
int __fastcall print_char ( unsigned __int8 @@a1@@ ) { char * @@v1@@ ; if ( tabify_output ) { if ( @@a1@@ == Number ) { LODWORD ( @@v1@@ ) = ++ spaces_not_printed ; return ( int ) @@v1@@ ; } if ( spaces_not_printed > Number ) { print_white_space ( ) ; if ( ( ( * __ctype_b_loc ( ) ) [ @@a1@@ ] & Number ) == Number ) { LABEL_5 : if ( @@a1@@ == Number ) -- output_position ; goto LABEL_7 ; } } else if ( ( ( * __ctype_b_loc ( ) ) [ @@a1@@ ] & Number ) == Number ) { goto LABEL_5 ; } ++ output_position ; } LABEL_7 : @@v1@@ = stdout -> _IO_write_ptr ; if ( @@v1@@ >= stdout -> _IO_write_end ) { LODWORD ( @@v1@@ ) = __overflow ( stdout , @@a1@@ ) ; } else { stdout -> _IO_write_ptr = @@v1@@ + Number ; * @@v1@@ = @@a1@@ ; } return ( int ) @@v1@@ ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
void * __fastcall store_char ( char @@a1@@ ) { __int64 @@v1@@ ; void * @@result@@ ; int @@v3@@ ; @@v1@@ = ( unsigned int ) buff_current ; @@result@@ = buff ; @@v3@@ = buff_current ; if ( ( unsigned int ) buff_current >= ( unsigned __int64 ) buff_allocated ) { @@result@@ = ( void * ) x2realloc ( buff , & buff_allocated ) ; @@v1@@ = ( unsigned int ) buff_current ; buff = @@result@@ ; @@v3@@ = buff_current ; } * ( ( _BYTE * ) @@result@@ + @@v1@@ ) = @@a1@@ ; buff_current = @@v3@@ + Number ; return @@result@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) _frame_dummy_init_array_entry [ @@i@@ ] ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall add_line_number_isra_2 ( __int64 ( __fastcall * * @@a1@@ ) ( __int64 , __int64 ) ) { char * @@v2@@ ; char * @@v3@@ ; __int64 @@v4@@ ; __int64 @@result@@ ; int @@v6@@ ; __sprintf_chk ( ) ; ++ line_number ; @@v2@@ = ( char * ) number_buff ; if ( chars_per_number > Number ) { @@v3@@ = ( char * ) number_buff + ( unsigned int ) ( chars_per_number - Number ) + Number ; do ( * @@a1@@ ) ( ( unsigned int ) * @@v2@@ ++ , Number L ) ; while ( @@v3@@ != @@v2@@ ) ; } @@v4@@ = ( unsigned int ) number_separator ; if ( columns > Number ) { if ( number_separator == Number ) { @@result@@ = ( unsigned int ) ( number_width - chars_per_number ) ; @@v6@@ = @@result@@ - Number ; if ( number_width - chars_per_number > Number ) { do { -- @@v6@@ ; @@result@@ = ( * @@a1@@ ) ( Number L , Number L ) ; } while ( @@v6@@ != Number ) ; } } else { @@result@@ = ( * @@a1@@ ) ( @@v4@@ , Number L ) ; } } else { @@result@@ = ( * @@a1@@ ) ( @@v4@@ , Number L ) ; if ( number_separator == Number ) { @@result@@ = ( unsigned int ) ( output_position / chars_per_output_tab ) ; output_position += chars_per_output_tab - output_position % chars_per_output_tab ; } } if ( truncate_lines ) { if ( ! parallel_files ) { @@result@@ = ( unsigned int ) number_width ; input_position += number_width ; } } return @@result@@ ; }
unsigned __int64 __fastcall parse_column_count ( char * @@a1@@ ) { int @@v1@@ ; __int64 @@v2@@ ; char * @@v3@@ ; __int64 @@v5@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = __readfsqword ( Number ) ; if ( ( unsigned int ) xstrtol ( @@a1@@ ) || ( @@v1@@ = @@v5@@ , ( unsigned __int64 ) ( @@v5@@ - Number ) > Number ) ) { @@v2@@ = quote ( @@a1@@ , Number L ) ; @@v3@@ = dcgettext ( Number L , String , Number ) ; error ( Number , Number , @@v3@@ , @@v2@@ ) ; @@v1@@ = @@v5@@ ; } columns = @@v1@@ ; explicit_columns = Number ; return __readfsqword ( Number ) ^ @@v6@@ ; }
void __fastcall read_rest_of_line ( __int64 @@a1@@ ) { FILE * @@v2@@ ; int @@v3@@ ; char * @@v4@@ ; char * @@v5@@ ; int @@v6@@ ; @@v2@@ = * ( FILE * * ) @@a1@@ ; do { @@v4@@ = @@v2@@ -> _IO_read_ptr ; if ( @@v4@@ < @@v2@@ -> _IO_read_end ) { @@v2@@ -> _IO_read_ptr = @@v4@@ + Number ; @@v3@@ = ( unsigned __int8 ) * @@v4@@ ; if ( @@v3@@ == Number ) return ; } else { @@v3@@ = __uflow ( @@v2@@ ) ; if ( @@v3@@ == Number ) return ; } if ( @@v3@@ == Number ) { @@v5@@ = @@v2@@ -> _IO_read_ptr ; if ( @@v5@@ >= @@v2@@ -> _IO_read_end ) { @@v6@@ = __uflow ( @@v2@@ ) ; } else { @@v2@@ -> _IO_read_ptr = @@v5@@ + Number ; @@v6@@ = ( unsigned __int8 ) * @@v5@@ ; } if ( @@v6@@ == Number ) { if ( ! keep_FF ) { LABEL_13 : hold_file_isra_1 ( ( _DWORD * ) ( @@a1@@ + Number ) , ( _DWORD * ) ( @@a1@@ + Number ) ) ; return ; } } else { ungetc ( @@v6@@ , @@v2@@ ) ; if ( ! keep_FF ) goto LABEL_13 ; } print_a_FF = Number ; goto LABEL_13 ; } } while ( @@v3@@ != Number ) ; if ( * ( _DWORD * ) ( @@a1@@ + Number ) != Number ) close_file_part_4 ( @@a1@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
unsigned __int64 __fastcall prog_fprintf ( FILE * @@s@@ ) { char * @@v1@@ ; unsigned __int64 @@v3@@ ; @@v3@@ = __readfsqword ( Number ) ; fputs_unlocked ( program_name , @@s@@ ) ; fwrite_unlocked ( String , Number , Number , @@s@@ ) ; rpl_vfprintf ( @@s@@ ) ; @@v1@@ = @@s@@ -> _IO_write_ptr ; if ( @@v1@@ >= @@s@@ -> _IO_write_end ) { __overflow ( @@s@@ , Number ) ; } else { @@s@@ -> _IO_write_ptr = @@v1@@ + Number ; * @@v1@@ = Number ; } return __readfsqword ( Number ) ^ @@v3@@ ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
__int64 __fastcall gnu_mbswidth ( char * @@s@@ , char @@a2@@ ) { __int64 @@v2@@ ; @@v2@@ = strlen ( @@s@@ ) ; return mbsnwidth ( @@s@@ , @@v2@@ , @@a2@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 __fastcall first_last_page ( unsigned int @@a1@@ , char @@a2@@ , char * @@a3@@ ) { unsigned int @@v4@@ ; char @@v5@@ ; char * @@v7@@ ; __int64 @@v8@@ ; @@v4@@ = xstrtoumax ( @@a3@@ ) ; if ( ( @@v4@@ & Number ) != Number ) goto LABEL_11 ; if ( @@v7@@ == @@a3@@ || ! @@v8@@ ) return Number L ; @@v5@@ = * @@v7@@ ; if ( * @@v7@@ != Number ) goto LABEL_5 ; @@v4@@ = xstrtoumax ( @@v7@@ + Number ) ; if ( @@v4@@ ) LABEL_11 : xstrtol_fatal ( @@v4@@ , @@a1@@ , ( unsigned int ) @@a2@@ , & long_options , @@a3@@ ) ; if ( @@v7@@ == @@v7@@ + Number ) return Number L ; @@v5@@ = * @@v7@@ ; LABEL_5 : if ( ! @@v5@@ ) { first_page_number = @@v8@@ ; last_page_number = Number ; return Number L ; } return Number L ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; program_invocation_short_name = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
int closedir ( DIR * @@dirp@@ ) { return closedir ( @@dirp@@ ) ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
char * __fastcall mmalloca ( __int64 @@a1@@ ) { bool @@v1@@ ; size_t @@v2@@ ; _DWORD * @@v3@@ ; char * @@v4@@ ; unsigned __int64 @@v5@@ ; __int64 @@v6@@ ; @@v1@@ = __CFADD__ ( @@a1@@ , Number L ) ; @@v2@@ = @@a1@@ + Number ; if ( @@v1@@ ) return Number L ; @@v3@@ = malloc ( @@v2@@ ) ; @@v4@@ = Number L ; if ( @@v3@@ ) { @@v3@@ [ Number ] = Number ; @@v4@@ = ( char * ) ( @@v3@@ + Number ) ; @@v5@@ = ( unsigned __int64 ) ( @@v3@@ + Number ) % Number ; @@v6@@ = mmalloca_results [ @@v5@@ ] ; mmalloca_results [ @@v5@@ ] = @@v3@@ + Number ; * ( _QWORD * ) @@v3@@ = @@v6@@ ; } return @@v4@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
char * nl_langinfo ( nl_item @@item@@ ) { return nl_langinfo ( @@item@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
int isatty ( int @@fd@@ ) { return isatty ( @@fd@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
int closedir ( DIR * @@dirp@@ ) { return closedir ( @@dirp@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
int rpmatch ( const char * @@response@@ ) { return rpmatch ( @@response@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( char * ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = @@result@@ + Number ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = @@result@@ + Number ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = ( __int64 ) @@v1@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
int __freading ( FILE * @@fp@@ ) { return _freading ( @@fp@@ ) ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_2091D0 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2091B0 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2091C0 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
__int64 __fastcall rpl_vfprintf ( FILE * @@s@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { char * @@v3@@ ; size_t @@v4@@ ; char * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; size_t @@n@@ ; char @@v11@@ [ Number ] ; unsigned __int64 @@v12@@ ; @@n@@ = Number L ; @@v12@@ = __readfsqword ( Number ) ; @@v3@@ = ( char * ) vasnprintf ( @@v11@@ , & @@n@@ , @@a2@@ , @@a3@@ ) ; @@v4@@ = @@n@@ ; if ( ! @@v3@@ ) goto LABEL_10 ; @@v5@@ = @@v3@@ ; if ( fwrite ( @@v3@@ , Number , @@n@@ , @@s@@ ) >= @@v4@@ ) { if ( @@v5@@ != @@v11@@ ) free ( @@v5@@ ) ; if ( @@v4@@ <= Number ) return ( unsigned int ) @@v4@@ ; * __errno_location ( ) = Number ; LABEL_10 : LODWORD ( @@v4@@ ) = Number ; fseterr ( @@s@@ ) ; return ( unsigned int ) @@v4@@ ; } LODWORD ( @@v4@@ ) = Number ; if ( @@v5@@ != @@v11@@ ) { @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; free ( @@v5@@ ) ; * @@v9@@ = @@v8@@ ; } return ( unsigned int ) @@v4@@ ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
__int64 __fastcall cache_fstatat_constprop_4 ( int @@fildes@@ , char * @@filename@@ , struct stat * @@stat_buf@@ ) { __off_t @@v3@@ ; int * @@v6@@ ; __ino_t @@v7@@ ; @@v3@@ = @@stat_buf@@ -> st_size ; if ( @@v3@@ == Number ) { if ( __fxstatat ( Number , @@fildes@@ , @@filename@@ , @@stat_buf@@ , Number ) ) { @@stat_buf@@ -> st_size = Number ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * @@v6@@ ; @@stat_buf@@ -> st_ino = @@v7@@ ; goto LABEL_6 ; } @@v3@@ = @@stat_buf@@ -> st_size ; } if ( @@v3@@ >= Number ) return Number L ; @@v6@@ = __errno_location ( ) ; @@v7@@ = @@stat_buf@@ -> st_ino ; LABEL_6 : * @@v6@@ = @@v7@@ ; return Number ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
int nanosleep ( const struct timespec * @@requested_time@@ , struct timespec * @@remaining@@ ) { return nanosleep ( @@requested_time@@ , @@remaining@@ ) ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v2@@ ; char * @@v3@@ ; FILE * @@v4@@ ; char * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; char * @@v9@@ ; char * @@v10@@ ; bool @@v11@@ ; bool @@v12@@ ; const char * @@v13@@ ; __int64 @@v14@@ ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v2@@ = stdout ; @@v3@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v3@@ , @@v2@@ ) ; @@v4@@ = stdout ; @@v5@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v5@@ , @@v4@@ ) ; @@v6@@ = dcgettext ( Number L , String String String String , Number ) ; __printf_chk ( ) ; last_component ( program_name , @@v6@@ ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = Number L ; @@v10@@ = setlocale ( Number , Number L ) ; @@v11@@ = Number ; @@v12@@ = @@v10@@ == Number L ; if ( @@v10@@ ) { @@v13@@ = String ; @@v9@@ = @@v10@@ ; @@v14@@ = Number L ; do { if ( ! @@v14@@ ) break ; @@v11@@ = ( unsigned __int8 ) * @@v9@@ < ( unsigned int ) * @@v13@@ ; @@v12@@ = * @@v9@@ ++ == * @@v13@@ ++ ; -- @@v14@@ ; } while ( @@v12@@ ) ; if ( ( ! @@v11@@ && ! @@v12@@ ) != @@v11@@ ) { last_component ( program_name , @@v9@@ ) ; @@v9@@ = dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name , @@v9@@ ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; exit ( @@status@@ ) ; }
__int64 __fastcall argmatch ( const char * @@a1@@ , const char * * @@a2@@ , char * @@a3@@ , size_t @@a4@@ ) { char * @@v5@@ ; size_t @@v6@@ ; const char * @@v7@@ ; size_t @@v8@@ ; __int64 @@v9@@ ; bool @@v10@@ ; char @@v11@@ ; __int64 @@v12@@ ; __int64 @@v14@@ ; char @@v15@@ ; @@v5@@ = @@a3@@ ; @@v6@@ = strlen ( @@a1@@ ) ; @@v7@@ = * @@a2@@ ; @@v14@@ = Number ; if ( ! * @@a2@@ ) return @@v14@@ ; @@v8@@ = @@v6@@ ; @@v15@@ = Number ; @@v9@@ = Number L ; do { while ( strncmp ( @@v7@@ , @@a1@@ , @@v8@@ ) ) { LABEL_7 : ++ @@v9@@ ; @@v5@@ += @@a4@@ ; @@v7@@ = @@a2@@ [ @@v9@@ ] ; if ( ! @@v7@@ ) goto LABEL_12 ; } if ( strlen ( @@v7@@ ) == @@v8@@ ) return @@v9@@ ; if ( @@v14@@ != Number ) { if ( @@a3@@ ) { @@v10@@ = memcmp ( & @@a3@@ [ @@a4@@ * @@v14@@ ] , @@v5@@ , @@a4@@ ) == Number ; @@v11@@ = @@v15@@ ; if ( ! @@v10@@ ) @@v11@@ = Number ; @@v15@@ = @@v11@@ ; } else { @@v15@@ = Number ; } goto LABEL_7 ; } @@v14@@ = @@v9@@ ++ ; @@v5@@ += @@a4@@ ; @@v7@@ = @@a2@@ [ @@v9@@ ] ; } while ( @@v7@@ ) ; LABEL_12 : @@v12@@ = Number ; if ( ! @@v15@@ ) @@v12@@ = @@v14@@ ; return @@v12@@ ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
bool __fastcall LCO_compare ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { return * @@a1@@ == * @@a2@@ ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 __fastcall fts_sort ( _QWORD * @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { __int64 @@v5@@ ; bool @@v6@@ ; int ( * @@v7@@ ) ( const void * , const void * ) ; void * @@v8@@ ; void * @@v9@@ ; _QWORD * @@v10@@ ; __int64 * @@v11@@ ; size_t @@v12@@ ; __int64 @@result@@ ; __int64 @@v14@@ ; __int64 * @@i@@ ; __int64 @@v16@@ ; __int64 @@v17@@ ; @@v5@@ = @@a2@@ ; @@v6@@ = @@a1@@ [ Number ] < @@a3@@ ; @@v7@@ = ( int ( * ) ( const void * , const void * ) ) @@a1@@ [ Number ] ; @@v8@@ = ( void * ) @@a1@@ [ Number ] ; if ( ! @@v6@@ ) goto LABEL_5 ; @@a1@@ [ Number ] = @@a3@@ + Number ; if ( @@a3@@ + Number > Number ) { LABEL_15 : free ( @@v8@@ ) ; @@a1@@ [ Number ] = Number L ; @@a1@@ [ Number ] = Number L ; return @@a2@@ ; } @@v9@@ = realloc ( @@v8@@ , Number * ( @@a3@@ + Number ) ) ; @@v8@@ = @@v9@@ ; if ( ! @@v9@@ ) { @@v8@@ = ( void * ) @@a1@@ [ Number ] ; goto LABEL_15 ; } @@a1@@ [ Number ] = @@v9@@ ; LABEL_5 : if ( @@a2@@ ) { @@v10@@ = @@v8@@ ; do { * @@v10@@ ++ = @@v5@@ ; @@v5@@ = * ( _QWORD * ) ( @@v5@@ + Number ) ; } while ( @@v5@@ ) ; } qsort ( @@v8@@ , @@a3@@ , Number , @@v7@@ ) ; @@v11@@ = ( __int64 * ) @@a1@@ [ Number ] ; @@v12@@ = @@a3@@ - Number ; @@result@@ = * @@v11@@ ; if ( @@a3@@ == Number ) { @@v17@@ = * @@v11@@ ; } else { @@v14@@ = * @@v11@@ ; for ( @@i@@ = ( __int64 * ) @@a1@@ [ Number ] ; ; @@v14@@ = * @@i@@ ) { @@v16@@ = @@i@@ [ Number ] ; ++ @@i@@ ; -- @@v12@@ ; * ( _QWORD * ) ( @@v14@@ + Number ) = @@v16@@ ; if ( ! @@v12@@ ) break ; } @@v17@@ = @@v11@@ [ @@a3@@ - Number ] ; } * ( _QWORD * ) ( @@v17@@ + Number ) = Number L ; return @@result@@ ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
int __cdecl __noreturn main ( int @@argc@@ , const char * * @@argv@@ , const char * * @@envp@@ ) { char * * @@v3@@ ; const char * * @@v4@@ ; int @@v5@@ ; char * @@v6@@ ; int * @@v7@@ ; set_program_name ( * @@argv@@ , @@argv@@ , @@envp@@ ) ; setlocale ( Number , String ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; parse_long_options ( @@argc@@ , ( _DWORD ) @@argv@@ , ( unsigned int ) String , ( unsigned int ) String , ( _DWORD ) Version , ( unsigned int ) usage , String , Number L ) ; if ( getopt_long ( @@argc@@ , ( char * const * ) @@argv@@ , String , Number L , Number L ) != Number ) usage ( Number ) ; have_read_stdin = Number ; if ( optind == @@argc@@ ) { LOBYTE ( @@v5@@ ) = cksum ( String ) ; } else { if ( optind >= @@argc@@ ) { LOBYTE ( @@v5@@ ) = Number ; goto LABEL_7 ; } @@v3@@ = ( char * * ) & @@argv@@ [ optind ] ; @@v4@@ = & ( & @@argv@@ [ optind ] ) [ ( unsigned __int64 ) ( unsigned int ) ( @@argc@@ + ~ optind ) + Number ] ; @@v5@@ = Number ; do { @@v6@@ = * @@v3@@ ++ ; @@v5@@ &= cksum ( @@v6@@ ) ; } while ( @@v3@@ != ( char * * ) @@v4@@ ) ; } if ( have_read_stdin ) { if ( fclose ( stdin ) == Number ) { @@v7@@ = __errno_location ( ) ; error ( Number , * @@v7@@ , String ) ; } } LABEL_7 : exit ( ( unsigned __int8 ) @@v5@@ ^ Number ) ; }
__int64 __fastcall fts_set ( __int64 a1 , __int64 @@a2@@ , unsigned int @@a3@@ ) { __int64 @@result@@ ; if ( @@a3@@ > Number ) { * __errno_location ( ) = Number ; @@result@@ = Number L ; } else { * ( _WORD * ) ( @@a2@@ + Number ) = @@a3@@ ; @@result@@ = Number L ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
unsigned __int64 __fastcall raw_hasher ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return __ROR8__ ( @@a1@@ , Number ) % @@a2@@ ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
bool __fastcall strip_trailing_slashes ( char * @@a1@@ ) { const char * @@v1@@ ; const char * @@v2@@ ; bool @@v3@@ ; @@v1@@ = last_component ( @@a1@@ ) ; if ( ! * @@v1@@ ) @@v1@@ = @@a1@@ ; @@v2@@ = & @@v1@@ [ base_len ( @@v1@@ ) ] ; @@v3@@ = * @@v2@@ == Number ; * @@v2@@ = Number ; return ! @@v3@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
__int64 __fastcall hash_find_entry ( __int64 * @@a1@@ , __int64 @@a2@@ , __m128i * * @@a3@@ , char @@a4@@ ) { __int64 @@v5@@ ; __m128i * @@v8@@ ; __int64 @@v9@@ ; __int64 * @@v10@@ ; const __m128i * @@v12@@ ; @@v5@@ = * @@a1@@ ; @@v8@@ = ( __m128i * ) ( Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) + @@v5@@ ) ; if ( @@a1@@ [ Number ] <= ( unsigned __int64 ) @@v8@@ ) abort ( ) ; * @@a3@@ = @@v8@@ ; @@v9@@ = @@v8@@ -> m128i_i64 [ Number ] ; if ( @@v8@@ -> m128i_i64 [ Number ] ) { if ( @@v9@@ != @@a2@@ ) { if ( ! ( ( unsigned __int8 ( __fastcall * ) ( __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ ) ) { @@v10@@ = ( __int64 * ) @@v8@@ -> m128i_i64 [ Number ] ; if ( @@v10@@ ) { @@v9@@ = * @@v10@@ ; if ( @@a2@@ != * @@v10@@ ) { while ( ! ( ( unsigned __int8 ( __fastcall * ) ( __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ ) ) { @@v8@@ = ( __m128i * ) @@v8@@ -> m128i_i64 [ Number ] ; @@v10@@ = ( __int64 * ) @@v8@@ -> m128i_i64 [ Number ] ; if ( ! @@v10@@ ) return Number L ; @@v9@@ = * @@v10@@ ; if ( * @@v10@@ == @@a2@@ ) goto LABEL_12 ; } @@v10@@ = ( __int64 * ) @@v8@@ -> m128i_i64 [ Number ] ; @@v9@@ = * @@v10@@ ; } LABEL_12 : if ( @@a4@@ ) { @@v8@@ -> m128i_i64 [ Number ] = @@v10@@ [ Number ] ; * @@v10@@ = Number L ; @@v10@@ [ Number ] = @@a1@@ [ Number ] ; @@a1@@ [ Number ] = ( __int64 ) @@v10@@ ; } return @@v9@@ ; } return Number L ; } @@v9@@ = @@v8@@ -> m128i_i64 [ Number ] ; } if ( @@a4@@ ) { @@v12@@ = ( const __m128i * ) @@v8@@ -> m128i_i64 [ Number ] ; if ( @@v12@@ ) { * @@v8@@ = _mm_loadu_si128 ( @@v12@@ ) ; @@v12@@ -> m128i_i64 [ Number ] = Number L ; @@v12@@ -> m128i_i64 [ Number ] = @@a1@@ [ Number ] ; @@a1@@ [ Number ] = ( __int64 ) @@v12@@ ; return @@v9@@ ; } @@v8@@ -> m128i_i64 [ Number ] = Number L ; } return @@v9@@ ; } return Number L ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
__int64 __fastcall hash_reset_tuning ( __int64 @@a1@@ ) { __int64 @@result@@ ; * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; * ( _QWORD * ) @@a1@@ = Number ; @@result@@ = Number ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number ; return @@result@@ ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall print_stored ( _DWORD * @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; unsigned __int8 * @@v3@@ ; unsigned __int8 * @@v4@@ ; int @@v5@@ ; int @@v6@@ ; __int64 @@result@@ ; int * @@v8@@ ; char * @@v9@@ ; char * @@v10@@ ; @@v1@@ = ( int ) @@a1@@ [ Number ] ; @@v2@@ = ( char * ) buff ; pad_vertically = Number ; @@a1@@ [ Number ] = @@v1@@ + Number ; @@v3@@ = ( unsigned __int8 * ) & @@v2@@ [ * ( ( int * ) line_vector + @@v1@@ ) ] ; @@v4@@ = ( unsigned __int8 * ) & @@v2@@ [ * ( ( int * ) line_vector + @@v1@@ + Number ) ] ; if ( print_a_header ) print_header ( ) ; if ( @@a1@@ [ Number ] == Number ) { @@v8@@ = ( int * ) column_vector ; if ( columns > Number ) { @@v9@@ = ( char * ) column_vector + Number ; @@v10@@ = ( char * ) column_vector + Number * ( unsigned __int64 ) ( unsigned int ) ( columns - Number ) + Number ; do { * ( _DWORD * ) @@v9@@ = Number ; @@v9@@ += Number ; } while ( @@v9@@ != @@v10@@ ) ; } if ( @@v8@@ [ Number ] <= Number ) { if ( ! extremities ) pad_vertically = Number ; return Number L ; } } if ( padding_not_printed - col_sep_length > Number ) { pad_across_to ( padding_not_printed - col_sep_length ) ; padding_not_printed = Number ; if ( ! use_col_separator ) goto LABEL_6 ; } else if ( ! use_col_separator ) { goto LABEL_6 ; } print_sep_string ( ) ; LABEL_6 : while ( @@v4@@ != @@v3@@ ) print_char ( * @@v3@@ ++ ) ; if ( spaces_not_printed ) return Number L ; @@v5@@ = @@a1@@ [ Number ] ; @@v6@@ = @@v5@@ + * ( ( _DWORD * ) end_vector + @@v1@@ ) ; output_position = @@v6@@ ; if ( @@v5@@ - col_sep_length != chars_per_margin ) return Number L ; @@result@@ = Number L ; output_position = @@v6@@ - col_sep_length ; return @@result@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
_QWORD * __fastcall hash_initialize ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 ( __fastcall * @@a3@@ ) ( __int64 a1 , unsigned __int64 a2 ) , bool ( __fastcall * @@a4@@ ) ( __int64 a1 , __int64 a2 ) , __int64 @@a5@@ ) { unsigned __int64 ( __fastcall * @@v5@@ ) ( __int64 , unsigned __int64 ) ; bool ( __fastcall * @@v6@@ ) ( __int64 , __int64 ) ; char * @@v9@@ ; _QWORD * @@v10@@ ; float * * @@v11@@ ; float @@v12@@ ; float @@v13@@ ; float @@v14@@ ; unsigned __int64 @@v15@@ ; char * @@v16@@ ; void * @@v17@@ ; @@v5@@ = @@a3@@ ; @@v6@@ = @@a4@@ ; if ( ! @@a3@@ ) @@v5@@ = raw_hasher ; if ( ! @@a4@@ ) @@v6@@ = raw_comparator ; @@v9@@ = ( char * ) malloc ( Number ) ; @@v10@@ = @@v9@@ ; if ( @@v9@@ ) { @@v11@@ = ( float * * ) ( @@v9@@ + Number ) ; if ( @@a2@@ ) { * ( ( _QWORD * ) @@v9@@ + Number ) = @@a2@@ ; if ( ! ( unsigned __int8 ) check_tuning_isra_0 ( @@v11@@ ) ) goto LABEL_20 ; if ( * ( _BYTE * ) ( @@a2@@ + Number ) ) { LABEL_15 : @@v15@@ = next_prime ( @@a1@@ ) ; if ( @@v15@@ <= Number ) { @@v10@@ [ Number ] = @@v15@@ ; if ( @@v15@@ ) { @@v16@@ = ( char * ) calloc ( @@v15@@ , Number ) ; * @@v10@@ = @@v16@@ ; if ( @@v16@@ ) { @@v10@@ [ Number ] = Number L ; @@v10@@ [ Number ] = Number L ; @@v10@@ [ Number ] = @@v5@@ ; @@v10@@ [ Number ] = @@v6@@ ; @@v10@@ [ Number ] = & @@v16@@ [ Number * @@v15@@ ] ; @@v10@@ [ Number ] = @@a5@@ ; @@v10@@ [ Number ] = Number L ; return @@v10@@ ; } } } LABEL_20 : @@v17@@ = @@v10@@ ; @@v10@@ = Number L ; free ( @@v17@@ ) ; return @@v10@@ ; } @@v12@@ = * ( float * ) ( @@a2@@ + Number ) ; } else { * ( ( _QWORD * ) @@v9@@ + Number ) = & default_tuning ; @@v12@@ = Number ; if ( ! ( unsigned __int8 ) check_tuning_isra_0 ( @@v11@@ ) ) goto LABEL_20 ; } if ( @@a1@@ < Number ) @@v13@@ = ( float ) ( @@a1@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@a1@@ >> Number ) ) + ( float ) ( @@a1@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@a1@@ >> Number ) ) ; else @@v13@@ = ( float ) ( int ) @@a1@@ ; @@v14@@ = @@v13@@ / @@v12@@ ; if ( @@v14@@ >= Number ) goto LABEL_20 ; if ( @@v14@@ < Number ) @@a1@@ = ( unsigned int ) ( int ) @@v14@@ ; else @@a1@@ = ( unsigned int ) ( int ) ( float ) ( @@v14@@ - Number ) ^ Number ; goto LABEL_15 ; } return @@v10@@ ; }
__int64 __fastcall open_file ( const char * @@a1@@ , __int64 @@a2@@ ) { bool @@v2@@ ; unsigned int @@v3@@ ; __int64 @@v5@@ ; int * @@v6@@ ; if ( ! strcmp ( @@a1@@ , String ) ) { * ( _QWORD * ) ( @@a2@@ + Number ) = dcgettext ( Number L , String , Number ) ; have_read_stdin = Number ; @@v2@@ = stdin == Number L ; * ( _QWORD * ) @@a2@@ = stdin ; if ( ! @@v2@@ ) { LABEL_3 : ++ total_files ; * ( _DWORD * ) ( @@a2@@ + Number ) = Number ; * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; return Number ; } } else { * ( _QWORD * ) ( @@a2@@ + Number ) = @@a1@@ ; @@v5@@ = fopen_safer ( @@a1@@ , String ) ; * ( _QWORD * ) @@a2@@ = @@v5@@ ; if ( @@v5@@ ) goto LABEL_3 ; } @@v3@@ = ( unsigned __int8 ) ignore_failed_opens ; failed_opens = Number ; if ( ! ignore_failed_opens ) { @@v6@@ = __errno_location ( ) ; error ( Number , * @@v6@@ , String , @@a1@@ ) ; return @@v3@@ ; } return Number L ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 __fastcall mbsnwidth ( char * @@s@@ , __int64 @@a2@@ , char @@a3@@ ) { char * @@v3@@ ; char * @@v4@@ ; unsigned int @@v5@@ ; char @@v6@@ ; size_t @@v7@@ ; __int64 @@v8@@ ; int @@v9@@ ; const unsigned __int16 * @@v11@@ ; unsigned __int16 @@v12@@ ; wchar_t @@pwc@@ ; mbstate_t @@ps@@ ; unsigned __int64 @@v16@@ ; @@v3@@ = & @@s@@ [ @@a2@@ ] ; @@v4@@ = @@s@@ ; @@v16@@ = __readfsqword ( Number ) ; if ( __ctype_get_mb_cur_max ( ) <= Number ) { @@v5@@ = Number ; if ( @@s@@ >= @@v3@@ ) return @@v5@@ ; @@v11@@ = * __ctype_b_loc ( ) ; @@v5@@ = Number ; while ( Number ) { @@v12@@ = @@v11@@ [ ( unsigned __int8 ) * @@v4@@ ++ ] ; if ( ( @@v12@@ & Number ) != Number ) { ++ @@v5@@ ; } else { if ( ( @@a3@@ & Number ) != Number ) return ( unsigned int ) Number ; @@v5@@ += ( ( unsigned __int8 ) ( @@v12@@ >> Number ) ^ Number ) & Number ; } if ( @@v3@@ == @@v4@@ ) return @@v5@@ ; } } @@v5@@ = Number ; if ( @@s@@ < @@v3@@ ) { do { @@v6@@ = * @@v4@@ ; if ( * @@v4@@ <= Number ) { if ( @@v6@@ < Number && ( unsigned __int8 ) ( @@v6@@ - Number ) > Number ) { LABEL_12 : @@ps@@ = Number L ; while ( Number ) { @@v7@@ = mbrtowc ( & @@pwc@@ , @@v4@@ , @@v3@@ - @@v4@@ , & @@ps@@ ) ; @@v8@@ = @@v7@@ ; if ( @@v7@@ == Number ) { if ( ( @@a3@@ & Number ) == Number ) goto LABEL_6 ; return ( unsigned int ) Number ; } if ( @@v7@@ == Number ) break ; if ( ! @@v7@@ ) @@v8@@ = Number L ; @@v9@@ = wcwidth ( @@pwc@@ ) ; if ( @@v9@@ < Number ) { if ( ( @@a3@@ & Number ) != Number ) return ( unsigned int ) Number ; @@v9@@ = iswcntrl ( @@pwc@@ ) == Number ; } @@v5@@ += @@v9@@ ; @@v4@@ += @@v8@@ ; if ( mbsinit ( & @@ps@@ ) ) goto LABEL_7 ; } if ( ( @@a3@@ & Number ) != Number ) return ( unsigned int ) Number ; ++ @@v5@@ ; @@v4@@ = & @@s@@ [ @@a2@@ ] ; continue ; } } else if ( @@v6@@ < Number || @@v6@@ > Number && ( unsigned __int8 ) ( @@v6@@ - Number ) > Number ) { goto LABEL_12 ; } LABEL_6 : ++ @@v4@@ ; ++ @@v5@@ ; LABEL_7 : ; } while ( @@v4@@ < @@v3@@ ) ; } return @@v5@@ ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
int dirfd ( DIR * @@dirp@@ ) { return dirfd ( @@dirp@@ ) ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_206210 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061F0 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_206200 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
FILE * __fastcall fopen_safer ( const char * @@a1@@ , const char * @@a2@@ ) { FILE * @@v2@@ ; FILE * @@v3@@ ; unsigned int @@v4@@ ; int @@v6@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; int * @@v10@@ ; int @@v11@@ ; int * @@v12@@ ; @@v2@@ = fopen ( @@a1@@ , @@a2@@ ) ; @@v3@@ = @@v2@@ ; if ( @@v2@@ ) { @@v4@@ = fileno ( @@v2@@ ) ; if ( @@v4@@ <= Number ) { @@v6@@ = dup_safer ( @@v4@@ ) ; if ( @@v6@@ < Number ) { @@v10@@ = __errno_location ( ) ; @@v11@@ = * @@v10@@ ; @@v12@@ = @@v10@@ ; fclose ( @@v3@@ ) ; @@v3@@ = Number L ; * @@v12@@ = @@v11@@ ; } else if ( fclose ( @@v3@@ ) || ( @@v3@@ = fdopen ( @@v6@@ , @@a2@@ ) ) == Number L ) { @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; close ( @@v6@@ ) ; * @@v9@@ = @@v8@@ ; @@v3@@ = Number L ; } } } return @@v3@@ ; }
int __xstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _xstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
int fflush ( FILE * @@stream@@ ) { return fflush ( @@stream@@ ) ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
__ino_t * __fastcall get_root_dev_ino ( __ino_t * @@a1@@ ) { struct stat @@v2@@ ; unsigned __int64 @@v3@@ ; @@v3@@ = __readfsqword ( Number ) ; if ( __lxstat ( Number , String , & @@v2@@ ) ) return Number L ; * @@a1@@ = @@v2@@ . st_ino ; @@a1@@ [ Number ] = @@v2@@ . st_dev ; return @@a1@@ ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
int rename ( const char * @@old@@ , const char * @@a2@@ ) { return rename ( @@old@@ , @@a2@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
bool __fastcall writable_destination ( char * @@name@@ , __int16 @@a2@@ ) { if ( ( @@a2@@ & Number ) == Number ) return Number ; if ( ( unsigned __int8 ) can_write_any_file ( ) ) return Number ; return euidaccess ( @@name@@ , Number ) == Number ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
bool __fastcall hard_locale ( int @@a1@@ ) { char * @@v1@@ ; bool @@result@@ ; @@v1@@ = setlocale ( @@a1@@ , Number L ) ; @@result@@ = Number ; if ( @@v1@@ ) { @@result@@ = Number ; if ( strcmp ( @@v1@@ , String ) ) @@result@@ = strcmp ( @@v1@@ , String ) != Number ; } return @@result@@ ; }
__int64 yesno ( ) { unsigned int @@v0@@ ; __ssize_t @@v1@@ ; char * @@lineptr@@ ; size_t @@n@@ [ Number ] ; @@v0@@ = Number ; @@lineptr@@ = Number L ; @@n@@ [ Number ] = __readfsqword ( Number ) ; @@n@@ [ Number ] = Number L ; @@v1@@ = __getdelim ( & @@lineptr@@ , @@n@@ , Number , stdin ) ; if ( @@v1@@ > Number ) { @@lineptr@@ [ @@v1@@ - Number ] = Number ; LOBYTE ( @@v0@@ ) = rpmatch ( @@lineptr@@ ) > Number ; } free ( @@lineptr@@ ) ; return @@v0@@ ; }
__int64 __fastcall src_info_init ( __int64 @@a1@@ ) { __int64 @@result@@ ; @@result@@ = hash_initialize ( Number L , Number L , triple_hash_no_name , triple_compare , triple_free ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@result@@ ; return @@result@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall dup_cloexec ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
char __fastcall chown_failure_ok ( __int64 @@a1@@ ) { int * @@v1@@ ; char @@result@@ ; @@v1@@ = __errno_location ( ) ; @@result@@ = * @@v1@@ == Number || * @@v1@@ == Number ; if ( @@result@@ ) @@result@@ = * ( _BYTE * ) ( @@a1@@ + Number ) ^ Number ; return @@result@@ ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
void __fastcall cycle_check_init ( __int64 @@a1@@ ) { * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _DWORD * ) ( @@a1@@ + Number ) = Number ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
bool __fastcall src_to_dest_compare ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@result@@ ; @@result@@ = Number ; if ( * @@a1@@ == * @@a2@@ ) @@result@@ = @@a1@@ [ Number ] == @@a2@@ [ Number ] ; return @@result@@ ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall memcpy_lowcase ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v3@@ ; const __int32_t * * @@v4@@ ; if ( @@a3@@ ) { @@v3@@ = @@a3@@ - Number ; @@v4@@ = __ctype_tolower_loc ( ) ; do { * ( _BYTE * ) ( @@a1@@ + @@v3@@ ) = ( * @@v4@@ ) [ * ( unsigned __int8 * ) ( @@a2@@ + @@v3@@ ) ] ; -- @@v3@@ ; } while ( @@v3@@ != Number ) ; } return @@a1@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
__int64 __fastcall cycle_check ( __int64 @@a1@@ , __int64 * @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@result@@ ; __int64 @@v5@@ ; if ( * ( _DWORD * ) ( @@a1@@ + Number ) != Number ) __assert_fail ( String , String , Number , String ) ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v3@@ = @@a2@@ [ Number ] ; if ( ! @@v2@@ ) { * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; goto LABEL_7 ; } if ( * ( _QWORD * ) @@a1@@ == @@v3@@ && * @@a2@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ) { return Number L ; } @@result@@ = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v2@@ + Number ; if ( ( ( @@v2@@ + Number ) & @@v2@@ ) == Number ) { if ( @@v2@@ == Number ) return Number L ; LABEL_7 : @@v5@@ = * @@a2@@ ; * ( _QWORD * ) @@a1@@ = @@v3@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v5@@ ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall remember_copied ( void * @@src@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { void * @@v4@@ ; __int64 @@v5@@ ; void * @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; @@v4@@ = ( void * ) xmalloc ( Number L ) ; @@v5@@ = xstrdup ( @@src@@ ) ; @@v6@@ = src_to_dest ; * ( ( _QWORD * ) @@v4@@ + Number ) = @@v5@@ ; * ( _QWORD * ) @@v4@@ = @@a2@@ ; * ( ( _QWORD * ) @@v4@@ + Number ) = @@a3@@ ; @@v7@@ = hash_insert ( @@v6@@ , @@v4@@ ) ; if ( ! @@v7@@ ) xalloc_die ( ) ; @@v8@@ = @@v7@@ ; if ( @@v4@@ == ( void * ) @@v7@@ ) return Number L ; free ( * ( ( void * * ) @@v4@@ + Number ) ) ; free ( @@v4@@ ) ; return * ( _QWORD * ) ( @@v8@@ + Number ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 __fastcall nstrftime ( char * @@a1@@ , __int64 @@a2@@ , char * @@a3@@ , const __m128i * @@a4@@ , unsigned int @@a5@@ , unsigned int @@a6@@ ) { return strftime_case_ ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
void __fastcall record_file ( __int64 @@a1@@ , void * @@a2@@ , _QWORD * @@a3@@ ) { _QWORD * @@v4@@ ; __int64 @@v5@@ ; if ( @@a1@@ ) { @@v4@@ = ( _QWORD * ) xmalloc ( Number L ) ; * @@v4@@ = xstrdup ( @@a2@@ ) ; @@v4@@ [ Number ] = @@a3@@ [ Number ] ; @@v4@@ [ Number ] = * @@a3@@ ; @@v5@@ = hash_insert ( @@a1@@ , @@v4@@ ) ; if ( ! @@v5@@ ) xalloc_die ( ) ; if ( @@v4@@ != ( _QWORD * ) @@v5@@ ) triple_free ( @@v4@@ ) ; } }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; char * @@v11@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String String String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v9@@ = stdout ; @@v10@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; @@v11@@ = setlocale ( Number , Number L ) ; if ( @@v11@@ ) { if ( strncmp ( @@v11@@ , String , Number ) ) { last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
bool __fastcall triple_compare_ino_str ( __int64 @@a1@@ , __int64 @@a2@@ ) { bool @@result@@ ; @@result@@ = Number ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) == * ( _QWORD * ) ( @@a2@@ + Number ) && * ( _QWORD * ) ( @@a1@@ + Number ) == * ( _QWORD * ) ( @@a2@@ + Number ) ) { @@result@@ = strcmp ( * ( const char * * ) @@a1@@ , * ( const char * * ) @@a2@@ ) == Number ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
void __fastcall __noreturn xstrtol_fatal ( unsigned int @@a1@@ , int @@a2@@ , char @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ ) { int @@v7@@ ; const char * @@v8@@ ; char * @@v9@@ ; char * @@v10@@ ; char * @@v11@@ ; char @@v12@@ [ Number ] ; unsigned __int64 @@v13@@ ; @@v13@@ = __readfsqword ( Number ) ; @@v7@@ = exit_failure ; if ( @@a1@@ > Number ) { @@v8@@ = String ; if ( @@a1@@ != Number ) goto LABEL_7 ; } else if ( @@a1@@ >= Number ) { @@v8@@ = String ; } else { @@v8@@ = String ; if ( @@a1@@ != Number ) goto LABEL_7 ; } if ( @@a2@@ < Number ) { @@v12@@ [ Number ] = @@a3@@ ; @@v12@@ [ Number ] = Number ; @@v10@@ = @@v12@@ ; @@v9@@ = & asc_C200 [ - @@a2@@ ] ; } else { @@v9@@ = String ; @@v10@@ = * ( char * * ) ( @@a4@@ + Number L * @@a2@@ ) ; } @@v11@@ = dcgettext ( Number L , @@v8@@ , Number ) ; error ( @@v7@@ , Number , @@v11@@ , @@v9@@ , @@v10@@ , @@a5@@ ) ; LABEL_7 : abort ( ) ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_20E330 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20E310 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_20E320 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
unsigned __int64 __fastcall buffer_lcm ( unsigned __int64 @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v4@@ ; unsigned __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; unsigned __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; if ( @@a1@@ ) { if ( @@a2@@ ) { @@v6@@ = @@a2@@ ; @@v7@@ = @@a1@@ ; while ( Number ) { @@v8@@ = @@v7@@ % @@v6@@ ; if ( ! ( @@v7@@ % @@v6@@ ) ) break ; @@v7@@ = @@v6@@ ; @@v6@@ = @@v8@@ ; } @@v9@@ = @@a1@@ / @@v6@@ ; @@v4@@ = @@a1@@ / @@v6@@ * @@a2@@ ; if ( @@v9@@ * @@a2@@ <= @@a3@@ && @@v4@@ / @@a2@@ == @@v9@@ ) { return @@v4@@ ; } } } else { @@a1@@ = Number ; if ( @@a2@@ ) @@a1@@ = @@a2@@ ; } if ( @@a1@@ <= @@a3@@ ) @@a3@@ = @@a1@@ ; return @@a3@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
__int64 __fastcall _xargmatch_internal ( __int64 @@a1@@ , const char * @@a2@@ , const char * * @@a3@@ , char * @@a4@@ , size_t @@a5@@ , void ( * @@a6@@ ) ( void ) ) { __int64 @@result@@ ; @@result@@ = argmatch ( @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; if ( @@result@@ < Number ) { argmatch_invalid ( @@a1@@ , ( __int64 ) @@a2@@ , @@result@@ ) ; argmatch_valid ( @@a3@@ , @@a4@@ , @@a5@@ ) ; @@a6@@ ( ) ; @@result@@ = Number ; } return @@result@@ ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) _frame_dummy_init_array_entry [ @@i@@ ] ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
__int64 __fastcall xget_version ( void * @@a1@@ , const char * @@a2@@ ) { char * @@v2@@ ; if ( @@a2@@ && * @@a2@@ ) return get_version_part_0 ( ( __int64 ) @@a1@@ , @@a2@@ ) ; @@v2@@ = getenv ( String ) ; if ( @@v2@@ && * @@v2@@ ) { @@a1@@ = & unk_14A7E ; @@a2@@ = @@v2@@ ; return get_version_part_0 ( ( __int64 ) @@a1@@ , @@a2@@ ) ; } return Number L ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; char * @@v9@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = setlocale ( Number , Number L ) ; if ( @@v9@@ ) { if ( strncmp ( @@v9@@ , String , Number ) ) { last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
__int64 __fastcall dup_safer ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ , char @@a7@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ , @@a7@@ ) ; }
void __fastcall close_stdin_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
int rpmatch ( const char * @@response@@ ) { return rpmatch ( @@response@@ ) ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
struct dirent * readdir ( DIR * @@dirp@@ ) { return readdir ( @@dirp@@ ) ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_2091D0 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2091B0 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_2091C0 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
__int64 __fastcall rpl_fcntl ( int @@a1@@ , int @@a2@@ , __int64 @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { int @@v6@@ ; int @@v8@@ ; int @@v9@@ ; int @@v10@@ ; int @@v11@@ ; int * @@v12@@ ; int @@v13@@ ; int * @@v14@@ ; int @@v15@@ ; @@v15@@ = @@a3@@ ; if ( @@a2@@ != Number ) return ( unsigned int ) fcntl ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( have_dupfd_cloexec_3202 < Number ) { @@v6@@ = ( ( __int64 ( __fastcall * ) ( int , _DWORD , _DWORD , int , int , int , char ) ) rpl_fcntl ) ( @@a1@@ , Number , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ , Number ) ; if ( @@v6@@ < Number || have_dupfd_cloexec_3202 != Number ) return ( unsigned int ) @@v6@@ ; } else { @@v6@@ = fcntl ( @@a1@@ , Number , ( unsigned int ) @@a3@@ ) ; if ( @@v6@@ >= Number || * __errno_location ( ) != Number ) { have_dupfd_cloexec_3202 = Number ; return ( unsigned int ) @@v6@@ ; } @@v6@@ = ( ( __int64 ( __fastcall * ) ( int , _DWORD , int , int , int , int , char ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v15@@ , @@v8@@ , @@v9@@ , @@v10@@ , Number ) ; if ( @@v6@@ < Number ) return ( unsigned int ) @@v6@@ ; have_dupfd_cloexec_3202 = Number ; } @@v11@@ = fcntl ( @@v6@@ , Number ) ; if ( @@v11@@ < Number || fcntl ( @@v6@@ , Number , @@v11@@ | Number ) == Number ) { @@v12@@ = __errno_location ( ) ; @@v13@@ = * @@v12@@ ; @@v14@@ = @@v12@@ ; close ( @@v6@@ ) ; @@v6@@ = Number ; * @@v14@@ = @@v13@@ ; } return ( unsigned int ) @@v6@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
int iconv_close ( iconv_t @@cd@@ ) { return iconv_close ( @@cd@@ ) ; }
__int64 __fastcall dir_len ( _BYTE * @@a1@@ ) { unsigned __int64 @@v1@@ ; _BYTE * @@v2@@ ; __int64 @@v3@@ ; @@v1@@ = * @@a1@@ == Number ; @@v2@@ = last_component ( @@a1@@ ) ; if ( @@v2@@ - @@a1@@ <= @@v1@@ ) return @@v2@@ - @@a1@@ ; @@v3@@ = @@v2@@ - @@a1@@ - Number ; if ( * ( @@v2@@ - Number ) != Number ) return @@v2@@ - @@a1@@ ; while ( @@v1@@ != @@v3@@ && @@a1@@ [ @@v3@@ - Number ] == Number ) -- @@v3@@ ; return @@v3@@ ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
unsigned __int64 __fastcall raw_hasher ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return __ROR8__ ( @@a1@@ , Number ) % @@a2@@ ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
__int64 __fastcall hash_get_n_buckets ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
int __fastcall fchmod_or_lchmod ( int @@a1@@ , const char * @@a2@@ , __mode_t @@a3@@ ) { int @@result@@ ; if ( @@a1@@ < Number ) @@result@@ = chmod ( @@a2@@ , @@a3@@ ) ; else @@result@@ = fchmod ( @@a1@@ , @@a3@@ ) ; return @@result@@ ; }
void __fastcall fseterr ( _DWORD * @@a1@@ ) { * @@a1@@ |= Number ; }
__int64 __fastcall hash_get_n_buckets_used ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_206210 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061F0 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_206200 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall dest_info_init ( __int64 @@a1@@ ) { __int64 @@result@@ ; @@result@@ = hash_initialize ( Number L , Number L , triple_hash , triple_compare , triple_free ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@result@@ ; return @@result@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
unsigned __int64 __fastcall hash_get_max_bucket_length ( __int64 @@a1@@ ) { _QWORD * @@v1@@ ; unsigned __int64 @@v2@@ ; unsigned __int64 @@result@@ ; __int64 @@v4@@ ; unsigned __int64 @@i@@ ; @@v1@@ = * ( _QWORD * * ) @@a1@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; for ( @@result@@ = Number L ; ( unsigned __int64 ) @@v1@@ < @@v2@@ ; @@v1@@ += Number ) { if ( * @@v1@@ ) { @@v4@@ = @@v1@@ [ Number ] ; for ( @@i@@ = Number L ; @@v4@@ ; ++ @@i@@ ) @@v4@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; if ( @@result@@ < @@i@@ ) @@result@@ = @@i@@ ; } } return @@result@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
bool __fastcall cp_options_default ( __int64 @@a1@@ ) { bool @@result@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _OWORD * ) @@a1@@ = Number L ; * ( _OWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _OWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _OWORD * ) ( @@a1@@ + Number ) = Number L ; @@result@@ = geteuid ( ) == Number ; * ( _BYTE * ) ( @@a1@@ + Number ) = @@result@@ ; * ( _BYTE * ) ( @@a1@@ + Number ) = @@result@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
__int64 __fastcall hash_get_first ( __int64 @@a1@@ ) { __int64 * @@v1@@ ; unsigned __int64 @@v2@@ ; __int64 @@result@@ ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; @@v1@@ = * ( __int64 * * ) @@a1@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( * ( _QWORD * ) @@a1@@ >= @@v2@@ ) goto LABEL_9 ; @@result@@ = * @@v1@@ ; if ( ! * @@v1@@ ) { while ( Number ) { @@v1@@ += Number ; if ( ( unsigned __int64 ) @@v1@@ >= @@v2@@ ) break ; @@result@@ = * @@v1@@ ; if ( * @@v1@@ ) return @@result@@ ; } LABEL_9 : abort ( ) ; } return @@result@@ ; }
unsigned __int64 __fastcall forget_created ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v3@@ ; __int64 @@v5@@ [ Number ] ; unsigned __int64 @@v6@@ ; @@v5@@ [ Number ] = @@a1@@ ; @@v5@@ [ Number ] = @@a2@@ ; @@v5@@ [ Number ] = Number L ; @@v6@@ = __readfsqword ( Number ) ; @@v2@@ = hash_delete ( src_to_dest , @@v5@@ ) ; if ( @@v2@@ ) { @@v3@@ = ( void * ) @@v2@@ ; free ( * ( void * * ) ( @@v2@@ + Number ) ) ; free ( @@v3@@ ) ; } return __readfsqword ( Number ) ^ @@v6@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
__locale_t newlocale ( int @@category_mask@@ , const char * @@locale@@ , __locale_t @@base@@ ) { return newlocale ( @@category_mask@@ , @@locale@@ , @@base@@ ) ; }
__int64 __fastcall hash_reset_tuning ( __int64 @@a1@@ ) { __int64 @@result@@ ; * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; * ( _QWORD * ) @@a1@@ = Number ; @@result@@ = Number ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number ; return @@result@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
__int64 __fastcall copy_acl ( __int64 @@a1@@ , __int64 a2 , const char * @@a3@@ , int @@a4@@ , __mode_t @@a5@@ ) { int @@v6@@ ; __int64 @@result@@ ; __int64 @@v8@@ ; char * @@v9@@ ; int * @@v10@@ ; const char * @@v11@@ ; int * @@v12@@ ; @@v6@@ = qset_acl ( @@a3@@ , @@a4@@ , @@a5@@ ) ; if ( @@v6@@ == Number ) { @@v11@@ = ( const char * ) quote ( @@a1@@ ) ; @@v12@@ = __errno_location ( ) ; error ( Number , * @@v12@@ , String , @@v11@@ ) ; @@result@@ = Number ; } else if ( @@v6@@ == Number ) { @@v8@@ = quote ( @@a3@@ ) ; @@v9@@ = dcgettext ( Number L , String , Number ) ; @@v10@@ = __errno_location ( ) ; error ( Number , * @@v10@@ , @@v9@@ , @@v8@@ ) ; @@result@@ = Number ; } else { @@result@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
unsigned __int64 __fastcall triple_hash ( _QWORD * @@a1@@ , unsigned __int64 @@a2@@ ) { return ( @@a1@@ [ Number ] ^ ( unsigned __int64 ) hash_pjw ( * @@a1@@ ) ) % @@a2@@ ; }
_QWORD * __fastcall hash_initialize ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 ( __fastcall * @@a3@@ ) ( __int64 a1 , unsigned __int64 a2 ) , bool ( __fastcall * @@a4@@ ) ( __int64 a1 , __int64 a2 ) , __int64 @@a5@@ ) { unsigned __int64 ( __fastcall * @@v5@@ ) ( __int64 , unsigned __int64 ) ; bool ( __fastcall * @@v6@@ ) ( __int64 , __int64 ) ; char * @@v9@@ ; _QWORD * @@v10@@ ; float * * @@v11@@ ; float @@v12@@ ; float @@v13@@ ; float @@v14@@ ; unsigned __int64 @@v15@@ ; char * @@v16@@ ; void * @@v17@@ ; @@v5@@ = @@a3@@ ; @@v6@@ = @@a4@@ ; if ( ! @@a3@@ ) @@v5@@ = raw_hasher ; if ( ! @@a4@@ ) @@v6@@ = raw_comparator ; @@v9@@ = ( char * ) malloc ( Number ) ; @@v10@@ = @@v9@@ ; if ( @@v9@@ ) { @@v11@@ = ( float * * ) ( @@v9@@ + Number ) ; if ( @@a2@@ ) { * ( ( _QWORD * ) @@v9@@ + Number ) = @@a2@@ ; if ( ! ( unsigned __int8 ) check_tuning_isra_0 ( @@v11@@ ) ) goto LABEL_20 ; if ( * ( _BYTE * ) ( @@a2@@ + Number ) ) { LABEL_15 : @@v15@@ = next_prime ( @@a1@@ ) ; if ( @@v15@@ <= Number ) { @@v10@@ [ Number ] = @@v15@@ ; if ( @@v15@@ ) { @@v16@@ = ( char * ) calloc ( @@v15@@ , Number ) ; * @@v10@@ = @@v16@@ ; if ( @@v16@@ ) { @@v10@@ [ Number ] = Number L ; @@v10@@ [ Number ] = Number L ; @@v10@@ [ Number ] = @@v5@@ ; @@v10@@ [ Number ] = @@v6@@ ; @@v10@@ [ Number ] = & @@v16@@ [ Number * @@v15@@ ] ; @@v10@@ [ Number ] = @@a5@@ ; @@v10@@ [ Number ] = Number L ; return @@v10@@ ; } } } LABEL_20 : @@v17@@ = @@v10@@ ; @@v10@@ = Number L ; free ( @@v17@@ ) ; return @@v10@@ ; } @@v12@@ = * ( float * ) ( @@a2@@ + Number ) ; } else { * ( ( _QWORD * ) @@v9@@ + Number ) = & default_tuning ; @@v12@@ = Number ; if ( ! ( unsigned __int8 ) check_tuning_isra_0 ( @@v11@@ ) ) goto LABEL_20 ; } if ( @@a1@@ < Number ) @@v13@@ = ( float ) ( @@a1@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@a1@@ >> Number ) ) + ( float ) ( @@a1@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@a1@@ >> Number ) ) ; else @@v13@@ = ( float ) ( int ) @@a1@@ ; @@v14@@ = @@v13@@ / @@v12@@ ; if ( @@v14@@ >= Number ) goto LABEL_20 ; if ( @@v14@@ < Number ) @@a1@@ = ( unsigned int ) ( int ) @@v14@@ ; else @@a1@@ = ( unsigned int ) ( int ) ( float ) ( @@v14@@ - Number ) ^ Number ; goto LABEL_15 ; } return @@v10@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
__int64 __fastcall triple_compare ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { __int64 @@result@@ ; @@result@@ = Number L ; if ( @@a1@@ [ Number ] == @@a2@@ [ Number ] && @@a1@@ [ Number ] == @@a2@@ [ Number ] ) { @@result@@ = same_name ( * @@a1@@ , * @@a2@@ ) ; } return @@result@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
void __fastcall c_strtod ( char * @@nptr@@ , char * * @@endptr@@ ) { if ( ! c_locale_cache ) c_locale_cache = newlocale ( Number , String , Number L ) ; if ( c_locale_cache ) { strtod_l ( @@nptr@@ , @@endptr@@ , c_locale_cache ) ; } else if ( @@endptr@@ ) { * @@endptr@@ = @@nptr@@ ; } }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
size_t __fastcall strnlen1 ( const void * @@a1@@ , size_t @@a2@@ ) { _BYTE * @@v2@@ ; __int64 @@v3@@ ; bool @@v4@@ ; size_t @@result@@ ; @@v2@@ = memchr ( @@a1@@ , Number , @@a2@@ ) ; @@v3@@ = @@v2@@ - ( _BYTE * ) @@a1@@ + Number ; @@v4@@ = @@v2@@ == Number L ; @@result@@ = @@a2@@ ; if ( ! @@v4@@ ) @@result@@ = @@v3@@ ; return @@result@@ ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
__int64 __fastcall same_name ( _BYTE * @@a1@@ , _BYTE * @@a2@@ ) { unsigned int @@v2@@ ; const char * @@v3@@ ; const char * @@v4@@ ; size_t @@v5@@ ; char * @@v7@@ ; char * @@v8@@ ; int * @@v9@@ ; int * @@v10@@ ; struct stat @@v11@@ ; struct stat @@stat_buf@@ ; unsigned __int64 @@v13@@ ; @@v2@@ = Number ; @@v13@@ = __readfsqword ( Number ) ; @@v3@@ = last_component ( @@a1@@ ) ; @@v4@@ = last_component ( @@a2@@ ) ; @@v5@@ = base_len ( @@v3@@ ) ; if ( @@v5@@ == base_len ( @@v4@@ ) && ! memcmp ( @@v3@@ , @@v4@@ , @@v5@@ ) ) { @@v7@@ = ( char * ) dir_name ( @@a1@@ ) ; @@v8@@ = ( char * ) dir_name ( @@a2@@ ) ; if ( __xstat ( Number , @@v7@@ , & @@v11@@ ) ) { @@v10@@ = __errno_location ( ) ; error ( Number , * @@v10@@ , String , @@v7@@ ) ; } if ( __xstat ( Number , @@v8@@ , & @@stat_buf@@ ) ) { @@v9@@ = __errno_location ( ) ; error ( Number , * @@v9@@ , String , @@v8@@ ) ; } @@v2@@ = Number ; if ( @@v11@@ . st_ino == @@stat_buf@@ . st_ino ) LOBYTE ( @@v2@@ ) = @@v11@@ . st_dev == @@stat_buf@@ . st_dev ; free ( @@v7@@ ) ; free ( @@v8@@ ) ; } return @@v2@@ ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
void __fastcall argmatch_invalid ( __int64 a1 , __int64 @@a2@@ , __int64 @@a3@@ ) { char * @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; if ( @@a3@@ == Number ) @@v3@@ = dcgettext ( Number L , String , Number ) ; else @@v3@@ = dcgettext ( Number L , String , Number ) ; @@v4@@ = quote_n ( Number L ) ; @@v5@@ = quotearg_n_style ( Number L , Number L , @@a2@@ ) ; error ( Number , Number , @@v3@@ , @@v5@@ , @@v4@@ ) ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
char can_write_any_file ( ) { char @@result@@ ; __uid_t @@v1@@ ; if ( initialized_2987 ) return can_write_2988 ; @@v1@@ = geteuid ( ) ; initialized_2987 = Number ; @@result@@ = @@v1@@ == Number ; can_write_2988 = @@result@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall get_version ( __int64 @@a1@@ , const char * @@a2@@ ) { __int64 @@result@@ ; if ( @@a2@@ && * @@a2@@ ) @@result@@ = get_version_part_0 ( @@a1@@ , @@a2@@ ) ; else @@result@@ = Number L ; return @@result@@ ; }
void __fastcall hold_file_isra_1 ( _DWORD * @@a1@@ , _DWORD * @@a2@@ ) { char @@v2@@ ; _DWORD * @@v3@@ ; char * @@v4@@ ; if ( parallel_files ) { * @@a1@@ = Number ; -- files_ready_to_read ; * @@a2@@ = Number ; } else { if ( columns ) { @@v2@@ = storing_columns ; @@v3@@ = ( char * ) column_vector + Number ; @@v4@@ = ( char * ) column_vector + Number * ( unsigned __int64 ) ( unsigned int ) ( columns - Number ) + Number ; do { while ( @@v2@@ ) { * @@v3@@ = Number ; @@v3@@ += Number ; if ( @@v3@@ == ( _DWORD * ) @@v4@@ ) goto LABEL_7 ; } * @@v3@@ = Number ; @@v3@@ += Number ; } while ( @@v3@@ != ( _DWORD * ) @@v4@@ ) ; } LABEL_7 : * @@a2@@ = Number ; -- files_ready_to_read ; } }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
void __fastcall align_column ( __int64 @@a1@@ ) { padding_not_printed = * ( _DWORD * ) ( @@a1@@ + Number ) ; if ( padding_not_printed - col_sep_length > Number ) { pad_across_to ( padding_not_printed - col_sep_length ) ; padding_not_printed = Number ; } if ( use_col_separator ) print_sep_string ( ) ; if ( * ( _BYTE * ) ( @@a1@@ + Number ) ) add_line_number_isra_2 ( ( __int64 ( __fastcall * * ) ( __int64 , __int64 ) ) ( @@a1@@ + Number ) ) ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_2051D0 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2051B0 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_2051C0 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_2051D0 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2051B0 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2051C0 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
_BYTE * __fastcall mdir_name ( void * @@src@@ ) { __int64 @@v1@@ ; _BYTE * @@v2@@ ; _BYTE * @@v3@@ ; _BYTE * @@v4@@ ; @@v1@@ = dir_len ( @@src@@ ) ; @@v2@@ = malloc ( @@v1@@ + ( @@v1@@ == Number ) + Number ) ; @@v3@@ = @@v2@@ ; if ( @@v2@@ ) { @@v4@@ = memcpy ( @@v2@@ , @@src@@ , @@v1@@ ) ; @@v3@@ = @@v4@@ ; if ( ! @@v1@@ ) { * @@v4@@ = Number ; @@v1@@ = Number L ; } @@v4@@ [ @@v1@@ ] = Number ; } return @@v3@@ ; }
__int64 __fastcall freadahead ( __int64 @@a1@@ ) { __int64 @@result@@ ; @@result@@ = Number L ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= * ( _QWORD * ) ( @@a1@@ + Number ) ) { @@result@@ = * ( _QWORD * ) ( @@a1@@ + Number ) - * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( ( * ( _DWORD * ) @@a1@@ & Number ) != Number ) @@result@@ += * ( _QWORD * ) ( @@a1@@ + Number ) - * ( _QWORD * ) ( @@a1@@ + Number ) ; } return @@result@@ ; }
void __fastcall close_file_part_4 ( __int64 @@a1@@ ) { FILE * @@v2@@ ; char * @@v3@@ ; char * @@v4@@ ; int @@v5@@ ; int * @@v6@@ ; int * @@v7@@ ; @@v2@@ = * ( FILE * * ) @@a1@@ ; if ( ( @@v2@@ -> _flags & Number ) != Number ) { @@v7@@ = __errno_location ( ) ; error ( Number , * @@v7@@ , String , * ( const char * * ) ( @@a1@@ + Number ) ) ; @@v2@@ = * ( FILE * * ) @@a1@@ ; } if ( fileno ( @@v2@@ ) && fclose ( * ( FILE * * ) @@a1@@ ) ) { @@v6@@ = __errno_location ( ) ; error ( Number , * @@v6@@ , String , * ( const char * * ) ( @@a1@@ + Number ) ) ; } if ( parallel_files ) { * ( _DWORD * ) ( @@a1@@ + Number ) = Number ; * ( _DWORD * ) ( @@a1@@ + Number ) = Number ; -- files_ready_to_read ; } else { if ( columns ) { @@v3@@ = ( char * ) column_vector + Number ; @@v4@@ = ( char * ) column_vector + Number * ( unsigned __int64 ) ( unsigned int ) ( columns - Number ) + Number ; do { @@v5@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( _DWORD * ) @@v3@@ = Number ; if ( ! @@v5@@ ) * ( ( _DWORD * ) @@v3@@ + Number ) = Number ; @@v3@@ += Number ; } while ( @@v3@@ != @@v4@@ ) ; } -- files_ready_to_read ; } }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
unsigned __int64 __fastcall next_prime ( unsigned __int64 @@a1@@ ) { unsigned __int64 @@v1@@ ; unsigned __int64 @@v2@@ ; __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; if ( @@a1@@ < Number ) @@a1@@ = Number L ; @@v1@@ = @@a1@@ | Number ; if ( @@v1@@ != Number ) { while ( Number ) { @@v2@@ = @@v1@@ % Number ; if ( @@v1@@ <= Number ) goto LABEL_9 ; if ( @@v1@@ % Number ) break ; LABEL_10 : @@v1@@ += Number L ; if ( @@v1@@ == Number ) return @@v1@@ ; } @@v3@@ = Number L ; @@v4@@ = Number L ; @@v5@@ = Number L ; while ( Number ) { @@v5@@ += Number L ; @@v4@@ += @@v3@@ ; @@v2@@ = @@v1@@ % @@v5@@ ; if ( @@v4@@ >= @@v1@@ ) break ; @@v3@@ += Number L ; if ( ! ( @@v1@@ % @@v5@@ ) ) goto LABEL_10 ; } LABEL_9 : if ( @@v2@@ ) return @@v1@@ ; goto LABEL_10 ; } return @@v1@@ ; }
__int64 __fastcall knuth_morris_pratt_unibyte ( unsigned __int8 * @@a1@@ , const char * @@a2@@ , unsigned __int8 * * @@a3@@ ) { const char * @@v4@@ ; size_t @@v6@@ ; void * @@v7@@ ; __int64 * @@v8@@ ; __int64 @@v9@@ ; __int64 @@i@@ ; char @@v11@@ ; __int64 @@v12@@ ; unsigned __int8 * @@v13@@ ; __int64 @@v14@@ ; __int64 @@v16@@ ; @@v4@@ = @@a2@@ ; @@v6@@ = strlen ( @@a2@@ ) ; if ( @@v6@@ > Number ) return Number L ; if ( Number * @@v6@@ > Number ) { @@v8@@ = ( __int64 * ) mmalloca ( ) ; } else { @@v7@@ = alloca ( Number * @@v6@@ + Number ) ; @@v8@@ = & @@v16@@ ; } if ( ! @@v8@@ ) return Number L ; @@v8@@ [ Number ] = Number L ; if ( @@v6@@ > Number ) { @@v9@@ = Number L ; for ( @@i@@ = Number L ; @@i@@ != @@v6@@ ; ++ @@i@@ ) { @@v11@@ = @@a2@@ [ @@i@@ - Number ] ; if ( @@v11@@ == @@a2@@ [ @@v9@@ ] ) { LABEL_23 : ++ @@v9@@ ; @@v8@@ [ @@i@@ ] = @@i@@ - @@v9@@ ; } else { while ( @@v9@@ ) { @@v9@@ -= @@v8@@ [ @@v9@@ ] ; if ( @@v11@@ == @@a2@@ [ @@v9@@ ] ) goto LABEL_23 ; } @@v8@@ [ @@i@@ ] = @@i@@ ; @@v9@@ = Number L ; } } } * @@a3@@ = Number L ; @@v12@@ = * @@a1@@ ; @@v13@@ = @@a1@@ ; @@v14@@ = Number L ; LABEL_14 : while ( Number ) { if ( ( _BYTE ) @@v12@@ ) { while ( @@v4@@ [ @@v14@@ ] != ( _BYTE ) @@v12@@ ) { if ( ! @@v14@@ ) { @@v12@@ = @@v13@@ [ Number ] ; ++ @@a1@@ ; ++ @@v13@@ ; goto LABEL_14 ; } @@a2@@ = ( const char * ) @@v8@@ [ @@v14@@ ] ; @@a1@@ = & @@a1@@ [ ( _QWORD ) @@a2@@ ] ; @@v14@@ -= ( __int64 ) @@a2@@ ; } ++ @@v14@@ ; @@a2@@ = ( const char * ) ( @@v13@@ + Number ) ; if ( @@v6@@ != @@v14@@ ) { @@v12@@ = * ++ @@v13@@ ; continue ; } * @@a3@@ = @@a1@@ ; } break ; } freea ( @@v8@@ , @@a2@@ , @@v12@@ , @@v13@@ ) ; return Number L ; }
int __freading ( FILE * @@fp@@ ) { return _freading ( @@fp@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 __fastcall hash_get_n_entries ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
unsigned __int64 __fastcall getoptarg ( char * @@nptr@@ , char @@a2@@ , char * @@a3@@ , _DWORD * @@a4@@ ) { char * @@v5@@ ; char @@v6@@ ; __int64 @@v8@@ ; char * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; @@v5@@ = @@nptr@@ ; @@v11@@ = __readfsqword ( Number ) ; @@v6@@ = * @@nptr@@ ; if ( ( unsigned int ) ( * @@nptr@@ - Number ) > Number ) { * @@a3@@ = @@v6@@ ; @@v6@@ = @@nptr@@ [ Number ] ; @@v5@@ = @@nptr@@ + Number ; } if ( @@v6@@ ) { if ( ( unsigned int ) xstrtol ( @@v5@@ ) || ( unsigned __int64 ) ( @@v10@@ - Number ) > Number ) { @@v8@@ = quote ( @@v5@@ , Number L ) ; @@v9@@ = dcgettext ( Number L , String , Number ) ; error ( Number , Number , @@v9@@ , ( unsigned int ) @@a2@@ , @@v8@@ ) ; usage ( Number ) ; } * @@a4@@ = @@v10@@ ; } return __readfsqword ( Number ) ^ @@v11@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
void free ( void * @@ptr@@ ) { __imp_free ( @@ptr@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
int unlink ( const char * @@name@@ ) { return unlink ( @@name@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 __fastcall hash_print_statistics ( __int64 @@a1@@ ) { unsigned __int64 @@v1@@ ; _QWORD * @@v2@@ ; unsigned __int64 @@i@@ ; __int64 @@v4@@ ; unsigned __int64 @@j@@ ; @@v1@@ = Number L ; @@v2@@ = * ( _QWORD * * ) @@a1@@ ; for ( @@i@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; ( unsigned __int64 ) @@v2@@ < @@i@@ ; @@v2@@ += Number ) { if ( * @@v2@@ ) { @@v4@@ = @@v2@@ [ Number ] ; for ( @@j@@ = Number L ; @@v4@@ ; ++ @@j@@ ) @@v4@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; if ( @@v1@@ < @@j@@ ) @@v1@@ = @@j@@ ; } } __fprintf_chk ( ) ; __fprintf_chk ( ) ; __fprintf_chk ( ) ; return __fprintf_chk ( ) ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
void __fastcall decode_preserve_arg ( void * @@a1@@ , _BYTE * @@a2@@ , char @@a3@@ ) { const char * @@v4@@ ; const char * @@v5@@ ; char * @@v6@@ ; bool @@v7@@ ; char * @@ptr@@ ; @@ptr@@ = ( char * ) xstrdup ( @@a1@@ ) ; @@v4@@ = @@ptr@@ ; do { @@v5@@ = Number L ; @@v6@@ = strchr ( @@v4@@ , Number ) ; if ( @@v6@@ ) { @@v5@@ = @@v6@@ + Number ; * @@v6@@ = Number ; } switch ( _xargmatch_internal ( String , @@v4@@ , preserve_args_6810 , & preserve_vals_6809 , Number L , argmatch_die ) ) { case Number L : case Number L : case Number L : @@a2@@ [ Number ] = @@a3@@ ; break ; case Number L : case Number L : case Number L : @@a2@@ [ Number ] = @@a3@@ ; break ; case Number L : case Number L : case Number L : @@a2@@ [ Number ] = @@a3@@ ; break ; case Number L : case Number L : @@a2@@ [ Number ] = @@a3@@ ; break ; case Number L : @@a2@@ [ Number ] = @@a3@@ ; @@a2@@ [ Number ] = @@a3@@ ; break ; case Number L : @@a2@@ [ Number ] = @@a3@@ ; @@a2@@ [ Number ] = @@a3@@ ; break ; case Number L : @@v7@@ = selinux_enabled == Number ; @@a2@@ [ Number ] = @@a3@@ ; @@a2@@ [ Number ] = @@a3@@ ; @@a2@@ [ Number ] = @@a3@@ ; @@a2@@ [ Number ] = @@a3@@ ; if ( ! @@v7@@ ) @@a2@@ [ Number ] = @@a3@@ ; @@a2@@ [ Number ] = @@a3@@ ; break ; default : abort ( ) ; } @@v4@@ = @@v5@@ ; } while ( @@v5@@ ) ; free ( @@ptr@@ ) ; }
int __lxstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _lxstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
__int64 __fastcall hash_get_next ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; __int64 * @@v6@@ ; _QWORD * @@v7@@ ; __int64 @@v8@@ ; __int64 @@result@@ ; @@v2@@ = * @@a1@@ ; @@v4@@ = ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) ; @@v5@@ = @@a1@@ [ Number ] ; @@v6@@ = ( __int64 * ) ( @@v2@@ + Number * @@v4@@ ) ; if ( @@v5@@ <= ( unsigned __int64 ) @@v6@@ ) abort ( ) ; if ( ! @@v6@@ ) goto LABEL_10 ; @@v7@@ = ( _QWORD * ) @@v6@@ [ Number ] ; if ( * @@v6@@ != @@a2@@ ) { do { if ( ! @@v7@@ ) goto LABEL_10 ; @@v8@@ = * @@v7@@ ; @@v7@@ = ( _QWORD * ) @@v7@@ [ Number ] ; } while ( @@v8@@ != @@a2@@ ) ; } if ( @@v7@@ ) return * @@v7@@ ; LABEL_10 : while ( Number ) { @@v6@@ += Number ; if ( @@v5@@ <= ( unsigned __int64 ) @@v6@@ ) break ; @@result@@ = * @@v6@@ ; if ( * @@v6@@ ) return @@result@@ ; } return Number L ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
__mode_t umask ( __mode_t @@mask@@ ) { return umask ( @@mask@@ ) ; }
__int64 __fastcall set_acl ( const char * @@a1@@ , int @@a2@@ , __mode_t @@a3@@ ) { unsigned int @@v3@@ ; __int64 @@v4@@ ; char * @@v5@@ ; int * @@v6@@ ; @@v3@@ = chmod_or_fchmod ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( @@v3@@ ) { @@v4@@ = quote ( @@a1@@ ) ; @@v5@@ = dcgettext ( Number L , String , Number ) ; @@v6@@ = __errno_location ( ) ; error ( Number , * @@v6@@ , @@v5@@ , @@v4@@ ) ; } return @@v3@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
int iswalnum ( wint_t @@wc@@ ) { return iswalnum ( @@wc@@ ) ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
int __fxstat ( int @@ver@@ , int @@fildes@@ , struct stat * @@stat_buf@@ ) { return _fxstat ( @@ver@@ , @@fildes@@ , @@stat_buf@@ ) ; }
bool __fastcall seen_file ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 * @@a3@@ ) { bool @@result@@ ; __int64 @@v4@@ ; __int64 @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; @@result@@ = Number ; if ( @@a1@@ ) { @@v4@@ = @@a3@@ [ Number ] ; @@v5@@ [ Number ] = @@a2@@ ; @@v5@@ [ Number ] = @@v4@@ ; @@v5@@ [ Number ] = * @@a3@@ ; @@result@@ = hash_lookup ( @@a1@@ , @@v5@@ ) != Number ; } return @@result@@ ; }
void __fastcall hash_free ( void * @@ptr@@ ) { _QWORD * @@v2@@ ; unsigned __int64 @@v3@@ ; _QWORD * @@v4@@ ; _QWORD * @@v5@@ ; _QWORD * @@v6@@ ; _QWORD * @@v7@@ ; _QWORD * @@v8@@ ; @@v2@@ = * ( _QWORD * * ) @@ptr@@ ; @@v3@@ = * ( ( _QWORD * ) @@ptr@@ + Number ) ; if ( * ( ( _QWORD * ) @@ptr@@ + Number ) && * ( ( _QWORD * ) @@ptr@@ + Number ) ) { if ( ( unsigned __int64 ) @@v2@@ >= @@v3@@ ) goto LABEL_14 ; do { if ( * @@v2@@ ) { @@v4@@ = @@v2@@ ; do { ( * ( ( void ( * * ) ( void ) ) @@ptr@@ + Number ) ) ( ) ; @@v4@@ = ( _QWORD * ) @@v4@@ [ Number ] ; } while ( @@v4@@ ) ; @@v3@@ = * ( ( _QWORD * ) @@ptr@@ + Number ) ; } @@v2@@ += Number ; } while ( @@v3@@ > ( unsigned __int64 ) @@v2@@ ) ; @@v2@@ = * ( _QWORD * * ) @@ptr@@ ; } if ( ( unsigned __int64 ) @@v2@@ < @@v3@@ ) { do { @@v5@@ = ( _QWORD * ) @@v2@@ [ Number ] ; if ( @@v5@@ ) { do { @@v6@@ = ( _QWORD * ) @@v5@@ [ Number ] ; free ( @@v5@@ ) ; @@v5@@ = @@v6@@ ; } while ( @@v6@@ ) ; } @@v2@@ += Number ; } while ( * ( ( _QWORD * ) @@ptr@@ + Number ) > ( unsigned __int64 ) @@v2@@ ) ; } LABEL_14 : @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@ptr@@ + Number ) ; if ( @@v7@@ ) { do { @@v8@@ = ( _QWORD * ) @@v7@@ [ Number ] ; free ( @@v7@@ ) ; @@v7@@ = @@v8@@ ; } while ( @@v8@@ ) ; } free ( * ( void * * ) @@ptr@@ ) ; free ( @@ptr@@ ) ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
DIR * fdopendir ( int @@fd@@ ) { return fdopendir ( @@fd@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
unsigned __int64 __fastcall triple_hash_no_name ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) % @@a2@@ ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
void __fastcall triple_free ( void * @@ptr@@ ) { free ( * ( void * * ) @@ptr@@ ) ; free ( @@ptr@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
const char * __fastcall proper_name ( char * @@s@@ ) { char * @@v1@@ ; const char * @@v2@@ ; size_t @@v4@@ ; size_t @@v5@@ ; __int64 @@v6@@ ; @@v1@@ = dcgettext ( Number L , @@s@@ , Number ) ; @@v2@@ = @@v1@@ ; if ( @@s@@ == @@v1@@ || ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@v1@@ , ( __int64 ) @@s@@ ) ) { return @@v2@@ ; } @@v4@@ = strlen ( @@v2@@ ) ; @@v5@@ = strlen ( @@s@@ ) ; @@v6@@ = xmalloc ( @@v4@@ + @@v5@@ + Number ) ; __sprintf_chk ( ) ; return ( const char * ) @@v6@@ ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
int __fastcall emit_verbose ( __int64 a1 , __int64 a2 , __int64 @@a3@@ ) { char * @@v4@@ ; quote_n ( Number L ) ; quote_n ( Number L ) ; __printf_chk ( ) ; if ( @@a3@@ ) { quote ( @@a3@@ ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } @@v4@@ = stdout -> _IO_write_ptr ; if ( @@v4@@ >= stdout -> _IO_write_end ) { LODWORD ( @@v4@@ ) = __overflow ( stdout , Number ) ; } else { stdout -> _IO_write_ptr = @@v4@@ + Number ; * @@v4@@ = Number ; } return ( int ) @@v4@@ ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
__int64 __fastcall copy ( char * @@a1@@ , char * @@a2@@ , char @@a3@@ , __m128i * @@a4@@ , __int64 @@a5@@ , _BYTE * @@a6@@ ) { __int32 @@v6@@ ; unsigned int @@v7@@ ; char @@v9@@ ; unsigned __int64 @@v10@@ ; @@v10@@ = __readfsqword ( Number ) ; if ( ! @@a4@@ ) __assert_fail ( String , String , Number , String ) ; if ( @@a4@@ -> m128i_i32 [ Number ] > Number ) __assert_fail ( String , String , Number , String ) ; @@v6@@ = @@a4@@ -> m128i_i32 [ Number ] ; if ( ( unsigned int ) ( @@v6@@ - Number ) > Number ) __assert_fail ( String , String , Number , String ) ; @@v7@@ = @@a4@@ [ Number ] . m128i_u32 [ Number ] ; if ( @@v7@@ > Number ) __assert_fail ( String , String , Number , String ) ; if ( @@a4@@ [ Number ] . m128i_i8 [ Number ] && @@a4@@ [ Number ] . m128i_i8 [ Number ] ) __assert_fail ( String , String , Number , String ) ; if ( @@v6@@ != Number && @@v7@@ == Number ) __assert_fail ( String , String , Number , String ) ; @@v9@@ = Number ; top_level_dst_name = ( __int64 ) @@a2@@ ; top_level_src_name = ( __int64 ) @@a1@@ ; return copy_internal ( @@a1@@ , @@a2@@ , @@a3@@ , Number L , Number L , @@a4@@ , Number , & @@v9@@ , @@a5@@ , @@a6@@ ) ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
int __fastcall argmatch_valid ( _QWORD * @@a1@@ , char * @@a2@@ , size_t @@a3@@ ) { const void * @@v5@@ ; __int64 @@v6@@ ; char * @@v7@@ ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; if ( * @@a1@@ ) { @@v5@@ = Number L ; @@v6@@ = Number L ; do { while ( ! @@v6@@ || memcmp ( @@v5@@ , @@a2@@ , @@a3@@ ) ) { ++ @@v6@@ ; @@v5@@ = @@a2@@ ; __fprintf_chk ( ) ; @@a2@@ += @@a3@@ ; if ( ! @@a1@@ [ @@v6@@ ] ) goto LABEL_7 ; } ++ @@v6@@ ; @@a2@@ += @@a3@@ ; __fprintf_chk ( ) ; } while ( @@a1@@ [ @@v6@@ ] ) ; } LABEL_7 : @@v7@@ = stderr -> _IO_write_ptr ; if ( @@v7@@ >= stderr -> _IO_write_end ) { LODWORD ( @@v7@@ ) = __overflow ( stderr , Number ) ; } else { stderr -> _IO_write_ptr = @@v7@@ + Number ; * @@v7@@ = Number ; } return ( int ) @@v7@@ ; }
bool __fastcall dev_info_compare ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { return * @@a1@@ == * @@a2@@ ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name_0 = @@a1@@ ; }
__int64 __fastcall full_write ( int @@fd@@ , void * @@buf@@ , size_t @@n@@ ) { size_t @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; if ( ! @@n@@ ) return Number L ; @@v4@@ = @@n@@ ; @@v5@@ = Number L ; do { @@v6@@ = safe_write ( @@fd@@ , @@buf@@ , @@v4@@ ) ; if ( @@v6@@ == Number ) break ; if ( ! @@v6@@ ) { * __errno_location ( ) = Number ; return @@v5@@ ; } @@v5@@ += @@v6@@ ; @@buf@@ = ( char * ) @@buf@@ + @@v6@@ ; @@v4@@ -= @@v6@@ ; } while ( @@v4@@ ) ; return @@v5@@ ; }
__mode_t umask ( __mode_t @@mask@@ ) { return umask ( @@mask@@ ) ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_20E330 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20E310 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20E320 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall dir_name ( void * @@a1@@ ) { __int64 @@result@@ ; @@result@@ = mdir_name ( @@a1@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
__int64 __fastcall validate_timespec ( _QWORD * @@a1@@ ) { unsigned __int64 @@v1@@ ; unsigned __int64 @@v2@@ ; int @@v3@@ ; int @@v4@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) __assert_fail ( String , String , Number , String ) ; @@v1@@ = @@a1@@ [ Number ] ; if ( @@v1@@ - Number > Number && @@v1@@ > Number || ( @@v2@@ = @@a1@@ [ Number ] , @@v2@@ - Number > Number ) && @@v2@@ > Number ) { * __errno_location ( ) = Number ; @@result@@ = Number ; } else { @@v3@@ = Number ; @@v4@@ = Number ; if ( @@v1@@ - Number <= Number ) { * @@a1@@ = Number L ; @@v3@@ = @@v1@@ == Number ; @@v4@@ = Number ; } if ( @@v2@@ - Number <= Number ) { @@a1@@ [ Number ] = Number L ; @@v4@@ = Number ; @@v3@@ += @@v2@@ == Number ; } @@result@@ = @@v4@@ + ( unsigned int ) ( @@v3@@ == Number ) ; } return @@result@@ ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
__int64 __fastcall memcpy_uppcase ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v3@@ ; const __int32_t * * @@v4@@ ; if ( @@a3@@ ) { @@v3@@ = @@a3@@ - Number ; @@v4@@ = __ctype_toupper_loc ( ) ; do { * ( _BYTE * ) ( @@a1@@ + @@v3@@ ) = ( * @@v4@@ ) [ * ( unsigned __int8 * ) ( @@a2@@ + @@v3@@ ) ] ; -- @@v3@@ ; } while ( @@v3@@ != Number ) ; } return @@a1@@ ; }
int __fastcall rpl_fflush ( FILE * @@stream@@ ) { if ( ! @@stream@@ || ! __freading ( @@stream@@ ) || ( @@stream@@ -> _flags & Number ) == Number ) { return fflush ( @@stream@@ ) ; } rpl_fseeko ( @@stream@@ , Number L , Number ) ; return fflush ( @@stream@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
__int64 __fastcall argmatch ( const char * @@a1@@ , const char * * @@a2@@ , char * @@a3@@ , size_t @@a4@@ ) { char * @@v5@@ ; size_t @@v6@@ ; const char * @@v7@@ ; size_t @@v8@@ ; __int64 @@v9@@ ; bool @@v10@@ ; char @@v11@@ ; __int64 @@v12@@ ; __int64 @@v14@@ ; char @@v15@@ ; @@v5@@ = @@a3@@ ; @@v6@@ = strlen ( @@a1@@ ) ; @@v7@@ = * @@a2@@ ; @@v14@@ = Number ; if ( ! * @@a2@@ ) return @@v14@@ ; @@v8@@ = @@v6@@ ; @@v15@@ = Number ; @@v9@@ = Number L ; do { while ( strncmp ( @@v7@@ , @@a1@@ , @@v8@@ ) ) { LABEL_7 : ++ @@v9@@ ; @@v5@@ += @@a4@@ ; @@v7@@ = @@a2@@ [ @@v9@@ ] ; if ( ! @@v7@@ ) goto LABEL_12 ; } if ( strlen ( @@v7@@ ) == @@v8@@ ) return @@v9@@ ; if ( @@v14@@ != Number ) { if ( @@a3@@ ) { @@v10@@ = memcmp ( & @@a3@@ [ @@a4@@ * @@v14@@ ] , @@v5@@ , @@a4@@ ) == Number ; @@v11@@ = @@v15@@ ; if ( ! @@v10@@ ) @@v11@@ = Number ; @@v15@@ = @@v11@@ ; } else { @@v15@@ = Number ; } goto LABEL_7 ; } @@v14@@ = @@v9@@ ++ ; @@v5@@ += @@a4@@ ; @@v7@@ = @@a2@@ [ @@v9@@ ] ; } while ( @@v7@@ ) ; LABEL_12 : @@v12@@ = Number ; if ( ! @@v15@@ ) @@v12@@ = @@v14@@ ; return @@v12@@ ; }
__int64 __fastcall file_name_concat ( void * @@a1@@ , void * @@a2@@ ) { __int64 @@result@@ ; @@result@@ = mfile_name_concat ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
__int64 __fastcall rpl_fcntl ( int @@a1@@ , int @@a2@@ , __int64 @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { int @@v6@@ ; int @@v8@@ ; int @@v9@@ ; int @@v10@@ ; int @@v11@@ ; int * @@v12@@ ; int @@v13@@ ; int * @@v14@@ ; int @@v15@@ ; @@v15@@ = @@a3@@ ; if ( @@a2@@ != Number ) return ( unsigned int ) fcntl ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( have_dupfd_cloexec_3202 < Number ) { @@v6@@ = rpl_fcntl ( @@a1@@ , Number , ( unsigned int ) @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( @@v6@@ < Number || have_dupfd_cloexec_3202 != Number ) return ( unsigned int ) @@v6@@ ; } else { @@v6@@ = fcntl ( @@a1@@ , Number , ( unsigned int ) @@a3@@ ) ; if ( @@v6@@ >= Number || * __errno_location ( ) != Number ) { have_dupfd_cloexec_3202 = Number ; return ( unsigned int ) @@v6@@ ; } @@v6@@ = rpl_fcntl ( @@a1@@ , Number , @@v15@@ , @@v8@@ , @@v9@@ , @@v10@@ ) ; if ( @@v6@@ < Number ) return ( unsigned int ) @@v6@@ ; have_dupfd_cloexec_3202 = Number ; } @@v11@@ = fcntl ( @@v6@@ , Number ) ; if ( @@v11@@ < Number || fcntl ( @@v6@@ , Number , @@v11@@ | Number ) == Number ) { @@v12@@ = __errno_location ( ) ; @@v13@@ = * @@v12@@ ; @@v14@@ = @@v12@@ ; close ( @@v6@@ ) ; @@v6@@ = Number ; * @@v14@@ = @@v13@@ ; } return ( unsigned int ) @@v6@@ ; }
__int64 __fastcall filemodestring ( __int64 @@a1@@ , __int64 @@a2@@ ) { return strmode ( * ( _DWORD * ) ( @@a1@@ + Number ) , @@a2@@ ) ; }
int __fastcall rpl_fseeko ( FILE * @@stream@@ , __off_t @@offset@@ , int @@whence@@ ) { int @@v5@@ ; int @@v6@@ ; if ( @@stream@@ -> _IO_read_end != @@stream@@ -> _IO_read_ptr || @@stream@@ -> _IO_write_ptr != @@stream@@ -> _IO_write_base || @@stream@@ -> _IO_save_base ) { return fseeko ( @@stream@@ , @@offset@@ , @@whence@@ ) ; } if ( @@whence@@ == Number && @@offset@@ > Number ) { @@v5@@ = fileno ( @@stream@@ ) ; if ( lseek ( @@v5@@ , Number L , Number ) != Number ) { @@stream@@ -> _flags &= Number ; return fseeko ( @@stream@@ , @@offset@@ , @@whence@@ ) ; } } else { @@v6@@ = fileno ( @@stream@@ ) ; if ( lseek ( @@v6@@ , @@offset@@ , @@whence@@ ) != Number ) { @@stream@@ -> _flags &= Number ; return Number ; } } return Number ; }
__int64 yesno ( ) { unsigned int @@v0@@ ; __ssize_t @@v1@@ ; char * @@lineptr@@ ; size_t @@n@@ [ Number ] ; @@v0@@ = Number ; @@lineptr@@ = Number L ; @@n@@ [ Number ] = __readfsqword ( Number ) ; @@n@@ [ Number ] = Number L ; @@v1@@ = __getdelim ( & @@lineptr@@ , @@n@@ , Number , stdin ) ; if ( @@v1@@ > Number ) { @@lineptr@@ [ @@v1@@ - Number ] = Number ; LOBYTE ( @@v0@@ ) = rpmatch ( @@lineptr@@ ) > Number ; } free ( @@lineptr@@ ) ; return @@v0@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
void * __fastcall mfile_name_concat ( void * @@src@@ , void * @@a2@@ , _QWORD * @@a3@@ ) { const char * @@v4@@ ; const char * @@v5@@ ; size_t @@v6@@ ; size_t @@v7@@ ; _BOOL8 @@v8@@ ; void * @@v9@@ ; void * @@v10@@ ; _BYTE * @@v11@@ ; char * @@v12@@ ; size_t @@n@@ ; char @@v15@@ ; @@v4@@ = ( const char * ) @@a2@@ ; @@v5@@ = last_component ( @@src@@ ) ; @@v6@@ = base_len ( @@v5@@ ) ; @@v7@@ = @@v6@@ + @@v5@@ - ( _BYTE * ) @@src@@ ; @@v8@@ = @@v6@@ ; if ( @@v6@@ ) @@v8@@ = @@v5@@ [ @@v6@@ - Number ] != Number ; @@v15@@ = * ( _BYTE * ) @@a2@@ ; if ( * ( _BYTE * ) @@a2@@ == Number ) { do ++ @@v4@@ ; while ( * @@v4@@ == Number ) ; } @@n@@ = strlen ( @@v4@@ ) ; @@v9@@ = malloc ( @@n@@ + @@v8@@ + @@v7@@ + Number ) ; @@v10@@ = @@v9@@ ; if ( @@v9@@ ) { @@v11@@ = mempcpy ( @@v9@@ , @@src@@ , @@v7@@ ) ; * @@v11@@ = Number ; @@v12@@ = & @@v11@@ [ @@v8@@ ] ; if ( @@a3@@ ) * @@a3@@ = & @@v12@@ [ - ( @@v15@@ == Number ) ] ; * ( _BYTE * ) mempcpy ( @@v12@@ , @@v4@@ , @@n@@ ) = Number ; } return @@v10@@ ; }
unsigned __int64 __fastcall hash_pjw ( char * @@a1@@ , unsigned __int64 @@a2@@ ) { __int64 @@v2@@ ; unsigned __int64 @@v3@@ ; @@v2@@ = * @@a1@@ ; if ( ! ( _BYTE ) @@v2@@ ) return Number L ; @@v3@@ = Number L ; do { ++ @@a1@@ ; @@v3@@ = @@v2@@ + __ROL8__ ( @@v3@@ , Number ) ; @@v2@@ = * @@a1@@ ; } while ( ( _BYTE ) @@v2@@ ) ; return @@v3@@ % @@a2@@ ; }
__int64 __fastcall check_tuning_isra_0 ( float * * @@a1@@ ) { float * @@v1@@ ; __int64 @@result@@ ; float @@v3@@ ; float @@v4@@ ; float @@v5@@ ; @@v1@@ = * @@a1@@ ; @@result@@ = Number L ; if ( * @@a1@@ != ( float * ) & default_tuning ) { @@v3@@ = @@v1@@ [ Number ] ; if ( @@v3@@ <= Number || @@v3@@ >= Number || @@v1@@ [ Number ] <= Number || * @@v1@@ < Number || ( @@v4@@ = * @@v1@@ + Number , @@v5@@ = @@v1@@ [ Number ] , @@v5@@ <= @@v4@@ ) || @@v5@@ > Number || @@v3@@ <= @@v4@@ ) { * @@a1@@ = ( float * ) & default_tuning ; @@result@@ = Number L ; } } return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
bool __fastcall hash_table_ok ( __int64 @@a1@@ ) { _QWORD * @@v1@@ ; unsigned __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; bool @@result@@ ; @@v1@@ = * ( _QWORD * * ) @@a1@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v3@@ = Number L ; @@v4@@ = Number L ; if ( * ( _QWORD * ) @@a1@@ < @@v2@@ ) { do { if ( * @@v1@@ ) { @@v5@@ = @@v1@@ [ Number ] ; ++ @@v4@@ ; ++ @@v3@@ ; for ( ; @@v5@@ ; ++ @@v3@@ ) @@v5@@ = * ( _QWORD * ) ( @@v5@@ + Number ) ; } @@v1@@ += Number ; } while ( ( unsigned __int64 ) @@v1@@ < @@v2@@ ) ; } @@result@@ = Number ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) == @@v4@@ ) @@result@@ = * ( _QWORD * ) ( @@a1@@ + Number ) == @@v3@@ ; return @@result@@ ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
unsigned __int64 __fastcall hash_get_entries ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { _QWORD * @@v3@@ ; unsigned __int64 @@v4@@ ; _QWORD * @@v5@@ ; unsigned __int64 @@result@@ ; @@v3@@ = * ( _QWORD * * ) @@a1@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= * ( _QWORD * ) @@a1@@ ) return Number L ; @@v4@@ = Number L ; while ( ! * @@v3@@ ) { LABEL_9 : @@v3@@ += Number ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= ( unsigned __int64 ) @@v3@@ ) return @@v4@@ ; } if ( @@a3@@ <= @@v4@@ ) return @@v4@@ ; * ( _QWORD * ) ( @@a2@@ + Number * @@v4@@ ) = * @@v3@@ ; @@v5@@ = ( _QWORD * ) @@v3@@ [ Number ] ; @@result@@ = @@v4@@ + Number ; if ( ! @@v5@@ ) { LABEL_8 : @@v4@@ = @@result@@ ; goto LABEL_9 ; } while ( @@a3@@ != @@result@@ ) { ++ @@result@@ ; * ( _QWORD * ) ( @@a2@@ + Number * @@result@@ - Number ) = * @@v5@@ ; @@v5@@ = ( _QWORD * ) @@v5@@ [ Number ] ; if ( ! @@v5@@ ) goto LABEL_8 ; } return @@result@@ ; }
__int64 __fastcall hash_lookup ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; _QWORD * @@v4@@ ; __int64 @@v5@@ ; @@v2@@ = * @@a1@@ ; @@v4@@ = ( _QWORD * ) ( Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) + @@v2@@ ) ; if ( @@a1@@ [ Number ] <= ( unsigned __int64 ) @@v4@@ ) abort ( ) ; @@v5@@ = * @@v4@@ ; if ( ! * @@v4@@ ) return Number L ; while ( @@v5@@ != @@a2@@ ) { if ( ( ( unsigned __int8 ( __fastcall * ) ( __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ ) ) return * @@v4@@ ; @@v4@@ = ( _QWORD * ) @@v4@@ [ Number ] ; if ( ! @@v4@@ ) return Number L ; @@v5@@ = * @@v4@@ ; } return @@v5@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
__int64 __fastcall fd_safer ( int @@fd@@ , __int64 @@a2@@ , __int64 @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { unsigned int @@v6@@ ; unsigned int @@v7@@ ; int * @@v8@@ ; int @@v9@@ ; int * @@v10@@ ; char @@v12@@ ; @@v6@@ = @@fd@@ ; if ( ( unsigned int ) @@fd@@ <= Number ) { @@v7@@ = dup_safer ( @@fd@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ , @@v12@@ ) ; @@v8@@ = __errno_location ( ) ; @@v9@@ = * @@v8@@ ; @@v10@@ = @@v8@@ ; close ( @@fd@@ ) ; @@v6@@ = @@v7@@ ; * @@v10@@ = @@v9@@ ; } return @@v6@@ ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall hash_do_for_each ( __int64 @@a1@@ , unsigned __int8 ( __fastcall * @@a2@@ ) ( __int64 , __int64 ) , __int64 @@a3@@ ) { __int64 * @@v3@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 * @@v8@@ ; @@v3@@ = * ( __int64 * * ) @@a1@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= * ( _QWORD * ) @@a1@@ ) return Number L ; @@v6@@ = Number L ; while ( Number ) { @@v7@@ = * @@v3@@ ; if ( * @@v3@@ ) break ; LABEL_8 : @@v3@@ += Number ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= ( unsigned __int64 ) @@v3@@ ) return @@v6@@ ; } @@v8@@ = @@v3@@ ; while ( @@a2@@ ( @@v7@@ , @@a3@@ ) ) { @@v8@@ = ( __int64 * ) @@v8@@ [ Number ] ; ++ @@v6@@ ; if ( ! @@v8@@ ) goto LABEL_8 ; @@v7@@ = * @@v8@@ ; } return @@v6@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
int __fastcall rpl_linkat ( int @@fd@@ , char * @@path@@ , int @@a3@@ , const char * @@a4@@ , int @@a5@@ ) { int @@v6@@ ; char * @@v8@@ ; int @@v9@@ ; char * @@v10@@ ; _BYTE * @@v11@@ ; void * @@v12@@ ; _BYTE * @@v13@@ ; int @@v14@@ ; int @@v15@@ ; int @@tofda@@ ; int * @@v19@@ ; if ( ! @@a5@@ ) return linkat ( @@fd@@ , @@path@@ , @@a3@@ , @@a4@@ , Number ) ; if ( ( @@a5@@ & Number ) != Number ) { @@v6@@ = Number ; * __errno_location ( ) = Number ; return @@v6@@ ; } if ( have_follow_really_4922 < Number ) { @@v19@@ = __errno_location ( ) ; } else { @@v6@@ = linkat ( @@fd@@ , @@path@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; if ( @@v6@@ != Number || ( @@v19@@ = __errno_location ( ) , * @@v19@@ != Number ) ) { have_follow_really_4922 = Number ; return @@v6@@ ; } have_follow_really_4922 = Number ; } @@v8@@ = @@path@@ ; @@v9@@ = Number ; while ( Number ) { @@v11@@ = ( _BYTE * ) areadlinkat ( @@fd@@ , @@v8@@ ) ; @@v12@@ = @@v11@@ ; if ( ! @@v11@@ ) break ; if ( * @@v11@@ != Number ) { @@v13@@ = mdir_name ( @@v8@@ ) ; if ( @@path@@ != @@v8@@ ) free ( @@v8@@ ) ; if ( ! @@v13@@ ) { @@v6@@ = Number ; free ( @@v12@@ ) ; * @@v19@@ = Number ; return @@v6@@ ; } @@v8@@ = ( char * ) mfile_name_concat ( @@v13@@ , @@v12@@ , Number L ) ; free ( @@v13@@ ) ; free ( @@v12@@ ) ; if ( ! @@v8@@ ) { @@v6@@ = Number ; * @@v19@@ = Number ; return @@v6@@ ; } goto LABEL_11 ; } if ( @@path@@ == @@v8@@ ) { -- @@v9@@ ; @@v8@@ = @@v11@@ ; if ( ! @@v9@@ ) { LABEL_20 : * @@v19@@ = Number ; @@v14@@ = Number ; goto LABEL_21 ; } } else { @@v10@@ = @@v8@@ ; @@v8@@ = @@v11@@ ; free ( @@v10@@ ) ; LABEL_11 : if ( ! -- @@v9@@ ) goto LABEL_20 ; } } @@v14@@ = * @@v19@@ ; if ( * @@v19@@ != Number ) { LABEL_21 : @@tofda@@ = @@v14@@ ; @@v6@@ = Number ; if ( @@path@@ != @@v8@@ ) { free ( @@v8@@ ) ; * @@v19@@ = @@tofda@@ ; } return @@v6@@ ; } @@v6@@ = linkat ( @@fd@@ , @@v8@@ , @@a3@@ , @@a4@@ , Number ) ; if ( @@path@@ != @@v8@@ ) { @@v15@@ = * @@v19@@ ; free ( @@v8@@ ) ; * @@v19@@ = @@v15@@ ; } return @@v6@@ ; }
__int64 __fastcall open_safer ( const char * @@a1@@ , char @@a2@@ , unsigned int @@a3@@ ) { __int64 @@v3@@ ; int @@v4@@ ; @@v3@@ = Number L ; if ( ( @@a2@@ & Number ) != Number ) @@v3@@ = @@a3@@ ; @@v4@@ = open ( @@a1@@ , @@a2@@ , @@v3@@ ) ; return fd_safer ( @@v4@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
size_t __fastcall mbslen ( char * @@s@@ ) { __int64 @@i@@ ; int @@v3@@ ; wchar_t @@v4@@ ; size_t @@v5@@ ; size_t @@v6@@ ; size_t @@v7@@ ; size_t @@v8@@ ; char @@v9@@ ; mbstate_t @@v10@@ ; char @@v11@@ ; char * @@sa@@ ; size_t @@v13@@ ; char @@v14@@ ; wchar_t @@v15@@ [ Number ] ; unsigned __int64 @@v16@@ ; @@v16@@ = __readfsqword ( Number ) ; if ( __ctype_get_mb_cur_max ( ) > Number ) { @@sa@@ = @@s@@ ; @@v9@@ = Number ; @@v10@@ = Number L ; @@v11@@ = Number ; for ( @@i@@ = Number L ; ; ++ @@i@@ ) { if ( ! @@v9@@ ) { @@v3@@ = is_basic_table [ ( ( unsigned __int8 ) * @@sa@@ >> Number ) & Number ] ; if ( _bittest ( & @@v3@@ , ( unsigned __int8 ) * @@sa@@ ) ) { @@v13@@ = Number L ; @@v4@@ = * @@sa@@ ; @@v14@@ = Number ; @@v11@@ = Number ; @@v15@@ [ Number ] = @@v4@@ ; goto LABEL_7 ; } if ( ! mbsinit ( & @@v10@@ ) ) __assert_fail ( String , String , Number , String ) ; @@v9@@ = Number ; } @@v5@@ = __ctype_get_mb_cur_max ( ) ; @@v6@@ = strnlen1 ( @@sa@@ , @@v5@@ ) ; @@v7@@ = mbrtowc ( @@v15@@ , @@sa@@ , @@v6@@ , & @@v10@@ ) ; @@v13@@ = @@v7@@ ; switch ( @@v7@@ ) { case Number : @@v13@@ = Number L ; @@v14@@ = Number ; goto LABEL_8 ; case Number : @@v8@@ = strlen ( @@sa@@ ) ; @@v14@@ = Number ; @@v13@@ = @@v8@@ ; goto LABEL_8 ; case Number : @@v13@@ = Number L ; if ( * @@sa@@ ) __assert_fail ( String , String , Number , String ) ; if ( @@v15@@ [ Number ] ) __assert_fail ( String , String , Number , String ) ; break ; } @@v14@@ = Number ; if ( mbsinit ( & @@v10@@ ) ) @@v9@@ = Number ; @@v11@@ = Number ; LABEL_7 : if ( ! @@v15@@ [ Number ] ) return @@i@@ ; LABEL_8 : @@sa@@ += @@v13@@ ; @@v11@@ = Number ; } } return strlen ( @@s@@ ) ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_219290 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_219270 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_219280 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
bool __fastcall strip_trailing_slashes ( char * @@a1@@ ) { const char * @@v1@@ ; const char * @@v2@@ ; bool @@v3@@ ; @@v1@@ = last_component ( @@a1@@ ) ; if ( ! * @@v1@@ ) @@v1@@ = @@a1@@ ; @@v2@@ = & @@v1@@ [ base_len ( @@v1@@ ) ] ; @@v3@@ = * @@v2@@ == Number ; * @@v2@@ = Number ; return ! @@v3@@ ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall gl_futimens ( int @@fd2@@ , char * @@path@@ , const __m128i * @@a3@@ ) { return fdutimens ( @@path@@ , @@fd2@@ , @@a3@@ ) ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_2061F0 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061D0 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061E0 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_219290 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_219270 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_219280 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_2061F0 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061D0 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_2061E0 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
__int64 __fastcall umaxtostr ( unsigned __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; @@v2@@ = @@a2@@ + Number ; * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; do { * ( _BYTE * ) -- @@v2@@ = @@a1@@ % Number + Number ; @@a1@@ /= Number ; } while ( @@a1@@ ) ; return @@v2@@ ; }
__int64 __fastcall utimens ( char * @@a1@@ , const __m128i * @@a2@@ ) { return fdutimens ( @@a1@@ , Number , @@a2@@ ) ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
__int64 __fastcall savedirstream ( DIR * @@dirp@@ ) { size_t @@v1@@ ; unsigned __int64 @@v2@@ ; __int64 @@v3@@ ; int * @@v4@@ ; struct dirent * @@v5@@ ; char @@v6@@ ; char * @@v7@@ ; size_t @@v8@@ ; size_t @@v9@@ ; size_t @@v10@@ ; unsigned __int64 @@v11@@ ; __int64 @@v12@@ ; int @@v13@@ ; void * @@v15@@ ; size_t @@n@@ ; size_t @@na@@ ; size_t @@v18@@ ; if ( ! @@dirp@@ ) return Number L ; @@v1@@ = Number L ; @@v2@@ = Number L ; @@v3@@ = xmalloc ( Number L ) ; @@v4@@ = __errno_location ( ) ; while ( Number ) { * @@v4@@ = Number ; @@v5@@ = readdir ( @@dirp@@ ) ; if ( ! @@v5@@ ) break ; @@v6@@ = @@v5@@ -> d_name [ Number ] ; @@v7@@ = @@v5@@ -> d_name ; if ( @@v6@@ == Number ) { if ( @@v5@@ -> d_name [ Number ] == Number ) { @@v6@@ = @@v5@@ -> d_name [ Number ] ; goto LABEL_3 ; } if ( @@v5@@ -> d_name [ Number ] ) { LABEL_8 : @@v8@@ = strlen ( @@v5@@ -> d_name ) ; @@v9@@ = @@v8@@ + Number ; @@v10@@ = @@v8@@ + Number + @@v1@@ ; if ( __CFADD__ ( @@v8@@ + Number , @@v1@@ ) ) LABEL_21 : xalloc_die ( ) ; if ( @@v2@@ <= @@v10@@ ) { do { @@v11@@ = Number * @@v2@@ ; if ( Number * @@v2@@ < @@v2@@ ) goto LABEL_21 ; @@v2@@ *= Number L ; } while ( @@v10@@ >= @@v11@@ ) ; @@v18@@ = @@v8@@ + Number + @@v1@@ ; @@n@@ = @@v8@@ + Number ; @@v12@@ = xrealloc ( @@v3@@ , @@v11@@ , @@v9@@ ) ; @@v10@@ = @@v18@@ ; @@v9@@ = @@n@@ ; @@v3@@ = @@v12@@ ; } @@na@@ = @@v10@@ ; memcpy ( ( void * ) ( @@v3@@ + @@v1@@ ) , @@v7@@ , @@v9@@ ) ; @@v1@@ = @@na@@ ; } } else { LABEL_3 : if ( @@v6@@ ) goto LABEL_8 ; } } * ( _BYTE * ) ( @@v3@@ + @@v1@@ ) = Number ; @@v13@@ = * @@v4@@ ; if ( closedir ( @@dirp@@ ) ) @@v13@@ = * @@v4@@ ; if ( @@v13@@ ) { @@v15@@ = ( void * ) @@v3@@ ; @@v3@@ = Number L ; free ( @@v15@@ ) ; * @@v4@@ = @@v13@@ ; } return @@v3@@ ; }
__int64 __fastcall lutimens ( char * @@path@@ , const __m128i * @@a2@@ ) { int @@v2@@ ; struct timespec * @@v3@@ ; int @@v4@@ ; unsigned int @@v5@@ ; __time_t @@v7@@ ; __syscall_slong_t @@v8@@ ; struct timespec * @@times@@ ; __int128 @@v10@@ [ Number ] ; struct stat @@stat_buf@@ ; unsigned __int64 @@v12@@ ; @@v12@@ = __readfsqword ( Number ) ; if ( ! @@a2@@ ) { @@v3@@ = Number L ; @@v2@@ = Number ; @@times@@ = Number L ; if ( lutimensat_works_really < Number ) { lutimensat_works_really = Number ; LABEL_17 : if ( __lxstat ( Number , @@path@@ , & @@stat_buf@@ ) ) return ( unsigned int ) Number ; goto LABEL_12 ; } goto LABEL_6 ; } @@v10@@ [ Number ] = ( __int128 ) _mm_loadu_si128 ( @@a2@@ ) ; @@times@@ = ( struct timespec * ) @@v10@@ ; @@v10@@ [ Number ] = ( __int128 ) _mm_loadu_si128 ( @@a2@@ + Number ) ; @@v2@@ = validate_timespec ( @@v10@@ ) ; if ( @@v2@@ < Number ) return ( unsigned int ) Number ; if ( lutimensat_works_really >= Number ) { if ( @@v2@@ == Number ) { if ( __lxstat ( Number , @@path@@ , & @@stat_buf@@ ) ) return ( unsigned int ) Number ; @@v3@@ = @@times@@ ; if ( @@times@@ -> tv_nsec == Number ) { @@v8@@ = @@stat_buf@@ . st_atim . tv_nsec ; @@v2@@ = Number ; @@times@@ -> tv_sec = @@stat_buf@@ . st_atim . tv_sec ; @@v3@@ -> tv_nsec = @@v8@@ ; } else { @@v2@@ = Number ; if ( @@times@@ [ Number ] . tv_nsec == Number ) { @@v7@@ = @@stat_buf@@ . st_mtim . tv_sec ; @@times@@ [ Number ] . tv_nsec = @@stat_buf@@ . st_mtim . tv_nsec ; @@v3@@ [ Number ] . tv_sec = @@v7@@ ; } } } else { @@v3@@ = @@times@@ ; } LABEL_6 : @@v4@@ = utimensat ( Number , @@path@@ , @@v3@@ , Number ) ; @@v5@@ = @@v4@@ ; if ( @@v4@@ <= Number ) { if ( ! @@v4@@ || * __errno_location ( ) != Number ) { utimensat_works_really = Number ; lutimensat_works_really = Number ; return @@v5@@ ; } } else { * __errno_location ( ) = Number ; } } lutimensat_works_really = Number ; if ( ! @@v2@@ ) goto LABEL_17 ; if ( @@v2@@ == Number ) { if ( ! @@times@@ ) { LABEL_12 : if ( ( @@stat_buf@@ . st_mode & Number ) != Number ) return ( unsigned int ) fdutimens ( @@path@@ , Number , ( const __m128i * ) @@times@@ ) ; * __errno_location ( ) = Number ; return ( unsigned int ) Number ; } } else { if ( __lxstat ( Number , @@path@@ , & @@stat_buf@@ ) ) return ( unsigned int ) Number ; if ( ! @@times@@ ) goto LABEL_12 ; } @@v5@@ = Number ; if ( ! ( unsigned __int8 ) update_timespec ( & @@stat_buf@@ , & @@times@@ ) ) goto LABEL_12 ; return @@v5@@ ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
__int64 __fastcall dup_safer ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ , char @@a7@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ , @@a7@@ ) ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
__int64 __fastcall c_strcasecmp ( unsigned __int8 * @@a1@@ , unsigned __int8 * @@a2@@ ) { __int64 @@result@@ ; int @@v3@@ ; int @@v4@@ ; @@result@@ = Number L ; if ( @@a1@@ != @@a2@@ ) { do { @@v3@@ = * @@a1@@ ; if ( ( unsigned int ) ( @@v3@@ - Number ) < Number ) LOBYTE ( @@v3@@ ) = @@v3@@ + Number ; @@v4@@ = * @@a2@@ ; if ( ( unsigned int ) ( @@v4@@ - Number ) < Number ) LOBYTE ( @@v4@@ ) = @@v4@@ + Number ; if ( ! ( _BYTE ) @@v3@@ ) break ; ++ @@a1@@ ; ++ @@a2@@ ; } while ( ( _BYTE ) @@v3@@ == ( _BYTE ) @@v4@@ ) ; @@result@@ = ( unsigned __int8 ) @@v3@@ - ( unsigned int ) ( unsigned __int8 ) @@v4@@ ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
__int64 __fastcall rpl_fcntl ( int @@a1@@ , int @@a2@@ , __int64 @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { int @@v6@@ ; int @@v8@@ ; int @@v9@@ ; int @@v10@@ ; int @@v11@@ ; int * @@v12@@ ; int @@v13@@ ; int * @@v14@@ ; int @@v15@@ ; @@v15@@ = @@a3@@ ; if ( @@a2@@ != Number ) return ( unsigned int ) fcntl ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( have_dupfd_cloexec_3202 < Number ) { @@v6@@ = ( ( __int64 ( __fastcall * ) ( int , _DWORD , _DWORD , int , int , int , char ) ) rpl_fcntl ) ( @@a1@@ , Number , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ , Number ) ; if ( @@v6@@ < Number || have_dupfd_cloexec_3202 != Number ) return ( unsigned int ) @@v6@@ ; } else { @@v6@@ = fcntl ( @@a1@@ , Number , ( unsigned int ) @@a3@@ ) ; if ( @@v6@@ >= Number || * __errno_location ( ) != Number ) { have_dupfd_cloexec_3202 = Number ; return ( unsigned int ) @@v6@@ ; } @@v6@@ = ( ( __int64 ( __fastcall * ) ( int , _DWORD , int , int , int , int , char ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v15@@ , @@v8@@ , @@v9@@ , @@v10@@ , Number ) ; if ( @@v6@@ < Number ) return ( unsigned int ) @@v6@@ ; have_dupfd_cloexec_3202 = Number ; } @@v11@@ = fcntl ( @@v6@@ , Number ) ; if ( @@v11@@ < Number || fcntl ( @@v6@@ , Number , @@v11@@ | Number ) == Number ) { @@v12@@ = __errno_location ( ) ; @@v13@@ = * @@v12@@ ; @@v14@@ = @@v12@@ ; close ( @@v6@@ ) ; @@v6@@ = Number ; * @@v14@@ = @@v13@@ ; } return ( unsigned int ) @@v6@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_2061F0 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061D0 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_2061E0 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
char * __fastcall str_iconv ( char * @@s@@ , char * @@fromcode@@ , char * @@tocode@@ ) { char * @@v4@@ ; iconv_t @@v6@@ ; void * @@v7@@ ; int * @@v8@@ ; int @@v9@@ ; int * @@v10@@ ; int * @@v11@@ ; int @@v12@@ ; int * @@v13@@ ; if ( * @@s@@ && ( unsigned int ) c_strcasecmp ( ( unsigned __int8 * ) @@fromcode@@ , ( unsigned __int8 * ) @@tocode@@ ) ) { @@v6@@ = iconv_open ( @@tocode@@ , @@fromcode@@ ) ; @@v7@@ = @@v6@@ ; if ( @@v6@@ == ( iconv_t ) Number ) return Number L ; @@v4@@ = str_cd_iconv ( @@s@@ , @@v6@@ ) ; if ( @@v4@@ ) { if ( iconv_close ( @@v7@@ ) < Number ) { @@v8@@ = __errno_location ( ) ; @@v9@@ = * @@v8@@ ; @@v10@@ = @@v8@@ ; free ( @@v4@@ ) ; @@v4@@ = Number L ; * @@v10@@ = @@v9@@ ; } } else { @@v11@@ = __errno_location ( ) ; @@v12@@ = * @@v11@@ ; @@v13@@ = @@v11@@ ; iconv_close ( @@v7@@ ) ; * @@v13@@ = @@v12@@ ; } return @@v4@@ ; } @@v4@@ = strdup ( @@s@@ ) ; if ( @@v4@@ ) return @@v4@@ ; * __errno_location ( ) = Number ; return Number L ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
int isatty ( int @@fd@@ ) { return isatty ( @@fd@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void __fastcall freea ( unsigned __int64 @@a1@@ ) { __int64 @@v1@@ ; __int64 @@v2@@ ; _QWORD * @@v3@@ ; if ( @@a1@@ ) { if ( * ( _DWORD * ) ( @@a1@@ - Number ) == Number ) { @@v1@@ = mmalloca_results [ @@a1@@ % Number ] ; if ( @@v1@@ ) { if ( @@v1@@ == @@a1@@ ) { @@v3@@ = & mmalloca_results [ @@a1@@ % Number ] ; LABEL_12 : * @@v3@@ = * ( _QWORD * ) ( @@a1@@ - Number ) ; free ( ( void * ) ( @@a1@@ - Number ) ) ; } else { while ( Number ) { @@v2@@ = * ( _QWORD * ) ( @@v1@@ - Number ) ; if ( ! @@v2@@ ) break ; if ( @@a1@@ == @@v2@@ ) { @@v3@@ = ( _QWORD * ) ( @@v1@@ - Number ) ; goto LABEL_12 ; } @@v1@@ = * ( _QWORD * ) ( @@v1@@ - Number ) ; } } } } } }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; char * @@v7@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = setlocale ( Number , Number L ) ; if ( @@v7@@ ) { if ( strncmp ( @@v7@@ , String , Number ) ) { last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
int __lxstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _lxstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
int __cdecl __noreturn main ( int @@argc@@ , const char * * @@argv@@ , const char * * @@envp@@ ) { const char * @@v3@@ ; if ( @@argc@@ == Number ) { set_program_name ( * @@argv@@ , @@argv@@ , @@envp@@ ) ; setlocale ( Number , String ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; @@v3@@ = @@argv@@ [ Number ] ; if ( ! strcmp ( @@v3@@ , String ) ) usage ( Number ) ; if ( ! strcmp ( @@v3@@ , String ) ) version_etc ( ( _DWORD ) stdout , ( unsigned int ) String , ( unsigned int ) & unk_3778 , ( _DWORD ) Version , ( unsigned int ) String , Number ) ; } exit ( Number ) ; }
int dirfd ( DIR * @@dirp@@ ) { return dirfd ( @@dirp@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
int __fxstat ( int @@ver@@ , int @@fildes@@ , struct stat * @@stat_buf@@ ) { return _fxstat ( @@ver@@ , @@fildes@@ , @@stat_buf@@ ) ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
__int64 __fastcall dup_cloexec ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
void __fastcall cwd_advance_fd ( __int64 @@a1@@ , int @@a2@@ , char @@a3@@ ) { int @@v4@@ ; int @@v5@@ ; @@v4@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; if ( @@v4@@ == @@a2@@ && @@v4@@ != Number ) abort ( ) ; if ( @@a3@@ ) { @@v5@@ = i_ring_push ( @@a1@@ + Number ) ; if ( @@v5@@ < Number ) { LABEL_6 : * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; return ; } close ( @@v5@@ ) ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; } else { if ( ( * ( _BYTE * ) ( @@a1@@ + Number ) & Number ) != Number || @@v4@@ < Number ) goto LABEL_6 ; close ( @@v4@@ ) ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; } }
__int64 __fastcall dup_safer ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
int __cdecl __noreturn main ( int @@argc@@ , const char * * @@argv@@ , const char * * envp ) { __int64 @@v3@@ ; char * @@v4@@ ; set_program_name ( * @@argv@@ ) ; setlocale ( Number , String ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; parse_long_options ( @@argc@@ , ( _DWORD ) @@argv@@ , ( unsigned int ) String , ( unsigned int ) & unk_3986 , ( _DWORD ) Version , ( unsigned int ) usage , String , Number L ) ; if ( getopt_long ( @@argc@@ , ( char * const * ) @@argv@@ , String , Number L , Number L ) == Number ) { if ( optind >= @@argc@@ ) { gethostid ( ) ; __printf_chk ( ) ; exit ( Number ) ; } @@v3@@ = quote ( @@argv@@ [ optind ] ) ; @@v4@@ = dcgettext ( Number L , String , Number ) ; error ( Number , Number , @@v4@@ , @@v3@@ ) ; } usage ( Number ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
__int64 __fastcall enter_dir_isra_11 ( __int16 @@a1@@ , _QWORD * @@a2@@ , __int64 @@a3@@ ) { _QWORD * @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; __int64 @@result@@ ; if ( ( @@a1@@ & Number ) != Number ) { @@v4@@ = malloc ( Number ) ; if ( @@v4@@ ) { @@v5@@ = * ( _QWORD * ) ( @@a3@@ + Number ) ; @@v6@@ = * @@a2@@ ; @@v4@@ [ Number ] = @@a3@@ ; * @@v4@@ = @@v5@@ ; @@v4@@ [ Number ] = * ( _QWORD * ) ( @@a3@@ + Number ) ; @@v7@@ = hash_insert ( @@v6@@ , @@v4@@ ) ; if ( @@v4@@ == ( _QWORD * ) @@v7@@ ) return Number L ; free ( @@v4@@ ) ; if ( @@v7@@ ) { @@v8@@ = * ( _QWORD * ) ( @@v7@@ + Number ) ; * ( _WORD * ) ( @@a3@@ + Number ) = Number ; * ( _QWORD * ) @@a3@@ = @@v8@@ ; return Number L ; } } @@result@@ = Number L ; } else { @@result@@ = cycle_check ( * @@a2@@ , @@a3@@ + Number ) ; if ( ! ( _BYTE ) @@result@@ ) return Number L ; * ( _QWORD * ) @@a3@@ = @@a3@@ ; * ( _WORD * ) ( @@a3@@ + Number ) = Number ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
__int64 __fastcall hash_get_n_buckets ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__int64 __fastcall hash_get_n_entries ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
bool __fastcall hash_table_ok ( __int64 @@a1@@ ) { _QWORD * @@v1@@ ; unsigned __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; bool @@result@@ ; @@v1@@ = * ( _QWORD * * ) @@a1@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v3@@ = Number L ; @@v4@@ = Number L ; if ( * ( _QWORD * ) @@a1@@ < @@v2@@ ) { do { if ( * @@v1@@ ) { @@v5@@ = @@v1@@ [ Number ] ; ++ @@v4@@ ; ++ @@v3@@ ; for ( ; @@v5@@ ; ++ @@v3@@ ) @@v5@@ = * ( _QWORD * ) ( @@v5@@ + Number ) ; } @@v1@@ += Number ; } while ( ( unsigned __int64 ) @@v1@@ < @@v2@@ ) ; } @@result@@ = Number ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) == @@v4@@ ) @@result@@ = * ( _QWORD * ) ( @@a1@@ + Number ) == @@v3@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall hash_get_next ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; __int64 * @@v6@@ ; _QWORD * @@v7@@ ; __int64 @@v8@@ ; __int64 @@result@@ ; @@v2@@ = * @@a1@@ ; @@v4@@ = ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) ; @@v5@@ = @@a1@@ [ Number ] ; @@v6@@ = ( __int64 * ) ( @@v2@@ + Number * @@v4@@ ) ; if ( @@v5@@ <= ( unsigned __int64 ) @@v6@@ ) abort ( ) ; if ( ! @@v6@@ ) goto LABEL_10 ; @@v7@@ = ( _QWORD * ) @@v6@@ [ Number ] ; if ( * @@v6@@ != @@a2@@ ) { do { if ( ! @@v7@@ ) goto LABEL_10 ; @@v8@@ = * @@v7@@ ; @@v7@@ = ( _QWORD * ) @@v7@@ [ Number ] ; } while ( @@v8@@ != @@a2@@ ) ; } if ( @@v7@@ ) return * @@v7@@ ; LABEL_10 : while ( Number ) { @@v6@@ += Number ; if ( @@v5@@ <= ( unsigned __int64 ) @@v6@@ ) break ; @@result@@ = * @@v6@@ ; if ( * @@v6@@ ) return @@result@@ ; } return Number L ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
int clock_gettime ( clockid_t @@clock_id@@ , struct timespec * @@tp@@ ) { return clock_gettime ( @@clock_id@@ , @@tp@@ ) ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
void __fastcall hash_free ( void * @@ptr@@ ) { _QWORD * @@v2@@ ; unsigned __int64 @@v3@@ ; _QWORD * @@v4@@ ; _QWORD * @@v5@@ ; _QWORD * @@v6@@ ; _QWORD * @@v7@@ ; _QWORD * @@v8@@ ; @@v2@@ = * ( _QWORD * * ) @@ptr@@ ; @@v3@@ = * ( ( _QWORD * ) @@ptr@@ + Number ) ; if ( * ( ( _QWORD * ) @@ptr@@ + Number ) && * ( ( _QWORD * ) @@ptr@@ + Number ) ) { if ( ( unsigned __int64 ) @@v2@@ >= @@v3@@ ) goto LABEL_14 ; do { if ( * @@v2@@ ) { @@v4@@ = @@v2@@ ; do { ( * ( ( void ( * * ) ( void ) ) @@ptr@@ + Number ) ) ( ) ; @@v4@@ = ( _QWORD * ) @@v4@@ [ Number ] ; } while ( @@v4@@ ) ; @@v3@@ = * ( ( _QWORD * ) @@ptr@@ + Number ) ; } @@v2@@ += Number ; } while ( @@v3@@ > ( unsigned __int64 ) @@v2@@ ) ; @@v2@@ = * ( _QWORD * * ) @@ptr@@ ; } if ( ( unsigned __int64 ) @@v2@@ < @@v3@@ ) { do { @@v5@@ = ( _QWORD * ) @@v2@@ [ Number ] ; if ( @@v5@@ ) { do { @@v6@@ = ( _QWORD * ) @@v5@@ [ Number ] ; free ( @@v5@@ ) ; @@v5@@ = @@v6@@ ; } while ( @@v6@@ ) ; } @@v2@@ += Number ; } while ( * ( ( _QWORD * ) @@ptr@@ + Number ) > ( unsigned __int64 ) @@v2@@ ) ; } LABEL_14 : @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@ptr@@ + Number ) ; if ( @@v7@@ ) { do { @@v8@@ = ( _QWORD * ) @@v7@@ [ Number ] ; free ( @@v7@@ ) ; @@v7@@ = @@v8@@ ; } while ( @@v8@@ ) ; } free ( * ( void * * ) @@ptr@@ ) ; free ( @@ptr@@ ) ; }
DIR * opendir ( const char * @@name@@ ) { return opendir ( @@name@@ ) ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
int closedir ( DIR * @@dirp@@ ) { return closedir ( @@dirp@@ ) ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
int fileno ( FILE * @@stream@@ ) { return fileno ( @@stream@@ ) ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
char * nl_langinfo ( nl_item @@item@@ ) { return nl_langinfo ( @@item@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
void * __fastcall mfile_name_concat ( void * @@src@@ , void * @@a2@@ , _QWORD * @@a3@@ ) { const char * @@v4@@ ; const char * @@v5@@ ; size_t @@v6@@ ; size_t @@v7@@ ; _BOOL8 @@v8@@ ; void * @@v9@@ ; void * @@v10@@ ; _BYTE * @@v11@@ ; char * @@v12@@ ; size_t @@n@@ ; char @@v15@@ ; @@v4@@ = ( const char * ) @@a2@@ ; @@v5@@ = last_component ( @@src@@ ) ; @@v6@@ = base_len ( @@v5@@ ) ; @@v7@@ = @@v6@@ + @@v5@@ - ( _BYTE * ) @@src@@ ; @@v8@@ = @@v6@@ ; if ( @@v6@@ ) @@v8@@ = @@v5@@ [ @@v6@@ - Number ] != Number ; @@v15@@ = * ( _BYTE * ) @@a2@@ ; if ( * ( _BYTE * ) @@a2@@ == Number ) { do ++ @@v4@@ ; while ( * @@v4@@ == Number ) ; } @@n@@ = strlen ( @@v4@@ ) ; @@v9@@ = malloc ( @@n@@ + @@v8@@ + @@v7@@ + Number ) ; @@v10@@ = @@v9@@ ; if ( @@v9@@ ) { @@v11@@ = mempcpy ( @@v9@@ , @@src@@ , @@v7@@ ) ; * @@v11@@ = Number ; @@v12@@ = & @@v11@@ [ @@v8@@ ] ; if ( @@a3@@ ) * @@a3@@ = & @@v12@@ [ - ( @@v15@@ == Number ) ] ; * ( _BYTE * ) mempcpy ( @@v12@@ , @@v4@@ , @@n@@ ) = Number ; } return @@v10@@ ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
int iswspace ( wint_t @@wc@@ ) { return iswspace ( @@wc@@ ) ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
char * strdup ( const char * @@s@@ ) { return strdup ( @@s@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_20D210 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20D1F0 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20D200 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
unsigned __int64 __fastcall overwrite_prompt_isra_14 ( char * @@a1@@ , unsigned int * @@a2@@ ) { int @@v3@@ ; char @@v5@@ [ Number ] ; unsigned __int64 @@v6@@ ; @@v3@@ = * @@a2@@ ; @@v6@@ = __readfsqword ( Number ) ; if ( writable_destination ( @@a1@@ , @@v3@@ ) ) { quote ( @@a1@@ ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { strmode ( * @@a2@@ , @@v5@@ ) ; @@v5@@ [ Number ] = Number ; quote ( @@a1@@ ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } return __readfsqword ( Number ) ^ @@v6@@ ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; char * @@v10@@ ; char * @@v11@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; dcgettext ( Number L , String String String String String String , Number ) ; __printf_chk ( ) ; @@v7@@ = dcgettext ( Number L , String String String String , Number ) ; __printf_chk ( ) ; last_component ( program_name , @@v7@@ ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v8@@ = stdout ; @@v9@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = Number L ; @@v11@@ = setlocale ( Number , Number L ) ; if ( @@v11@@ ) { @@v10@@ = String ; if ( strncmp ( @@v11@@ , String , Number ) ) { last_component ( program_name , String ) ; @@v10@@ = dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name , @@v10@@ ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
unsigned __int64 __fastcall src_to_dest_hash ( _QWORD * @@a1@@ , unsigned __int64 @@a2@@ ) { return * @@a1@@ % @@a2@@ ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_2071F0 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2071D0 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_2071E0 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
void __fastcall __noreturn openat_save_fail ( int @@errnum@@ ) { char * @@v1@@ ; @@v1@@ = dcgettext ( Number L , String , Number ) ; error ( exit_failure , @@errnum@@ , @@v1@@ ) ; abort ( ) ; }
void __fastcall src_to_dest_free ( void * @@ptr@@ ) { free ( * ( ( void * * ) @@ptr@@ + Number ) ) ; free ( @@ptr@@ ) ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
__int64 __fastcall src_to_dest_lookup ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; __int64 @@result@@ ; __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = @@a1@@ ; @@v4@@ [ Number ] = @@a2@@ ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v2@@ = hash_lookup ( src_to_dest , @@v4@@ ) ; if ( @@v2@@ ) @@result@@ = * ( _QWORD * ) ( @@v2@@ + Number ) ; else @@result@@ = Number L ; return @@result@@ ; }
__int64 __fastcall set_cloexec_flag ( int @@a1@@ , char @@a2@@ , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { int @@v6@@ ; int @@v7@@ ; int @@v8@@ ; int @@v9@@ ; int @@v10@@ ; unsigned int @@v11@@ ; __int64 @@result@@ ; @@v6@@ = rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( @@v6@@ < Number ) return Number ; @@v9@@ = @@v6@@ ; @@v10@@ = @@v6@@ | Number ; @@v11@@ = @@v9@@ & Number ; if ( @@a2@@ ) @@v11@@ = @@v10@@ ; @@result@@ = Number L ; if ( @@v11@@ != @@v9@@ ) @@result@@ = ( unsigned int ) - ( ( unsigned int ) rpl_fcntl ( @@a1@@ , Number , @@v11@@ , @@v9@@ , @@v7@@ , @@v8@@ ) == Number ) ; return @@result@@ ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
int __fastcall chmod_or_fchmod ( const char * @@a1@@ , int @@a2@@ , __mode_t @@a3@@ ) { int @@result@@ ; if ( @@a2@@ == Number ) @@result@@ = chmod ( @@a1@@ , @@a3@@ ) ; else @@result@@ = fchmod ( @@a2@@ , @@a3@@ ) ; return @@result@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
__int64 __fastcall fd_safer ( int @@fd@@ , __int64 @@a2@@ , __int64 @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { unsigned int @@v6@@ ; unsigned int @@v7@@ ; int * @@v8@@ ; int @@v9@@ ; int * @@v10@@ ; @@v6@@ = @@fd@@ ; if ( ( unsigned int ) @@fd@@ <= Number ) { @@v7@@ = dup_safer ( @@fd@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; @@v8@@ = __errno_location ( ) ; @@v9@@ = * @@v8@@ ; @@v10@@ = @@v8@@ ; close ( @@fd@@ ) ; @@v6@@ = @@v7@@ ; * @@v10@@ = @@v9@@ ; } return @@v6@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
char * __fastcall areadlink_with_size ( char * @@path@@ , unsigned __int64 @@a2@@ ) { size_t @@v2@@ ; char * @@v3@@ ; char * @@v4@@ ; ssize_t @@v5@@ ; char * @@v7@@ ; @@v2@@ = @@a2@@ + Number ; if ( @@a2@@ >= Number ) @@v2@@ = Number L ; while ( Number ) { @@v3@@ = ( char * ) malloc ( @@v2@@ ) ; @@v4@@ = @@v3@@ ; if ( @@v3@@ ) { while ( Number ) { @@v5@@ = readlink ( @@path@@ , @@v3@@ , @@v2@@ ) ; if ( @@v5@@ < Number && * __errno_location ( ) != Number ) { @@v7@@ = @@v4@@ ; @@v4@@ = Number L ; free ( @@v7@@ ) ; return @@v4@@ ; } if ( @@v2@@ > @@v5@@ ) { @@v4@@ [ @@v5@@ ] = Number ; return @@v4@@ ; } free ( @@v4@@ ) ; if ( @@v2@@ > Number ) break ; @@v2@@ *= Number L ; @@v3@@ = ( char * ) malloc ( @@v2@@ ) ; @@v4@@ = @@v3@@ ; if ( ! @@v3@@ ) return @@v4@@ ; } if ( @@v2@@ <= Number ) { @@v2@@ = Number ; continue ; } @@v4@@ = Number L ; * __errno_location ( ) = Number ; } break ; } return @@v4@@ ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 __fastcall cdb_advance_fd ( int * @@a1@@ , const char * @@a2@@ ) { int @@v3@@ ; int @@v4@@ ; int @@v5@@ ; @@v3@@ = openat ( * @@a1@@ , @@a2@@ , Number ) ; if ( @@v3@@ < Number ) return Number ; @@v4@@ = * @@a1@@ ; @@v5@@ = @@v3@@ ; if ( @@v4@@ >= Number ) { if ( close ( @@v4@@ ) ) cdb_free_part_0 ( ) ; } * @@a1@@ = @@v5@@ ; return Number L ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
int fileno ( FILE * @@stream@@ ) { return fileno ( @@stream@@ ) ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
struct tm * localtime ( const time_t * @@timer@@ ) { return localtime ( @@timer@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
int puts ( const char * @@s@@ ) { return puts ( @@s@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
__int64 __fastcall argmatch_to_argument ( void * @@s1@@ , __int64 * @@a2@@ , char * @@a3@@ , size_t @@a4@@ ) { __int64 @@v4@@ ; __int64 * @@v7@@ ; @@v4@@ = * @@a2@@ ; if ( * @@a2@@ ) { @@v7@@ = @@a2@@ + Number ; do { if ( ! memcmp ( @@s1@@ , @@a3@@ , @@a4@@ ) ) break ; @@v4@@ = * @@v7@@ ; @@a3@@ += @@a4@@ ; ++ @@v7@@ ; } while ( @@v4@@ ) ; } return @@v4@@ ; }
const char * gai_strerror ( int @@ecode@@ ) { return gai_strerror ( @@ecode@@ ) ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
__int64 __fastcall fd_reopen ( int @@fd2@@ , char * @@file@@ , int @@oflag@@ , unsigned int @@a4@@ ) { int @@v4@@ ; unsigned int @@v5@@ ; int @@v6@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; @@v4@@ = open ( @@file@@ , @@oflag@@ , @@a4@@ ) ; @@v5@@ = @@v4@@ ; if ( @@fd2@@ != @@v4@@ && @@v4@@ >= Number ) { @@v6@@ = dup2 ( @@v4@@ , @@fd2@@ ) ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; close ( @@v5@@ ) ; @@v5@@ = @@v6@@ ; * @@v9@@ = @@v8@@ ; } return @@v5@@ ; }
char * nl_langinfo ( nl_item @@item@@ ) { return nl_langinfo ( @@item@@ ) ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; FILE * @@v11@@ ; char * @@v12@@ ; char * @@v13@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String String String String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = stdout ; @@v10@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v11@@ = stdout ; @@v12@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v12@@ , @@v11@@ ) ; @@v13@@ = setlocale ( Number , Number L ) ; if ( @@v13@@ ) { if ( strncmp ( @@v13@@ , String , Number ) ) { last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
char * strdup ( const char * @@s@@ ) { return strdup ( @@s@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_2061F0 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061D0 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061E0 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall hash_find_entry ( __int64 * @@a1@@ , __int64 @@a2@@ , __m128i * * @@a3@@ , char @@a4@@ ) { __int64 @@v5@@ ; __m128i * @@v8@@ ; __int64 @@v9@@ ; __int64 * @@v10@@ ; const __m128i * @@v12@@ ; @@v5@@ = * @@a1@@ ; @@v8@@ = ( __m128i * ) ( Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) + @@v5@@ ) ; if ( @@a1@@ [ Number ] <= ( unsigned __int64 ) @@v8@@ ) abort ( ) ; * @@a3@@ = @@v8@@ ; @@v9@@ = @@v8@@ -> m128i_i64 [ Number ] ; if ( @@v8@@ -> m128i_i64 [ Number ] ) { if ( @@v9@@ != @@a2@@ ) { if ( ! ( ( unsigned __int8 ( __fastcall * ) ( __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ ) ) { @@v10@@ = ( __int64 * ) @@v8@@ -> m128i_i64 [ Number ] ; if ( @@v10@@ ) { @@v9@@ = * @@v10@@ ; if ( @@a2@@ != * @@v10@@ ) { while ( ! ( ( unsigned __int8 ( __fastcall * ) ( __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ ) ) { @@v8@@ = ( __m128i * ) @@v8@@ -> m128i_i64 [ Number ] ; @@v10@@ = ( __int64 * ) @@v8@@ -> m128i_i64 [ Number ] ; if ( ! @@v10@@ ) return Number L ; @@v9@@ = * @@v10@@ ; if ( * @@v10@@ == @@a2@@ ) goto LABEL_12 ; } @@v10@@ = ( __int64 * ) @@v8@@ -> m128i_i64 [ Number ] ; @@v9@@ = * @@v10@@ ; } LABEL_12 : if ( @@a4@@ ) { @@v8@@ -> m128i_i64 [ Number ] = @@v10@@ [ Number ] ; * @@v10@@ = Number L ; @@v10@@ [ Number ] = @@a1@@ [ Number ] ; @@a1@@ [ Number ] = ( __int64 ) @@v10@@ ; } return @@v9@@ ; } return Number L ; } @@v9@@ = @@v8@@ -> m128i_i64 [ Number ] ; } if ( @@a4@@ ) { @@v12@@ = ( const __m128i * ) @@v8@@ -> m128i_i64 [ Number ] ; if ( @@v12@@ ) { * @@v8@@ = _mm_loadu_si128 ( @@v12@@ ) ; @@v12@@ -> m128i_i64 [ Number ] = Number L ; @@v12@@ -> m128i_i64 [ Number ] = @@a1@@ [ Number ] ; @@a1@@ [ Number ] = ( __int64 ) @@v12@@ ; return @@v9@@ ; } @@v8@@ -> m128i_i64 [ Number ] = Number L ; } return @@v9@@ ; } return Number L ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
char * __fastcall time_string_isra_0 ( int @@a1@@ ) { struct tm * @@v1@@ ; time_t @@v3@@ ; unsigned __int64 @@v4@@ ; @@v3@@ = @@a1@@ ; @@v4@@ = __readfsqword ( Number ) ; @@v1@@ = localtime ( & @@v3@@ ) ; if ( ! @@v1@@ ) return ( char * ) imaxtostr ( @@v3@@ , buf_6506 ) ; strftime ( buf_6506 , Number , time_format , @@v1@@ ) ; return buf_6506 ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
void clearerr_unlocked ( FILE * @@stream@@ ) { clearerr_unlocked ( @@stream@@ ) ; }
unsigned __int64 __fastcall hash_string ( unsigned __int8 * @@a1@@ , unsigned __int64 @@a2@@ ) { __int64 @@v2@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@v4@@ ; @@v2@@ = * @@a1@@ ; for ( @@i@@ = Number L ; ( _BYTE ) @@v2@@ ; @@i@@ = @@v4@@ % @@a2@@ ) { ++ @@a1@@ ; @@v4@@ = @@v2@@ + Number * @@i@@ ; @@v2@@ = * @@a1@@ ; } return @@i@@ ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
void __fastcall hash_clear ( _QWORD * @@a1@@ ) { _QWORD * @@v1@@ ; _QWORD * @@v2@@ ; void ( __fastcall * @@v3@@ ) ( _QWORD ) ; _QWORD * @@v4@@ ; __int64 @@v5@@ ; @@v1@@ = ( _QWORD * ) * @@a1@@ ; if ( * @@a1@@ < @@a1@@ [ Number ] ) { do { if ( * @@v1@@ ) { @@v2@@ = ( _QWORD * ) @@v1@@ [ Number ] ; @@v3@@ = ( void ( __fastcall * ) ( _QWORD ) ) @@a1@@ [ Number ] ; if ( @@v2@@ ) { do { if ( @@v3@@ ) { @@v3@@ ( * @@v2@@ ) ; @@v3@@ = ( void ( __fastcall * ) ( _QWORD ) ) @@a1@@ [ Number ] ; } @@v4@@ = ( _QWORD * ) @@v2@@ [ Number ] ; @@v5@@ = @@a1@@ [ Number ] ; * @@v2@@ = Number L ; @@v2@@ [ Number ] = @@v5@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v2@@ = @@v4@@ ; } while ( @@v4@@ ) ; } if ( @@v3@@ ) @@v3@@ ( * @@v1@@ ) ; * @@v1@@ = Number L ; @@v1@@ [ Number ] = Number L ; } @@v1@@ += Number ; } while ( @@a1@@ [ Number ] > ( unsigned __int64 ) @@v1@@ ) ; } @@a1@@ [ Number ] = Number L ; @@a1@@ [ Number ] = Number L ; }
int __fastcall xputchar ( unsigned __int8 @@a1@@ ) { int @@result@@ ; char * @@v2@@ ; @@result@@ = ( int ) stdout ; @@v2@@ = stdout -> _IO_write_ptr ; if ( @@v2@@ >= stdout -> _IO_write_end ) { @@result@@ = __overflow ( stdout , @@a1@@ ) ; if ( @@result@@ < Number ) write_error ( ) ; } else { stdout -> _IO_write_ptr = @@v2@@ + Number ; * @@v2@@ = @@a1@@ ; } return @@result@@ ; }
DIR * __fastcall opendir_safer ( const char * @@a1@@ ) { DIR * @@v1@@ ; DIR * @@v2@@ ; unsigned int @@v3@@ ; int @@v5@@ ; DIR * @@v6@@ ; int * @@v7@@ ; int @@v8@@ ; @@v1@@ = opendir ( @@a1@@ ) ; @@v2@@ = @@v1@@ ; if ( ! @@v1@@ ) return @@v2@@ ; @@v3@@ = dirfd ( @@v1@@ ) ; if ( @@v3@@ > Number ) return @@v2@@ ; @@v5@@ = dup_safer ( @@v3@@ ) ; @@v6@@ = fdopendir ( @@v5@@ ) ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; if ( ! @@v6@@ ) close ( @@v5@@ ) ; closedir ( @@v2@@ ) ; * @@v7@@ = @@v8@@ ; return @@v6@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
DIR * fdopendir ( int @@fd@@ ) { return fdopendir ( @@fd@@ ) ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; __m128i * @@v10@@ ; __int64 @@v11@@ ; unsigned __int64 * @@v12@@ ; _BYTE * @@v13@@ ; unsigned __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; _BYTE * @@v16@@ ; unsigned __int64 @@v19@@ ; int @@v20@@ ; int @@v21@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v20@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = Number * @@v8@@ ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v9@@ , @@v8@@ ) ; slotvec = @@v7@@ ; @@v11@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v10@@ = ( __m128i * ) xrealloc ( slotvec , @@v9@@ , @@v8@@ ) ; @@v11@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v10@@ ; slotvec = @@v10@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v11@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v12@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v13@@ = ( _BYTE * ) @@v12@@ [ Number ] ; @@v21@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v19@@ = * @@v12@@ ; @@v14@@ = quotearg_buffer_restyled ( @@v13@@ , * @@v12@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v21@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v19@@ <= @@v14@@ ) { @@v15@@ = @@v14@@ + Number ; * @@v12@@ = @@v14@@ + Number ; if ( @@v13@@ != ( _BYTE * ) & slot0 ) free ( @@v13@@ ) ; @@v16@@ = ( _BYTE * ) xmalloc ( @@v15@@ ) ; @@v12@@ [ Number ] = ( unsigned __int64 ) @@v16@@ ; @@v13@@ = @@v16@@ ; quotearg_buffer_restyled ( @@v16@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v21@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v20@@ ; return @@v13@@ ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
void free ( void * @@ptr@@ ) { __imp_free ( @@ptr@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
ssize_t __fastcall safe_write ( int @@fd@@ , void * @@buf@@ , size_t @@n@@ ) { ssize_t @@v4@@ ; int @@v5@@ ; while ( Number ) { @@v4@@ = write ( @@fd@@ , @@buf@@ , @@n@@ ) ; if ( @@v4@@ >= Number ) break ; @@v5@@ = * __errno_location ( ) ; if ( @@v5@@ != Number ) { if ( @@v5@@ != Number || @@n@@ <= Number ) return @@v4@@ ; @@n@@ = Number L ; } } return @@v4@@ ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; int @@v12@@ ; _BYTE * @@v13@@ ; __int64 @@v14@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v12@@ = * @@v6@@ ; @@v14@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v13@@ = ( _BYTE * ) xmalloc ( @@v14@@ + Number , @@v14@@ + Number , @@v8@@ , @@v9@@ , @@v10@@ ) ; quotearg_buffer_restyled ( @@v13@@ , @@v14@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v12@@ ; if ( @@a3@@ ) * @@a3@@ = @@v14@@ ; return @@v13@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
DIR * opendir ( const char * @@name@@ ) { return opendir ( @@name@@ ) ; }
__int64 __fastcall savedir ( const char * @@a1@@ ) { DIR * @@v1@@ ; @@v1@@ = opendir_safer ( @@a1@@ ) ; return savedirstream ( @@v1@@ ) ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
__int64 __fastcall fdsavedir ( int @@a1@@ ) { DIR * @@v1@@ ; @@v1@@ = fdopendir ( @@a1@@ ) ; return savedirstream ( @@v1@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
int chdir ( const char * @@path@@ ) { return chdir ( @@path@@ ) ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
int closedir ( DIR * @@dirp@@ ) { return closedir ( @@dirp@@ ) ; }
unsigned __int64 __fastcall dev_info_hash ( _QWORD * @@a1@@ , unsigned __int64 @@a2@@ ) { return * @@a1@@ % @@a2@@ ; }
__int64 __fastcall rpl_vasprintf ( _QWORD * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { void * @@v3@@ ; unsigned int @@v4@@ ; __int64 @@result@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; @@v3@@ = ( void * ) vasnprintf ( Number L , @@v6@@ , @@a2@@ , @@a3@@ ) ; if ( ! @@v3@@ ) return Number ; @@v4@@ = @@v6@@ [ Number ] ; if ( @@v6@@ [ Number ] > Number ) { free ( @@v3@@ ) ; * __errno_location ( ) = Number ; @@result@@ = Number ; } else { * @@a1@@ = @@v3@@ ; @@result@@ = @@v4@@ ; } return @@result@@ ; }
unsigned __int64 __fastcall AD_hash ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) % @@a2@@ ; }
__int64 __fastcall update_timespec ( _QWORD * @@a1@@ , struct timespec * * @@a2@@ ) { struct timespec * @@v2@@ ; __syscall_slong_t @@v3@@ ; __syscall_slong_t @@v4@@ ; __int64 @@result@@ ; __time_t @@v6@@ ; __time_t @@v7@@ ; @@v2@@ = * @@a2@@ ; @@v3@@ = ( * @@a2@@ ) -> tv_nsec ; @@v4@@ = ( * @@a2@@ ) [ Number ] . tv_nsec ; if ( @@v3@@ != Number ) { if ( @@v3@@ == Number ) { if ( @@v4@@ == Number ) { * @@a2@@ = Number L ; return Number L ; } gettime ( * @@a2@@ ) ; @@v4@@ = @@v2@@ [ Number ] . tv_nsec ; if ( @@v4@@ != Number ) { LABEL_4 : @@result@@ = Number L ; if ( @@v4@@ != Number ) return @@result@@ ; LABEL_11 : gettime ( @@v2@@ + Number ) ; return Number L ; } } else if ( @@v4@@ != Number ) { goto LABEL_4 ; } @@v6@@ = @@a1@@ [ Number ] ; @@v2@@ [ Number ] . tv_nsec = @@a1@@ [ Number ] ; @@v2@@ [ Number ] . tv_sec = @@v6@@ ; return Number L ; } @@result@@ = Number L ; if ( @@v4@@ != Number ) { @@v7@@ = @@a1@@ [ Number ] ; @@v2@@ -> tv_nsec = @@a1@@ [ Number ] ; @@result@@ = Number L ; @@v2@@ -> tv_sec = @@v7@@ ; if ( @@v4@@ == Number ) goto LABEL_11 ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
bool __fastcall LCO_compare ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { return * @@a1@@ == * @@a2@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
void clearerr_unlocked ( FILE * @@stream@@ ) { clearerr_unlocked ( @@stream@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
char * __fastcall areadlinkat ( int @@fd@@ , char * @@path@@ ) { int @@v2@@ ; size_t @@v3@@ ; char * @@v4@@ ; ssize_t @@v5@@ ; size_t @@v6@@ ; int * @@v7@@ ; char * @@v8@@ ; size_t @@v10@@ ; char * @@v11@@ ; char * @@v12@@ ; ssize_t @@v13@@ ; char @@ptr@@ [ Number ] ; unsigned __int64 @@v15@@ ; @@v2@@ = Number ; @@v3@@ = Number L ; @@v15@@ = __readfsqword ( Number ) ; @@v4@@ = @@ptr@@ ; while ( Number ) { @@v5@@ = readlinkat ( @@fd@@ , @@path@@ , @@v4@@ , @@v3@@ ) ; @@v6@@ = @@v5@@ ; if ( @@v5@@ < Number ) { @@v13@@ = @@v5@@ ; @@v7@@ = __errno_location ( ) ; @@v6@@ = @@v13@@ ; if ( * @@v7@@ != Number ) { if ( @@v4@@ != @@ptr@@ ) { @@v8@@ = @@v4@@ ; @@v4@@ = Number L ; free ( @@v8@@ ) ; return @@v4@@ ; } return Number L ; } } if ( @@v6@@ < @@v3@@ ) break ; if ( @@v4@@ != @@ptr@@ ) free ( @@v4@@ ) ; @@v3@@ *= Number L ; if ( ! -- @@v2@@ ) { @@v4@@ = Number L ; * __errno_location ( ) = Number ; return @@v4@@ ; } @@v4@@ = ( char * ) malloc ( @@v3@@ ) ; if ( ! @@v4@@ ) return Number L ; } @@v4@@ [ @@v6@@ ] = Number ; @@v10@@ = @@v6@@ + Number ; if ( @@v4@@ == @@ptr@@ ) { @@v12@@ = ( char * ) malloc ( @@v6@@ + Number ) ; @@v4@@ = @@v12@@ ; if ( @@v12@@ ) memcpy ( @@v12@@ , @@ptr@@ , @@v10@@ ) ; } else if ( @@v3@@ > @@v10@@ ) { @@v11@@ = ( char * ) realloc ( @@v4@@ , @@v6@@ + Number ) ; if ( @@v11@@ ) @@v4@@ = @@v11@@ ; } return @@v4@@ ; }
__int64 __fastcall fts_stat ( __int64 @@a1@@ , __int64 @@a2@@ , char @@a3@@ ) { struct stat * @@v4@@ ; bool @@v5@@ ; int @@v6@@ ; const char * @@v7@@ ; int * @@v8@@ ; int @@v9@@ ; int * @@v10@@ ; __int64 @@result@@ ; int @@v12@@ ; __int64 @@v13@@ ; @@v4@@ = ( struct stat * ) ( @@a2@@ + Number ) ; @@v5@@ = * ( _QWORD * ) ( @@a2@@ + Number ) == Number L ; @@v6@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; @@v7@@ = * ( const char * * ) ( @@a2@@ + Number ) ; if ( @@v5@@ && ( @@v6@@ & Number ) != Number || ( @@v6@@ & Number ) != Number || @@a3@@ ) { if ( ! __xstat ( Number , @@v7@@ , @@v4@@ ) ) goto LABEL_11 ; @@v8@@ = __errno_location ( ) ; @@v9@@ = * @@v8@@ ; @@v10@@ = @@v8@@ ; if ( * @@v8@@ == Number && ! __lxstat ( Number , * ( const char * * ) ( @@a2@@ + Number ) , @@v4@@ ) ) { * @@v10@@ = Number ; return Number L ; } * ( _DWORD * ) ( @@a2@@ + Number ) = @@v9@@ ; LABEL_6 : * ( _QWORD * ) ( @@a2@@ + Number ) = Number L ; @@v4@@ -> __unused [ Number ] = Number L ; memset ( ( void * ) ( ( unsigned __int64 ) & @@v4@@ -> st_ino & Number ) , Number , Number L * ( ( ( unsigned int ) @@v4@@ - ( ( ( _DWORD ) @@v4@@ + Number ) & Number ) + Number ) >> Number ) ) ; return Number L ; } if ( __fxstatat ( Number , * ( _DWORD * ) ( @@a1@@ + Number ) , @@v7@@ , @@v4@@ , Number ) ) { * ( _DWORD * ) ( @@a2@@ + Number ) = * __errno_location ( ) ; goto LABEL_6 ; } LABEL_11 : @@v12@@ = * ( _DWORD * ) ( @@a2@@ + Number ) & Number ; if ( @@v12@@ == Number ) { @@v13@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( ( * ( _BYTE * ) ( @@a1@@ + Number ) & Number ) == Number ) @@v13@@ -= Number L ; @@v5@@ = * ( _BYTE * ) ( @@a2@@ + Number ) == Number ; * ( _QWORD * ) ( @@a2@@ + Number ) = @@v13@@ ; @@result@@ = Number L ; if ( @@v5@@ && ( ! * ( _BYTE * ) ( @@a2@@ + Number ) || ( * ( _DWORD * ) ( @@a2@@ + Number ) & Number ) == Number ) ) { @@result@@ = * ( _QWORD * ) ( @@a2@@ + Number ) == Number L ? Number : Number ; } } else if ( @@v12@@ == Number ) { @@result@@ = Number L ; } else { @@result@@ = Number * ( unsigned int ) ( @@v12@@ == Number ) + Number ; } return @@result@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
char * __fastcall mmalloca ( __int64 @@a1@@ ) { bool @@v1@@ ; size_t @@v2@@ ; _DWORD * @@v3@@ ; char * @@v4@@ ; unsigned __int64 @@v5@@ ; __int64 @@v6@@ ; @@v1@@ = __CFADD__ ( @@a1@@ , Number L ) ; @@v2@@ = @@a1@@ + Number ; if ( @@v1@@ ) return Number L ; @@v3@@ = malloc ( @@v2@@ ) ; @@v4@@ = Number L ; if ( @@v3@@ ) { @@v3@@ [ Number ] = Number ; @@v4@@ = ( char * ) ( @@v3@@ + Number ) ; @@v5@@ = ( unsigned __int64 ) ( @@v3@@ + Number ) % Number ; @@v6@@ = mmalloca_results [ @@v5@@ ] ; mmalloca_results [ @@v5@@ ] = @@v3@@ + Number ; * ( _QWORD * ) @@v3@@ = @@v6@@ ; } return @@v4@@ ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
FILE * __fastcall next_file ( FILE * @@stream@@ ) { const char * @@v1@@ ; const char * @@v2@@ ; FILE * @@result@@ ; int * @@v4@@ ; int * @@v5@@ ; int * @@v6@@ ; const char * @@v7@@ ; if ( @@stream@@ ) { @@v1@@ = ( const char * ) prev_file_6378 ; if ( ( @@stream@@ -> _flags & Number ) != Number ) { @@v7@@ = ( const char * ) prev_file_6378 ; @@v6@@ = __errno_location ( ) ; error ( Number , * @@v6@@ , String , @@v7@@ ) ; exit_status = Number ; @@v1@@ = ( const char * ) prev_file_6378 ; } if ( ! strcmp ( @@v1@@ , String ) ) { clearerr_unlocked ( @@stream@@ ) ; } else if ( fclose ( @@stream@@ ) ) { @@v5@@ = __errno_location ( ) ; error ( Number , * @@v5@@ , String , ( const char * ) prev_file_6378 ) ; exit_status = Number ; } } @@v2@@ = * ( const char * * ) file_list ; file_list += Number L ; if ( ! @@v2@@ ) return Number L ; while ( Number ) { if ( ! strcmp ( @@v2@@ , String ) ) { prev_file_6378 = ( __int64 ) @@v2@@ ; @@result@@ = stdin ; have_read_stdin = Number ; return @@result@@ ; } @@result@@ = fopen ( @@v2@@ , String ) ; if ( @@result@@ ) break ; @@v4@@ = __errno_location ( ) ; error ( Number , * @@v4@@ , String , @@v2@@ ) ; exit_status = Number ; @@v2@@ = * ( const char * * ) file_list ; file_list += Number L ; if ( ! @@v2@@ ) return Number L ; } prev_file_6378 = ( __int64 ) @@v2@@ ; return @@result@@ ; }
__int64 __fastcall hash_find_entry ( __int64 * @@a1@@ , __int64 @@a2@@ , __m128i * * @@a3@@ , char @@a4@@ ) { __int64 @@v5@@ ; __m128i * @@v8@@ ; __int64 @@v9@@ ; __int64 * @@v10@@ ; const __m128i * @@v12@@ ; @@v5@@ = * @@a1@@ ; @@v8@@ = ( __m128i * ) ( Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) + @@v5@@ ) ; if ( @@a1@@ [ Number ] <= ( unsigned __int64 ) @@v8@@ ) abort ( ) ; * @@a3@@ = @@v8@@ ; @@v9@@ = @@v8@@ -> m128i_i64 [ Number ] ; if ( @@v8@@ -> m128i_i64 [ Number ] ) { if ( @@v9@@ != @@a2@@ ) { if ( ! ( ( unsigned __int8 ( __fastcall * ) ( __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ ) ) { @@v10@@ = ( __int64 * ) @@v8@@ -> m128i_i64 [ Number ] ; if ( @@v10@@ ) { @@v9@@ = * @@v10@@ ; if ( @@a2@@ != * @@v10@@ ) { while ( ! ( ( unsigned __int8 ( __fastcall * ) ( __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ ) ) { @@v8@@ = ( __m128i * ) @@v8@@ -> m128i_i64 [ Number ] ; @@v10@@ = ( __int64 * ) @@v8@@ -> m128i_i64 [ Number ] ; if ( ! @@v10@@ ) return Number L ; @@v9@@ = * @@v10@@ ; if ( * @@v10@@ == @@a2@@ ) goto LABEL_12 ; } @@v10@@ = ( __int64 * ) @@v8@@ -> m128i_i64 [ Number ] ; @@v9@@ = * @@v10@@ ; } LABEL_12 : if ( @@a4@@ ) { @@v8@@ -> m128i_i64 [ Number ] = @@v10@@ [ Number ] ; * @@v10@@ = Number L ; @@v10@@ [ Number ] = @@a1@@ [ Number ] ; @@a1@@ [ Number ] = ( __int64 ) @@v10@@ ; } return @@v9@@ ; } return Number L ; } @@v9@@ = @@v8@@ -> m128i_i64 [ Number ] ; } if ( @@a4@@ ) { @@v12@@ = ( const __m128i * ) @@v8@@ -> m128i_i64 [ Number ] ; if ( @@v12@@ ) { * @@v8@@ = _mm_loadu_si128 ( @@v12@@ ) ; @@v12@@ -> m128i_i64 [ Number ] = Number L ; @@v12@@ -> m128i_i64 [ Number ] = @@a1@@ [ Number ] ; @@a1@@ [ Number ] = ( __int64 ) @@v12@@ ; return @@v9@@ ; } @@v8@@ -> m128i_i64 [ Number ] = Number L ; } return @@v9@@ ; } return Number L ; }
unsigned __int64 __fastcall LCO_hash ( _QWORD * @@a1@@ , unsigned __int64 @@a2@@ ) { return * @@a1@@ % @@a2@@ ; }
int __xstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _xstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) _frame_dummy_init_array_entry [ @@i@@ ] ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
int fchdir ( int @@fd@@ ) { return fchdir ( @@fd@@ ) ; }
char * __fastcall xstrndup ( const char * @@a1@@ , size_t @@a2@@ ) { char * @@result@@ ; @@result@@ = strndup ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
__int64 __fastcall i_ring_empty ( __int64 @@a1@@ ) { return * ( unsigned __int8 * ) ( @@a1@@ + Number ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
__int64 __fastcall fts_compare_ino ( __int64 @@a1@@ , __int64 @@a2@@ ) { unsigned __int64 @@v2@@ ; __int64 @@result@@ ; @@v2@@ = * ( _QWORD * ) ( * ( _QWORD * ) @@a2@@ + Number L ) ; if ( * ( _QWORD * ) ( * ( _QWORD * ) @@a1@@ + Number L ) < @@v2@@ ) @@result@@ = Number ; else @@result@@ = * ( _QWORD * ) ( * ( _QWORD * ) @@a1@@ + Number L ) > @@v2@@ ; return @@result@@ ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 __fastcall fd_ring_clear ( __int64 @@a1@@ ) { int @@v1@@ ; __int64 @@result@@ ; while ( Number ) { @@result@@ = i_ring_empty ( @@a1@@ ) ; if ( ( _BYTE ) @@result@@ ) break ; @@v1@@ = i_ring_pop ( @@a1@@ ) ; if ( @@v1@@ >= Number ) close ( @@v1@@ ) ; } return @@result@@ ; }
__int64 __fastcall i_ring_push ( __int64 @@a1@@ , int @@a2@@ ) { char @@v2@@ ; int @@v3@@ ; _DWORD * @@v4@@ ; __int64 @@result@@ ; int @@v6@@ ; @@v2@@ = * ( _BYTE * ) ( @@a1@@ + Number ) ^ Number ; @@v3@@ = ( @@v2@@ + ( unsigned __int8 ) * ( _DWORD * ) ( @@a1@@ + Number ) ) & Number ; @@v4@@ = ( _DWORD * ) ( @@a1@@ + Number L * ( ( @@v2@@ + ( unsigned __int8 ) * ( _DWORD * ) ( @@a1@@ + Number ) ) & Number ) ) ; @@result@@ = ( unsigned int ) * @@v4@@ ; * @@v4@@ = @@a2@@ ; @@v6@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@v3@@ ; if ( @@v6@@ == @@v3@@ ) * ( _DWORD * ) ( @@a1@@ + Number ) = ( ( _BYTE ) @@v6@@ + @@v2@@ ) & Number ; * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; return @@result@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; FILE * @@v11@@ ; char * @@v12@@ ; FILE * @@v13@@ ; char * @@v14@@ ; char * @@v15@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String String String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String String String String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String String String String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String String String String String String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = stdout ; @@v10@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; @@v11@@ = stdout ; @@v12@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v12@@ , @@v11@@ ) ; last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v13@@ = stdout ; @@v14@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v14@@ , @@v13@@ ) ; @@v15@@ = setlocale ( Number , Number L ) ; if ( @@v15@@ ) { if ( strncmp ( @@v15@@ , String , Number ) ) { last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
__int64 __fastcall fts_palloc_isra_2 ( void * * @@a1@@ , size_t * @@a2@@ , __int64 @@a3@@ ) { void * @@v4@@ ; size_t @@v5@@ ; void * @@v6@@ ; __int64 @@result@@ ; @@v4@@ = * @@a1@@ ; @@v5@@ = * @@a2@@ + @@a3@@ + Number ; if ( * @@a2@@ > @@v5@@ ) { free ( @@v4@@ ) ; * @@a1@@ = Number L ; * __errno_location ( ) = Number ; @@result@@ = Number L ; } else { * @@a2@@ = @@v5@@ ; @@v6@@ = realloc ( @@v4@@ , @@v5@@ ) ; if ( @@v6@@ ) { * @@a1@@ = @@v6@@ ; @@result@@ = Number L ; } else { free ( * @@a1@@ ) ; * @@a1@@ = Number L ; @@result@@ = Number L ; } } return @@result@@ ; }
__int64 __fastcall open_safer ( const char * @@a1@@ , char @@a2@@ , unsigned int @@a3@@ ) { __int64 @@v3@@ ; int @@v4@@ ; @@v3@@ = Number L ; if ( ( @@a2@@ & Number ) != Number ) @@v3@@ = @@a3@@ ; @@v4@@ = open ( @@a1@@ , @@a2@@ , @@v3@@ ) ; return fd_safer ( @@v4@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
char * __fastcall fts_alloc ( __int64 @@a1@@ , const void * @@a2@@ , size_t @@a3@@ ) { char * @@v4@@ ; char * @@v5@@ ; __int64 @@v6@@ ; @@v4@@ = ( char * ) malloc ( @@a3@@ + Number ) ; @@v5@@ = @@v4@@ ; if ( @@v4@@ ) { memcpy ( @@v4@@ + Number , @@a2@@ , @@a3@@ ) ; @@v6@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v5@@ [ @@a3@@ + Number ] = Number ; * ( ( _QWORD * ) @@v5@@ + Number ) = @@a3@@ ; * ( ( _QWORD * ) @@v5@@ + Number ) = @@a1@@ ; * ( ( _DWORD * ) @@v5@@ + Number ) = Number ; * ( _DWORD * ) ( @@v5@@ + Number ) = Number ; * ( ( _QWORD * ) @@v5@@ + Number ) = @@v6@@ ; * ( ( _QWORD * ) @@v5@@ + Number ) = Number L ; * ( ( _QWORD * ) @@v5@@ + Number ) = Number L ; } return @@v5@@ ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_207250 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_207230 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_207240 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
bool __fastcall setup_dir_isra_4 ( __int16 @@a1@@ , __int64 * @@a2@@ ) { __int64 @@v2@@ ; bool @@result@@ ; void * @@v4@@ ; if ( ( @@a1@@ & Number ) != Number ) { @@v2@@ = hash_initialize ( Number L , Number L , AD_hash , AD_compare , & free ) ; * @@a2@@ = @@v2@@ ; @@result@@ = @@v2@@ != Number ; } else { @@v4@@ = malloc ( Number ) ; * @@a2@@ = ( __int64 ) @@v4@@ ; @@result@@ = Number ; if ( @@v4@@ ) { cycle_check_init ( ) ; @@result@@ = Number ; } } return @@result@@ ; }
unsigned __int64 __fastcall leave_dir_isra_14 ( __int16 @@a1@@ , __int64 * * @@a2@@ , _QWORD * @@a3@@ ) { __int64 * @@v3@@ ; __int64 * @@v4@@ ; __int64 * @@v6@@ ; void * @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v11@@ = __readfsqword ( Number ) ; if ( ( @@a1@@ & Number ) != Number ) { @@v6@@ = * @@a2@@ ; @@v10@@ [ Number ] = @@a3@@ [ Number ] ; @@v10@@ [ Number ] = @@a3@@ [ Number ] ; @@v7@@ = ( void * ) hash_delete ( @@v6@@ , @@v10@@ ) ; if ( @@v7@@ ) { free ( @@v7@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; } goto LABEL_11 ; } @@v3@@ = ( __int64 * ) @@a3@@ [ Number ] ; if ( ! @@v3@@ || @@v3@@ [ Number ] < Number ) return __readfsqword ( Number ) ^ @@v11@@ ; @@v4@@ = * @@a2@@ ; if ( ! ( * @@a2@@ ) [ Number ] ) LABEL_11 : abort ( ) ; if ( * @@v4@@ == @@a3@@ [ Number ] && @@v4@@ [ Number ] == @@a3@@ [ Number ] ) { @@v8@@ = @@v3@@ [ Number ] ; @@v9@@ = @@v3@@ [ Number ] ; @@v4@@ [ Number ] = @@v8@@ ; * @@v4@@ = @@v9@@ ; } return __readfsqword ( Number ) ^ @@v11@@ ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 __fastcall hash_get_n_buckets_used ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
unsigned __int64 __fastcall raw_hasher ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return __ROR8__ ( @@a1@@ , Number ) % @@a2@@ ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
unsigned __int64 __fastcall hash_get_max_bucket_length ( __int64 @@a1@@ ) { _QWORD * @@v1@@ ; unsigned __int64 @@v2@@ ; unsigned __int64 @@result@@ ; __int64 @@v4@@ ; unsigned __int64 @@i@@ ; @@v1@@ = * ( _QWORD * * ) @@a1@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; for ( @@result@@ = Number L ; ( unsigned __int64 ) @@v1@@ < @@v2@@ ; @@v1@@ += Number ) { if ( * @@v1@@ ) { @@v4@@ = @@v1@@ [ Number ] ; for ( @@i@@ = Number L ; @@v4@@ ; ++ @@i@@ ) @@v4@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; if ( @@result@@ < @@i@@ ) @@result@@ = @@i@@ ; } } return @@result@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
__int64 __fastcall check_tuning_isra_0 ( float * * @@a1@@ ) { float * @@v1@@ ; __int64 @@result@@ ; float @@v3@@ ; float @@v4@@ ; float @@v5@@ ; @@v1@@ = * @@a1@@ ; @@result@@ = Number L ; if ( * @@a1@@ != ( float * ) & default_tuning ) { @@v3@@ = @@v1@@ [ Number ] ; if ( @@v3@@ <= Number || @@v3@@ >= Number || @@v1@@ [ Number ] <= Number || * @@v1@@ < Number || ( @@v4@@ = * @@v1@@ + Number , @@v5@@ = @@v1@@ [ Number ] , @@v5@@ <= @@v4@@ ) || @@v5@@ > Number || @@v3@@ <= @@v4@@ ) { * @@a1@@ = ( float * ) & default_tuning ; @@result@@ = Number L ; } } return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
bool __fastcall cycle_warning_required ( __int64 @@a1@@ , __int64 @@a2@@ ) { bool @@result@@ ; int @@v3@@ ; @@result@@ = Number ; @@v3@@ = * ( _DWORD * ) ( @@a1@@ + Number ) & Number ; if ( @@v3@@ != Number ) { @@result@@ = Number ; if ( @@v3@@ == Number ) @@result@@ = * ( _QWORD * ) ( @@a2@@ + Number ) != Number L ; } return @@result@@ ; }
__int64 __fastcall hash_lookup ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; _QWORD * @@v4@@ ; __int64 @@v5@@ ; @@v2@@ = * @@a1@@ ; @@v4@@ = ( _QWORD * ) ( Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) + @@v2@@ ) ; if ( @@a1@@ [ Number ] <= ( unsigned __int64 ) @@v4@@ ) abort ( ) ; @@v5@@ = * @@v4@@ ; if ( ! * @@v4@@ ) return Number L ; while ( @@v5@@ != @@a2@@ ) { if ( ( ( unsigned __int8 ( __fastcall * ) ( __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ ) ) return * @@v4@@ ; @@v4@@ = ( _QWORD * ) @@v4@@ [ Number ] ; if ( ! @@v4@@ ) return Number L ; @@v5@@ = * @@v4@@ ; } return @@v5@@ ; }
__int64 __fastcall digest_file_isra_0 ( const char * @@a1@@ ) { FILE * @@v1@@ ; unsigned int @@v2@@ ; int * @@v4@@ ; FILE * @@v5@@ ; int * @@v6@@ ; if ( ! strcmp ( @@a1@@ , String ) ) { @@v1@@ = stdin ; have_read_stdin = Number ; if ( ! ( unsigned int ) sha256_stream ( stdin ) ) return Number ; goto LABEL_5 ; } @@v5@@ = ( FILE * ) fopen_safer ( @@a1@@ , String ) ; @@v1@@ = @@v5@@ ; if ( ! @@v5@@ ) { LABEL_10 : @@v6@@ = __errno_location ( ) ; error ( Number , * @@v6@@ , String , @@a1@@ ) ; return Number L ; } if ( ! ( unsigned int ) sha256_stream ( @@v5@@ ) ) { if ( ! fclose ( @@v1@@ ) ) return Number ; goto LABEL_10 ; } LABEL_5 : @@v4@@ = __errno_location ( ) ; @@v2@@ = Number ; error ( Number , * @@v4@@ , String , @@a1@@ ) ; if ( stdin == @@v1@@ ) return @@v2@@ ; fclose ( @@v1@@ ) ; return Number L ; }
__int64 __fastcall hash_print_statistics ( __int64 @@a1@@ ) { unsigned __int64 @@v1@@ ; _QWORD * @@v2@@ ; unsigned __int64 @@i@@ ; __int64 @@v4@@ ; unsigned __int64 @@j@@ ; @@v1@@ = Number L ; @@v2@@ = * ( _QWORD * * ) @@a1@@ ; for ( @@i@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; ( unsigned __int64 ) @@v2@@ < @@i@@ ; @@v2@@ += Number ) { if ( * @@v2@@ ) { @@v4@@ = @@v2@@ [ Number ] ; for ( @@j@@ = Number L ; @@v4@@ ; ++ @@j@@ ) @@v4@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; if ( @@v1@@ < @@j@@ ) @@v1@@ = @@j@@ ; } } __fprintf_chk ( ) ; __fprintf_chk ( ) ; __fprintf_chk ( ) ; return __fprintf_chk ( ) ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__int64 __fastcall dup_cloexec ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
unsigned __int64 __fastcall hash_string ( unsigned __int8 * @@a1@@ , unsigned __int64 @@a2@@ ) { __int64 @@v2@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@v4@@ ; @@v2@@ = * @@a1@@ ; for ( @@i@@ = Number L ; ( _BYTE ) @@v2@@ ; @@i@@ = @@v4@@ % @@a2@@ ) { ++ @@a1@@ ; @@v4@@ = @@v2@@ + Number * @@i@@ ; @@v2@@ = * @@a1@@ ; } return @@i@@ ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
unsigned __int64 __fastcall hash_get_entries ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { _QWORD * @@v3@@ ; unsigned __int64 @@v4@@ ; _QWORD * @@v5@@ ; unsigned __int64 @@result@@ ; @@v3@@ = * ( _QWORD * * ) @@a1@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= * ( _QWORD * ) @@a1@@ ) return Number L ; @@v4@@ = Number L ; while ( ! * @@v3@@ ) { LABEL_9 : @@v3@@ += Number ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= ( unsigned __int64 ) @@v3@@ ) return @@v4@@ ; } if ( @@a3@@ <= @@v4@@ ) return @@v4@@ ; * ( _QWORD * ) ( @@a2@@ + Number * @@v4@@ ) = * @@v3@@ ; @@v5@@ = ( _QWORD * ) @@v3@@ [ Number ] ; @@result@@ = @@v4@@ + Number ; if ( ! @@v5@@ ) { LABEL_8 : @@v4@@ = @@result@@ ; goto LABEL_9 ; } while ( @@a3@@ != @@result@@ ) { ++ @@result@@ ; * ( _QWORD * ) ( @@a2@@ + Number * @@result@@ - Number ) = * @@v5@@ ; @@v5@@ = ( _QWORD * ) @@v5@@ [ Number ] ; if ( ! @@v5@@ ) goto LABEL_8 ; } return @@result@@ ; }
__int64 __fastcall hash_reset_tuning ( __int64 @@a1@@ ) { __int64 @@result@@ ; * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; * ( _QWORD * ) @@a1@@ = Number ; @@result@@ = Number ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number ; return @@result@@ ; }
__int64 __fastcall cycle_check ( __int64 @@a1@@ , __int64 * @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@result@@ ; __int64 @@v5@@ ; if ( * ( _DWORD * ) ( @@a1@@ + Number ) != Number ) __assert_fail ( String , String , Number , String ) ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v3@@ = @@a2@@ [ Number ] ; if ( ! @@v2@@ ) { * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; goto LABEL_7 ; } if ( * ( _QWORD * ) @@a1@@ == @@v3@@ && * @@a2@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ) { return Number L ; } @@result@@ = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v2@@ + Number ; if ( ( ( @@v2@@ + Number ) & @@v2@@ ) == Number ) { if ( @@v2@@ == Number ) return Number L ; LABEL_7 : @@v5@@ = * @@a2@@ ; * ( _QWORD * ) @@a1@@ = @@v3@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v5@@ ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
void __fastcall i_ring_init ( __int64 @@a1@@ , int @@a2@@ ) { * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; }
void __fastcall hash_clear ( _QWORD * @@a1@@ ) { _QWORD * @@v1@@ ; _QWORD * @@v2@@ ; void ( __fastcall * @@v3@@ ) ( _QWORD ) ; _QWORD * @@v4@@ ; __int64 @@v5@@ ; @@v1@@ = ( _QWORD * ) * @@a1@@ ; if ( * @@a1@@ < @@a1@@ [ Number ] ) { do { if ( * @@v1@@ ) { @@v2@@ = ( _QWORD * ) @@v1@@ [ Number ] ; @@v3@@ = ( void ( __fastcall * ) ( _QWORD ) ) @@a1@@ [ Number ] ; if ( @@v2@@ ) { do { if ( @@v3@@ ) { @@v3@@ ( * @@v2@@ ) ; @@v3@@ = ( void ( __fastcall * ) ( _QWORD ) ) @@a1@@ [ Number ] ; } @@v4@@ = ( _QWORD * ) @@v2@@ [ Number ] ; @@v5@@ = @@a1@@ [ Number ] ; * @@v2@@ = Number L ; @@v2@@ [ Number ] = @@v5@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v2@@ = @@v4@@ ; } while ( @@v4@@ ) ; } if ( @@v3@@ ) @@v3@@ ( * @@v1@@ ) ; * @@v1@@ = Number L ; @@v1@@ [ Number ] = Number L ; } @@v1@@ += Number ; } while ( @@a1@@ [ Number ] > ( unsigned __int64 ) @@v1@@ ) ; } @@a1@@ [ Number ] = Number L ; @@a1@@ [ Number ] = Number L ; }
int __fastcall restore_cwd ( __int64 @@a1@@ ) { int @@result@@ ; if ( * ( int * ) @@a1@@ < Number ) @@result@@ = chdir_long ( * ( void * * ) ( @@a1@@ + Number ) ) ; else @@result@@ = fchdir ( * ( _DWORD * ) @@a1@@ ) ; return @@result@@ ; }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
__int64 __fastcall i_ring_pop ( __int64 @@a1@@ ) { _DWORD * @@v1@@ ; int @@v2@@ ; __int64 @@result@@ ; if ( * ( _BYTE * ) ( @@a1@@ + Number ) ) abort ( ) ; @@v1@@ = ( _DWORD * ) ( @@a1@@ + Number L * * ( unsigned int * ) ( @@a1@@ + Number ) ) ; @@v2@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; @@result@@ = ( unsigned int ) * @@v1@@ ; * @@v1@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; if ( @@v2@@ == * ( _DWORD * ) ( @@a1@@ + Number ) ) * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; else * ( _DWORD * ) ( @@a1@@ + Number ) = ( ( _BYTE ) @@v2@@ + Number ) & Number ; return @@result@@ ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
__int64 __fastcall openat_safer ( int @@a1@@ , const char * @@a2@@ , char @@a3@@ , unsigned int @@a4@@ ) { __int64 @@v4@@ ; int @@v5@@ ; @@v4@@ = Number L ; if ( ( @@a3@@ & Number ) != Number ) @@v4@@ = @@a4@@ ; @@v5@@ = openat ( @@a1@@ , @@a2@@ , @@a3@@ , @@v4@@ ) ; return fd_safer ( @@v5@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
DIR * __fastcall opendir_safer ( const char * @@a1@@ ) { DIR * @@v1@@ ; DIR * @@v2@@ ; unsigned int @@v3@@ ; int @@v5@@ ; DIR * @@v6@@ ; int * @@v7@@ ; int @@v8@@ ; @@v1@@ = opendir ( @@a1@@ ) ; @@v2@@ = @@v1@@ ; if ( ! @@v1@@ ) return @@v2@@ ; @@v3@@ = dirfd ( @@v1@@ ) ; if ( @@v3@@ > Number ) return @@v2@@ ; @@v5@@ = dup_safer ( @@v3@@ ) ; @@v6@@ = fdopendir ( @@v5@@ ) ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; if ( ! @@v6@@ ) close ( @@v5@@ ) ; closedir ( @@v2@@ ) ; * @@v7@@ = @@v8@@ ; return @@v6@@ ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
__int64 __fastcall set_cloexec_flag ( int @@a1@@ , char @@a2@@ , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { int @@v6@@ ; int @@v7@@ ; int @@v8@@ ; int @@v9@@ ; int @@v10@@ ; unsigned int @@v11@@ ; __int64 @@result@@ ; @@v6@@ = rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( @@v6@@ < Number ) return Number ; @@v9@@ = @@v6@@ ; @@v10@@ = @@v6@@ | Number ; @@v11@@ = @@v9@@ & Number ; if ( @@a2@@ ) @@v11@@ = @@v10@@ ; @@result@@ = Number L ; if ( @@v11@@ != @@v9@@ ) @@result@@ = ( unsigned int ) - ( ( unsigned int ) rpl_fcntl ( @@a1@@ , Number , @@v11@@ , @@v9@@ , @@v7@@ , @@v8@@ ) == Number ) ; return @@result@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
__int64 __fastcall file_name_concat ( void * @@a1@@ , void * @@a2@@ ) { __int64 @@result@@ ; @@result@@ = mfile_name_concat ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
int __xstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _xstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_20A210 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20A1F0 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_20A200 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__ino_t * __fastcall get_root_dev_ino ( __ino_t * @@a1@@ ) { struct stat @@v2@@ ; unsigned __int64 @@v3@@ ; @@v3@@ = __readfsqword ( Number ) ; if ( __lxstat ( Number , String , & @@v2@@ ) ) return Number L ; * @@a1@@ = @@v2@@ . st_ino ; @@a1@@ [ Number ] = @@v2@@ . st_dev ; return @@a1@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_2071F0 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2071D0 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2071E0 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall getfileconat ( int @@fd@@ , _BYTE * @@a2@@ ) { int * @@v2@@ ; char * @@v3@@ ; int @@v5@@ ; int @@v6@@ [ Number ] ; char @@v7@@ [ Number ] ; unsigned __int64 @@v8@@ ; @@v8@@ = __readfsqword ( Number ) ; @@v2@@ = __errno_location ( ) ; if ( @@fd@@ != Number && * @@a2@@ != Number ) { @@v3@@ = ( char * ) openat_proc_name ( @@v7@@ , ( unsigned int ) @@fd@@ , @@a2@@ ) ; if ( @@v3@@ ) { * @@v2@@ = Number ; if ( @@v3@@ != @@v7@@ ) free ( @@v3@@ ) ; } if ( ( unsigned int ) save_cwd ( @@v6@@ ) ) openat_save_fail ( * @@v2@@ ) ; if ( @@fd@@ >= Number && @@v6@@ [ Number ] == @@fd@@ ) { free_cwd ( @@v6@@ ) ; * @@v2@@ = Number ; return Number ; } if ( fchdir ( @@fd@@ ) ) { @@v5@@ = * @@v2@@ ; free_cwd ( @@v6@@ ) ; * @@v2@@ = @@v5@@ ; return Number ; } * @@v2@@ = Number ; if ( ( unsigned int ) restore_cwd ( @@v6@@ ) ) openat_restore_fail ( * @@v2@@ ) ; free_cwd ( @@v6@@ ) ; } * @@v2@@ = Number ; return Number ; }
void __fastcall print_line ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char * @@a7@@ , char * @@s@@ , __int64 @@a9@@ , __int64 @@a10@@ ) { const char * @@v12@@ ; char @@v13@@ ; char * @@v14@@ ; __int64 @@v15@@ ; size_t @@v16@@ ; _BYTE * @@v17@@ ; void * @@v18@@ ; const char * @@v19@@ ; char * @@v20@@ ; char * @@i@@ ; size_t @@v22@@ ; int @@v24@@ ; char * @@v25@@ ; char @@v26@@ [ Number ] ; char @@v27@@ [ Number ] ; unsigned __int64 @@v28@@ ; @@v12@@ = ( const char * ) @@a2@@ ; byte_20B019 = @@a3@@ ; @@v13@@ = short_output ; @@v24@@ = @@a4@@ ; @@v14@@ = @@a7@@ ; @@v28@@ = __readfsqword ( Number ) ; if ( ! include_idle || short_output || ( @@v22@@ = strlen ( @@a7@@ ) , @@v14@@ = @@a7@@ , @@v22@@ > Number ) ) { @@v26@@ [ Number ] = Number ; } else { @@a2@@ = Number L ; __sprintf_chk ( ) ; @@v13@@ = short_output ; } if ( @@v13@@ || strlen ( @@s@@ ) > Number ) { @@v27@@ [ Number ] = Number ; } else { @@a2@@ = Number L ; __sprintf_chk ( ) ; } @@v15@@ = Number L ; if ( include_exit ) { @@v16@@ = strlen ( ( const char * ) @@a10@@ ) ; @@v15@@ = @@v16@@ + Number ; if ( @@v16@@ <= Number ) @@v15@@ = Number L ; } @@v17@@ = ( _BYTE * ) xmalloc ( @@v15@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v14@@ ) ; @@v18@@ = @@v17@@ ; if ( include_exit ) __sprintf_chk ( ) ; else * @@v17@@ = Number ; @@v19@@ = String ; if ( include_mesg ) @@v19@@ = ( const char * ) & mesg_6521 ; if ( ! @@v12@@ ) @@v12@@ = String ; if ( ( unsigned int ) rpl_asprintf ( ( unsigned int ) & @@v25@@ , ( unsigned int ) String , @@a1@@ , ( _DWORD ) @@v12@@ , ( _DWORD ) @@v19@@ , @@v24@@ , @@a5@@ , ( unsigned int ) time_format_width , @@a6@@ , @@v26@@ , @@v27@@ , @@a9@@ , @@v18@@ ) == Number ) xalloc_die ( ) ; @@v20@@ = @@v25@@ ; for ( @@i@@ = & @@v20@@ [ strlen ( @@v25@@ ) ] ; * ( @@i@@ - Number ) == Number ; -- @@i@@ ) { ; } * @@i@@ = Number ; puts ( @@v25@@ ) ; free ( @@v25@@ ) ; free ( @@v18@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
void __fastcall cycle_check_init ( __int64 @@a1@@ ) { * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _DWORD * ) ( @@a1@@ + Number ) = Number ; }
char * __fastcall canon_host ( char * @@a1@@ ) { return canon_host_r ( @@a1@@ , & last_cherror ) ; }
void __fastcall __noreturn openat_restore_fail ( int @@errnum@@ ) { char * @@v1@@ ; @@v1@@ = dcgettext ( Number L , String , Number ) ; error ( exit_failure , @@errnum@@ , @@v1@@ ) ; abort ( ) ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
__int64 __fastcall dup_safer ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
bool __fastcall hard_locale ( int @@a1@@ ) { char * @@v1@@ ; bool @@result@@ ; @@v1@@ = setlocale ( @@a1@@ , Number L ) ; @@result@@ = Number ; if ( @@v1@@ ) { @@result@@ = Number ; if ( strcmp ( @@v1@@ , String ) ) @@result@@ = strcmp ( @@v1@@ , String ) != Number ; } return @@result@@ ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
__int64 __fastcall rpl_fcntl ( int @@a1@@ , int @@a2@@ , __int64 @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { int @@v6@@ ; int @@v8@@ ; int @@v9@@ ; int @@v10@@ ; int @@v11@@ ; int * @@v12@@ ; int @@v13@@ ; int * @@v14@@ ; int @@v15@@ ; @@v15@@ = @@a3@@ ; if ( @@a2@@ != Number ) return ( unsigned int ) fcntl ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( have_dupfd_cloexec_3202 < Number ) { @@v6@@ = rpl_fcntl ( @@a1@@ , Number , ( unsigned int ) @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( @@v6@@ < Number || have_dupfd_cloexec_3202 != Number ) return ( unsigned int ) @@v6@@ ; } else { @@v6@@ = fcntl ( @@a1@@ , Number , ( unsigned int ) @@a3@@ ) ; if ( @@v6@@ >= Number || * __errno_location ( ) != Number ) { have_dupfd_cloexec_3202 = Number ; return ( unsigned int ) @@v6@@ ; } @@v6@@ = rpl_fcntl ( @@a1@@ , Number , @@v15@@ , @@v8@@ , @@v9@@ , @@v10@@ ) ; if ( @@v6@@ < Number ) return ( unsigned int ) @@v6@@ ; have_dupfd_cloexec_3202 = Number ; } @@v11@@ = fcntl ( @@v6@@ , Number ) ; if ( @@v11@@ < Number || fcntl ( @@v6@@ , Number , @@v11@@ | Number ) == Number ) { @@v12@@ = __errno_location ( ) ; @@v13@@ = * @@v12@@ ; @@v14@@ = @@v12@@ ; close ( @@v6@@ ) ; @@v6@@ = Number ; * @@v14@@ = @@v13@@ ; } return ( unsigned int ) @@v6@@ ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; const char * @@v2@@ ; char * @@v3@@ ; FILE * @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; char * @@v10@@ ; char * @@v11@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = String ; if ( uname_mode == Number ) { @@v11@@ = dcgettext ( Number L , String String String String String String String , Number ) ; fputs_unlocked ( @@v11@@ , @@v1@@ ) ; @@v1@@ = stdout ; @@v2@@ = String String String String String ; } @@v3@@ = dcgettext ( Number L , @@v2@@ , Number ) ; fputs_unlocked ( @@v3@@ , @@v1@@ ) ; @@v4@@ = stdout ; @@v5@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v5@@ , @@v4@@ ) ; @@v6@@ = stdout ; @@v7@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v8@@ = stdout ; @@v9@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = setlocale ( Number , Number L ) ; if ( @@v10@@ ) { if ( strncmp ( @@v10@@ , String , Number ) ) { last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
_BYTE * __fastcall openat_proc_name ( _BYTE * @@a1@@ , __int64 a2 , const char * @@a3@@ ) { void * @@v3@@ ; int @@v4@@ ; size_t @@v6@@ ; int @@v8@@ ; int @@v9@@ ; struct stat @@v10@@ ; struct stat @@stat_buf@@ ; char @@filename@@ [ Number ] ; unsigned __int64 @@v13@@ ; @@v3@@ = @@a1@@ ; @@v13@@ = __readfsqword ( Number ) ; if ( ! * @@a3@@ ) { * @@a1@@ = Number ; return @@a1@@ ; } @@v4@@ = proc_status_5238 ; if ( ! proc_status_5238 ) { @@v8@@ = open ( String , Number ) ; if ( @@v8@@ < Number ) { proc_status_5238 = Number ; return Number L ; } __sprintf_chk ( ) ; if ( __xstat ( Number , @@filename@@ , & @@v10@@ ) || __xstat ( Number , String , & @@stat_buf@@ ) || @@v10@@ . st_ino != @@stat_buf@@ . st_ino || ( @@v9@@ = Number , @@v10@@ . st_dev != @@stat_buf@@ . st_dev ) ) { @@v9@@ = Number ; } proc_status_5238 = @@v9@@ ; close ( @@v8@@ ) ; @@v4@@ = proc_status_5238 ; } if ( @@v4@@ < Number ) return Number L ; @@v6@@ = strlen ( @@a3@@ ) + Number ; if ( @@v6@@ > Number ) @@v3@@ = xmalloc ( @@v6@@ ) ; __sprintf_chk ( ) ; return @@v3@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; program_invocation_short_name = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
time_t time ( time_t * @@timer@@ ) { return time ( @@timer@@ ) ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
char * ttyname ( int @@fd@@ ) { return ttyname ( @@fd@@ ) ; }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
int __lxstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _lxstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
int closedir ( DIR * @@dirp@@ ) { return closedir ( @@dirp@@ ) ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
char * __fastcall canon_host_r ( char * @@s@@ , int * @@a2@@ ) { int @@v3@@ ; struct addrinfo * @@v4@@ ; char * @@v5@@ ; char * @@v6@@ ; struct addrinfo * @@ai@@ [ Number ] ; hints_3271 . ai_flags = Number ; @@ai@@ [ Number ] = Number L ; @@ai@@ [ Number ] = ( struct addrinfo * ) __readfsqword ( Number ) ; @@v3@@ = getaddrinfo ( @@s@@ , Number L , & hints_3271 , @@ai@@ ) ; if ( @@v3@@ ) { @@v6@@ = Number L ; if ( @@a2@@ ) * @@a2@@ = @@v3@@ ; } else { @@v4@@ = @@ai@@ [ Number ] ; @@v5@@ = @@ai@@ [ Number ] -> ai_canonname ; if ( ! @@v5@@ ) @@v5@@ = @@s@@ ; @@v6@@ = strdup ( @@v5@@ ) ; if ( ! @@v6@@ && @@a2@@ ) * @@a2@@ = Number ; freeaddrinfo ( @@v4@@ ) ; } return @@v6@@ ; }
struct group * getgrnam ( const char * @@name@@ ) { return getgrnam ( @@name@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; FILE * @@v11@@ ; char * @@v12@@ ; FILE * @@v13@@ ; char * @@v14@@ ; FILE * @@v15@@ ; char * @@v16@@ ; char * @@v17@@ ; FILE * @@v18@@ ; char * @@v19@@ ; char * @@v20@@ ; char * @@v21@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = stdout ; @@v10@@ = dcgettext ( Number L , String String String String , Number ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; @@v11@@ = stdout ; @@v12@@ = dcgettext ( Number L , String String String String , Number ) ; fputs_unlocked ( @@v12@@ , @@v11@@ ) ; @@v13@@ = stdout ; @@v14@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v14@@ , @@v13@@ ) ; @@v15@@ = stdout ; @@v16@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v16@@ , @@v15@@ ) ; @@v17@@ = dcgettext ( Number L , String String String , Number ) ; __printf_chk ( ) ; last_component ( program_name , @@v17@@ ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v18@@ = stdout ; @@v19@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v19@@ , @@v18@@ ) ; @@v20@@ = Number L ; @@v21@@ = setlocale ( Number , Number L ) ; if ( @@v21@@ ) { @@v20@@ = String ; if ( strncmp ( @@v21@@ , String , Number ) ) { last_component ( program_name , String ) ; @@v20@@ = dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name , @@v20@@ ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_20B2B0 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20B290 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_20B2A0 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __m128i * @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 * @@v10@@ ; _BYTE * @@v11@@ ; unsigned __int64 @@v12@@ ; __int64 @@v13@@ ; __int64 @@v14@@ ; __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; _BYTE * @@v17@@ ; unsigned __int64 @@v20@@ ; int @@v21@@ ; int @@v22@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v21@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L ) ; slotvec = @@v7@@ ; @@v9@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v8@@ = ( __m128i * ) xrealloc ( slotvec ) ; @@v9@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v8@@ ; slotvec = @@v8@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v9@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v10@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v11@@ = ( _BYTE * ) @@v10@@ [ Number ] ; @@v22@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v20@@ = * @@v10@@ ; @@v12@@ = quotearg_buffer_restyled ( @@v11@@ , * @@v10@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v22@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v20@@ <= @@v12@@ ) { @@v16@@ = @@v12@@ + Number ; * @@v10@@ = @@v12@@ + Number ; if ( @@v11@@ != ( _BYTE * ) & slot0 ) free ( @@v11@@ ) ; @@v17@@ = ( _BYTE * ) xmalloc ( @@v16@@ , @@v16@@ , @@v13@@ , @@v14@@ , @@v15@@ ) ; @@v10@@ [ Number ] = ( unsigned __int64 ) @@v17@@ ; @@v11@@ = @@v17@@ ; quotearg_buffer_restyled ( @@v17@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v22@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v21@@ ; return @@v11@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
int __fxstatat ( int @@ver@@ , int @@fildes@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ , int @@flag@@ ) { return _fxstatat ( @@ver@@ , @@fildes@@ , @@filename@@ , @@stat_buf@@ , @@flag@@ ) ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
struct dirent * readdir ( DIR * @@dirp@@ ) { return readdir ( @@dirp@@ ) ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; program_invocation_short_name = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
unsigned __int64 __fastcall LCO_hash ( _QWORD * @@a1@@ , unsigned __int64 @@a2@@ ) { return * @@a1@@ % @@a2@@ ; }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
__int64 __fastcall fts_compare_ino ( __int64 @@a1@@ , __int64 @@a2@@ ) { unsigned __int64 @@v2@@ ; __int64 @@result@@ ; @@v2@@ = * ( _QWORD * ) ( * ( _QWORD * ) @@a2@@ + Number L ) ; if ( * ( _QWORD * ) ( * ( _QWORD * ) @@a1@@ + Number L ) < @@v2@@ ) @@result@@ = Number ; else @@result@@ = * ( _QWORD * ) ( * ( _QWORD * ) @@a1@@ + Number L ) > @@v2@@ ; return @@result@@ ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
char * __fastcall extract_trimmed_name ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ ) { char * @@v5@@ ; char * @@v6@@ ; @@v5@@ = ( char * ) xmalloc ( Number L , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; strncpy ( @@v5@@ , ( const char * ) ( @@a1@@ + Number ) , Number ) ; @@v5@@ [ Number ] = Number ; @@v6@@ = & @@v5@@ [ strlen ( @@v5@@ ) ] ; if ( @@v5@@ < @@v6@@ ) { do { if ( * ( @@v6@@ - Number ) != Number ) break ; * -- @@v6@@ = Number ; } while ( @@v5@@ != @@v6@@ ) ; } return @@v5@@ ; }
__int64 __fastcall fd_ring_clear ( __int64 @@a1@@ ) { int @@v1@@ ; __int64 @@result@@ ; while ( Number ) { @@result@@ = i_ring_empty ( @@a1@@ ) ; if ( ( _BYTE ) @@result@@ ) break ; @@v1@@ = i_ring_pop ( @@a1@@ ) ; if ( @@v1@@ >= Number ) close ( @@v1@@ ) ; } return @@result@@ ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
__int64 __fastcall fts_palloc_isra_2 ( void * * @@a1@@ , size_t * @@a2@@ , __int64 @@a3@@ ) { void * @@v4@@ ; size_t @@v5@@ ; void * @@v6@@ ; __int64 @@result@@ ; @@v4@@ = * @@a1@@ ; @@v5@@ = * @@a2@@ + @@a3@@ + Number ; if ( * @@a2@@ > @@v5@@ ) { free ( @@v4@@ ) ; * @@a1@@ = Number L ; * __errno_location ( ) = Number ; @@result@@ = Number L ; } else { * @@a2@@ = @@v5@@ ; @@v6@@ = realloc ( @@v4@@ , @@v5@@ ) ; if ( @@v6@@ ) { * @@a1@@ = @@v6@@ ; @@result@@ = Number L ; } else { free ( * @@a1@@ ) ; * @@a1@@ = Number L ; @@result@@ = Number L ; } } return @@result@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 __fastcall enter_dir_isra_11 ( __int16 @@a1@@ , _QWORD * @@a2@@ , __int64 @@a3@@ ) { _QWORD * @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; __int64 @@result@@ ; if ( ( @@a1@@ & Number ) != Number ) { @@v4@@ = malloc ( Number ) ; if ( @@v4@@ ) { @@v5@@ = * ( _QWORD * ) ( @@a3@@ + Number ) ; @@v6@@ = * @@a2@@ ; @@v4@@ [ Number ] = @@a3@@ ; * @@v4@@ = @@v5@@ ; @@v4@@ [ Number ] = * ( _QWORD * ) ( @@a3@@ + Number ) ; @@v7@@ = hash_insert ( @@v6@@ , @@v4@@ ) ; if ( @@v4@@ == ( _QWORD * ) @@v7@@ ) return Number L ; free ( @@v4@@ ) ; if ( @@v7@@ ) { @@v8@@ = * ( _QWORD * ) ( @@v7@@ + Number ) ; * ( _WORD * ) ( @@a3@@ + Number ) = Number ; * ( _QWORD * ) @@a3@@ = @@v8@@ ; return Number L ; } } @@result@@ = Number L ; } else { @@result@@ = cycle_check ( * @@a2@@ , @@a3@@ + Number ) ; if ( ! ( _BYTE ) @@result@@ ) return Number L ; * ( _QWORD * ) @@a3@@ = @@a3@@ ; * ( _WORD * ) ( @@a3@@ + Number ) = Number ; } return @@result@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
bool __fastcall AD_compare ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@result@@ ; @@result@@ = Number ; if ( @@a1@@ [ Number ] == @@a2@@ [ Number ] ) @@result@@ = * @@a1@@ == * @@a2@@ ; return @@result@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
__int64 __fastcall check_tuning_isra_0 ( float * * @@a1@@ ) { float * @@v1@@ ; __int64 @@result@@ ; float @@v3@@ ; float @@v4@@ ; float @@v5@@ ; @@v1@@ = * @@a1@@ ; @@result@@ = Number L ; if ( * @@a1@@ != ( float * ) & default_tuning ) { @@v3@@ = @@v1@@ [ Number ] ; if ( @@v3@@ <= Number || @@v3@@ >= Number || @@v1@@ [ Number ] <= Number || * @@v1@@ < Number || ( @@v4@@ = * @@v1@@ + Number , @@v5@@ = @@v1@@ [ Number ] , @@v5@@ <= @@v4@@ ) || @@v5@@ > Number || @@v3@@ <= @@v4@@ ) { * @@a1@@ = ( float * ) & default_tuning ; @@result@@ = Number L ; } } return @@result@@ ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
__int64 __fastcall fts_sort ( _QWORD * @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { __int64 @@v5@@ ; bool @@v6@@ ; int ( * @@v7@@ ) ( const void * , const void * ) ; void * @@v8@@ ; void * @@v9@@ ; _QWORD * @@v10@@ ; __int64 * @@v11@@ ; size_t @@v12@@ ; __int64 @@result@@ ; __int64 @@v14@@ ; __int64 * @@i@@ ; __int64 @@v16@@ ; __int64 @@v17@@ ; @@v5@@ = @@a2@@ ; @@v6@@ = @@a1@@ [ Number ] < @@a3@@ ; @@v7@@ = ( int ( * ) ( const void * , const void * ) ) @@a1@@ [ Number ] ; @@v8@@ = ( void * ) @@a1@@ [ Number ] ; if ( ! @@v6@@ ) goto LABEL_5 ; @@a1@@ [ Number ] = @@a3@@ + Number ; if ( @@a3@@ + Number > Number ) { LABEL_15 : free ( @@v8@@ ) ; @@a1@@ [ Number ] = Number L ; @@a1@@ [ Number ] = Number L ; return @@a2@@ ; } @@v9@@ = realloc ( @@v8@@ , Number * ( @@a3@@ + Number ) ) ; @@v8@@ = @@v9@@ ; if ( ! @@v9@@ ) { @@v8@@ = ( void * ) @@a1@@ [ Number ] ; goto LABEL_15 ; } @@a1@@ [ Number ] = @@v9@@ ; LABEL_5 : if ( @@a2@@ ) { @@v10@@ = @@v8@@ ; do { * @@v10@@ ++ = @@v5@@ ; @@v5@@ = * ( _QWORD * ) ( @@v5@@ + Number ) ; } while ( @@v5@@ ) ; } qsort ( @@v8@@ , @@a3@@ , Number , @@v7@@ ) ; @@v11@@ = ( __int64 * ) @@a1@@ [ Number ] ; @@v12@@ = @@a3@@ - Number ; @@result@@ = * @@v11@@ ; if ( @@a3@@ == Number ) { @@v17@@ = * @@v11@@ ; } else { @@v14@@ = * @@v11@@ ; for ( @@i@@ = ( __int64 * ) @@a1@@ [ Number ] ; ; @@v14@@ = * @@i@@ ) { @@v16@@ = @@i@@ [ Number ] ; ++ @@i@@ ; -- @@v12@@ ; * ( _QWORD * ) ( @@v14@@ + Number ) = @@v16@@ ; if ( ! @@v12@@ ) break ; } @@v17@@ = @@v11@@ [ @@a3@@ - Number ] ; } * ( _QWORD * ) ( @@v17@@ + Number ) = Number L ; return @@result@@ ; }
__int64 __fastcall hash_lookup ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; _QWORD * @@v4@@ ; __int64 @@v5@@ ; @@v2@@ = * @@a1@@ ; @@v4@@ = ( _QWORD * ) ( Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) + @@v2@@ ) ; if ( @@a1@@ [ Number ] <= ( unsigned __int64 ) @@v4@@ ) abort ( ) ; @@v5@@ = * @@v4@@ ; if ( ! * @@v4@@ ) return Number L ; while ( @@v5@@ != @@a2@@ ) { if ( ( ( unsigned __int8 ( __fastcall * ) ( __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ ) ) return * @@v4@@ ; @@v4@@ = ( _QWORD * ) @@v4@@ [ Number ] ; if ( ! @@v4@@ ) return Number L ; @@v5@@ = * @@v4@@ ; } return @@v5@@ ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
__int64 __fastcall fts_set ( __int64 a1 , __int64 @@a2@@ , unsigned int @@a3@@ ) { __int64 @@result@@ ; if ( @@a3@@ > Number ) { * __errno_location ( ) = Number ; @@result@@ = Number L ; } else { * ( _WORD * ) ( @@a2@@ + Number ) = @@a3@@ ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall hash_do_for_each ( __int64 @@a1@@ , unsigned __int8 ( __fastcall * @@a2@@ ) ( __int64 , __int64 ) , __int64 @@a3@@ ) { __int64 * @@v3@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 * @@v8@@ ; @@v3@@ = * ( __int64 * * ) @@a1@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= * ( _QWORD * ) @@a1@@ ) return Number L ; @@v6@@ = Number L ; while ( Number ) { @@v7@@ = * @@v3@@ ; if ( * @@v3@@ ) break ; LABEL_8 : @@v3@@ += Number ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= ( unsigned __int64 ) @@v3@@ ) return @@v6@@ ; } @@v8@@ = @@v3@@ ; while ( @@a2@@ ( @@v7@@ , @@a3@@ ) ) { @@v8@@ = ( __int64 * ) @@v8@@ [ Number ] ; ++ @@v6@@ ; if ( ! @@v8@@ ) goto LABEL_8 ; @@v7@@ = * @@v8@@ ; } return @@v6@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 __fastcall i_ring_empty ( __int64 @@a1@@ ) { return * ( unsigned __int8 * ) ( @@a1@@ + Number ) ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
int fileno ( FILE * @@stream@@ ) { return fileno ( @@stream@@ ) ; }
unsigned __int64 __fastcall next_prime ( unsigned __int64 @@a1@@ ) { unsigned __int64 @@v1@@ ; unsigned __int64 @@v2@@ ; __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; if ( @@a1@@ < Number ) @@a1@@ = Number L ; @@v1@@ = @@a1@@ | Number ; if ( @@v1@@ != Number ) { while ( Number ) { @@v2@@ = @@v1@@ % Number ; if ( @@v1@@ <= Number ) goto LABEL_9 ; if ( @@v1@@ % Number ) break ; LABEL_10 : @@v1@@ += Number L ; if ( @@v1@@ == Number ) return @@v1@@ ; } @@v3@@ = Number L ; @@v4@@ = Number L ; @@v5@@ = Number L ; while ( Number ) { @@v5@@ += Number L ; @@v4@@ += @@v3@@ ; @@v2@@ = @@v1@@ % @@v5@@ ; if ( @@v4@@ >= @@v1@@ ) break ; @@v3@@ += Number L ; if ( ! ( @@v1@@ % @@v5@@ ) ) goto LABEL_10 ; } LABEL_9 : if ( @@v2@@ ) return @@v1@@ ; goto LABEL_10 ; } return @@v1@@ ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
__int64 __fastcall i_ring_push ( __int64 @@a1@@ , int @@a2@@ ) { char @@v2@@ ; int @@v3@@ ; _DWORD * @@v4@@ ; __int64 @@result@@ ; int @@v6@@ ; @@v2@@ = * ( _BYTE * ) ( @@a1@@ + Number ) ^ Number ; @@v3@@ = ( @@v2@@ + ( unsigned __int8 ) * ( _DWORD * ) ( @@a1@@ + Number ) ) & Number ; @@v4@@ = ( _DWORD * ) ( @@a1@@ + Number L * ( ( @@v2@@ + ( unsigned __int8 ) * ( _DWORD * ) ( @@a1@@ + Number ) ) & Number ) ) ; @@result@@ = ( unsigned int ) * @@v4@@ ; * @@v4@@ = @@a2@@ ; @@v6@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@v3@@ ; if ( @@v6@@ == @@v3@@ ) * ( _DWORD * ) ( @@a1@@ + Number ) = ( ( _BYTE ) @@v6@@ + @@v2@@ ) & Number ; * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; return @@result@@ ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
__int64 __fastcall hash_get_first ( __int64 @@a1@@ ) { __int64 * @@v1@@ ; unsigned __int64 @@v2@@ ; __int64 @@result@@ ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; @@v1@@ = * ( __int64 * * ) @@a1@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( * ( _QWORD * ) @@a1@@ >= @@v2@@ ) goto LABEL_9 ; @@result@@ = * @@v1@@ ; if ( ! * @@v1@@ ) { while ( Number ) { @@v1@@ += Number ; if ( ( unsigned __int64 ) @@v1@@ >= @@v2@@ ) break ; @@result@@ = * @@v1@@ ; if ( * @@v1@@ ) return @@result@@ ; } LABEL_9 : abort ( ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; char * @@v11@@ ; FILE * @@v12@@ ; char * @@v13@@ ; char * @@v14@@ ; char * @@v15@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String String String String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String String String String String String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = stdout ; @@v10@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; @@v11@@ = dcgettext ( Number L , String String String String String , Number ) ; __printf_chk ( ) ; last_component ( program_name , @@v11@@ ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v12@@ = stdout ; @@v13@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v13@@ , @@v12@@ ) ; @@v14@@ = Number L ; @@v15@@ = setlocale ( Number , Number L ) ; if ( @@v15@@ ) { @@v14@@ = String ; if ( strncmp ( @@v15@@ , String , Number ) ) { last_component ( program_name , String ) ; @@v14@@ = dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name , @@v14@@ ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
__int64 __fastcall hash_do_for_each ( __int64 @@a1@@ , unsigned __int8 ( __fastcall * @@a2@@ ) ( __int64 , __int64 ) , __int64 @@a3@@ ) { __int64 * @@v3@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 * @@v8@@ ; @@v3@@ = * ( __int64 * * ) @@a1@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= * ( _QWORD * ) @@a1@@ ) return Number L ; @@v6@@ = Number L ; while ( Number ) { @@v7@@ = * @@v3@@ ; if ( * @@v3@@ ) break ; LABEL_8 : @@v3@@ += Number ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= ( unsigned __int64 ) @@v3@@ ) return @@v6@@ ; } @@v8@@ = @@v3@@ ; while ( @@a2@@ ( @@v7@@ , @@a3@@ ) ) { @@v8@@ = ( __int64 * ) @@v8@@ [ Number ] ; ++ @@v6@@ ; if ( ! @@v8@@ ) goto LABEL_8 ; @@v7@@ = * @@v8@@ ; } return @@v6@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
_QWORD * __fastcall hash_initialize ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 ( __fastcall * @@a3@@ ) ( __int64 a1 , unsigned __int64 a2 ) , bool ( __fastcall * @@a4@@ ) ( __int64 a1 , __int64 a2 ) , __int64 @@a5@@ ) { unsigned __int64 ( __fastcall * @@v5@@ ) ( __int64 , unsigned __int64 ) ; bool ( __fastcall * @@v6@@ ) ( __int64 , __int64 ) ; char * @@v9@@ ; _QWORD * @@v10@@ ; float * * @@v11@@ ; float @@v12@@ ; float @@v13@@ ; float @@v14@@ ; unsigned __int64 @@v15@@ ; char * @@v16@@ ; void * @@v17@@ ; @@v5@@ = @@a3@@ ; @@v6@@ = @@a4@@ ; if ( ! @@a3@@ ) @@v5@@ = raw_hasher ; if ( ! @@a4@@ ) @@v6@@ = raw_comparator ; @@v9@@ = ( char * ) malloc ( Number ) ; @@v10@@ = @@v9@@ ; if ( @@v9@@ ) { @@v11@@ = ( float * * ) ( @@v9@@ + Number ) ; if ( @@a2@@ ) { * ( ( _QWORD * ) @@v9@@ + Number ) = @@a2@@ ; if ( ! ( unsigned __int8 ) check_tuning_isra_0 ( @@v11@@ ) ) goto LABEL_20 ; if ( * ( _BYTE * ) ( @@a2@@ + Number ) ) { LABEL_15 : @@v15@@ = next_prime ( @@a1@@ ) ; if ( @@v15@@ <= Number ) { @@v10@@ [ Number ] = @@v15@@ ; if ( @@v15@@ ) { @@v16@@ = ( char * ) calloc ( @@v15@@ , Number ) ; * @@v10@@ = @@v16@@ ; if ( @@v16@@ ) { @@v10@@ [ Number ] = Number L ; @@v10@@ [ Number ] = Number L ; @@v10@@ [ Number ] = @@v5@@ ; @@v10@@ [ Number ] = @@v6@@ ; @@v10@@ [ Number ] = & @@v16@@ [ Number * @@v15@@ ] ; @@v10@@ [ Number ] = @@a5@@ ; @@v10@@ [ Number ] = Number L ; return @@v10@@ ; } } } LABEL_20 : @@v17@@ = @@v10@@ ; @@v10@@ = Number L ; free ( @@v17@@ ) ; return @@v10@@ ; } @@v12@@ = * ( float * ) ( @@a2@@ + Number ) ; } else { * ( ( _QWORD * ) @@v9@@ + Number ) = & default_tuning ; @@v12@@ = Number ; if ( ! ( unsigned __int8 ) check_tuning_isra_0 ( @@v11@@ ) ) goto LABEL_20 ; } if ( @@a1@@ < Number ) @@v13@@ = ( float ) ( @@a1@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@a1@@ >> Number ) ) + ( float ) ( @@a1@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@a1@@ >> Number ) ) ; else @@v13@@ = ( float ) ( int ) @@a1@@ ; @@v14@@ = @@v13@@ / @@v12@@ ; if ( @@v14@@ >= Number ) goto LABEL_20 ; if ( @@v14@@ < Number ) @@a1@@ = ( unsigned int ) ( int ) @@v14@@ ; else @@a1@@ = ( unsigned int ) ( int ) ( float ) ( @@v14@@ - Number ) ^ Number ; goto LABEL_15 ; } return @@v10@@ ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
__int64 __fastcall sha224_read_ctx ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; __int64 @@i@@ ; @@result@@ = @@a2@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; @@i@@ += Number L ) * ( _DWORD * ) ( @@a2@@ + @@i@@ ) = _byteswap_ulong ( * ( _DWORD * ) ( @@a1@@ + @@i@@ ) ) ; return @@result@@ ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
__int64 __fastcall sha224_buffer ( void * @@a1@@ , size_t @@a2@@ , __int64 @@a3@@ ) { __m128i @@v5@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v5@@ . m128i_i64 [ Number ] = Number ; @@v5@@ . m128i_i64 [ Number ] = Number ; @@v9@@ = Number L ; @@v6@@ = Number ; @@v7@@ = Number ; sha256_process_bytes ( @@a1@@ , @@a2@@ , & @@v5@@ ) ; sha256_conclude_ctx ( ( __int64 ) & @@v5@@ ) ; return sha224_read_ctx ( ( __int64 ) & @@v5@@ , @@a3@@ ) ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_20E1F0 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20E1D0 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20E1E0 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
__ino_t * __fastcall get_root_dev_ino ( __ino_t * @@a1@@ ) { struct stat @@v2@@ ; unsigned __int64 @@v3@@ ; @@v3@@ = __readfsqword ( Number ) ; if ( __lxstat ( Number , String , & @@v2@@ ) ) return Number L ; * @@a1@@ = @@v2@@ . st_ino ; @@a1@@ [ Number ] = @@v2@@ . st_dev ; return @@a1@@ ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_20D210 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20D1F0 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_20D200 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
__int64 __fastcall cycle_check ( __int64 @@a1@@ , __int64 * @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@result@@ ; __int64 @@v5@@ ; if ( * ( _DWORD * ) ( @@a1@@ + Number ) != Number ) __assert_fail ( String , String , Number , String ) ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v3@@ = @@a2@@ [ Number ] ; if ( ! @@v2@@ ) { * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; goto LABEL_7 ; } if ( * ( _QWORD * ) @@a1@@ == @@v3@@ && * @@a2@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ) { return Number L ; } @@result@@ = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v2@@ + Number ; if ( ( ( @@v2@@ + Number ) & @@v2@@ ) == Number ) { if ( @@v2@@ == Number ) return Number L ; LABEL_7 : @@v5@@ = * @@a2@@ ; * ( _QWORD * ) @@a1@@ = @@v3@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v5@@ ; @@result@@ = Number L ; } return @@result@@ ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 __fastcall xfts_open ( const char * * @@a1@@ , int @@a2@@ , __int64 @@a3@@ ) { __int64 @@result@@ ; @@result@@ = fts_open ( @@a1@@ , @@a2@@ | Number , @@a3@@ ) ; if ( ! @@result@@ ) { if ( * __errno_location ( ) != Number ) xalloc_die ( ) ; __assert_fail ( String , String , Number , String ) ; } return @@result@@ ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
__int64 __fastcall dup_safer ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ , char @@a7@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ , @@a7@@ ) ; }
__int64 __fastcall save_cwd ( __int64 @@a1@@ , __int64 a2 , unsigned int @@a3@@ ) { int @@v3@@ ; __int64 @@result@@ ; __int64 @@v5@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; @@v3@@ = open_safer ( String , Number , @@a3@@ ) ; * ( _DWORD * ) @@a1@@ = @@v3@@ ; @@result@@ = Number L ; if ( @@v3@@ < Number ) { @@v5@@ = xgetcwd ( ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v5@@ ; @@result@@ = ( unsigned int ) - ( @@v5@@ == Number ) ; } return @@result@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
FILE * __fastcall fopen_safer ( const char * @@a1@@ , const char * @@a2@@ ) { FILE * @@v2@@ ; FILE * @@v3@@ ; unsigned int @@v4@@ ; int @@v6@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; int * @@v10@@ ; int @@v11@@ ; int * @@v12@@ ; @@v2@@ = fopen ( @@a1@@ , @@a2@@ ) ; @@v3@@ = @@v2@@ ; if ( @@v2@@ ) { @@v4@@ = fileno ( @@v2@@ ) ; if ( @@v4@@ <= Number ) { @@v6@@ = dup_safer ( @@v4@@ ) ; if ( @@v6@@ < Number ) { @@v10@@ = __errno_location ( ) ; @@v11@@ = * @@v10@@ ; @@v12@@ = @@v10@@ ; fclose ( @@v3@@ ) ; @@v3@@ = Number L ; * @@v12@@ = @@v11@@ ; } else if ( fclose ( @@v3@@ ) || ( @@v3@@ = fdopen ( @@v6@@ , @@a2@@ ) ) == Number L ) { @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; close ( @@v6@@ ) ; * @@v9@@ = @@v8@@ ; @@v3@@ = Number L ; } } } return @@v3@@ ; }
void __fastcall free_cwd ( __int64 @@a1@@ ) { int @@v2@@ ; @@v2@@ = * ( _DWORD * ) @@a1@@ ; if ( @@v2@@ >= Number ) close ( @@v2@@ ) ; free ( * ( void * * ) ( @@a1@@ + Number ) ) ; }
__int64 __fastcall rpl_fcntl ( int @@a1@@ , int @@a2@@ , __int64 @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { int @@v6@@ ; int @@v8@@ ; int @@v9@@ ; int @@v10@@ ; int @@v11@@ ; int * @@v12@@ ; int @@v13@@ ; int * @@v14@@ ; int @@v15@@ ; @@v15@@ = @@a3@@ ; if ( @@a2@@ != Number ) return ( unsigned int ) fcntl ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( have_dupfd_cloexec_3202 < Number ) { @@v6@@ = ( ( __int64 ( __fastcall * ) ( int , _DWORD , _DWORD , int , int , int , char ) ) rpl_fcntl ) ( @@a1@@ , Number , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ , Number ) ; if ( @@v6@@ < Number || have_dupfd_cloexec_3202 != Number ) return ( unsigned int ) @@v6@@ ; } else { @@v6@@ = fcntl ( @@a1@@ , Number , ( unsigned int ) @@a3@@ ) ; if ( @@v6@@ >= Number || * __errno_location ( ) != Number ) { have_dupfd_cloexec_3202 = Number ; return ( unsigned int ) @@v6@@ ; } @@v6@@ = ( ( __int64 ( __fastcall * ) ( int , _DWORD , int , int , int , int , char ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v15@@ , @@v8@@ , @@v9@@ , @@v10@@ , Number ) ; if ( @@v6@@ < Number ) return ( unsigned int ) @@v6@@ ; have_dupfd_cloexec_3202 = Number ; } @@v11@@ = fcntl ( @@v6@@ , Number ) ; if ( @@v11@@ < Number || fcntl ( @@v6@@ , Number , @@v11@@ | Number ) == Number ) { @@v12@@ = __errno_location ( ) ; @@v13@@ = * @@v12@@ ; @@v14@@ = @@v12@@ ; close ( @@v6@@ ) ; @@v6@@ = Number ; * @@v14@@ = @@v13@@ ; } return ( unsigned int ) @@v6@@ ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
int utmpxname ( const char * @@file@@ ) { return utmpxname ( @@file@@ ) ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 __fastcall sha256_init_ctx ( _QWORD * @@a1@@ ) { __int64 @@result@@ ; @@a1@@ [ Number ] = Number L ; @@a1@@ [ Number ] = Number L ; * @@a1@@ = Number ; @@a1@@ [ Number ] = Number ; @@a1@@ [ Number ] = Number ; @@result@@ = Number ; @@a1@@ [ Number ] = Number ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall sha224_finish_ctx ( __int64 @@a1@@ , __int64 @@a2@@ ) { sha256_conclude_ctx ( @@a1@@ ) ; return sha224_read_ctx ( @@a1@@ , @@a2@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
__int64 __fastcall sha256_read_ctx ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; __int64 @@i@@ ; @@result@@ = @@a2@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; @@i@@ += Number L ) * ( _DWORD * ) ( @@a2@@ + @@i@@ ) = _byteswap_ulong ( * ( _DWORD * ) ( @@a1@@ + @@i@@ ) ) ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
void freeaddrinfo ( struct addrinfo * @@ai@@ ) { freeaddrinfo ( @@ai@@ ) ; }
__int64 __fastcall sha256_finish_ctx ( __int64 @@a1@@ , __int64 @@a2@@ ) { sha256_conclude_ctx ( @@a1@@ ) ; return sha256_read_ctx ( @@a1@@ , @@a2@@ ) ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
__int64 __fastcall sha224_stream ( FILE * @@stream@@ , __int64 @@a2@@ ) { char * @@v2@@ ; __int64 @@result@@ ; size_t @@v4@@ ; int @@v5@@ ; size_t @@v6@@ ; __m128i @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; unsigned __int64 @@v12@@ ; @@v12@@ = __readfsqword ( Number ) ; @@v2@@ = ( char * ) malloc ( Number ) ; @@result@@ = Number L ; if ( @@v2@@ ) { @@v10@@ = Number L ; @@v11@@ = Number L ; @@v7@@ . m128i_i64 [ Number ] = Number ; @@v7@@ . m128i_i64 [ Number ] = Number ; @@v8@@ = Number ; @@v9@@ = Number ; LABEL_3 : @@v4@@ = Number L ; while ( Number ) { @@v6@@ = fread_unlocked ( & @@v2@@ [ @@v4@@ ] , Number , Number - @@v4@@ , @@stream@@ ) ; @@v4@@ += @@v6@@ ; if ( @@v4@@ == Number ) { sha256_process_block ( ( unsigned __int64 ) @@v2@@ , Number , & @@v7@@ ) ; goto LABEL_3 ; } @@v5@@ = @@stream@@ -> _flags ; if ( ! @@v6@@ ) break ; if ( ( @@v5@@ & Number ) != Number ) goto LABEL_9 ; } if ( ( @@v5@@ & Number ) != Number ) { free ( @@v2@@ ) ; return Number L ; } LABEL_9 : if ( @@v4@@ ) sha256_process_bytes ( @@v2@@ , @@v4@@ , & @@v7@@ ) ; sha256_conclude_ctx ( ( __int64 ) & @@v7@@ ) ; sha224_read_ctx ( ( __int64 ) & @@v7@@ , @@a2@@ ) ; free ( @@v2@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
char * __fastcall make_id_equals_comment ( __int64 @@a1@@ ) { char * @@v1@@ ; size_t @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; char * @@v7@@ ; @@v1@@ = dcgettext ( Number L , String , Number ) ; @@v2@@ = strlen ( @@v1@@ ) ; @@v6@@ = ( char * ) xmalloc ( @@v2@@ + Number , String , @@v3@@ , @@v4@@ , @@v5@@ ) ; @@v7@@ = dcgettext ( Number L , String , Number ) ; strcpy ( @@v6@@ , @@v7@@ ) ; return strncat ( @@v6@@ , ( const char * ) ( @@a1@@ + Number ) , Number ) ; }
char * __fastcall parse_user_spec ( char * @@s@@ , __uid_t * @@a2@@ , __gid_t * @@a3@@ , char * * @@a4@@ , char * * @@a5@@ ) { char * @@v8@@ ; char * @@v9@@ ; char * @@v10@@ ; char * @@v11@@ ; @@v8@@ = strchr ( @@s@@ , Number ) ; @@v9@@ = parse_with_separator ( @@s@@ , @@v8@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; @@v10@@ = @@v9@@ ; if ( ! @@v8@@ ) { if ( @@v9@@ ) { @@v11@@ = strchr ( @@s@@ , Number ) ; if ( @@v11@@ ) { if ( ! parse_with_separator ( @@s@@ , @@v11@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ) @@v10@@ = Number L ; } } } return @@v10@@ ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 __fastcall sha256_stream ( FILE * @@stream@@ , __int64 @@a2@@ ) { char * @@v2@@ ; __int64 @@result@@ ; size_t @@v4@@ ; int @@v5@@ ; size_t @@v6@@ ; __m128i @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; unsigned __int64 @@v12@@ ; @@v12@@ = __readfsqword ( Number ) ; @@v2@@ = ( char * ) malloc ( Number ) ; @@result@@ = Number L ; if ( @@v2@@ ) { @@v10@@ = Number L ; @@v11@@ = Number L ; @@v7@@ . m128i_i64 [ Number ] = Number ; @@v7@@ . m128i_i64 [ Number ] = Number ; @@v8@@ = Number ; @@v9@@ = Number ; LABEL_3 : @@v4@@ = Number L ; while ( Number ) { @@v6@@ = fread_unlocked ( & @@v2@@ [ @@v4@@ ] , Number , Number - @@v4@@ , @@stream@@ ) ; @@v4@@ += @@v6@@ ; if ( @@v4@@ == Number ) { sha256_process_block ( ( unsigned __int64 ) @@v2@@ , Number , & @@v7@@ ) ; goto LABEL_3 ; } @@v5@@ = @@stream@@ -> _flags ; if ( ! @@v6@@ ) break ; if ( ( @@v5@@ & Number ) != Number ) goto LABEL_9 ; } if ( ( @@v5@@ & Number ) != Number ) { free ( @@v2@@ ) ; return Number L ; } LABEL_9 : if ( @@v4@@ ) sha256_process_bytes ( @@v2@@ , @@v4@@ , & @@v7@@ ) ; sha256_conclude_ctx ( ( __int64 ) & @@v7@@ ) ; sha256_read_ctx ( ( __int64 ) & @@v7@@ , @@a2@@ ) ; free ( @@v2@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_2061F0 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061D0 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_2061E0 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
int uname ( struct utsname * @@name@@ ) { return uname ( @@name@@ ) ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
__int64 __fastcall imaxtostr ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; __int64 @@result@@ ; int @@v4@@ ; bool @@v5@@ ; @@v2@@ = @@a2@@ + Number ; * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; if ( @@a1@@ < Number ) { while ( Number ) { @@v4@@ = Number * ( @@a1@@ / Number ) + Number - @@a1@@ ; @@v5@@ = ( __int64 ) ( ( unsigned __int128 ) ( Number * ( __int128 ) @@a1@@ ) >> Number ) >> Number == @@a1@@ >> Number ; @@a1@@ /= Number L ; * ( _BYTE * ) ( @@v2@@ - Number ) = @@v4@@ ; if ( @@v5@@ ) break ; -- @@v2@@ ; } * ( _BYTE * ) ( @@v2@@ - Number ) = Number ; @@result@@ = @@v2@@ - Number ; } else { do { * ( _BYTE * ) -- @@v2@@ = @@a1@@ % Number + Number ; @@a1@@ /= Number ; } while ( @@a1@@ ) ; @@result@@ = @@v2@@ ; } return @@result@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
int __fxstatat ( int @@ver@@ , int @@fildes@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ , int @@flag@@ ) { return _fxstatat ( @@ver@@ , @@fildes@@ , @@filename@@ , @@stat_buf@@ , @@flag@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
int __fastcall print_element ( char * @@s@@ ) { char * @@v1@@ ; if ( printed_7039 ) { @@v1@@ = stdout -> _IO_write_ptr ; if ( @@v1@@ >= stdout -> _IO_write_end ) { __overflow ( stdout , Number ) ; } else { stdout -> _IO_write_ptr = @@v1@@ + Number ; * @@v1@@ = Number ; } } printed_7039 = Number ; return fputs_unlocked ( @@s@@ , stdout ) ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_20B2B0 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20B290 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20B2A0 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; FILE * @@v11@@ ; char * @@v12@@ ; FILE * @@v13@@ ; char * @@v14@@ ; FILE * @@v15@@ ; char * @@v16@@ ; FILE * @@v17@@ ; char * @@v18@@ ; char * @@v19@@ ; FILE * @@v20@@ ; char * @@v21@@ ; char * @@v22@@ ; char * @@v23@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String String String String String String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String String String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = stdout ; @@v10@@ = dcgettext ( Number L , String String String String String String , Number ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; @@v11@@ = stdout ; @@v12@@ = dcgettext ( Number L , String String String String String String String String String String , Number ) ; fputs_unlocked ( @@v12@@ , @@v11@@ ) ; @@v13@@ = stdout ; @@v14@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v14@@ , @@v13@@ ) ; @@v15@@ = stdout ; @@v16@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v16@@ , @@v15@@ ) ; @@v17@@ = stdout ; @@v18@@ = dcgettext ( Number L , String String String String , Number ) ; fputs_unlocked ( @@v18@@ , @@v17@@ ) ; @@v19@@ = dcgettext ( Number L , String String String String String , Number ) ; __printf_chk ( ) ; last_component ( program_name , @@v19@@ ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v20@@ = stdout ; @@v21@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v21@@ , @@v20@@ ) ; @@v22@@ = Number L ; @@v23@@ = setlocale ( Number , Number L ) ; if ( @@v23@@ ) { @@v22@@ = String ; if ( strncmp ( @@v23@@ , String , Number ) ) { last_component ( program_name , String ) ; @@v22@@ = dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name , @@v22@@ ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
void __fastcall cwd_advance_fd ( __int64 @@a1@@ , int @@a2@@ , char @@a3@@ ) { int @@v4@@ ; int @@v5@@ ; @@v4@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; if ( @@v4@@ == @@a2@@ && @@v4@@ != Number ) abort ( ) ; if ( @@a3@@ ) { @@v5@@ = i_ring_push ( @@a1@@ + Number ) ; if ( @@v5@@ < Number ) { LABEL_6 : * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; return ; } close ( @@v5@@ ) ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; } else { if ( ( * ( _BYTE * ) ( @@a1@@ + Number ) & Number ) != Number || @@v4@@ < Number ) goto LABEL_6 ; close ( @@v4@@ ) ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; } }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_2061F0 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061D0 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061E0 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
bool __fastcall setup_dir_isra_4 ( __int16 @@a1@@ , __int64 * @@a2@@ ) { __int64 @@v2@@ ; bool @@result@@ ; void * @@v4@@ ; if ( ( @@a1@@ & Number ) != Number ) { @@v2@@ = hash_initialize ( Number L , Number L , AD_hash , AD_compare , & free ) ; * @@a2@@ = @@v2@@ ; @@result@@ = @@v2@@ != Number ; } else { @@v4@@ = malloc ( Number ) ; * @@a2@@ = ( __int64 ) @@v4@@ ; @@result@@ = Number ; if ( @@v4@@ ) { cycle_check_init ( ) ; @@result@@ = Number ; } } return @@result@@ ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall fts_set ( __int64 a1 , __int64 @@a2@@ , unsigned int @@a3@@ ) { __int64 @@result@@ ; if ( @@a3@@ > Number ) { * __errno_location ( ) = Number ; @@result@@ = Number L ; } else { * ( _WORD * ) ( @@a2@@ + Number ) = @@a3@@ ; @@result@@ = Number L ; } return @@result@@ ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; FILE * @@v11@@ ; char * @@v12@@ ; char * @@v13@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String String String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String String String String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = stdout ; @@v10@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v11@@ = stdout ; @@v12@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v12@@ , @@v11@@ ) ; @@v13@@ = setlocale ( Number , Number L ) ; if ( @@v13@@ ) { if ( strncmp ( @@v13@@ , String , Number ) ) { last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_2081F0 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2081D0 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_2081E0 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
unsigned __int64 __fastcall raw_hasher ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return __ROR8__ ( @@a1@@ , Number ) % @@a2@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
struct passwd * getpwuid ( __uid_t @@uid@@ ) { return getpwuid ( @@uid@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
int dirfd ( DIR * @@dirp@@ ) { return dirfd ( @@dirp@@ ) ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
__int64 __fastcall hash_find_entry ( __int64 * @@a1@@ , __int64 @@a2@@ , __m128i * * @@a3@@ , char @@a4@@ ) { __int64 @@v5@@ ; __m128i * @@v8@@ ; __int64 @@v9@@ ; __int64 * @@v10@@ ; const __m128i * @@v12@@ ; @@v5@@ = * @@a1@@ ; @@v8@@ = ( __m128i * ) ( Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) + @@v5@@ ) ; if ( @@a1@@ [ Number ] <= ( unsigned __int64 ) @@v8@@ ) abort ( ) ; * @@a3@@ = @@v8@@ ; @@v9@@ = @@v8@@ -> m128i_i64 [ Number ] ; if ( @@v8@@ -> m128i_i64 [ Number ] ) { if ( @@v9@@ != @@a2@@ ) { if ( ! ( ( unsigned __int8 ( __fastcall * ) ( __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ ) ) { @@v10@@ = ( __int64 * ) @@v8@@ -> m128i_i64 [ Number ] ; if ( @@v10@@ ) { @@v9@@ = * @@v10@@ ; if ( @@a2@@ != * @@v10@@ ) { while ( ! ( ( unsigned __int8 ( __fastcall * ) ( __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ ) ) { @@v8@@ = ( __m128i * ) @@v8@@ -> m128i_i64 [ Number ] ; @@v10@@ = ( __int64 * ) @@v8@@ -> m128i_i64 [ Number ] ; if ( ! @@v10@@ ) return Number L ; @@v9@@ = * @@v10@@ ; if ( * @@v10@@ == @@a2@@ ) goto LABEL_12 ; } @@v10@@ = ( __int64 * ) @@v8@@ -> m128i_i64 [ Number ] ; @@v9@@ = * @@v10@@ ; } LABEL_12 : if ( @@a4@@ ) { @@v8@@ -> m128i_i64 [ Number ] = @@v10@@ [ Number ] ; * @@v10@@ = Number L ; @@v10@@ [ Number ] = @@a1@@ [ Number ] ; @@a1@@ [ Number ] = ( __int64 ) @@v10@@ ; } return @@v9@@ ; } return Number L ; } @@v9@@ = @@v8@@ -> m128i_i64 [ Number ] ; } if ( @@a4@@ ) { @@v12@@ = ( const __m128i * ) @@v8@@ -> m128i_i64 [ Number ] ; if ( @@v12@@ ) { * @@v8@@ = _mm_loadu_si128 ( @@v12@@ ) ; @@v12@@ -> m128i_i64 [ Number ] = Number L ; @@v12@@ -> m128i_i64 [ Number ] = @@a1@@ [ Number ] ; @@a1@@ [ Number ] = ( __int64 ) @@v12@@ ; return @@v9@@ ; } @@v8@@ -> m128i_i64 [ Number ] = Number L ; } return @@v9@@ ; } return Number L ; }
unsigned __int64 __fastcall randint_genmax ( __int64 * @@a1@@ , unsigned __int64 @@a2@@ ) { unsigned __int64 @@v2@@ ; unsigned __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; __int64 @@v6@@ ; char * @@v7@@ ; __int64 @@v8@@ ; __int64 @@v10@@ ; char @@v11@@ [ Number ] ; unsigned __int64 @@v12@@ ; @@v2@@ = @@a2@@ + Number ; @@v3@@ = @@a1@@ [ Number ] ; @@v4@@ = @@a1@@ [ Number ] ; @@v12@@ = __readfsqword ( Number ) ; @@v10@@ = * @@a1@@ ; while ( Number ) { if ( @@v4@@ >= @@a2@@ ) { if ( @@v4@@ == @@a2@@ ) goto LABEL_11 ; } else { @@v5@@ = @@v4@@ ; @@v6@@ = Number L ; do { ++ @@v6@@ ; @@v5@@ = ( @@v5@@ << Number ) + Number ; } while ( @@a2@@ > @@v5@@ ) ; randread ( @@v10@@ , @@v11@@ , @@v6@@ ) ; @@v7@@ = @@v11@@ ; do { @@v8@@ = ( unsigned __int8 ) * @@v7@@ ; @@v4@@ = ( @@v4@@ << Number ) + Number ; ++ @@v7@@ ; @@v3@@ = @@v8@@ + ( @@v3@@ << Number ) ; } while ( @@a2@@ > @@v4@@ ) ; if ( @@v4@@ == @@a2@@ ) { LABEL_11 : @@a1@@ [ Number ] = Number L ; @@a1@@ [ Number ] = Number L ; return @@v3@@ ; } } if ( @@v3@@ <= @@v4@@ - ( @@v4@@ - @@a2@@ ) % @@v2@@ ) break ; @@v4@@ = ( @@v4@@ - @@a2@@ ) % @@v2@@ - Number ; @@v3@@ %= @@v2@@ ; } @@a1@@ [ Number ] = @@v3@@ / @@v2@@ ; @@a1@@ [ Number ] = ( @@v4@@ - @@a2@@ ) / @@v2@@ ; @@v3@@ %= @@v2@@ ; return @@v3@@ ; }
struct dirent * readdir ( DIR * @@dirp@@ ) { return readdir ( @@dirp@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
DIR * fdopendir ( int @@fd@@ ) { return fdopendir ( @@fd@@ ) ; }
__int64 __fastcall hash_reset_tuning ( __int64 @@a1@@ ) { __int64 @@result@@ ; * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; * ( _QWORD * ) @@a1@@ = Number ; @@result@@ = Number ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number ; return @@result@@ ; }
__syscall_slong_t gethrxtime ( ) { struct timespec @@v1@@ ; unsigned __int64 @@v2@@ ; @@v2@@ = __readfsqword ( Number ) ; if ( clock_gettime ( Number , & @@v1@@ ) ) gettime ( & @@v1@@ ) ; return @@v1@@ . tv_nsec + Number * @@v1@@ . tv_sec ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
void free ( void * @@ptr@@ ) { __imp_free ( @@ptr@@ ) ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
__int64 __fastcall gid_to_name ( __gid_t @@a1@@ ) { struct group * @@v1@@ ; char * @@v2@@ ; _QWORD @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v1@@ = getgrgid ( @@a1@@ ) ; if ( @@v1@@ ) @@v2@@ = @@v1@@ -> gr_name ; else @@v2@@ = ( char * ) umaxtostr ( @@a1@@ , @@v4@@ ) ; return xstrdup ( @@v2@@ ) ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
__int64 __fastcall rpl_fcntl ( int @@a1@@ , int @@a2@@ , __int64 @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { int @@v6@@ ; int @@v8@@ ; int @@v9@@ ; int @@v10@@ ; int @@v11@@ ; int * @@v12@@ ; int @@v13@@ ; int * @@v14@@ ; int @@v15@@ ; @@v15@@ = @@a3@@ ; if ( @@a2@@ != Number ) return ( unsigned int ) fcntl ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( have_dupfd_cloexec_3202 < Number ) { @@v6@@ = ( ( __int64 ( __fastcall * ) ( int , _DWORD , _DWORD , int , int , int , char ) ) rpl_fcntl ) ( @@a1@@ , Number , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ , Number ) ; if ( @@v6@@ < Number || have_dupfd_cloexec_3202 != Number ) return ( unsigned int ) @@v6@@ ; } else { @@v6@@ = fcntl ( @@a1@@ , Number , ( unsigned int ) @@a3@@ ) ; if ( @@v6@@ >= Number || * __errno_location ( ) != Number ) { have_dupfd_cloexec_3202 = Number ; return ( unsigned int ) @@v6@@ ; } @@v6@@ = ( ( __int64 ( __fastcall * ) ( int , _DWORD , int , int , int , int , char ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v15@@ , @@v8@@ , @@v9@@ , @@v10@@ , Number ) ; if ( @@v6@@ < Number ) return ( unsigned int ) @@v6@@ ; have_dupfd_cloexec_3202 = Number ; } @@v11@@ = fcntl ( @@v6@@ , Number ) ; if ( @@v11@@ < Number || fcntl ( @@v6@@ , Number , @@v11@@ | Number ) == Number ) { @@v12@@ = __errno_location ( ) ; @@v13@@ = * @@v12@@ ; @@v14@@ = @@v12@@ ; close ( @@v6@@ ) ; @@v6@@ = Number ; * @@v14@@ = @@v13@@ ; } return ( unsigned int ) @@v6@@ ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
_QWORD * __fastcall hash_initialize ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 ( __fastcall * @@a3@@ ) ( __int64 a1 , unsigned __int64 a2 ) , bool ( __fastcall * @@a4@@ ) ( __int64 a1 , __int64 a2 ) , __int64 @@a5@@ ) { unsigned __int64 ( __fastcall * @@v5@@ ) ( __int64 , unsigned __int64 ) ; bool ( __fastcall * @@v6@@ ) ( __int64 , __int64 ) ; char * @@v9@@ ; _QWORD * @@v10@@ ; float * * @@v11@@ ; float @@v12@@ ; float @@v13@@ ; float @@v14@@ ; unsigned __int64 @@v15@@ ; char * @@v16@@ ; void * @@v17@@ ; @@v5@@ = @@a3@@ ; @@v6@@ = @@a4@@ ; if ( ! @@a3@@ ) @@v5@@ = raw_hasher ; if ( ! @@a4@@ ) @@v6@@ = raw_comparator ; @@v9@@ = ( char * ) malloc ( Number ) ; @@v10@@ = @@v9@@ ; if ( @@v9@@ ) { @@v11@@ = ( float * * ) ( @@v9@@ + Number ) ; if ( @@a2@@ ) { * ( ( _QWORD * ) @@v9@@ + Number ) = @@a2@@ ; if ( ! ( unsigned __int8 ) check_tuning_isra_0 ( @@v11@@ ) ) goto LABEL_20 ; if ( * ( _BYTE * ) ( @@a2@@ + Number ) ) { LABEL_15 : @@v15@@ = next_prime ( @@a1@@ ) ; if ( @@v15@@ <= Number ) { @@v10@@ [ Number ] = @@v15@@ ; if ( @@v15@@ ) { @@v16@@ = ( char * ) calloc ( @@v15@@ , Number ) ; * @@v10@@ = @@v16@@ ; if ( @@v16@@ ) { @@v10@@ [ Number ] = Number L ; @@v10@@ [ Number ] = Number L ; @@v10@@ [ Number ] = @@v5@@ ; @@v10@@ [ Number ] = @@v6@@ ; @@v10@@ [ Number ] = & @@v16@@ [ Number * @@v15@@ ] ; @@v10@@ [ Number ] = @@a5@@ ; @@v10@@ [ Number ] = Number L ; return @@v10@@ ; } } } LABEL_20 : @@v17@@ = @@v10@@ ; @@v10@@ = Number L ; free ( @@v17@@ ) ; return @@v10@@ ; } @@v12@@ = * ( float * ) ( @@a2@@ + Number ) ; } else { * ( ( _QWORD * ) @@v9@@ + Number ) = & default_tuning ; @@v12@@ = Number ; if ( ! ( unsigned __int8 ) check_tuning_isra_0 ( @@v11@@ ) ) goto LABEL_20 ; } if ( @@a1@@ < Number ) @@v13@@ = ( float ) ( @@a1@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@a1@@ >> Number ) ) + ( float ) ( @@a1@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@a1@@ >> Number ) ) ; else @@v13@@ = ( float ) ( int ) @@a1@@ ; @@v14@@ = @@v13@@ / @@v12@@ ; if ( @@v14@@ >= Number ) goto LABEL_20 ; if ( @@v14@@ < Number ) @@a1@@ = ( unsigned int ) ( int ) @@v14@@ ; else @@a1@@ = ( unsigned int ) ( int ) ( float ) ( @@v14@@ - Number ) ^ Number ; goto LABEL_15 ; } return @@v10@@ ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
__int64 screen_columns ( ) { __int64 @@result@@ ; char * @@v1@@ ; __int64 @@v2@@ ; char @@v3@@ [ Number ] ; unsigned __int16 @@v4@@ ; unsigned __int64 @@v5@@ ; @@v5@@ = __readfsqword ( Number ) ; if ( ioctl ( Number , Number , @@v3@@ ) || ( @@result@@ = @@v4@@ ) == Number ) { @@v1@@ = getenv ( String ) ; if ( ! @@v1@@ || ( unsigned int ) xstrtol ( @@v1@@ ) || ( @@result@@ = @@v2@@ , ( unsigned __int64 ) ( @@v2@@ - Number ) > Number ) ) { @@result@@ = Number L ; } } return @@result@@ ; }
int __xstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _xstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_207250 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_207230 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_207240 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
int fchdir ( int @@fd@@ ) { return fchdir ( @@fd@@ ) ; }
unsigned __int64 __fastcall AD_hash ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) % @@a2@@ ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
bool __fastcall LCO_compare ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { return * @@a1@@ == * @@a2@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
__int64 __fastcall uid_to_name ( __uid_t @@a1@@ ) { struct passwd * @@v1@@ ; char * @@v2@@ ; _QWORD @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v1@@ = getpwuid ( @@a1@@ ) ; if ( @@v1@@ ) @@v2@@ = @@v1@@ -> pw_name ; else @@v2@@ = ( char * ) umaxtostr ( @@a1@@ , @@v4@@ ) ; return xstrdup ( @@v2@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
__int64 __fastcall fts_sort ( _QWORD * @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { __int64 @@v5@@ ; bool @@v6@@ ; int ( * @@v7@@ ) ( const void * , const void * ) ; void * @@v8@@ ; void * @@v9@@ ; _QWORD * @@v10@@ ; __int64 * @@v11@@ ; size_t @@v12@@ ; __int64 @@result@@ ; __int64 @@v14@@ ; __int64 * @@i@@ ; __int64 @@v16@@ ; __int64 @@v17@@ ; @@v5@@ = @@a2@@ ; @@v6@@ = @@a1@@ [ Number ] < @@a3@@ ; @@v7@@ = ( int ( * ) ( const void * , const void * ) ) @@a1@@ [ Number ] ; @@v8@@ = ( void * ) @@a1@@ [ Number ] ; if ( ! @@v6@@ ) goto LABEL_5 ; @@a1@@ [ Number ] = @@a3@@ + Number ; if ( @@a3@@ + Number > Number ) { LABEL_15 : free ( @@v8@@ ) ; @@a1@@ [ Number ] = Number L ; @@a1@@ [ Number ] = Number L ; return @@a2@@ ; } @@v9@@ = realloc ( @@v8@@ , Number * ( @@a3@@ + Number ) ) ; @@v8@@ = @@v9@@ ; if ( ! @@v9@@ ) { @@v8@@ = ( void * ) @@a1@@ [ Number ] ; goto LABEL_15 ; } @@a1@@ [ Number ] = @@v9@@ ; LABEL_5 : if ( @@a2@@ ) { @@v10@@ = @@v8@@ ; do { * @@v10@@ ++ = @@v5@@ ; @@v5@@ = * ( _QWORD * ) ( @@v5@@ + Number ) ; } while ( @@v5@@ ) ; } qsort ( @@v8@@ , @@a3@@ , Number , @@v7@@ ) ; @@v11@@ = ( __int64 * ) @@a1@@ [ Number ] ; @@v12@@ = @@a3@@ - Number ; @@result@@ = * @@v11@@ ; if ( @@a3@@ == Number ) { @@v17@@ = * @@v11@@ ; } else { @@v14@@ = * @@v11@@ ; for ( @@i@@ = ( __int64 * ) @@a1@@ [ Number ] ; ; @@v14@@ = * @@i@@ ) { @@v16@@ = @@i@@ [ Number ] ; ++ @@i@@ ; -- @@v12@@ ; * ( _QWORD * ) ( @@v14@@ + Number ) = @@v16@@ ; if ( ! @@v12@@ ) break ; } @@v17@@ = @@v11@@ [ @@a3@@ - Number ] ; } * ( _QWORD * ) ( @@v17@@ + Number ) = Number L ; return @@result@@ ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall xfts_open ( const char * * @@a1@@ , int @@a2@@ , __int64 @@a3@@ ) { __int64 @@result@@ ; @@result@@ = fts_open ( @@a1@@ , @@a2@@ | Number , @@a3@@ ) ; if ( ! @@result@@ ) { if ( * __errno_location ( ) != Number ) xalloc_die ( ) ; __assert_fail ( String , String , Number , String ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
unsigned __int64 __fastcall next_prime ( unsigned __int64 @@a1@@ ) { unsigned __int64 @@v1@@ ; unsigned __int64 @@v2@@ ; __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; if ( @@a1@@ < Number ) @@a1@@ = Number L ; @@v1@@ = @@a1@@ | Number ; if ( @@v1@@ != Number ) { while ( Number ) { @@v2@@ = @@v1@@ % Number ; if ( @@v1@@ <= Number ) goto LABEL_9 ; if ( @@v1@@ % Number ) break ; LABEL_10 : @@v1@@ += Number L ; if ( @@v1@@ == Number ) return @@v1@@ ; } @@v3@@ = Number L ; @@v4@@ = Number L ; @@v5@@ = Number L ; while ( Number ) { @@v5@@ += Number L ; @@v4@@ += @@v3@@ ; @@v2@@ = @@v1@@ % @@v5@@ ; if ( @@v4@@ >= @@v1@@ ) break ; @@v3@@ += Number L ; if ( ! ( @@v1@@ % @@v5@@ ) ) goto LABEL_10 ; } LABEL_9 : if ( @@v2@@ ) return @@v1@@ ; goto LABEL_10 ; } return @@v1@@ ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
void __fastcall cycle_check_init ( __int64 @@a1@@ ) { * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _DWORD * ) ( @@a1@@ + Number ) = Number ; }
__int64 __fastcall hash_get_n_buckets ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int64 __fastcall rpl_vasprintf ( _QWORD * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { void * @@v3@@ ; unsigned int @@v4@@ ; __int64 @@result@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; @@v3@@ = ( void * ) vasnprintf ( Number L , @@v6@@ , @@a2@@ , @@a3@@ ) ; if ( ! @@v3@@ ) return Number ; @@v4@@ = @@v6@@ [ Number ] ; if ( @@v6@@ [ Number ] > Number ) { free ( @@v3@@ ) ; * __errno_location ( ) = Number ; @@result@@ = Number ; } else { * @@a1@@ = @@v3@@ ; @@result@@ = @@v4@@ ; } return @@result@@ ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
__int64 __fastcall hash_get_n_buckets_used ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
__int64 __fastcall rpl_fcntl ( int @@a1@@ , int @@a2@@ , __int64 @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { int @@v6@@ ; int @@v8@@ ; int @@v9@@ ; int @@v10@@ ; int @@v11@@ ; int * @@v12@@ ; int @@v13@@ ; int * @@v14@@ ; int @@v15@@ ; @@v15@@ = @@a3@@ ; if ( @@a2@@ != Number ) return ( unsigned int ) fcntl ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( have_dupfd_cloexec_3202 < Number ) { @@v6@@ = rpl_fcntl ( @@a1@@ , Number , ( unsigned int ) @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( @@v6@@ < Number || have_dupfd_cloexec_3202 != Number ) return ( unsigned int ) @@v6@@ ; } else { @@v6@@ = fcntl ( @@a1@@ , Number , ( unsigned int ) @@a3@@ ) ; if ( @@v6@@ >= Number || * __errno_location ( ) != Number ) { have_dupfd_cloexec_3202 = Number ; return ( unsigned int ) @@v6@@ ; } @@v6@@ = rpl_fcntl ( @@a1@@ , Number , @@v15@@ , @@v8@@ , @@v9@@ , @@v10@@ ) ; if ( @@v6@@ < Number ) return ( unsigned int ) @@v6@@ ; have_dupfd_cloexec_3202 = Number ; } @@v11@@ = fcntl ( @@v6@@ , Number ) ; if ( @@v11@@ < Number || fcntl ( @@v6@@ , Number , @@v11@@ | Number ) == Number ) { @@v12@@ = __errno_location ( ) ; @@v13@@ = * @@v12@@ ; @@v14@@ = @@v12@@ ; close ( @@v6@@ ) ; @@v6@@ = Number ; * @@v14@@ = @@v13@@ ; } return ( unsigned int ) @@v6@@ ; }
bool __fastcall AD_compare ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@result@@ ; @@result@@ = Number ; if ( @@a1@@ [ Number ] == @@a2@@ [ Number ] ) @@result@@ = * @@a1@@ == * @@a2@@ ; return @@result@@ ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
unsigned __int64 __fastcall hash_get_max_bucket_length ( __int64 @@a1@@ ) { _QWORD * @@v1@@ ; unsigned __int64 @@v2@@ ; unsigned __int64 @@result@@ ; __int64 @@v4@@ ; unsigned __int64 @@i@@ ; @@v1@@ = * ( _QWORD * * ) @@a1@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; for ( @@result@@ = Number L ; ( unsigned __int64 ) @@v1@@ < @@v2@@ ; @@v1@@ += Number ) { if ( * @@v1@@ ) { @@v4@@ = @@v1@@ [ Number ] ; for ( @@i@@ = Number L ; @@v4@@ ; ++ @@i@@ ) @@v4@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; if ( @@result@@ < @@i@@ ) @@result@@ = @@i@@ ; } } return @@result@@ ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
__int64 __fastcall hash_get_first ( __int64 @@a1@@ ) { __int64 * @@v1@@ ; unsigned __int64 @@v2@@ ; __int64 @@result@@ ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; @@v1@@ = * ( __int64 * * ) @@a1@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( * ( _QWORD * ) @@a1@@ >= @@v2@@ ) goto LABEL_9 ; @@result@@ = * @@v1@@ ; if ( ! * @@v1@@ ) { while ( Number ) { @@v1@@ += Number ; if ( ( unsigned __int64 ) @@v1@@ >= @@v2@@ ) break ; @@result@@ = * @@v1@@ ; if ( * @@v1@@ ) return @@result@@ ; } LABEL_9 : abort ( ) ; } return @@result@@ ; }
__int64 __fastcall fts_stat ( __int64 @@a1@@ , __int64 @@a2@@ , char @@a3@@ ) { struct stat * @@v4@@ ; bool @@v5@@ ; int @@v6@@ ; const char * @@v7@@ ; int * @@v8@@ ; int @@v9@@ ; int * @@v10@@ ; __int64 @@result@@ ; int @@v12@@ ; __int64 @@v13@@ ; @@v4@@ = ( struct stat * ) ( @@a2@@ + Number ) ; @@v5@@ = * ( _QWORD * ) ( @@a2@@ + Number ) == Number L ; @@v6@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; @@v7@@ = * ( const char * * ) ( @@a2@@ + Number ) ; if ( @@v5@@ && ( @@v6@@ & Number ) != Number || ( @@v6@@ & Number ) != Number || @@a3@@ ) { if ( ! __xstat ( Number , @@v7@@ , @@v4@@ ) ) goto LABEL_11 ; @@v8@@ = __errno_location ( ) ; @@v9@@ = * @@v8@@ ; @@v10@@ = @@v8@@ ; if ( * @@v8@@ == Number && ! __lxstat ( Number , * ( const char * * ) ( @@a2@@ + Number ) , @@v4@@ ) ) { * @@v10@@ = Number ; return Number L ; } * ( _DWORD * ) ( @@a2@@ + Number ) = @@v9@@ ; LABEL_6 : * ( _QWORD * ) ( @@a2@@ + Number ) = Number L ; @@v4@@ -> __unused [ Number ] = Number L ; memset ( ( void * ) ( ( unsigned __int64 ) & @@v4@@ -> st_ino & Number ) , Number , Number L * ( ( ( unsigned int ) @@v4@@ - ( ( ( _DWORD ) @@v4@@ + Number ) & Number ) + Number ) >> Number ) ) ; return Number L ; } if ( __fxstatat ( Number , * ( _DWORD * ) ( @@a1@@ + Number ) , @@v7@@ , @@v4@@ , Number ) ) { * ( _DWORD * ) ( @@a2@@ + Number ) = * __errno_location ( ) ; goto LABEL_6 ; } LABEL_11 : @@v12@@ = * ( _DWORD * ) ( @@a2@@ + Number ) & Number ; if ( @@v12@@ == Number ) { @@v13@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( ( * ( _BYTE * ) ( @@a1@@ + Number ) & Number ) == Number ) @@v13@@ -= Number L ; @@v5@@ = * ( _BYTE * ) ( @@a2@@ + Number ) == Number ; * ( _QWORD * ) ( @@a2@@ + Number ) = @@v13@@ ; @@result@@ = Number L ; if ( @@v5@@ && ( ! * ( _BYTE * ) ( @@a2@@ + Number ) || ( * ( _DWORD * ) ( @@a2@@ + Number ) & Number ) == Number ) ) { @@result@@ = * ( _QWORD * ) ( @@a2@@ + Number ) == Number L ? Number : Number ; } } else if ( @@v12@@ == Number ) { @@result@@ = Number L ; } else { @@result@@ = Number * ( unsigned int ) ( @@v12@@ == Number ) + Number ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
unsigned __int64 __fastcall hash_string ( unsigned __int8 * @@a1@@ , unsigned __int64 @@a2@@ ) { __int64 @@v2@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@v4@@ ; @@v2@@ = * @@a1@@ ; for ( @@i@@ = Number L ; ( _BYTE ) @@v2@@ ; @@i@@ = @@v4@@ % @@a2@@ ) { ++ @@a1@@ ; @@v4@@ = @@v2@@ + Number * @@i@@ ; @@v2@@ = * @@a1@@ ; } return @@i@@ ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
__int64 __fastcall hash_print_statistics ( __int64 @@a1@@ ) { unsigned __int64 @@v1@@ ; _QWORD * @@v2@@ ; unsigned __int64 @@i@@ ; __int64 @@v4@@ ; unsigned __int64 @@j@@ ; @@v1@@ = Number L ; @@v2@@ = * ( _QWORD * * ) @@a1@@ ; for ( @@i@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; ( unsigned __int64 ) @@v2@@ < @@i@@ ; @@v2@@ += Number ) { if ( * @@v2@@ ) { @@v4@@ = @@v2@@ [ Number ] ; for ( @@j@@ = Number L ; @@v4@@ ; ++ @@j@@ ) @@v4@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; if ( @@v1@@ < @@j@@ ) @@v1@@ = @@j@@ ; } } __fprintf_chk ( ) ; __fprintf_chk ( ) ; __fprintf_chk ( ) ; return __fprintf_chk ( ) ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_20A210 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20A1F0 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20A200 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
void __fastcall hash_clear ( _QWORD * @@a1@@ ) { _QWORD * @@v1@@ ; _QWORD * @@v2@@ ; void ( __fastcall * @@v3@@ ) ( _QWORD ) ; _QWORD * @@v4@@ ; __int64 @@v5@@ ; @@v1@@ = ( _QWORD * ) * @@a1@@ ; if ( * @@a1@@ < @@a1@@ [ Number ] ) { do { if ( * @@v1@@ ) { @@v2@@ = ( _QWORD * ) @@v1@@ [ Number ] ; @@v3@@ = ( void ( __fastcall * ) ( _QWORD ) ) @@a1@@ [ Number ] ; if ( @@v2@@ ) { do { if ( @@v3@@ ) { @@v3@@ ( * @@v2@@ ) ; @@v3@@ = ( void ( __fastcall * ) ( _QWORD ) ) @@a1@@ [ Number ] ; } @@v4@@ = ( _QWORD * ) @@v2@@ [ Number ] ; @@v5@@ = @@a1@@ [ Number ] ; * @@v2@@ = Number L ; @@v2@@ [ Number ] = @@v5@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v2@@ = @@v4@@ ; } while ( @@v4@@ ) ; } if ( @@v3@@ ) @@v3@@ ( * @@v1@@ ) ; * @@v1@@ = Number L ; @@v1@@ [ Number ] = Number L ; } @@v1@@ += Number ; } while ( @@a1@@ [ Number ] > ( unsigned __int64 ) @@v1@@ ) ; } @@a1@@ [ Number ] = Number L ; @@a1@@ [ Number ] = Number L ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall hash_get_next ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; __int64 * @@v6@@ ; _QWORD * @@v7@@ ; __int64 @@v8@@ ; __int64 @@result@@ ; @@v2@@ = * @@a1@@ ; @@v4@@ = ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) ; @@v5@@ = @@a1@@ [ Number ] ; @@v6@@ = ( __int64 * ) ( @@v2@@ + Number * @@v4@@ ) ; if ( @@v5@@ <= ( unsigned __int64 ) @@v6@@ ) abort ( ) ; if ( ! @@v6@@ ) goto LABEL_10 ; @@v7@@ = ( _QWORD * ) @@v6@@ [ Number ] ; if ( * @@v6@@ != @@a2@@ ) { do { if ( ! @@v7@@ ) goto LABEL_10 ; @@v8@@ = * @@v7@@ ; @@v7@@ = ( _QWORD * ) @@v7@@ [ Number ] ; } while ( @@v8@@ != @@a2@@ ) ; } if ( @@v7@@ ) return * @@v7@@ ; LABEL_10 : while ( Number ) { @@v6@@ += Number ; if ( @@v5@@ <= ( unsigned __int64 ) @@v6@@ ) break ; @@result@@ = * @@v6@@ ; if ( * @@v6@@ ) return @@result@@ ; } return Number L ; }
unsigned __int64 __fastcall sha224_init_ctx ( _QWORD * @@a1@@ ) { unsigned __int64 @@result@@ ; @@a1@@ [ Number ] = Number L ; @@a1@@ [ Number ] = Number L ; * @@a1@@ = Number ; @@a1@@ [ Number ] = Number ; @@a1@@ [ Number ] = Number ; @@result@@ = Number ; @@a1@@ [ Number ] = Number ; return @@result@@ ; }
__int64 __fastcall open_safer ( const char * @@a1@@ , char @@a2@@ , unsigned int @@a3@@ ) { __int64 @@v3@@ ; int @@v4@@ ; @@v3@@ = Number L ; if ( ( @@a2@@ & Number ) != Number ) @@v3@@ = @@a3@@ ; @@v4@@ = open ( @@a1@@ , @@a2@@ , @@v3@@ ) ; return fd_safer ( @@v4@@ ) ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
__int64 __fastcall sha256_buffer ( void * @@a1@@ , size_t @@a2@@ , __int64 @@a3@@ ) { __m128i @@v5@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v5@@ . m128i_i64 [ Number ] = Number ; @@v5@@ . m128i_i64 [ Number ] = Number ; @@v9@@ = Number L ; @@v6@@ = Number ; @@v7@@ = Number ; sha256_process_bytes ( @@a1@@ , @@a2@@ , & @@v5@@ ) ; sha256_conclude_ctx ( ( __int64 ) & @@v5@@ ) ; return sha256_read_ctx ( ( __int64 ) & @@v5@@ , @@a3@@ ) ; }
void __fastcall hash_free ( void * @@ptr@@ ) { _QWORD * @@v2@@ ; unsigned __int64 @@v3@@ ; _QWORD * @@v4@@ ; _QWORD * @@v5@@ ; _QWORD * @@v6@@ ; _QWORD * @@v7@@ ; _QWORD * @@v8@@ ; @@v2@@ = * ( _QWORD * * ) @@ptr@@ ; @@v3@@ = * ( ( _QWORD * ) @@ptr@@ + Number ) ; if ( * ( ( _QWORD * ) @@ptr@@ + Number ) && * ( ( _QWORD * ) @@ptr@@ + Number ) ) { if ( ( unsigned __int64 ) @@v2@@ >= @@v3@@ ) goto LABEL_14 ; do { if ( * @@v2@@ ) { @@v4@@ = @@v2@@ ; do { ( * ( ( void ( * * ) ( void ) ) @@ptr@@ + Number ) ) ( ) ; @@v4@@ = ( _QWORD * ) @@v4@@ [ Number ] ; } while ( @@v4@@ ) ; @@v3@@ = * ( ( _QWORD * ) @@ptr@@ + Number ) ; } @@v2@@ += Number ; } while ( @@v3@@ > ( unsigned __int64 ) @@v2@@ ) ; @@v2@@ = * ( _QWORD * * ) @@ptr@@ ; } if ( ( unsigned __int64 ) @@v2@@ < @@v3@@ ) { do { @@v5@@ = ( _QWORD * ) @@v2@@ [ Number ] ; if ( @@v5@@ ) { do { @@v6@@ = ( _QWORD * ) @@v5@@ [ Number ] ; free ( @@v5@@ ) ; @@v5@@ = @@v6@@ ; } while ( @@v6@@ ) ; } @@v2@@ += Number ; } while ( * ( ( _QWORD * ) @@ptr@@ + Number ) > ( unsigned __int64 ) @@v2@@ ) ; } LABEL_14 : @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@ptr@@ + Number ) ; if ( @@v7@@ ) { do { @@v8@@ = ( _QWORD * ) @@v7@@ [ Number ] ; free ( @@v7@@ ) ; @@v7@@ = @@v8@@ ; } while ( @@v8@@ ) ; } free ( * ( void * * ) @@ptr@@ ) ; free ( @@ptr@@ ) ; }
__int64 __fastcall openat_safer ( int @@a1@@ , const char * @@a2@@ , char @@a3@@ , unsigned int @@a4@@ ) { __int64 @@v4@@ ; int @@v5@@ ; @@v4@@ = Number L ; if ( ( @@a3@@ & Number ) != Number ) @@v4@@ = @@a4@@ ; @@v5@@ = openat ( @@a1@@ , @@a2@@ , @@a3@@ , @@v4@@ ) ; return fd_safer ( @@v5@@ ) ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_207210 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2071F0 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_207200 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_2061F0 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061D0 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_2061E0 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
int __lxstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _lxstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
char * __fastcall parse_user_spec ( char * @@s@@ , __uid_t * @@a2@@ , __gid_t * @@a3@@ , char * * @@a4@@ , char * * @@a5@@ ) { char * @@v8@@ ; char * @@v9@@ ; char * @@v10@@ ; char * @@v11@@ ; @@v8@@ = strchr ( @@s@@ , Number ) ; @@v9@@ = parse_with_separator ( @@s@@ , @@v8@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; @@v10@@ = @@v9@@ ; if ( ! @@v8@@ ) { if ( @@v9@@ ) { @@v11@@ = strchr ( @@s@@ , Number ) ; if ( @@v11@@ ) { if ( ! parse_with_separator ( @@s@@ , @@v11@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ) @@v10@@ = Number L ; } } } return @@v10@@ ; }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; program_invocation_short_name = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
__int64 __fastcall dup_cloexec ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
__int64 __fastcall umaxtostr ( unsigned __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; @@v2@@ = @@a2@@ + Number ; * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; do { * ( _BYTE * ) -- @@v2@@ = @@a1@@ % Number + Number ; @@a1@@ /= Number ; } while ( @@a1@@ ) ; return @@v2@@ ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
int chroot ( const char * @@path@@ ) { return chroot ( @@path@@ ) ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 __fastcall file_name_concat ( void * @@a1@@ , void * @@a2@@ ) { __int64 @@result@@ ; @@result@@ = mfile_name_concat ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
bool __fastcall cycle_warning_required ( __int64 @@a1@@ , __int64 @@a2@@ ) { bool @@result@@ ; int @@v3@@ ; @@result@@ = Number ; @@v3@@ = * ( _DWORD * ) ( @@a1@@ + Number ) & Number ; if ( @@v3@@ != Number ) { @@result@@ = Number ; if ( @@v3@@ == Number ) @@result@@ = * ( _QWORD * ) ( @@a2@@ + Number ) != Number L ; } return @@result@@ ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
struct group * getgrgid ( __gid_t @@gid@@ ) { return getgrgid ( @@gid@@ ) ; }
__int64 __fastcall dup_safer ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
__int64 __fastcall fd_safer ( int @@fd@@ , __int64 @@a2@@ , __int64 @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { unsigned int @@v6@@ ; unsigned int @@v7@@ ; int * @@v8@@ ; int @@v9@@ ; int * @@v10@@ ; @@v6@@ = @@fd@@ ; if ( ( unsigned int ) @@fd@@ <= Number ) { @@v7@@ = dup_safer ( @@fd@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; @@v8@@ = __errno_location ( ) ; @@v9@@ = * @@v8@@ ; @@v10@@ = @@v8@@ ; close ( @@fd@@ ) ; @@v6@@ = @@v7@@ ; * @@v10@@ = @@v9@@ ; } return @@v6@@ ; }
FILE * __fastcall freopen_safer ( const char * @@a1@@ , const char * @@a2@@ , FILE * @@a3@@ ) { int @@v4@@ ; int * @@v5@@ ; char @@v6@@ ; char @@v7@@ ; char @@v8@@ ; FILE * @@v9@@ ; int @@v10@@ ; @@v4@@ = fileno ( @@a3@@ ) ; @@v5@@ = __errno_location ( ) ; if ( @@v4@@ == Number ) { @@v6@@ = Number ; @@v7@@ = Number ; } else { if ( @@v4@@ == Number ) { @@v6@@ = Number ; } else { if ( ! @@v4@@ ) { @@v6@@ = Number ; @@v7@@ = Number ; @@v8@@ = Number ; LABEL_11 : @@v9@@ = freopen ( @@a1@@ , @@a2@@ , @@a3@@ ) ; goto LABEL_12 ; } @@v6@@ = dup2 ( Number , Number ) != Number ; } @@v7@@ = dup2 ( Number , Number ) != Number ; } if ( ! dup2 ( Number , Number ) ) { @@v8@@ = Number ; if ( ! @@v7@@ ) goto LABEL_9 ; goto LABEL_20 ; } @@v8@@ = protect_fd ( Number ) ; if ( ! @@v8@@ ) { @@v8@@ = Number ; @@v9@@ = Number L ; LABEL_12 : @@v10@@ = * @@v5@@ ; if ( ! @@v6@@ ) goto LABEL_13 ; goto LABEL_26 ; } if ( @@v7@@ ) { LABEL_20 : @@v7@@ = protect_fd ( Number ) ; if ( ! @@v7@@ ) { @@v9@@ = Number L ; @@v10@@ = * @@v5@@ ; if ( @@v6@@ ) close ( Number ) ; LABEL_23 : close ( Number ) ; if ( ! @@v8@@ ) goto LABEL_15 ; goto LABEL_24 ; } } LABEL_9 : if ( ! @@v6@@ ) goto LABEL_11 ; @@v6@@ = protect_fd ( Number ) ; if ( @@v6@@ ) goto LABEL_11 ; @@v10@@ = * @@v5@@ ; @@v9@@ = Number L ; LABEL_26 : close ( Number ) ; LABEL_13 : if ( @@v7@@ ) goto LABEL_23 ; if ( ! @@v8@@ ) goto LABEL_15 ; LABEL_24 : close ( Number ) ; LABEL_15 : if ( ! @@v9@@ ) * @@v5@@ = @@v10@@ ; return @@v9@@ ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_2081F0 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2081D0 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2081E0 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
struct passwd * getpwnam ( const char * @@name@@ ) { return getpwnam ( @@name@@ ) ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
int setgid ( __gid_t @@gid@@ ) { return setgid ( @@gid@@ ) ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
int setuid ( __uid_t @@uid@@ ) { return setuid ( @@uid@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
DIR * opendir ( const char * @@name@@ ) { return opendir ( @@name@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
_QWORD * randint_all_new ( ) { __int64 @@v0@@ ; __int64 @@v1@@ ; _QWORD * @@result@@ ; @@v0@@ = randread_new ( ) ; if ( ! @@v0@@ ) return Number L ; @@v1@@ = @@v0@@ ; @@result@@ = xmalloc ( Number ) ; * @@result@@ = @@v1@@ ; @@result@@ [ Number ] = Number L ; @@result@@ [ Number ] = Number L ; return @@result@@ ; }
struct group * getgrgid ( __gid_t @@gid@@ ) { return getgrgid ( @@gid@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
void __fastcall __noreturn randread_error ( wchar_t * @@a1@@ ) { _BYTE * @@v1@@ ; int * @@v2@@ ; const char * @@v3@@ ; char * @@v4@@ ; if ( @@a1@@ ) { @@v1@@ = quotearg_colon ( @@a1@@ ) ; @@v2@@ = __errno_location ( ) ; @@v3@@ = String ; if ( * @@v2@@ ) @@v3@@ = String ; @@v4@@ = dcgettext ( Number L , @@v3@@ , Number ) ; error ( exit_failure , * @@v2@@ , @@v4@@ , @@v1@@ ) ; } abort ( ) ; }
struct passwd * getpwnam ( const char * @@name@@ ) { return getpwnam ( @@name@@ ) ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; FILE * @@v11@@ ; char * @@v12@@ ; char * @@v13@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = stdout ; @@v10@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v11@@ = stdout ; @@v12@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v12@@ , @@v11@@ ) ; @@v13@@ = setlocale ( Number , Number L ) ; if ( @@v13@@ ) { if ( strncmp ( @@v13@@ , String , Number ) ) { last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
int fileno ( FILE * @@stream@@ ) { return fileno ( @@stream@@ ) ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
int __fxstat ( int @@ver@@ , int @@fildes@@ , struct stat * @@stat_buf@@ ) { return _fxstat ( @@ver@@ , @@fildes@@ , @@stat_buf@@ ) ; }
int __fastcall randread_free ( FILE * * @@a1@@ ) { FILE * @@v1@@ ; int @@result@@ ; @@v1@@ = * @@a1@@ ; free ( @@a1@@ ) ; if ( @@v1@@ ) @@result@@ = fclose ( @@v1@@ ) ; else @@result@@ = Number ; return @@result@@ ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
void __fastcall chopt_init ( __int64 @@a1@@ ) { * ( _DWORD * ) @@a1@@ = Number ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall umaxtostr ( unsigned __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; @@v2@@ = @@a2@@ + Number ; * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; do { * ( _BYTE * ) -- @@v2@@ = @@a1@@ % Number + Number ; @@a1@@ /= Number ; } while ( @@a1@@ ) ; return @@v2@@ ; }
__int64 __fastcall isaac_seed_data ( unsigned int * @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { __int64 @@v4@@ ; unsigned __int64 @@v6@@ ; unsigned __int64 @@i@@ ; __int64 @@result@@ ; @@v4@@ = @@a1@@ [ Number ] ; @@v6@@ = Number - @@v4@@ ; if ( Number - @@v4@@ >= @@a3@@ ) { @@v6@@ = @@a1@@ [ Number ] ; } else if ( @@v6@@ ) { do { for ( @@i@@ = Number L ; @@i@@ < @@v6@@ ; ++ @@i@@ ) { * ( ( _BYTE * ) @@a1@@ + @@v4@@ + @@i@@ ) ^= * ( _BYTE * ) ( @@a2@@ + @@i@@ ) ; } @@a3@@ -= @@v6@@ ; isaac_mix ( @@a1@@ , @@a1@@ ) ; @@a2@@ += @@v6@@ ; @@v4@@ = Number L ; @@a1@@ [ Number ] = Number ; @@v6@@ = Number L ; } while ( @@a3@@ > Number ) ; @@v6@@ = Number L ; } else { isaac_mix ( @@a1@@ , @@a1@@ ) ; @@a1@@ [ Number ] = Number ; } @@result@@ = Number L ; do { * ( ( _BYTE * ) @@a1@@ + @@v6@@ + @@result@@ ) ^= * ( _BYTE * ) ( @@a2@@ + @@result@@ ) ; ++ @@result@@ ; } while ( @@result@@ != @@a3@@ ) ; @@a1@@ [ Number ] = @@result@@ ; return @@result@@ ; }
__int64 __fastcall print_double ( unsigned __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { __int64 @@v6@@ ; int @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; unsigned __int64 @@v12@@ ; unsigned __int64 @@v13@@ ; double @@v14@@ ; __int64 @@result@@ ; if ( @@a1@@ > @@a2@@ ) { @@v6@@ = @@a6@@ ; @@v8@@ = @@a6@@ * ( @@a1@@ - Number ) ; @@v9@@ = Number L ; @@v10@@ = @@a6@@ * ( @@a1@@ - Number ) ; do { @@v13@@ = @@v10@@ ; @@v11@@ = @@v10@@ / @@a1@@ ; @@v12@@ = @@v10@@ % @@a1@@ ; @@v14@@ = * ( double * ) ( @@a3@@ + Number * @@v9@@ ) ; @@v10@@ -= @@v6@@ ; ++ @@v9@@ ; @@result@@ = xprintf ( @@a4@@ , @@a6@@ - ( int ) @@v11@@ + @@a5@@ , @@v12@@ , @@v8@@ , @@a5@@ , @@a6@@ - ( int ) @@v11@@ , @@v14@@ ) ; @@a6@@ = @@v13@@ / @@a1@@ ; } while ( @@a1@@ - @@a2@@ != @@v9@@ ) ; } return @@result@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 __fastcall dup_safer ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ , char @@a7@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ , @@a7@@ ) ; }
__int64 __fastcall print_long ( unsigned __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { __int64 @@v6@@ ; int @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; __int64 @@v12@@ ; __int64 @@result@@ ; if ( @@a1@@ > @@a2@@ ) { @@v6@@ = @@a6@@ ; @@v8@@ = @@a6@@ * ( @@a1@@ - Number ) ; @@v9@@ = Number L ; @@v10@@ = @@a6@@ * ( @@a1@@ - Number ) ; do { @@v11@@ = @@v10@@ ; @@v12@@ = * ( _QWORD * ) ( @@a3@@ + Number * @@v9@@ ) ; @@v10@@ -= @@v6@@ ; ++ @@v9@@ ; @@result@@ = xprintf ( @@a4@@ , @@a6@@ - ( unsigned int ) ( @@v11@@ / @@a1@@ ) + @@a5@@ , @@v12@@ , @@v8@@ , @@a5@@ , @@a6@@ - ( unsigned int ) ( @@v11@@ / @@a1@@ ) ) ; @@a6@@ = @@v11@@ / @@a1@@ ; } while ( @@a1@@ - @@a2@@ != @@v9@@ ) ; } return @@result@@ ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_207210 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2071F0 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_207200 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
int fileno ( FILE * @@stream@@ ) { return fileno ( @@stream@@ ) ; }
__int64 __fastcall print_char ( unsigned __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , int @@a5@@ , int @@a6@@ ) { __int64 @@v6@@ ; __int64 @@v7@@ ; int @@v8@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; __int64 @@result@@ ; __int64 @@v14@@ ; if ( @@a1@@ > @@a2@@ ) { @@v6@@ = @@a6@@ ; @@v7@@ = @@a3@@ ; @@v8@@ = @@a6@@ * ( @@a1@@ - Number ) ; @@v14@@ = @@a3@@ + @@a1@@ - @@a2@@ ; @@v10@@ = @@a6@@ * ( @@a1@@ - Number ) ; do { ++ @@v7@@ ; @@v11@@ = @@v10@@ ; @@v10@@ -= @@v6@@ ; @@result@@ = xprintf ( @@a4@@ , @@a6@@ - ( unsigned int ) ( @@v11@@ / @@a1@@ ) + @@a5@@ , * ( unsigned __int8 * ) ( @@v7@@ - Number ) , @@v8@@ , @@a5@@ , @@a6@@ - ( unsigned int ) ( @@v11@@ / @@a1@@ ) , @@a4@@ ) ; @@a6@@ = @@v11@@ / @@a1@@ ; } while ( @@v7@@ != @@v14@@ ) ; } return @@result@@ ; }
char * __fastcall fts_alloc ( __int64 @@a1@@ , const void * @@a2@@ , size_t @@a3@@ ) { char * @@v4@@ ; char * @@v5@@ ; __int64 @@v6@@ ; @@v4@@ = ( char * ) malloc ( @@a3@@ + Number ) ; @@v5@@ = @@v4@@ ; if ( @@v4@@ ) { memcpy ( @@v4@@ + Number , @@a2@@ , @@a3@@ ) ; @@v6@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v5@@ [ @@a3@@ + Number ] = Number ; * ( ( _QWORD * ) @@v5@@ + Number ) = @@a3@@ ; * ( ( _QWORD * ) @@v5@@ + Number ) = @@a1@@ ; * ( ( _DWORD * ) @@v5@@ + Number ) = Number ; * ( _DWORD * ) ( @@v5@@ + Number ) = Number ; * ( ( _QWORD * ) @@v5@@ + Number ) = @@v6@@ ; * ( ( _QWORD * ) @@v5@@ + Number ) = Number L ; * ( ( _QWORD * ) @@v5@@ + Number ) = Number L ; } return @@v5@@ ; }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
__int64 __fastcall read_char ( int * @@a1@@ ) { unsigned int @@v2@@ ; FILE * @@i@@ ; int * @@v4@@ ; int @@v5@@ ; int @@v6@@ ; int @@v7@@ ; * @@a1@@ = Number ; @@v2@@ = Number ; for ( @@i@@ = in_stream ; in_stream ; @@v2@@ &= @@v6@@ & @@v5@@ ) { @@v7@@ = fgetc ( @@i@@ ) ; * @@a1@@ = @@v7@@ ; if ( @@v7@@ != Number ) break ; @@v4@@ = __errno_location ( ) ; @@v5@@ = check_and_close ( * @@v4@@ ) ; @@v6@@ = open_next_file ( ) ; @@i@@ = in_stream ; } return @@v2@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
speed_t cfgetispeed ( const struct termios * @@termios_p@@ ) { return cfgetispeed ( @@termios_p@@ ) ; }
unsigned __int64 __fastcall leave_dir_isra_14 ( __int16 @@a1@@ , __int64 * * @@a2@@ , _QWORD * @@a3@@ ) { __int64 * @@v3@@ ; __int64 * @@v4@@ ; __int64 * @@v6@@ ; void * @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v11@@ = __readfsqword ( Number ) ; if ( ( @@a1@@ & Number ) != Number ) { @@v6@@ = * @@a2@@ ; @@v10@@ [ Number ] = @@a3@@ [ Number ] ; @@v10@@ [ Number ] = @@a3@@ [ Number ] ; @@v7@@ = ( void * ) hash_delete ( @@v6@@ , @@v10@@ ) ; if ( @@v7@@ ) { free ( @@v7@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; } goto LABEL_11 ; } @@v3@@ = ( __int64 * ) @@a3@@ [ Number ] ; if ( ! @@v3@@ || @@v3@@ [ Number ] < Number ) return __readfsqword ( Number ) ^ @@v11@@ ; @@v4@@ = * @@a2@@ ; if ( ! ( * @@a2@@ ) [ Number ] ) LABEL_11 : abort ( ) ; if ( * @@v4@@ == @@a3@@ [ Number ] && @@v4@@ [ Number ] == @@a3@@ [ Number ] ) { @@v8@@ = @@v3@@ [ Number ] ; @@v9@@ = @@v3@@ [ Number ] ; @@v4@@ [ Number ] = @@v8@@ ; * @@v4@@ = @@v9@@ ; } return __readfsqword ( Number ) ^ @@v11@@ ; }
__int64 __fastcall read_block ( size_t @@a1@@ , __int64 @@a2@@ , __int64 * @@a3@@ ) { FILE * @@v4@@ ; __int64 @@v6@@ ; unsigned int @@v7@@ ; int * @@v8@@ ; int @@v9@@ ; int @@v10@@ ; size_t @@v11@@ ; if ( ! @@a1@@ || bytes_per_block < @@a1@@ ) __assert_fail ( String , String , Number , String ) ; @@v4@@ = in_stream ; * @@a3@@ = Number L ; if ( ! @@v4@@ ) return Number ; @@v6@@ = Number L ; @@v7@@ = Number ; while ( Number ) { @@v11@@ = fread_unlocked ( ( void * ) ( @@a2@@ + @@v6@@ ) , Number , @@a1@@ - @@v6@@ , @@v4@@ ) ; * @@a3@@ += @@v11@@ ; if ( @@a1@@ - @@v6@@ == @@v11@@ ) break ; @@v8@@ = __errno_location ( ) ; @@v9@@ = check_and_close ( * @@v8@@ ) ; @@v10@@ = open_next_file ( ) ; @@v4@@ = in_stream ; @@v7@@ &= @@v10@@ & @@v9@@ ; if ( ! in_stream ) break ; @@v6@@ = * @@a3@@ ; } return @@v7@@ ; }
int remove ( const char * @@filename@@ ) { return remove ( @@filename@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
int clock_gettime ( clockid_t @@clock_id@@ , struct timespec * @@tp@@ ) { return clock_gettime ( @@clock_id@@ , @@tp@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
__int64 __fastcall hash_get_n_entries ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
__int64 __fastcall xvfprintf ( FILE * @@stream@@ ) { int @@v1@@ ; char * @@v3@@ ; int * @@v4@@ ; @@v1@@ = rpl_vfprintf ( @@stream@@ ) ; if ( @@v1@@ < Number && ! ferror ( @@stream@@ ) ) { @@v3@@ = dcgettext ( Number L , String , Number ) ; @@v4@@ = __errno_location ( ) ; error ( exit_failure , * @@v4@@ , @@v3@@ ) ; } return ( unsigned int ) @@v1@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
__int64 __fastcall xfprintf ( FILE * @@a1@@ ) { return xvfprintf ( @@a1@@ ) ; }
char * nl_langinfo ( nl_item @@item@@ ) { return nl_langinfo ( @@item@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
bool __fastcall hash_table_ok ( __int64 @@a1@@ ) { _QWORD * @@v1@@ ; unsigned __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; bool @@result@@ ; @@v1@@ = * ( _QWORD * * ) @@a1@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v3@@ = Number L ; @@v4@@ = Number L ; if ( * ( _QWORD * ) @@a1@@ < @@v2@@ ) { do { if ( * @@v1@@ ) { @@v5@@ = @@v1@@ [ Number ] ; ++ @@v4@@ ; ++ @@v3@@ ; for ( ; @@v5@@ ; ++ @@v3@@ ) @@v5@@ = * ( _QWORD * ) ( @@v5@@ + Number ) ; } @@v1@@ += Number ; } while ( ( unsigned __int64 ) @@v1@@ < @@v2@@ ) ; } @@result@@ = Number ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) == @@v4@@ ) @@result@@ = * ( _QWORD * ) ( @@a1@@ + Number ) == @@v3@@ ; return @@result@@ ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 __fastcall protect_fd ( int @@a1@@ ) { unsigned int @@v1@@ ; int @@v2@@ ; @@v1@@ = Number ; @@v2@@ = open ( String , Number ) ; if ( @@a1@@ != @@v2@@ ) { @@v1@@ = Number ; if ( @@v2@@ >= Number ) { close ( @@v2@@ ) ; * __errno_location ( ) = Number ; } } return @@v1@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
unsigned __int64 __fastcall hash_get_entries ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { _QWORD * @@v3@@ ; unsigned __int64 @@v4@@ ; _QWORD * @@v5@@ ; unsigned __int64 @@result@@ ; @@v3@@ = * ( _QWORD * * ) @@a1@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= * ( _QWORD * ) @@a1@@ ) return Number L ; @@v4@@ = Number L ; while ( ! * @@v3@@ ) { LABEL_9 : @@v3@@ += Number ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= ( unsigned __int64 ) @@v3@@ ) return @@v4@@ ; } if ( @@a3@@ <= @@v4@@ ) return @@v4@@ ; * ( _QWORD * ) ( @@a2@@ + Number * @@v4@@ ) = * @@v3@@ ; @@v5@@ = ( _QWORD * ) @@v3@@ [ Number ] ; @@result@@ = @@v4@@ + Number ; if ( ! @@v5@@ ) { LABEL_8 : @@v4@@ = @@result@@ ; goto LABEL_9 ; } while ( @@a3@@ != @@result@@ ) { ++ @@result@@ ; * ( _QWORD * ) ( @@a2@@ + Number * @@result@@ - Number ) = * @@v5@@ ; @@v5@@ = ( _QWORD * ) @@v5@@ [ Number ] ; if ( ! @@v5@@ ) goto LABEL_8 ; } return @@result@@ ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
unsigned __int64 __fastcall display_window_size ( char @@a1@@ , const char * @@a2@@ ) { int @@v3@@ ; char * @@v5@@ ; unsigned __int16 @@v6@@ ; unsigned __int16 @@v7@@ ; unsigned __int64 @@v8@@ ; @@v8@@ = __readfsqword ( Number ) ; if ( ioctl ( Number , Number , & @@v6@@ ) ) { @@v3@@ = * __errno_location ( ) ; if ( @@v3@@ == Number ) { if ( @@a1@@ ) return __readfsqword ( Number ) ^ @@v8@@ ; } else { error ( Number , @@v3@@ , String , @@a2@@ ) ; if ( @@a1@@ ) return __readfsqword ( Number ) ^ @@v8@@ ; } @@v5@@ = dcgettext ( Number L , String , Number ) ; error ( Number , Number , @@v5@@ , @@a2@@ ) ; return __readfsqword ( Number ) ^ @@v8@@ ; } if ( @@a1@@ ) { wrapf ( ( __int64 ) String , @@v6@@ , @@v7@@ ) ; } else { wrapf ( ( __int64 ) String , @@v6@@ , @@v7@@ ) ; current_col = Number ; } return __readfsqword ( Number ) ^ @@v8@@ ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
void __fastcall i_ring_init ( __int64 @@a1@@ , int @@a2@@ ) { * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; }
void * __fastcall mfile_name_concat ( void * @@src@@ , void * @@a2@@ , _QWORD * @@a3@@ ) { const char * @@v4@@ ; const char * @@v5@@ ; size_t @@v6@@ ; size_t @@v7@@ ; _BOOL8 @@v8@@ ; void * @@v9@@ ; void * @@v10@@ ; _BYTE * @@v11@@ ; char * @@v12@@ ; size_t @@n@@ ; char @@v15@@ ; @@v4@@ = ( const char * ) @@a2@@ ; @@v5@@ = last_component ( @@src@@ ) ; @@v6@@ = base_len ( @@v5@@ ) ; @@v7@@ = @@v6@@ + @@v5@@ - ( _BYTE * ) @@src@@ ; @@v8@@ = @@v6@@ ; if ( @@v6@@ ) @@v8@@ = @@v5@@ [ @@v6@@ - Number ] != Number ; @@v15@@ = * ( _BYTE * ) @@a2@@ ; if ( * ( _BYTE * ) @@a2@@ == Number ) { do ++ @@v4@@ ; while ( * @@v4@@ == Number ) ; } @@n@@ = strlen ( @@v4@@ ) ; @@v9@@ = malloc ( @@n@@ + @@v8@@ + @@v7@@ + Number ) ; @@v10@@ = @@v9@@ ; if ( @@v9@@ ) { @@v11@@ = mempcpy ( @@v9@@ , @@src@@ , @@v7@@ ) ; * @@v11@@ = Number ; @@v12@@ = & @@v11@@ [ @@v8@@ ] ; if ( @@a3@@ ) * @@a3@@ = & @@v12@@ [ - ( @@v15@@ == Number ) ] ; * ( _BYTE * ) mempcpy ( @@v12@@ , @@v4@@ , @@n@@ ) = Number ; } return @@v10@@ ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
__int64 __fastcall i_ring_pop ( __int64 @@a1@@ ) { _DWORD * @@v1@@ ; int @@v2@@ ; __int64 @@result@@ ; if ( * ( _BYTE * ) ( @@a1@@ + Number ) ) abort ( ) ; @@v1@@ = ( _DWORD * ) ( @@a1@@ + Number L * * ( unsigned int * ) ( @@a1@@ + Number ) ) ; @@v2@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; @@result@@ = ( unsigned int ) * @@v1@@ ; * @@v1@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; if ( @@v2@@ == * ( _DWORD * ) ( @@a1@@ + Number ) ) * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; else * ( _DWORD * ) ( @@a1@@ + Number ) = ( ( _BYTE ) @@v2@@ + Number ) & Number ; return @@result@@ ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
DIR * __fastcall opendir_safer ( const char * @@a1@@ ) { DIR * @@v1@@ ; DIR * @@v2@@ ; unsigned int @@v3@@ ; int @@v5@@ ; DIR * @@v6@@ ; int * @@v7@@ ; int @@v8@@ ; @@v1@@ = opendir ( @@a1@@ ) ; @@v2@@ = @@v1@@ ; if ( ! @@v1@@ ) return @@v2@@ ; @@v3@@ = dirfd ( @@v1@@ ) ; if ( @@v3@@ > Number ) return @@v2@@ ; @@v5@@ = dup_safer ( @@v3@@ ) ; @@v6@@ = fdopendir ( @@v5@@ ) ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; if ( ! @@v6@@ ) close ( @@v5@@ ) ; closedir ( @@v2@@ ) ; * @@v7@@ = @@v8@@ ; return @@v6@@ ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_20E330 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20E310 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20E320 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_20E1F0 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20E1D0 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_20E1E0 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
_QWORD * __fastcall randint_new ( __int64 @@a1@@ ) { _QWORD * @@result@@ ; @@result@@ = xmalloc ( Number ) ; * @@result@@ = @@a1@@ ; @@result@@ [ Number ] = Number L ; @@result@@ [ Number ] = Number L ; return @@result@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
void randint_free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
_QWORD * __fastcall randread_new ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { FILE * @@v2@@ ; void * @@v3@@ ; size_t @@v4@@ ; _QWORD * @@result@@ ; _QWORD * @@v6@@ ; if ( @@a2@@ ) { if ( @@a1@@ ) { @@v2@@ = ( FILE * ) fopen_safer ( @@a1@@ , & off_695E ) ; if ( @@v2@@ ) { @@v3@@ = xmalloc ( Number ) ; * ( _QWORD * ) @@v3@@ = @@v2@@ ; @@v4@@ = Number L ; if ( @@a2@@ <= Number ) @@v4@@ = @@a2@@ ; * ( ( _QWORD * ) @@v3@@ + Number ) = randread_error ; * ( ( _QWORD * ) @@v3@@ + Number ) = @@a1@@ ; setvbuf ( @@v2@@ , ( char * ) @@v3@@ + Number , Number , @@v4@@ ) ; } else { @@v3@@ = Number L ; } @@result@@ = @@v3@@ ; } else { @@v6@@ = xmalloc ( Number ) ; * @@v6@@ = Number L ; @@v6@@ [ Number ] = Number L ; @@v6@@ [ Number ] = Number L ; @@v6@@ [ Number ] = randread_error ; isaac_seed ( @@v6@@ + Number ) ; @@result@@ = @@v6@@ ; } } else { @@result@@ = xmalloc ( Number ) ; * @@result@@ = Number L ; @@result@@ [ Number ] = Number L ; @@result@@ [ Number ] = randread_error ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
__int64 __fastcall randint_get_source ( __int64 @@a1@@ ) { return * ( _QWORD * ) @@a1@@ ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
FILE * __fastcall fopen_safer ( const char * @@a1@@ , const char * @@a2@@ ) { FILE * @@v2@@ ; FILE * @@v3@@ ; unsigned int @@v4@@ ; int @@v6@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; int * @@v10@@ ; int @@v11@@ ; int * @@v12@@ ; @@v2@@ = fopen ( @@a1@@ , @@a2@@ ) ; @@v3@@ = @@v2@@ ; if ( @@v2@@ ) { @@v4@@ = fileno ( @@v2@@ ) ; if ( @@v4@@ <= Number ) { @@v6@@ = dup_safer ( @@v4@@ ) ; if ( @@v6@@ < Number ) { @@v10@@ = __errno_location ( ) ; @@v11@@ = * @@v10@@ ; @@v12@@ = @@v10@@ ; fclose ( @@v3@@ ) ; @@v3@@ = Number L ; * @@v12@@ = @@v11@@ ; } else if ( fclose ( @@v3@@ ) || ( @@v3@@ = fdopen ( @@v6@@ , @@a2@@ ) ) == Number L ) { @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; close ( @@v6@@ ) ; * @@v9@@ = @@v8@@ ; @@v3@@ = Number L ; } } } return @@v3@@ ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 __fastcall randint_all_free ( void * @@ptr@@ ) { unsigned int @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = randread_free ( * ( _QWORD * ) @@ptr@@ ) ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; randint_free ( @@ptr@@ ) ; @@result@@ = @@v1@@ ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
__int64 __fastcall set_cloexec_flag ( int @@a1@@ , char @@a2@@ , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { int @@v6@@ ; int @@v7@@ ; int @@v8@@ ; int @@v9@@ ; int @@v10@@ ; unsigned int @@v11@@ ; __int64 @@result@@ ; @@v6@@ = rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( @@v6@@ < Number ) return Number ; @@v9@@ = @@v6@@ ; @@v10@@ = @@v6@@ | Number ; @@v11@@ = @@v9@@ & Number ; if ( @@a2@@ ) @@v11@@ = @@v10@@ ; @@result@@ = Number L ; if ( @@v11@@ != @@v9@@ ) @@result@@ = ( unsigned int ) - ( ( unsigned int ) rpl_fcntl ( @@a1@@ , Number , @@v11@@ , @@v9@@ , @@v7@@ , @@v8@@ ) == Number ) ; return @@result@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
_QWORD * __fastcall readlinebuffer_delim ( _QWORD * @@a1@@ , _IO_FILE * @@a2@@ , char @@a3@@ ) { __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ ; int @@v7@@ ; char * @@v8@@ ; int @@v9@@ ; char @@v10@@ ; _BYTE * @@v11@@ ; __int64 @@v12@@ ; __int64 @@v13@@ ; __int64 @@v14@@ ; char * @@v15@@ ; _QWORD * @@result@@ ; int @@v17@@ ; char @@v18@@ ; __int64 @@v19@@ ; char @@v20@@ ; char @@v21@@ ; @@v3@@ = @@a1@@ [ Number ] ; @@v4@@ = @@v3@@ + * @@a1@@ ; if ( ( @@a2@@ -> _flags & Number ) == Number ) { @@v6@@ = @@a1@@ [ Number ] ; @@v7@@ = @@a3@@ ; while ( Number ) { @@v8@@ = @@a2@@ -> _IO_read_ptr ; if ( @@v8@@ >= @@a2@@ -> _IO_read_end ) { @@v21@@ = @@a3@@ ; @@v19@@ = @@v4@@ ; @@v17@@ = __uflow ( @@a2@@ ) ; @@v9@@ = @@v17@@ ; @@v4@@ = @@v19@@ ; @@a3@@ = @@v21@@ ; if ( @@v17@@ == Number ) { if ( @@v3@@ == @@v6@@ || ( @@a2@@ -> _flags & Number ) != Number ) return Number L ; if ( * ( _BYTE * ) ( @@v6@@ - Number ) == @@v21@@ ) { LABEL_8 : @@result@@ = @@a1@@ ; @@a1@@ [ Number ] = @@v6@@ - @@v3@@ ; return @@result@@ ; } @@v9@@ = @@v7@@ ; @@v10@@ = @@v21@@ ; } else { @@v10@@ = @@v17@@ ; } } else { @@a2@@ -> _IO_read_ptr = @@v8@@ + Number ; @@v9@@ = ( unsigned __int8 ) * @@v8@@ ; @@v10@@ = * @@v8@@ ; } @@v11@@ = ( _BYTE * ) @@v6@@ ; if ( @@v6@@ == @@v4@@ ) { @@v12@@ = * @@a1@@ ; @@v20@@ = @@a3@@ ; @@v18@@ = @@v10@@ ; @@v13@@ = x2realloc ( @@v3@@ , @@a1@@ ) ; @@v14@@ = * @@a1@@ ; @@v15@@ = ( char * ) ( @@v13@@ + @@v12@@ ) ; @@a1@@ [ Number ] = @@v13@@ ; @@v3@@ = @@v13@@ ; @@a3@@ = @@v20@@ ; @@v6@@ = @@v13@@ + @@v12@@ + Number ; @@v4@@ = @@v13@@ + @@v14@@ ; * @@v15@@ = @@v18@@ ; if ( @@v9@@ == @@v7@@ ) goto LABEL_8 ; } else { ++ @@v6@@ ; * @@v11@@ = @@v10@@ ; if ( @@v9@@ == @@v7@@ ) goto LABEL_8 ; } } } return Number L ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_210230 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_210210 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_210220 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
__int64 __fastcall randread ( __int64 @@a1@@ , char * @@a2@@ , size_t @@a3@@ ) { size_t @@v4@@ ; int * @@v6@@ ; FILE * @@v7@@ ; int * @@v8@@ ; __int64 @@v9@@ ; int @@v10@@ ; __int64 @@result@@ ; size_t @@v12@@ ; __int64 @@v13@@ ; void * @@v14@@ ; size_t @@v15@@ ; __int64 @@v16@@ ; char * @@v17@@ ; FILE * @@src@@ ; char * @ @ VAR_584 @ @ srca @ @ $41FE09B6257987CAFC80CA7C5973CF25 ; @@v4@@ = @@a3@@ ; @@src@@ = * ( FILE * * ) @@a1@@ ; if ( * ( _QWORD * ) @@a1@@ ) { @@v6@@ = __errno_location ( ) ; @@v7@@ = @@src@@ ; @@v8@@ = @@v6@@ ; while ( Number ) { @@result@@ = fread_unlocked ( @@a2@@ , Number , @@v4@@ , @@v7@@ ) ; @@a2@@ += @@result@@ ; @@v4@@ -= @@result@@ ; if ( ! @@v4@@ ) break ; @@v9@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v10@@ = * * ( _DWORD * * ) @@a1@@ & Number ; if ( @@v10@@ ) @@v10@@ = * @@v8@@ ; * @@v8@@ = @@v10@@ ; ( * ( void ( __fastcall * * ) ( __int64 ) ) ( @@a1@@ + Number ) ) ( @@v9@@ ) ; @@v7@@ = * ( FILE * * ) @@a1@@ ; } } else { @@v12@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v13@@ = @@a1@@ + Number ; @ @ VAR_584 @ @ srca @ @ $41FE09B6257987CAFC80CA7C5973CF25 = ( char * ) ( @@a1@@ + Number ) ; if ( @@a3@@ <= @@v12@@ ) { @ @ VAR_584 @ @ srca @ @ $41FE09B6257987CAFC80CA7C5973CF25 = ( char * ) ( @@a1@@ + Number - @@v12@@ + Number ) ; LABEL_18 : @@result@@ = ( __int64 ) memcpy ( @@a2@@ , @ @ VAR_584 @ @ srca @ @ $41FE09B6257987CAFC80CA7C5973CF25 , @@v4@@ ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v12@@ - @@v4@@ ; } else { while ( Number ) { @@v14@@ = @@a2@@ ; @@a2@@ += @@v12@@ ; @@v4@@ -= @@v12@@ ; memcpy ( @@v14@@ , & @ @ VAR_584 @ @ srca @ @ $41FE09B6257987CAFC80CA7C5973CF25 [ Number - @@v12@@ ] , @@v12@@ ) ; if ( ( ( unsigned __int8 ) @@a2@@ & Number ) == Number ) break ; LABEL_16 : @@v12@@ = Number L ; isaac_refill ( @@v13@@ , @ @ VAR_584 @ @ srca @ @ $41FE09B6257987CAFC80CA7C5973CF25 ) ; if ( @@v4@@ <= Number ) goto LABEL_17 ; } if ( @@v4@@ <= Number ) { isaac_refill ( @@v13@@ , @ @ VAR_584 @ @ srca @ @ $41FE09B6257987CAFC80CA7C5973CF25 ) ; LABEL_17 : @@v12@@ = Number L ; goto LABEL_18 ; } @@v15@@ = @@v4@@ - Number ; @@v16@@ = ( ( _WORD ) @@v4@@ - Number ) & Number ; while ( Number ) { @@v17@@ = @@a2@@ ; @@a2@@ += Number ; @@result@@ = isaac_refill ( @@v13@@ , @@v17@@ ) ; @@v4@@ = @@v15@@ ; if ( ! @@v15@@ ) break ; if ( @@v15@@ == @@v16@@ ) goto LABEL_16 ; @@v15@@ -= Number L ; } * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; } } return @@result@@ ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
int tcgetattr ( int @@fd@@ , struct termios * @@termios_p@@ ) { return tcgetattr ( @@fd@@ , @@termios_p@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
int cfsetospeed ( struct termios * @@termios_p@@ , speed_t @@speed@@ ) { return cfsetospeed ( @@termios_p@@ , @@speed@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
int chdir ( const char * @@path@@ ) { return chdir ( @@path@@ ) ; }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
speed_t cfgetospeed ( const struct termios * @@termios_p@@ ) { return cfgetospeed ( @@termios_p@@ ) ; }
struct group * getgrnam ( const char * @@name@@ ) { return getgrnam ( @@name@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) _frame_dummy_init_array_entry [ @@i@@ ] ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
int cfsetispeed ( struct termios * @@termios_p@@ , speed_t @@speed@@ ) { return cfsetispeed ( @@termios_p@@ , @@speed@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
__int16 * __fastcall visible_part_0 ( unsigned __int8 @@a1@@ ) { __int16 * @@v2@@ ; if ( @@a1@@ <= Number ) { @@v2@@ = & word_2100B2 ; LOBYTE ( buf_6798 ) = Number ; HIBYTE ( buf_6798 ) = @@a1@@ + Number ; } else { if ( @@a1@@ <= Number ) { buf_6798 = @@a1@@ ; return & buf_6798 ; } if ( @@a1@@ == Number ) { @@v2@@ = & word_2100B2 ; buf_6798 = Number ; } else { buf_6798 = Number ; if ( @@a1@@ <= Number ) { LOBYTE ( word_2100B2 ) = Number ; @@v2@@ = ( __int16 * ) & unk_2100B4 ; HIBYTE ( word_2100B2 ) = @@a1@@ - Number ; } else if ( @@a1@@ == Number ) { word_2100B2 = Number ; @@v2@@ = ( __int16 * ) & unk_2100B4 ; } else { @@v2@@ = ( __int16 * ) ( ( char * ) & word_2100B2 + Number ) ; LOBYTE ( word_2100B2 ) = @@a1@@ + Number ; } } } * ( _BYTE * ) @@v2@@ = Number ; return & buf_6798 ; }
int __fastcall memcoll ( void * @@s1@@ , size_t @@n@@ , void * @@s2@@ , __int64 @@a4@@ ) { const char * @@v5@@ ; int * @@v7@@ ; size_t @@v8@@ ; char * @@v9@@ ; __int64 @@v10@@ ; char @@v11@@ ; size_t @@v12@@ ; size_t @@v13@@ ; int @@result@@ ; __int64 @@v15@@ ; __int64 @@v16@@ ; int @@v17@@ ; char @@v18@@ ; char @@v19@@ ; @@v5@@ = ( const char * ) @@s1@@ ; @@v7@@ = __errno_location ( ) ; if ( @@n@@ != @@a4@@ || ( @@result@@ = memcmp ( @@s1@@ , @@s2@@ , @@n@@ ) ) != Number ) { @@v8@@ = @@n@@ + Number ; @@v18@@ = * ( ( _BYTE * ) @@s1@@ + @@n@@ ) ; @@v9@@ = ( char * ) @@s2@@ + @@a4@@ ; @@v10@@ = @@a4@@ + Number ; @@v11@@ = * @@v9@@ ; * ( ( _BYTE * ) @@s1@@ + @@n@@ ) = Number ; * @@v9@@ = Number ; @@v19@@ = @@v11@@ ; do { * @@v7@@ = Number ; @@result@@ = strcoll ( @@v5@@ , ( const char * ) @@s2@@ ) ; if ( @@result@@ ) { @@v15@@ = @@v8@@ - Number ; @@v16@@ = @@v10@@ - Number ; goto LABEL_7 ; } @@v12@@ = strlen ( @@v5@@ ) + Number ; @@v13@@ = strlen ( ( const char * ) @@s2@@ ) + Number ; @@v5@@ += @@v12@@ ; @@s2@@ = ( char * ) @@s2@@ + @@v13@@ ; @@v10@@ -= @@v13@@ ; @@v8@@ -= @@v12@@ ; if ( ! @@v8@@ ) { @@v15@@ = Number ; @@v17@@ = @@v10@@ != Number ; @@v16@@ = @@v10@@ - Number ; @@result@@ = - @@v17@@ ; goto LABEL_7 ; } } while ( @@v10@@ ) ; @@v15@@ = @@v8@@ - Number ; @@v16@@ = Number ; @@result@@ = Number ; LABEL_7 : @@v5@@ [ @@v15@@ ] = @@v18@@ ; * ( ( _BYTE * ) @@s2@@ + @@v16@@ ) = @@v19@@ ; } else { * @@v7@@ = Number ; } return @@result@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
__int64 __fastcall string_to_baud ( char * @@s1@@ ) { const char * @@v1@@ ; int @@v2@@ ; void * * @@v3@@ ; @@v1@@ = String ; @@v2@@ = Number ; @@v3@@ = & off_20EB38 ; do { if ( ! strcmp ( @@s1@@ , @@v1@@ ) ) return * ( ( unsigned int * ) & speeds + Number * @@v2@@ + Number ) ; @@v3@@ += Number ; @@v1@@ = ( const char * ) * ( @@v3@@ - Number ) ; ++ @@v2@@ ; } while ( @@v1@@ ) ; return Number ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
int __cdecl __noreturn main ( int @@argc@@ , const char * * @@argv@@ , const char * * envp ) { char * @@v3@@ ; set_program_name ( * @@argv@@ ) ; setlocale ( Number , String ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; parse_long_options ( @@argc@@ , ( _DWORD ) @@argv@@ , ( unsigned int ) String , ( unsigned int ) String , ( _DWORD ) Version , ( unsigned int ) usage , String , Number L ) ; if ( getopt_long ( @@argc@@ , ( char * const * ) @@argv@@ , String , Number L , Number L ) == Number ) { if ( optind < @@argc@@ ) { @@v3@@ = dcgettext ( Number L , String , Number ) ; error ( Number , Number , @@v3@@ ) ; } sync ( ) ; exit ( Number ) ; } usage ( Number ) ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
unsigned __int64 __fastcall integer_arg ( char * @@a1@@ , unsigned __int64 @@a2@@ ) { unsigned __int64 @@result@@ ; __int64 @@v3@@ ; char * @@v4@@ ; unsigned __int64 @@v5@@ ; if ( ( unsigned int ) xstrtoul ( @@a1@@ ) || ( @@result@@ = @@v5@@ , @@v5@@ > @@a2@@ ) ) { @@v3@@ = quote ( @@a1@@ ) ; @@v4@@ = dcgettext ( Number L , String , Number ) ; error ( Number , Number , @@v4@@ , @@v3@@ ) ; usage ( Number ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_2071F0 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2071D0 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_2071E0 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
struct passwd * getpwuid ( __uid_t @@uid@@ ) { return getpwuid ( @@uid@@ ) ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_210230 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_210210 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_210220 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall rpl_fcntl ( int @@a1@@ , int @@a2@@ , __int64 @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { int @@v6@@ ; int @@v8@@ ; int @@v9@@ ; int @@v10@@ ; int @@v11@@ ; int * @@v12@@ ; int @@v13@@ ; int * @@v14@@ ; int @@v15@@ ; @@v15@@ = @@a3@@ ; if ( @@a2@@ != Number ) return ( unsigned int ) fcntl ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( have_dupfd_cloexec_3202 < Number ) { @@v6@@ = ( ( __int64 ( __fastcall * ) ( int , _DWORD , _DWORD , int , int , int , char ) ) rpl_fcntl ) ( @@a1@@ , Number , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ , Number ) ; if ( @@v6@@ < Number || have_dupfd_cloexec_3202 != Number ) return ( unsigned int ) @@v6@@ ; } else { @@v6@@ = fcntl ( @@a1@@ , Number , ( unsigned int ) @@a3@@ ) ; if ( @@v6@@ >= Number || * __errno_location ( ) != Number ) { have_dupfd_cloexec_3202 = Number ; return ( unsigned int ) @@v6@@ ; } @@v6@@ = ( ( __int64 ( __fastcall * ) ( int , _DWORD , int , int , int , int , char ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v15@@ , @@v8@@ , @@v9@@ , @@v10@@ , Number ) ; if ( @@v6@@ < Number ) return ( unsigned int ) @@v6@@ ; have_dupfd_cloexec_3202 = Number ; } @@v11@@ = fcntl ( @@v6@@ , Number ) ; if ( @@v11@@ < Number || fcntl ( @@v6@@ , Number , @@v11@@ | Number ) == Number ) { @@v12@@ = __errno_location ( ) ; @@v13@@ = * @@v12@@ ; @@v14@@ = @@v12@@ ; close ( @@v6@@ ) ; @@v6@@ = Number ; * @@v14@@ = @@v13@@ ; } return ( unsigned int ) @@v6@@ ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
__int64 __fastcall dup_safer ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ , char @@a7@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ , @@a7@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; char * @@v9@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = setlocale ( Number , Number L ) ; if ( @@v9@@ ) { if ( strncmp ( @@v9@@ , String , Number ) ) { last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
__int64 __fastcall rpl_fcntl ( int @@a1@@ , int @@a2@@ , __int64 @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { int @@v6@@ ; int @@v8@@ ; int @@v9@@ ; int @@v10@@ ; int @@v11@@ ; int * @@v12@@ ; int @@v13@@ ; int * @@v14@@ ; int @@v15@@ ; @@v15@@ = @@a3@@ ; if ( @@a2@@ != Number ) return ( unsigned int ) fcntl ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( have_dupfd_cloexec_3202 < Number ) { @@v6@@ = ( ( __int64 ( __fastcall * ) ( int , _DWORD , _DWORD , int , int , int , char ) ) rpl_fcntl ) ( @@a1@@ , Number , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ , Number ) ; if ( @@v6@@ < Number || have_dupfd_cloexec_3202 != Number ) return ( unsigned int ) @@v6@@ ; } else { @@v6@@ = fcntl ( @@a1@@ , Number , ( unsigned int ) @@a3@@ ) ; if ( @@v6@@ >= Number || * __errno_location ( ) != Number ) { have_dupfd_cloexec_3202 = Number ; return ( unsigned int ) @@v6@@ ; } @@v6@@ = ( ( __int64 ( __fastcall * ) ( int , _DWORD , int , int , int , int , char ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v15@@ , @@v8@@ , @@v9@@ , @@v10@@ , Number ) ; if ( @@v6@@ < Number ) return ( unsigned int ) @@v6@@ ; have_dupfd_cloexec_3202 = Number ; } @@v11@@ = fcntl ( @@v6@@ , Number ) ; if ( @@v11@@ < Number || fcntl ( @@v6@@ , Number , @@v11@@ | Number ) == Number ) { @@v12@@ = __errno_location ( ) ; @@v13@@ = * @@v12@@ ; @@v14@@ = @@v12@@ ; close ( @@v6@@ ) ; @@v6@@ = Number ; * @@v14@@ = @@v13@@ ; } return ( unsigned int ) @@v6@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
int fsync ( int @@fd@@ ) { return fsync ( @@fd@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
int puts ( const char * @@s@@ ) { return puts ( @@s@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_2061F0 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061D0 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_2061E0 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_2061F0 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061D0 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061E0 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; FILE * @@v11@@ ; char * @@v12@@ ; FILE * @@v13@@ ; char * @@v14@@ ; FILE * @@v15@@ ; char * @@v16@@ ; char * @@v17@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String String String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; fputc_unlocked ( Number , stdout ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String String String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; fputc_unlocked ( Number , stdout ) ; @@v9@@ = stdout ; @@v10@@ = dcgettext ( Number L , String String String String , Number ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; fputc_unlocked ( Number , stdout ) ; @@v11@@ = stdout ; @@v12@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v12@@ , @@v11@@ ) ; @@v13@@ = stdout ; @@v14@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v14@@ , @@v13@@ ) ; last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v15@@ = stdout ; @@v16@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v16@@ , @@v15@@ ) ; @@v17@@ = setlocale ( Number , Number L ) ; if ( @@v17@@ ) { if ( strncmp ( @@v17@@ , String , Number ) ) { last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; char * @@v9@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = setlocale ( Number , Number L ) ; if ( @@v9@@ ) { if ( strncmp ( @@v9@@ , String , Number ) ) { last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
void __fastcall interrupt_handler ( int @@a1@@ ) { interrupt_signal = @@a1@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
char * nl_langinfo ( nl_item @@item@@ ) { return nl_langinfo ( @@item@@ ) ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
int puts ( const char * @@s@@ ) { return puts ( @@s@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
unsigned __int64 print_stats ( ) { __int64 @@v0@@ ; char @@v2@@ [ Number ] ; unsigned __int64 @@v3@@ ; @@v3@@ = __readfsqword ( Number ) ; @@v0@@ = gethrxtime ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; if ( r_truncate ) { dcngettext ( Number L , String , String , r_truncate , Number ) ; __fprintf_chk ( ) ; if ( ( status_flags & Number ) != Number ) return __readfsqword ( Number ) ^ @@v3@@ ; } else if ( ( status_flags & Number ) != Number ) { return __readfsqword ( Number ) ^ @@v3@@ ; } human_readable ( w_bytes , @@v2@@ , Number L , Number L , Number L ) ; dcngettext ( Number L , String , String , w_bytes , Number ) ; __fprintf_chk ( ) ; if ( start_time >= @@v0@@ ) dcgettext ( Number L , String , Number ) ; else human_readable ( w_bytes , @@v2@@ , Number L , Number L , @@v0@@ - start_time ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; return __readfsqword ( Number ) ^ @@v3@@ ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 __fastcall print_long_double ( unsigned __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { int @@v7@@ ; unsigned __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@result@@ ; __int64 @@v12@@ ; __int64 @@v15@@ ; if ( @@a1@@ > @@a2@@ ) { @@v15@@ = @@a6@@ ; @@v7@@ = @@a6@@ * ( @@a1@@ - Number ) ; @@v8@@ = @@a1@@ ; @@v9@@ = @@a6@@ * ( @@a1@@ - Number ) ; do { @@a3@@ += Number L ; -- @@v8@@ ; @@v10@@ = @@v9@@ / @@a1@@ ; xprintf ( @@a4@@ , @@a6@@ - @@v9@@ / @@a1@@ + @@a5@@ , @@v9@@ % @@a1@@ , @@v7@@ , @@a5@@ , @@a6@@ - @@v9@@ / @@a1@@ , * ( _QWORD * ) ( @@a3@@ - Number ) , * ( _QWORD * ) ( @@a3@@ - Number ) ) ; @@v9@@ -= @@v15@@ ; @@a6@@ = @@v10@@ ; @@result@@ = @@v12@@ ; } while ( @@v8@@ != @@a2@@ ) ; } return @@result@@ ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
unsigned __int64 __fastcall parse_integer ( char * @@a1@@ , _BYTE * @@a2@@ ) { int @@v2@@ ; __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; unsigned __int64 @@v6@@ ; __int64 @@v7@@ ; _BYTE * @@v8@@ ; @@v2@@ = xstrtoumax ( @@a1@@ ) ; if ( @@v2@@ != Number ) { if ( ! @@v2@@ ) return @@v7@@ ; LABEL_6 : * @@a2@@ = Number ; return Number L ; } if ( * @@v8@@ != Number ) goto LABEL_6 ; @@v6@@ = ( ( __int64 ( __fastcall * ) ( _BYTE * , _BYTE * , __int64 ) ) parse_integer ) ( @@v8@@ + Number , @@a2@@ , @@v3@@ ) ; @@v4@@ = @@v6@@ ; if ( @@v6@@ ) { @@v4@@ = @@v6@@ * @@v7@@ ; if ( @@v7@@ != @@v6@@ * @@v7@@ / @@v6@@ ) goto LABEL_6 ; } return @@v4@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 __fastcall print_long_long ( unsigned __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { __int64 @@v6@@ ; int @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; __int64 @@v12@@ ; __int64 @@result@@ ; if ( @@a1@@ > @@a2@@ ) { @@v6@@ = @@a6@@ ; @@v8@@ = @@a6@@ * ( @@a1@@ - Number ) ; @@v9@@ = Number L ; @@v10@@ = @@a6@@ * ( @@a1@@ - Number ) ; do { @@v11@@ = @@v10@@ ; @@v12@@ = * ( _QWORD * ) ( @@a3@@ + Number * @@v9@@ ) ; @@v10@@ -= @@v6@@ ; ++ @@v9@@ ; @@result@@ = xprintf ( @@a4@@ , @@a6@@ - ( unsigned int ) ( @@v11@@ / @@a1@@ ) + @@a5@@ , @@v12@@ , @@v8@@ , @@a5@@ , @@a6@@ - ( unsigned int ) ( @@v11@@ / @@a1@@ ) ) ; @@a6@@ = @@v11@@ / @@a1@@ ; } while ( @@a1@@ - @@a2@@ != @@v9@@ ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
unsigned __int64 __fastcall set_fd_flags ( int @@fildes@@ , int @@a2@@ , __int64 @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { int @@v8@@ ; int @@v9@@ ; int @@v10@@ ; int @@v11@@ ; unsigned int @@v12@@ ; int @@v13@@ ; __int64 @@v14@@ ; char * @@v15@@ ; int * @@v16@@ ; struct stat @@v17@@ ; unsigned __int64 @@v18@@ ; @@v18@@ = __readfsqword ( Number ) ; if ( ( @@a2@@ & Number ) != Number ) { @@v8@@ = rpl_fcntl ( @@fildes@@ , Number , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ , @@v17@@ . st_dev ) ; @@v12@@ = @@v8@@ | @@a2@@ & Number ; @@v13@@ = @@v8@@ ; if ( @@v8@@ >= Number ) { if ( @@v8@@ == @@v12@@ ) return __readfsqword ( Number ) ^ @@v18@@ ; if ( ( @@v12@@ & Number ) != Number ) { if ( __fxstat ( Number , @@fildes@@ , & @@v17@@ ) ) goto LABEL_7 ; if ( ( @@v17@@ . st_mode & Number ) != Number ) { * __errno_location ( ) = Number ; goto LABEL_7 ; } @@v12@@ &= Number ; if ( @@v12@@ == @@v13@@ ) return __readfsqword ( Number ) ^ @@v18@@ ; } if ( ( unsigned int ) rpl_fcntl ( @@fildes@@ , Number , @@v12@@ , @@v9@@ , @@v10@@ , @@v11@@ , @@v17@@ . st_dev ) != Number ) return __readfsqword ( Number ) ^ @@v18@@ ; } LABEL_7 : @@v14@@ = quote ( @@a3@@ ) ; @@v15@@ = dcgettext ( Number L , String , Number ) ; @@v16@@ = __errno_location ( ) ; error ( Number , * @@v16@@ , @@v15@@ , @@v14@@ ) ; } return __readfsqword ( Number ) ^ @@v18@@ ; }
__int64 __fastcall print_s_short ( unsigned __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { __int64 @@v6@@ ; int @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; int @@v12@@ ; __int64 @@result@@ ; if ( @@a1@@ > @@a2@@ ) { @@v6@@ = @@a6@@ ; @@v8@@ = @@a6@@ * ( @@a1@@ - Number ) ; @@v9@@ = Number L ; @@v10@@ = @@a6@@ * ( @@a1@@ - Number ) ; do { @@v11@@ = @@v10@@ ; @@v12@@ = * ( __int16 * ) ( @@a3@@ + Number * @@v9@@ ) ; @@v10@@ -= @@v6@@ ; ++ @@v9@@ ; @@result@@ = xprintf ( @@a4@@ , @@a6@@ - ( unsigned int ) ( @@v11@@ / @@a1@@ ) + @@a5@@ , @@v12@@ , @@v8@@ , @@a5@@ , @@a6@@ - ( unsigned int ) ( @@v11@@ / @@a1@@ ) ) ; @@a6@@ = @@v11@@ / @@a1@@ ; } while ( @@a1@@ - @@a2@@ != @@v9@@ ) ; } return @@result@@ ; }
int __cdecl __noreturn main ( int @@argc@@ , const char * * @@argv@@ , const char * * envp ) { __int64 @@v3@@ ; char * @@v4@@ ; __uid_t @@v5@@ ; struct passwd * @@v6@@ ; set_program_name ( * @@argv@@ ) ; setlocale ( Number , String ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; parse_long_options ( @@argc@@ , ( _DWORD ) @@argv@@ , ( unsigned int ) String , ( unsigned int ) & unk_3AC2 , ( _DWORD ) Version , ( unsigned int ) usage , String , Number L ) ; if ( getopt_long ( @@argc@@ , ( char * const * ) @@argv@@ , String , Number L , Number L ) == Number ) { if ( optind == @@argc@@ ) { @@v5@@ = geteuid ( ) ; @@v6@@ = getpwuid ( @@v5@@ ) ; if ( @@v6@@ ) { puts ( @@v6@@ -> pw_name ) ; exit ( Number ) ; } dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; exit ( Number ) ; } @@v3@@ = quote ( @@argv@@ [ optind ] ) ; @@v4@@ = dcgettext ( Number L , String , Number ) ; error ( Number , Number , @@v4@@ , @@v3@@ ) ; } usage ( Number ) ; }
__int64 __fastcall skip ( __off_t @@offset@@ ) { unsigned int @@v1@@ ; FILE * @@v2@@ ; unsigned __int64 @@v3@@ ; int @@v4@@ ; int @@v5@@ ; int @@v6@@ ; unsigned __int64 @@v7@@ ; __int64 @@v8@@ ; char * @@v10@@ ; int * @@v11@@ ; struct stat @@v12@@ ; unsigned __int64 @@v13@@ ; @@v1@@ = Number ; @@v13@@ = __readfsqword ( Number ) ; if ( ! @@offset@@ ) return @@v1@@ ; @@v2@@ = in_stream ; if ( ! in_stream ) { LABEL_16 : @@v10@@ = dcgettext ( Number L , String , Number ) ; error ( Number , Number , @@v10@@ ) ; return @@v1@@ ; } @@v3@@ = @@offset@@ ; while ( Number ) { @@v6@@ = fileno ( @@v2@@ ) ; if ( __fxstat ( Number , @@v6@@ , & @@v12@@ ) ) { @@v11@@ = __errno_location ( ) ; @@v1@@ = Number ; error ( Number , * @@v11@@ , String , ( const char * ) input_filename ) ; goto LABEL_7 ; } if ( ( @@v12@@ . st_mode & Number ) != Number || @@v12@@ . st_size <= Number ) break ; if ( @@v12@@ . st_size >= @@v3@@ ) { if ( ( unsigned int ) rpl_fseeko ( @@v2@@ , @@v3@@ , Number ) ) @@v1@@ = Number ; return @@v1@@ ; } @@v3@@ -= @@v12@@ . st_size ; LABEL_7 : @@v4@@ = check_and_close ( Number ) & @@v1@@ ; @@v5@@ = open_next_file ( ) ; @@v2@@ = in_stream ; @@v1@@ = @@v5@@ & @@v4@@ ; if ( ! in_stream ) goto LABEL_16 ; } @@v7@@ = Number ; while ( Number ) { if ( @@v7@@ > @@v3@@ ) @@v7@@ = @@v3@@ ; @@v8@@ = __fread_unlocked_chk ( ) ; @@v3@@ -= @@v8@@ ; if ( @@v7@@ != @@v8@@ ) break ; if ( ! @@v3@@ ) return @@v1@@ ; } return Number ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
__off_t __fastcall skip_via_lseek ( __int64 @@a1@@ , int @@a2@@ , __off_t @@a3@@ , int @@a4@@ ) { int @@v6@@ ; __off_t @@v7@@ ; __int64 @@v9@@ ; char * @@v10@@ ; _QWORD @@v11@@ [ Number ] ; __int64 @@v12@@ [ Number ] ; @@v12@@ [ Number ] = __readfsqword ( Number ) ; @@v6@@ = ioctl ( @@a2@@ , Number , @@v11@@ ) ; @@v7@@ = lseek ( @@a2@@ , @@a3@@ , @@a4@@ ) ; if ( @@v7@@ >= Number && ! @@v6@@ && ! ioctl ( @@a2@@ , Number , @@v12@@ ) && @@v11@@ [ Number ] == @@v12@@ [ Number ] && @@v11@@ [ Number ] == @@v12@@ [ Number ] ) { @@v9@@ = @@v12@@ [ Number ] ; @@v7@@ = Number ; @@v10@@ = dcgettext ( Number L , String String , Number ) ; error ( Number , Number , @@v10@@ , @@a1@@ , @@v9@@ ) ; * __errno_location ( ) = Number ; } return @@v7@@ ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
unsigned __int64 process_signals ( ) { int @@v0@@ ; sigset_t @@_0@@ ; unsigned __int64 @@vars88@@ ; @@vars88@@ = __readfsqword ( Number ) ; while ( interrupt_signal || info_signal_count ) { while ( Number ) { sigprocmask ( Number , & caught_signals , & @@_0@@ ) ; @@v0@@ = interrupt_signal ; if ( info_signal_count ) -- info_signal_count ; sigprocmask ( Number , & @@_0@@ , Number L ) ; if ( @@v0@@ ) break ; print_stats ( ) ; if ( ! interrupt_signal && ! info_signal_count ) return __readfsqword ( Number ) ^ @@vars88@@ ; } cleanup ( ) ; print_stats ( ) ; raise ( @@v0@@ ) ; } return __readfsqword ( Number ) ^ @@vars88@@ ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
ssize_t __fastcall iread ( int @@fd@@ , void * @@buf@@ , size_t @@nbytes@@ ) { ssize_t @@v4@@ ; do { process_signals ( ) ; @@v4@@ = read ( @@fd@@ , @@buf@@ , @@nbytes@@ ) ; } while ( @@v4@@ < Number && * __errno_location ( ) == Number ) ; return @@v4@@ ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall gen_tempname_len ( char * @@filename@@ , int @@a2@@ , int @@a3@@ , int @@a4@@ , size_t @@a5@@ ) { size_t @@v7@@ ; void * @@v8@@ ; char * @@v9@@ ; int @@v10@@ ; int @@v11@@ ; unsigned int @@v12@@ ; int @@v13@@ ; int * @@v15@@ ; size_t @@v16@@ ; int @@v18@@ ; int @@v19@@ ; int @@oflag@@ ; int @@v21@@ ; struct stat @@v22@@ ; unsigned __int64 @@v23@@ ; @@v23@@ = __readfsqword ( Number ) ; @@v15@@ = __errno_location ( ) ; @@v21@@ = * @@v15@@ ; @@v7@@ = strlen ( @@filename@@ ) ; if ( @@a2@@ + @@a5@@ > @@v7@@ || ( @@v16@@ = @@v7@@ - @@a5@@ - @@a2@@ , @@a5@@ > strspn ( & @@filename@@ [ @@v16@@ ] , String ) ) ) { @@v12@@ = Number ; * @@v15@@ = Number ; return @@v12@@ ; } @@v8@@ = ( void * ) randint_all_new ( Number L , Number L ) ; if ( ! @@v8@@ ) return ( unsigned int ) Number ; LOBYTE ( @@a3@@ ) = @@a3@@ & Number | Number ; @@v19@@ = Number ; @@oflag@@ = @@a3@@ ; while ( Number ) { if ( @@a5@@ ) { @@v9@@ = & @@filename@@ [ @@v16@@ ] ; do * @@v9@@ ++ = letters [ randint_genmax ( @@v8@@ , Number L ) ] ; while ( @@v9@@ != & @@filename@@ [ @@a5@@ + @@v16@@ ] ) ; } if ( @@a4@@ == Number ) { @@v10@@ = mkdir ( @@filename@@ , Number ) ; goto LABEL_13 ; } if ( @@a4@@ == Number ) break ; if ( @@a4@@ ) __assert_fail ( String , String , Number , String ) ; @@v10@@ = open ( @@filename@@ , @@oflag@@ , Number L ) ; LABEL_13 : if ( @@v10@@ >= Number ) { @@v13@@ = @@v10@@ ; * @@v15@@ = @@v21@@ ; @@v11@@ = @@v21@@ ; goto LABEL_21 ; } @@v11@@ = * @@v15@@ ; if ( * @@v15@@ != Number ) { @@v13@@ = Number ; goto LABEL_21 ; } LABEL_15 : if ( ! -- @@v19@@ ) { randint_all_free ( @@v8@@ ) ; @@v12@@ = Number ; * @@v15@@ = Number ; return @@v12@@ ; } } if ( __lxstat ( Number , @@filename@@ , & @@v22@@ ) >= Number ) goto LABEL_15 ; @@v13@@ = Number ; @@v11@@ = * @@v15@@ ; if ( * @@v15@@ == Number ) { @@v13@@ = Number ; * @@v15@@ = @@v21@@ ; @@v11@@ = @@v21@@ ; } LABEL_21 : @@v18@@ = @@v13@@ ; randint_all_free ( @@v8@@ ) ; @@v12@@ = @@v18@@ ; * @@v15@@ = @@v11@@ ; return @@v12@@ ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
ssize_t __fastcall iread_fullblock ( int @@fd@@ , void * @@buf@@ , size_t @@nbytes@@ ) { size_t @@v4@@ ; __int64 @@v5@@ ; ssize_t @@result@@ ; if ( ! @@nbytes@@ ) return Number L ; @@v4@@ = @@nbytes@@ ; @@v5@@ = Number L ; while ( Number ) { @@result@@ = iread ( @@fd@@ , @@buf@@ , @@v4@@ ) ; if ( @@result@@ < Number ) break ; if ( @@result@@ ) { @@v5@@ += @@result@@ ; @@buf@@ = ( char * ) @@buf@@ + @@result@@ ; @@v4@@ -= @@result@@ ; if ( @@v4@@ ) continue ; } return @@v5@@ ; } return @@result@@ ; }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_2061F0 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061D0 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061E0 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
void __fastcall __noreturn quit ( int @@status@@ ) { cleanup ( ) ; print_stats ( ) ; process_signals ( ) ; exit ( @@status@@ ) ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
unsigned __int64 __fastcall iwrite_constprop_3 ( __int64 @@a1@@ , size_t @@a2@@ , int @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { unsigned __int64 @@v6@@ ; ssize_t @@v7@@ ; int @@v9@@ ; int @@v10@@ ; int @@v11@@ ; int @@v12@@ ; __off_t @@v13@@ ; __int64 @@v14@@ ; char * @@v15@@ ; int * @@v16@@ ; if ( ( output_flags & Number ) != Number && output_blocksize > @@a2@@ ) { @@v9@@ = rpl_fcntl ( Number , Number , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; BYTE1 ( @@v9@@ ) &= Number ; if ( ( unsigned int ) rpl_fcntl ( Number , Number , @@v9@@ , @@v10@@ , @@v11@@ , @@v12@@ ) ) { @@v14@@ = quote ( output_file ) ; @@v15@@ = dcgettext ( Number L , String , Number ) ; @@v16@@ = __errno_location ( ) ; error ( Number , * @@v16@@ , @@v15@@ , @@v14@@ ) ; } @@v13@@ = lseek ( Number , Number L , Number ) ; if ( @@v13@@ >= Number ) posix_fadvise ( Number , @@v13@@ , Number L , Number ) ; conversions_mask |= Number ; } @@v6@@ = Number L ; if ( ! @@a2@@ ) return @@v6@@ ; while ( Number ) { process_signals ( ) ; @@v7@@ = write ( Number , ( const void * ) ( @@a1@@ + @@v6@@ ) , @@a2@@ - @@v6@@ ) ; if ( @@v7@@ >= Number ) break ; if ( * __errno_location ( ) != Number ) return @@v6@@ ; LABEL_7 : if ( @@a2@@ <= @@v6@@ ) return @@v6@@ ; } if ( @@v7@@ ) { @@v6@@ += @@v7@@ ; goto LABEL_7 ; } * __errno_location ( ) = Number ; return @@v6@@ ; }
unsigned __int64 __fastcall isaac_seed ( __m128i * @@a1@@ ) { __int64 * @@v2@@ ; __m128i @@v3@@ ; unsigned __int64 @@result@@ ; __int64 @@v5@@ ; unsigned __int64 @@v6@@ ; @@v2@@ = & @@a1@@ -> m128i_i64 [ Number ] ; @@v6@@ = __readfsqword ( Number ) ; * ( @@v2@@ - Number ) = Number L ; @@v2@@ [ Number ] = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) & iv_3359 ) ; memset ( ( void * ) ( ( unsigned __int64 ) @@v2@@ & Number ) , Number , Number L * ( ( ( unsigned int ) @@a1@@ - ( ( unsigned int ) @@v2@@ & Number ) + Number ) >> Number ) ) ; @@a1@@ [ Number ] = @@v3@@ ; @@a1@@ [ Number ] . m128i_i64 [ Number ] = Number L ; @@a1@@ [ Number ] . m128i_i32 [ Number ] = Number ; @@a1@@ [ Number ] = _mm_load_si128 ( ( const __m128i * ) & xmmword_6990 ) ; LODWORD ( @@v5@@ ) = getpid ( ) ; isaac_seed_data ( ( unsigned int * ) @@a1@@ , ( __int64 ) & @@v5@@ , Number ) ; LODWORD ( @@v5@@ ) = getppid ( ) ; isaac_seed_data ( ( unsigned int * ) @@a1@@ , ( __int64 ) & @@v5@@ , Number ) ; LODWORD ( @@v5@@ ) = getuid ( ) ; isaac_seed_data ( ( unsigned int * ) @@a1@@ , ( __int64 ) & @@v5@@ , Number ) ; LODWORD ( @@v5@@ ) = getgid ( ) ; isaac_seed_data ( ( unsigned int * ) @@a1@@ , ( __int64 ) & @@v5@@ , Number ) ; @@v5@@ = gethrxtime ( ) ; isaac_seed_data ( ( unsigned int * ) @@a1@@ , ( __int64 ) & @@v5@@ , Number ) ; isaac_mix ( ( unsigned int * ) @@a1@@ , @@a1@@ ) ; isaac_mix ( ( unsigned int * ) @@a1@@ , @@a1@@ ) ; @@result@@ = __readfsqword ( Number ) ^ @@v6@@ ; @@a1@@ [ Number ] . m128i_i32 [ Number ] = Number ; return @@result@@ ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
int tcsetattr ( int @@fd@@ , int @@optional_actions@@ , const struct termios * @@termios_p@@ ) { return tcsetattr ( @@fd@@ , @@optional_actions@@ , @@termios_p@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void __fastcall copy_with_block ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 a3 , __int64 a4 , int @@a5@@ , int @@a6@@ ) { _BYTE * @@v6@@ ; _BYTE * @@v7@@ ; int @@v8@@ ; void * @@v9@@ ; __int64 @@v10@@ ; bool @@v11@@ ; int @@v12@@ ; __int64 @@v13@@ ; int @@v14@@ ; __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; if ( @@a2@@ ) { @@v6@@ = ( _BYTE * ) ( @@a1@@ + @@a2@@ ) ; @@v7@@ = ( _BYTE * ) @@a1@@ ; do { while ( Number ) { @@v16@@ = col ; if ( * @@v7@@ != newline_character ) break ; if ( conversion_blocksize > ( unsigned __int64 ) col ) { do { @@v12@@ = oc ; @@v13@@ = ( unsigned __int8 ) space_character ; @@v14@@ = ( int ) obuf ; @@v15@@ = oc + Number ; @@v11@@ = oc + Number < output_blocksize ; * ( ( _BYTE * ) obuf + oc ) = space_character ; oc = @@v15@@ ; if ( ! @@v11@@ ) write_output ( @@a1@@ , @@v13@@ , @@v12@@ , @@v14@@ , @@a5@@ , @@a6@@ ) ; ++ @@v16@@ ; } while ( conversion_blocksize > @@v16@@ ) ; } ++ @@v7@@ ; col = Number L ; if ( @@v6@@ == @@v7@@ ) return ; } if ( conversion_blocksize == col ) { ++ r_truncate ; } else if ( conversion_blocksize > ( unsigned __int64 ) col ) { @@v8@@ = oc ; @@v9@@ = obuf ; @@v10@@ = oc + Number ; @@v11@@ = oc + Number < output_blocksize ; * ( ( _BYTE * ) obuf + oc ) = * @@v7@@ ; oc = @@v10@@ ; if ( ! @@v11@@ ) { write_output ( @@a1@@ , ( __int64 ) @@v9@@ , @@v10@@ , @@v8@@ , @@a5@@ , @@a6@@ ) ; @@v16@@ = col ; } } ++ @@v7@@ ; col = @@v16@@ + Number ; } while ( @@v6@@ != @@v7@@ ) ; } }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
int ferror ( FILE * @@stream@@ ) { return ferror ( @@stream@@ ) ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
__int64 __fastcall mode_type_flag ( int @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; switch ( @@a1@@ ) { case Number : @@result@@ = @@a2@@ + Number ; break ; case Number : @@result@@ = @@a2@@ ; break ; case Number : @@result@@ = @@a2@@ + Number ; break ; case Number : @@result@@ = @@a2@@ + Number ; break ; case Number : @@result@@ = Number L ; break ; default : abort ( ) ; } return @@result@@ ; }
void __fastcall copy_with_unblock ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , __int64 a3 , __int64 a4 , int @@a5@@ , int @@a6@@ ) { _BYTE * @@v6@@ ; unsigned __int64 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; int @@v11@@ ; __int64 @@v12@@ ; bool @@v13@@ ; char @@v14@@ ; __int64 @@v15@@ ; bool @@v16@@ ; if ( @@a2@@ ) { @@v6@@ = @@a1@@ ; @@v8@@ = Number L ; while ( Number ) { @@v13@@ = col < ( unsigned __int64 ) conversion_blocksize ; @@v14@@ = @@v6@@ [ @@v8@@ ] ; ++ col ; if ( @@v13@@ ) { @@v11@@ = ( unsigned __int8 ) space_character ; if ( space_character == @@v14@@ ) { ++ pending_spaces_6894 ; } else { @@a1@@ = obuf ; @@v15@@ = oc ; @@v10@@ = output_blocksize ; if ( pending_spaces_6894 ) { while ( Number ) { @@v9@@ = @@v15@@ + Number ; @@a1@@ [ @@v15@@ ] = @@v11@@ ; oc = @@v15@@ + Number ; if ( @@v15@@ + Number < @@v10@@ ) { if ( ! -- pending_spaces_6894 ) goto LABEL_13 ; } else { write_output ( ( __int64 ) @@a1@@ , @@v10@@ , @@v9@@ , @@v11@@ , @@a5@@ , @@a6@@ ) ; @@v16@@ = pending_spaces_6894 -- == Number ; @@a1@@ = obuf ; @@v9@@ = oc ; @@v10@@ = output_blocksize ; if ( @@v16@@ ) goto LABEL_13 ; } @@v11@@ = ( unsigned __int8 ) space_character ; @@v15@@ = @@v9@@ ; } } @@v9@@ = oc ; LABEL_13 : @@a1@@ [ @@v9@@ ] = @@v14@@ ; oc = @@v9@@ + Number ; if ( @@v9@@ + Number >= @@v10@@ ) goto LABEL_14 ; } LABEL_4 : if ( @@a2@@ <= ++ @@v8@@ ) return ; } else { LODWORD ( @@v9@@ ) = oc ; -- @@v8@@ ; @@v10@@ = ( unsigned __int8 ) newline_character ; @@v11@@ = ( int ) obuf ; pending_spaces_6894 = Number L ; col = Number L ; @@v12@@ = oc + Number ; @@v13@@ = oc + Number < output_blocksize ; * ( ( _BYTE * ) obuf + oc ) = newline_character ; oc = @@v12@@ ; if ( @@v13@@ ) goto LABEL_4 ; LABEL_14 : ++ @@v8@@ ; write_output ( ( __int64 ) @@a1@@ , @@v10@@ , @@v9@@ , @@v11@@ , @@a5@@ , @@a6@@ ) ; if ( @@a2@@ <= @@v8@@ ) return ; } } } }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
int __fxstat ( int @@ver@@ , int @@fildes@@ , struct stat * @@stat_buf@@ ) { return _fxstat ( @@ver@@ , @@fildes@@ , @@stat_buf@@ ) ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
unsigned __int64 __fastcall set_window_size ( int @@a1@@ , int @@a2@@ , const char * @@a3@@ ) { int @@v5@@ ; int * @@v6@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; if ( ioctl ( Number , Number , & @@v8@@ ) ) { @@v5@@ = * __errno_location ( ) ; if ( @@v5@@ != Number ) error ( Number , @@v5@@ , String , @@a3@@ ) ; @@v8@@ = Number L ; } if ( @@a1@@ >= Number ) LOWORD ( @@v8@@ ) = @@a1@@ ; if ( @@a2@@ >= Number ) WORD1 ( @@v8@@ ) = @@a2@@ ; if ( ioctl ( Number , Number , & @@v8@@ ) ) { @@v6@@ = __errno_location ( ) ; error ( Number , * @@v6@@ , String , @@a3@@ ) ; } return __readfsqword ( Number ) ^ @@v9@@ ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; program_invocation_short_name = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
void __fastcall __noreturn xstrtol_fatal ( unsigned int @@a1@@ , int @@a2@@ , char @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ ) { int @@v7@@ ; const char * @@v8@@ ; char * @@v9@@ ; char * @@v10@@ ; char * @@v11@@ ; char @@v12@@ [ Number ] ; unsigned __int64 @@v13@@ ; @@v13@@ = __readfsqword ( Number ) ; @@v7@@ = exit_failure ; if ( @@a1@@ > Number ) { @@v8@@ = String ; if ( @@a1@@ != Number ) goto LABEL_7 ; } else if ( @@a1@@ >= Number ) { @@v8@@ = String ; } else { @@v8@@ = String ; if ( @@a1@@ != Number ) goto LABEL_7 ; } if ( @@a2@@ < Number ) { @@v12@@ [ Number ] = @@a3@@ ; @@v12@@ [ Number ] = Number ; @@v10@@ = @@v12@@ ; @@v9@@ = & asc_BCF8 [ - @@a2@@ ] ; } else { @@v9@@ = String ; @@v10@@ = * ( char * * ) ( @@a4@@ + Number L * @@a2@@ ) ; } @@v11@@ = dcgettext ( Number L , @@v8@@ , Number ) ; error ( @@v7@@ , Number , @@v11@@ , @@v9@@ , @@v10@@ , @@a5@@ ) ; LABEL_7 : abort ( ) ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
unsigned __int64 __fastcall print_named_ascii ( unsigned __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , const char * @@a4@@ , int @@a5@@ , int @@a6@@ ) { __int64 @@v7@@ ; __int64 @@v8@@ ; int @@v9@@ ; unsigned __int64 @@v10@@ ; char * @@v11@@ ; unsigned __int64 @@v12@@ ; unsigned __int8 @@v13@@ ; __int64 @@v15@@ ; char @@v16@@ [ Number ] ; unsigned __int64 @@v17@@ ; @@v17@@ = __readfsqword ( Number ) ; if ( @@a1@@ > @@a2@@ ) { @@v7@@ = @@a6@@ ; @@v8@@ = @@a3@@ ; @@v9@@ = @@a6@@ * ( @@a1@@ - Number ) ; LOBYTE ( @@v15@@ ) = @@a3@@ + @@a1@@ - @@a2@@ ; @@v10@@ = @@a6@@ * ( @@a1@@ - Number ) ; do { ++ @@v8@@ ; @@v11@@ = String ; @@v12@@ = @@v10@@ / @@a1@@ ; @@v13@@ = * ( _BYTE * ) ( @@v8@@ - Number ) & Number ; if ( @@v13@@ != Number ) { if ( @@v13@@ <= Number ) { @@a4@@ = String ; @@v11@@ = & charname [ Number * @@v13@@ ] ; } else { @@v16@@ [ Number ] = * ( _BYTE * ) ( @@v8@@ - Number ) & Number ; @@v16@@ [ Number ] = Number ; @@v11@@ = @@v16@@ ; } } @@v10@@ -= @@v7@@ ; xprintf ( ( unsigned int ) String , @@a6@@ - @@v12@@ + @@a5@@ , ( _DWORD ) @@v11@@ , ( _DWORD ) @@a4@@ , @@v9@@ , @@a6@@ - @@v12@@ , @@v15@@ ) ; @@a6@@ = @@v12@@ ; } while ( @@v8@@ != @@v15@@ ) ; } return __readfsqword ( Number ) ^ @@v17@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
__int64 __fastcall print_int ( unsigned __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { __int64 @@v6@@ ; int @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; int @@v12@@ ; __int64 @@result@@ ; if ( @@a1@@ > @@a2@@ ) { @@v6@@ = @@a6@@ ; @@v8@@ = @@a6@@ * ( @@a1@@ - Number ) ; @@v9@@ = Number L ; @@v10@@ = @@a6@@ * ( @@a1@@ - Number ) ; do { @@v11@@ = @@v10@@ ; @@v12@@ = * ( _DWORD * ) ( @@a3@@ + Number * @@v9@@ ) ; @@v10@@ -= @@v6@@ ; ++ @@v9@@ ; @@result@@ = xprintf ( @@a4@@ , @@a6@@ - ( unsigned int ) ( @@v11@@ / @@a1@@ ) + @@a5@@ , @@v12@@ , @@v8@@ , @@a5@@ , @@a6@@ - ( unsigned int ) ( @@v11@@ / @@a1@@ ) ) ; @@a6@@ = @@v11@@ / @@a1@@ ; } while ( @@a1@@ - @@a2@@ != @@v9@@ ) ; } return @@result@@ ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
int puts ( const char * @@s@@ ) { return puts ( @@s@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
unsigned __int64 __fastcall print_ascii ( unsigned __int64 @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 * @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; unsigned __int8 * @@v8@@ ; int @@v9@@ ; unsigned __int64 @@v10@@ ; const char * @@v11@@ ; unsigned __int8 * @@v13@@ ; int @@v15@@ ; char @@v16@@ ; unsigned __int64 @@v17@@ ; @@v17@@ = __readfsqword ( Number ) ; if ( @@a1@@ > @@a2@@ ) { @@v6@@ = @@a6@@ ; @@v7@@ = @@a6@@ * ( @@a1@@ - Number ) ; @@v8@@ = @@a3@@ ; @@v13@@ = & @@a3@@ [ @@a1@@ - @@a2@@ ] ; do { @@v9@@ = * @@v8@@ ++ ; @@v10@@ = @@v7@@ / @@a1@@ ; switch ( ( char ) @@v9@@ ) { case Number : @@v11@@ = String ; break ; case Number : @@v11@@ = String ; break ; case Number : @@v11@@ = String ; break ; case Number : @@v11@@ = String ; break ; case Number : @@v11@@ = String ; break ; case Number : @@v11@@ = String ; break ; case Number : @@v11@@ = String ; break ; case Number : @@v11@@ = ( const char * ) & unk_99B7 ; break ; default : @@v15@@ = @@a6@@ ; __ctype_b_loc ( ) ; __sprintf_chk ( ) ; @@a6@@ = @@v15@@ ; @@v11@@ = & @@v16@@ ; break ; } @@v7@@ -= @@v6@@ ; xprintf ( ( unsigned int ) String , @@a6@@ - @@v10@@ + @@a5@@ , ( _DWORD ) @@v11@@ , @@a4@@ , @@v9@@ , @@a6@@ - @@v10@@ , @@v13@@ ) ; @@a6@@ = @@v10@@ ; } while ( @@v8@@ != @@v13@@ ) ; } return __readfsqword ( Number ) ^ @@v17@@ ; }
int fgetc ( FILE * @@stream@@ ) { return fgetc ( @@stream@@ ) ; }
__int64 __fastcall fd_reopen ( int @@fd2@@ , char * @@file@@ , int @@oflag@@ , unsigned int @@a4@@ ) { int @@v4@@ ; unsigned int @@v5@@ ; int @@v6@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; @@v4@@ = open ( @@file@@ , @@oflag@@ , @@a4@@ ) ; @@v5@@ = @@v4@@ ; if ( @@fd2@@ != @@v4@@ && @@v4@@ >= Number ) { @@v6@@ = dup2 ( @@v4@@ , @@fd2@@ ) ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; close ( @@v5@@ ) ; @@v5@@ = @@v6@@ ; * @@v9@@ = @@v8@@ ; } return @@v5@@ ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
int __fastcall format_address_label ( unsigned __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { format_address_std ( @@a1@@ , Number ) ; return format_address_paren ( pseudo_offset + @@a1@@ , @@a2@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
bool __fastcall parse_old_offset ( char * @@nptr@@ ) { char * @@v1@@ ; if ( ! * @@nptr@@ ) return Number ; @@v1@@ = @@nptr@@ ; if ( * @@nptr@@ == Number ) @@v1@@ = @@nptr@@ + Number ; strchr ( @@v1@@ , Number ) ; return ( unsigned int ) xstrtoumax ( @@v1@@ ) == Number ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; program_invocation_short_name = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
__int64 __fastcall rpl_fcntl ( int @@a1@@ , int @@a2@@ , __int64 @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { int @@v6@@ ; int @@v8@@ ; int @@v9@@ ; int @@v10@@ ; int @@v11@@ ; int * @@v12@@ ; int @@v13@@ ; int * @@v14@@ ; int @@v15@@ ; @@v15@@ = @@a3@@ ; if ( @@a2@@ != Number ) return ( unsigned int ) fcntl ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( have_dupfd_cloexec_3202 < Number ) { @@v6@@ = rpl_fcntl ( @@a1@@ , Number , ( unsigned int ) @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( @@v6@@ < Number || have_dupfd_cloexec_3202 != Number ) return ( unsigned int ) @@v6@@ ; } else { @@v6@@ = fcntl ( @@a1@@ , Number , ( unsigned int ) @@a3@@ ) ; if ( @@v6@@ >= Number || * __errno_location ( ) != Number ) { have_dupfd_cloexec_3202 = Number ; return ( unsigned int ) @@v6@@ ; } @@v6@@ = rpl_fcntl ( @@a1@@ , Number , @@v15@@ , @@v8@@ , @@v9@@ , @@v10@@ ) ; if ( @@v6@@ < Number ) return ( unsigned int ) @@v6@@ ; have_dupfd_cloexec_3202 = Number ; } @@v11@@ = fcntl ( @@v6@@ , Number ) ; if ( @@v11@@ < Number || fcntl ( @@v6@@ , Number , @@v11@@ | Number ) == Number ) { @@v12@@ = __errno_location ( ) ; @@v13@@ = * @@v12@@ ; @@v14@@ = @@v12@@ ; close ( @@v6@@ ) ; @@v6@@ = Number ; * @@v14@@ = @@v13@@ ; } return ( unsigned int ) @@v6@@ ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
__int64 __fastcall print_float ( unsigned __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { __int64 @@v6@@ ; int @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; unsigned __int64 @@v12@@ ; unsigned __int64 @@v13@@ ; double @@v14@@ ; __int64 @@result@@ ; if ( @@a1@@ > @@a2@@ ) { @@v6@@ = @@a6@@ ; @@v8@@ = @@a6@@ * ( @@a1@@ - Number ) ; @@v9@@ = Number L ; @@v10@@ = @@a6@@ * ( @@a1@@ - Number ) ; do { @@v13@@ = @@v10@@ ; @@v11@@ = @@v10@@ / @@a1@@ ; @@v12@@ = @@v10@@ % @@a1@@ ; @@v10@@ -= @@v6@@ ; @@v14@@ = * ( float * ) ( @@a3@@ + Number * @@v9@@ ++ ) ; @@result@@ = xprintf ( @@a4@@ , @@a6@@ - ( int ) @@v11@@ + @@a5@@ , @@v12@@ , @@v8@@ , @@a5@@ , @@a6@@ - ( int ) @@v11@@ , @@v14@@ ) ; @@a6@@ = @@v13@@ / @@a1@@ ; } while ( @@a1@@ - @@a2@@ != @@v9@@ ) ; } return @@result@@ ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
__syscall_slong_t gethrxtime ( ) { struct timespec @@v1@@ ; unsigned __int64 @@v2@@ ; @@v2@@ = __readfsqword ( Number ) ; if ( clock_gettime ( Number , & @@v1@@ ) ) gettime ( & @@v1@@ ) ; return @@v1@@ . tv_nsec + Number * @@v1@@ . tv_sec ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
long double __fastcall adjust_value_part_0 ( int @@a1@@ , long double @@a2@@ ) { unsigned __int64 @@v7@@ ; long double @@v8@@ ; long double @@result@@ ; if ( @@a2@@ >= Number ) @@v7@@ = ( __int64 ) ( @@a2@@ - Number ) ^ Number ; else @@v7@@ = ( __int64 ) @@a2@@ ; @@v8@@ = ( long double ) @@v7@@ ; if ( @@a1@@ ) return @@v8@@ ; @@result@@ = @@v8@@ ; if ( @@a2@@ != @@v8@@ ) @@result@@ = ( long double ) ( @@v7@@ + Number ) ; return @@result@@ ; }
__int64 __fastcall print_s_char ( unsigned __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , int @@a5@@ , int @@a6@@ ) { __int64 @@v6@@ ; __int64 @@v7@@ ; int @@v8@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; __int64 @@result@@ ; __int64 @@v14@@ ; if ( @@a1@@ > @@a2@@ ) { @@v6@@ = @@a6@@ ; @@v7@@ = @@a3@@ ; @@v8@@ = @@a6@@ * ( @@a1@@ - Number ) ; @@v14@@ = @@a3@@ + @@a1@@ - @@a2@@ ; @@v10@@ = @@a6@@ * ( @@a1@@ - Number ) ; do { ++ @@v7@@ ; @@v11@@ = @@v10@@ ; @@v10@@ -= @@v6@@ ; @@result@@ = xprintf ( @@a4@@ , @@a6@@ - ( unsigned int ) ( @@v11@@ / @@a1@@ ) + @@a5@@ , * ( char * ) ( @@v7@@ - Number ) , @@v8@@ , @@a5@@ , @@a6@@ - ( unsigned int ) ( @@v11@@ / @@a1@@ ) , @@a4@@ ) ; @@a6@@ = @@v11@@ / @@a1@@ ; } while ( @@v7@@ != @@v14@@ ) ; } return @@result@@ ; }
int __fastcall rpl_fseeko ( FILE * @@stream@@ , __off_t @@offset@@ , int @@whence@@ ) { int @@v5@@ ; int @@v6@@ ; if ( @@stream@@ -> _IO_read_end != @@stream@@ -> _IO_read_ptr || @@stream@@ -> _IO_write_ptr != @@stream@@ -> _IO_write_base || @@stream@@ -> _IO_save_base ) { return fseeko ( @@stream@@ , @@offset@@ , @@whence@@ ) ; } if ( @@whence@@ == Number && @@offset@@ > Number ) { @@v5@@ = fileno ( @@stream@@ ) ; if ( lseek ( @@v5@@ , Number L , Number ) != Number ) { @@stream@@ -> _flags &= Number ; return fseeko ( @@stream@@ , @@offset@@ , @@whence@@ ) ; } } else { @@v6@@ = fileno ( @@stream@@ ) ; if ( lseek ( @@v6@@ , @@offset@@ , @@whence@@ ) != Number ) { @@stream@@ -> _flags &= Number ; return Number ; } } return Number ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 __fastcall human_options ( char * @@nptr@@ , int * @@a2@@ , unsigned __int64 * @@a3@@ ) { char * @@v4@@ ; int @@v5@@ ; int @@v6@@ ; int @@v7@@ ; __int64 @@result@@ ; unsigned __int64 @@v9@@ ; char * @@v10@@ [ Number ] ; @@v4@@ = @@nptr@@ ; @@v10@@ [ Number ] = ( char * ) __readfsqword ( Number ) ; if ( @@nptr@@ || ( @@v4@@ = getenv ( String ) ) != Number L || ( @@v4@@ = getenv ( String ) ) != Number L ) { @@v5@@ = Number ; if ( * @@v4@@ == Number ) { ++ @@v4@@ ; @@v5@@ = Number ; } @@v6@@ = argmatch ( @@v4@@ , block_size_args , block_size_opts , Number L ) ; if ( @@v6@@ >= Number ) { * @@a3@@ = Number L ; @@v7@@ = block_size_opts [ @@v6@@ ] | @@v5@@ ; @@result@@ = Number L ; * @@a2@@ = @@v7@@ ; return @@result@@ ; } @@result@@ = xstrtoumax ( @@v4@@ , @@v10@@ , Number , @@a3@@ , String ) ; if ( ( _DWORD ) @@result@@ ) { @@v9@@ = * @@a3@@ ; * @@a2@@ = Number ; LABEL_15 : if ( ! @@v9@@ ) { * @@a3@@ = getenv ( String ) == Number L ? Number L : Number L ; @@result@@ = Number L ; } return @@result@@ ; } if ( ( unsigned __int8 ) ( * @@v4@@ - Number ) > Number ) { if ( @@v4@@ != @@v10@@ [ Number ] ) { while ( ( unsigned __int8 ) ( * ++ @@v4@@ - Number ) > Number ) { if ( @@v4@@ == @@v10@@ [ Number ] ) goto LABEL_22 ; } goto LABEL_13 ; } LABEL_22 : if ( * ( @@v10@@ [ Number ] - Number ) == Number ) { @@v5@@ |= Number ; if ( * ( @@v10@@ [ Number ] - Number ) != Number ) goto LABEL_13 ; } else { LOBYTE ( @@v5@@ ) = @@v5@@ | Number ; } @@v5@@ |= Number ; } LABEL_13 : @@v9@@ = * @@a3@@ ; * @@a2@@ = @@v5@@ ; goto LABEL_15 ; } if ( getenv ( String ) ) * @@a3@@ = Number L ; else * @@a3@@ = Number L ; @@result@@ = Number L ; * @@a2@@ = Number ; return @@result@@ ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
void __fastcall write_block ( __int64 @@a1@@ , __int64 @@a2@@ , const void * @@a3@@ , unsigned __int8 * @@a4@@ ) { __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; unsigned __int8 * @@v6@@ ; char * @@v7@@ ; unsigned __int64 @@v8@@ ; size_t @@v9@@ ; size_t @@v10@@ ; unsigned __int8 * @@v11@@ ; const unsigned __int16 * * @@v12@@ ; __int64 @@v13@@ ; char @@v14@@ ; int @@v15@@ ; char * @@v16@@ ; char * @@v17@@ ; if ( abbreviate_duplicate_blocks && ! first_6849 && bytes_per_block == @@a2@@ && ! memcmp ( @@a3@@ , @@a4@@ , bytes_per_block ) ) { if ( ! prev_pair_equal_6850 ) { puts ( String ) ; prev_pair_equal_6850 = Number ; } } else { prev_pair_equal_6850 = Number ; if ( n_specs ) { @@v4@@ = Number L ; @@v5@@ = Number L ; @@v6@@ = & @@a4@@ [ @@a2@@ ] ; do { @@v8@@ = width_bytes [ * ( unsigned int * ) ( spec + @@v4@@ + Number ) ] ; @@v9@@ = bytes_per_block / @@v8@@ ; @@v10@@ = ( bytes_per_block - @@a2@@ ) / @@v8@@ ; if ( @@v5@@ ) __printf_chk ( ) ; else format_address ( @@a1@@ , Number L ) ; ( * ( void ( __fastcall * * ) ( _QWORD , _QWORD , unsigned __int8 * , __int64 , _QWORD , _QWORD ) ) ( @@v4@@ + spec + Number ) ) ( ( int ) @@v9@@ , ( int ) @@v10@@ , @@a4@@ , @@v4@@ + spec + Number , * ( unsigned int * ) ( @@v4@@ + spec + Number ) , * ( unsigned int * ) ( @@v4@@ + spec + Number ) ) ; if ( * ( _BYTE * ) ( @@v4@@ + spec + Number ) ) { __printf_chk ( ) ; fwrite_unlocked ( String , Number , Number , stdout ) ; if ( @@a2@@ ) { @@v11@@ = @@a4@@ ; @@v12@@ = __ctype_b_loc ( ) ; do { @@v13@@ = * @@v11@@ ++ ; @@v14@@ = * ( @@v11@@ - Number ) ; @@v15@@ = ( unsigned __int8 ) @@v13@@ ; if ( ( ( * @@v12@@ ) [ @@v13@@ ] & Number ) == Number ) { @@v15@@ = Number ; @@v14@@ = Number ; } @@v16@@ = stdout -> _IO_write_ptr ; if ( @@v16@@ >= stdout -> _IO_write_end ) { __overflow ( stdout , @@v15@@ ) ; } else { stdout -> _IO_write_ptr = @@v16@@ + Number ; * @@v16@@ = @@v14@@ ; } } while ( @@v11@@ != @@v6@@ ) ; } @@v17@@ = stdout -> _IO_write_ptr ; if ( @@v17@@ >= stdout -> _IO_write_end ) { __overflow ( stdout , Number ) ; } else { stdout -> _IO_write_ptr = @@v17@@ + Number ; * @@v17@@ = Number ; } } @@v7@@ = stdout -> _IO_write_ptr ; if ( @@v7@@ >= stdout -> _IO_write_end ) { __overflow ( stdout , Number ) ; } else { stdout -> _IO_write_ptr = @@v7@@ + Number ; * @@v7@@ = Number ; } ++ @@v5@@ ; @@v4@@ += Number L ; } while ( n_specs > @@v5@@ ) ; } } first_6849 = Number ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_20E330 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20E310 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_20E320 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; __int64 @@v14@@ ; __int64 @@v15@@ ; __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; _BYTE * @@v18@@ ; unsigned __int64 @@v21@@ ; int @@v22@@ ; int @@v23@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v22@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v23@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v21@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v23@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v21@@ <= @@v13@@ ) { @@v17@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v18@@ = ( _BYTE * ) xmalloc ( @@v17@@ , @@v17@@ , @@v14@@ , @@v15@@ , @@v16@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v18@@ ; @@v12@@ = @@v18@@ ; quotearg_buffer_restyled ( @@v18@@ , @@v17@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v23@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v22@@ ; return @@v12@@ ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
__int64 __fastcall rpl_vprintf ( __int64 @@a1@@ , __int64 @@a2@@ ) { return rpl_vfprintf ( stdout , @@a1@@ , @@a2@@ ) ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
void __fastcall fseterr ( _DWORD * @@a1@@ ) { * @@a1@@ |= Number ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
__int64 __fastcall sha1_init_ctx ( _QWORD * @@a1@@ ) { __int64 @@result@@ ; @@a1@@ [ Number ] = Number L ; * @@a1@@ = Number ; @@a1@@ [ Number ] = Number ; @@result@@ = Number L ; @@a1@@ [ Number ] = Number L ; return @@result@@ ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_20C490 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20C470 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_20C480 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 __fastcall sha1_stream ( FILE * @@stream@@ , _DWORD * @@a2@@ ) { char * @@v2@@ ; __int64 @@result@@ ; size_t @@v4@@ ; int @@v5@@ ; size_t @@v6@@ ; __m128i @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; @@v10@@ = __readfsqword ( Number ) ; @@v2@@ = ( char * ) malloc ( Number ) ; @@result@@ = Number L ; if ( @@v2@@ ) { @@v9@@ = Number L ; @@v7@@ . m128i_i64 [ Number ] = Number ; @@v7@@ . m128i_i64 [ Number ] = Number ; @@v8@@ = Number L ; LABEL_3 : @@v4@@ = Number L ; while ( Number ) { @@v6@@ = fread_unlocked ( & @@v2@@ [ @@v4@@ ] , Number , Number - @@v4@@ , @@stream@@ ) ; @@v4@@ += @@v6@@ ; if ( @@v4@@ == Number ) { sha1_process_block ( ( unsigned __int64 ) @@v2@@ , Number , @@v7@@ . m128i_i32 ) ; goto LABEL_3 ; } @@v5@@ = @@stream@@ -> _flags ; if ( ! @@v6@@ ) break ; if ( ( @@v5@@ & Number ) != Number ) goto LABEL_9 ; } if ( ( @@v5@@ & Number ) != Number ) { free ( @@v2@@ ) ; return Number L ; } LABEL_9 : if ( @@v4@@ ) sha1_process_bytes ( @@v2@@ , @@v4@@ , & @@v7@@ ) ; sha1_finish_ctx ( @@v7@@ . m128i_i32 , @@a2@@ ) ; free ( @@v2@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; FILE * @@v11@@ ; char * @@v12@@ ; FILE * @@v13@@ ; char * @@v14@@ ; FILE * @@v15@@ ; char * @@v16@@ ; char * @@v17@@ ; FILE * @@v18@@ ; char * @@v19@@ ; char * @@v20@@ ; char * @@v21@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String String String String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String String String String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = stdout ; @@v10@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; @@v11@@ = stdout ; @@v12@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v12@@ , @@v11@@ ) ; @@v13@@ = stdout ; @@v14@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v14@@ , @@v13@@ ) ; @@v15@@ = stdout ; @@v16@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v16@@ , @@v15@@ ) ; @@v17@@ = dcgettext ( Number L , String String String String , Number ) ; __printf_chk ( ) ; last_component ( program_name , @@v17@@ ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v18@@ = stdout ; @@v19@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v19@@ , @@v18@@ ) ; @@v20@@ = Number L ; @@v21@@ = setlocale ( Number , Number L ) ; if ( @@v21@@ ) { @@v20@@ = String ; if ( strncmp ( @@v21@@ , String , Number ) ) { last_component ( program_name , String ) ; @@v20@@ = dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name , @@v20@@ ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
void __fastcall check_order_isra_1_part_2 ( __int64 * @@a1@@ , __int64 * @@a2@@ , __int64 * @@a3@@ , __int64 * @@a4@@ , unsigned int @@a5@@ ) { __int64 @@v5@@ ; __int64 @@v8@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; __int64 @@v12@@ ; __int64 @@v13@@ ; __int64 @@v14@@ ; int @@v15@@ ; char * @@v16@@ ; @@v5@@ = ( int ) ( @@a5@@ - Number ) ; if ( ! * ( ( _BYTE * ) & issued_disorder_warning + @@v5@@ ) ) { @@v8@@ = * @@a1@@ ; @@v10@@ = * @@a3@@ ; @@v11@@ = * @@a2@@ ; @@v12@@ = * @@a4@@ ; @@v13@@ = @@v8@@ - Number ; @@v14@@ = @@v10@@ - Number ; if ( hard_LC_COLLATE ) @@v15@@ = xmemcoll ( @@v11@@ , @@v13@@ , @@v12@@ , @@v14@@ ) ; else @@v15@@ = memcmp2 ( @@v11@@ , @@v13@@ , @@v12@@ , @@v14@@ ) ; if ( @@v15@@ > Number ) { @@v16@@ = dcgettext ( Number L , String , Number ) ; error ( check_input_order == Number , Number , @@v16@@ , @@a5@@ ) ; * ( ( _BYTE * ) & issued_disorder_warning + @@v5@@ ) = Number ; } } }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
_QWORD * __fastcall readlinebuffer ( _QWORD * @@a1@@ , _IO_FILE * @@a2@@ ) { return readlinebuffer_delim ( @@a1@@ , @@a2@@ , Number ) ; }
__int64 __fastcall fd_reopen ( int @@fd2@@ , char * @@file@@ , int @@oflag@@ , unsigned int @@a4@@ ) { int @@v4@@ ; unsigned int @@v5@@ ; int @@v6@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; @@v4@@ = open ( @@file@@ , @@oflag@@ , @@a4@@ ) ; @@v5@@ = @@v4@@ ; if ( @@fd2@@ != @@v4@@ && @@v4@@ >= Number ) { @@v6@@ = dup2 ( @@v4@@ , @@fd2@@ ) ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; close ( @@v5@@ ) ; @@v5@@ = @@v6@@ ; * @@v9@@ = @@v8@@ ; } return @@v5@@ ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
int __fastcall memcmp2 ( const void * @@a1@@ , size_t @@a2@@ , const void * @@a3@@ , size_t @@a4@@ ) { size_t @@v6@@ ; int @@result@@ ; @@v6@@ = @@a4@@ ; if ( @@a2@@ <= @@a4@@ ) @@v6@@ = @@a2@@ ; @@result@@ = memcmp ( @@a1@@ , @@a3@@ , @@v6@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ < @@a4@@ ) @@result@@ = Number ; else @@result@@ = @@a2@@ > @@a4@@ ; } return @@result@@ ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
FILE * __fastcall fopen_safer ( const char * @@a1@@ , const char * @@a2@@ ) { FILE * @@v2@@ ; FILE * @@v3@@ ; unsigned int @@v4@@ ; int @@v6@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; int * @@v10@@ ; int @@v11@@ ; int * @@v12@@ ; @@v2@@ = fopen ( @@a1@@ , @@a2@@ ) ; @@v3@@ = @@v2@@ ; if ( @@v2@@ ) { @@v4@@ = fileno ( @@v2@@ ) ; if ( @@v4@@ <= Number ) { @@v6@@ = dup_safer ( @@v4@@ ) ; if ( @@v6@@ < Number ) { @@v10@@ = __errno_location ( ) ; @@v11@@ = * @@v10@@ ; @@v12@@ = @@v10@@ ; fclose ( @@v3@@ ) ; @@v3@@ = Number L ; * @@v12@@ = @@v11@@ ; } else if ( fclose ( @@v3@@ ) || ( @@v3@@ = fdopen ( @@v6@@ , @@a2@@ ) ) == Number L ) { @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; close ( @@v6@@ ) ; * @@v9@@ = @@v8@@ ; @@v3@@ = Number L ; } } } return @@v3@@ ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall xmemcoll ( void * @@a1@@ , size_t @@a2@@ , void * @@a3@@ , __int64 @@a4@@ ) { unsigned int @@v6@@ ; int @@v7@@ ; char * @@v8@@ ; char * @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; char * @@v12@@ ; @@v6@@ = memcoll ( @@a1@@ , @@a2@@ , @@a3@@ ) ; @@v7@@ = * __errno_location ( ) ; if ( @@v7@@ ) { @@v8@@ = dcgettext ( Number L , String , Number ) ; error ( Number , @@v7@@ , @@v8@@ ) ; @@v9@@ = dcgettext ( Number L , String , Number ) ; error ( Number , Number , @@v9@@ ) ; @@v10@@ = quotearg_n_style_mem ( Number L , Number L , @@a3@@ , @@a4@@ ) ; @@v11@@ = quotearg_n_style_mem ( Number L , Number L , @@a1@@ , @@a2@@ ) ; @@v12@@ = dcgettext ( Number L , String , Number ) ; error ( exit_failure , Number , @@v12@@ , @@v11@@ , @@v10@@ ) ; } return @@v6@@ ; }
__int64 __fastcall argmatch ( const char * @@a1@@ , const char * * @@a2@@ , char * @@a3@@ , size_t @@a4@@ ) { char * @@v5@@ ; size_t @@v6@@ ; const char * @@v7@@ ; size_t @@v8@@ ; __int64 @@v9@@ ; bool @@v10@@ ; char @@v11@@ ; __int64 @@v12@@ ; __int64 @@v14@@ ; char @@v15@@ ; @@v5@@ = @@a3@@ ; @@v6@@ = strlen ( @@a1@@ ) ; @@v7@@ = * @@a2@@ ; @@v14@@ = Number ; if ( ! * @@a2@@ ) return @@v14@@ ; @@v8@@ = @@v6@@ ; @@v15@@ = Number ; @@v9@@ = Number L ; do { while ( strncmp ( @@v7@@ , @@a1@@ , @@v8@@ ) ) { LABEL_7 : ++ @@v9@@ ; @@v5@@ += @@a4@@ ; @@v7@@ = @@a2@@ [ @@v9@@ ] ; if ( ! @@v7@@ ) goto LABEL_12 ; } if ( strlen ( @@v7@@ ) == @@v8@@ ) return @@v9@@ ; if ( @@v14@@ != Number ) { if ( @@a3@@ ) { @@v10@@ = memcmp ( & @@a3@@ [ @@a4@@ * @@v14@@ ] , @@v5@@ , @@a4@@ ) == Number ; @@v11@@ = @@v15@@ ; if ( ! @@v10@@ ) @@v11@@ = Number ; @@v15@@ = @@v11@@ ; } else { @@v15@@ = Number ; } goto LABEL_7 ; } @@v14@@ = @@v9@@ ++ ; @@v5@@ += @@a4@@ ; @@v7@@ = @@a2@@ [ @@v9@@ ] ; } while ( @@v7@@ ) ; LABEL_12 : @@v12@@ = Number ; if ( ! @@v15@@ ) @@v12@@ = @@v14@@ ; return @@v12@@ ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
char * strdup ( const char * @@s@@ ) { return strdup ( @@s@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
bool __fastcall hard_locale ( int @@a1@@ ) { char * @@v1@@ ; bool @@result@@ ; @@v1@@ = setlocale ( @@a1@@ , Number L ) ; @@result@@ = Number ; if ( @@v1@@ ) { @@result@@ = Number ; if ( strcmp ( @@v1@@ , String ) ) @@result@@ = strcmp ( @@v1@@ , String ) != Number ; } return @@result@@ ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; FILE * @@v11@@ ; char * @@v12@@ ; FILE * @@v13@@ ; char * @@v14@@ ; char * @@v15@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String String String String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; dcgettext ( Number L , String String String String String , Number ) ; __fprintf_chk ( ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = stdout ; @@v10@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; @@v11@@ = stdout ; @@v12@@ = dcgettext ( Number L , String String String , Number ) ; fputs_unlocked ( @@v12@@ , @@v11@@ ) ; last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v13@@ = stdout ; @@v14@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v14@@ , @@v13@@ ) ; @@v15@@ = setlocale ( Number , Number L ) ; if ( @@v15@@ ) { if ( strncmp ( @@v15@@ , String , Number ) ) { last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
time_t time ( time_t * @@timer@@ ) { return time ( @@timer@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_2071F0 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2071D0 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2071E0 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
unsigned __int64 __fastcall fprintftime ( FILE * @@a1@@ , unsigned __int8 * @@a2@@ , __int64 @@a3@@ , unsigned int @@a4@@ , unsigned int @@a5@@ ) { return strftime_case_ ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
unsigned __int64 __fastcall format_address_std ( unsigned __int64 @@a1@@ , char @@a2@@ ) { const char * @@v3@@ ; char * @@v4@@ ; char * @@v5@@ ; char @@v7@@ ; char @@v8@@ ; char @@v9@@ [ Number ] ; unsigned __int64 @@v10@@ ; @@v10@@ = __readfsqword ( Number ) ; @@v3@@ = @@v9@@ ; @@v9@@ [ Number ] = @@a2@@ ; @@v9@@ [ Number ] = Number ; @@v4@@ = & @@v9@@ [ - address_pad_len ] ; switch ( address_base ) { case Number : do { * -- @@v3@@ = @@a1@@ % Number + Number ; @@a1@@ /= Number ; } while ( @@a1@@ ) ; break ; case Number : do { @@v8@@ = @@a1@@ ; @@a1@@ >>= Number ; * -- @@v3@@ = a0123456789abcd [ @@v8@@ & Number ] ; } while ( @@a1@@ ) ; break ; case Number : do { @@v7@@ = @@a1@@ ; @@a1@@ >>= Number ; * -- @@v3@@ = ( @@v7@@ & Number ) + Number ; } while ( @@a1@@ ) ; break ; } @@v5@@ = ( char * ) @@v3@@ ; if ( @@v4@@ < @@v3@@ ) { do * -- @@v5@@ = Number ; while ( @@v4@@ != @@v5@@ ) ; @@v3@@ = @@v4@@ ; } fputs_unlocked ( @@v3@@ , stdout ) ; return __readfsqword ( Number ) ^ @@v10@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
__int64 __fastcall print_short ( unsigned __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { __int64 @@v6@@ ; int @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; int @@v12@@ ; __int64 @@result@@ ; if ( @@a1@@ > @@a2@@ ) { @@v6@@ = @@a6@@ ; @@v8@@ = @@a6@@ * ( @@a1@@ - Number ) ; @@v9@@ = Number L ; @@v10@@ = @@a6@@ * ( @@a1@@ - Number ) ; do { @@v11@@ = @@v10@@ ; @@v12@@ = * ( unsigned __int16 * ) ( @@a3@@ + Number * @@v9@@ ) ; @@v10@@ -= @@v6@@ ; ++ @@v9@@ ; @@result@@ = xprintf ( @@a4@@ , @@a6@@ - ( unsigned int ) ( @@v11@@ / @@a1@@ ) + @@a5@@ , @@v12@@ , @@v8@@ , @@a5@@ , @@a6@@ - ( unsigned int ) ( @@v11@@ / @@a1@@ ) ) ; @@a6@@ = @@v11@@ / @@a1@@ ; } while ( @@a1@@ - @@a2@@ != @@v9@@ ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_20C490 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20C470 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20C480 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_20D230 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20D210 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20D220 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
__int64 __fastcall check_and_close ( int @@errnum@@ ) { unsigned int @@v1@@ ; char * @@v2@@ ; __int64 @@v4@@ ; char * @@v5@@ ; int * @@v6@@ ; @@v1@@ = Number ; if ( in_stream ) { if ( ( in_stream -> _flags & Number ) != Number ) { @@v4@@ = input_filename ; @@v5@@ = dcgettext ( Number L , String , Number ) ; error ( Number , @@errnum@@ , @@v5@@ , @@v4@@ ) ; @@v1@@ = Number ; if ( strcmp ( * ( const char * * ) ( file_list - Number ) , String ) ) fclose ( in_stream ) ; } else if ( ! strcmp ( * ( const char * * ) ( file_list - Number ) , String ) || ! fclose ( in_stream ) ) { @@v1@@ = Number ; } else { @@v6@@ = __errno_location ( ) ; @@v1@@ = Number ; error ( Number , * @@v6@@ , String , ( const char * ) input_filename ) ; } in_stream = Number L ; } if ( ( stdout -> _flags & Number ) != Number ) { @@v1@@ = Number ; @@v2@@ = dcgettext ( Number L , String , Number ) ; error ( Number , Number , @@v2@@ ) ; } return @@v1@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 __fastcall umaxtostr ( unsigned __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; @@v2@@ = @@a2@@ + Number ; * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; do { * ( _BYTE * ) -- @@v2@@ = @@a1@@ % Number + Number ; @@a1@@ /= Number ; } while ( @@a1@@ ) ; return @@v2@@ ; }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
int __fastcall format_address_paren ( unsigned __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { char * @@v2@@ ; char * @@v3@@ ; @@v2@@ = stdout -> _IO_write_ptr ; if ( @@v2@@ >= stdout -> _IO_write_end ) { __overflow ( stdout , Number ) ; } else { stdout -> _IO_write_ptr = @@v2@@ + Number ; * @@v2@@ = Number ; } LODWORD ( @@v3@@ ) = format_address_std ( @@a1@@ , Number ) ; if ( @@a2@@ ) { @@v3@@ = stdout -> _IO_write_ptr ; if ( @@v3@@ >= stdout -> _IO_write_end ) { LODWORD ( @@v3@@ ) = __overflow ( stdout , @@a2@@ ) ; } else { stdout -> _IO_write_ptr = @@v3@@ + Number ; * @@v3@@ = @@a2@@ ; } } return ( int ) @@v3@@ ; }
int raise ( int @@sig@@ ) { return raise ( @@sig@@ ) ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
int fdatasync ( int @@fildes@@ ) { return fdatasync ( @@fildes@@ ) ; }
__int64 __fastcall c_strcasecmp ( unsigned __int8 * @@a1@@ , unsigned __int8 * @@a2@@ ) { __int64 @@result@@ ; int @@v3@@ ; int @@v4@@ ; @@result@@ = Number L ; if ( @@a1@@ != @@a2@@ ) { do { @@v3@@ = * @@a1@@ ; if ( ( unsigned int ) ( @@v3@@ - Number ) < Number ) LOBYTE ( @@v3@@ ) = @@v3@@ + Number ; @@v4@@ = * @@a2@@ ; if ( ( unsigned int ) ( @@v4@@ - Number ) < Number ) LOBYTE ( @@v4@@ ) = @@v4@@ + Number ; if ( ! ( _BYTE ) @@v3@@ ) break ; ++ @@a1@@ ; ++ @@a2@@ ; } while ( ( _BYTE ) @@v3@@ == ( _BYTE ) @@v4@@ ) ; @@result@@ = ( unsigned __int8 ) @@v3@@ - ( unsigned int ) ( unsigned __int8 ) @@v4@@ ; } return @@result@@ ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
char * __fastcall mmalloca ( __int64 @@a1@@ ) { bool @@v1@@ ; size_t @@v2@@ ; _DWORD * @@v3@@ ; char * @@v4@@ ; unsigned __int64 @@v5@@ ; __int64 @@v6@@ ; @@v1@@ = __CFADD__ ( @@a1@@ , Number L ) ; @@v2@@ = @@a1@@ + Number ; if ( @@v1@@ ) return Number L ; @@v3@@ = malloc ( @@v2@@ ) ; @@v4@@ = Number L ; if ( @@v3@@ ) { @@v3@@ [ Number ] = Number ; @@v4@@ = ( char * ) ( @@v3@@ + Number ) ; @@v5@@ = ( unsigned __int64 ) ( @@v3@@ + Number ) % Number ; @@v6@@ = mmalloca_results [ @@v5@@ ] ; mmalloca_results [ @@v5@@ ] = @@v3@@ + Number ; * ( _QWORD * ) @@v3@@ = @@v6@@ ; } return @@v4@@ ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
int clock_gettime ( clockid_t @@clock_id@@ , struct timespec * @@tp@@ ) { return clock_gettime ( @@clock_id@@ , @@tp@@ ) ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 __fastcall dup_safer ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ , char @@a7@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ , @@a7@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
int sigemptyset ( sigset_t * @@set@@ ) { return sigemptyset ( @@set@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
int __fxstat ( int @@ver@@ , int @@fildes@@ , struct stat * @@stat_buf@@ ) { return _fxstat ( @@ver@@ , @@fildes@@ , @@stat_buf@@ ) ; }
__int64 __fastcall rpl_fcntl ( int @@a1@@ , int @@a2@@ , __int64 @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { int @@v6@@ ; int @@v8@@ ; int @@v9@@ ; int @@v10@@ ; int @@v11@@ ; int * @@v12@@ ; int @@v13@@ ; int * @@v14@@ ; int @@v15@@ ; @@v15@@ = @@a3@@ ; if ( @@a2@@ != Number ) return ( unsigned int ) fcntl ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( have_dupfd_cloexec_3202 < Number ) { @@v6@@ = ( ( __int64 ( __fastcall * ) ( int , _DWORD , _DWORD , int , int , int , char ) ) rpl_fcntl ) ( @@a1@@ , Number , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ , Number ) ; if ( @@v6@@ < Number || have_dupfd_cloexec_3202 != Number ) return ( unsigned int ) @@v6@@ ; } else { @@v6@@ = fcntl ( @@a1@@ , Number , ( unsigned int ) @@a3@@ ) ; if ( @@v6@@ >= Number || * __errno_location ( ) != Number ) { have_dupfd_cloexec_3202 = Number ; return ( unsigned int ) @@v6@@ ; } @@v6@@ = ( ( __int64 ( __fastcall * ) ( int , _DWORD , int , int , int , int , char ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v15@@ , @@v8@@ , @@v9@@ , @@v10@@ , Number ) ; if ( @@v6@@ < Number ) return ( unsigned int ) @@v6@@ ; have_dupfd_cloexec_3202 = Number ; } @@v11@@ = fcntl ( @@v6@@ , Number ) ; if ( @@v11@@ < Number || fcntl ( @@v6@@ , Number , @@v11@@ | Number ) == Number ) { @@v12@@ = __errno_location ( ) ; @@v13@@ = * @@v12@@ ; @@v14@@ = @@v12@@ ; close ( @@v6@@ ) ; @@v6@@ = Number ; * @@v14@@ = @@v13@@ ; } return ( unsigned int ) @@v6@@ ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
int __xstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _xstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
int iswspace ( wint_t @@wc@@ ) { return iswspace ( @@wc@@ ) ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
char * strdup ( const char * @@s@@ ) { return strdup ( @@s@@ ) ; }
__int64 __fastcall parse_symbols ( char * @@s@@ , __int64 @@a2@@ , const char * @@a3@@ ) { unsigned int @@v6@@ ; char * @@v7@@ ; __int64 @@v8@@ ; char * @@v9@@ ; char * @@v10@@ ; char @@v11@@ ; char @@v12@@ ; int @@v13@@ ; unsigned __int64 @@v15@@ ; const char * @@v16@@ ; char * @@v17@@ ; @@v6@@ = Number ; while ( Number ) { @@v7@@ = strchr ( @@s@@ , Number ) ; @@v8@@ = @@a2@@ ; LABEL_3 : @@v9@@ = ( char * ) @@v8@@ ; @@v10@@ = @@s@@ ; while ( Number ) { @@v11@@ = * @@v9@@ ; @@v12@@ = * @@v10@@ ; if ( ! * @@v9@@ ) break ; ++ @@v10@@ ; ++ @@v9@@ ; if ( @@v11@@ != @@v12@@ ) { LABEL_9 : if ( ! * ( _BYTE * ) @@v8@@ ) { if ( @@v7@@ ) @@v15@@ = @@v7@@ - @@s@@ ; else @@v15@@ = strlen ( @@s@@ ) ; @@v16@@ = ( const char * ) quotearg_n_style_mem ( Number L , Number L , @@s@@ , @@v15@@ ) ; @@v17@@ = dcgettext ( Number L , @@a3@@ , Number ) ; error ( Number , Number , String , @@v17@@ , @@v16@@ ) ; usage ( Number ) ; } @@v8@@ += Number L ; goto LABEL_3 ; } } if ( @@v12@@ != Number && @@v12@@ ) goto LABEL_9 ; @@v13@@ = * ( _DWORD * ) ( @@v8@@ + Number ) ; if ( ! @@v13@@ ) goto LABEL_9 ; @@v6@@ |= @@v13@@ ; if ( @@v7@@ ) { @@s@@ = @@v7@@ + Number ; continue ; } return @@v6@@ ; } }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
void __fastcall argmatch_invalid ( __int64 @@a1@@ , wchar_t * @@a2@@ , __int64 @@a3@@ ) { char * @@v3@@ ; __int64 @@v4@@ ; _BYTE * @@v5@@ ; if ( @@a3@@ == Number ) @@v3@@ = dcgettext ( Number L , String , Number ) ; else @@v3@@ = dcgettext ( Number L , String , Number ) ; @@v4@@ = quote_n ( Number L , @@a1@@ ) ; @@v5@@ = quotearg_n_style ( Number , Number , @@a2@@ ) ; error ( Number , Number , @@v3@@ , @@v5@@ , @@v4@@ ) ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; int @@v12@@ ; _BYTE * @@v13@@ ; __int64 @@v14@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v12@@ = * @@v6@@ ; @@v14@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v13@@ = ( _BYTE * ) xmalloc ( @@v14@@ + Number , @@v14@@ + Number , @@v8@@ , @@v9@@ , @@v10@@ ) ; quotearg_buffer_restyled ( @@v13@@ , @@v14@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v12@@ ; if ( @@a3@@ ) * @@a3@@ = @@v14@@ ; return @@v13@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
const char * __fastcall proper_name ( char * @@s@@ ) { char * @@v1@@ ; const char * @@v2@@ ; size_t @@v4@@ ; size_t @@v5@@ ; __int64 @@v6@@ ; @@v1@@ = dcgettext ( Number L , @@s@@ , Number ) ; @@v2@@ = @@v1@@ ; if ( @@s@@ == @@v1@@ || ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@v1@@ , ( __int64 ) @@s@@ ) ) { return @@v2@@ ; } @@v4@@ = strlen ( @@v2@@ ) ; @@v5@@ = strlen ( @@s@@ ) ; @@v6@@ = xmalloc ( @@v4@@ + @@v5@@ + Number ) ; __sprintf_chk ( ) ; return ( const char * ) @@v6@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
__int64 __fastcall _xargmatch_internal ( __int64 @@a1@@ , char * @@a2@@ , const char * * @@a3@@ , char * @@a4@@ , size_t @@a5@@ , void ( * @@a6@@ ) ( void ) ) { __int64 @@result@@ ; @@result@@ = argmatch ( @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; if ( @@result@@ < Number ) { argmatch_invalid ( @@a1@@ , ( wchar_t * ) @@a2@@ , @@result@@ ) ; argmatch_valid ( @@a3@@ , @@a4@@ , @@a5@@ ) ; @@a6@@ ( ) ; @@result@@ = Number ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
int iswalnum ( wint_t @@wc@@ ) { return iswalnum ( @@wc@@ ) ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
__int64 __fastcall argmatch_to_argument ( void * @@s1@@ , __int64 * @@a2@@ , char * @@a3@@ , size_t @@a4@@ ) { __int64 @@v4@@ ; __int64 * @@v7@@ ; @@v4@@ = * @@a2@@ ; if ( * @@a2@@ ) { @@v7@@ = @@a2@@ + Number ; do { if ( ! memcmp ( @@s1@@ , @@a3@@ , @@a4@@ ) ) break ; @@v4@@ = * @@v7@@ ; @@a3@@ += @@a4@@ ; ++ @@v7@@ ; } while ( @@v4@@ ) ; } return @@v4@@ ; }
int __fxstat ( int @@ver@@ , int @@fildes@@ , struct stat * @@stat_buf@@ ) { return _fxstat ( @@ver@@ , @@fildes@@ , @@stat_buf@@ ) ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
__int64 __fastcall xreadlink ( char * @@a1@@ ) { __int64 @@v1@@ ; @@v1@@ = areadlink ( @@a1@@ ) ; if ( ! @@v1@@ && * __errno_location ( ) == Number ) xalloc_die ( ) ; return @@v1@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) _frame_dummy_init_array_entry [ @@i@@ ] ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
__int64 __fastcall dir_name ( void * @@a1@@ ) { __int64 @@result@@ ; @@result@@ = mdir_name ( @@a1@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
__int64 __fastcall rpl_vfprintf ( FILE * @@s@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { char * @@v3@@ ; size_t @@v4@@ ; char * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; size_t @@n@@ ; char @@v11@@ [ Number ] ; unsigned __int64 @@v12@@ ; @@n@@ = Number L ; @@v12@@ = __readfsqword ( Number ) ; @@v3@@ = ( char * ) vasnprintf ( @@v11@@ , & @@n@@ , @@a2@@ , @@a3@@ ) ; @@v4@@ = @@n@@ ; if ( ! @@v3@@ ) goto LABEL_10 ; @@v5@@ = @@v3@@ ; if ( fwrite ( @@v3@@ , Number , @@n@@ , @@s@@ ) >= @@v4@@ ) { if ( @@v5@@ != @@v11@@ ) free ( @@v5@@ ) ; if ( @@v4@@ <= Number ) return ( unsigned int ) @@v4@@ ; * __errno_location ( ) = Number ; LABEL_10 : LODWORD ( @@v4@@ ) = Number ; fseterr ( @@s@@ ) ; return ( unsigned int ) @@v4@@ ; } LODWORD ( @@v4@@ ) = Number ; if ( @@v5@@ != @@v11@@ ) { @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; free ( @@v5@@ ) ; * @@v9@@ = @@v8@@ ; } return ( unsigned int ) @@v4@@ ; }
__int64 __fastcall full_read ( int @@fd@@ , void * @@buf@@ , size_t @@nbytes@@ ) { size_t @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; if ( ! @@nbytes@@ ) return Number L ; @@v4@@ = @@nbytes@@ ; @@v5@@ = Number L ; do { @@v6@@ = safe_read ( @@fd@@ , @@buf@@ , @@v4@@ ) ; if ( @@v6@@ == Number ) break ; if ( ! @@v6@@ ) { * __errno_location ( ) = Number ; return @@v5@@ ; } @@v5@@ += @@v6@@ ; @@buf@@ = ( char * ) @@buf@@ + @@v6@@ ; @@v4@@ -= @@v6@@ ; } while ( @@v4@@ ) ; return @@v5@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
_BYTE * __fastcall mdir_name ( void * @@src@@ ) { __int64 @@v1@@ ; _BYTE * @@v2@@ ; _BYTE * @@v3@@ ; _BYTE * @@v4@@ ; @@v1@@ = dir_len ( @@src@@ ) ; @@v2@@ = malloc ( @@v1@@ + ( @@v1@@ == Number ) + Number ) ; @@v3@@ = @@v2@@ ; if ( @@v2@@ ) { @@v4@@ = memcpy ( @@v2@@ , @@src@@ , @@v1@@ ) ; @@v3@@ = @@v4@@ ; if ( ! @@v1@@ ) { * @@v4@@ = Number ; @@v1@@ = Number L ; } @@v4@@ [ @@v1@@ ] = Number ; } return @@v3@@ ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
const char * __fastcall proper_name ( char * @@s@@ ) { char * @@v1@@ ; const char * @@v2@@ ; size_t @@v4@@ ; size_t @@v5@@ ; __int64 @@v6@@ ; @@v1@@ = dcgettext ( Number L , @@s@@ , Number ) ; @@v2@@ = @@v1@@ ; if ( @@s@@ == @@v1@@ || ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@v1@@ , ( __int64 ) @@s@@ ) ) { return @@v2@@ ; } @@v4@@ = strlen ( @@v2@@ ) ; @@v5@@ = strlen ( @@s@@ ) ; @@v6@@ = xmalloc ( @@v4@@ + @@v5@@ + Number ) ; __sprintf_chk ( ) ; return ( const char * ) @@v6@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
int fileno ( FILE * @@stream@@ ) { return fileno ( @@stream@@ ) ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
int iconv_close ( iconv_t @@cd@@ ) { return iconv_close ( @@cd@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
size_t __fastcall writeline_isra_0 ( size_t * @@a1@@ , const void * * @@a2@@ , FILE * @@a3@@ , int @@a4@@ ) { size_t @@result@@ ; FILE * @@v5@@ ; FILE * @@v6@@ ; if ( @@a4@@ == Number ) { if ( ! only_file_2 ) return @@result@@ ; if ( only_file_1 ) { LABEL_12 : @@v5@@ = @@a3@@ ; fputs_unlocked ( delimiter , @@a3@@ ) ; @@a3@@ = @@v5@@ ; } return fwrite_unlocked ( * @@a2@@ , Number , * @@a1@@ , @@a3@@ ) ; } if ( @@a4@@ != Number ) { if ( ! only_file_1 ) return @@result@@ ; return fwrite_unlocked ( * @@a2@@ , Number , * @@a1@@ , @@a3@@ ) ; } if ( both ) { if ( only_file_1 ) { @@v6@@ = @@a3@@ ; fputs_unlocked ( delimiter , @@a3@@ ) ; @@a3@@ = @@v6@@ ; } if ( ! only_file_2 ) return fwrite_unlocked ( * @@a2@@ , Number , * @@a1@@ , @@a3@@ ) ; goto LABEL_12 ; } return @@result@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; program_invocation_short_name = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
void __fastcall initbuffer ( __int64 @@a1@@ ) { * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _OWORD * ) @@a1@@ = Number L ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
void __fastcall freebuffer ( __int64 @@a1@@ ) { free ( * ( void * * ) ( @@a1@@ + Number ) ) ; }
int fileno ( FILE * @@stream@@ ) { return fileno ( @@stream@@ ) ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
void * malloc ( size_t @@size@@ ) { return __imp_malloc ( @@size@@ ) ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
__int64 __fastcall open_safer ( const char * @@a1@@ , char @@a2@@ , unsigned int @@a3@@ ) { __int64 @@v3@@ ; int @@v4@@ ; @@v3@@ = Number L ; if ( ( @@a2@@ & Number ) != Number ) @@v3@@ = @@a3@@ ; @@v4@@ = open ( @@a1@@ , @@a2@@ , @@v3@@ ) ; return fd_safer ( @@v4@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
__int64 __fastcall rpl_vasprintf ( _QWORD * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { void * @@v3@@ ; unsigned int @@v4@@ ; __int64 @@result@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; @@v3@@ = ( void * ) vasnprintf ( Number L , @@v6@@ , @@a2@@ , @@a3@@ ) ; if ( ! @@v3@@ ) return Number ; @@v4@@ = @@v6@@ [ Number ] ; if ( @@v6@@ [ Number ] > Number ) { free ( @@v3@@ ) ; * __errno_location ( ) = Number ; @@result@@ = Number ; } else { * @@a1@@ = @@v3@@ ; @@result@@ = @@v4@@ ; } return @@result@@ ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; char * @@v11@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String String String String String String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v9@@ = stdout ; @@v10@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; @@v11@@ = setlocale ( Number , Number L ) ; if ( @@v11@@ ) { if ( strncmp ( @@v11@@ , String , Number ) ) { last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
__int64 __fastcall knuth_morris_pratt_unibyte ( unsigned __int8 * @@a1@@ , const char * @@a2@@ , unsigned __int8 * * @@a3@@ ) { const char * @@v4@@ ; size_t @@v6@@ ; void * @@v7@@ ; __int64 * @@v8@@ ; __int64 @@v9@@ ; __int64 @@i@@ ; char @@v11@@ ; __int64 @@v12@@ ; unsigned __int8 * @@v13@@ ; __int64 @@v14@@ ; __int64 @@v16@@ ; @@v4@@ = @@a2@@ ; @@v6@@ = strlen ( @@a2@@ ) ; if ( @@v6@@ > Number ) return Number L ; if ( Number * @@v6@@ > Number ) { @@v8@@ = ( __int64 * ) mmalloca ( ) ; } else { @@v7@@ = alloca ( Number * @@v6@@ + Number ) ; @@v8@@ = & @@v16@@ ; } if ( ! @@v8@@ ) return Number L ; @@v8@@ [ Number ] = Number L ; if ( @@v6@@ > Number ) { @@v9@@ = Number L ; for ( @@i@@ = Number L ; @@i@@ != @@v6@@ ; ++ @@i@@ ) { @@v11@@ = @@a2@@ [ @@i@@ - Number ] ; if ( @@v11@@ == @@a2@@ [ @@v9@@ ] ) { LABEL_23 : ++ @@v9@@ ; @@v8@@ [ @@i@@ ] = @@i@@ - @@v9@@ ; } else { while ( @@v9@@ ) { @@v9@@ -= @@v8@@ [ @@v9@@ ] ; if ( @@v11@@ == @@a2@@ [ @@v9@@ ] ) goto LABEL_23 ; } @@v8@@ [ @@i@@ ] = @@i@@ ; @@v9@@ = Number L ; } } } * @@a3@@ = Number L ; @@v12@@ = * @@a1@@ ; @@v13@@ = @@a1@@ ; @@v14@@ = Number L ; LABEL_14 : while ( Number ) { if ( ( _BYTE ) @@v12@@ ) { while ( @@v4@@ [ @@v14@@ ] != ( _BYTE ) @@v12@@ ) { if ( ! @@v14@@ ) { @@v12@@ = @@v13@@ [ Number ] ; ++ @@a1@@ ; ++ @@v13@@ ; goto LABEL_14 ; } @@a2@@ = ( const char * ) @@v8@@ [ @@v14@@ ] ; @@a1@@ = & @@a1@@ [ ( _QWORD ) @@a2@@ ] ; @@v14@@ -= ( __int64 ) @@a2@@ ; } ++ @@v14@@ ; @@a2@@ = ( const char * ) ( @@v13@@ + Number ) ; if ( @@v6@@ != @@v14@@ ) { @@v12@@ = * ++ @@v13@@ ; continue ; } * @@a3@@ = @@a1@@ ; } break ; } freea ( @@v8@@ , @@a2@@ , @@v12@@ , @@v13@@ ) ; return Number L ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_20D230 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20D210 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_20D220 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
__int64 __fastcall md5_init_ctx ( __int64 @@a1@@ ) { __int64 @@result@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _DWORD * ) ( @@a1@@ + Number ) = Number ; * ( _QWORD * ) @@a1@@ = Number ; @@result@@ = Number ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number ; return @@result@@ ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
ssize_t __fastcall safe_read ( int @@fd@@ , void * @@buf@@ , size_t @@nbytes@@ ) { ssize_t @@v4@@ ; int @@v5@@ ; while ( Number ) { @@v4@@ = read ( @@fd@@ , @@buf@@ , @@nbytes@@ ) ; if ( @@v4@@ >= Number ) break ; @@v5@@ = * __errno_location ( ) ; if ( @@v5@@ != Number ) { if ( @@nbytes@@ <= Number || @@v5@@ != Number ) return @@v4@@ ; @@nbytes@@ = Number L ; } } return @@v4@@ ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
int __fastcall argmatch_valid ( _QWORD * @@a1@@ , char * @@a2@@ , size_t @@a3@@ ) { const void * @@v5@@ ; __int64 @@v6@@ ; char * @@v7@@ ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; if ( * @@a1@@ ) { @@v5@@ = Number L ; @@v6@@ = Number L ; do { while ( ! @@v6@@ || memcmp ( @@v5@@ , @@a2@@ , @@a3@@ ) ) { ++ @@v6@@ ; @@v5@@ = @@a2@@ ; __fprintf_chk ( ) ; @@a2@@ += @@a3@@ ; if ( ! @@a1@@ [ @@v6@@ ] ) goto LABEL_7 ; } ++ @@v6@@ ; @@a2@@ += @@a3@@ ; __fprintf_chk ( ) ; } while ( @@a1@@ [ @@v6@@ ] ) ; } LABEL_7 : @@v7@@ = stderr -> _IO_write_ptr ; if ( @@v7@@ >= stderr -> _IO_write_end ) { LODWORD ( @@v7@@ ) = __overflow ( stderr , Number ) ; } else { stderr -> _IO_write_ptr = @@v7@@ + Number ; * @@v7@@ = Number ; } return ( int ) @@v7@@ ; }
__int64 __fastcall fd_reopen ( int @@fd2@@ , char * @@file@@ , int @@oflag@@ , unsigned int @@a4@@ ) { int @@v4@@ ; unsigned int @@v5@@ ; int @@v6@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; @@v4@@ = open ( @@file@@ , @@oflag@@ , @@a4@@ ) ; @@v5@@ = @@v4@@ ; if ( @@fd2@@ != @@v4@@ && @@v4@@ >= Number ) { @@v6@@ = dup2 ( @@v4@@ , @@fd2@@ ) ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; close ( @@v5@@ ) ; @@v5@@ = @@v6@@ ; * @@v9@@ = @@v8@@ ; } return @@v5@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
__int64 __fastcall md5_stream ( FILE * @@stream@@ , _DWORD * @@a2@@ ) { int * @@v2@@ ; __int64 @@result@@ ; size_t @@v4@@ ; int @@v5@@ ; size_t @@v6@@ ; __int64 @@v7@@ [ Number ] ; int @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v2@@ = ( int * ) malloc ( Number ) ; @@result@@ = Number L ; if ( @@v2@@ ) { @@v7@@ [ Number ] = Number L ; @@v8@@ = Number ; @@v7@@ [ Number ] = Number ; @@v7@@ [ Number ] = Number ; LABEL_3 : @@v4@@ = Number L ; while ( Number ) { @@v6@@ = fread_unlocked ( ( char * ) @@v2@@ + @@v4@@ , Number , Number - @@v4@@ , @@stream@@ ) ; @@v4@@ += @@v6@@ ; if ( @@v4@@ == Number ) { md5_process_block ( @@v2@@ , Number , @@v7@@ ) ; goto LABEL_3 ; } @@v5@@ = @@stream@@ -> _flags ; if ( ! @@v6@@ ) break ; if ( ( @@v5@@ & Number ) != Number ) goto LABEL_9 ; } if ( ( @@v5@@ & Number ) != Number ) { free ( @@v2@@ ) ; return Number L ; } LABEL_9 : if ( @@v4@@ ) md5_process_bytes ( @@v2@@ , @@v4@@ , ( __int64 ) @@v7@@ ) ; md5_finish_ctx ( @@v7@@ , @@a2@@ ) ; free ( @@v2@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
void __fastcall freea ( unsigned __int64 @@a1@@ ) { __int64 @@v1@@ ; __int64 @@v2@@ ; _QWORD * @@v3@@ ; if ( @@a1@@ ) { if ( * ( _DWORD * ) ( @@a1@@ - Number ) == Number ) { @@v1@@ = mmalloca_results [ @@a1@@ % Number ] ; if ( @@v1@@ ) { if ( @@v1@@ == @@a1@@ ) { @@v3@@ = & mmalloca_results [ @@a1@@ % Number ] ; LABEL_12 : * @@v3@@ = * ( _QWORD * ) ( @@a1@@ - Number ) ; free ( ( void * ) ( @@a1@@ - Number ) ) ; } else { while ( Number ) { @@v2@@ = * ( _QWORD * ) ( @@v1@@ - Number ) ; if ( ! @@v2@@ ) break ; if ( @@a1@@ == @@v2@@ ) { @@v3@@ = ( _QWORD * ) ( @@v1@@ - Number ) ; goto LABEL_12 ; } @@v1@@ = * ( _QWORD * ) ( @@v1@@ - Number ) ; } } } } } }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_208210 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2081F0 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_208200 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
char * nl_langinfo ( nl_item @@item@@ ) { return nl_langinfo ( @@item@@ ) ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
int iswspace ( wint_t @@wc@@ ) { return iswspace ( @@wc@@ ) ; }
__int64 __fastcall knuth_morris_pratt_unibyte ( unsigned __int8 * @@a1@@ , const char * @@a2@@ , unsigned __int8 * * @@a3@@ ) { const char * @@v4@@ ; size_t @@v6@@ ; void * @@v7@@ ; __int64 * @@v8@@ ; __int64 @@v9@@ ; __int64 @@i@@ ; char @@v11@@ ; __int64 @@v12@@ ; unsigned __int8 * @@v13@@ ; __int64 @@v14@@ ; __int64 @@v16@@ ; @@v4@@ = @@a2@@ ; @@v6@@ = strlen ( @@a2@@ ) ; if ( @@v6@@ > Number ) return Number L ; if ( Number * @@v6@@ > Number ) { @@v8@@ = ( __int64 * ) mmalloca ( ) ; } else { @@v7@@ = alloca ( Number * @@v6@@ + Number ) ; @@v8@@ = & @@v16@@ ; } if ( ! @@v8@@ ) return Number L ; @@v8@@ [ Number ] = Number L ; if ( @@v6@@ > Number ) { @@v9@@ = Number L ; for ( @@i@@ = Number L ; @@i@@ != @@v6@@ ; ++ @@i@@ ) { @@v11@@ = @@a2@@ [ @@i@@ - Number ] ; if ( @@v11@@ == @@a2@@ [ @@v9@@ ] ) { LABEL_23 : ++ @@v9@@ ; @@v8@@ [ @@i@@ ] = @@i@@ - @@v9@@ ; } else { while ( @@v9@@ ) { @@v9@@ -= @@v8@@ [ @@v9@@ ] ; if ( @@v11@@ == @@a2@@ [ @@v9@@ ] ) goto LABEL_23 ; } @@v8@@ [ @@i@@ ] = @@i@@ ; @@v9@@ = Number L ; } } } * @@a3@@ = Number L ; @@v12@@ = * @@a1@@ ; @@v13@@ = @@a1@@ ; @@v14@@ = Number L ; LABEL_14 : while ( Number ) { if ( ( _BYTE ) @@v12@@ ) { while ( @@v4@@ [ @@v14@@ ] != ( _BYTE ) @@v12@@ ) { if ( ! @@v14@@ ) { @@v12@@ = @@v13@@ [ Number ] ; ++ @@a1@@ ; ++ @@v13@@ ; goto LABEL_14 ; } @@a2@@ = ( const char * ) @@v8@@ [ @@v14@@ ] ; @@a1@@ = & @@a1@@ [ ( _QWORD ) @@a2@@ ] ; @@v14@@ -= ( __int64 ) @@a2@@ ; } ++ @@v14@@ ; @@a2@@ = ( const char * ) ( @@v13@@ + Number ) ; if ( @@v6@@ != @@v14@@ ) { @@v12@@ = * ++ @@v13@@ ; continue ; } * @@a3@@ = @@a1@@ ; } break ; } freea ( @@v8@@ , @@a2@@ , @@v12@@ , @@v13@@ ) ; return Number L ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
int fileno ( FILE * @@stream@@ ) { return fileno ( @@stream@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
__locale_t newlocale ( int @@category_mask@@ , const char * @@locale@@ , __locale_t @@base@@ ) { return newlocale ( @@category_mask@@ , @@locale@@ , @@base@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall full_write ( int @@fd@@ , void * @@buf@@ , size_t @@n@@ ) { size_t @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; if ( ! @@n@@ ) return Number L ; @@v4@@ = @@n@@ ; @@v5@@ = Number L ; do { @@v6@@ = safe_write ( @@fd@@ , @@buf@@ , @@v4@@ ) ; if ( @@v6@@ == Number ) break ; if ( ! @@v6@@ ) { * __errno_location ( ) = Number ; return @@v5@@ ; } @@v5@@ += @@v6@@ ; @@buf@@ = ( char * ) @@buf@@ + @@v6@@ ; @@v4@@ -= @@v6@@ ; } while ( @@v4@@ ) ; return @@v5@@ ; }
unsigned __int64 __fastcall uptime ( const char * @@a1@@ , unsigned int @@a2@@ , double @@a3@@ ) { int * @@v3@@ ; unsigned __int64 @@v5@@ ; __int16 * @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; if ( ( unsigned int ) read_utmp ( @@a1@@ , & @@v5@@ , & @@v6@@ , @@a2@@ ) ) { @@v3@@ = __errno_location ( ) ; error ( Number , * @@v3@@ , String , @@a1@@ ) ; } print_uptime ( @@v5@@ , @@v6@@ , @@a3@@ ) ; return __readfsqword ( Number ) ^ @@v7@@ ; }
struct tm * localtime ( const time_t * @@timer@@ ) { return localtime ( @@timer@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
int clock_gettime ( clockid_t @@clock_id@@ , struct timespec * @@tp@@ ) { return clock_gettime ( @@clock_id@@ , @@tp@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
size_t __fastcall strnlen1 ( const void * @@a1@@ , size_t @@a2@@ ) { _BYTE * @@v2@@ ; __int64 @@v3@@ ; bool @@v4@@ ; size_t @@result@@ ; @@v2@@ = memchr ( @@a1@@ , Number , @@a2@@ ) ; @@v3@@ = @@v2@@ - ( _BYTE * ) @@a1@@ + Number ; @@v4@@ = @@v2@@ == Number L ; @@result@@ = @@a2@@ ; if ( ! @@v4@@ ) @@result@@ = @@v3@@ ; return @@result@@ ; }
time_t time ( time_t * @@timer@@ ) { return time ( @@timer@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
time_t mktime ( struct tm * @@tp@@ ) { return mktime ( @@tp@@ ) ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void __fastcall c_strtod ( char * @@nptr@@ , char * * @@endptr@@ ) { if ( ! c_locale_cache ) c_locale_cache = newlocale ( Number , String , Number L ) ; if ( c_locale_cache ) { strtod_l ( @@nptr@@ , @@endptr@@ , c_locale_cache ) ; } else if ( @@endptr@@ ) { * @@endptr@@ = @@nptr@@ ; } }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int64 __fastcall digits_to_date_time ( __int64 @@a1@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 a5 , __int64 a6 , __int128 @@a7@@ , unsigned __int64 @@a8@@ ) { __int64 @@result@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; __m128i @@v11@@ ; @@result@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v9@@ = * ( ( _QWORD * ) & @@a7@@ + Number ) ; @@v10@@ = @@a8@@ ; if ( @@result@@ && ! * ( _QWORD * ) ( @@a1@@ + Number ) && ! * ( _BYTE * ) ( @@a1@@ + Number ) ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) || @@a8@@ > Number ) { @@result@@ = @@a8@@ ; @@v11@@ = _mm_loadu_si128 ( ( const __m128i * ) & @@a7@@ ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@a8@@ ; * ( __m128i * ) ( @@a1@@ + Number ) = @@v11@@ ; return @@result@@ ; } * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; goto LABEL_13 ; } if ( @@a8@@ <= Number ) { ++ * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( @@v10@@ > Number ) { * ( _QWORD * ) ( @@a1@@ + Number ) = @@v9@@ / Number ; @@result@@ = Number * ( @@v9@@ / Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v9@@ % Number ; LABEL_10 : * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _DWORD * ) ( @@a1@@ + Number ) = Number ; return @@result@@ ; } LABEL_13 : * ( _QWORD * ) ( @@a1@@ + Number ) = @@v9@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; goto LABEL_10 ; } * ( _QWORD * ) ( @@a1@@ + Number ) = @@result@@ + Number ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v10@@ - Number ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v9@@ % Number ; @@result@@ = Number * @@v9@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v9@@ / Number % Number ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v9@@ / Number ; return @@result@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
FILE * __fastcall fopen_safer ( const char * @@a1@@ , const char * @@a2@@ ) { FILE * @@v2@@ ; FILE * @@v3@@ ; unsigned int @@v4@@ ; int @@v6@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; int * @@v10@@ ; int @@v11@@ ; int * @@v12@@ ; @@v2@@ = fopen ( @@a1@@ , @@a2@@ ) ; @@v3@@ = @@v2@@ ; if ( @@v2@@ ) { @@v4@@ = fileno ( @@v2@@ ) ; if ( @@v4@@ <= Number ) { @@v6@@ = dup_safer ( @@v4@@ ) ; if ( @@v6@@ < Number ) { @@v10@@ = __errno_location ( ) ; @@v11@@ = * @@v10@@ ; @@v12@@ = @@v10@@ ; fclose ( @@v3@@ ) ; @@v3@@ = Number L ; * @@v12@@ = @@v11@@ ; } else if ( fclose ( @@v3@@ ) || ( @@v3@@ = fdopen ( @@v6@@ , @@a2@@ ) ) == Number L ) { @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; close ( @@v6@@ ) ; * @@v9@@ = @@v8@@ ; @@v3@@ = Number L ; } } } return @@v3@@ ; }
__int64 __fastcall digest_file_isra_0 ( const char * @@a1@@ ) { FILE * @@v1@@ ; unsigned int @@v2@@ ; int * @@v4@@ ; FILE * @@v5@@ ; int * @@v6@@ ; if ( ! strcmp ( @@a1@@ , String ) ) { @@v1@@ = stdin ; have_read_stdin = Number ; if ( ! ( unsigned int ) sha1_stream ( stdin ) ) return Number ; goto LABEL_5 ; } @@v5@@ = ( FILE * ) fopen_safer ( @@a1@@ , String ) ; @@v1@@ = @@v5@@ ; if ( ! @@v5@@ ) { LABEL_10 : @@v6@@ = __errno_location ( ) ; error ( Number , * @@v6@@ , String , @@a1@@ ) ; return Number L ; } if ( ! ( unsigned int ) sha1_stream ( @@v5@@ ) ) { if ( ! fclose ( @@v1@@ ) ) return Number ; goto LABEL_10 ; } LABEL_5 : @@v4@@ = __errno_location ( ) ; @@v2@@ = Number ; error ( Number , * @@v4@@ , String , @@a1@@ ) ; if ( stdin == @@v1@@ ) return @@v2@@ ; fclose ( @@v1@@ ) ; return Number L ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
__int64 __fastcall argmatch ( const char * @@a1@@ , const char * * @@a2@@ , char * @@a3@@ , size_t @@a4@@ ) { char * @@v5@@ ; size_t @@v6@@ ; const char * @@v7@@ ; size_t @@v8@@ ; __int64 @@v9@@ ; bool @@v10@@ ; char @@v11@@ ; __int64 @@v12@@ ; __int64 @@v14@@ ; char @@v15@@ ; @@v5@@ = @@a3@@ ; @@v6@@ = strlen ( @@a1@@ ) ; @@v7@@ = * @@a2@@ ; @@v14@@ = Number ; if ( ! * @@a2@@ ) return @@v14@@ ; @@v8@@ = @@v6@@ ; @@v15@@ = Number ; @@v9@@ = Number L ; do { while ( strncmp ( @@v7@@ , @@a1@@ , @@v8@@ ) ) { LABEL_7 : ++ @@v9@@ ; @@v5@@ += @@a4@@ ; @@v7@@ = @@a2@@ [ @@v9@@ ] ; if ( ! @@v7@@ ) goto LABEL_12 ; } if ( strlen ( @@v7@@ ) == @@v8@@ ) return @@v9@@ ; if ( @@v14@@ != Number ) { if ( @@a3@@ ) { @@v10@@ = memcmp ( & @@a3@@ [ @@a4@@ * @@v14@@ ] , @@v5@@ , @@a4@@ ) == Number ; @@v11@@ = @@v15@@ ; if ( ! @@v10@@ ) @@v11@@ = Number ; @@v15@@ = @@v11@@ ; } else { @@v15@@ = Number ; } goto LABEL_7 ; } @@v14@@ = @@v9@@ ++ ; @@v5@@ += @@a4@@ ; @@v7@@ = @@a2@@ [ @@v9@@ ] ; } while ( @@v7@@ ) ; LABEL_12 : @@v12@@ = Number ; if ( ! @@v15@@ ) @@v12@@ = @@v14@@ ; return @@v12@@ ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
int putenv ( char * @@string@@ ) { return putenv ( @@string@@ ) ; }
_DWORD * __fastcall sha1_read_ctx ( unsigned int * @@a1@@ , _DWORD * @@a2@@ ) { _DWORD * @@result@@ ; @@result@@ = @@a2@@ ; * @@a2@@ = _byteswap_ulong ( * @@a1@@ ) ; @@a2@@ [ Number ] = _byteswap_ulong ( @@a1@@ [ Number ] ) ; @@a2@@ [ Number ] = _byteswap_ulong ( @@a1@@ [ Number ] ) ; @@a2@@ [ Number ] = _byteswap_ulong ( @@a1@@ [ Number ] ) ; @@a2@@ [ Number ] = _byteswap_ulong ( @@a1@@ [ Number ] ) ; return @@result@@ ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
ssize_t __fastcall safe_write ( int @@fd@@ , void * @@buf@@ , size_t @@n@@ ) { ssize_t @@v4@@ ; int @@v5@@ ; while ( Number ) { @@v4@@ = write ( @@fd@@ , @@buf@@ , @@n@@ ) ; if ( @@v4@@ >= Number ) break ; @@v5@@ = * __errno_location ( ) ; if ( @@v5@@ != Number ) { if ( @@v5@@ != Number || @@n@@ <= Number ) return @@v4@@ ; @@n@@ = Number L ; } } return @@v4@@ ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
size_t __fastcall strnlen1 ( const void * @@a1@@ , size_t @@a2@@ ) { _BYTE * @@v2@@ ; __int64 @@v3@@ ; bool @@v4@@ ; size_t @@result@@ ; @@v2@@ = memchr ( @@a1@@ , Number , @@a2@@ ) ; @@v3@@ = @@v2@@ - ( _BYTE * ) @@a1@@ + Number ; @@v4@@ = @@v2@@ == Number L ; @@result@@ = @@a2@@ ; if ( ! @@v4@@ ) @@result@@ = @@v3@@ ; return @@result@@ ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ , @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
char * __fastcall str_iconv ( char * @@s@@ , char * @@fromcode@@ , char * @@tocode@@ ) { char * @@v4@@ ; iconv_t @@v6@@ ; void * @@v7@@ ; int * @@v8@@ ; int @@v9@@ ; int * @@v10@@ ; int * @@v11@@ ; int @@v12@@ ; int * @@v13@@ ; if ( * @@s@@ && ( unsigned int ) c_strcasecmp ( ( unsigned __int8 * ) @@fromcode@@ , ( unsigned __int8 * ) @@tocode@@ ) ) { @@v6@@ = iconv_open ( @@tocode@@ , @@fromcode@@ ) ; @@v7@@ = @@v6@@ ; if ( @@v6@@ == ( iconv_t ) Number ) return Number L ; @@v4@@ = str_cd_iconv ( @@s@@ , @@v6@@ ) ; if ( @@v4@@ ) { if ( iconv_close ( @@v7@@ ) < Number ) { @@v8@@ = __errno_location ( ) ; @@v9@@ = * @@v8@@ ; @@v10@@ = @@v8@@ ; free ( @@v4@@ ) ; @@v4@@ = Number L ; * @@v10@@ = @@v9@@ ; } } else { @@v11@@ = __errno_location ( ) ; @@v12@@ = * @@v11@@ ; @@v13@@ = @@v11@@ ; iconv_close ( @@v7@@ ) ; * @@v13@@ = @@v12@@ ; } return @@v4@@ ; } @@v4@@ = strdup ( @@s@@ ) ; if ( @@v4@@ ) return @@v4@@ ; * __errno_location ( ) = Number ; return Number L ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
int puts ( const char * @@s@@ ) { return puts ( @@s@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 __fastcall file_name_concat ( void * @@a1@@ , void * @@a2@@ ) { __int64 @@result@@ ; @@result@@ = mfile_name_concat ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_209210 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2091F0 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_209200 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 __fastcall gl_futimens ( int @@fd2@@ , char * @@path@@ , const __m128i * @@a3@@ ) { return fdutimens ( @@path@@ , @@fd2@@ , @@a3@@ ) ; }
size_t __fastcall mbslen ( char * @@s@@ ) { __int64 @@i@@ ; int @@v3@@ ; wchar_t @@v4@@ ; size_t @@v5@@ ; size_t @@v6@@ ; size_t @@v7@@ ; size_t @@v8@@ ; char @@v9@@ ; mbstate_t @@v10@@ ; char @@v11@@ ; char * @@sa@@ ; size_t @@v13@@ ; char @@v14@@ ; wchar_t @@v15@@ [ Number ] ; unsigned __int64 @@v16@@ ; @@v16@@ = __readfsqword ( Number ) ; if ( __ctype_get_mb_cur_max ( ) > Number ) { @@sa@@ = @@s@@ ; @@v9@@ = Number ; @@v10@@ = Number L ; @@v11@@ = Number ; for ( @@i@@ = Number L ; ; ++ @@i@@ ) { if ( ! @@v9@@ ) { @@v3@@ = * ( ( _DWORD * ) & is_basic_table + ( ( ( unsigned __int8 ) * @@sa@@ >> Number ) & Number ) ) ; if ( _bittest ( & @@v3@@ , ( unsigned __int8 ) * @@sa@@ ) ) { @@v13@@ = Number L ; @@v4@@ = * @@sa@@ ; @@v14@@ = Number ; @@v11@@ = Number ; @@v15@@ [ Number ] = @@v4@@ ; goto LABEL_7 ; } if ( ! mbsinit ( & @@v10@@ ) ) __assert_fail ( String , String , Number , String ) ; @@v9@@ = Number ; } @@v5@@ = __ctype_get_mb_cur_max ( ) ; @@v6@@ = strnlen1 ( @@sa@@ , @@v5@@ ) ; @@v7@@ = mbrtowc ( @@v15@@ , @@sa@@ , @@v6@@ , & @@v10@@ ) ; @@v13@@ = @@v7@@ ; switch ( @@v7@@ ) { case Number : @@v13@@ = Number L ; @@v14@@ = Number ; goto LABEL_8 ; case Number : @@v8@@ = strlen ( @@sa@@ ) ; @@v14@@ = Number ; @@v13@@ = @@v8@@ ; goto LABEL_8 ; case Number : @@v13@@ = Number L ; if ( * @@sa@@ ) __assert_fail ( String , String , Number , String ) ; if ( @@v15@@ [ Number ] ) __assert_fail ( String , String , Number , String ) ; break ; } @@v14@@ = Number ; if ( mbsinit ( & @@v10@@ ) ) @@v9@@ = Number ; @@v11@@ = Number ; LABEL_7 : if ( ! @@v15@@ [ Number ] ) return @@i@@ ; LABEL_8 : @@sa@@ += @@v13@@ ; @@v11@@ = Number ; } } return strlen ( @@s@@ ) ; }
_DWORD * __fastcall sha1_buffer ( void * @@a1@@ , size_t @@a2@@ , _DWORD * @@a3@@ ) { __m128i @@v5@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; unsigned __int64 @@v8@@ ; @@v8@@ = __readfsqword ( Number ) ; @@v7@@ = Number L ; @@v5@@ . m128i_i64 [ Number ] = Number ; @@v5@@ . m128i_i64 [ Number ] = Number ; @@v6@@ = Number L ; sha1_process_bytes ( @@a1@@ , @@a2@@ , & @@v5@@ ) ; return sha1_finish_ctx ( @@v5@@ . m128i_i32 , @@a3@@ ) ; }
void * __fastcall mfile_name_concat ( void * @@src@@ , void * @@a2@@ , _QWORD * @@a3@@ ) { const char * @@v4@@ ; const char * @@v5@@ ; size_t @@v6@@ ; size_t @@v7@@ ; _BOOL8 @@v8@@ ; void * @@v9@@ ; void * @@v10@@ ; _BYTE * @@v11@@ ; char * @@v12@@ ; size_t @@n@@ ; char @@v15@@ ; @@v4@@ = ( const char * ) @@a2@@ ; @@v5@@ = last_component ( @@src@@ ) ; @@v6@@ = base_len ( @@v5@@ ) ; @@v7@@ = @@v6@@ + @@v5@@ - ( _BYTE * ) @@src@@ ; @@v8@@ = @@v6@@ ; if ( @@v6@@ ) @@v8@@ = @@v5@@ [ @@v6@@ - Number ] != Number ; @@v15@@ = * ( _BYTE * ) @@a2@@ ; if ( * ( _BYTE * ) @@a2@@ == Number ) { do ++ @@v4@@ ; while ( * @@v4@@ == Number ) ; } @@n@@ = strlen ( @@v4@@ ) ; @@v9@@ = malloc ( @@n@@ + @@v8@@ + @@v7@@ + Number ) ; @@v10@@ = @@v9@@ ; if ( @@v9@@ ) { @@v11@@ = mempcpy ( @@v9@@ , @@src@@ , @@v7@@ ) ; * @@v11@@ = Number ; @@v12@@ = & @@v11@@ [ @@v8@@ ] ; if ( @@a3@@ ) * @@a3@@ = & @@v12@@ [ - ( @@v15@@ == Number ) ] ; * ( _BYTE * ) mempcpy ( @@v12@@ , @@v4@@ , @@n@@ ) = Number ; } return @@v10@@ ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; char * @@v11@@ ; FILE * @@v12@@ ; char * @@v13@@ ; char * @@v14@@ ; char * @@v15@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String String String String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String String String String String String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = stdout ; @@v10@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; @@v11@@ = dcgettext ( Number L , String String String String String , Number ) ; __printf_chk ( ) ; last_component ( program_name , @@v11@@ ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v12@@ = stdout ; @@v13@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v13@@ , @@v12@@ ) ; @@v14@@ = Number L ; @@v15@@ = setlocale ( Number , Number L ) ; if ( @@v15@@ ) { @@v14@@ = String ; if ( strncmp ( @@v15@@ , String , Number ) ) { last_component ( program_name , String ) ; @@v14@@ = dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name , @@v14@@ ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
__int64 __fastcall dup_safer ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ , char @@a7@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ , @@a7@@ ) ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
char * __fastcall xstrndup ( const char * @@a1@@ , size_t @@a2@@ ) { char * @@result@@ ; @@result@@ = strndup ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__int64 __fastcall fd_reopen ( int @@fd2@@ , char * @@file@@ , int @@oflag@@ , unsigned int @@a4@@ ) { int @@v4@@ ; unsigned int @@v5@@ ; int @@v6@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; @@v4@@ = open ( @@file@@ , @@oflag@@ , @@a4@@ ) ; @@v5@@ = @@v4@@ ; if ( @@fd2@@ != @@v4@@ && @@v4@@ >= Number ) { @@v6@@ = dup2 ( @@v4@@ , @@fd2@@ ) ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; close ( @@v5@@ ) ; @@v5@@ = @@v6@@ ; * @@v9@@ = @@v8@@ ; } return @@v5@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_209210 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2091F0 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_209200 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
void free ( void * @@ptr@@ ) { __imp_free ( @@ptr@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
__int64 __fastcall c_strcasecmp ( unsigned __int8 * @@a1@@ , unsigned __int8 * @@a2@@ ) { __int64 @@result@@ ; int @@v3@@ ; int @@v4@@ ; @@result@@ = Number L ; if ( @@a1@@ != @@a2@@ ) { do { @@v3@@ = * @@a1@@ ; if ( ( unsigned int ) ( @@v3@@ - Number ) < Number ) LOBYTE ( @@v3@@ ) = @@v3@@ + Number ; @@v4@@ = * @@a2@@ ; if ( ( unsigned int ) ( @@v4@@ - Number ) < Number ) LOBYTE ( @@v4@@ ) = @@v4@@ + Number ; if ( ! ( _BYTE ) @@v3@@ ) break ; ++ @@a1@@ ; ++ @@a2@@ ; } while ( ( _BYTE ) @@v3@@ == ( _BYTE ) @@v4@@ ) ; @@result@@ = ( unsigned __int8 ) @@v3@@ - ( unsigned int ) ( unsigned __int8 ) @@v4@@ ; } return @@result@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
__int64 __fastcall c_strcasecmp ( unsigned __int8 * @@a1@@ , unsigned __int8 * @@a2@@ ) { __int64 @@result@@ ; int @@v3@@ ; int @@v4@@ ; @@result@@ = Number L ; if ( @@a1@@ != @@a2@@ ) { do { @@v3@@ = * @@a1@@ ; if ( ( unsigned int ) ( @@v3@@ - Number ) < Number ) LOBYTE ( @@v3@@ ) = @@v3@@ + Number ; @@v4@@ = * @@a2@@ ; if ( ( unsigned int ) ( @@v4@@ - Number ) < Number ) LOBYTE ( @@v4@@ ) = @@v4@@ + Number ; if ( ! ( _BYTE ) @@v3@@ ) break ; ++ @@a1@@ ; ++ @@a2@@ ; } while ( ( _BYTE ) @@v3@@ == ( _BYTE ) @@v4@@ ) ; @@result@@ = ( unsigned __int8 ) @@v3@@ - ( unsigned int ) ( unsigned __int8 ) @@v4@@ ; } return @@result@@ ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
char * __fastcall mmalloca ( __int64 @@a1@@ ) { bool @@v1@@ ; size_t @@v2@@ ; _DWORD * @@v3@@ ; char * @@v4@@ ; unsigned __int64 @@v5@@ ; __int64 @@v6@@ ; @@v1@@ = __CFADD__ ( @@a1@@ , Number L ) ; @@v2@@ = @@a1@@ + Number ; if ( @@v1@@ ) return Number L ; @@v3@@ = malloc ( @@v2@@ ) ; @@v4@@ = Number L ; if ( @@v3@@ ) { @@v3@@ [ Number ] = Number ; @@v4@@ = ( char * ) ( @@v3@@ + Number ) ; @@v5@@ = ( unsigned __int64 ) ( @@v3@@ + Number ) % Number ; @@v6@@ = mmalloca_results [ @@v5@@ ] ; mmalloca_results [ @@v5@@ ] = @@v3@@ + Number ; * ( _QWORD * ) @@v3@@ = @@v6@@ ; } return @@v4@@ ; }
__int64 __fastcall rpl_fcntl ( int @@a1@@ , int @@a2@@ , __int64 @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { int @@v6@@ ; int @@v8@@ ; int @@v9@@ ; int @@v10@@ ; int @@v11@@ ; int * @@v12@@ ; int @@v13@@ ; int * @@v14@@ ; int @@v15@@ ; @@v15@@ = @@a3@@ ; if ( @@a2@@ != Number ) return ( unsigned int ) fcntl ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( have_dupfd_cloexec_3202 < Number ) { @@v6@@ = ( ( __int64 ( __fastcall * ) ( int , _DWORD , _DWORD , int , int , int , char ) ) rpl_fcntl ) ( @@a1@@ , Number , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ , Number ) ; if ( @@v6@@ < Number || have_dupfd_cloexec_3202 != Number ) return ( unsigned int ) @@v6@@ ; } else { @@v6@@ = fcntl ( @@a1@@ , Number , ( unsigned int ) @@a3@@ ) ; if ( @@v6@@ >= Number || * __errno_location ( ) != Number ) { have_dupfd_cloexec_3202 = Number ; return ( unsigned int ) @@v6@@ ; } @@v6@@ = ( ( __int64 ( __fastcall * ) ( int , _DWORD , int , int , int , int , char ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v15@@ , @@v8@@ , @@v9@@ , @@v10@@ , Number ) ; if ( @@v6@@ < Number ) return ( unsigned int ) @@v6@@ ; have_dupfd_cloexec_3202 = Number ; } @@v11@@ = fcntl ( @@v6@@ , Number ) ; if ( @@v11@@ < Number || fcntl ( @@v6@@ , Number , @@v11@@ | Number ) == Number ) { @@v12@@ = __errno_location ( ) ; @@v13@@ = * @@v12@@ ; @@v14@@ = @@v12@@ ; close ( @@v6@@ ) ; @@v6@@ = Number ; * @@v14@@ = @@v13@@ ; } return ( unsigned int ) @@v6@@ ; }
size_t __fastcall mbslen ( char * @@s@@ ) { __int64 @@i@@ ; int @@v3@@ ; wchar_t @@v4@@ ; size_t @@v5@@ ; size_t @@v6@@ ; size_t @@v7@@ ; size_t @@v8@@ ; char @@v9@@ ; mbstate_t @@v10@@ ; char @@v11@@ ; char * @@sa@@ ; size_t @@v13@@ ; char @@v14@@ ; wchar_t @@v15@@ [ Number ] ; unsigned __int64 @@v16@@ ; @@v16@@ = __readfsqword ( Number ) ; if ( __ctype_get_mb_cur_max ( ) > Number ) { @@sa@@ = @@s@@ ; @@v9@@ = Number ; @@v10@@ = Number L ; @@v11@@ = Number ; for ( @@i@@ = Number L ; ; ++ @@i@@ ) { if ( ! @@v9@@ ) { @@v3@@ = * ( ( _DWORD * ) & is_basic_table + ( ( ( unsigned __int8 ) * @@sa@@ >> Number ) & Number ) ) ; if ( _bittest ( & @@v3@@ , ( unsigned __int8 ) * @@sa@@ ) ) { @@v13@@ = Number L ; @@v4@@ = * @@sa@@ ; @@v14@@ = Number ; @@v11@@ = Number ; @@v15@@ [ Number ] = @@v4@@ ; goto LABEL_7 ; } if ( ! mbsinit ( & @@v10@@ ) ) __assert_fail ( String , String , Number , String ) ; @@v9@@ = Number ; } @@v5@@ = __ctype_get_mb_cur_max ( ) ; @@v6@@ = strnlen1 ( @@sa@@ , @@v5@@ ) ; @@v7@@ = mbrtowc ( @@v15@@ , @@sa@@ , @@v6@@ , & @@v10@@ ) ; @@v13@@ = @@v7@@ ; switch ( @@v7@@ ) { case Number : @@v13@@ = Number L ; @@v14@@ = Number ; goto LABEL_8 ; case Number : @@v8@@ = strlen ( @@sa@@ ) ; @@v14@@ = Number ; @@v13@@ = @@v8@@ ; goto LABEL_8 ; case Number : @@v13@@ = Number L ; if ( * @@sa@@ ) __assert_fail ( String , String , Number , String ) ; if ( @@v15@@ [ Number ] ) __assert_fail ( String , String , Number , String ) ; break ; } @@v14@@ = Number ; if ( mbsinit ( & @@v10@@ ) ) @@v9@@ = Number ; @@v11@@ = Number ; LABEL_7 : if ( ! @@v15@@ [ Number ] ) return @@i@@ ; LABEL_8 : @@sa@@ += @@v13@@ ; @@v11@@ = Number ; } } return strlen ( @@s@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
int __cdecl __noreturn main ( int @@argc@@ , const char * * @@argv@@ , const char * * envp ) { __int64 @@v3@@ ; char * @@v4@@ ; set_program_name ( * @@argv@@ ) ; setlocale ( Number , String ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; parse_long_options ( @@argc@@ , ( _DWORD ) @@argv@@ , ( unsigned int ) String , ( unsigned int ) & unk_62F8 , ( _DWORD ) Version , ( unsigned int ) usage , String , String , String , Number L ) ; if ( getopt_long ( @@argc@@ , ( char * const * ) @@argv@@ , String , Number L , Number L ) == Number ) { if ( @@argc@@ == optind ) { uptime ( String , Number L ) ; LABEL_5 : exit ( Number ) ; } if ( @@argc@@ - optind == Number ) { uptime ( @@argv@@ [ optind ] , Number L ) ; goto LABEL_5 ; } @@v3@@ = quote ( @@argv@@ [ optind + Number ] ) ; @@v4@@ = dcgettext ( Number L , String , Number ) ; error ( Number , Number , @@v4@@ , @@v3@@ ) ; } usage ( Number ) ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
__int64 __fastcall protect_fd ( int @@a1@@ ) { unsigned int @@v1@@ ; int @@v2@@ ; @@v1@@ = Number ; @@v2@@ = open ( String , Number ) ; if ( @@a1@@ != @@v2@@ ) { @@v1@@ = Number ; if ( @@v2@@ >= Number ) { close ( @@v2@@ ) ; * __errno_location ( ) = Number ; } } return @@v1@@ ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
void __fastcall fwrite_uppcase ( FILE * @@stream@@ , unsigned __int8 * @@a2@@ , __int64 @@a3@@ ) { unsigned __int8 * @@v3@@ ; unsigned __int8 * @@v4@@ ; const __int32_t * * @@v5@@ ; __int64 @@v6@@ ; if ( @@a3@@ ) { @@v3@@ = @@a2@@ ; @@v4@@ = & @@a2@@ [ @@a3@@ ] ; @@v5@@ = __ctype_toupper_loc ( ) ; do { @@v6@@ = * @@v3@@ ++ ; fputc ( ( * @@v5@@ ) [ @@v6@@ ] , @@stream@@ ) ; } while ( @@v3@@ != @@v4@@ ) ; } }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
FILE * __fastcall fopen_safer ( const char * @@a1@@ , const char * @@a2@@ ) { FILE * @@v2@@ ; FILE * @@v3@@ ; unsigned int @@v4@@ ; int @@v6@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; int * @@v10@@ ; int @@v11@@ ; int * @@v12@@ ; @@v2@@ = fopen ( @@a1@@ , @@a2@@ ) ; @@v3@@ = @@v2@@ ; if ( @@v2@@ ) { @@v4@@ = fileno ( @@v2@@ ) ; if ( @@v4@@ <= Number ) { @@v6@@ = dup_safer ( @@v4@@ ) ; if ( @@v6@@ < Number ) { @@v10@@ = __errno_location ( ) ; @@v11@@ = * @@v10@@ ; @@v12@@ = @@v10@@ ; fclose ( @@v3@@ ) ; @@v3@@ = Number L ; * @@v12@@ = @@v11@@ ; } else if ( fclose ( @@v3@@ ) || ( @@v3@@ = fdopen ( @@v6@@ , @@a2@@ ) ) == Number L ) { @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; close ( @@v6@@ ) ; * @@v9@@ = @@v8@@ ; @@v3@@ = Number L ; } } } return @@v3@@ ; }
FILE * __fastcall freopen_safer ( const char * @@a1@@ , const char * @@a2@@ , FILE * @@a3@@ ) { int @@v4@@ ; int * @@v5@@ ; char @@v6@@ ; char @@v7@@ ; char @@v8@@ ; FILE * @@v9@@ ; int @@v10@@ ; @@v4@@ = fileno ( @@a3@@ ) ; @@v5@@ = __errno_location ( ) ; if ( @@v4@@ == Number ) { @@v6@@ = Number ; @@v7@@ = Number ; } else { if ( @@v4@@ == Number ) { @@v6@@ = Number ; } else { if ( ! @@v4@@ ) { @@v6@@ = Number ; @@v7@@ = Number ; @@v8@@ = Number ; LABEL_11 : @@v9@@ = freopen ( @@a1@@ , @@a2@@ , @@a3@@ ) ; goto LABEL_12 ; } @@v6@@ = dup2 ( Number , Number ) != Number ; } @@v7@@ = dup2 ( Number , Number ) != Number ; } if ( ! dup2 ( Number , Number ) ) { @@v8@@ = Number ; if ( ! @@v7@@ ) goto LABEL_9 ; goto LABEL_20 ; } @@v8@@ = protect_fd ( Number ) ; if ( ! @@v8@@ ) { @@v8@@ = Number ; @@v9@@ = Number L ; LABEL_12 : @@v10@@ = * @@v5@@ ; if ( ! @@v6@@ ) goto LABEL_13 ; goto LABEL_26 ; } if ( @@v7@@ ) { LABEL_20 : @@v7@@ = protect_fd ( Number ) ; if ( ! @@v7@@ ) { @@v9@@ = Number L ; @@v10@@ = * @@v5@@ ; if ( @@v6@@ ) close ( Number ) ; LABEL_23 : close ( Number ) ; if ( ! @@v8@@ ) goto LABEL_15 ; goto LABEL_24 ; } } LABEL_9 : if ( ! @@v6@@ ) goto LABEL_11 ; @@v6@@ = protect_fd ( Number ) ; if ( @@v6@@ ) goto LABEL_11 ; @@v10@@ = * @@v5@@ ; @@v9@@ = Number L ; LABEL_26 : close ( Number ) ; LABEL_13 : if ( @@v7@@ ) goto LABEL_23 ; if ( ! @@v8@@ ) goto LABEL_15 ; LABEL_24 : close ( Number ) ; LABEL_15 : if ( ! @@v9@@ ) * @@v5@@ = @@v10@@ ; return @@v9@@ ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
DIR * opendir ( const char * @@name@@ ) { return opendir ( @@name@@ ) ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
int __lxstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _lxstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
int closedir ( DIR * @@dirp@@ ) { return closedir ( @@dirp@@ ) ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
__mode_t umask ( __mode_t @@mask@@ ) { return umask ( @@mask@@ ) ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_209250 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_209230 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_209240 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_209250 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_209230 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_209240 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
int utmpxname ( const char * @@file@@ ) { return utmpxname ( @@file@@ ) ; }
DIR * fdopendir ( int @@fd@@ ) { return fdopendir ( @@fd@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
struct tm * localtime ( const time_t * @@timer@@ ) { return localtime ( @@timer@@ ) ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; FILE * @@v11@@ ; char * @@v12@@ ; FILE * @@v13@@ ; char * @@v14@@ ; char * @@v15@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String String String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String String String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String String String String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = stdout ; @@v10@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; @@v11@@ = stdout ; @@v12@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v12@@ , @@v11@@ ) ; last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v13@@ = stdout ; @@v14@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v14@@ , @@v13@@ ) ; @@v15@@ = setlocale ( Number , Number L ) ; if ( @@v15@@ ) { if ( strncmp ( @@v15@@ , String , Number ) ) { last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
time_t mktime ( struct tm * @@tp@@ ) { return mktime ( @@tp@@ ) ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; char * @@v7@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String String String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = setlocale ( Number , Number L ) ; if ( @@v7@@ ) { if ( strncmp ( @@v7@@ , String , Number ) ) { last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
__int64 __fastcall fd_ring_clear ( __int64 @@a1@@ ) { int @@v1@@ ; __int64 @@result@@ ; while ( Number ) { @@result@@ = i_ring_empty ( @@a1@@ ) ; if ( ( _BYTE ) @@result@@ ) break ; @@v1@@ = i_ring_pop ( @@a1@@ ) ; if ( @@v1@@ >= Number ) close ( @@v1@@ ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
int __lxstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _lxstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
int __fxstat ( int @@ver@@ , int @@fildes@@ , struct stat * @@stat_buf@@ ) { return _fxstat ( @@ver@@ , @@fildes@@ , @@stat_buf@@ ) ; }
char * __fastcall extract_trimmed_name ( __int64 @@a1@@ ) { char * @@v1@@ ; char * @@v2@@ ; @@v1@@ = ( char * ) xmalloc ( Number L ) ; strncpy ( @@v1@@ , ( const char * ) ( @@a1@@ + Number ) , Number ) ; @@v1@@ [ Number ] = Number ; @@v2@@ = & @@v1@@ [ strlen ( @@v1@@ ) ] ; if ( @@v1@@ < @@v2@@ ) { do { if ( * ( @@v2@@ - Number ) != Number ) break ; * -- @@v2@@ = Number ; } while ( @@v1@@ != @@v2@@ ) ; } return @@v1@@ ; }
__int64 __fastcall fts_palloc_isra_2 ( void * * @@a1@@ , size_t * @@a2@@ , __int64 @@a3@@ ) { void * @@v4@@ ; size_t @@v5@@ ; void * @@v6@@ ; __int64 @@result@@ ; @@v4@@ = * @@a1@@ ; @@v5@@ = * @@a2@@ + @@a3@@ + Number ; if ( * @@a2@@ > @@v5@@ ) { free ( @@v4@@ ) ; * @@a1@@ = Number L ; * __errno_location ( ) = Number ; @@result@@ = Number L ; } else { * @@a2@@ = @@v5@@ ; @@v6@@ = realloc ( @@v4@@ , @@v5@@ ) ; if ( @@v6@@ ) { * @@a1@@ = @@v6@@ ; @@result@@ = Number L ; } else { free ( * @@a1@@ ) ; * @@a1@@ = Number L ; @@result@@ = Number L ; } } return @@result@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
__int64 __fastcall fts_set ( __int64 a1 , __int64 @@a2@@ , unsigned int @@a3@@ ) { __int64 @@result@@ ; if ( @@a3@@ > Number ) { * __errno_location ( ) = Number ; @@result@@ = Number L ; } else { * ( _WORD * ) ( @@a2@@ + Number ) = @@a3@@ ; @@result@@ = Number L ; } return @@result@@ ; }
void __fastcall fwrite_lowcase ( FILE * @@stream@@ , unsigned __int8 * @@a2@@ , __int64 @@a3@@ ) { unsigned __int8 * @@v3@@ ; unsigned __int8 * @@v4@@ ; const __int32_t * * @@v5@@ ; __int64 @@v6@@ ; if ( @@a3@@ ) { @@v3@@ = @@a2@@ ; @@v4@@ = & @@a2@@ [ @@a3@@ ] ; @@v5@@ = __ctype_tolower_loc ( ) ; do { @@v6@@ = * @@v3@@ ++ ; fputc ( ( * @@v5@@ ) [ @@v6@@ ] , @@stream@@ ) ; } while ( @@v3@@ != @@v4@@ ) ; } }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_2091F0 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2091D0 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2091E0 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
unsigned __int64 __fastcall next_prime ( unsigned __int64 @@a1@@ ) { unsigned __int64 @@v1@@ ; unsigned __int64 @@v2@@ ; __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; if ( @@a1@@ < Number ) @@a1@@ = Number L ; @@v1@@ = @@a1@@ | Number ; if ( @@v1@@ != Number ) { while ( Number ) { @@v2@@ = @@v1@@ % Number ; if ( @@v1@@ <= Number ) goto LABEL_9 ; if ( @@v1@@ % Number ) break ; LABEL_10 : @@v1@@ += Number L ; if ( @@v1@@ == Number ) return @@v1@@ ; } @@v3@@ = Number L ; @@v4@@ = Number L ; @@v5@@ = Number L ; while ( Number ) { @@v5@@ += Number L ; @@v4@@ += @@v3@@ ; @@v2@@ = @@v1@@ % @@v5@@ ; if ( @@v4@@ >= @@v1@@ ) break ; @@v3@@ += Number L ; if ( ! ( @@v1@@ % @@v5@@ ) ) goto LABEL_10 ; } LABEL_9 : if ( @@v2@@ ) return @@v1@@ ; goto LABEL_10 ; } return @@v1@@ ; }
bool __fastcall mktime_ok ( _DWORD * @@a1@@ , struct tm * @@a2@@ , time_t @@a3@@ ) { bool @@result@@ ; time_t @@timer@@ ; @@timer@@ = @@a3@@ ; if ( @@a3@@ != Number || ( @@a2@@ = localtime ( & @@timer@@ ) , @@result@@ = Number , @@a2@@ ) ) { @@result@@ = ( @@a2@@ -> tm_year ^ @@a1@@ [ Number ] | @@a2@@ -> tm_mon ^ @@a1@@ [ Number ] | @@a2@@ -> tm_mday ^ @@a1@@ [ Number ] | @@a2@@ -> tm_hour ^ @@a1@@ [ Number ] | @@a2@@ -> tm_min ^ @@a1@@ [ Number ] | @@a2@@ -> tm_sec ^ * @@a1@@ ) == Number ; } return @@result@@ ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
char * * __fastcall lookup_zone ( __int64 @@a1@@ , const char * @@a2@@ ) { const char * @@v3@@ ; char * * @@v4@@ ; const char * @@v6@@ ; const char * * @@v7@@ ; const char * @@v8@@ ; @@v3@@ = String ; @@v4@@ = & universal_time_zone_table ; do { if ( ! strcmp ( @@a2@@ , @@v3@@ ) ) return @@v4@@ ; @@v4@@ += Number ; @@v3@@ = * @@v4@@ ; } while ( * @@v4@@ ) ; @@v6@@ = * ( const char * * ) ( @@a1@@ + Number ) ; @@v7@@ = ( const char * * ) ( @@a1@@ + Number ) ; if ( ! @@v6@@ ) { LABEL_6 : @@v4@@ = & time_zone_table ; @@v8@@ = String ; while ( strcmp ( @@a2@@ , @@v8@@ ) ) { @@v4@@ += Number ; @@v8@@ = * @@v4@@ ; if ( ! * @@v4@@ ) return Number L ; } return @@v4@@ ; } while ( strcmp ( @@a2@@ , @@v6@@ ) ) { @@v7@@ += Number ; @@v6@@ = * @@v7@@ ; if ( ! * @@v7@@ ) goto LABEL_6 ; } return ( char * * ) @@v7@@ ; }
__int64 __fastcall hash_print_statistics ( __int64 @@a1@@ ) { unsigned __int64 @@v1@@ ; _QWORD * @@v2@@ ; unsigned __int64 @@i@@ ; __int64 @@v4@@ ; unsigned __int64 @@j@@ ; @@v1@@ = Number L ; @@v2@@ = * ( _QWORD * * ) @@a1@@ ; for ( @@i@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; ( unsigned __int64 ) @@v2@@ < @@i@@ ; @@v2@@ += Number ) { if ( * @@v2@@ ) { @@v4@@ = @@v2@@ [ Number ] ; for ( @@j@@ = Number L ; @@v4@@ ; ++ @@j@@ ) @@v4@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; if ( @@v1@@ < @@j@@ ) @@v1@@ = @@j@@ ; } } __fprintf_chk ( ) ; __fprintf_chk ( ) ; __fprintf_chk ( ) ; return __fprintf_chk ( ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
__int64 __fastcall hash_get_next ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; __int64 * @@v6@@ ; _QWORD * @@v7@@ ; __int64 @@v8@@ ; __int64 @@result@@ ; @@v2@@ = * @@a1@@ ; @@v4@@ = ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) ; @@v5@@ = @@a1@@ [ Number ] ; @@v6@@ = ( __int64 * ) ( @@v2@@ + Number * @@v4@@ ) ; if ( @@v5@@ <= ( unsigned __int64 ) @@v6@@ ) abort ( ) ; if ( ! @@v6@@ ) goto LABEL_10 ; @@v7@@ = ( _QWORD * ) @@v6@@ [ Number ] ; if ( * @@v6@@ != @@a2@@ ) { do { if ( ! @@v7@@ ) goto LABEL_10 ; @@v8@@ = * @@v7@@ ; @@v7@@ = ( _QWORD * ) @@v7@@ [ Number ] ; } while ( @@v8@@ != @@a2@@ ) ; } if ( @@v7@@ ) return * @@v7@@ ; LABEL_10 : while ( Number ) { @@v6@@ += Number ; if ( @@v5@@ <= ( unsigned __int64 ) @@v6@@ ) break ; @@result@@ = * @@v6@@ ; if ( * @@v6@@ ) return @@result@@ ; } return Number L ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
__int64 __fastcall _xargmatch_internal ( __int64 @@a1@@ , const char * @@a2@@ , const char * * @@a3@@ , char * @@a4@@ , size_t @@a5@@ , void ( * @@a6@@ ) ( void ) ) { __int64 @@result@@ ; @@result@@ = argmatch ( @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; if ( @@result@@ < Number ) { argmatch_invalid ( @@a1@@ , ( __int64 ) @@a2@@ , @@result@@ ) ; argmatch_valid ( @@a3@@ , @@a4@@ , @@a5@@ ) ; @@a6@@ ( ) ; @@result@@ = Number ; } return @@result@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
int iconv_close ( iconv_t @@cd@@ ) { return iconv_close ( @@cd@@ ) ; }
void __fastcall hash_free ( void * @@ptr@@ ) { _QWORD * @@v2@@ ; unsigned __int64 @@v3@@ ; _QWORD * @@v4@@ ; _QWORD * @@v5@@ ; _QWORD * @@v6@@ ; _QWORD * @@v7@@ ; _QWORD * @@v8@@ ; @@v2@@ = * ( _QWORD * * ) @@ptr@@ ; @@v3@@ = * ( ( _QWORD * ) @@ptr@@ + Number ) ; if ( * ( ( _QWORD * ) @@ptr@@ + Number ) && * ( ( _QWORD * ) @@ptr@@ + Number ) ) { if ( ( unsigned __int64 ) @@v2@@ >= @@v3@@ ) goto LABEL_14 ; do { if ( * @@v2@@ ) { @@v4@@ = @@v2@@ ; do { ( * ( ( void ( * * ) ( void ) ) @@ptr@@ + Number ) ) ( ) ; @@v4@@ = ( _QWORD * ) @@v4@@ [ Number ] ; } while ( @@v4@@ ) ; @@v3@@ = * ( ( _QWORD * ) @@ptr@@ + Number ) ; } @@v2@@ += Number ; } while ( @@v3@@ > ( unsigned __int64 ) @@v2@@ ) ; @@v2@@ = * ( _QWORD * * ) @@ptr@@ ; } if ( ( unsigned __int64 ) @@v2@@ < @@v3@@ ) { do { @@v5@@ = ( _QWORD * ) @@v2@@ [ Number ] ; if ( @@v5@@ ) { do { @@v6@@ = ( _QWORD * ) @@v5@@ [ Number ] ; free ( @@v5@@ ) ; @@v5@@ = @@v6@@ ; } while ( @@v6@@ ) ; } @@v2@@ += Number ; } while ( * ( ( _QWORD * ) @@ptr@@ + Number ) > ( unsigned __int64 ) @@v2@@ ) ; } LABEL_14 : @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@ptr@@ + Number ) ; if ( @@v7@@ ) { do { @@v8@@ = ( _QWORD * ) @@v7@@ [ Number ] ; free ( @@v7@@ ) ; @@v7@@ = @@v8@@ ; } while ( @@v8@@ ) ; } free ( * ( void * * ) @@ptr@@ ) ; free ( @@ptr@@ ) ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
int iswalnum ( wint_t @@wc@@ ) { return iswalnum ( @@wc@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
char * nl_langinfo ( nl_item @@item@@ ) { return nl_langinfo ( @@item@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; FILE * @@v11@@ ; char * @@v12@@ ; FILE * @@v13@@ ; char * @@v14@@ ; FILE * @@v15@@ ; char * @@v16@@ ; FILE * @@v17@@ ; char * @@v18@@ ; FILE * @@v19@@ ; char * @@v20@@ ; char * @@v21@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String String String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = stdout ; @@v10@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; @@v11@@ = stdout ; @@v12@@ = dcgettext ( Number L , String String String , Number ) ; fputs_unlocked ( @@v12@@ , @@v11@@ ) ; @@v13@@ = stdout ; @@v14@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v14@@ , @@v13@@ ) ; @@v15@@ = stdout ; @@v16@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v16@@ , @@v15@@ ) ; @@v17@@ = stdout ; @@v18@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v18@@ , @@v17@@ ) ; last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v19@@ = stdout ; @@v20@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v20@@ , @@v19@@ ) ; @@v21@@ = setlocale ( Number , Number L ) ; if ( @@v21@@ ) { if ( strncmp ( @@v21@@ , String , Number ) ) { last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_2091F0 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2091D0 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_2091E0 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall dir_len ( _BYTE * @@a1@@ ) { unsigned __int64 @@v1@@ ; _BYTE * @@v2@@ ; __int64 @@v3@@ ; @@v1@@ = * @@a1@@ == Number ; @@v2@@ = last_component ( @@a1@@ ) ; if ( @@v2@@ - @@a1@@ <= @@v1@@ ) return @@v2@@ - @@a1@@ ; @@v3@@ = @@v2@@ - @@a1@@ - Number ; if ( * ( @@v2@@ - Number ) != Number ) return @@v2@@ - @@a1@@ ; while ( @@v1@@ != @@v3@@ && @@a1@@ [ @@v3@@ - Number ] == Number ) -- @@v3@@ ; return @@v3@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_20D250 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20D230 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20D240 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_20C230 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20C210 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_20C220 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
__int64 __fastcall set_cloexec_flag ( int @@a1@@ , char @@a2@@ , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { int @@v6@@ ; int @@v7@@ ; int @@v8@@ ; int @@v9@@ ; int @@v10@@ ; unsigned int @@v11@@ ; __int64 @@result@@ ; @@v6@@ = rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( @@v6@@ < Number ) return Number ; @@v9@@ = @@v6@@ ; @@v10@@ = @@v6@@ | Number ; @@v11@@ = @@v9@@ & Number ; if ( @@a2@@ ) @@v11@@ = @@v10@@ ; @@result@@ = Number L ; if ( @@v11@@ != @@v9@@ ) @@result@@ = ( unsigned int ) - ( ( unsigned int ) rpl_fcntl ( @@a1@@ , Number , @@v11@@ , @@v9@@ , @@v7@@ , @@v8@@ ) == Number ) ; return @@result@@ ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
__int64 __fastcall lutimens ( char * @@path@@ , const __m128i * @@a2@@ ) { int @@v2@@ ; struct timespec * @@v3@@ ; int @@v4@@ ; unsigned int @@v5@@ ; __time_t @@v7@@ ; __syscall_slong_t @@v8@@ ; struct timespec * @@times@@ ; __int128 @@v10@@ [ Number ] ; struct stat @@stat_buf@@ ; unsigned __int64 @@v12@@ ; @@v12@@ = __readfsqword ( Number ) ; if ( ! @@a2@@ ) { @@v3@@ = Number L ; @@v2@@ = Number ; @@times@@ = Number L ; if ( lutimensat_works_really < Number ) { lutimensat_works_really = Number ; LABEL_17 : if ( __lxstat ( Number , @@path@@ , & @@stat_buf@@ ) ) return ( unsigned int ) Number ; goto LABEL_12 ; } goto LABEL_6 ; } @@v10@@ [ Number ] = ( __int128 ) _mm_loadu_si128 ( @@a2@@ ) ; @@times@@ = ( struct timespec * ) @@v10@@ ; @@v10@@ [ Number ] = ( __int128 ) _mm_loadu_si128 ( @@a2@@ + Number ) ; @@v2@@ = validate_timespec ( @@v10@@ ) ; if ( @@v2@@ < Number ) return ( unsigned int ) Number ; if ( lutimensat_works_really >= Number ) { if ( @@v2@@ == Number ) { if ( __lxstat ( Number , @@path@@ , & @@stat_buf@@ ) ) return ( unsigned int ) Number ; @@v3@@ = @@times@@ ; if ( @@times@@ -> tv_nsec == Number ) { @@v8@@ = @@stat_buf@@ . st_atim . tv_nsec ; @@v2@@ = Number ; @@times@@ -> tv_sec = @@stat_buf@@ . st_atim . tv_sec ; @@v3@@ -> tv_nsec = @@v8@@ ; } else { @@v2@@ = Number ; if ( @@times@@ [ Number ] . tv_nsec == Number ) { @@v7@@ = @@stat_buf@@ . st_mtim . tv_sec ; @@times@@ [ Number ] . tv_nsec = @@stat_buf@@ . st_mtim . tv_nsec ; @@v3@@ [ Number ] . tv_sec = @@v7@@ ; } } } else { @@v3@@ = @@times@@ ; } LABEL_6 : @@v4@@ = utimensat ( Number , @@path@@ , @@v3@@ , Number ) ; @@v5@@ = @@v4@@ ; if ( @@v4@@ <= Number ) { if ( ! @@v4@@ || * __errno_location ( ) != Number ) { utimensat_works_really = Number ; lutimensat_works_really = Number ; return @@v5@@ ; } } else { * __errno_location ( ) = Number ; } } lutimensat_works_really = Number ; if ( ! @@v2@@ ) goto LABEL_17 ; if ( @@v2@@ == Number ) { if ( ! @@times@@ ) { LABEL_12 : if ( ( @@stat_buf@@ . st_mode & Number ) != Number ) return ( unsigned int ) fdutimens ( @@path@@ , Number , ( const __m128i * ) @@times@@ ) ; * __errno_location ( ) = Number ; return ( unsigned int ) Number ; } } else { if ( __lxstat ( Number , @@path@@ , & @@stat_buf@@ ) ) return ( unsigned int ) Number ; if ( ! @@times@@ ) goto LABEL_12 ; } @@v5@@ = Number ; if ( ! ( unsigned __int8 ) update_timespec ( & @@stat_buf@@ , & @@times@@ ) ) goto LABEL_12 ; return @@v5@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
int ferror ( FILE * @@stream@@ ) { return ferror ( @@stream@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
int feof ( FILE * @@stream@@ ) { return feof ( @@stream@@ ) ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_20F250 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20F230 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20F240 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
char * __fastcall str_iconv ( char * @@s@@ , char * @@fromcode@@ , char * @@tocode@@ ) { char * @@v4@@ ; iconv_t @@v6@@ ; void * @@v7@@ ; int * @@v8@@ ; int @@v9@@ ; int * @@v10@@ ; int * @@v11@@ ; int @@v12@@ ; int * @@v13@@ ; if ( * @@s@@ && ( unsigned int ) c_strcasecmp ( ( unsigned __int8 * ) @@fromcode@@ , ( unsigned __int8 * ) @@tocode@@ ) ) { @@v6@@ = iconv_open ( @@tocode@@ , @@fromcode@@ ) ; @@v7@@ = @@v6@@ ; if ( @@v6@@ == ( iconv_t ) Number ) return Number L ; @@v4@@ = str_cd_iconv ( @@s@@ , @@v6@@ ) ; if ( @@v4@@ ) { if ( iconv_close ( @@v7@@ ) < Number ) { @@v8@@ = __errno_location ( ) ; @@v9@@ = * @@v8@@ ; @@v10@@ = @@v8@@ ; free ( @@v4@@ ) ; @@v4@@ = Number L ; * @@v10@@ = @@v9@@ ; } } else { @@v11@@ = __errno_location ( ) ; @@v12@@ = * @@v11@@ ; @@v13@@ = @@v11@@ ; iconv_close ( @@v7@@ ) ; * @@v13@@ = @@v12@@ ; } return @@v4@@ ; } @@v4@@ = strdup ( @@s@@ ) ; if ( @@v4@@ ) return @@v4@@ ; * __errno_location ( ) = Number ; return Number L ; }
__int64 __fastcall argv_iter ( __int64 @@a1@@ , _DWORD * @@a2@@ ) { __int64 @@result@@ ; __int64 * @@v3@@ ; if ( * ( _QWORD * ) @@a1@@ ) { if ( getdelim ( ( char * * ) ( @@a1@@ + Number ) , ( size_t * ) ( @@a1@@ + Number ) , Number , * ( FILE * * ) @@a1@@ ) < Number ) { * @@a2@@ = feof ( * ( FILE * * ) @@a1@@ ) == Number ? Number : Number ; @@result@@ = Number L ; } else { * @@a2@@ = Number ; ++ * ( _QWORD * ) ( @@a1@@ + Number ) ; @@result@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; } } else { @@v3@@ = * ( __int64 * * ) ( @@a1@@ + Number ) ; @@result@@ = * @@v3@@ ; if ( * @@v3@@ ) { * @@a2@@ = Number ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v3@@ + Number ; } else { * @@a2@@ = Number ; } } return @@result@@ ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
void __fastcall freea ( unsigned __int64 @@a1@@ ) { __int64 @@v1@@ ; __int64 @@v2@@ ; _QWORD * @@v3@@ ; if ( @@a1@@ ) { if ( * ( _DWORD * ) ( @@a1@@ - Number ) == Number ) { @@v1@@ = mmalloca_results [ @@a1@@ % Number ] ; if ( @@v1@@ ) { if ( @@v1@@ == @@a1@@ ) { @@v3@@ = & mmalloca_results [ @@a1@@ % Number ] ; LABEL_12 : * @@v3@@ = * ( _QWORD * ) ( @@a1@@ - Number ) ; free ( ( void * ) ( @@a1@@ - Number ) ) ; } else { while ( Number ) { @@v2@@ = * ( _QWORD * ) ( @@v1@@ - Number ) ; if ( ! @@v2@@ ) break ; if ( @@a1@@ == @@v2@@ ) { @@v3@@ = ( _QWORD * ) ( @@v1@@ - Number ) ; goto LABEL_12 ; } @@v1@@ = * ( _QWORD * ) ( @@v1@@ - Number ) ; } } } } } }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
_QWORD * __fastcall save_token ( __int64 @@a1@@ ) { __int64 @@v1@@ ; __int64 @@v2@@ ; __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; __int64 @@v5@@ ; unsigned __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; _QWORD * @@v8@@ ; _QWORD * @@result@@ ; @@v1@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v3@@ = ( unsigned int ) ( * ( _DWORD * ) ( @@a1@@ + Number ) - @@v2@@ - Number ) ; if ( @@v1@@ == @@v2@@ ) * ( _BYTE * ) ( @@a1@@ + Number ) |= Number ; @@v4@@ = @@v1@@ + * ( int * ) ( @@a1@@ + Number ) ; @@v5@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v6@@ = ~ * ( _DWORD * ) ( @@a1@@ + Number ) & @@v4@@ ; @@v7@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v6@@ ; if ( ( __int64 ) ( @@v6@@ - @@v5@@ ) > ( __int64 ) ( @@v7@@ - @@v5@@ ) ) { * ( _QWORD * ) ( @@a1@@ + Number ) = @@v7@@ ; @@v6@@ = @@v7@@ ; } * ( _QWORD * ) ( @@a1@@ + Number ) = @@v6@@ ; @@v8@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) < ( unsigned __int64 ) ( @@v8@@ + Number ) ) { _obstack_newchunk ( ( struct obstack * ) ( @@a1@@ + Number ) , Number ) ; @@v8@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; } * @@v8@@ = @@v2@@ ; @@result@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) += Number L ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) < ( unsigned __int64 ) ( @@result@@ + Number ) ) { _obstack_newchunk ( ( struct obstack * ) ( @@a1@@ + Number ) , Number ) ; @@result@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; } * @@result@@ = @@v3@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) += Number L ; ++ * ( _QWORD * ) @@a1@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_20F250 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20F230 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_20F240 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall digest_file_isra_0 ( const char * @@a1@@ ) { FILE * @@v1@@ ; unsigned int @@v2@@ ; int * @@v4@@ ; FILE * @@v5@@ ; int * @@v6@@ ; if ( ! strcmp ( @@a1@@ , String ) ) { @@v1@@ = stdin ; have_read_stdin = Number ; if ( ! ( unsigned int ) md5_stream ( stdin ) ) return Number ; goto LABEL_5 ; } @@v5@@ = ( FILE * ) fopen_safer ( @@a1@@ , String ) ; @@v1@@ = @@v5@@ ; if ( ! @@v5@@ ) { LABEL_10 : @@v6@@ = __errno_location ( ) ; error ( Number , * @@v6@@ , format , @@a1@@ ) ; return Number L ; } if ( ! ( unsigned int ) md5_stream ( @@v5@@ ) ) { if ( ! fclose ( @@v1@@ ) ) return Number ; goto LABEL_10 ; } LABEL_5 : @@v4@@ = __errno_location ( ) ; @@v2@@ = Number ; error ( Number , * @@v4@@ , format , @@a1@@ ) ; if ( stdin == @@v1@@ ) return @@v2@@ ; fclose ( @@v1@@ ) ; return Number L ; }
char * __fastcall areadlink ( char * @@path@@ ) { int @@v1@@ ; size_t @@v2@@ ; char * @@v3@@ ; ssize_t @@v4@@ ; char * @@v5@@ ; size_t @@v7@@ ; char * @@v8@@ ; char * @@v9@@ ; _QWORD @@v10@@ [ Number ] ; @@v1@@ = Number ; @@v2@@ = Number L ; @@v10@@ [ Number ] = __readfsqword ( Number ) ; @@v3@@ = ( char * ) @@v10@@ ; while ( Number ) { @@v4@@ = readlink ( @@path@@ , @@v3@@ , @@v2@@ ) ; if ( @@v4@@ < Number && * __errno_location ( ) != Number ) { if ( @@v3@@ != ( char * ) @@v10@@ ) { @@v5@@ = @@v3@@ ; @@v3@@ = Number L ; free ( @@v5@@ ) ; return @@v3@@ ; } return Number L ; } if ( @@v4@@ < @@v2@@ ) break ; if ( @@v3@@ != ( char * ) @@v10@@ ) free ( @@v3@@ ) ; @@v2@@ *= Number L ; if ( ! -- @@v1@@ ) { @@v3@@ = Number L ; * __errno_location ( ) = Number ; return @@v3@@ ; } @@v3@@ = ( char * ) malloc ( @@v2@@ ) ; if ( ! @@v3@@ ) return Number L ; } @@v3@@ [ @@v4@@ ] = Number ; @@v7@@ = @@v4@@ + Number ; if ( @@v3@@ == ( char * ) @@v10@@ ) { @@v9@@ = ( char * ) malloc ( @@v7@@ ) ; @@v3@@ = @@v9@@ ; if ( @@v9@@ ) memcpy ( @@v9@@ , @@v10@@ , @@v7@@ ) ; } else if ( @@v2@@ > @@v7@@ ) { @@v8@@ = ( char * ) realloc ( @@v3@@ , @@v7@@ ) ; if ( @@v8@@ ) @@v3@@ = @@v8@@ ; } return @@v3@@ ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
int fileno ( FILE * @@stream@@ ) { return fileno ( @@stream@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
_DWORD * __fastcall md5_read_ctx ( _DWORD * @@a1@@ , _DWORD * @@a2@@ ) { _DWORD * @@result@@ ; @@result@@ = @@a2@@ ; * @@a2@@ = * @@a1@@ ; @@a2@@ [ Number ] = @@a1@@ [ Number ] ; @@a2@@ [ Number ] = @@a1@@ [ Number ] ; @@a2@@ [ Number ] = @@a1@@ [ Number ] ; return @@result@@ ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_2061F0 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061D0 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_2061E0 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_208230 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_208210 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_208220 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; char * @@v11@@ ; FILE * @@v12@@ ; char * @@v13@@ ; char * @@v14@@ ; char * @@v15@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String String String String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String String String String String String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = stdout ; @@v10@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; @@v11@@ = dcgettext ( Number L , String String String String String , Number ) ; __printf_chk ( ) ; last_component ( program_name , @@v11@@ ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v12@@ = stdout ; @@v13@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v13@@ , @@v12@@ ) ; @@v14@@ = Number L ; @@v15@@ = setlocale ( Number , Number L ) ; if ( @@v15@@ ) { @@v14@@ = String ; if ( strncmp ( @@v15@@ , String , Number ) ) { last_component ( program_name , String ) ; @@v14@@ = dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name , @@v14@@ ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
_DWORD * __fastcall md5_finish_ctx ( _DWORD * @@a1@@ , _DWORD * @@a2@@ ) { __int64 @@v2@@ ; int @@v4@@ ; int @@v5@@ ; unsigned __int64 @@v6@@ ; bool @@v7@@ ; unsigned int @@v8@@ ; unsigned __int64 @@v9@@ ; _QWORD * @@v10@@ ; @@v2@@ = ( unsigned int ) @@a1@@ [ Number ] ; @@v4@@ = @@a1@@ [ Number ] ; @@v5@@ = @@a1@@ [ Number ] ; @@v6@@ = ( - ( __int64 ) ( ( unsigned int ) @@v2@@ < Number ) & Number ) + Number ; @@v7@@ = __CFADD__ ( @@a1@@ [ Number ] , @@v5@@ ) ; @@v8@@ = @@a1@@ [ Number ] + @@v5@@ ; @@a1@@ [ Number ] = @@v8@@ ; if ( @@v7@@ ) @@a1@@ [ Number ] = ++ @@v4@@ ; @@a1@@ [ ( - ( __int64 ) ( ( unsigned int ) @@v2@@ < Number ) & Number ) + Number ] = Number * @@v8@@ ; @@a1@@ [ ( - ( __int64 ) ( ( unsigned int ) @@v2@@ < Number ) & Number ) + Number ] = ( @@v8@@ >> Number ) | ( Number * @@v4@@ ) ; @@v9@@ = @@v6@@ - @@v2@@ - Number ; @@v10@@ = ( _QWORD * ) ( ( char * ) @@a1@@ + @@v2@@ + Number ) ; if ( @@v9@@ >= Number ) { * @@v10@@ = fillbuf ; * ( _QWORD * ) ( ( char * ) @@v10@@ + @@v9@@ - Number ) = * ( __int64 * * ) ( ( char * ) & fillbuf + @@v9@@ - Number ) ; qmemcpy ( ( void * ) ( ( unsigned __int64 ) ( @@v10@@ + Number ) & Number ) , ( const void * ) ( ( char * ) & fillbuf - ( ( char * ) @@v10@@ - ( ( unsigned __int64 ) ( @@v10@@ + Number ) & Number ) ) ) , Number * ( ( ( unsigned __int64 ) @@v10@@ + @@v9@@ - ( ( unsigned __int64 ) ( @@v10@@ + Number ) & Number ) ) >> Number ) ) ; } else if ( ( @@v9@@ & Number ) != Number ) { * ( _DWORD * ) @@v10@@ = ( _DWORD ) fillbuf ; * ( _DWORD * ) ( ( char * ) @@v10@@ + @@v9@@ - Number ) = * ( _DWORD * ) ( ( char * ) & fillbuf + @@v9@@ - Number ) ; } else if ( @@v6@@ - @@v2@@ != Number ) { * ( _BYTE * ) @@v10@@ = ( _BYTE ) fillbuf ; if ( ( @@v9@@ & Number ) != Number ) * ( _WORD * ) ( ( char * ) @@v10@@ + @@v9@@ - Number ) = * ( _WORD * ) ( ( char * ) & fillbuf + @@v9@@ - Number ) ; } md5_process_block ( @@a1@@ + Number , @@v6@@ , @@a1@@ ) ; return md5_read_ctx ( @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall dup_safer ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ , char @@a7@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ , @@a7@@ ) ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
int raise ( int @@sig@@ ) { return raise ( @@sig@@ ) ; }
_DWORD * __fastcall md5_buffer ( void * @@a1@@ , size_t @@a2@@ , _DWORD * @@a3@@ ) { __int64 @@v5@@ [ Number ] ; int @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v5@@ [ Number ] = Number L ; @@v5@@ [ Number ] = Number ; @@v5@@ [ Number ] = Number ; @@v6@@ = Number ; md5_process_bytes ( @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; return md5_finish_ctx ( @@v5@@ , @@a3@@ ) ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
int isatty ( int @@fd@@ ) { return isatty ( @@fd@@ ) ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
int clock_gettime ( clockid_t @@clock_id@@ , struct timespec * @@tp@@ ) { return clock_gettime ( @@clock_id@@ , @@tp@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
int __lxstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _lxstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
__int64 __fastcall rpl_fcntl ( int @@a1@@ , int @@a2@@ , __int64 @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { int @@v6@@ ; int @@v8@@ ; int @@v9@@ ; int @@v10@@ ; int @@v11@@ ; int * @@v12@@ ; int @@v13@@ ; int * @@v14@@ ; int @@v15@@ ; @@v15@@ = @@a3@@ ; if ( @@a2@@ != Number ) return ( unsigned int ) fcntl ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( have_dupfd_cloexec_3202 < Number ) { @@v6@@ = ( ( __int64 ( __fastcall * ) ( int , _DWORD , _DWORD , int , int , int , char ) ) rpl_fcntl ) ( @@a1@@ , Number , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ , Number ) ; if ( @@v6@@ < Number || have_dupfd_cloexec_3202 != Number ) return ( unsigned int ) @@v6@@ ; } else { @@v6@@ = fcntl ( @@a1@@ , Number , ( unsigned int ) @@a3@@ ) ; if ( @@v6@@ >= Number || * __errno_location ( ) != Number ) { have_dupfd_cloexec_3202 = Number ; return ( unsigned int ) @@v6@@ ; } @@v6@@ = ( ( __int64 ( __fastcall * ) ( int , _DWORD , int , int , int , int , char ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v15@@ , @@v8@@ , @@v9@@ , @@v10@@ , Number ) ; if ( @@v6@@ < Number ) return ( unsigned int ) @@v6@@ ; have_dupfd_cloexec_3202 = Number ; } @@v11@@ = fcntl ( @@v6@@ , Number ) ; if ( @@v11@@ < Number || fcntl ( @@v6@@ , Number , @@v11@@ | Number ) == Number ) { @@v12@@ = __errno_location ( ) ; @@v13@@ = * @@v12@@ ; @@v14@@ = @@v12@@ ; close ( @@v6@@ ) ; @@v6@@ = Number ; * @@v14@@ = @@v13@@ ; } return ( unsigned int ) @@v6@@ ; }
int __xstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _xstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
time_t mktime ( struct tm * @@tp@@ ) { return mktime ( @@tp@@ ) ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
unsigned __int64 __fastcall AD_hash ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) % @@a2@@ ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
void * __fastcall get_tz ( void * @@dest@@ ) { char * @@v1@@ ; char * @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v1@@ = getenv ( String ) ; if ( ! @@v1@@ ) return Number L ; @@v2@@ = @@v1@@ ; @@v3@@ = strlen ( @@v1@@ ) ; if ( @@v3@@ + Number <= Number ) @@result@@ = memcpy ( @@dest@@ , @@v2@@ , @@v3@@ + Number ) ; else @@result@@ = ( void * ) xmemdup ( @@v2@@ , @@v3@@ + Number ) ; return @@result@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 __fastcall fts_compare_ino ( __int64 @@a1@@ , __int64 @@a2@@ ) { unsigned __int64 @@v2@@ ; __int64 @@result@@ ; @@v2@@ = * ( _QWORD * ) ( * ( _QWORD * ) @@a2@@ + Number L ) ; if ( * ( _QWORD * ) ( * ( _QWORD * ) @@a1@@ + Number L ) < @@v2@@ ) @@result@@ = Number ; else @@result@@ = * ( _QWORD * ) ( * ( _QWORD * ) @@a1@@ + Number L ) > @@v2@@ ; return @@result@@ ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; program_invocation_short_name = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
int __xstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _xstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
int __fastcall strcmp_size ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; @@v2@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) > @@v2@@ ) return Number ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) < @@v2@@ ) return Number ; return strcmp ( * ( const char * * ) @@a1@@ , * ( const char * * ) @@a2@@ ) ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
void __fastcall cwd_advance_fd ( __int64 @@a1@@ , int @@a2@@ , char @@a3@@ ) { int @@v4@@ ; int @@v5@@ ; @@v4@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; if ( @@v4@@ == @@a2@@ && @@v4@@ != Number ) abort ( ) ; if ( @@a3@@ ) { @@v5@@ = i_ring_push ( @@a1@@ + Number ) ; if ( @@v5@@ < Number ) { LABEL_6 : * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; return ; } close ( @@v5@@ ) ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; } else { if ( ( * ( _BYTE * ) ( @@a1@@ + Number ) & Number ) != Number || @@v4@@ < Number ) goto LABEL_6 ; close ( @@v4@@ ) ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; } }
int unsetenv ( const char * @@name@@ ) { return unsetenv ( @@name@@ ) ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
int __fastcall rev_xstrcoll_size ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; bool @@v3@@ ; int @@result@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v3@@ = * ( _QWORD * ) ( @@a2@@ + Number ) < @@v2@@ ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) > @@v2@@ ) return Number ; @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = xstrcoll ( * ( char * * ) @@a2@@ , * ( char * * ) @@a1@@ ) ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
__int64 __fastcall enter_dir_isra_11 ( __int16 @@a1@@ , _QWORD * @@a2@@ , __int64 @@a3@@ ) { _QWORD * @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; __int64 @@result@@ ; if ( ( @@a1@@ & Number ) != Number ) { @@v4@@ = malloc ( Number ) ; if ( @@v4@@ ) { @@v5@@ = * ( _QWORD * ) ( @@a3@@ + Number ) ; @@v6@@ = * @@a2@@ ; @@v4@@ [ Number ] = @@a3@@ ; * @@v4@@ = @@v5@@ ; @@v4@@ [ Number ] = * ( _QWORD * ) ( @@a3@@ + Number ) ; @@v7@@ = hash_insert ( @@v6@@ , @@v4@@ ) ; if ( @@v4@@ == ( _QWORD * ) @@v7@@ ) return Number L ; free ( @@v4@@ ) ; if ( @@v7@@ ) { @@v8@@ = * ( _QWORD * ) ( @@v7@@ + Number ) ; * ( _WORD * ) ( @@a3@@ + Number ) = Number ; * ( _QWORD * ) @@a3@@ = @@v8@@ ; return Number L ; } } @@result@@ = Number L ; } else { @@result@@ = cycle_check ( * @@a2@@ , @@a3@@ + Number ) ; if ( ! ( _BYTE ) @@result@@ ) return Number L ; * ( _QWORD * ) @@a3@@ = @@a3@@ ; * ( _WORD * ) ( @@a3@@ + Number ) = Number ; } return @@result@@ ; }
size_t __fastcall format_user ( unsigned int @@a1@@ , int @@a2@@ , char @@a3@@ ) { char * @@v3@@ ; @@v3@@ = String ; if ( @@a3@@ ) { @@v3@@ = Number L ; if ( ! numeric_ids ) @@v3@@ = ( char * ) getuser ( ) ; } return format_user_or_group ( @@v3@@ , @@a1@@ , @@a2@@ ) ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; FILE * @@v11@@ ; char * @@v12@@ ; FILE * @@v13@@ ; char * @@v14@@ ; FILE * @@v15@@ ; char * @@v16@@ ; FILE * @@v17@@ ; char * @@v18@@ ; char * @@v19@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String String String String String String String String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String String String String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = stdout ; @@v10@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; @@v11@@ = stdout ; @@v12@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v12@@ , @@v11@@ ) ; @@v13@@ = stdout ; @@v14@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v14@@ , @@v13@@ ) ; @@v15@@ = stdout ; @@v16@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v16@@ , @@v15@@ ) ; last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v17@@ = stdout ; @@v18@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v18@@ , @@v17@@ ) ; @@v19@@ = setlocale ( Number , Number L ) ; if ( @@v19@@ ) { if ( strncmp ( @@v19@@ , String , Number ) ) { last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
__int64 __fastcall argmatch_to_argument ( void * @@s1@@ , __int64 * @@a2@@ , char * @@a3@@ , size_t @@a4@@ ) { __int64 @@v4@@ ; __int64 * @@v7@@ ; @@v4@@ = * @@a2@@ ; if ( * @@a2@@ ) { @@v7@@ = @@a2@@ + Number ; do { if ( ! memcmp ( @@s1@@ , @@a3@@ , @@a4@@ ) ) break ; @@v4@@ = * @@v7@@ ; @@a3@@ += @@a4@@ ; ++ @@v7@@ ; } while ( @@v4@@ ) ; } return @@v4@@ ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
void __fastcall file_failure ( char @@a1@@ , const char * @@a2@@ , __int64 @@a3@@ ) { __int64 @@v3@@ ; int * @@v4@@ ; @@v3@@ = quotearg_colon ( @@a3@@ ) ; @@v4@@ = __errno_location ( ) ; error ( Number , * @@v4@@ , @@a2@@ , @@v3@@ ) ; if ( @@a1@@ ) { exit_status = Number ; } else if ( ! exit_status ) { exit_status = Number ; } }
__int64 __fastcall check_tuning_isra_0 ( float * * @@a1@@ ) { float * @@v1@@ ; __int64 @@result@@ ; float @@v3@@ ; float @@v4@@ ; float @@v5@@ ; @@v1@@ = * @@a1@@ ; @@result@@ = Number L ; if ( * @@a1@@ != ( float * ) & default_tuning ) { @@v3@@ = @@v1@@ [ Number ] ; if ( @@v3@@ <= Number || @@v3@@ >= Number || @@v1@@ [ Number ] <= Number || * @@v1@@ < Number || ( @@v4@@ = * @@v1@@ + Number , @@v5@@ = @@v1@@ [ Number ] , @@v5@@ <= @@v4@@ ) || @@v5@@ > Number || @@v3@@ <= @@v4@@ ) { * @@a1@@ = ( float * ) & default_tuning ; @@result@@ = Number L ; } } return @@result@@ ; }
void __fastcall argmatch_invalid ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { char * @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; if ( @@a3@@ == Number ) @@v3@@ = dcgettext ( Number L , String , Number ) ; else @@v3@@ = dcgettext ( Number L , String , Number ) ; @@v4@@ = quote_n ( Number L , @@a1@@ ) ; @@v5@@ = quotearg_n_style ( Number L , Number L , @@a2@@ ) ; error ( Number , Number , @@v3@@ , @@v5@@ , @@v4@@ ) ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_208210 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2081F0 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_208200 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
__int64 __fastcall hash_lookup ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; _QWORD * @@v4@@ ; __int64 @@v5@@ ; @@v2@@ = * @@a1@@ ; @@v4@@ = ( _QWORD * ) ( Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) + @@v2@@ ) ; if ( @@a1@@ [ Number ] <= ( unsigned __int64 ) @@v4@@ ) abort ( ) ; @@v5@@ = * @@v4@@ ; if ( ! * @@v4@@ ) return Number L ; while ( @@v5@@ != @@a2@@ ) { if ( ( ( unsigned __int8 ( __fastcall * ) ( __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ ) ) return * @@v4@@ ; @@v4@@ = ( _QWORD * ) @@v4@@ [ Number ] ; if ( ! @@v4@@ ) return Number L ; @@v5@@ = * @@v4@@ ; } return @@v5@@ ; }
__int64 __fastcall year_isra_0 ( int * @@a1@@ , int * @@a2@@ , __int64 @@a3@@ , char @@a4@@ ) { __int64 @@result@@ ; struct tm * @@v5@@ ; int @@v6@@ ; time_t @@v7@@ ; unsigned __int64 @@v8@@ ; @@v8@@ = __readfsqword ( Number ) ; if ( @@a3@@ == Number ) { @@v6@@ = * @@a2@@ ; @@result@@ = Number L ; * @@a1@@ = * @@a2@@ ; if ( * @@a2@@ > Number ) return @@result@@ ; if ( ( @@a4@@ & Number ) == Number ) { * @@a1@@ = @@v6@@ + Number ; return @@result@@ ; } return Number L ; } if ( ! @@a3@@ ) { time ( & @@v7@@ ) ; @@v5@@ = localtime ( & @@v7@@ ) ; if ( @@v5@@ ) { * @@a1@@ = @@v5@@ -> tm_year ; return Number L ; } return Number L ; } if ( @@a3@@ != Number ) abort ( ) ; if ( ( @@a4@@ & Number ) == Number ) return Number L ; * @@a1@@ = @@a2@@ [ Number ] + Number * * @@a2@@ - Number ; return Number L ; }
int __fastcall rev_strcmp_df_mtime ( __int64 @@a1@@ , __int64 @@a2@@ ) { bool @@v2@@ ; bool @@v3@@ ; int @@result@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; @@v2@@ = * ( _DWORD * ) ( @@a1@@ + Number ) == Number || * ( _DWORD * ) ( @@a1@@ + Number ) == Number ; @@v3@@ = * ( _DWORD * ) ( @@a2@@ + Number ) == Number || * ( _DWORD * ) ( @@a2@@ + Number ) == Number ; if ( ! @@v3@@ && @@v2@@ ) return Number ; if ( @@v2@@ || ( @@result@@ = Number , ! @@v3@@ ) ) { @@v5@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) <= @@v5@@ ) { if ( * ( _QWORD * ) ( @@a2@@ + Number ) < @@v5@@ ) return Number ; @@v6@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) <= @@v6@@ ) { if ( * ( _QWORD * ) ( @@a2@@ + Number ) >= @@v6@@ ) return strcmp ( * ( const char * * ) @@a2@@ , * ( const char * * ) @@a1@@ ) ; return Number ; } } return Number ; } return @@result@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
__int64 __fastcall hash_do_for_each ( __int64 @@a1@@ , unsigned __int8 ( __fastcall * @@a2@@ ) ( __int64 , __int64 ) , __int64 @@a3@@ ) { __int64 * @@v3@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 * @@v8@@ ; @@v3@@ = * ( __int64 * * ) @@a1@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= * ( _QWORD * ) @@a1@@ ) return Number L ; @@v6@@ = Number L ; while ( Number ) { @@v7@@ = * @@v3@@ ; if ( * @@v3@@ ) break ; LABEL_8 : @@v3@@ += Number ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= ( unsigned __int64 ) @@v3@@ ) return @@v6@@ ; } @@v8@@ = @@v3@@ ; while ( @@a2@@ ( @@v7@@ , @@a3@@ ) ) { @@v8@@ = ( __int64 * ) @@v8@@ [ Number ] ; ++ @@v6@@ ; if ( ! @@v8@@ ) goto LABEL_8 ; @@v7@@ = * @@v8@@ ; } return @@v6@@ ; }
int __fastcall rev_xstrcoll_df_size ( __int64 @@a1@@ , __int64 @@a2@@ ) { bool @@v2@@ ; bool @@v3@@ ; int @@result@@ ; __int64 @@v5@@ ; bool @@v6@@ ; @@v2@@ = * ( _DWORD * ) ( @@a1@@ + Number ) == Number || * ( _DWORD * ) ( @@a1@@ + Number ) == Number ; @@v3@@ = * ( _DWORD * ) ( @@a2@@ + Number ) == Number || * ( _DWORD * ) ( @@a2@@ + Number ) == Number ; if ( ! @@v3@@ && @@v2@@ ) goto LABEL_9 ; if ( @@v2@@ || ( @@result@@ = Number , ! @@v3@@ ) ) { @@v5@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v6@@ = * ( _QWORD * ) ( @@a2@@ + Number ) < @@v5@@ ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) <= @@v5@@ ) { @@result@@ = Number ; if ( ! @@v6@@ ) @@result@@ = xstrcoll ( * ( char * * ) @@a2@@ , * ( char * * ) @@a1@@ ) ; return @@result@@ ; } LABEL_9 : @@result@@ = Number ; } return @@result@@ ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
void __fastcall hash_clear ( _QWORD * @@a1@@ ) { _QWORD * @@v1@@ ; _QWORD * @@v2@@ ; void ( __fastcall * @@v3@@ ) ( _QWORD ) ; _QWORD * @@v4@@ ; __int64 @@v5@@ ; @@v1@@ = ( _QWORD * ) * @@a1@@ ; if ( * @@a1@@ < @@a1@@ [ Number ] ) { do { if ( * @@v1@@ ) { @@v2@@ = ( _QWORD * ) @@v1@@ [ Number ] ; @@v3@@ = ( void ( __fastcall * ) ( _QWORD ) ) @@a1@@ [ Number ] ; if ( @@v2@@ ) { do { if ( @@v3@@ ) { @@v3@@ ( * @@v2@@ ) ; @@v3@@ = ( void ( __fastcall * ) ( _QWORD ) ) @@a1@@ [ Number ] ; } @@v4@@ = ( _QWORD * ) @@v2@@ [ Number ] ; @@v5@@ = @@a1@@ [ Number ] ; * @@v2@@ = Number L ; @@v2@@ [ Number ] = @@v5@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v2@@ = @@v4@@ ; } while ( @@v4@@ ) ; } if ( @@v3@@ ) @@v3@@ ( * @@v1@@ ) ; * @@v1@@ = Number L ; @@v1@@ [ Number ] = Number L ; } @@v1@@ += Number ; } while ( @@a1@@ [ Number ] > ( unsigned __int64 ) @@v1@@ ) ; } @@a1@@ [ Number ] = Number L ; @@a1@@ [ Number ] = Number L ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
int __fastcall rev_xstrcoll_df_name ( __int64 @@a1@@ , __int64 @@a2@@ ) { bool @@v2@@ ; bool @@v3@@ ; int @@result@@ ; @@v2@@ = * ( _DWORD * ) ( @@a1@@ + Number ) == Number || * ( _DWORD * ) ( @@a1@@ + Number ) == Number ; @@v3@@ = * ( _DWORD * ) ( @@a2@@ + Number ) == Number || * ( _DWORD * ) ( @@a2@@ + Number ) == Number ; if ( ! @@v3@@ && @@v2@@ ) return Number ; if ( @@v2@@ || ( @@result@@ = Number , ! @@v3@@ ) ) @@result@@ = xstrcoll ( * ( char * * ) @@a2@@ , * ( char * * ) @@a1@@ ) ; return @@result@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall open_safer ( const char * @@a1@@ , char @@a2@@ , unsigned int @@a3@@ ) { __int64 @@v3@@ ; int @@v4@@ ; @@v3@@ = Number L ; if ( ( @@a2@@ & Number ) != Number ) @@v3@@ = @@a3@@ ; @@v4@@ = open ( @@a1@@ , @@a2@@ , @@v3@@ ) ; return fd_safer ( @@v4@@ ) ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
DIR * __fastcall opendir_safer ( const char * @@a1@@ ) { DIR * @@v1@@ ; DIR * @@v2@@ ; unsigned int @@v3@@ ; int @@v5@@ ; DIR * @@v6@@ ; int * @@v7@@ ; int @@v8@@ ; @@v1@@ = opendir ( @@a1@@ ) ; @@v2@@ = @@v1@@ ; if ( ! @@v1@@ ) return @@v2@@ ; @@v3@@ = dirfd ( @@v1@@ ) ; if ( @@v3@@ > Number ) return @@v2@@ ; @@v5@@ = dup_safer ( @@v3@@ ) ; @@v6@@ = fdopendir ( @@v5@@ ) ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; if ( ! @@v6@@ ) close ( @@v5@@ ) ; closedir ( @@v2@@ ) ; * @@v7@@ = @@v8@@ ; return @@v6@@ ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
__int64 __fastcall apply_relative_time ( __int64 @@a1@@ , int @@a2@@ , __int64 a3 , __int64 a4 , __int64 a5 , __int64 a6 , __int64 @@a7@@ , __int64 @@a8@@ , __int64 @@a9@@ , __int64 @@a10@@ , __int64 @@a11@@ , __int64 @@a12@@ , __int64 @@a13@@ ) { __int64 @@result@@ ; * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; * ( _QWORD * ) ( @@a1@@ + Number ) += @@a2@@ * @@a13@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) += @@a2@@ * @@a12@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) += @@a2@@ * @@a11@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) += @@a2@@ * @@a10@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) += @@a2@@ * @@a9@@ ; @@result@@ = @@a2@@ * @@a8@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) += @@result@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) += @@a7@@ * @@a2@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number , @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
size_t __fastcall length_of_file_name_and_frills ( __int64 @@a1@@ ) { __int64 @@v1@@ ; __int64 @@v2@@ ; size_t @@v3@@ ; const char * @@v5@@ ; __int64 @@v6@@ ; const char * @@v7@@ ; size_t @@v8@@ ; char @@v9@@ [ Number ] ; unsigned __int64 @@v10@@ ; @@v10@@ = __readfsqword ( Number ) ; if ( ! print_inode ) { @@v1@@ = Number L ; goto LABEL_11 ; } if ( format == Number ) { @@v7@@ = ( const char * ) umaxtostr ( * ( _QWORD * ) ( @@a1@@ + Number ) , @@v9@@ ) ; @@v1@@ = strlen ( @@v7@@ ) + Number ; LABEL_11 : if ( ! print_block_size ) { LABEL_6 : if ( ! print_scontext ) goto LABEL_7 ; if ( format == Number ) { @@v6@@ = strlen ( * ( const char * * ) ( @@a1@@ + Number ) ) + Number ; goto LABEL_17 ; } LABEL_16 : @@v6@@ = scontext_width + Number L ; LABEL_17 : @@v1@@ += @@v6@@ ; goto LABEL_7 ; } if ( format == Number ) { @@v2@@ = Number L ; if ( * ( _BYTE * ) ( @@a1@@ + Number ) ) { @@v5@@ = ( const char * ) human_readable ( * ( _QWORD * ) ( @@a1@@ + Number ) , @@v9@@ , ( unsigned int ) human_output_opts , Number L , output_block_size ) ; @@v2@@ = strlen ( @@v5@@ ) + Number ; } goto LABEL_5 ; } LABEL_4 : @@v2@@ = block_size_width + Number L ; LABEL_5 : @@v1@@ += @@v2@@ ; goto LABEL_6 ; } @@v1@@ = inode_number_width + Number L ; if ( print_block_size ) goto LABEL_4 ; if ( print_scontext ) goto LABEL_16 ; LABEL_7 : quote_name ( Number L , * ( _QWORD * ) @@a1@@ , filename_quoting_options , & @@v8@@ ) ; @@v3@@ = @@v8@@ + @@v1@@ ; if ( indicator_style ) @@v3@@ += ( unsigned __int8 ) get_type_indicator ( * ( _BYTE * ) ( @@a1@@ + Number ) , * ( _DWORD * ) ( @@a1@@ + Number ) , * ( _DWORD * ) ( @@a1@@ + Number ) ) != Number ; return @@v3@@ ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall update_timespec ( _QWORD * @@a1@@ , struct timespec * * @@a2@@ ) { struct timespec * @@v2@@ ; __syscall_slong_t @@v3@@ ; __syscall_slong_t @@v4@@ ; __int64 @@result@@ ; __time_t @@v6@@ ; __time_t @@v7@@ ; @@v2@@ = * @@a2@@ ; @@v3@@ = ( * @@a2@@ ) -> tv_nsec ; @@v4@@ = ( * @@a2@@ ) [ Number ] . tv_nsec ; if ( @@v3@@ != Number ) { if ( @@v3@@ == Number ) { if ( @@v4@@ == Number ) { * @@a2@@ = Number L ; return Number L ; } gettime ( * @@a2@@ ) ; @@v4@@ = @@v2@@ [ Number ] . tv_nsec ; if ( @@v4@@ != Number ) { LABEL_4 : @@result@@ = Number L ; if ( @@v4@@ != Number ) return @@result@@ ; LABEL_11 : gettime ( @@v2@@ + Number ) ; return Number L ; } } else if ( @@v4@@ != Number ) { goto LABEL_4 ; } @@v6@@ = @@a1@@ [ Number ] ; @@v2@@ [ Number ] . tv_nsec = @@a1@@ [ Number ] ; @@v2@@ [ Number ] . tv_sec = @@v6@@ ; return Number L ; } @@result@@ = Number L ; if ( @@v4@@ != Number ) { @@v7@@ = @@a1@@ [ Number ] ; @@v2@@ -> tv_nsec = @@a1@@ [ Number ] ; @@result@@ = Number L ; @@v2@@ -> tv_sec = @@v7@@ ; if ( @@v4@@ == Number ) goto LABEL_11 ; } return @@result@@ ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_20D250 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20D230 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_20D240 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
int __fastcall xstrcoll_atime ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; @@v2@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= @@v2@@ ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) < @@v2@@ ) return Number ; @@v3@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= @@v3@@ ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) >= @@v3@@ ) return xstrcoll ( * ( char * * ) @@a1@@ , * ( char * * ) @@a2@@ ) ; return Number ; } } return Number ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) _frame_dummy_init_array_entry [ @@i@@ ] ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
int __fastcall argmatch_valid ( _QWORD * @@a1@@ , char * @@a2@@ , size_t @@a3@@ ) { const void * @@v5@@ ; __int64 @@v6@@ ; char * @@v7@@ ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; if ( * @@a1@@ ) { @@v5@@ = Number L ; @@v6@@ = Number L ; do { while ( ! @@v6@@ || memcmp ( @@v5@@ , @@a2@@ , @@a3@@ ) ) { ++ @@v6@@ ; @@v5@@ = @@a2@@ ; __fprintf_chk ( ) ; @@a2@@ += @@a3@@ ; if ( ! @@a1@@ [ @@v6@@ ] ) goto LABEL_7 ; } ++ @@v6@@ ; @@a2@@ += @@a3@@ ; __fprintf_chk ( ) ; } while ( @@a1@@ [ @@v6@@ ] ) ; } LABEL_7 : @@v7@@ = stderr -> _IO_write_ptr ; if ( @@v7@@ >= stderr -> _IO_write_end ) { LODWORD ( @@v7@@ ) = __overflow ( stderr , Number ) ; } else { stderr -> _IO_write_ptr = @@v7@@ + Number ; * @@v7@@ = Number ; } return ( int ) @@v7@@ ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
int __fastcall rev_xstrcoll_ctime ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) <= @@v2@@ ) { if ( * ( _QWORD * ) ( @@a2@@ + Number ) < @@v2@@ ) return Number ; @@v3@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) <= @@v3@@ ) { if ( * ( _QWORD * ) ( @@a2@@ + Number ) >= @@v3@@ ) return xstrcoll ( * ( char * * ) @@a2@@ , * ( char * * ) @@a1@@ ) ; return Number ; } } return Number ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 posix2_version ( ) { unsigned int @@v0@@ ; char * @@v1@@ ; __int64 @@v3@@ ; char * @@v4@@ [ Number ] ; @@v0@@ = Number ; @@v4@@ [ Number ] = ( char * ) __readfsqword ( Number ) ; @@v1@@ = getenv ( String ) ; if ( @@v1@@ ) { if ( * @@v1@@ ) { @@v3@@ = strtol ( @@v1@@ , @@v4@@ , Number ) ; if ( ! * @@v4@@ [ Number ] ) { if ( @@v3@@ < ( __int64 ) Number ) { @@v0@@ = Number ; } else { @@v0@@ = Number ; if ( @@v3@@ <= Number ) @@v0@@ = @@v3@@ ; } } } } return @@v0@@ ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
int __fastcall rev_strcmp_ctime ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) <= @@v2@@ ) { if ( * ( _QWORD * ) ( @@a2@@ + Number ) < @@v2@@ ) return Number ; @@v3@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) <= @@v3@@ ) { if ( * ( _QWORD * ) ( @@a2@@ + Number ) >= @@v3@@ ) return strcmp ( * ( const char * * ) @@a2@@ , * ( const char * * ) @@a1@@ ) ; return Number ; } } return Number ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
int __fastcall xstrcoll_df_mtime ( __int64 @@a1@@ , __int64 @@a2@@ ) { bool @@v2@@ ; bool @@v3@@ ; int @@result@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; @@v2@@ = * ( _DWORD * ) ( @@a1@@ + Number ) == Number || * ( _DWORD * ) ( @@a1@@ + Number ) == Number ; @@v3@@ = * ( _DWORD * ) ( @@a2@@ + Number ) == Number || * ( _DWORD * ) ( @@a2@@ + Number ) == Number ; if ( ! @@v3@@ && @@v2@@ ) return Number ; if ( @@v2@@ || ( @@result@@ = Number , ! @@v3@@ ) ) { @@v5@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= @@v5@@ ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) < @@v5@@ ) return Number ; @@v6@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= @@v6@@ ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) >= @@v6@@ ) return xstrcoll ( * ( char * * ) @@a1@@ , * ( char * * ) @@a2@@ ) ; return Number ; } } return Number ; } return @@result@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_20C230 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20C210 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20C220 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
int __fastcall rev_xstrcoll_df_ctime ( __int64 @@a1@@ , __int64 @@a2@@ ) { bool @@v2@@ ; bool @@v3@@ ; int @@result@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; @@v2@@ = * ( _DWORD * ) ( @@a1@@ + Number ) == Number || * ( _DWORD * ) ( @@a1@@ + Number ) == Number ; @@v3@@ = * ( _DWORD * ) ( @@a2@@ + Number ) == Number || * ( _DWORD * ) ( @@a2@@ + Number ) == Number ; if ( ! @@v3@@ && @@v2@@ ) return Number ; if ( @@v2@@ || ( @@result@@ = Number , ! @@v3@@ ) ) { @@v5@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) <= @@v5@@ ) { if ( * ( _QWORD * ) ( @@a2@@ + Number ) < @@v5@@ ) return Number ; @@v6@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) <= @@v6@@ ) { if ( * ( _QWORD * ) ( @@a2@@ + Number ) >= @@v6@@ ) return xstrcoll ( * ( char * * ) @@a2@@ , * ( char * * ) @@a1@@ ) ; return Number ; } } return Number ; } return @@result@@ ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ , __int64 a3 , __int64 @@a4@@ ) { size_t @@v4@@ ; size_t @@v5@@ ; void * @@result@@ ; @@v4@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v4@@ > Number ) xalloc_die ( @@a1@@ , @@a2@@ , Number , @@a4@@ ) ; @@v5@@ = ( ( @@v4@@ + Number ) >> Number ) + @@v4@@ ; * @@a2@@ = @@v5@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v5@@ ) ; } else { if ( ! @@v4@@ ) @@v4@@ = Number L ; * @@a2@@ = @@v4@@ ; @@result@@ = xrealloc ( Number L , @@v4@@ ) ; } return @@result@@ ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
int __fastcall strcmp_extension ( const char * * @@a1@@ , const char * * @@a2@@ ) { const char * @@v2@@ ; char * @@v3@@ ; const char * @@v4@@ ; const char * @@v5@@ ; char * @@v6@@ ; int @@result@@ ; @@v2@@ = * @@a1@@ ; @@v3@@ = strrchr ( * @@a1@@ , Number ) ; @@v4@@ = * @@a2@@ ; @@v5@@ = @@v3@@ ; @@v6@@ = strrchr ( * @@a2@@ , Number ) ; if ( @@v6@@ ) { if ( ! @@v5@@ ) @@v5@@ = String ; @@result@@ = strcmp ( @@v5@@ , @@v6@@ ) ; if ( ! @@result@@ ) return strcmp ( @@v2@@ , @@v4@@ ) ; } else { if ( ! @@v5@@ ) return strcmp ( @@v2@@ , @@v4@@ ) ; @@result@@ = strcmp ( @@v5@@ , String ) ; if ( ! @@result@@ ) return strcmp ( @@v2@@ , @@v4@@ ) ; } return @@result@@ ; }
int __cdecl __noreturn main ( int @@argc@@ , const char * * @@argv@@ , const char * * envp ) { int @@v4@@ ; __int64 @@v5@@ ; _QWORD * @@i@@ ; bool @@v7@@ ; int @@v8@@ ; char * * @@v9@@ ; int @@v10@@ ; char * @@v11@@ ; const char * @@v12@@ ; char @@v13@@ ; char @@v14@@ ; set_program_name ( * @@argv@@ ) ; setlocale ( Number , String ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; exit_failure = Number ; atexit ( close_stdout ) ; while ( Number ) { @@v4@@ = getopt_long ( @@argc@@ , ( char * const * ) @@argv@@ , String , & longopts , Number L ) ; if ( @@v4@@ == Number ) break ; if ( @@v4@@ == Number ) usage ( Number ) ; if ( @@v4@@ != Number ) { if ( @@v4@@ != Number ) usage ( Number ) ; version_etc ( ( _DWORD ) stdout , ( unsigned int ) String , ( unsigned int ) & unk_3B1F , ( _DWORD ) Version , ( unsigned int ) String , ( unsigned int ) String , Number ) ; exit ( Number ) ; } } @@v5@@ = optind ; if ( optind < @@argc@@ ) { @@v8@@ = Number ; do { if ( strchr ( @@argv@@ [ @@v5@@ ] , Number ) ) goto LABEL_16 ; @@v9@@ = ( char * * ) environ ; @@v10@@ = Number ; LABEL_19 : @@v11@@ = * @@v9@@ ; if ( * @@v9@@ ) { @@v12@@ = @@argv@@ [ @@v5@@ ] ; @@v13@@ = * @@v11@@ ; while ( Number ) { if ( ! @@v13@@ ) goto LABEL_29 ; while ( Number ) { @@v14@@ = * @@v12@@ ; if ( ! * @@v12@@ ) goto LABEL_29 ; ++ @@v12@@ ; if ( @@v14@@ != @@v13@@ ) goto LABEL_29 ; @@v13@@ = @@v11@@ [ Number ] ; if ( @@v13@@ != Number ) break ; if ( ! * @@v12@@ ) { __printf_chk ( ) ; @@v10@@ = Number ; LABEL_29 : ++ @@v9@@ ; goto LABEL_19 ; } ++ @@v11@@ ; } ++ @@v11@@ ; } } @@v8@@ += @@v10@@ ; LABEL_16 : ++ @@v5@@ ; } while ( @@argc@@ > ( int ) @@v5@@ ) ; @@v7@@ = @@argc@@ - optind == @@v8@@ ; } else { for ( @@i@@ = ( _QWORD * ) environ ; * @@i@@ ; ++ @@i@@ ) __printf_chk ( ) ; @@v7@@ = Number ; } exit ( ! @@v7@@ ) ; }
void __fastcall cycle_check_init ( __int64 @@a1@@ ) { * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _DWORD * ) ( @@a1@@ + Number ) = Number ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
int __fastcall xstrcoll_df_extension ( __int64 @@a1@@ , __int64 @@a2@@ ) { bool @@v2@@ ; bool @@v3@@ ; int @@result@@ ; char * @@v5@@ ; char * @@v6@@ ; @@v2@@ = * ( _DWORD * ) ( @@a1@@ + Number ) == Number || * ( _DWORD * ) ( @@a1@@ + Number ) == Number ; @@v3@@ = * ( _DWORD * ) ( @@a2@@ + Number ) == Number || * ( _DWORD * ) ( @@a2@@ + Number ) == Number ; if ( ! @@v3@@ && @@v2@@ ) return Number ; if ( @@v2@@ || ( @@result@@ = Number , ! @@v3@@ ) ) { @@v5@@ = strrchr ( * ( const char * * ) @@a1@@ , Number ) ; @@v6@@ = strrchr ( * ( const char * * ) @@a2@@ , Number ) ; if ( ! @@v6@@ ) @@v6@@ = ( char * ) String ; if ( ! @@v5@@ ) @@v5@@ = ( char * ) String ; @@result@@ = xstrcoll ( @@v5@@ , @@v6@@ ) ; if ( ! @@result@@ ) @@result@@ = xstrcoll ( * ( char * * ) @@a1@@ , * ( char * * ) @@a2@@ ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
__int64 __fastcall rpl_fcntl ( int @@a1@@ , int @@a2@@ , __int64 @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { int @@v6@@ ; int @@v8@@ ; int @@v9@@ ; int @@v10@@ ; int @@v11@@ ; int * @@v12@@ ; int @@v13@@ ; int * @@v14@@ ; int @@v15@@ ; @@v15@@ = @@a3@@ ; if ( @@a2@@ != Number ) return ( unsigned int ) fcntl ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( have_dupfd_cloexec_3202 < Number ) { @@v6@@ = rpl_fcntl ( @@a1@@ , Number , ( unsigned int ) @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( @@v6@@ < Number || have_dupfd_cloexec_3202 != Number ) return ( unsigned int ) @@v6@@ ; } else { @@v6@@ = fcntl ( @@a1@@ , Number , ( unsigned int ) @@a3@@ ) ; if ( @@v6@@ >= Number || * __errno_location ( ) != Number ) { have_dupfd_cloexec_3202 = Number ; return ( unsigned int ) @@v6@@ ; } @@v6@@ = rpl_fcntl ( @@a1@@ , Number , @@v15@@ , @@v8@@ , @@v9@@ , @@v10@@ ) ; if ( @@v6@@ < Number ) return ( unsigned int ) @@v6@@ ; have_dupfd_cloexec_3202 = Number ; } @@v11@@ = fcntl ( @@v6@@ , Number ) ; if ( @@v11@@ < Number || fcntl ( @@v6@@ , Number , @@v11@@ | Number ) == Number ) { @@v12@@ = __errno_location ( ) ; @@v13@@ = * @@v12@@ ; @@v14@@ = @@v12@@ ; close ( @@v6@@ ) ; @@v6@@ = Number ; * @@v14@@ = @@v13@@ ; } return ( unsigned int ) @@v6@@ ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 __fastcall mbsnwidth ( char * @@s@@ , __int64 @@a2@@ , char @@a3@@ ) { char * @@v3@@ ; char * @@v4@@ ; unsigned int @@v5@@ ; char @@v6@@ ; size_t @@v7@@ ; __int64 @@v8@@ ; int @@v9@@ ; const unsigned __int16 * @@v11@@ ; unsigned __int16 @@v12@@ ; wchar_t @@pwc@@ ; mbstate_t @@ps@@ ; unsigned __int64 @@v16@@ ; @@v3@@ = & @@s@@ [ @@a2@@ ] ; @@v4@@ = @@s@@ ; @@v16@@ = __readfsqword ( Number ) ; if ( __ctype_get_mb_cur_max ( ) <= Number ) { @@v5@@ = Number ; if ( @@s@@ >= @@v3@@ ) return @@v5@@ ; @@v11@@ = * __ctype_b_loc ( ) ; @@v5@@ = Number ; while ( Number ) { @@v12@@ = @@v11@@ [ ( unsigned __int8 ) * @@v4@@ ++ ] ; if ( ( @@v12@@ & Number ) != Number ) { ++ @@v5@@ ; } else { if ( ( @@a3@@ & Number ) != Number ) return ( unsigned int ) Number ; @@v5@@ += ( ( unsigned __int8 ) ( @@v12@@ >> Number ) ^ Number ) & Number ; } if ( @@v3@@ == @@v4@@ ) return @@v5@@ ; } } @@v5@@ = Number ; if ( @@s@@ < @@v3@@ ) { do { @@v6@@ = * @@v4@@ ; if ( * @@v4@@ <= Number ) { if ( @@v6@@ < Number && ( unsigned __int8 ) ( @@v6@@ - Number ) > Number ) { LABEL_12 : @@ps@@ = Number L ; while ( Number ) { @@v7@@ = mbrtowc ( & @@pwc@@ , @@v4@@ , @@v3@@ - @@v4@@ , & @@ps@@ ) ; @@v8@@ = @@v7@@ ; if ( @@v7@@ == Number ) { if ( ( @@a3@@ & Number ) == Number ) goto LABEL_6 ; return ( unsigned int ) Number ; } if ( @@v7@@ == Number ) break ; if ( ! @@v7@@ ) @@v8@@ = Number L ; @@v9@@ = wcwidth ( @@pwc@@ ) ; if ( @@v9@@ < Number ) { if ( ( @@a3@@ & Number ) != Number ) return ( unsigned int ) Number ; @@v9@@ = iswcntrl ( @@pwc@@ ) == Number ; } @@v5@@ += @@v9@@ ; @@v4@@ += @@v8@@ ; if ( mbsinit ( & @@ps@@ ) ) goto LABEL_7 ; } if ( ( @@a3@@ & Number ) != Number ) return ( unsigned int ) Number ; ++ @@v5@@ ; @@v4@@ = & @@s@@ [ @@a2@@ ] ; continue ; } } else if ( @@v6@@ < Number || @@v6@@ > Number && ( unsigned __int8 ) ( @@v6@@ - Number ) > Number ) { goto LABEL_12 ; } LABEL_6 : ++ @@v4@@ ; ++ @@v5@@ ; LABEL_7 : ; } while ( @@v4@@ < @@v3@@ ) ; } return @@v5@@ ; }
__int64 __fastcall utimens ( char * @@a1@@ , const __m128i * @@a2@@ ) { return fdutimens ( @@a1@@ , Number , @@a2@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
_QWORD * __fastcall argv_iter_init_stream ( __int64 @@a1@@ ) { _QWORD * @@result@@ ; @@result@@ = malloc ( Number ) ; if ( @@result@@ ) { * @@result@@ = @@a1@@ ; @@result@@ [ Number ] = Number L ; @@result@@ [ Number ] = Number L ; @@result@@ [ Number ] = Number L ; @@result@@ [ Number ] = Number L ; } return @@result@@ ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
void __fastcall readtokens0_free ( __int64 @@a1@@ ) { obstack_free ( ( struct obstack * ) ( @@a1@@ + Number ) , Number L ) ; obstack_free ( ( struct obstack * ) ( @@a1@@ + Number ) , Number L ) ; obstack_free ( ( struct obstack * ) ( @@a1@@ + Number ) , Number L ) ; }
int __fastcall argmatch_valid ( _QWORD * @@a1@@ , char * @@a2@@ , size_t @@a3@@ ) { const void * @@v5@@ ; __int64 @@v6@@ ; char * @@v7@@ ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; if ( * @@a1@@ ) { @@v5@@ = Number L ; @@v6@@ = Number L ; do { while ( ! @@v6@@ || memcmp ( @@v5@@ , @@a2@@ , @@a3@@ ) ) { ++ @@v6@@ ; @@v5@@ = @@a2@@ ; __fprintf_chk ( ) ; @@a2@@ += @@a3@@ ; if ( ! @@a1@@ [ @@v6@@ ] ) goto LABEL_7 ; } ++ @@v6@@ ; @@a2@@ += @@a3@@ ; __fprintf_chk ( ) ; } while ( @@a1@@ [ @@v6@@ ] ) ; } LABEL_7 : @@v7@@ = stderr -> _IO_write_ptr ; if ( @@v7@@ >= stderr -> _IO_write_end ) { LODWORD ( @@v7@@ ) = __overflow ( stderr , Number ) ; } else { stderr -> _IO_write_ptr = @@v7@@ + Number ; * @@v7@@ = Number ; } return ( int ) @@v7@@ ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
int __fxstatat ( int @@ver@@ , int @@fildes@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ , int @@flag@@ ) { return _fxstatat ( @@ver@@ , @@fildes@@ , @@filename@@ , @@stat_buf@@ , @@flag@@ ) ; }
void * __fastcall mfile_name_concat ( void * @@src@@ , void * @@a2@@ , _QWORD * @@a3@@ ) { const char * @@v4@@ ; const char * @@v5@@ ; size_t @@v6@@ ; size_t @@v7@@ ; _BOOL8 @@v8@@ ; void * @@v9@@ ; void * @@v10@@ ; _BYTE * @@v11@@ ; char * @@v12@@ ; size_t @@n@@ ; char @@v15@@ ; @@v4@@ = ( const char * ) @@a2@@ ; @@v5@@ = last_component ( @@src@@ ) ; @@v6@@ = base_len ( @@v5@@ ) ; @@v7@@ = @@v6@@ + @@v5@@ - ( _BYTE * ) @@src@@ ; @@v8@@ = @@v6@@ ; if ( @@v6@@ ) @@v8@@ = @@v5@@ [ @@v6@@ - Number ] != Number ; @@v15@@ = * ( _BYTE * ) @@a2@@ ; if ( * ( _BYTE * ) @@a2@@ == Number ) { do ++ @@v4@@ ; while ( * @@v4@@ == Number ) ; } @@n@@ = strlen ( @@v4@@ ) ; @@v9@@ = malloc ( @@n@@ + @@v8@@ + @@v7@@ + Number ) ; @@v10@@ = @@v9@@ ; if ( @@v9@@ ) { @@v11@@ = mempcpy ( @@v9@@ , @@src@@ , @@v7@@ ) ; * @@v11@@ = Number ; @@v12@@ = & @@v11@@ [ @@v8@@ ] ; if ( @@a3@@ ) * @@a3@@ = & @@v12@@ [ - ( @@v15@@ == Number ) ] ; * ( _BYTE * ) mempcpy ( @@v12@@ , @@v4@@ , @@n@@ ) = Number ; } return @@v10@@ ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; char * @@v10@@ ; char * @@v11@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String String String String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = dcgettext ( Number L , String String String String , Number ) ; __printf_chk ( ) ; last_component ( program_name , @@v7@@ ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v8@@ = stdout ; @@v9@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = Number L ; @@v11@@ = setlocale ( Number , Number L ) ; if ( @@v11@@ ) { @@v10@@ = String ; if ( strncmp ( @@v11@@ , String , Number ) ) { last_component ( program_name , String ) ; @@v10@@ = dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name , @@v10@@ ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
int __xstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _xstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
__int64 __fastcall hash_print_statistics ( __int64 @@a1@@ ) { unsigned __int64 @@v1@@ ; _QWORD * @@v2@@ ; unsigned __int64 @@i@@ ; __int64 @@v4@@ ; unsigned __int64 @@j@@ ; @@v1@@ = Number L ; @@v2@@ = * ( _QWORD * * ) @@a1@@ ; for ( @@i@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; ( unsigned __int64 ) @@v2@@ < @@i@@ ; @@v2@@ += Number ) { if ( * @@v2@@ ) { @@v4@@ = @@v2@@ [ Number ] ; for ( @@j@@ = Number L ; @@v4@@ ; ++ @@j@@ ) @@v4@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; if ( @@v1@@ < @@j@@ ) @@v1@@ = @@j@@ ; } } __fprintf_chk ( ) ; __fprintf_chk ( ) ; __fprintf_chk ( ) ; return __fprintf_chk ( ) ; }
int __fxstat ( int @@ver@@ , int @@fildes@@ , struct stat * @@stat_buf@@ ) { return _fxstat ( @@ver@@ , @@fildes@@ , @@stat_buf@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_2061F0 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061D0 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061E0 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall hash_get_next ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; __int64 * @@v6@@ ; _QWORD * @@v7@@ ; __int64 @@v8@@ ; __int64 @@result@@ ; @@v2@@ = * @@a1@@ ; @@v4@@ = ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) ; @@v5@@ = @@a1@@ [ Number ] ; @@v6@@ = ( __int64 * ) ( @@v2@@ + Number * @@v4@@ ) ; if ( @@v5@@ <= ( unsigned __int64 ) @@v6@@ ) abort ( ) ; if ( ! @@v6@@ ) goto LABEL_10 ; @@v7@@ = ( _QWORD * ) @@v6@@ [ Number ] ; if ( * @@v6@@ != @@a2@@ ) { do { if ( ! @@v7@@ ) goto LABEL_10 ; @@v8@@ = * @@v7@@ ; @@v7@@ = ( _QWORD * ) @@v7@@ [ Number ] ; } while ( @@v8@@ != @@a2@@ ) ; } if ( @@v7@@ ) return * @@v7@@ ; LABEL_10 : while ( Number ) { @@v6@@ += Number ; if ( @@v5@@ <= ( unsigned __int64 ) @@v6@@ ) break ; @@result@@ = * @@v6@@ ; if ( * @@v6@@ ) return @@result@@ ; } return Number L ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 __fastcall human_options ( char * @@nptr@@ , int * @@a2@@ , __int64 * @@a3@@ ) { char * @@v4@@ ; int @@v5@@ ; int @@v6@@ ; int @@v7@@ ; __int64 @@result@@ ; __int64 @@v9@@ ; char * @@v10@@ ; @@v4@@ = @@nptr@@ ; if ( @@nptr@@ || ( @@v4@@ = getenv ( String ) ) != Number L || ( @@v4@@ = getenv ( String ) ) != Number L ) { @@v5@@ = Number ; if ( * @@v4@@ == Number ) { ++ @@v4@@ ; @@v5@@ = Number ; } @@v6@@ = argmatch ( @@v4@@ , ( const char * * ) block_size_args , ( char * ) & block_size_opts , Number ) ; if ( @@v6@@ >= Number ) { * @@a3@@ = Number L ; @@v7@@ = * ( ( _DWORD * ) & block_size_opts + @@v6@@ ) | @@v5@@ ; @@result@@ = Number L ; * @@a2@@ = @@v7@@ ; return @@result@@ ; } @@result@@ = xstrtoumax ( @@v4@@ ) ; if ( ( _DWORD ) @@result@@ ) { @@v9@@ = * @@a3@@ ; * @@a2@@ = Number ; LABEL_15 : if ( ! @@v9@@ ) { * @@a3@@ = getenv ( String ) == Number L ? Number L : Number L ; @@result@@ = Number L ; } return @@result@@ ; } if ( ( unsigned __int8 ) ( * @@v4@@ - Number ) > Number ) { if ( @@v4@@ != @@v10@@ ) { while ( ( unsigned __int8 ) ( * ++ @@v4@@ - Number ) > Number ) { if ( @@v4@@ == @@v10@@ ) goto LABEL_22 ; } goto LABEL_13 ; } LABEL_22 : if ( * ( @@v10@@ - Number ) == Number ) { @@v5@@ |= Number ; if ( * ( @@v10@@ - Number ) != Number ) goto LABEL_13 ; } else { LOBYTE ( @@v5@@ ) = @@v5@@ | Number ; } @@v5@@ |= Number ; } LABEL_13 : @@v9@@ = * @@a3@@ ; * @@a2@@ = @@v5@@ ; goto LABEL_15 ; } if ( getenv ( String ) ) * @@a3@@ = Number L ; else * @@a3@@ = Number L ; @@result@@ = Number L ; * @@a2@@ = Number ; return @@result@@ ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 __fastcall filemodestring ( __int64 @@a1@@ , __int64 @@a2@@ ) { return strmode ( * ( _DWORD * ) ( @@a1@@ + Number ) , @@a2@@ ) ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
bool __fastcall LCO_compare ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { return * @@a1@@ == * @@a2@@ ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
int dirfd ( DIR * @@dirp@@ ) { return dirfd ( @@dirp@@ ) ; }
__int64 __fastcall getgidbyname ( char * @@src@@ ) { __int64 @@v1@@ ; char @@v2@@ ; __int64 @@result@@ ; __int64 @@v4@@ ; char @@v5@@ ; struct group * @@v6@@ ; size_t @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; @@v1@@ = group_alist ; if ( group_alist ) { @@v2@@ = * @@src@@ ; while ( * ( _BYTE * ) ( @@v1@@ + Number ) != @@v2@@ || strcmp ( ( const char * ) ( @@v1@@ + Number ) , @@src@@ ) ) { @@v1@@ = * ( _QWORD * ) ( @@v1@@ + Number ) ; if ( ! @@v1@@ ) goto LABEL_7 ; } return @@v1@@ ; } LABEL_7 : @@v4@@ = nogroup_alist ; if ( nogroup_alist ) { @@v5@@ = * @@src@@ ; while ( * ( _BYTE * ) ( @@v4@@ + Number ) != @@v5@@ || strcmp ( ( const char * ) ( @@v4@@ + Number ) , @@src@@ ) ) { @@v4@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; if ( ! @@v4@@ ) goto LABEL_13 ; } @@result@@ = Number L ; } else { LABEL_13 : @@v6@@ = getgrnam ( @@src@@ ) ; @@v7@@ = strlen ( @@src@@ ) ; @@v1@@ = xmalloc ( @@v7@@ + Number ) ; strcpy ( ( char * ) ( @@v1@@ + Number ) , @@src@@ ) ; if ( @@v6@@ ) { * ( _DWORD * ) @@v1@@ = @@v6@@ -> gr_gid ; @@v8@@ = group_alist ; group_alist = @@v1@@ ; * ( _QWORD * ) ( @@v1@@ + Number ) = @@v8@@ ; return @@v1@@ ; } @@v9@@ = nogroup_alist ; nogroup_alist = @@v1@@ ; * ( _QWORD * ) ( @@v1@@ + Number ) = @@v9@@ ; @@result@@ = Number L ; } return @@result@@ ; }
struct dirent * readdir ( DIR * @@dirp@@ ) { return readdir ( @@dirp@@ ) ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
int fchdir ( int @@fd@@ ) { return fchdir ( @@fd@@ ) ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
__int64 __fastcall fts_sort ( _QWORD * @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { __int64 @@v5@@ ; bool @@v6@@ ; int ( * @@v7@@ ) ( const void * , const void * ) ; void * @@v8@@ ; void * @@v9@@ ; _QWORD * @@v10@@ ; __int64 * @@v11@@ ; size_t @@v12@@ ; __int64 @@result@@ ; __int64 @@v14@@ ; __int64 * @@i@@ ; __int64 @@v16@@ ; __int64 @@v17@@ ; @@v5@@ = @@a2@@ ; @@v6@@ = @@a1@@ [ Number ] < @@a3@@ ; @@v7@@ = ( int ( * ) ( const void * , const void * ) ) @@a1@@ [ Number ] ; @@v8@@ = ( void * ) @@a1@@ [ Number ] ; if ( ! @@v6@@ ) goto LABEL_5 ; @@a1@@ [ Number ] = @@a3@@ + Number ; if ( @@a3@@ + Number > Number ) { LABEL_15 : free ( @@v8@@ ) ; @@a1@@ [ Number ] = Number L ; @@a1@@ [ Number ] = Number L ; return @@a2@@ ; } @@v9@@ = realloc ( @@v8@@ , Number * ( @@a3@@ + Number ) ) ; @@v8@@ = @@v9@@ ; if ( ! @@v9@@ ) { @@v8@@ = ( void * ) @@a1@@ [ Number ] ; goto LABEL_15 ; } @@a1@@ [ Number ] = @@v9@@ ; LABEL_5 : if ( @@a2@@ ) { @@v10@@ = @@v8@@ ; do { * @@v10@@ ++ = @@v5@@ ; @@v5@@ = * ( _QWORD * ) ( @@v5@@ + Number ) ; } while ( @@v5@@ ) ; } qsort ( @@v8@@ , @@a3@@ , Number , @@v7@@ ) ; @@v11@@ = ( __int64 * ) @@a1@@ [ Number ] ; @@v12@@ = @@a3@@ - Number ; @@result@@ = * @@v11@@ ; if ( @@a3@@ == Number ) { @@v17@@ = * @@v11@@ ; } else { @@v14@@ = * @@v11@@ ; for ( @@i@@ = ( __int64 * ) @@a1@@ [ Number ] ; ; @@v14@@ = * @@i@@ ) { @@v16@@ = @@i@@ [ Number ] ; ++ @@i@@ ; -- @@v12@@ ; * ( _QWORD * ) ( @@v14@@ + Number ) = @@v16@@ ; if ( ! @@v12@@ ) break ; } @@v17@@ = @@v11@@ [ @@a3@@ - Number ] ; } * ( _QWORD * ) ( @@v17@@ + Number ) = Number L ; return @@result@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
void free ( void * @@ptr@@ ) { __imp_free ( @@ptr@@ ) ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
unsigned __int64 __fastcall raw_hasher ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return __ROR8__ ( @@a1@@ , Number ) % @@a2@@ ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
ssize_t __fastcall safe_read ( int @@fd@@ , void * @@buf@@ , size_t @@nbytes@@ ) { ssize_t @@v4@@ ; int @@v5@@ ; while ( Number ) { @@v4@@ = read ( @@fd@@ , @@buf@@ , @@nbytes@@ ) ; if ( @@v4@@ >= Number ) break ; @@v5@@ = * __errno_location ( ) ; if ( @@v5@@ != Number ) { if ( @@nbytes@@ <= Number || @@v5@@ != Number ) return @@v4@@ ; @@nbytes@@ = Number L ; } } return @@v4@@ ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; program_invocation_short_name = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
__int64 __fastcall hash_find_entry ( __int64 * @@a1@@ , __int64 @@a2@@ , __m128i * * @@a3@@ , char @@a4@@ ) { __int64 @@v5@@ ; __m128i * @@v8@@ ; __int64 @@v9@@ ; __int64 * @@v10@@ ; const __m128i * @@v12@@ ; @@v5@@ = * @@a1@@ ; @@v8@@ = ( __m128i * ) ( Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) + @@v5@@ ) ; if ( @@a1@@ [ Number ] <= ( unsigned __int64 ) @@v8@@ ) abort ( ) ; * @@a3@@ = @@v8@@ ; @@v9@@ = @@v8@@ -> m128i_i64 [ Number ] ; if ( @@v8@@ -> m128i_i64 [ Number ] ) { if ( @@v9@@ != @@a2@@ ) { if ( ! ( ( unsigned __int8 ( __fastcall * ) ( __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ ) ) { @@v10@@ = ( __int64 * ) @@v8@@ -> m128i_i64 [ Number ] ; if ( @@v10@@ ) { @@v9@@ = * @@v10@@ ; if ( @@a2@@ != * @@v10@@ ) { while ( ! ( ( unsigned __int8 ( __fastcall * ) ( __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ ) ) { @@v8@@ = ( __m128i * ) @@v8@@ -> m128i_i64 [ Number ] ; @@v10@@ = ( __int64 * ) @@v8@@ -> m128i_i64 [ Number ] ; if ( ! @@v10@@ ) return Number L ; @@v9@@ = * @@v10@@ ; if ( * @@v10@@ == @@a2@@ ) goto LABEL_12 ; } @@v10@@ = ( __int64 * ) @@v8@@ -> m128i_i64 [ Number ] ; @@v9@@ = * @@v10@@ ; } LABEL_12 : if ( @@a4@@ ) { @@v8@@ -> m128i_i64 [ Number ] = @@v10@@ [ Number ] ; * @@v10@@ = Number L ; @@v10@@ [ Number ] = @@a1@@ [ Number ] ; @@a1@@ [ Number ] = ( __int64 ) @@v10@@ ; } return @@v9@@ ; } return Number L ; } @@v9@@ = @@v8@@ -> m128i_i64 [ Number ] ; } if ( @@a4@@ ) { @@v12@@ = ( const __m128i * ) @@v8@@ -> m128i_i64 [ Number ] ; if ( @@v12@@ ) { * @@v8@@ = _mm_loadu_si128 ( @@v12@@ ) ; @@v12@@ -> m128i_i64 [ Number ] = Number L ; @@v12@@ -> m128i_i64 [ Number ] = @@a1@@ [ Number ] ; @@a1@@ [ Number ] = ( __int64 ) @@v12@@ ; return @@v9@@ ; } @@v8@@ -> m128i_i64 [ Number ] = Number L ; } return @@v9@@ ; } return Number L ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_219F70 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_219F50 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_219F60 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
__int64 __fastcall hash_reset_tuning ( __int64 @@a1@@ ) { __int64 @@result@@ ; * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; * ( _QWORD * ) @@a1@@ = Number ; @@result@@ = Number ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number ; return @@result@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
bool __fastcall AD_compare ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@result@@ ; @@result@@ = Number ; if ( @@a1@@ [ Number ] == @@a2@@ [ Number ] ) @@result@@ = * @@a1@@ == * @@a2@@ ; return @@result@@ ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
int iswcntrl ( wint_t @@wc@@ ) { return iswcntrl ( @@wc@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void __fastcall i_ring_init ( __int64 @@a1@@ , int @@a2@@ ) { * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; }
char * __fastcall fts_alloc ( __int64 @@a1@@ , const void * @@a2@@ , size_t @@a3@@ ) { char * @@v4@@ ; char * @@v5@@ ; __int64 @@v6@@ ; @@v4@@ = ( char * ) malloc ( @@a3@@ + Number ) ; @@v5@@ = @@v4@@ ; if ( @@v4@@ ) { memcpy ( @@v4@@ + Number , @@a2@@ , @@a3@@ ) ; @@v6@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v5@@ [ @@a3@@ + Number ] = Number ; * ( ( _QWORD * ) @@v5@@ + Number ) = @@a3@@ ; * ( ( _QWORD * ) @@v5@@ + Number ) = @@a1@@ ; * ( ( _DWORD * ) @@v5@@ + Number ) = Number ; * ( _DWORD * ) ( @@v5@@ + Number ) = Number ; * ( ( _QWORD * ) @@v5@@ + Number ) = @@v6@@ ; * ( ( _QWORD * ) @@v5@@ + Number ) = Number L ; * ( ( _QWORD * ) @@v5@@ + Number ) = Number L ; } return @@v5@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
DIR * opendir ( const char * @@name@@ ) { return opendir ( @@name@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 __fastcall i_ring_pop ( __int64 @@a1@@ ) { _DWORD * @@v1@@ ; int @@v2@@ ; __int64 @@result@@ ; if ( * ( _BYTE * ) ( @@a1@@ + Number ) ) abort ( ) ; @@v1@@ = ( _DWORD * ) ( @@a1@@ + Number L * * ( unsigned int * ) ( @@a1@@ + Number ) ) ; @@v2@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; @@result@@ = ( unsigned int ) * @@v1@@ ; * @@v1@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; if ( @@v2@@ == * ( _DWORD * ) ( @@a1@@ + Number ) ) * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; else * ( _DWORD * ) ( @@a1@@ + Number ) = ( ( _BYTE ) @@v2@@ + Number ) & Number ; return @@result@@ ; }
int closedir ( DIR * @@dirp@@ ) { return closedir ( @@dirp@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
bool __fastcall setup_dir_isra_4 ( __int16 @@a1@@ , __int64 * @@a2@@ ) { __int64 @@v2@@ ; bool @@result@@ ; void * @@v4@@ ; if ( ( @@a1@@ & Number ) != Number ) { @@v2@@ = hash_initialize ( Number L , Number L , AD_hash , AD_compare , & free ) ; * @@a2@@ = @@v2@@ ; @@result@@ = @@v2@@ != Number ; } else { @@v4@@ = malloc ( Number ) ; * @@a2@@ = ( __int64 ) @@v4@@ ; @@result@@ = Number ; if ( @@v4@@ ) { cycle_check_init ( ) ; @@result@@ = Number ; } } return @@result@@ ; }
int sigemptyset ( sigset_t * @@set@@ ) { return sigemptyset ( @@set@@ ) ; }
__int64 __fastcall openat_safer ( int @@a1@@ , const char * @@a2@@ , char @@a3@@ , unsigned int @@a4@@ ) { __int64 @@v4@@ ; int @@v5@@ ; @@v4@@ = Number L ; if ( ( @@a3@@ & Number ) != Number ) @@v4@@ = @@a4@@ ; @@v5@@ = openat ( @@a1@@ , @@a2@@ , @@a3@@ , @@v4@@ ) ; return fd_safer ( @@v5@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
char * nl_langinfo ( nl_item @@item@@ ) { return nl_langinfo ( @@item@@ ) ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
int fflush_unlocked ( FILE * @@stream@@ ) { return fflush_unlocked ( @@stream@@ ) ; }
unsigned __int64 __fastcall leave_dir_isra_14 ( __int16 @@a1@@ , __int64 * * @@a2@@ , _QWORD * @@a3@@ ) { __int64 * @@v3@@ ; __int64 * @@v4@@ ; __int64 * @@v6@@ ; void * @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v11@@ = __readfsqword ( Number ) ; if ( ( @@a1@@ & Number ) != Number ) { @@v6@@ = * @@a2@@ ; @@v10@@ [ Number ] = @@a3@@ [ Number ] ; @@v10@@ [ Number ] = @@a3@@ [ Number ] ; @@v7@@ = ( void * ) hash_delete ( @@v6@@ , @@v10@@ ) ; if ( @@v7@@ ) { free ( @@v7@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; } goto LABEL_11 ; } @@v3@@ = ( __int64 * ) @@a3@@ [ Number ] ; if ( ! @@v3@@ || @@v3@@ [ Number ] < Number ) return __readfsqword ( Number ) ^ @@v11@@ ; @@v4@@ = * @@a2@@ ; if ( ! ( * @@a2@@ ) [ Number ] ) LABEL_11 : abort ( ) ; if ( * @@v4@@ == @@a3@@ [ Number ] && @@v4@@ [ Number ] == @@a3@@ [ Number ] ) { @@v8@@ = @@v3@@ [ Number ] ; @@v9@@ = @@v3@@ [ Number ] ; @@v4@@ [ Number ] = @@v8@@ ; * @@v4@@ = @@v9@@ ; } return __readfsqword ( Number ) ^ @@v11@@ ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
unsigned __int64 __fastcall hash_get_max_bucket_length ( __int64 @@a1@@ ) { _QWORD * @@v1@@ ; unsigned __int64 @@v2@@ ; unsigned __int64 @@result@@ ; __int64 @@v4@@ ; unsigned __int64 @@i@@ ; @@v1@@ = * ( _QWORD * * ) @@a1@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; for ( @@result@@ = Number L ; ( unsigned __int64 ) @@v1@@ < @@v2@@ ; @@v1@@ += Number ) { if ( * @@v1@@ ) { @@v4@@ = @@v1@@ [ Number ] ; for ( @@i@@ = Number L ; @@v4@@ ; ++ @@i@@ ) @@v4@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; if ( @@result@@ < @@i@@ ) @@result@@ = @@i@@ ; } } return @@result@@ ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
int __fastcall rev_strcmp_size ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) > @@v2@@ ) return Number ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) < @@v2@@ ) return Number ; return strcmp ( * ( const char * * ) @@a2@@ , * ( const char * * ) @@a1@@ ) ; }
unsigned __int64 __fastcall adjust_column ( __int64 @@a1@@ , char @@a2@@ ) { unsigned __int64 @@result@@ ; if ( count_bytes ) return @@a1@@ + Number ; if ( @@a2@@ != Number ) { @@result@@ = Number L ; if ( @@a2@@ == Number ) return @@result@@ ; if ( @@a2@@ == Number ) return ( @@a1@@ & Number ) + Number ; return @@a1@@ + Number ; } @@result@@ = Number L ; if ( @@a1@@ ) @@result@@ = @@a1@@ - Number ; return @@result@@ ; }
__int64 __fastcall hash_get_first ( __int64 @@a1@@ ) { __int64 * @@v1@@ ; unsigned __int64 @@v2@@ ; __int64 @@result@@ ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; @@v1@@ = * ( __int64 * * ) @@a1@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( * ( _QWORD * ) @@a1@@ >= @@v2@@ ) goto LABEL_9 ; @@result@@ = * @@v1@@ ; if ( ! * @@v1@@ ) { while ( Number ) { @@v1@@ += Number ; if ( ( unsigned __int64 ) @@v1@@ >= @@v2@@ ) break ; @@result@@ = * @@v1@@ ; if ( * @@v1@@ ) return @@result@@ ; } LABEL_9 : abort ( ) ; } return @@result@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ , @@v4@@ ) ; } return @@result@@ ; }
__int64 __fastcall xstrcoll_version ( char * * @@a1@@ , char * * @@a2@@ ) { return filevercmp ( * @@a1@@ , * @@a2@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
size_t __fastcall format_user_or_group ( char * @@s@@ , __int64 a2 , int @@a3@@ ) { int @@v3@@ ; size_t @@v4@@ ; char * @@v5@@ ; size_t @@result@@ ; if ( @@s@@ ) { @@v3@@ = @@a3@@ - gnu_mbswidth ( @@s@@ ) ; if ( @@v3@@ < Number ) @@v3@@ = Number ; fputs_unlocked ( @@s@@ , stdout ) ; @@v4@@ = strlen ( @@s@@ ) + @@v3@@ ; do { @@v5@@ = stdout -> _IO_write_ptr ; if ( @@v5@@ >= stdout -> _IO_write_end ) { __overflow ( stdout , Number ) ; } else { stdout -> _IO_write_ptr = @@v5@@ + Number ; * @@v5@@ = Number ; } -- @@v3@@ ; } while ( @@v3@@ != Number ) ; } else { @@v4@@ = @@a3@@ ; __printf_chk ( ) ; } @@result@@ = @@v4@@ + dired_pos + Number ; dired_pos = @@result@@ ; return @@result@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ , @@v4@@ ) ; return @@result@@ ; }
unsigned __int64 __fastcall hash_string ( unsigned __int8 * @@a1@@ , unsigned __int64 @@a2@@ ) { __int64 @@v2@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@v4@@ ; @@v2@@ = * @@a1@@ ; for ( @@i@@ = Number L ; ( _BYTE ) @@v2@@ ; @@i@@ = @@v4@@ % @@a2@@ ) { ++ @@a1@@ ; @@v4@@ = @@v2@@ + Number * @@i@@ ; @@v2@@ = * @@a1@@ ; } return @@i@@ ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
unsigned __int64 __fastcall LCO_hash ( _QWORD * @@a1@@ , unsigned __int64 @@a2@@ ) { return * @@a1@@ % @@a2@@ ; }
bool __fastcall cycle_warning_required ( __int64 @@a1@@ , __int64 @@a2@@ ) { bool @@result@@ ; int @@v3@@ ; @@result@@ = Number ; @@v3@@ = * ( _DWORD * ) ( @@a1@@ + Number ) & Number ; if ( @@v3@@ != Number ) { @@result@@ = Number ; if ( @@v3@@ == Number ) @@result@@ = * ( _QWORD * ) ( @@a2@@ + Number ) != Number L ; } return @@result@@ ; }
int __fastcall xstrcoll_df_size ( __int64 @@a1@@ , __int64 @@a2@@ ) { bool @@v2@@ ; bool @@v3@@ ; int @@result@@ ; __int64 @@v5@@ ; bool @@v6@@ ; @@v2@@ = * ( _DWORD * ) ( @@a1@@ + Number ) == Number || * ( _DWORD * ) ( @@a1@@ + Number ) == Number ; @@v3@@ = * ( _DWORD * ) ( @@a2@@ + Number ) == Number || * ( _DWORD * ) ( @@a2@@ + Number ) == Number ; if ( ! @@v3@@ && @@v2@@ ) goto LABEL_9 ; if ( @@v2@@ || ( @@result@@ = Number , ! @@v3@@ ) ) { @@v5@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@v6@@ = * ( _QWORD * ) ( @@a1@@ + Number ) < @@v5@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= @@v5@@ ) { @@result@@ = Number ; if ( ! @@v6@@ ) @@result@@ = xstrcoll ( * ( char * * ) @@a1@@ , * ( char * * ) @@a2@@ ) ; return @@result@@ ; } LABEL_9 : @@result@@ = Number ; } return @@result@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
_QWORD * __fastcall hash_initialize ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 ( __fastcall * @@a3@@ ) ( __int64 a1 , unsigned __int64 a2 ) , bool ( __fastcall * @@a4@@ ) ( __int64 a1 , __int64 a2 ) , __int64 @@a5@@ ) { unsigned __int64 ( __fastcall * @@v5@@ ) ( __int64 , unsigned __int64 ) ; bool ( __fastcall * @@v6@@ ) ( __int64 , __int64 ) ; char * @@v9@@ ; _QWORD * @@v10@@ ; float * * @@v11@@ ; float @@v12@@ ; float @@v13@@ ; float @@v14@@ ; unsigned __int64 @@v15@@ ; char * @@v16@@ ; void * @@v17@@ ; @@v5@@ = @@a3@@ ; @@v6@@ = @@a4@@ ; if ( ! @@a3@@ ) @@v5@@ = raw_hasher ; if ( ! @@a4@@ ) @@v6@@ = raw_comparator ; @@v9@@ = ( char * ) malloc ( Number ) ; @@v10@@ = @@v9@@ ; if ( @@v9@@ ) { @@v11@@ = ( float * * ) ( @@v9@@ + Number ) ; if ( @@a2@@ ) { * ( ( _QWORD * ) @@v9@@ + Number ) = @@a2@@ ; if ( ! ( unsigned __int8 ) check_tuning_isra_0 ( @@v11@@ ) ) goto LABEL_20 ; if ( * ( _BYTE * ) ( @@a2@@ + Number ) ) { LABEL_15 : @@v15@@ = next_prime ( @@a1@@ ) ; if ( @@v15@@ <= Number ) { @@v10@@ [ Number ] = @@v15@@ ; if ( @@v15@@ ) { @@v16@@ = ( char * ) calloc ( @@v15@@ , Number ) ; * @@v10@@ = @@v16@@ ; if ( @@v16@@ ) { @@v10@@ [ Number ] = Number L ; @@v10@@ [ Number ] = Number L ; @@v10@@ [ Number ] = @@v5@@ ; @@v10@@ [ Number ] = @@v6@@ ; @@v10@@ [ Number ] = & @@v16@@ [ Number * @@v15@@ ] ; @@v10@@ [ Number ] = @@a5@@ ; @@v10@@ [ Number ] = Number L ; return @@v10@@ ; } } } LABEL_20 : @@v17@@ = @@v10@@ ; @@v10@@ = Number L ; free ( @@v17@@ ) ; return @@v10@@ ; } @@v12@@ = * ( float * ) ( @@a2@@ + Number ) ; } else { * ( ( _QWORD * ) @@v9@@ + Number ) = & default_tuning ; @@v12@@ = Number ; if ( ! ( unsigned __int8 ) check_tuning_isra_0 ( @@v11@@ ) ) goto LABEL_20 ; } if ( @@a1@@ < Number ) @@v13@@ = ( float ) ( @@a1@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@a1@@ >> Number ) ) + ( float ) ( @@a1@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@a1@@ >> Number ) ) ; else @@v13@@ = ( float ) ( int ) @@a1@@ ; @@v14@@ = @@v13@@ / @@v12@@ ; if ( @@v14@@ >= Number ) goto LABEL_20 ; if ( @@v14@@ < Number ) @@a1@@ = ( unsigned int ) ( int ) @@v14@@ ; else @@a1@@ = ( unsigned int ) ( int ) ( float ) ( @@v14@@ - Number ) ^ Number ; goto LABEL_15 ; } return @@v10@@ ; }
__int64 __fastcall cycle_check ( __int64 @@a1@@ , __int64 * @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@result@@ ; __int64 @@v5@@ ; if ( * ( _DWORD * ) ( @@a1@@ + Number ) != Number ) __assert_fail ( String , String , Number , String ) ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v3@@ = @@a2@@ [ Number ] ; if ( ! @@v2@@ ) { * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; goto LABEL_7 ; } if ( * ( _QWORD * ) @@a1@@ == @@v3@@ && * @@a2@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ) { return Number L ; } @@result@@ = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v2@@ + Number ; if ( ( ( @@v2@@ + Number ) & @@v2@@ ) == Number ) { if ( @@v2@@ == Number ) return Number L ; LABEL_7 : @@v5@@ = * @@a2@@ ; * ( _QWORD * ) @@a1@@ = @@v3@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v5@@ ; @@result@@ = Number L ; } return @@result@@ ; }
int __fastcall strcmp_df_name ( __int64 @@a1@@ , __int64 @@a2@@ ) { bool @@v2@@ ; bool @@v3@@ ; int @@result@@ ; @@v2@@ = * ( _DWORD * ) ( @@a1@@ + Number ) == Number || * ( _DWORD * ) ( @@a1@@ + Number ) == Number ; @@v3@@ = * ( _DWORD * ) ( @@a2@@ + Number ) == Number || * ( _DWORD * ) ( @@a2@@ + Number ) == Number ; if ( ! @@v3@@ && @@v2@@ ) return Number ; if ( @@v2@@ || ( @@result@@ = Number , ! @@v3@@ ) ) @@result@@ = strcmp ( * ( const char * * ) @@a1@@ , * ( const char * * ) @@a2@@ ) ; return @@result@@ ; }
__int64 __fastcall fts_stat ( __int64 @@a1@@ , __int64 @@a2@@ , char @@a3@@ ) { struct stat * @@v4@@ ; bool @@v5@@ ; int @@v6@@ ; const char * @@v7@@ ; int * @@v8@@ ; int @@v9@@ ; int * @@v10@@ ; __int64 @@result@@ ; int @@v12@@ ; __int64 @@v13@@ ; @@v4@@ = ( struct stat * ) ( @@a2@@ + Number ) ; @@v5@@ = * ( _QWORD * ) ( @@a2@@ + Number ) == Number L ; @@v6@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; @@v7@@ = * ( const char * * ) ( @@a2@@ + Number ) ; if ( @@v5@@ && ( @@v6@@ & Number ) != Number || ( @@v6@@ & Number ) != Number || @@a3@@ ) { if ( ! __xstat ( Number , @@v7@@ , @@v4@@ ) ) goto LABEL_11 ; @@v8@@ = __errno_location ( ) ; @@v9@@ = * @@v8@@ ; @@v10@@ = @@v8@@ ; if ( * @@v8@@ == Number && ! __lxstat ( Number , * ( const char * * ) ( @@a2@@ + Number ) , @@v4@@ ) ) { * @@v10@@ = Number ; return Number L ; } * ( _DWORD * ) ( @@a2@@ + Number ) = @@v9@@ ; LABEL_6 : * ( _QWORD * ) ( @@a2@@ + Number ) = Number L ; @@v4@@ -> __unused [ Number ] = Number L ; memset ( ( void * ) ( ( unsigned __int64 ) & @@v4@@ -> st_ino & Number ) , Number , Number L * ( ( ( unsigned int ) @@v4@@ - ( ( ( _DWORD ) @@v4@@ + Number ) & Number ) + Number ) >> Number ) ) ; return Number L ; } if ( __fxstatat ( Number , * ( _DWORD * ) ( @@a1@@ + Number ) , @@v7@@ , @@v4@@ , Number ) ) { * ( _DWORD * ) ( @@a2@@ + Number ) = * __errno_location ( ) ; goto LABEL_6 ; } LABEL_11 : @@v12@@ = * ( _DWORD * ) ( @@a2@@ + Number ) & Number ; if ( @@v12@@ == Number ) { @@v13@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( ( * ( _BYTE * ) ( @@a1@@ + Number ) & Number ) == Number ) @@v13@@ -= Number L ; @@v5@@ = * ( _BYTE * ) ( @@a2@@ + Number ) == Number ; * ( _QWORD * ) ( @@a2@@ + Number ) = @@v13@@ ; @@result@@ = Number L ; if ( @@v5@@ && ( ! * ( _BYTE * ) ( @@a2@@ + Number ) || ( * ( _DWORD * ) ( @@a2@@ + Number ) & Number ) == Number ) ) { @@result@@ = * ( _QWORD * ) ( @@a2@@ + Number ) == Number L ? Number : Number ; } } else if ( @@v12@@ == Number ) { @@result@@ = Number L ; } else { @@result@@ = Number * ( unsigned int ) ( @@v12@@ == Number ) + Number ; } return @@result@@ ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
__int64 __fastcall xstrcoll_df_version ( __int64 @@a1@@ , __int64 @@a2@@ ) { bool @@v2@@ ; bool @@v3@@ ; __int64 @@result@@ ; @@v2@@ = * ( _DWORD * ) ( @@a1@@ + Number ) == Number || * ( _DWORD * ) ( @@a1@@ + Number ) == Number ; @@v3@@ = * ( _DWORD * ) ( @@a2@@ + Number ) == Number || * ( _DWORD * ) ( @@a2@@ + Number ) == Number ; if ( ! @@v3@@ && @@v2@@ ) return Number ; if ( @@v2@@ || ( @@result@@ = Number L , ! @@v3@@ ) ) @@result@@ = filevercmp ( * ( char * * ) @@a1@@ , * ( char * * ) @@a2@@ ) ; return @@result@@ ; }
unsigned __int64 __fastcall write_counts ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v10@@ ; _BYTE @@v12@@ [ Number ] ; unsigned __int64 @@v13@@ ; @@v13@@ = __readfsqword ( Number ) ; if ( print_lines ) { umaxtostr ( @@a1@@ , @@v12@@ ) ; __printf_chk ( ) ; if ( ! print_words ) { LABEL_3 : if ( ! print_chars ) goto LABEL_4 ; goto LABEL_13 ; } } else if ( ! print_words ) { goto LABEL_3 ; } umaxtostr ( @@a2@@ , @@v12@@ ) ; __printf_chk ( ) ; if ( ! print_chars ) { LABEL_4 : if ( ! print_bytes ) goto LABEL_5 ; LABEL_14 : umaxtostr ( @@a4@@ , @@v12@@ ) ; __printf_chk ( ) ; if ( ! print_linelength ) goto LABEL_6 ; goto LABEL_15 ; } LABEL_13 : umaxtostr ( @@a3@@ , @@v12@@ ) ; __printf_chk ( ) ; if ( print_bytes ) goto LABEL_14 ; LABEL_5 : if ( ! print_linelength ) goto LABEL_6 ; LABEL_15 : umaxtostr ( @@a5@@ , @@v12@@ ) ; __printf_chk ( ) ; LABEL_6 : if ( @@a6@@ ) __printf_chk ( ) ; @@v10@@ = stdout -> _IO_write_ptr ; if ( @@v10@@ >= stdout -> _IO_write_end ) { __overflow ( stdout , Number ) ; } else { stdout -> _IO_write_ptr = @@v10@@ + Number ; * @@v10@@ = Number ; } return __readfsqword ( Number ) ^ @@v13@@ ; }
__int64 __fastcall hash_get_n_buckets ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 __fastcall hash_get_n_buckets_used ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int64 __fastcall align_nstrftime_constprop_49 ( __int64 @@a1@@ , const char * @@a2@@ , __int64 @@a3@@ , unsigned int @@a4@@ ) { const char * @@v5@@ ; char * @@v7@@ ; char * @@v9@@ ; char * @@v10@@ ; _QWORD @@v11@@ [ Number ] ; @@v5@@ = @@a2@@ ; @@v11@@ [ Number ] = __readfsqword ( Number ) ; if ( required_mon_width ) { @@v7@@ = strstr ( @@a2@@ , String ) ; if ( @@v7@@ ) { if ( strlen ( @@a2@@ ) <= Number ) { @@v9@@ = ( char * ) __mempcpy_chk ( ) ; @@v5@@ = ( const char * ) @@v11@@ ; @@v10@@ = stpcpy ( @@v9@@ , & abmon [ Number * * ( int * ) ( @@a3@@ + Number ) ] ) ; strcpy ( @@v10@@ , @@v7@@ + Number ) ; } } } return nstrftime ( @@a1@@ , Number L , @@v5@@ , @@a3@@ , Number L , @@a4@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
int __fastcall readtokens0_init ( __int64 @@a1@@ ) { * ( _QWORD * ) @@a1@@ = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; _obstack_begin ( ( struct obstack * ) ( @@a1@@ + Number ) , Number , Number , ( void * ( * ) ( __int64 ) ) & malloc , ( void ( * ) ( void * ) ) & free ) ; _obstack_begin ( ( struct obstack * ) ( @@a1@@ + Number ) , Number , Number , ( void * ( * ) ( __int64 ) ) & malloc , ( void ( * ) ( void * ) ) & free ) ; return _obstack_begin ( ( struct obstack * ) ( @@a1@@ + Number ) , Number , Number , ( void * ( * ) ( __int64 ) ) & malloc , ( void ( * ) ( void * ) ) & free ) ; }
__int64 __fastcall hash_get_n_entries ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__ino_t * __fastcall get_root_dev_ino ( __ino_t * @@a1@@ ) { struct stat @@v2@@ ; unsigned __int64 @@v3@@ ; @@v3@@ = __readfsqword ( Number ) ; if ( __lxstat ( Number , String , & @@v2@@ ) ) return Number L ; * @@a1@@ = @@v2@@ . st_ino ; @@a1@@ [ Number ] = @@v2@@ . st_dev ; return @@a1@@ ; }
int __fastcall rev_xstrcoll_mtime ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) <= @@v2@@ ) { if ( * ( _QWORD * ) ( @@a2@@ + Number ) < @@v2@@ ) return Number ; @@v3@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) <= @@v3@@ ) { if ( * ( _QWORD * ) ( @@a2@@ + Number ) >= @@v3@@ ) return xstrcoll ( * ( char * * ) @@a2@@ , * ( char * * ) @@a1@@ ) ; return Number ; } } return Number ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ , @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
bool __fastcall hash_table_ok ( __int64 @@a1@@ ) { _QWORD * @@v1@@ ; unsigned __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; bool @@result@@ ; @@v1@@ = * ( _QWORD * * ) @@a1@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v3@@ = Number L ; @@v4@@ = Number L ; if ( * ( _QWORD * ) @@a1@@ < @@v2@@ ) { do { if ( * @@v1@@ ) { @@v5@@ = @@v1@@ [ Number ] ; ++ @@v4@@ ; ++ @@v3@@ ; for ( ; @@v5@@ ; ++ @@v3@@ ) @@v5@@ = * ( _QWORD * ) ( @@v5@@ + Number ) ; } @@v1@@ += Number ; } while ( ( unsigned __int64 ) @@v1@@ < @@v2@@ ) ; } @@result@@ = Number ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) == @@v4@@ ) @@result@@ = * ( _QWORD * ) ( @@a1@@ + Number ) == @@v3@@ ; return @@result@@ ; }
int __fastcall xstrcoll_mtime ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; @@v2@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= @@v2@@ ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) < @@v2@@ ) return Number ; @@v3@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= @@v3@@ ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) >= @@v3@@ ) return xstrcoll ( * ( char * * ) @@a1@@ , * ( char * * ) @@a2@@ ) ; return Number ; } } return Number ; }
__int64 __fastcall xfts_open ( const char * * @@a1@@ , int @@a2@@ , __int64 @@a3@@ ) { __int64 @@v3@@ ; __int64 @@result@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; @@v3@@ = @@a2@@ | Number ; @@result@@ = fts_open ( @@a1@@ , @@v3@@ , @@a3@@ ) ; if ( ! @@result@@ ) { if ( * __errno_location ( ) != Number ) xalloc_die ( @@a1@@ , @@v3@@ , @@v5@@ , @@v6@@ ) ; __assert_fail ( String , String , Number , String ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
unsigned __int64 __fastcall hash_get_entries ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { _QWORD * @@v3@@ ; unsigned __int64 @@v4@@ ; _QWORD * @@v5@@ ; unsigned __int64 @@result@@ ; @@v3@@ = * ( _QWORD * * ) @@a1@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= * ( _QWORD * ) @@a1@@ ) return Number L ; @@v4@@ = Number L ; while ( ! * @@v3@@ ) { LABEL_9 : @@v3@@ += Number ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= ( unsigned __int64 ) @@v3@@ ) return @@v4@@ ; } if ( @@a3@@ <= @@v4@@ ) return @@v4@@ ; * ( _QWORD * ) ( @@a2@@ + Number * @@v4@@ ) = * @@v3@@ ; @@v5@@ = ( _QWORD * ) @@v3@@ [ Number ] ; @@result@@ = @@v4@@ + Number ; if ( ! @@v5@@ ) { LABEL_8 : @@v4@@ = @@result@@ ; goto LABEL_9 ; } while ( @@a3@@ != @@result@@ ) { ++ @@result@@ ; * ( _QWORD * ) ( @@a2@@ + Number * @@result@@ - Number ) = * @@v5@@ ; @@v5@@ = ( _QWORD * ) @@v5@@ [ Number ] ; if ( ! @@v5@@ ) goto LABEL_8 ; } return @@result@@ ; }
__int64 __fastcall dup_safer ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
int __fastcall rev_strcmp_mtime ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) <= @@v2@@ ) { if ( * ( _QWORD * ) ( @@a2@@ + Number ) < @@v2@@ ) return Number ; @@v3@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) <= @@v3@@ ) { if ( * ( _QWORD * ) ( @@a2@@ + Number ) >= @@v3@@ ) return strcmp ( * ( const char * * ) @@a2@@ , * ( const char * * ) @@a1@@ ) ; return Number ; } } return Number ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
double physmem_total ( ) { int @@v0@@ ; double @@result@@ ; double @@v2@@ ; @@v2@@ = ( double ) ( int ) sysconf ( Number ) ; @@v0@@ = sysconf ( Number ) ; if ( @@v2@@ < Number || ( double ) @@v0@@ < Number ) @@result@@ = Number ; else @@result@@ = @@v2@@ * ( double ) @@v0@@ ; return @@result@@ ; }
__int64 __fastcall i_ring_empty ( __int64 @@a1@@ ) { return * ( unsigned __int8 * ) ( @@a1@@ + Number ) ; }
int __fastcall xstrcoll_df_ctime ( __int64 @@a1@@ , __int64 @@a2@@ ) { bool @@v2@@ ; bool @@v3@@ ; int @@result@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; @@v2@@ = * ( _DWORD * ) ( @@a1@@ + Number ) == Number || * ( _DWORD * ) ( @@a1@@ + Number ) == Number ; @@v3@@ = * ( _DWORD * ) ( @@a2@@ + Number ) == Number || * ( _DWORD * ) ( @@a2@@ + Number ) == Number ; if ( ! @@v3@@ && @@v2@@ ) return Number ; if ( @@v2@@ || ( @@result@@ = Number , ! @@v3@@ ) ) { @@v5@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= @@v5@@ ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) < @@v5@@ ) return Number ; @@v6@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= @@v6@@ ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) >= @@v6@@ ) return xstrcoll ( * ( char * * ) @@a1@@ , * ( char * * ) @@a2@@ ) ; return Number ; } } return Number ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_2061F0 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061D0 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_2061E0 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
__int64 __fastcall fd_safer ( int @@fd@@ , __int64 @@a2@@ , __int64 @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { unsigned int @@v6@@ ; unsigned int @@v7@@ ; int * @@v8@@ ; int @@v9@@ ; int * @@v10@@ ; @@v6@@ = @@fd@@ ; if ( ( unsigned int ) @@fd@@ <= Number ) { @@v7@@ = dup_safer ( @@fd@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; @@v8@@ = __errno_location ( ) ; @@v9@@ = * @@v8@@ ; @@v10@@ = @@v8@@ ; close ( @@fd@@ ) ; @@v6@@ = @@v7@@ ; * @@v10@@ = @@v9@@ ; } return @@v6@@ ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
int __fastcall rev_strcmp_extension ( const char * * @@a1@@ , const char * * @@a2@@ ) { const char * @@v2@@ ; char * @@v3@@ ; const char * @@v4@@ ; const char * @@v5@@ ; char * @@v6@@ ; int @@result@@ ; @@v2@@ = * @@a2@@ ; @@v3@@ = strrchr ( * @@a2@@ , Number ) ; @@v4@@ = * @@a1@@ ; @@v5@@ = @@v3@@ ; @@v6@@ = strrchr ( * @@a1@@ , Number ) ; if ( @@v6@@ ) { if ( ! @@v5@@ ) @@v5@@ = String ; @@result@@ = strcmp ( @@v5@@ , @@v6@@ ) ; if ( ! @@result@@ ) return strcmp ( @@v2@@ , @@v4@@ ) ; } else { if ( ! @@v5@@ ) return strcmp ( @@v2@@ , @@v4@@ ) ; @@result@@ = strcmp ( @@v5@@ , String ) ; if ( ! @@result@@ ) return strcmp ( @@v2@@ , @@v4@@ ) ; } return @@result@@ ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
__int64 __fastcall i_ring_push ( __int64 @@a1@@ , int @@a2@@ ) { char @@v2@@ ; int @@v3@@ ; _DWORD * @@v4@@ ; __int64 @@result@@ ; int @@v6@@ ; @@v2@@ = * ( _BYTE * ) ( @@a1@@ + Number ) ^ Number ; @@v3@@ = ( @@v2@@ + ( unsigned __int8 ) * ( _DWORD * ) ( @@a1@@ + Number ) ) & Number ; @@v4@@ = ( _DWORD * ) ( @@a1@@ + Number L * ( ( @@v2@@ + ( unsigned __int8 ) * ( _DWORD * ) ( @@a1@@ + Number ) ) & Number ) ) ; @@result@@ = ( unsigned int ) * @@v4@@ ; * @@v4@@ = @@a2@@ ; @@v6@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@v3@@ ; if ( @@v6@@ == @@v3@@ ) * ( _DWORD * ) ( @@a1@@ + Number ) = ( ( _BYTE ) @@v6@@ + @@v2@@ ) & Number ; * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; return @@result@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
char * __fastcall areadlink_with_size ( char * @@path@@ , unsigned __int64 @@a2@@ ) { size_t @@v2@@ ; char * @@v3@@ ; char * @@v4@@ ; ssize_t @@v5@@ ; char * @@v7@@ ; @@v2@@ = @@a2@@ + Number ; if ( @@a2@@ >= Number ) @@v2@@ = Number L ; while ( Number ) { @@v3@@ = ( char * ) malloc ( @@v2@@ ) ; @@v4@@ = @@v3@@ ; if ( @@v3@@ ) { while ( Number ) { @@v5@@ = readlink ( @@path@@ , @@v3@@ , @@v2@@ ) ; if ( @@v5@@ < Number && * __errno_location ( ) != Number ) { @@v7@@ = @@v4@@ ; @@v4@@ = Number L ; free ( @@v7@@ ) ; return @@v4@@ ; } if ( @@v2@@ > @@v5@@ ) { @@v4@@ [ @@v5@@ ] = Number ; return @@v4@@ ; } free ( @@v4@@ ) ; if ( @@v2@@ > Number ) break ; @@v2@@ *= Number L ; @@v3@@ = ( char * ) malloc ( @@v2@@ ) ; @@v4@@ = @@v3@@ ; if ( ! @@v3@@ ) return @@v4@@ ; } if ( @@v2@@ <= Number ) { @@v2@@ = Number ; continue ; } @@v4@@ = Number L ; * __errno_location ( ) = Number ; } break ; } return @@v4@@ ; }
__int64 __fastcall mode_create_from_ref ( char * @@filename@@ ) { __mode_t @@v1@@ ; __int64 @@result@@ ; struct stat @@v3@@ ; unsigned __int64 @@v4@@ ; @@v4@@ = __readfsqword ( Number ) ; if ( __xstat ( Number , @@filename@@ , & @@v3@@ ) ) return Number L ; @@v1@@ = @@v3@@ . st_mode ; @@result@@ = xmalloc ( Number L ) ; * ( _DWORD * ) ( @@result@@ + Number ) = Number ; * ( _DWORD * ) ( @@result@@ + Number ) = Number ; * ( _WORD * ) @@result@@ = Number ; * ( _DWORD * ) ( @@result@@ + Number ) = @@v1@@ ; * ( _BYTE * ) ( @@result@@ + Number ) = Number ; return @@result@@ ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
int __xstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _xstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
int iswspace ( wint_t @@wc@@ ) { return iswspace ( @@wc@@ ) ; }
__int64 __fastcall argmatch ( const char * @@a1@@ , const char * * @@a2@@ , char * @@a3@@ , size_t @@a4@@ ) { char * @@v5@@ ; size_t @@v6@@ ; const char * @@v7@@ ; size_t @@v8@@ ; __int64 @@v9@@ ; bool @@v10@@ ; char @@v11@@ ; __int64 @@v12@@ ; __int64 @@v14@@ ; char @@v15@@ ; @@v5@@ = @@a3@@ ; @@v6@@ = strlen ( @@a1@@ ) ; @@v7@@ = * @@a2@@ ; @@v14@@ = Number ; if ( ! * @@a2@@ ) return @@v14@@ ; @@v8@@ = @@v6@@ ; @@v15@@ = Number ; @@v9@@ = Number L ; do { while ( strncmp ( @@v7@@ , @@a1@@ , @@v8@@ ) ) { LABEL_7 : ++ @@v9@@ ; @@v5@@ += @@a4@@ ; @@v7@@ = @@a2@@ [ @@v9@@ ] ; if ( ! @@v7@@ ) goto LABEL_12 ; } if ( strlen ( @@v7@@ ) == @@v8@@ ) return @@v9@@ ; if ( @@v14@@ != Number ) { if ( @@a3@@ ) { @@v10@@ = memcmp ( & @@a3@@ [ @@a4@@ * @@v14@@ ] , @@v5@@ , @@a4@@ ) == Number ; @@v11@@ = @@v15@@ ; if ( ! @@v10@@ ) @@v11@@ = Number ; @@v15@@ = @@v11@@ ; } else { @@v15@@ = Number ; } goto LABEL_7 ; } @@v14@@ = @@v9@@ ++ ; @@v5@@ += @@a4@@ ; @@v7@@ = @@a2@@ [ @@v9@@ ] ; } while ( @@v7@@ ) ; LABEL_12 : @@v12@@ = Number ; if ( ! @@v15@@ ) @@v12@@ = @@v14@@ ; return @@v12@@ ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
__int64 sysconf ( int @@name@@ ) { return sysconf ( @@name@@ ) ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
unsigned __int64 __fastcall raw_hasher ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return __ROR8__ ( @@a1@@ , Number ) % @@a2@@ ; }
bool __fastcall wd_comparator ( __int64 @@a1@@ , __int64 @@a2@@ ) { return * ( _DWORD * ) ( @@a1@@ + Number ) == * ( _DWORD * ) ( @@a2@@ + Number ) ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
void * malloc ( size_t @@size@@ ) { return __imp_malloc ( @@size@@ ) ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_208230 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_208210 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_208220 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
_QWORD * __fastcall argv_iter_init_argv ( __int64 @@a1@@ ) { _QWORD * @@result@@ ; @@result@@ = malloc ( Number ) ; if ( @@result@@ ) { * @@result@@ = Number L ; @@result@@ [ Number ] = @@a1@@ ; @@result@@ [ Number ] = @@a1@@ ; } return @@result@@ ; }
__int64 __fastcall check_tuning_isra_0 ( float * * @@a1@@ ) { float * @@v1@@ ; __int64 @@result@@ ; float @@v3@@ ; float @@v4@@ ; float @@v5@@ ; @@v1@@ = * @@a1@@ ; @@result@@ = Number L ; if ( * @@a1@@ != ( float * ) & default_tuning ) { @@v3@@ = @@v1@@ [ Number ] ; if ( @@v3@@ <= Number || @@v3@@ >= Number || @@v1@@ [ Number ] <= Number || * @@v1@@ < Number || ( @@v4@@ = * @@v1@@ + Number , @@v5@@ = @@v1@@ [ Number ] , @@v5@@ <= @@v4@@ ) || @@v5@@ > Number || @@v3@@ <= @@v4@@ ) { * @@a1@@ = ( float * ) & default_tuning ; @@result@@ = Number L ; } } return @@result@@ ; }
__int64 __fastcall start_lines ( __int64 @@a1@@ , int @@a2@@ , __int64 @@a3@@ , _QWORD * @@a4@@ ) { __int64 @@result@@ ; __int64 @@v6@@ ; __int64 @@v8@@ ; char * @@v9@@ ; char * @@v10@@ ; char * @@v11@@ ; size_t @@v12@@ ; __int64 @@v13@@ ; char * @@v14@@ ; int * @@v15@@ ; unsigned int @@v16@@ ; char @@s@@ [ Number ] ; unsigned __int64 @@v18@@ ; @@v18@@ = __readfsqword ( Number ) ; @@result@@ = Number L ; if ( @@a3@@ ) { @@v6@@ = @@a3@@ ; while ( Number ) { @@v8@@ = safe_read ( @@a2@@ , @@s@@ , Number ) ; @@v9@@ = & @@s@@ [ @@v8@@ ] ; if ( ! @@v8@@ ) return Number ; if ( @@v8@@ == Number ) break ; * @@a4@@ += @@v8@@ ; @@v10@@ = @@s@@ ; while ( Number ) { @@v11@@ = ( char * ) memchr ( @@v10@@ , Number , @@v9@@ - @@v10@@ ) ; if ( ! @@v11@@ ) break ; -- @@v6@@ ; @@v10@@ = @@v11@@ + Number ; if ( ! @@v6@@ ) { @@result@@ = Number L ; if ( @@v9@@ > @@v10@@ ) { @@v12@@ = @@v9@@ - @@v10@@ ; if ( @@v12@@ ) { @@v16@@ = Number ; xwrite_stdout_part_5 ( @@v10@@ , @@v12@@ ) ; @@result@@ = @@v16@@ ; } } return @@result@@ ; } } } @@v13@@ = quote ( @@a1@@ , @@s@@ ) ; @@v14@@ = dcgettext ( Number L , String , Number ) ; @@v15@@ = __errno_location ( ) ; error ( Number , * @@v15@@ , @@v14@@ , @@v13@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
__int64 __fastcall argv_iter_n_args ( _QWORD * @@a1@@ ) { __int64 @@result@@ ; if ( * @@a1@@ ) @@result@@ = @@a1@@ [ Number ] ; else @@result@@ = ( __int64 ) ( @@a1@@ [ Number ] - @@a1@@ [ Number ] ) >> Number ; return @@result@@ ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
__int64 __fastcall hash_get_first ( __int64 @@a1@@ ) { __int64 * @@v1@@ ; unsigned __int64 @@v2@@ ; __int64 @@result@@ ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; @@v1@@ = * ( __int64 * * ) @@a1@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( * ( _QWORD * ) @@a1@@ >= @@v2@@ ) goto LABEL_9 ; @@result@@ = * @@v1@@ ; if ( ! * @@v1@@ ) { while ( Number ) { @@v1@@ += Number ; if ( ( unsigned __int64 ) @@v1@@ >= @@v2@@ ) break ; @@result@@ = * @@v1@@ ; if ( * @@v1@@ ) return @@result@@ ; } LABEL_9 : abort ( ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
void __fastcall argv_iter_free ( void * @@ptr@@ ) { if ( * ( _QWORD * ) @@ptr@@ ) free ( * ( ( void * * ) @@ptr@@ + Number ) ) ; free ( @@ptr@@ ) ; }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; FILE * @@v11@@ ; char * @@v12@@ ; FILE * @@v13@@ ; char * @@v14@@ ; FILE * @@v15@@ ; char * @@v16@@ ; FILE * @@v17@@ ; char * @@v18@@ ; FILE * @@v19@@ ; char * @@v20@@ ; char * @@v21@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String String String String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; dcgettext ( Number L , String String String String String String String , Number ) ; __printf_chk ( ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = stdout ; @@v10@@ = dcgettext ( Number L , String String String , Number ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; @@v11@@ = stdout ; @@v12@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v12@@ , @@v11@@ ) ; @@v13@@ = stdout ; @@v14@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v14@@ , @@v13@@ ) ; @@v15@@ = stdout ; @@v16@@ = dcgettext ( Number L , String String String String String String String , Number ) ; fputs_unlocked ( @@v16@@ , @@v15@@ ) ; @@v17@@ = stdout ; @@v18@@ = dcgettext ( Number L , String String String String String String , Number ) ; fputs_unlocked ( @@v18@@ , @@v17@@ ) ; last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v19@@ = stdout ; @@v20@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v20@@ , @@v19@@ ) ; @@v21@@ = setlocale ( Number , Number L ) ; if ( @@v21@@ ) { if ( strncmp ( @@v21@@ , String , Number ) ) { last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@result@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ , @@v4@@ ) ; } return @@result@@ ; }
struct tm * localtime ( const time_t * @@timer@@ ) { return localtime ( @@timer@@ ) ; }
unsigned __int64 __fastcall hash_string ( unsigned __int8 * @@a1@@ , unsigned __int64 @@a2@@ ) { __int64 @@v2@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@v4@@ ; @@v2@@ = * @@a1@@ ; for ( @@i@@ = Number L ; ( _BYTE ) @@v2@@ ; @@i@@ = @@v4@@ % @@a2@@ ) { ++ @@a1@@ ; @@v4@@ = @@v2@@ + Number * @@i@@ ; @@v2@@ = * @@a1@@ ; } return @@i@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
void * __fastcall xzalloc ( size_t @@n@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@n@@ ) ; }
void __fastcall argmatch_invalid ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { char * @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; if ( @@a3@@ == Number ) @@v3@@ = dcgettext ( Number L , String , Number ) ; else @@v3@@ = dcgettext ( Number L , String , Number ) ; @@v4@@ = quote_n ( Number L , @@a1@@ ) ; @@v5@@ = quotearg_n_style ( Number L , Number L , @@a2@@ ) ; error ( Number , Number , @@v3@@ , @@v5@@ , @@v4@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
_QWORD * __fastcall hash_initialize ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 ( __fastcall * @@a3@@ ) ( __int64 a1 , unsigned __int64 a2 ) , bool ( __fastcall * @@a4@@ ) ( __int64 a1 , __int64 a2 ) , __int64 @@a5@@ ) { unsigned __int64 ( __fastcall * @@v5@@ ) ( __int64 , unsigned __int64 ) ; bool ( __fastcall * @@v6@@ ) ( __int64 , __int64 ) ; char * @@v9@@ ; _QWORD * @@v10@@ ; float * * @@v11@@ ; float @@v12@@ ; float @@v13@@ ; float @@v14@@ ; unsigned __int64 @@v15@@ ; char * @@v16@@ ; void * @@v17@@ ; @@v5@@ = @@a3@@ ; @@v6@@ = @@a4@@ ; if ( ! @@a3@@ ) @@v5@@ = raw_hasher ; if ( ! @@a4@@ ) @@v6@@ = raw_comparator ; @@v9@@ = ( char * ) malloc ( Number ) ; @@v10@@ = @@v9@@ ; if ( @@v9@@ ) { @@v11@@ = ( float * * ) ( @@v9@@ + Number ) ; if ( @@a2@@ ) { * ( ( _QWORD * ) @@v9@@ + Number ) = @@a2@@ ; if ( ! ( unsigned __int8 ) check_tuning_isra_0 ( @@v11@@ ) ) goto LABEL_20 ; if ( * ( _BYTE * ) ( @@a2@@ + Number ) ) { LABEL_15 : @@v15@@ = next_prime ( @@a1@@ ) ; if ( @@v15@@ <= Number ) { @@v10@@ [ Number ] = @@v15@@ ; if ( @@v15@@ ) { @@v16@@ = ( char * ) calloc ( @@v15@@ , Number ) ; * @@v10@@ = @@v16@@ ; if ( @@v16@@ ) { @@v10@@ [ Number ] = Number L ; @@v10@@ [ Number ] = Number L ; @@v10@@ [ Number ] = @@v5@@ ; @@v10@@ [ Number ] = @@v6@@ ; @@v10@@ [ Number ] = & @@v16@@ [ Number * @@v15@@ ] ; @@v10@@ [ Number ] = @@a5@@ ; @@v10@@ [ Number ] = Number L ; return @@v10@@ ; } } } LABEL_20 : @@v17@@ = @@v10@@ ; @@v10@@ = Number L ; free ( @@v17@@ ) ; return @@v10@@ ; } @@v12@@ = * ( float * ) ( @@a2@@ + Number ) ; } else { * ( ( _QWORD * ) @@v9@@ + Number ) = & default_tuning ; @@v12@@ = Number ; if ( ! ( unsigned __int8 ) check_tuning_isra_0 ( @@v11@@ ) ) goto LABEL_20 ; } if ( @@a1@@ < Number ) @@v13@@ = ( float ) ( @@a1@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@a1@@ >> Number ) ) + ( float ) ( @@a1@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@a1@@ >> Number ) ) ; else @@v13@@ = ( float ) ( int ) @@a1@@ ; @@v14@@ = @@v13@@ / @@v12@@ ; if ( @@v14@@ >= Number ) goto LABEL_20 ; if ( @@v14@@ < Number ) @@a1@@ = ( unsigned int ) ( int ) @@v14@@ ; else @@a1@@ = ( unsigned int ) ( int ) ( float ) ( @@v14@@ - Number ) ^ Number ; goto LABEL_15 ; } return @@v10@@ ; }
struct passwd * getpwuid ( __uid_t @@uid@@ ) { return getpwuid ( @@uid@@ ) ; }
__int64 __fastcall argmatch_to_argument ( void * @@s1@@ , __int64 * @@a2@@ , char * @@a3@@ , size_t @@a4@@ ) { __int64 @@v4@@ ; __int64 * @@v7@@ ; @@v4@@ = * @@a2@@ ; if ( * @@a2@@ ) { @@v7@@ = @@a2@@ + Number ; do { if ( ! memcmp ( @@s1@@ , @@a3@@ , @@a4@@ ) ) break ; @@v4@@ = * @@v7@@ ; @@a3@@ += @@a4@@ ; ++ @@v7@@ ; } while ( @@v4@@ ) ; } return @@v4@@ ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
__int64 __fastcall dup_cloexec ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
struct group * getgrgid ( __gid_t @@gid@@ ) { return getgrgid ( @@gid@@ ) ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
struct passwd * getpwnam ( const char * @@name@@ ) { return getpwnam ( @@name@@ ) ; }
void __fastcall c_strtod ( char * @@nptr@@ , char * * @@endptr@@ ) { if ( ! c_locale_cache ) c_locale_cache = newlocale ( Number , String , Number L ) ; if ( c_locale_cache ) { strtod_l ( @@nptr@@ , @@endptr@@ , c_locale_cache ) ; } else if ( @@endptr@@ ) { * @@endptr@@ = @@nptr@@ ; } }
struct dirent * readdir ( DIR * @@dirp@@ ) { return readdir ( @@dirp@@ ) ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
double physmem_available ( ) { int @@v0@@ ; double @@result@@ ; double @@v2@@ ; @@v2@@ = ( double ) ( int ) sysconf ( Number ) ; @@v0@@ = sysconf ( Number ) ; if ( @@v2@@ < Number || ( double ) @@v0@@ < Number ) @@result@@ = physmem_total ( ) * Number ; else @@result@@ = @@v2@@ * ( double ) @@v0@@ ; return @@result@@ ; }
void * malloc ( size_t @@size@@ ) { return __imp_malloc ( @@size@@ ) ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 __fastcall dir_len ( _BYTE * @@a1@@ ) { unsigned __int64 @@v1@@ ; _BYTE * @@v2@@ ; __int64 @@v3@@ ; @@v1@@ = * @@a1@@ == Number ; @@v2@@ = last_component ( @@a1@@ ) ; if ( @@v2@@ - @@a1@@ <= @@v1@@ ) return @@v2@@ - @@a1@@ ; @@v3@@ = @@v2@@ - @@a1@@ - Number ; if ( * ( @@v2@@ - Number ) != Number ) return @@v2@@ - @@a1@@ ; while ( @@v1@@ != @@v3@@ && @@a1@@ [ @@v3@@ - Number ] == Number ) -- @@v3@@ ; return @@v3@@ ; }
bool __fastcall dev_ino_compare ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@result@@ ; @@result@@ = Number ; if ( * @@a1@@ == * @@a2@@ ) @@result@@ = @@a1@@ [ Number ] == @@a2@@ [ Number ] ; return @@result@@ ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
int __fastcall strcmp_name ( const char * * @@a1@@ , const char * * @@a2@@ ) { return strcmp ( * @@a1@@ , * @@a2@@ ) ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 __fastcall check_tuning_isra_0 ( float * * @@a1@@ ) { float * @@v1@@ ; __int64 @@result@@ ; float @@v3@@ ; float @@v4@@ ; float @@v5@@ ; @@v1@@ = * @@a1@@ ; @@result@@ = Number L ; if ( * @@a1@@ != ( float * ) & default_tuning ) { @@v3@@ = @@v1@@ [ Number ] ; if ( @@v3@@ <= Number || @@v3@@ >= Number || @@v1@@ [ Number ] <= Number || * @@v1@@ < Number || ( @@v4@@ = * @@v1@@ + Number , @@v5@@ = @@v1@@ [ Number ] , @@v5@@ <= @@v4@@ ) || @@v5@@ > Number || @@v3@@ <= @@v4@@ ) { * @@a1@@ = ( float * ) & default_tuning ; @@result@@ = Number L ; } } return @@result@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
int __fastcall rev_strcmp_name ( const char * * @@a1@@ , const char * * @@a2@@ ) { return strcmp ( * @@a2@@ , * @@a1@@ ) ; }
__int64 __fastcall nstrftime ( char * @@a1@@ , __int64 @@a2@@ , char * @@a3@@ , const __m128i * @@a4@@ , unsigned int @@a5@@ , unsigned int @@a6@@ ) { return strftime_case_ ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
bool __fastcall hash_table_ok ( __int64 @@a1@@ ) { _QWORD * @@v1@@ ; unsigned __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; bool @@result@@ ; @@v1@@ = * ( _QWORD * * ) @@a1@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v3@@ = Number L ; @@v4@@ = Number L ; if ( * ( _QWORD * ) @@a1@@ < @@v2@@ ) { do { if ( * @@v1@@ ) { @@v5@@ = @@v1@@ [ Number ] ; ++ @@v4@@ ; ++ @@v3@@ ; for ( ; @@v5@@ ; ++ @@v3@@ ) @@v5@@ = * ( _QWORD * ) ( @@v5@@ + Number ) ; } @@v1@@ += Number ; } while ( ( unsigned __int64 ) @@v1@@ < @@v2@@ ) ; } @@result@@ = Number ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) == @@v4@@ ) @@result@@ = * ( _QWORD * ) ( @@a1@@ + Number ) == @@v3@@ ; return @@result@@ ; }
int fgetc ( FILE * @@stream@@ ) { return fgetc ( @@stream@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
int __fastcall xstrcoll_size ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; bool @@v3@@ ; int @@result@@ ; @@v2@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@v3@@ = * ( _QWORD * ) ( @@a1@@ + Number ) < @@v2@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) > @@v2@@ ) return Number ; @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = xstrcoll ( * ( char * * ) @@a1@@ , * ( char * * ) @@a2@@ ) ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
int fileno ( FILE * @@stream@@ ) { return fileno ( @@stream@@ ) ; }
__int64 __fastcall hash_get_next ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; __int64 * @@v6@@ ; _QWORD * @@v7@@ ; __int64 @@v8@@ ; __int64 @@result@@ ; @@v2@@ = * @@a1@@ ; @@v4@@ = ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) ; @@v5@@ = @@a1@@ [ Number ] ; @@v6@@ = ( __int64 * ) ( @@v2@@ + Number * @@v4@@ ) ; if ( @@v5@@ <= ( unsigned __int64 ) @@v6@@ ) abort ( ) ; if ( ! @@v6@@ ) goto LABEL_10 ; @@v7@@ = ( _QWORD * ) @@v6@@ [ Number ] ; if ( * @@v6@@ != @@a2@@ ) { do { if ( ! @@v7@@ ) goto LABEL_10 ; @@v8@@ = * @@v7@@ ; @@v7@@ = ( _QWORD * ) @@v7@@ [ Number ] ; } while ( @@v8@@ != @@a2@@ ) ; } if ( @@v7@@ ) return * @@v7@@ ; LABEL_10 : while ( Number ) { @@v6@@ += Number ; if ( @@v5@@ <= ( unsigned __int64 ) @@v6@@ ) break ; @@result@@ = * @@v6@@ ; if ( * @@v6@@ ) return @@result@@ ; } return Number L ; }
void __fastcall __noreturn xstrtol_fatal ( unsigned int @@a1@@ , int @@a2@@ , char @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ ) { int @@v7@@ ; const char * @@v8@@ ; char * @@v9@@ ; char * @@v10@@ ; char * @@v11@@ ; char @@v12@@ [ Number ] ; unsigned __int64 @@v13@@ ; @@v13@@ = __readfsqword ( Number ) ; @@v7@@ = exit_failure ; if ( @@a1@@ > Number ) { @@v8@@ = String ; if ( @@a1@@ != Number ) goto LABEL_7 ; } else if ( @@a1@@ >= Number ) { @@v8@@ = String ; } else { @@v8@@ = String ; if ( @@a1@@ != Number ) goto LABEL_7 ; } if ( @@a2@@ < Number ) { @@v12@@ [ Number ] = @@a3@@ ; @@v12@@ [ Number ] = Number ; @@v10@@ = @@v12@@ ; @@v9@@ = & asc_15700 [ - @@a2@@ ] ; } else { @@v9@@ = String ; @@v10@@ = * ( char * * ) ( @@a4@@ + Number L * @@a2@@ ) ; } @@v11@@ = dcgettext ( Number L , @@v8@@ , Number ) ; error ( @@v7@@ , Number , @@v11@@ , @@v9@@ , @@v10@@ , @@a5@@ ) ; LABEL_7 : abort ( ) ; }
int __fastcall indent ( unsigned __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; unsigned __int64 @@v6@@ ; char * @@v7@@ ; char * @@v8@@ ; if ( @@a1@@ < @@a2@@ ) { @@v3@@ = @@a1@@ ; do { while ( Number ) { @@v5@@ = tabsize ; @@v6@@ = @@v3@@ + Number ; @@v7@@ = stdout -> _IO_write_ptr ; @@v8@@ = stdout -> _IO_write_end ; if ( ! tabsize || @@a2@@ / tabsize <= @@v6@@ / tabsize ) break ; if ( @@v7@@ >= @@v8@@ ) { __overflow ( stdout , Number ) ; @@v5@@ = tabsize ; } else { stdout -> _IO_write_ptr = @@v7@@ + Number ; * @@v7@@ = Number ; } @@v4@@ = @@v3@@ / @@v5@@ ; @@v3@@ = @@v3@@ + @@v5@@ - @@v3@@ % @@v5@@ ; if ( @@v3@@ >= @@a2@@ ) return @@v4@@ ; } if ( @@v7@@ >= @@v8@@ ) { LODWORD ( @@v4@@ ) = __overflow ( stdout , Number ) ; } else { LODWORD ( @@v4@@ ) = ( _DWORD ) @@v7@@ + Number ; stdout -> _IO_write_ptr = @@v7@@ + Number ; * @@v7@@ = Number ; } ++ @@v3@@ ; } while ( @@v6@@ < @@a2@@ ) ; } return @@v4@@ ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
int wcwidth ( wchar_t @@c@@ ) { return wcwidth ( @@c@@ ) ; }
__int64 __fastcall hash_reset_tuning ( __int64 @@a1@@ ) { __int64 @@result@@ ; * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; * ( _QWORD * ) @@a1@@ = Number ; @@result@@ = Number ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number ; return @@result@@ ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
int __fxstat ( int @@ver@@ , int @@fildes@@ , struct stat * @@stat_buf@@ ) { return _fxstat ( @@ver@@ , @@fildes@@ , @@stat_buf@@ ) ; }
__int64 __fastcall umaxtostr ( unsigned __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; @@v2@@ = @@a2@@ + Number ; * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; do { * ( _BYTE * ) -- @@v2@@ = @@a1@@ % Number + Number ; @@a1@@ /= Number ; } while ( @@a1@@ ) ; return @@v2@@ ; }
int __fastcall strcmp_df_size ( __int64 @@a1@@ , __int64 @@a2@@ ) { bool @@v2@@ ; bool @@v3@@ ; int @@result@@ ; __int64 @@v5@@ ; @@v2@@ = * ( _DWORD * ) ( @@a1@@ + Number ) == Number || * ( _DWORD * ) ( @@a1@@ + Number ) == Number ; @@v3@@ = * ( _DWORD * ) ( @@a2@@ + Number ) == Number || * ( _DWORD * ) ( @@a2@@ + Number ) == Number ; if ( ! @@v3@@ && @@v2@@ ) goto LABEL_9 ; if ( @@v2@@ || ( @@result@@ = Number , ! @@v3@@ ) ) { @@v5@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= @@v5@@ ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) < @@v5@@ ) @@result@@ = Number ; else @@result@@ = strcmp ( * ( const char * * ) @@a1@@ , * ( const char * * ) @@a2@@ ) ; return @@result@@ ; } LABEL_9 : @@result@@ = Number ; } return @@result@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
void free ( void * @@ptr@@ ) { __imp_free ( @@ptr@@ ) ; }
void __fastcall hash_free ( void * @@ptr@@ ) { _QWORD * @@v2@@ ; unsigned __int64 @@v3@@ ; _QWORD * @@v4@@ ; _QWORD * @@v5@@ ; _QWORD * @@v6@@ ; _QWORD * @@v7@@ ; _QWORD * @@v8@@ ; @@v2@@ = * ( _QWORD * * ) @@ptr@@ ; @@v3@@ = * ( ( _QWORD * ) @@ptr@@ + Number ) ; if ( * ( ( _QWORD * ) @@ptr@@ + Number ) && * ( ( _QWORD * ) @@ptr@@ + Number ) ) { if ( ( unsigned __int64 ) @@v2@@ >= @@v3@@ ) goto LABEL_14 ; do { if ( * @@v2@@ ) { @@v4@@ = @@v2@@ ; do { ( * ( ( void ( * * ) ( void ) ) @@ptr@@ + Number ) ) ( ) ; @@v4@@ = ( _QWORD * ) @@v4@@ [ Number ] ; } while ( @@v4@@ ) ; @@v3@@ = * ( ( _QWORD * ) @@ptr@@ + Number ) ; } @@v2@@ += Number ; } while ( @@v3@@ > ( unsigned __int64 ) @@v2@@ ) ; @@v2@@ = * ( _QWORD * * ) @@ptr@@ ; } if ( ( unsigned __int64 ) @@v2@@ < @@v3@@ ) { do { @@v5@@ = ( _QWORD * ) @@v2@@ [ Number ] ; if ( @@v5@@ ) { do { @@v6@@ = ( _QWORD * ) @@v5@@ [ Number ] ; free ( @@v5@@ ) ; @@v5@@ = @@v6@@ ; } while ( @@v6@@ ) ; } @@v2@@ += Number ; } while ( * ( ( _QWORD * ) @@ptr@@ + Number ) > ( unsigned __int64 ) @@v2@@ ) ; } LABEL_14 : @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@ptr@@ + Number ) ; if ( @@v7@@ ) { do { @@v8@@ = ( _QWORD * ) @@v7@@ [ Number ] ; free ( @@v7@@ ) ; @@v7@@ = @@v8@@ ; } while ( @@v8@@ ) ; } free ( * ( void * * ) @@ptr@@ ) ; free ( @@ptr@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
int __fastcall rev_strcmp_df_size ( __int64 @@a1@@ , __int64 @@a2@@ ) { bool @@v2@@ ; bool @@v3@@ ; int @@result@@ ; __int64 @@v5@@ ; @@v2@@ = * ( _DWORD * ) ( @@a1@@ + Number ) == Number || * ( _DWORD * ) ( @@a1@@ + Number ) == Number ; @@v3@@ = * ( _DWORD * ) ( @@a2@@ + Number ) == Number || * ( _DWORD * ) ( @@a2@@ + Number ) == Number ; if ( ! @@v3@@ && @@v2@@ ) goto LABEL_9 ; if ( @@v2@@ || ( @@result@@ = Number , ! @@v3@@ ) ) { @@v5@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) <= @@v5@@ ) { if ( * ( _QWORD * ) ( @@a2@@ + Number ) < @@v5@@ ) @@result@@ = Number ; else @@result@@ = strcmp ( * ( const char * * ) @@a2@@ , * ( const char * * ) @@a1@@ ) ; return @@result@@ ; } LABEL_9 : @@result@@ = Number ; } return @@result@@ ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; char * @@v11@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String String String String String String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v9@@ = stdout ; @@v10@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; @@v11@@ = setlocale ( Number , Number L ) ; if ( @@v11@@ ) { if ( strncmp ( @@v11@@ , String , Number ) ) { last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 __fastcall get_type_indicator ( char @@a1@@ , __int16 @@a2@@ , int @@a3@@ ) { int @@v3@@ ; __int64 @@result@@ ; bool @@v5@@ ; int @@v6@@ ; if ( @@a1@@ ) { @@v3@@ = @@a2@@ & Number ; if ( @@v3@@ == Number ) { @@result@@ = Number L ; if ( indicator_style == Number ) @@result@@ = ( @@a2@@ & Number ) != Number ? Number : Number ; return @@result@@ ; } @@v5@@ = @@v3@@ == Number ; } else { @@result@@ = Number L ; if ( @@a3@@ == Number ) return @@result@@ ; @@v5@@ = @@a3@@ == Number || @@a3@@ == Number ; } @@result@@ = Number L ; if ( ! @@v5@@ ) { @@result@@ = Number L ; if ( indicator_style != Number ) { if ( @@a1@@ ) { @@v6@@ = @@a2@@ & Number ; @@result@@ = Number L ; if ( @@v6@@ != Number ) { @@result@@ = Number L ; if ( @@v6@@ != Number ) { LOBYTE ( @@result@@ ) = @@v6@@ == Number ; return - ( int ) @@result@@ & Number ; } } } else { @@result@@ = Number L ; if ( @@a3@@ != Number ) { @@result@@ = Number L ; if ( @@a3@@ != Number ) { LOBYTE ( @@result@@ ) = @@a3@@ == Number ; return - ( int ) @@result@@ & Number ; } } } } } return @@result@@ ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
int dirfd ( DIR * @@dirp@@ ) { return dirfd ( @@dirp@@ ) ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
int __fastcall rev_strcmp_df_atime ( __int64 @@a1@@ , __int64 @@a2@@ ) { bool @@v2@@ ; bool @@v3@@ ; int @@result@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; @@v2@@ = * ( _DWORD * ) ( @@a1@@ + Number ) == Number || * ( _DWORD * ) ( @@a1@@ + Number ) == Number ; @@v3@@ = * ( _DWORD * ) ( @@a2@@ + Number ) == Number || * ( _DWORD * ) ( @@a2@@ + Number ) == Number ; if ( ! @@v3@@ && @@v2@@ ) return Number ; if ( @@v2@@ || ( @@result@@ = Number , ! @@v3@@ ) ) { @@v5@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) <= @@v5@@ ) { if ( * ( _QWORD * ) ( @@a2@@ + Number ) < @@v5@@ ) return Number ; @@v6@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) <= @@v6@@ ) { if ( * ( _QWORD * ) ( @@a2@@ + Number ) >= @@v6@@ ) return strcmp ( * ( const char * * ) @@a2@@ , * ( const char * * ) @@a1@@ ) ; return Number ; } } return Number ; } return @@result@@ ; }
struct group * getgrnam ( const char * @@name@@ ) { return getgrnam ( @@name@@ ) ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_20E250 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20E230 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_20E240 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
int wcwidth ( wchar_t @@c@@ ) { return wcwidth ( @@c@@ ) ; }
int __fastcall xstrcoll_ctime ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; @@v2@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= @@v2@@ ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) < @@v2@@ ) return Number ; @@v3@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= @@v3@@ ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) >= @@v3@@ ) return xstrcoll ( * ( char * * ) @@a1@@ , * ( char * * ) @@a2@@ ) ; return Number ; } } return Number ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
ssize_t __fastcall safe_read ( int @@fd@@ , void * @@buf@@ , size_t @@nbytes@@ ) { ssize_t @@v4@@ ; int @@v5@@ ; while ( Number ) { @@v4@@ = read ( @@fd@@ , @@buf@@ , @@nbytes@@ ) ; if ( @@v4@@ >= Number ) break ; @@v5@@ = * __errno_location ( ) ; if ( @@v5@@ != Number ) { if ( @@nbytes@@ <= Number || @@v5@@ != Number ) return @@v4@@ ; @@nbytes@@ = Number L ; } } return @@v4@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
int __fastcall strcmp_ctime ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; @@v2@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= @@v2@@ ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) < @@v2@@ ) return Number ; @@v3@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= @@v3@@ ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) >= @@v3@@ ) return strcmp ( * ( const char * * ) @@a1@@ , * ( const char * * ) @@a2@@ ) ; return Number ; } } return Number ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
unsigned __int64 __fastcall dev_ino_hash ( _QWORD * @@a1@@ , unsigned __int64 @@a2@@ ) { return * @@a1@@ % @@a2@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
bool __fastcall xstrtod ( __int64 @@a1@@ , _QWORD * @@a2@@ , double * @@a3@@ , void ( __fastcall * @@a4@@ ( ) ( constchar , char ) ) ( __int64 , __int64 * ) , double @@a5@@ ) { int * @@v7@@ ; bool @@result@@ ; __int64 @@v9@@ [ Number ] ; @@v9@@ [ Number ] = __readfsqword ( Number ) ; @@v7@@ = __errno_location ( ) ; * @@v7@@ = Number ; @@a4@@ ( ) ( constchar , char ) ( @@a1@@ , @@v9@@ ) ; if ( @@v9@@ [ Number ] == @@a1@@ ) { @@result@@ = Number ; } else { if ( @@a2@@ ) { @@result@@ = Number ; if ( @@a5@@ == Number ) { LABEL_6 : * @@a2@@ = @@v9@@ [ Number ] ; goto LABEL_7 ; } } else { @@result@@ = Number ; if ( * ( _BYTE * ) @@v9@@ [ Number ] ) goto LABEL_7 ; if ( @@a5@@ == Number ) { @@result@@ = Number ; goto LABEL_7 ; } } @@result@@ = * @@v7@@ != Number ; } if ( @@a2@@ ) goto LABEL_6 ; LABEL_7 : * @@a3@@ = @@a5@@ ; return @@result@@ ; }
int __fastcall rev_xstrcoll_df_atime ( __int64 @@a1@@ , __int64 @@a2@@ ) { bool @@v2@@ ; bool @@v3@@ ; int @@result@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; @@v2@@ = * ( _DWORD * ) ( @@a1@@ + Number ) == Number || * ( _DWORD * ) ( @@a1@@ + Number ) == Number ; @@v3@@ = * ( _DWORD * ) ( @@a2@@ + Number ) == Number || * ( _DWORD * ) ( @@a2@@ + Number ) == Number ; if ( ! @@v3@@ && @@v2@@ ) return Number ; if ( @@v2@@ || ( @@result@@ = Number , ! @@v3@@ ) ) { @@v5@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) <= @@v5@@ ) { if ( * ( _QWORD * ) ( @@a2@@ + Number ) < @@v5@@ ) return Number ; @@v6@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) <= @@v6@@ ) { if ( * ( _QWORD * ) ( @@a2@@ + Number ) >= @@v6@@ ) return xstrcoll ( * ( char * * ) @@a2@@ , * ( char * * ) @@a1@@ ) ; return Number ; } } return Number ; } return @@result@@ ; }
int _setjmp ( struct __jmp_buf_tag @@env@@ ( ( orgarrdim ( Number , Number ) ) ) [ Number ] ) { return setjmp ( @@env@@ ( ( orgarrdim ( Number , Number ) ) ) ) ; }
void dev_ino_free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
__pid_t tcgetpgrp ( int @@fd@@ ) { return tcgetpgrp ( @@fd@@ ) ; }
__off_t __fastcall xlseek ( int @@a1@@ , __off_t @@a2@@ , int @@a3@@ , __int64 @@a4@@ ) { __off_t @@result@@ ; __int64 @@v7@@ ; int * @@v8@@ ; const char * @@v9@@ ; char * @@v10@@ ; _QWORD @@v11@@ [ Number ] ; @@v11@@ [ Number ] = __readfsqword ( Number ) ; @@result@@ = lseek ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( @@result@@ < Number ) { @@v7@@ = offtostr ( @@a2@@ , @@v11@@ ) ; @@v8@@ = __errno_location ( ) ; @@v9@@ = String ; if ( @@a3@@ != Number ) { @@v9@@ = String ; if ( @@a3@@ == Number ) @@v9@@ = String ; } @@v10@@ = dcgettext ( Number L , @@v9@@ , Number ) ; error ( Number , * @@v8@@ , @@v10@@ , @@a4@@ , @@v7@@ ) ; exit ( Number ) ; } return @@result@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
int __fastcall rev_xstrcoll_extension ( const char * * @@a1@@ , const char * * @@a2@@ ) { char * @@v2@@ ; char * @@v3@@ ; int @@result@@ ; @@v2@@ = strrchr ( * @@a2@@ , Number ) ; @@v3@@ = strrchr ( * @@a1@@ , Number ) ; if ( ! @@v3@@ ) @@v3@@ = ( char * ) String ; if ( ! @@v2@@ ) @@v2@@ = ( char * ) String ; @@result@@ = xstrcoll ( @@v2@@ , @@v3@@ ) ; if ( ! @@result@@ ) @@result@@ = xstrcoll ( ( char * ) * @@a2@@ , ( char * ) * @@a1@@ ) ; return @@result@@ ; }
int __fxstat ( int @@ver@@ , int @@fildes@@ , struct stat * @@stat_buf@@ ) { return _fxstat ( @@ver@@ , @@fildes@@ , @@stat_buf@@ ) ; }
bool __fastcall is_colored ( unsigned int @@a1@@ ) { __int64 * @@v1@@ ; bool @@result@@ ; __int64 @@v3@@ ; _BYTE * @@v4@@ ; @@v1@@ = ( __int64 * ) ( ( char * ) & color_indicator + Number * @@a1@@ ) ; @@result@@ = Number ; @@v3@@ = * @@v1@@ ; if ( * @@v1@@ ) { @@v4@@ = ( _BYTE * ) @@v1@@ [ Number ] ; if ( @@v3@@ == Number ) { @@result@@ = * @@v4@@ != Number ; } else { @@result@@ = Number ; if ( @@v3@@ == Number ) @@result@@ = memcmp ( @@v4@@ , String , Number ) != Number ; } } return @@result@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
void free ( void * @@ptr@@ ) { __imp_free ( @@ptr@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
_BOOL8 __fastcall fremote ( int @@a1@@ , __int64 @@a2@@ ) { __int64 @@v3@@ ; char * @@v4@@ ; int * @@v5@@ ; struct statfs @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; if ( fstatfs ( @@a1@@ , & @@v6@@ ) ) { @@v3@@ = quote ( @@a2@@ , & @@v6@@ ) ; @@v4@@ = dcgettext ( Number L , String , Number ) ; @@v5@@ = __errno_location ( ) ; error ( Number , * @@v5@@ , @@v4@@ , @@v3@@ ) ; return Number L ; } if ( @@v6@@ . f_type == Number ) return Number L ; if ( @@v6@@ . f_type > Number ) { if ( @@v6@@ . f_type != Number ) { if ( @@v6@@ . f_type > Number ) return @@v6@@ . f_type == Number || @@v6@@ . f_type == Number L || @@v6@@ . f_type == Number ; if ( @@v6@@ . f_type != Number && @@v6@@ . f_type != Number ) return Number L ; } return Number L ; } if ( @@v6@@ . f_type == Number ) return Number L ; if ( @@v6@@ . f_type > Number ) return @@v6@@ . f_type == Number || @@v6@@ . f_type == Number || @@v6@@ . f_type == Number ; return @@v6@@ . f_type == Number || @@v6@@ . f_type == Number ; }
int __fastcall xstrcoll_name ( char * * @@a1@@ , char * * @@a2@@ ) { return xstrcoll ( * @@a1@@ , * @@a2@@ ) ; }
int __fastcall strcmp_df_mtime ( __int64 @@a1@@ , __int64 @@a2@@ ) { bool @@v2@@ ; bool @@v3@@ ; int @@result@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; @@v2@@ = * ( _DWORD * ) ( @@a1@@ + Number ) == Number || * ( _DWORD * ) ( @@a1@@ + Number ) == Number ; @@v3@@ = * ( _DWORD * ) ( @@a2@@ + Number ) == Number || * ( _DWORD * ) ( @@a2@@ + Number ) == Number ; if ( ! @@v3@@ && @@v2@@ ) return Number ; if ( @@v2@@ || ( @@result@@ = Number , ! @@v3@@ ) ) { @@v5@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= @@v5@@ ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) < @@v5@@ ) return Number ; @@v6@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= @@v6@@ ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) >= @@v6@@ ) return strcmp ( * ( const char * * ) @@a1@@ , * ( const char * * ) @@a2@@ ) ; return Number ; } } return Number ; } return @@result@@ ; }
__int64 __fastcall sighandler ( int @@a1@@ ) { __int64 @@result@@ ; @@result@@ = ( unsigned int ) interrupt_signal ; if ( ! interrupt_signal ) interrupt_signal = @@a1@@ ; return @@result@@ ; }
_BYTE * __fastcall find_int ( _BYTE * @@a1@@ ) { const unsigned __int16 * @@v1@@ ; _BYTE * @@result@@ ; __int64 @@v3@@ ; char * @@v4@@ ; unsigned __int8 * @@v5@@ ; int @@i@@ ; @@v1@@ = * __ctype_b_loc ( ) ; for ( @@result@@ = @@a1@@ ; ; ++ @@result@@ ) { @@v3@@ = ( unsigned __int8 ) * @@result@@ ; if ( ( @@v1@@ [ @@v3@@ ] & Number ) == Number ) break ; } if ( ( _BYTE ) @@v3@@ == Number ) @@v4@@ = ++ @@result@@ ; else @@v4@@ = & @@result@@ [ * @@result@@ == Number ] ; @@v5@@ = ( unsigned __int8 * ) ( @@v4@@ + Number ) ; if ( ( unsigned int ) ( * @@v4@@ - Number ) > Number ) goto LABEL_14 ; for ( @@i@@ = @@v4@@ [ Number ] ; ( unsigned int ) ( @@i@@ - Number ) <= Number ; @@i@@ = ( char ) * @@v5@@ ) { ++ @@v5@@ ; } if ( ( @@v1@@ [ ( unsigned __int8 ) @@i@@ ] & Number ) != Number ) { do LOBYTE ( @@i@@ ) = * ++ @@v5@@ ; while ( ( @@v1@@ [ * @@v5@@ ] & Number ) != Number ) ; } if ( ( _BYTE ) @@i@@ ) { LABEL_14 : quote ( @@a1@@ ) ; dcgettext ( Number L , String , Number ) ; test_syntax_error ( ) ; } return @@result@@ ; }
int __fastcall rev_xstrcoll_name ( char * * @@a1@@ , char * * @@a2@@ ) { return xstrcoll ( * @@a2@@ , * @@a1@@ ) ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
void * __fastcall queue_directory ( void * @@src@@ , void * @@a2@@ , char @@a3@@ ) { __int64 * @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; void * @@result@@ ; @@v4@@ = ( __int64 * ) xmalloc ( Number L ) ; @@v5@@ = Number L ; if ( @@a2@@ ) @@v5@@ = xstrdup ( @@a2@@ ) ; @@v4@@ [ Number ] = @@v5@@ ; @@v6@@ = Number L ; if ( @@src@@ ) @@v6@@ = xstrdup ( @@src@@ ) ; * @@v4@@ = @@v6@@ ; @@result@@ = pending_dirs ; * ( ( _BYTE * ) @@v4@@ + Number ) = @@a3@@ ; pending_dirs = @@v4@@ ; @@v4@@ [ Number ] = ( __int64 ) @@result@@ ; return @@result@@ ; }
int __fastcall rev_xstrcoll_df_extension ( __int64 @@a1@@ , __int64 @@a2@@ ) { bool @@v2@@ ; bool @@v3@@ ; int @@result@@ ; char * @@v5@@ ; char * @@v6@@ ; @@v2@@ = * ( _DWORD * ) ( @@a1@@ + Number ) == Number || * ( _DWORD * ) ( @@a1@@ + Number ) == Number ; @@v3@@ = * ( _DWORD * ) ( @@a2@@ + Number ) == Number || * ( _DWORD * ) ( @@a2@@ + Number ) == Number ; if ( ! @@v3@@ && @@v2@@ ) return Number ; if ( @@v2@@ || ( @@result@@ = Number , ! @@v3@@ ) ) { @@v5@@ = strrchr ( * ( const char * * ) @@a2@@ , Number ) ; @@v6@@ = strrchr ( * ( const char * * ) @@a1@@ , Number ) ; if ( ! @@v6@@ ) @@v6@@ = ( char * ) String ; if ( ! @@v5@@ ) @@v5@@ = ( char * ) String ; @@result@@ = xstrcoll ( @@v5@@ , @@v6@@ ) ; if ( ! @@result@@ ) @@result@@ = xstrcoll ( * ( char * * ) @@a2@@ , * ( char * * ) @@a1@@ ) ; } return @@result@@ ; }
__int64 __fastcall rev_xstrcoll_version ( char * * @@a1@@ , char * * @@a2@@ ) { return filevercmp ( * @@a2@@ , * @@a1@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
__int64 __fastcall argmatch ( const char * @@a1@@ , const char * * @@a2@@ , char * @@a3@@ , size_t @@a4@@ ) { char * @@v5@@ ; size_t @@v6@@ ; const char * @@v7@@ ; size_t @@v8@@ ; __int64 @@v9@@ ; bool @@v10@@ ; char @@v11@@ ; __int64 @@v12@@ ; __int64 @@v14@@ ; char @@v15@@ ; @@v5@@ = @@a3@@ ; @@v6@@ = strlen ( @@a1@@ ) ; @@v7@@ = * @@a2@@ ; @@v14@@ = Number ; if ( ! * @@a2@@ ) return @@v14@@ ; @@v8@@ = @@v6@@ ; @@v15@@ = Number ; @@v9@@ = Number L ; do { while ( strncmp ( @@v7@@ , @@a1@@ , @@v8@@ ) ) { LABEL_7 : ++ @@v9@@ ; @@v5@@ += @@a4@@ ; @@v7@@ = @@a2@@ [ @@v9@@ ] ; if ( ! @@v7@@ ) goto LABEL_12 ; } if ( strlen ( @@v7@@ ) == @@v8@@ ) return @@v9@@ ; if ( @@v14@@ != Number ) { if ( @@a3@@ ) { @@v10@@ = memcmp ( & @@a3@@ [ @@a4@@ * @@v14@@ ] , @@v5@@ , @@a4@@ ) == Number ; @@v11@@ = @@v15@@ ; if ( ! @@v10@@ ) @@v11@@ = Number ; @@v15@@ = @@v11@@ ; } else { @@v15@@ = Number ; } goto LABEL_7 ; } @@v14@@ = @@v9@@ ++ ; @@v5@@ += @@a4@@ ; @@v7@@ = @@a2@@ [ @@v9@@ ] ; } while ( @@v7@@ ) ; LABEL_12 : @@v12@@ = Number ; if ( ! @@v15@@ ) @@v12@@ = @@v14@@ ; return @@v12@@ ; }
void __fastcall dired_dump_obstack ( const char * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; char * @@v10@@ ; @@v2@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@v3@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@v4@@ = ( unsigned int ) ( @@v2@@ - @@v3@@ ) >> Number ; if ( ( _DWORD ) @@v4@@ ) { if ( @@v2@@ == @@v3@@ ) * ( _BYTE * ) ( @@a2@@ + Number ) |= Number ; @@v5@@ = @@v2@@ + * ( int * ) ( @@a2@@ + Number ) ; @@v6@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@v7@@ = ~ * ( _DWORD * ) ( @@a2@@ + Number ) & @@v5@@ ; @@v8@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; * ( _QWORD * ) ( @@a2@@ + Number ) = @@v7@@ ; if ( ( __int64 ) ( @@v7@@ - @@v8@@ ) > @@v6@@ - @@v8@@ ) * ( _QWORD * ) ( @@a2@@ + Number ) = @@v6@@ ; @@v9@@ = @@v3@@ + Number * @@v4@@ ; * ( _QWORD * ) ( @@a2@@ + Number ) = * ( _QWORD * ) ( @@a2@@ + Number ) ; fputs_unlocked ( @@a1@@ , stdout ) ; do { @@v3@@ += Number L ; __printf_chk ( ) ; } while ( @@v3@@ != @@v9@@ ) ; @@v10@@ = stdout -> _IO_write_ptr ; if ( @@v10@@ >= stdout -> _IO_write_end ) { __overflow ( stdout , Number ) ; } else { stdout -> _IO_write_ptr = @@v10@@ + Number ; * @@v10@@ = Number ; } } }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
char * __fastcall match_suffix ( char * * @@a1@@ ) { char * @@v1@@ ; char @@v2@@ ; bool @@v3@@ ; char * @@result@@ ; @@v1@@ = * @@a1@@ ; @@v2@@ = * * @@a1@@ ; if ( @@v2@@ ) { @@v3@@ = Number ; @@result@@ = Number L ; while ( Number ) { if ( @@v3@@ ) { @@v3@@ = @@v2@@ != Number && ( @@v2@@ & Number ) - Number > Number ; if ( @@v3@@ ) { @@v3@@ = Number ; @@result@@ = Number L ; } goto LABEL_5 ; } if ( @@v2@@ == Number ) break ; if ( ( unsigned int ) ( @@v2@@ - Number ) <= Number ) { LABEL_5 : * @@a1@@ = ++ @@v1@@ ; @@v2@@ = * @@v1@@ ; if ( ! * @@v1@@ ) return @@result@@ ; } else { if ( @@v2@@ != Number && ( @@v2@@ & Number ) - Number > Number ) @@result@@ = Number L ; * @@a1@@ = ++ @@v1@@ ; @@v2@@ = * @@v1@@ ; if ( ! * @@v1@@ ) return @@result@@ ; } } @@v3@@ = Number ; if ( ! @@result@@ ) @@result@@ = @@v1@@ ; goto LABEL_5 ; } return Number L ; }
void __fastcall extract_dirs_from_files ( void * @@a1@@ , char @@a2@@ ) { __int64 @@v3@@ ; __int64 @@i@@ ; __int64 @@v5@@ ; int @@v6@@ ; void * @@v7@@ ; _BYTE * @@v8@@ ; void * @@v9@@ ; __int64 @@v10@@ ; _QWORD * @@v11@@ ; char * @@v12@@ ; char * @@v13@@ ; bool @@v14@@ ; char @@v15@@ ; if ( @@a1@@ && active_dir_set ) queue_directory ( Number L , @@a1@@ , Number ) ; @@v3@@ = cwd_n_used ; for ( @@i@@ = Number * cwd_n_used - Number ; -- @@v3@@ != Number ; @@i@@ -= Number L ) { @@v5@@ = * ( _QWORD * ) ( ( char * ) sorted_file + @@i@@ ) ; @@v6@@ = * ( _DWORD * ) ( @@v5@@ + Number ) ; if ( @@v6@@ == Number || @@v6@@ == Number ) { @@v7@@ = * ( void * * ) @@v5@@ ; if ( ! @@a1@@ ) goto LABEL_15 ; @@v8@@ = ( _BYTE * ) last_component ( @@v7@@ ) ; if ( * @@v8@@ != Number || ( @@v15@@ = @@v8@@ [ ( @@v8@@ [ Number ] == Number ) + Number ] ) != Number && @@v15@@ != Number ) { @@v7@@ = * ( void * * ) @@v5@@ ; if ( * * ( _BYTE * * ) @@v5@@ == Number ) { LABEL_15 : queue_directory ( @@v7@@ , * ( void * * ) ( @@v5@@ + Number ) , @@a2@@ ) ; } else { @@v9@@ = ( void * ) file_name_concat ( @@a1@@ , * ( _QWORD * ) @@v5@@ , Number L ) ; queue_directory ( @@v9@@ , * ( void * * ) ( @@v5@@ + Number ) , @@a2@@ ) ; free ( @@v9@@ ) ; } if ( * ( _DWORD * ) ( @@v5@@ + Number ) == Number ) free ( * ( void * * ) @@v5@@ ) ; continue ; } } } @@v10@@ = cwd_n_used ; if ( cwd_n_used ) { @@v11@@ = sorted_file ; @@v12@@ = ( char * ) sorted_file + Number * cwd_n_used ; @@v13@@ = ( char * ) sorted_file ; @@v10@@ = Number L ; do { @@v14@@ = * ( _DWORD * ) ( * ( _QWORD * ) @@v13@@ + Number L ) == Number ; @@v11@@ [ @@v10@@ ] = * ( _QWORD * ) @@v13@@ ; @@v13@@ += Number ; @@v10@@ += ! @@v14@@ ; } while ( @@v12@@ != @@v13@@ ) ; } cwd_n_used = @@v10@@ ; }
unsigned __int64 __fastcall next_prime ( unsigned __int64 @@a1@@ ) { unsigned __int64 @@v1@@ ; unsigned __int64 @@v2@@ ; __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; if ( @@a1@@ < Number ) @@a1@@ = Number L ; @@v1@@ = @@a1@@ | Number ; if ( @@v1@@ != Number ) { while ( Number ) { @@v2@@ = @@v1@@ % Number ; if ( @@v1@@ <= Number ) goto LABEL_9 ; if ( @@v1@@ % Number ) break ; LABEL_10 : @@v1@@ += Number L ; if ( @@v1@@ == Number ) return @@v1@@ ; } @@v3@@ = Number L ; @@v4@@ = Number L ; @@v5@@ = Number L ; while ( Number ) { @@v5@@ += Number L ; @@v4@@ += @@v3@@ ; @@v2@@ = @@v1@@ % @@v5@@ ; if ( @@v4@@ >= @@v1@@ ) break ; @@v3@@ += Number L ; if ( ! ( @@v1@@ % @@v5@@ ) ) goto LABEL_10 ; } LABEL_9 : if ( @@v2@@ ) return @@v1@@ ; goto LABEL_10 ; } return @@v1@@ ; }
int __fastcall xstrcoll_df_name ( __int64 @@a1@@ , __int64 @@a2@@ ) { bool @@v2@@ ; bool @@v3@@ ; int @@result@@ ; @@v2@@ = * ( _DWORD * ) ( @@a1@@ + Number ) == Number || * ( _DWORD * ) ( @@a1@@ + Number ) == Number ; @@v3@@ = * ( _DWORD * ) ( @@a2@@ + Number ) == Number || * ( _DWORD * ) ( @@a2@@ + Number ) == Number ; if ( ! @@v3@@ && @@v2@@ ) return Number ; if ( @@v2@@ || ( @@result@@ = Number , ! @@v3@@ ) ) @@result@@ = xstrcoll ( * ( char * * ) @@a1@@ , * ( char * * ) @@a2@@ ) ; return @@result@@ ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
int __fastcall rev_strcmp_df_name ( __int64 @@a1@@ , __int64 @@a2@@ ) { bool @@v2@@ ; bool @@v3@@ ; int @@result@@ ; @@v2@@ = * ( _DWORD * ) ( @@a1@@ + Number ) == Number || * ( _DWORD * ) ( @@a1@@ + Number ) == Number ; @@v3@@ = * ( _DWORD * ) ( @@a2@@ + Number ) == Number || * ( _DWORD * ) ( @@a2@@ + Number ) == Number ; if ( ! @@v3@@ && @@v2@@ ) return Number ; if ( @@v2@@ || ( @@result@@ = Number , ! @@v3@@ ) ) @@result@@ = strcmp ( * ( const char * * ) @@a2@@ , * ( const char * * ) @@a1@@ ) ; return @@result@@ ; }
__int64 __fastcall hash_lookup ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; _QWORD * @@v4@@ ; __int64 @@v5@@ ; @@v2@@ = * @@a1@@ ; @@v4@@ = ( _QWORD * ) ( Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) + @@v2@@ ) ; if ( @@a1@@ [ Number ] <= ( unsigned __int64 ) @@v4@@ ) abort ( ) ; @@v5@@ = * @@v4@@ ; if ( ! * @@v4@@ ) return Number L ; while ( @@v5@@ != @@a2@@ ) { if ( ( ( unsigned __int8 ( __fastcall * ) ( __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ ) ) return * @@v4@@ ; @@v4@@ = ( _QWORD * ) @@v4@@ [ Number ] ; if ( ! @@v4@@ ) return Number L ; @@v5@@ = * @@v4@@ ; } return @@v5@@ ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
int __fastcall rev_strcmp_df_extension ( __int64 @@a1@@ , __int64 @@a2@@ ) { bool @@v2@@ ; bool @@v3@@ ; int @@result@@ ; const char * @@v5@@ ; char * @@v6@@ ; const char * @@v7@@ ; const char * @@v8@@ ; char * @@v9@@ ; @@v2@@ = * ( _DWORD * ) ( @@a1@@ + Number ) == Number || * ( _DWORD * ) ( @@a1@@ + Number ) == Number ; @@v3@@ = * ( _DWORD * ) ( @@a2@@ + Number ) == Number || * ( _DWORD * ) ( @@a2@@ + Number ) == Number ; if ( ! @@v3@@ && @@v2@@ ) return Number ; if ( @@v2@@ || ( @@result@@ = Number , ! @@v3@@ ) ) { @@v5@@ = * ( const char * * ) @@a2@@ ; @@v6@@ = strrchr ( * ( const char * * ) @@a2@@ , Number ) ; @@v7@@ = * ( const char * * ) @@a1@@ ; @@v8@@ = @@v6@@ ; @@v9@@ = strrchr ( * ( const char * * ) @@a1@@ , Number ) ; if ( @@v9@@ ) { if ( ! @@v8@@ ) @@v8@@ = String ; } else { @@v9@@ = ( char * ) String ; if ( ! @@v8@@ ) return strcmp ( @@v5@@ , @@v7@@ ) ; } @@result@@ = strcmp ( @@v8@@ , @@v9@@ ) ; if ( ! @@result@@ ) return strcmp ( @@v5@@ , @@v7@@ ) ; } return @@result@@ ; }
__int64 __fastcall rev_xstrcoll_df_version ( __int64 @@a1@@ , __int64 @@a2@@ ) { bool @@v2@@ ; bool @@v3@@ ; __int64 @@result@@ ; @@v2@@ = * ( _DWORD * ) ( @@a1@@ + Number ) == Number || * ( _DWORD * ) ( @@a1@@ + Number ) == Number ; @@v3@@ = * ( _DWORD * ) ( @@a2@@ + Number ) == Number || * ( _DWORD * ) ( @@a2@@ + Number ) == Number ; if ( ! @@v3@@ && @@v2@@ ) return Number ; if ( @@v2@@ || ( @@result@@ = Number L , ! @@v3@@ ) ) @@result@@ = filevercmp ( * ( char * * ) @@a2@@ , * ( char * * ) @@a1@@ ) ; return @@result@@ ; }
unsigned __int64 __fastcall hash_string ( unsigned __int8 * @@a1@@ , unsigned __int64 @@a2@@ ) { __int64 @@v2@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@v4@@ ; @@v2@@ = * @@a1@@ ; for ( @@i@@ = Number L ; ( _BYTE ) @@v2@@ ; @@i@@ = @@v4@@ % @@a2@@ ) { ++ @@a1@@ ; @@v4@@ = @@v2@@ + Number * @@i@@ ; @@v2@@ = * @@a1@@ ; } return @@i@@ ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
void __fastcall argmatch_invalid ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { char * @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; if ( @@a3@@ == Number ) @@v3@@ = dcgettext ( Number L , String , Number ) ; else @@v3@@ = dcgettext ( Number L , String , Number ) ; @@v4@@ = quote_n ( Number L , @@a1@@ ) ; @@v5@@ = quotearg_n_style ( Number L , Number L , @@a2@@ ) ; error ( Number , Number , @@v3@@ , @@v5@@ , @@v4@@ ) ; }
size_t __fastcall print_file_name_and_frills ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { __int64 @@v3@@ ; size_t @@v4@@ ; _QWORD @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; if ( print_inode ) { if ( * ( _BYTE * ) ( @@a1@@ + Number ) ) { @@v3@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( @@v3@@ ) umaxtostr ( @@v3@@ , @@v6@@ ) ; } __printf_chk ( ) ; } if ( print_block_size ) { if ( * ( _BYTE * ) ( @@a1@@ + Number ) ) human_readable ( * ( _QWORD * ) ( @@a1@@ + Number ) , @@v6@@ , ( unsigned int ) human_output_opts , Number L , output_block_size ) ; __printf_chk ( ) ; } if ( print_scontext ) __printf_chk ( ) ; @@v4@@ = print_name_with_quoting ( @@a1@@ , Number L , Number L , @@a2@@ ) ; if ( indicator_style ) @@v4@@ += print_type_indicator ( * ( _BYTE * ) ( @@a1@@ + Number ) , * ( _DWORD * ) ( @@a1@@ + Number ) , * ( _DWORD * ) ( @@a1@@ + Number ) ) ; return @@v4@@ ; }
__int64 format_user_width ( ) { int * @@v0@@ ; int @@v1@@ ; unsigned int @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; if ( numeric_ids || ( @@v4@@ = ( char * ) getuser ( ) ) == Number L ) { __sprintf_chk ( ) ; @@v0@@ = ( int * ) @@v5@@ ; do { @@v1@@ = * @@v0@@ ++ ; @@v2@@ = ~ @@v1@@ & ( @@v1@@ - Number ) & Number ; } while ( ! @@v2@@ ) ; if ( ( ~ @@v1@@ & ( @@v1@@ - Number ) & Number ) == Number ) LOBYTE ( @@v2@@ ) = ( ~ @@v1@@ & ( @@v1@@ - Number ) & Number ) >> Number ; if ( ( ~ @@v1@@ & ( @@v1@@ - Number ) & Number ) == Number ) LODWORD ( @@v0@@ ) = ( _DWORD ) @@v0@@ + Number ; @@result@@ = ( _DWORD ) @@v0@@ - ( __CFADD__ ( ( _BYTE ) @@v2@@ , ( _BYTE ) @@v2@@ ) + Number ) - ( unsigned int ) @@v5@@ ; } else { @@result@@ = gnu_mbswidth ( @@v4@@ ) ; if ( ( int ) @@result@@ < Number ) @@result@@ = Number L ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
void __fastcall hash_clear ( _QWORD * @@a1@@ ) { _QWORD * @@v1@@ ; _QWORD * @@v2@@ ; void ( __fastcall * @@v3@@ ) ( _QWORD ) ; _QWORD * @@v4@@ ; __int64 @@v5@@ ; @@v1@@ = ( _QWORD * ) * @@a1@@ ; if ( * @@a1@@ < @@a1@@ [ Number ] ) { do { if ( * @@v1@@ ) { @@v2@@ = ( _QWORD * ) @@v1@@ [ Number ] ; @@v3@@ = ( void ( __fastcall * ) ( _QWORD ) ) @@a1@@ [ Number ] ; if ( @@v2@@ ) { do { if ( @@v3@@ ) { @@v3@@ ( * @@v2@@ ) ; @@v3@@ = ( void ( __fastcall * ) ( _QWORD ) ) @@a1@@ [ Number ] ; } @@v4@@ = ( _QWORD * ) @@v2@@ [ Number ] ; @@v5@@ = @@a1@@ [ Number ] ; * @@v2@@ = Number L ; @@v2@@ [ Number ] = @@v5@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v2@@ = @@v4@@ ; } while ( @@v4@@ ) ; } if ( @@v3@@ ) @@v3@@ ( * @@v1@@ ) ; * @@v1@@ = Number L ; @@v1@@ [ Number ] = Number L ; } @@v1@@ += Number ; } while ( @@a1@@ [ Number ] > ( unsigned __int64 ) @@v1@@ ) ; } @@a1@@ [ Number ] = Number L ; @@a1@@ [ Number ] = Number L ; }
int __fastcall rev_strcmp_df_ctime ( __int64 @@a1@@ , __int64 @@a2@@ ) { bool @@v2@@ ; bool @@v3@@ ; int @@result@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; @@v2@@ = * ( _DWORD * ) ( @@a1@@ + Number ) == Number || * ( _DWORD * ) ( @@a1@@ + Number ) == Number ; @@v3@@ = * ( _DWORD * ) ( @@a2@@ + Number ) == Number || * ( _DWORD * ) ( @@a2@@ + Number ) == Number ; if ( ! @@v3@@ && @@v2@@ ) return Number ; if ( @@v2@@ || ( @@result@@ = Number , ! @@v3@@ ) ) { @@v5@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) <= @@v5@@ ) { if ( * ( _QWORD * ) ( @@a2@@ + Number ) < @@v5@@ ) return Number ; @@v6@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) <= @@v6@@ ) { if ( * ( _QWORD * ) ( @@a2@@ + Number ) >= @@v6@@ ) return strcmp ( * ( const char * * ) @@a2@@ , * ( const char * * ) @@a1@@ ) ; return Number ; } } return Number ; } return @@result@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
int __fastcall strcmp_atime ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; @@v2@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= @@v2@@ ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) < @@v2@@ ) return Number ; @@v3@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= @@v3@@ ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) >= @@v3@@ ) return strcmp ( * ( const char * * ) @@a1@@ , * ( const char * * ) @@a2@@ ) ; return Number ; } } return Number ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
unsigned __int64 __fastcall next_prime ( unsigned __int64 @@a1@@ ) { unsigned __int64 @@v1@@ ; unsigned __int64 @@v2@@ ; __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; if ( @@a1@@ < Number ) @@a1@@ = Number L ; @@v1@@ = @@a1@@ | Number ; if ( @@v1@@ != Number ) { while ( Number ) { @@v2@@ = @@v1@@ % Number ; if ( @@v1@@ <= Number ) goto LABEL_9 ; if ( @@v1@@ % Number ) break ; LABEL_10 : @@v1@@ += Number L ; if ( @@v1@@ == Number ) return @@v1@@ ; } @@v3@@ = Number L ; @@v4@@ = Number L ; @@v5@@ = Number L ; while ( Number ) { @@v5@@ += Number L ; @@v4@@ += @@v3@@ ; @@v2@@ = @@v1@@ % @@v5@@ ; if ( @@v4@@ >= @@v1@@ ) break ; @@v3@@ += Number L ; if ( ! ( @@v1@@ % @@v5@@ ) ) goto LABEL_10 ; } LABEL_9 : if ( @@v2@@ ) return @@v1@@ ; goto LABEL_10 ; } return @@v1@@ ; }
int __fastcall rev_xstrcoll_atime ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) <= @@v2@@ ) { if ( * ( _QWORD * ) ( @@a2@@ + Number ) < @@v2@@ ) return Number ; @@v3@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) <= @@v3@@ ) { if ( * ( _QWORD * ) ( @@a2@@ + Number ) >= @@v3@@ ) return xstrcoll ( * ( char * * ) @@a2@@ , * ( char * * ) @@a1@@ ) ; return Number ; } } return Number ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
int __fastcall xstrcoll_df_atime ( __int64 @@a1@@ , __int64 @@a2@@ ) { bool @@v2@@ ; bool @@v3@@ ; int @@result@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; @@v2@@ = * ( _DWORD * ) ( @@a1@@ + Number ) == Number || * ( _DWORD * ) ( @@a1@@ + Number ) == Number ; @@v3@@ = * ( _DWORD * ) ( @@a2@@ + Number ) == Number || * ( _DWORD * ) ( @@a2@@ + Number ) == Number ; if ( ! @@v3@@ && @@v2@@ ) return Number ; if ( @@v2@@ || ( @@result@@ = Number , ! @@v3@@ ) ) { @@v5@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= @@v5@@ ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) < @@v5@@ ) return Number ; @@v6@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= @@v6@@ ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) >= @@v6@@ ) return xstrcoll ( * ( char * * ) @@a1@@ , * ( char * * ) @@a2@@ ) ; return Number ; } } return Number ; } return @@result@@ ; }
bool __fastcall hash_table_ok ( __int64 @@a1@@ ) { _QWORD * @@v1@@ ; unsigned __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; bool @@result@@ ; @@v1@@ = * ( _QWORD * * ) @@a1@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v3@@ = Number L ; @@v4@@ = Number L ; if ( * ( _QWORD * ) @@a1@@ < @@v2@@ ) { do { if ( * @@v1@@ ) { @@v5@@ = @@v1@@ [ Number ] ; ++ @@v4@@ ; ++ @@v3@@ ; for ( ; @@v5@@ ; ++ @@v3@@ ) @@v5@@ = * ( _QWORD * ) ( @@v5@@ + Number ) ; } @@v1@@ += Number ; } while ( ( unsigned __int64 ) @@v1@@ < @@v2@@ ) ; } @@result@@ = Number ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) == @@v4@@ ) @@result@@ = * ( _QWORD * ) ( @@a1@@ + Number ) == @@v3@@ ; return @@result@@ ; }
int __fastcall rev_strcmp_atime ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) <= @@v2@@ ) { if ( * ( _QWORD * ) ( @@a2@@ + Number ) < @@v2@@ ) return Number ; @@v3@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) <= @@v3@@ ) { if ( * ( _QWORD * ) ( @@a2@@ + Number ) >= @@v3@@ ) return strcmp ( * ( const char * * ) @@a2@@ , * ( const char * * ) @@a1@@ ) ; return Number ; } } return Number ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) _frame_dummy_init_array_entry [ @@i@@ ] ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
int __fastcall strcmp_df_ctime ( __int64 @@a1@@ , __int64 @@a2@@ ) { bool @@v2@@ ; bool @@v3@@ ; int @@result@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; @@v2@@ = * ( _DWORD * ) ( @@a1@@ + Number ) == Number || * ( _DWORD * ) ( @@a1@@ + Number ) == Number ; @@v3@@ = * ( _DWORD * ) ( @@a2@@ + Number ) == Number || * ( _DWORD * ) ( @@a2@@ + Number ) == Number ; if ( ! @@v3@@ && @@v2@@ ) return Number ; if ( @@v2@@ || ( @@result@@ = Number , ! @@v3@@ ) ) { @@v5@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= @@v5@@ ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) < @@v5@@ ) return Number ; @@v6@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= @@v6@@ ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) >= @@v6@@ ) return strcmp ( * ( const char * * ) @@a1@@ , * ( const char * * ) @@a2@@ ) ; return Number ; } } return Number ; } return @@result@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
unsigned __int64 __fastcall hash_get_entries ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { _QWORD * @@v3@@ ; unsigned __int64 @@v4@@ ; _QWORD * @@v5@@ ; unsigned __int64 @@result@@ ; @@v3@@ = * ( _QWORD * * ) @@a1@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= * ( _QWORD * ) @@a1@@ ) return Number L ; @@v4@@ = Number L ; while ( ! * @@v3@@ ) { LABEL_9 : @@v3@@ += Number ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= ( unsigned __int64 ) @@v3@@ ) return @@v4@@ ; } if ( @@a3@@ <= @@v4@@ ) return @@v4@@ ; * ( _QWORD * ) ( @@a2@@ + Number * @@v4@@ ) = * @@v3@@ ; @@v5@@ = ( _QWORD * ) @@v3@@ [ Number ] ; @@result@@ = @@v4@@ + Number ; if ( ! @@v5@@ ) { LABEL_8 : @@v4@@ = @@result@@ ; goto LABEL_9 ; } while ( @@a3@@ != @@result@@ ) { ++ @@result@@ ; * ( _QWORD * ) ( @@a2@@ + Number * @@result@@ - Number ) = * @@v5@@ ; @@v5@@ = ( _QWORD * ) @@v5@@ [ Number ] ; if ( ! @@v5@@ ) goto LABEL_8 ; } return @@result@@ ; }
int __fastcall strcmp_mtime ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; @@v2@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= @@v2@@ ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) < @@v2@@ ) return Number ; @@v3@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= @@v3@@ ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) >= @@v3@@ ) return strcmp ( * ( const char * * ) @@a1@@ , * ( const char * * ) @@a2@@ ) ; return Number ; } } return Number ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
void __fastcall hash_clear ( _QWORD * @@a1@@ ) { _QWORD * @@v1@@ ; _QWORD * @@v2@@ ; void ( __fastcall * @@v3@@ ) ( _QWORD ) ; _QWORD * @@v4@@ ; __int64 @@v5@@ ; @@v1@@ = ( _QWORD * ) * @@a1@@ ; if ( * @@a1@@ < @@a1@@ [ Number ] ) { do { if ( * @@v1@@ ) { @@v2@@ = ( _QWORD * ) @@v1@@ [ Number ] ; @@v3@@ = ( void ( __fastcall * ) ( _QWORD ) ) @@a1@@ [ Number ] ; if ( @@v2@@ ) { do { if ( @@v3@@ ) { @@v3@@ ( * @@v2@@ ) ; @@v3@@ = ( void ( __fastcall * ) ( _QWORD ) ) @@a1@@ [ Number ] ; } @@v4@@ = ( _QWORD * ) @@v2@@ [ Number ] ; @@v5@@ = @@a1@@ [ Number ] ; * @@v2@@ = Number L ; @@v2@@ [ Number ] = @@v5@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v2@@ = @@v4@@ ; } while ( @@v4@@ ) ; } if ( @@v3@@ ) @@v3@@ ( * @@v1@@ ) ; * @@v1@@ = Number L ; @@v1@@ [ Number ] = Number L ; } @@v1@@ += Number ; } while ( @@a1@@ [ Number ] > ( unsigned __int64 ) @@v1@@ ) ; } @@a1@@ [ Number ] = Number L ; @@a1@@ [ Number ] = Number L ; }
int __fastcall rev_xstrcoll_df_mtime ( __int64 @@a1@@ , __int64 @@a2@@ ) { bool @@v2@@ ; bool @@v3@@ ; int @@result@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; @@v2@@ = * ( _DWORD * ) ( @@a1@@ + Number ) == Number || * ( _DWORD * ) ( @@a1@@ + Number ) == Number ; @@v3@@ = * ( _DWORD * ) ( @@a2@@ + Number ) == Number || * ( _DWORD * ) ( @@a2@@ + Number ) == Number ; if ( ! @@v3@@ && @@v2@@ ) return Number ; if ( @@v2@@ || ( @@result@@ = Number , ! @@v3@@ ) ) { @@v5@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) <= @@v5@@ ) { if ( * ( _QWORD * ) ( @@a2@@ + Number ) < @@v5@@ ) return Number ; @@v6@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) <= @@v6@@ ) { if ( * ( _QWORD * ) ( @@a2@@ + Number ) >= @@v6@@ ) return xstrcoll ( * ( char * * ) @@a2@@ , * ( char * * ) @@a1@@ ) ; return Number ; } } return Number ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
__int64 __fastcall getgroup ( __gid_t @@a1@@ ) { __int64 @@v1@@ ; const char * @@v3@@ ; struct group * @@v4@@ ; size_t @@v5@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@result@@ ; @@v1@@ = group_alist ; if ( group_alist ) { if ( @@a1@@ == * ( _DWORD * ) group_alist ) goto LABEL_9 ; while ( Number ) { @@v1@@ = * ( _QWORD * ) ( @@v1@@ + Number ) ; if ( ! @@v1@@ ) break ; if ( * ( _DWORD * ) @@v1@@ == @@a1@@ ) goto LABEL_9 ; } } @@v3@@ = String ; @@v4@@ = getgrgid ( @@a1@@ ) ; @@v5@@ = Number L ; if ( @@v4@@ ) { @@v3@@ = @@v4@@ -> gr_name ; @@v5@@ = strlen ( @@v4@@ -> gr_name ) + Number ; } @@v6@@ = xmalloc ( @@v5@@ ) ; * ( _DWORD * ) @@v6@@ = @@a1@@ ; @@v1@@ = @@v6@@ ; strcpy ( ( char * ) ( @@v6@@ + Number ) , @@v3@@ ) ; @@v7@@ = group_alist ; group_alist = @@v1@@ ; * ( _QWORD * ) ( @@v1@@ + Number ) = @@v7@@ ; LABEL_9 : if ( * ( _BYTE * ) ( @@v1@@ + Number ) ) @@result@@ = @@v1@@ + Number ; else @@result@@ = Number L ; return @@result@@ ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
void __fastcall mpsort ( __int64 * @@a1@@ , unsigned __int64 @@a2@@ , int ( __fastcall * @@a3@@ ) ( __int64 , __int64 ) ) { mpsort_with_tmp ( @@a1@@ , @@a2@@ , & @@a1@@ [ @@a2@@ ] , @@a3@@ ) ; }
int __fastcall xstrcoll_extension ( const char * * @@a1@@ , const char * * @@a2@@ ) { char * @@v2@@ ; char * @@v3@@ ; int @@result@@ ; @@v2@@ = strrchr ( * @@a1@@ , Number ) ; @@v3@@ = strrchr ( * @@a2@@ , Number ) ; if ( ! @@v3@@ ) @@v3@@ = ( char * ) String ; if ( ! @@v2@@ ) @@v2@@ = ( char * ) String ; @@result@@ = xstrcoll ( @@v2@@ , @@v3@@ ) ; if ( ! @@result@@ ) @@result@@ = xstrcoll ( ( char * ) * @@a1@@ , ( char * ) * @@a2@@ ) ; return @@result@@ ; }
__int64 __fastcall argmatch_to_argument ( void * @@s1@@ , __int64 * @@a2@@ , char * @@a3@@ , size_t @@a4@@ ) { __int64 @@v4@@ ; __int64 * @@v7@@ ; @@v4@@ = * @@a2@@ ; if ( * @@a2@@ ) { @@v7@@ = @@a2@@ + Number ; do { if ( ! memcmp ( @@s1@@ , @@a3@@ , @@a4@@ ) ) break ; @@v4@@ = * @@v7@@ ; @@a3@@ += @@a4@@ ; ++ @@v7@@ ; } while ( @@v4@@ ) ; } return @@v4@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
bool __fastcall mktime_ok ( _DWORD * @@a1@@ , struct tm * @@a2@@ , time_t @@a3@@ ) { bool @@result@@ ; time_t @@timer@@ ; @@timer@@ = @@a3@@ ; if ( @@a3@@ != Number || ( @@a2@@ = localtime ( & @@timer@@ ) , @@result@@ = Number , @@a2@@ ) ) { @@result@@ = ( @@a2@@ -> tm_year ^ @@a1@@ [ Number ] | @@a2@@ -> tm_mon ^ @@a1@@ [ Number ] | @@a2@@ -> tm_mday ^ @@a1@@ [ Number ] | @@a2@@ -> tm_hour ^ @@a1@@ [ Number ] | @@a2@@ -> tm_min ^ @@a1@@ [ Number ] | @@a2@@ -> tm_sec ^ * @@a1@@ ) == Number ; } return @@result@@ ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
int __fastcall strcmp_df_atime ( __int64 @@a1@@ , __int64 @@a2@@ ) { bool @@v2@@ ; bool @@v3@@ ; int @@result@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; @@v2@@ = * ( _DWORD * ) ( @@a1@@ + Number ) == Number || * ( _DWORD * ) ( @@a1@@ + Number ) == Number ; @@v3@@ = * ( _DWORD * ) ( @@a2@@ + Number ) == Number || * ( _DWORD * ) ( @@a2@@ + Number ) == Number ; if ( ! @@v3@@ && @@v2@@ ) return Number ; if ( @@v2@@ || ( @@result@@ = Number , ! @@v3@@ ) ) { @@v5@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= @@v5@@ ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) < @@v5@@ ) return Number ; @@v6@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= @@v6@@ ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) >= @@v6@@ ) return strcmp ( * ( const char * * ) @@a1@@ , * ( const char * * ) @@a2@@ ) ; return Number ; } } return Number ; } return @@result@@ ; }
__int64 __fastcall xnanosleep ( double @@a1@@ ) { __int64 @@v1@@ ; char @@v2@@ ; signed __int64 @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; unsigned __int64 @@v8@@ ; @@v8@@ = __readfsqword ( Number ) ; if ( @@a1@@ < Number ) __assert_fail ( String , String , Number , String ) ; if ( @@a1@@ > Number ) { @@v2@@ = Number ; } else { @@v1@@ = ( unsigned int ) ( int ) @@a1@@ ; @@v6@@ = @@v1@@ ; @@v2@@ = Number ; @@v3@@ = ( unsigned int ) ( int ) ( ( @@a1@@ - ( double ) ( int ) @@v1@@ ) * Number ) + ( unsigned __int64 ) ( ( @@a1@@ - ( double ) ( int ) @@v1@@ ) * Number > ( double ) ( int ) ( ( @@a1@@ - ( double ) ( int ) @@v1@@ ) * Number ) ) ; @@v7@@ = @@v3@@ ; if ( @@v3@@ > Number ) { @@v6@@ = @@v1@@ + Number ; @@v7@@ = @@v3@@ - Number ; } } @@v4@@ = __errno_location ( ) ; while ( Number ) { if ( @@v2@@ ) { @@v6@@ = Number ; @@v7@@ = Number L ; } * @@v4@@ = Number ; @@result@@ = rpl_nanosleep ( & @@v6@@ , Number L ) ; if ( ! ( _DWORD ) @@result@@ ) break ; if ( ( * @@v4@@ & Number ) != Number ) return Number ; } return @@result@@ ; }
__int64 __fastcall file_name_concat ( void * @@a1@@ , void * @@a2@@ ) { __int64 @@result@@ ; @@result@@ = mfile_name_concat ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
int __fastcall strcmp_df_extension ( __int64 @@a1@@ , __int64 @@a2@@ ) { bool @@v2@@ ; bool @@v3@@ ; int @@result@@ ; const char * @@v5@@ ; char * @@v6@@ ; const char * @@v7@@ ; const char * @@v8@@ ; char * @@v9@@ ; @@v2@@ = * ( _DWORD * ) ( @@a1@@ + Number ) == Number || * ( _DWORD * ) ( @@a1@@ + Number ) == Number ; @@v3@@ = * ( _DWORD * ) ( @@a2@@ + Number ) == Number || * ( _DWORD * ) ( @@a2@@ + Number ) == Number ; if ( ! @@v3@@ && @@v2@@ ) return Number ; if ( @@v2@@ || ( @@result@@ = Number , ! @@v3@@ ) ) { @@v5@@ = * ( const char * * ) @@a1@@ ; @@v6@@ = strrchr ( * ( const char * * ) @@a1@@ , Number ) ; @@v7@@ = * ( const char * * ) @@a2@@ ; @@v8@@ = @@v6@@ ; @@v9@@ = strrchr ( * ( const char * * ) @@a2@@ , Number ) ; if ( @@v9@@ ) { if ( ! @@v8@@ ) @@v8@@ = String ; } else { @@v9@@ = ( char * ) String ; if ( ! @@v8@@ ) return strcmp ( @@v5@@ , @@v7@@ ) ; } @@result@@ = strcmp ( @@v8@@ , @@v9@@ ) ; if ( ! @@result@@ ) return strcmp ( @@v5@@ , @@v7@@ ) ; } return @@result@@ ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall gnu_mbswidth ( char * @@s@@ , char @@a2@@ ) { __int64 @@v2@@ ; @@v2@@ = strlen ( @@s@@ ) ; return mbsnwidth ( @@s@@ , @@v2@@ , @@a2@@ ) ; }
__int64 __fastcall hash_find_entry ( __int64 * @@a1@@ , __int64 @@a2@@ , __m128i * * @@a3@@ , char @@a4@@ ) { __int64 @@v5@@ ; __m128i * @@v8@@ ; __int64 @@v9@@ ; __int64 * @@v10@@ ; const __m128i * @@v12@@ ; @@v5@@ = * @@a1@@ ; @@v8@@ = ( __m128i * ) ( Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) + @@v5@@ ) ; if ( @@a1@@ [ Number ] <= ( unsigned __int64 ) @@v8@@ ) abort ( ) ; * @@a3@@ = @@v8@@ ; @@v9@@ = @@v8@@ -> m128i_i64 [ Number ] ; if ( @@v8@@ -> m128i_i64 [ Number ] ) { if ( @@v9@@ != @@a2@@ ) { if ( ! ( ( unsigned __int8 ( __fastcall * ) ( __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ ) ) { @@v10@@ = ( __int64 * ) @@v8@@ -> m128i_i64 [ Number ] ; if ( @@v10@@ ) { @@v9@@ = * @@v10@@ ; if ( @@a2@@ != * @@v10@@ ) { while ( ! ( ( unsigned __int8 ( __fastcall * ) ( __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ ) ) { @@v8@@ = ( __m128i * ) @@v8@@ -> m128i_i64 [ Number ] ; @@v10@@ = ( __int64 * ) @@v8@@ -> m128i_i64 [ Number ] ; if ( ! @@v10@@ ) return Number L ; @@v9@@ = * @@v10@@ ; if ( * @@v10@@ == @@a2@@ ) goto LABEL_12 ; } @@v10@@ = ( __int64 * ) @@v8@@ -> m128i_i64 [ Number ] ; @@v9@@ = * @@v10@@ ; } LABEL_12 : if ( @@a4@@ ) { @@v8@@ -> m128i_i64 [ Number ] = @@v10@@ [ Number ] ; * @@v10@@ = Number L ; @@v10@@ [ Number ] = @@a1@@ [ Number ] ; @@a1@@ [ Number ] = ( __int64 ) @@v10@@ ; } return @@v9@@ ; } return Number L ; } @@v9@@ = @@v8@@ -> m128i_i64 [ Number ] ; } if ( @@a4@@ ) { @@v12@@ = ( const __m128i * ) @@v8@@ -> m128i_i64 [ Number ] ; if ( @@v12@@ ) { * @@v8@@ = _mm_loadu_si128 ( @@v12@@ ) ; @@v12@@ -> m128i_i64 [ Number ] = Number L ; @@v12@@ -> m128i_i64 [ Number ] = @@a1@@ [ Number ] ; @@a1@@ [ Number ] = ( __int64 ) @@v12@@ ; return @@v9@@ ; } @@v8@@ -> m128i_i64 [ Number ] = Number L ; } return @@v9@@ ; } return Number L ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
long double __fastcall adjust_value_part_0 ( int @@a1@@ , long double @@a2@@ ) { unsigned __int64 @@v7@@ ; long double @@v8@@ ; long double @@result@@ ; if ( @@a2@@ >= Number ) @@v7@@ = ( __int64 ) ( @@a2@@ - Number ) ^ Number ; else @@v7@@ = ( __int64 ) @@a2@@ ; @@v8@@ = ( long double ) @@v7@@ ; if ( @@a1@@ ) return @@v8@@ ; @@result@@ = @@v8@@ ; if ( @@a2@@ != @@v8@@ ) @@result@@ = ( long double ) ( @@v7@@ + Number ) ; return @@result@@ ; }
__int64 __fastcall _xargmatch_internal ( __int64 @@a1@@ , const char * @@a2@@ , const char * * @@a3@@ , char * @@a4@@ , size_t @@a5@@ , void ( * @@a6@@ ) ( void ) ) { __int64 @@result@@ ; @@result@@ = argmatch ( @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; if ( @@result@@ < Number ) { argmatch_invalid ( @@a1@@ , ( __int64 ) @@a2@@ , @@result@@ ) ; argmatch_valid ( @@a3@@ , @@a4@@ , @@a5@@ ) ; @@a6@@ ( ) ; @@result@@ = Number ; } return @@result@@ ; }
__int64 __fastcall _xargmatch_internal ( __int64 @@a1@@ , const char * @@a2@@ , const char * * @@a3@@ , char * @@a4@@ , size_t @@a5@@ , void ( * @@a6@@ ) ( void ) ) { __int64 @@result@@ ; @@result@@ = argmatch ( @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; if ( @@result@@ < Number ) { argmatch_invalid ( @@a1@@ , ( __int64 ) @@a2@@ , @@result@@ ) ; argmatch_valid ( @@a3@@ , @@a4@@ , @@a5@@ ) ; @@a6@@ ( ) ; @@result@@ = Number ; } return @@result@@ ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
bool __fastcall test_unop_part_1 ( __int64 @@a1@@ ) { bool @@result@@ ; @@result@@ = Number ; if ( ( unsigned __int8 ) ( * ( _BYTE * ) ( @@a1@@ + Number ) - Number ) <= Number ) @@result@@ = ( ( Number L << ( * ( _BYTE * ) ( @@a1@@ + Number ) - Number ) ) & Number ) != Number ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
void __fastcall fwrite_uppcase ( FILE * @@stream@@ , unsigned __int8 * @@a2@@ , __int64 @@a3@@ ) { unsigned __int8 * @@v3@@ ; unsigned __int8 * @@v4@@ ; const __int32_t * * @@v5@@ ; __int64 @@v6@@ ; if ( @@a3@@ ) { @@v3@@ = @@a2@@ ; @@v4@@ = & @@a2@@ [ @@a3@@ ] ; @@v5@@ = __ctype_toupper_loc ( ) ; do { @@v6@@ = * @@v3@@ ++ ; fputc ( ( * @@v5@@ ) [ @@v6@@ ] , @@stream@@ ) ; } while ( @@v3@@ != @@v4@@ ) ; } }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
__int64 __fastcall getuser ( __uid_t @@a1@@ ) { __int64 @@v1@@ ; const char * @@v3@@ ; struct passwd * @@v4@@ ; size_t @@v5@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@result@@ ; @@v1@@ = user_alist ; if ( user_alist ) { if ( @@a1@@ == * ( _DWORD * ) user_alist ) goto LABEL_9 ; while ( Number ) { @@v1@@ = * ( _QWORD * ) ( @@v1@@ + Number ) ; if ( ! @@v1@@ ) break ; if ( * ( _DWORD * ) @@v1@@ == @@a1@@ ) goto LABEL_9 ; } } @@v3@@ = String ; @@v4@@ = getpwuid ( @@a1@@ ) ; @@v5@@ = Number L ; if ( @@v4@@ ) { @@v3@@ = @@v4@@ -> pw_name ; @@v5@@ = strlen ( @@v4@@ -> pw_name ) + Number ; } @@v6@@ = xmalloc ( @@v5@@ ) ; * ( _DWORD * ) @@v6@@ = @@a1@@ ; @@v1@@ = @@v6@@ ; strcpy ( ( char * ) ( @@v6@@ + Number ) , @@v3@@ ) ; @@v7@@ = user_alist ; user_alist = @@v1@@ ; * ( _QWORD * ) ( @@v1@@ + Number ) = @@v7@@ ; LABEL_9 : if ( * ( _BYTE * ) ( @@v1@@ + Number ) ) @@result@@ = @@v1@@ + Number ; else @@result@@ = Number L ; return @@result@@ ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
__int64 __fastcall filemodestring ( __int64 @@a1@@ , __int64 @@a2@@ ) { return strmode ( * ( _DWORD * ) ( @@a1@@ + Number ) , @@a2@@ ) ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ , @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
bool __fastcall hard_locale ( int @@a1@@ ) { char * @@v1@@ ; bool @@result@@ ; @@v1@@ = setlocale ( @@a1@@ , Number L ) ; @@result@@ = Number ; if ( @@v1@@ ) { @@result@@ = Number ; if ( strcmp ( @@v1@@ , String ) ) @@result@@ = strcmp ( @@v1@@ , String ) != Number ; } return @@result@@ ; }
__int64 __fastcall imaxtostr ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; __int64 @@result@@ ; int @@v4@@ ; bool @@v5@@ ; @@v2@@ = @@a2@@ + Number ; * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; if ( @@a1@@ < Number ) { while ( Number ) { @@v4@@ = Number * ( @@a1@@ / Number ) + Number - @@a1@@ ; @@v5@@ = ( __int64 ) ( ( unsigned __int128 ) ( Number * ( __int128 ) @@a1@@ ) >> Number ) >> Number == @@a1@@ >> Number ; @@a1@@ /= Number L ; * ( _BYTE * ) ( @@v2@@ - Number ) = @@v4@@ ; if ( @@v5@@ ) break ; -- @@v2@@ ; } * ( _BYTE * ) ( @@v2@@ - Number ) = Number ; @@result@@ = @@v2@@ - Number ; } else { do { * ( _BYTE * ) -- @@v2@@ = @@a1@@ % Number + Number ; @@a1@@ /= Number ; } while ( @@a1@@ ) ; @@result@@ = @@v2@@ ; } return @@result@@ ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
__int64 __fastcall hash_get_n_buckets ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall memcpy_uppcase ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v3@@ ; const __int32_t * * @@v4@@ ; if ( @@a3@@ ) { @@v3@@ = @@a3@@ - Number ; @@v4@@ = __ctype_toupper_loc ( ) ; do { * ( _BYTE * ) ( @@a1@@ + @@v3@@ ) = ( * @@v4@@ ) [ * ( unsigned __int8 * ) ( @@a2@@ + @@v3@@ ) ] ; -- @@v3@@ ; } while ( @@v3@@ != Number ) ; } return @@a1@@ ; }
__int64 __fastcall hash_get_n_buckets_used ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_20F210 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20F1F0 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20F200 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_2071D0 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2071B0 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_2071C0 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
__int64 __fastcall hash_get_n_entries ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_219F70 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_219F50 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_219F60 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
unsigned __int64 __fastcall hash_get_max_bucket_length ( __int64 @@a1@@ ) { _QWORD * @@v1@@ ; unsigned __int64 @@v2@@ ; unsigned __int64 @@result@@ ; __int64 @@v4@@ ; unsigned __int64 @@i@@ ; @@v1@@ = * ( _QWORD * * ) @@a1@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; for ( @@result@@ = Number L ; ( unsigned __int64 ) @@v1@@ < @@v2@@ ; @@v1@@ += Number ) { if ( * @@v1@@ ) { @@v4@@ = @@v1@@ [ Number ] ; for ( @@i@@ = Number L ; @@v4@@ ; ++ @@i@@ ) @@v4@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; if ( @@result@@ < @@i@@ ) @@result@@ = @@i@@ ; } } return @@result@@ ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
int putenv ( char * @@string@@ ) { return putenv ( @@string@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
__int64 __fastcall hash_lookup ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; _QWORD * @@v4@@ ; __int64 @@v5@@ ; @@v2@@ = * @@a1@@ ; @@v4@@ = ( _QWORD * ) ( Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) + @@v2@@ ) ; if ( @@a1@@ [ Number ] <= ( unsigned __int64 ) @@v4@@ ) abort ( ) ; @@v5@@ = * @@v4@@ ; if ( ! * @@v4@@ ) return Number L ; while ( @@v5@@ != @@a2@@ ) { if ( ( ( unsigned __int8 ( __fastcall * ) ( __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ ) ) return * @@v4@@ ; @@v4@@ = ( _QWORD * ) @@v4@@ [ Number ] ; if ( ! @@v4@@ ) return Number L ; @@v5@@ = * @@v4@@ ; } return @@v5@@ ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = _do_global_dtors_aux_fini_array_entry - _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) _frame_dummy_init_array_entry [ @@i@@ ] ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
int clock_settime ( clockid_t @@clock_id@@ , const struct timespec * @@tp@@ ) { return clock_settime ( @@clock_id@@ , @@tp@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall hash_do_for_each ( __int64 @@a1@@ , unsigned __int8 ( __fastcall * @@a2@@ ) ( __int64 , __int64 ) , __int64 @@a3@@ ) { __int64 * @@v3@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 * @@v8@@ ; @@v3@@ = * ( __int64 * * ) @@a1@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= * ( _QWORD * ) @@a1@@ ) return Number L ; @@v6@@ = Number L ; while ( Number ) { @@v7@@ = * @@v3@@ ; if ( * @@v3@@ ) break ; LABEL_8 : @@v3@@ += Number ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= ( unsigned __int64 ) @@v3@@ ) return @@v6@@ ; } @@v8@@ = @@v3@@ ; while ( @@a2@@ ( @@v7@@ , @@a3@@ ) ) { @@v8@@ = ( __int64 * ) @@v8@@ [ Number ] ; ++ @@v6@@ ; if ( ! @@v8@@ ) goto LABEL_8 ; @@v7@@ = * @@v8@@ ; } return @@v6@@ ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
__int64 __fastcall hash_reset_tuning ( __int64 @@a1@@ ) { __int64 @@result@@ ; * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; * ( _QWORD * ) @@a1@@ = Number ; @@result@@ = Number ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number ; return @@result@@ ; }
__int64 __fastcall apply_relative_time ( __int64 @@a1@@ , int @@a2@@ , __int64 a3 , __int64 a4 , __int64 a5 , __int64 a6 , __int64 @@a7@@ , __int64 @@a8@@ , __int64 @@a9@@ , __int64 @@a10@@ , __int64 @@a11@@ , __int64 @@a12@@ , __int64 @@a13@@ ) { __int64 @@result@@ ; * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; * ( _QWORD * ) ( @@a1@@ + Number ) += @@a2@@ * @@a13@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) += @@a2@@ * @@a12@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) += @@a2@@ * @@a11@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) += @@a2@@ * @@a10@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) += @@a2@@ * @@a9@@ ; @@result@@ = @@a2@@ * @@a8@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) += @@result@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) += @@a7@@ * @@a2@@ ; return @@result@@ ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
__int64 __fastcall hash_get_n_buckets ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
void * __fastcall get_tz ( void * @@dest@@ ) { char * @@v1@@ ; char * @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v1@@ = getenv ( String ) ; if ( ! @@v1@@ ) return Number L ; @@v2@@ = @@v1@@ ; @@v3@@ = strlen ( @@v1@@ ) ; if ( @@v3@@ + Number <= Number ) @@result@@ = memcpy ( @@dest@@ , @@v2@@ , @@v3@@ + Number ) ; else @@result@@ = ( void * ) xmemdup ( @@v2@@ , @@v3@@ + Number ) ; return @@result@@ ; }
void __fastcall hash_free ( void * @@ptr@@ ) { _QWORD * @@v2@@ ; unsigned __int64 @@v3@@ ; _QWORD * @@v4@@ ; _QWORD * @@v5@@ ; _QWORD * @@v6@@ ; _QWORD * @@v7@@ ; _QWORD * @@v8@@ ; @@v2@@ = * ( _QWORD * * ) @@ptr@@ ; @@v3@@ = * ( ( _QWORD * ) @@ptr@@ + Number ) ; if ( * ( ( _QWORD * ) @@ptr@@ + Number ) && * ( ( _QWORD * ) @@ptr@@ + Number ) ) { if ( ( unsigned __int64 ) @@v2@@ >= @@v3@@ ) goto LABEL_14 ; do { if ( * @@v2@@ ) { @@v4@@ = @@v2@@ ; do { ( * ( ( void ( * * ) ( void ) ) @@ptr@@ + Number ) ) ( ) ; @@v4@@ = ( _QWORD * ) @@v4@@ [ Number ] ; } while ( @@v4@@ ) ; @@v3@@ = * ( ( _QWORD * ) @@ptr@@ + Number ) ; } @@v2@@ += Number ; } while ( @@v3@@ > ( unsigned __int64 ) @@v2@@ ) ; @@v2@@ = * ( _QWORD * * ) @@ptr@@ ; } if ( ( unsigned __int64 ) @@v2@@ < @@v3@@ ) { do { @@v5@@ = ( _QWORD * ) @@v2@@ [ Number ] ; if ( @@v5@@ ) { do { @@v6@@ = ( _QWORD * ) @@v5@@ [ Number ] ; free ( @@v5@@ ) ; @@v5@@ = @@v6@@ ; } while ( @@v6@@ ) ; } @@v2@@ += Number ; } while ( * ( ( _QWORD * ) @@ptr@@ + Number ) > ( unsigned __int64 ) @@v2@@ ) ; } LABEL_14 : @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@ptr@@ + Number ) ; if ( @@v7@@ ) { do { @@v8@@ = ( _QWORD * ) @@v7@@ [ Number ] ; free ( @@v7@@ ) ; @@v7@@ = @@v8@@ ; } while ( @@v8@@ ) ; } free ( * ( void * * ) @@ptr@@ ) ; free ( @@ptr@@ ) ; }
int __cdecl __noreturn main ( int @@argc@@ , const char * * @@argv@@ , const char * * envp ) { __int64 @@v4@@ ; const char * @@v5@@ ; int @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; __int64 @@v9@@ ; int @@v10@@ ; const char * @@v11@@ ; int * @@v12@@ ; __int64 @@v13@@ ; char @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; @@v4@@ = Number L ; @@v5@@ = * @@argv@@ ; @@v15@@ = __readfsqword ( Number ) ; set_program_name ( @@v5@@ ) ; setlocale ( Number , String ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; have_read_stdin = Number ; count_bytes = Number ; break_spaces = Number ; while ( Number ) { @@v6@@ = getopt_long ( @@argc@@ , ( char * const * ) @@argv@@ , String , & longopts , Number L ) ; if ( @@v6@@ == Number ) { @@v9@@ = optind ; if ( optind == @@argc@@ ) { LOBYTE ( @@v10@@ ) = fold_file ( String , @@v4@@ ) ; } else { @@v10@@ = Number ; while ( @@argc@@ > ( int ) @@v9@@ ) { @@v11@@ = @@argv@@ [ @@v9@@ ++ ] ; @@v10@@ &= fold_file ( @@v11@@ , @@v4@@ ) ; } } if ( have_read_stdin && fclose ( stdin ) == Number ) { @@v12@@ = __errno_location ( ) ; error ( Number , * @@v12@@ , String ) ; } exit ( ( unsigned __int8 ) @@v10@@ ^ Number ) ; } if ( @@v6@@ > Number ) { switch ( @@v6@@ ) { case String : break_spaces = Number ; break ; case String : goto LABEL_14 ; case String : count_bytes = Number ; break ; default : goto LABEL_11 ; } } else { if ( @@v6@@ < Number ) { if ( @@v6@@ == Number ) { version_etc ( ( _DWORD ) stdout , ( unsigned int ) String , ( unsigned int ) & unk_42B1 , ( _DWORD ) Version , ( unsigned int ) String , Number ) ; exit ( Number ) ; } if ( @@v6@@ == Number ) usage ( Number ) ; LABEL_11 : usage ( Number ) ; } if ( optarg ) { -- optarg ; } else { @@v14@@ [ Number ] = @@v6@@ ; @@v14@@ [ Number ] = Number ; optarg = @@v14@@ ; } LABEL_14 : if ( ( unsigned int ) xstrtoul ( optarg ) || ( @@v4@@ = @@v13@@ , ( unsigned __int64 ) ( @@v13@@ - Number ) > Number ) ) { @@v7@@ = quote ( optarg , Number L ) ; @@v8@@ = dcgettext ( Number L , String , Number ) ; error ( Number , Number , @@v8@@ , @@v7@@ ) ; @@v4@@ = @@v13@@ ; } } } }
unsigned __int64 __fastcall hash_get_max_bucket_length ( __int64 @@a1@@ ) { _QWORD * @@v1@@ ; unsigned __int64 @@v2@@ ; unsigned __int64 @@result@@ ; __int64 @@v4@@ ; unsigned __int64 @@i@@ ; @@v1@@ = * ( _QWORD * * ) @@a1@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; for ( @@result@@ = Number L ; ( unsigned __int64 ) @@v1@@ < @@v2@@ ; @@v1@@ += Number ) { if ( * @@v1@@ ) { @@v4@@ = @@v1@@ [ Number ] ; for ( @@i@@ = Number L ; @@v4@@ ; ++ @@i@@ ) @@v4@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; if ( @@result@@ < @@i@@ ) @@result@@ = @@i@@ ; } } return @@result@@ ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
__int64 __fastcall getuidbyname ( char * @@src@@ ) { __int64 @@v1@@ ; char @@v2@@ ; __int64 @@result@@ ; __int64 @@v4@@ ; char @@v5@@ ; struct passwd * @@v6@@ ; size_t @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; @@v1@@ = user_alist ; if ( user_alist ) { @@v2@@ = * @@src@@ ; while ( * ( _BYTE * ) ( @@v1@@ + Number ) != @@v2@@ || strcmp ( ( const char * ) ( @@v1@@ + Number ) , @@src@@ ) ) { @@v1@@ = * ( _QWORD * ) ( @@v1@@ + Number ) ; if ( ! @@v1@@ ) goto LABEL_7 ; } return @@v1@@ ; } LABEL_7 : @@v4@@ = nouser_alist ; if ( nouser_alist ) { @@v5@@ = * @@src@@ ; while ( * ( _BYTE * ) ( @@v4@@ + Number ) != @@v5@@ || strcmp ( ( const char * ) ( @@v4@@ + Number ) , @@src@@ ) ) { @@v4@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; if ( ! @@v4@@ ) goto LABEL_13 ; } @@result@@ = Number L ; } else { LABEL_13 : @@v6@@ = getpwnam ( @@src@@ ) ; @@v7@@ = strlen ( @@src@@ ) ; @@v1@@ = xmalloc ( @@v7@@ + Number ) ; strcpy ( ( char * ) ( @@v1@@ + Number ) , @@src@@ ) ; if ( @@v6@@ ) { * ( _DWORD * ) @@v1@@ = @@v6@@ -> pw_uid ; @@v8@@ = user_alist ; user_alist = @@v1@@ ; * ( _QWORD * ) ( @@v1@@ + Number ) = @@v8@@ ; return @@v1@@ ; } @@v9@@ = nouser_alist ; nouser_alist = @@v1@@ ; * ( _QWORD * ) ( @@v1@@ + Number ) = @@v9@@ ; @@result@@ = Number L ; } return @@result@@ ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
__int64 __fastcall hash_get_next ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; __int64 * @@v6@@ ; _QWORD * @@v7@@ ; __int64 @@v8@@ ; __int64 @@result@@ ; @@v2@@ = * @@a1@@ ; @@v4@@ = ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) ; @@v5@@ = @@a1@@ [ Number ] ; @@v6@@ = ( __int64 * ) ( @@v2@@ + Number * @@v4@@ ) ; if ( @@v5@@ <= ( unsigned __int64 ) @@v6@@ ) abort ( ) ; if ( ! @@v6@@ ) goto LABEL_10 ; @@v7@@ = ( _QWORD * ) @@v6@@ [ Number ] ; if ( * @@v6@@ != @@a2@@ ) { do { if ( ! @@v7@@ ) goto LABEL_10 ; @@v8@@ = * @@v7@@ ; @@v7@@ = ( _QWORD * ) @@v7@@ [ Number ] ; } while ( @@v8@@ != @@a2@@ ) ; } if ( @@v7@@ ) return * @@v7@@ ; LABEL_10 : while ( Number ) { @@v6@@ += Number ; if ( @@v5@@ <= ( unsigned __int64 ) @@v6@@ ) break ; @@result@@ = * @@v6@@ ; if ( * @@v6@@ ) return @@result@@ ; } return Number L ; }
int __fastcall argmatch_valid ( _QWORD * @@a1@@ , char * @@a2@@ , size_t @@a3@@ ) { const void * @@v5@@ ; __int64 @@v6@@ ; char * @@v7@@ ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; if ( * @@a1@@ ) { @@v5@@ = Number L ; @@v6@@ = Number L ; do { while ( ! @@v6@@ || memcmp ( @@v5@@ , @@a2@@ , @@a3@@ ) ) { ++ @@v6@@ ; @@v5@@ = @@a2@@ ; __fprintf_chk ( ) ; @@a2@@ += @@a3@@ ; if ( ! @@a1@@ [ @@v6@@ ] ) goto LABEL_7 ; } ++ @@v6@@ ; @@a2@@ += @@a3@@ ; __fprintf_chk ( ) ; } while ( @@a1@@ [ @@v6@@ ] ) ; } LABEL_7 : @@v7@@ = stderr -> _IO_write_ptr ; if ( @@v7@@ >= stderr -> _IO_write_end ) { LODWORD ( @@v7@@ ) = __overflow ( stderr , Number ) ; } else { stderr -> _IO_write_ptr = @@v7@@ + Number ; * @@v7@@ = Number ; } return ( int ) @@v7@@ ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
void __fastcall hash_free ( void * @@ptr@@ ) { _QWORD * @@v2@@ ; unsigned __int64 @@v3@@ ; _QWORD * @@v4@@ ; _QWORD * @@v5@@ ; _QWORD * @@v6@@ ; _QWORD * @@v7@@ ; _QWORD * @@v8@@ ; @@v2@@ = * ( _QWORD * * ) @@ptr@@ ; @@v3@@ = * ( ( _QWORD * ) @@ptr@@ + Number ) ; if ( * ( ( _QWORD * ) @@ptr@@ + Number ) && * ( ( _QWORD * ) @@ptr@@ + Number ) ) { if ( ( unsigned __int64 ) @@v2@@ >= @@v3@@ ) goto LABEL_14 ; do { if ( * @@v2@@ ) { @@v4@@ = @@v2@@ ; do { ( * ( ( void ( * * ) ( void ) ) @@ptr@@ + Number ) ) ( ) ; @@v4@@ = ( _QWORD * ) @@v4@@ [ Number ] ; } while ( @@v4@@ ) ; @@v3@@ = * ( ( _QWORD * ) @@ptr@@ + Number ) ; } @@v2@@ += Number ; } while ( @@v3@@ > ( unsigned __int64 ) @@v2@@ ) ; @@v2@@ = * ( _QWORD * * ) @@ptr@@ ; } if ( ( unsigned __int64 ) @@v2@@ < @@v3@@ ) { do { @@v5@@ = ( _QWORD * ) @@v2@@ [ Number ] ; if ( @@v5@@ ) { do { @@v6@@ = ( _QWORD * ) @@v5@@ [ Number ] ; free ( @@v5@@ ) ; @@v5@@ = @@v6@@ ; } while ( @@v6@@ ) ; } @@v2@@ += Number ; } while ( * ( ( _QWORD * ) @@ptr@@ + Number ) > ( unsigned __int64 ) @@v2@@ ) ; } LABEL_14 : @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@ptr@@ + Number ) ; if ( @@v7@@ ) { do { @@v8@@ = ( _QWORD * ) @@v7@@ [ Number ] ; free ( @@v7@@ ) ; @@v7@@ = @@v8@@ ; } while ( @@v8@@ ) ; } free ( * ( void * * ) @@ptr@@ ) ; free ( @@ptr@@ ) ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
unsigned __int64 __fastcall fprintftime ( FILE * @@a1@@ , unsigned __int8 * @@a2@@ , __int64 @@a3@@ , unsigned int @@a4@@ , unsigned int @@a5@@ ) { return strftime_case_ ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
__int64 __fastcall memcpy_lowcase ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v3@@ ; const __int32_t * * @@v4@@ ; if ( @@a3@@ ) { @@v3@@ = @@a3@@ - Number ; @@v4@@ = __ctype_tolower_loc ( ) ; do { * ( _BYTE * ) ( @@a1@@ + @@v3@@ ) = ( * @@v4@@ ) [ * ( unsigned __int8 * ) ( @@a2@@ + @@v3@@ ) ] ; -- @@v3@@ ; } while ( @@v3@@ != Number ) ; } return @@a1@@ ; }
__int64 __fastcall umaxtostr ( unsigned __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; @@v2@@ = @@a2@@ + Number ; * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; do { * ( _BYTE * ) -- @@v2@@ = @@a1@@ % Number + Number ; @@a1@@ /= Number ; } while ( @@a1@@ ) ; return @@v2@@ ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_2061F0 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061D0 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2061E0 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
unsigned __int64 __fastcall wd_hasher ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return * ( int * ) ( @@a1@@ + Number ) % @@a2@@ ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
char * __fastcall pretty_name_isra_2 ( const char * @@a1@@ ) { char * @@result@@ ; @@result@@ = ( char * ) @@a1@@ ; if ( ! strcmp ( @@a1@@ , String ) ) @@result@@ = dcgettext ( Number L , String , Number ) ; return @@result@@ ; }
unsigned __int64 __fastcall triple_hash_no_name ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) % @@a2@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
void __fastcall triple_free ( void * @@ptr@@ ) { free ( * ( void * * ) @@ptr@@ ) ; free ( @@ptr@@ ) ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
__int64 __fastcall start_bytes_isra_6 ( __int64 @@a1@@ , int @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; size_t @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; int * @@v9@@ ; _BYTE @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v11@@ = __readfsqword ( Number ) ; if ( @@a3@@ ) { @@v3@@ = @@a3@@ ; while ( Number ) { @@v4@@ = safe_read ( @@a2@@ , @@v10@@ , Number ) ; if ( ! @@v4@@ ) return Number ; if ( @@v4@@ == Number ) { @@v7@@ = quote ( @@a1@@ , @@v10@@ ) ; @@v8@@ = dcgettext ( Number L , String , Number ) ; @@v9@@ = __errno_location ( ) ; error ( Number , * @@v9@@ , @@v8@@ , @@v7@@ ) ; return Number L ; } if ( @@v4@@ > @@v3@@ ) break ; @@v3@@ -= @@v4@@ ; if ( ! @@v3@@ ) return Number L ; } @@v6@@ = @@v4@@ - @@v3@@ ; if ( @@v6@@ ) xwrite_stdout_part_5 ( & @@v10@@ [ @@v3@@ ] , @@v6@@ ) ; } return Number L ; }
__int64 __fastcall dir_name ( void * @@a1@@ ) { __int64 @@result@@ ; @@result@@ = mdir_name ( @@a1@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; FILE * @@v11@@ ; char * @@v12@@ ; char * @@v13@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String String String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = stdout ; @@v10@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v11@@ = stdout ; @@v12@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v12@@ , @@v11@@ ) ; @@v13@@ = setlocale ( Number , Number L ) ; if ( @@v13@@ ) { if ( strncmp ( @@v13@@ , String , Number ) ) { last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; program_invocation_short_name = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
int __lxstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _lxstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
int __cdecl __noreturn main ( int @@argc@@ , const char * * @@argv@@ , const char * * @@envp@@ ) { const char * @@v3@@ ; if ( @@argc@@ == Number ) { set_program_name ( * @@argv@@ , @@argv@@ , @@envp@@ ) ; setlocale ( Number , String ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; @@v3@@ = @@argv@@ [ Number ] ; if ( ! strcmp ( @@v3@@ , String ) ) usage ( Number ) ; if ( ! strcmp ( @@v3@@ , String ) ) version_etc ( ( _DWORD ) stdout , ( unsigned int ) String , ( unsigned int ) & unk_3779 , ( _DWORD ) Version , ( unsigned int ) String , Number ) ; } exit ( Number ) ; }
int nanosleep ( const struct timespec * @@requested_time@@ , struct timespec * @@remaining@@ ) { return nanosleep ( @@requested_time@@ , @@remaining@@ ) ; }
char * __fastcall areadlink_with_size ( char * @@path@@ , unsigned __int64 @@a2@@ ) { size_t @@v2@@ ; char * @@v3@@ ; char * @@v4@@ ; ssize_t @@v5@@ ; char * @@v7@@ ; @@v2@@ = @@a2@@ + Number ; if ( @@a2@@ >= Number ) @@v2@@ = Number L ; while ( Number ) { @@v3@@ = ( char * ) malloc ( @@v2@@ ) ; @@v4@@ = @@v3@@ ; if ( @@v3@@ ) { while ( Number ) { @@v5@@ = readlink ( @@path@@ , @@v3@@ , @@v2@@ ) ; if ( @@v5@@ < Number && * __errno_location ( ) != Number ) { @@v7@@ = @@v4@@ ; @@v4@@ = Number L ; free ( @@v7@@ ) ; return @@v4@@ ; } if ( @@v2@@ > @@v5@@ ) { @@v4@@ [ @@v5@@ ] = Number ; return @@v4@@ ; } free ( @@v4@@ ) ; if ( @@v2@@ > Number ) break ; @@v2@@ *= Number L ; @@v3@@ = ( char * ) malloc ( @@v2@@ ) ; @@v4@@ = @@v3@@ ; if ( ! @@v3@@ ) return @@v4@@ ; } if ( @@v2@@ <= Number ) { @@v2@@ = Number ; continue ; } @@v4@@ = Number L ; * __errno_location ( ) = Number ; } break ; } return @@v4@@ ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
int __fxstat ( int @@ver@@ , int @@fildes@@ , struct stat * @@stat_buf@@ ) { return _fxstat ( @@ver@@ , @@fildes@@ , @@stat_buf@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
int fflush_unlocked ( FILE * @@stream@@ ) { return fflush_unlocked ( @@stream@@ ) ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
unsigned __int64 __fastcall raw_hasher ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return __ROR8__ ( @@a1@@ , Number ) % @@a2@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall hash_find_entry ( __int64 * @@a1@@ , __int64 @@a2@@ , __m128i * * @@a3@@ , char @@a4@@ ) { __int64 @@v5@@ ; __m128i * @@v8@@ ; __int64 @@v9@@ ; __int64 * @@v10@@ ; const __m128i * @@v12@@ ; @@v5@@ = * @@a1@@ ; @@v8@@ = ( __m128i * ) ( Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) + @@v5@@ ) ; if ( @@a1@@ [ Number ] <= ( unsigned __int64 ) @@v8@@ ) abort ( ) ; * @@a3@@ = @@v8@@ ; @@v9@@ = @@v8@@ -> m128i_i64 [ Number ] ; if ( @@v8@@ -> m128i_i64 [ Number ] ) { if ( @@v9@@ != @@a2@@ ) { if ( ! ( ( unsigned __int8 ( __fastcall * ) ( __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ ) ) { @@v10@@ = ( __int64 * ) @@v8@@ -> m128i_i64 [ Number ] ; if ( @@v10@@ ) { @@v9@@ = * @@v10@@ ; if ( @@a2@@ != * @@v10@@ ) { while ( ! ( ( unsigned __int8 ( __fastcall * ) ( __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ ) ) { @@v8@@ = ( __m128i * ) @@v8@@ -> m128i_i64 [ Number ] ; @@v10@@ = ( __int64 * ) @@v8@@ -> m128i_i64 [ Number ] ; if ( ! @@v10@@ ) return Number L ; @@v9@@ = * @@v10@@ ; if ( * @@v10@@ == @@a2@@ ) goto LABEL_12 ; } @@v10@@ = ( __int64 * ) @@v8@@ -> m128i_i64 [ Number ] ; @@v9@@ = * @@v10@@ ; } LABEL_12 : if ( @@a4@@ ) { @@v8@@ -> m128i_i64 [ Number ] = @@v10@@ [ Number ] ; * @@v10@@ = Number L ; @@v10@@ [ Number ] = @@a1@@ [ Number ] ; @@a1@@ [ Number ] = ( __int64 ) @@v10@@ ; } return @@v9@@ ; } return Number L ; } @@v9@@ = @@v8@@ -> m128i_i64 [ Number ] ; } if ( @@a4@@ ) { @@v12@@ = ( const __m128i * ) @@v8@@ -> m128i_i64 [ Number ] ; if ( @@v12@@ ) { * @@v8@@ = _mm_loadu_si128 ( @@v12@@ ) ; @@v12@@ -> m128i_i64 [ Number ] = Number L ; @@v12@@ -> m128i_i64 [ Number ] = @@a1@@ [ Number ] ; @@a1@@ [ Number ] = ( __int64 ) @@v12@@ ; return @@v9@@ ; } @@v8@@ -> m128i_i64 [ Number ] = Number L ; } return @@v9@@ ; } return Number L ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
__int64 __fastcall hash_get_n_buckets ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
int isatty ( int @@fd@@ ) { return isatty ( @@fd@@ ) ; }
void __fastcall close_fd ( unsigned int @@a1@@ , __int64 @@a2@@ ) { char * @@v2@@ ; int * @@v3@@ ; if ( @@a1@@ + Number > Number ) { if ( close ( @@a1@@ ) ) { @@v2@@ = dcgettext ( Number L , String , Number ) ; @@v3@@ = __errno_location ( ) ; error ( Number , * @@v3@@ , @@v2@@ , @@a2@@ , @@a1@@ ) ; } } }
__int64 __fastcall hash_get_first ( __int64 @@a1@@ ) { __int64 * @@v1@@ ; unsigned __int64 @@v2@@ ; __int64 @@result@@ ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; @@v1@@ = * ( __int64 * * ) @@a1@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( * ( _QWORD * ) @@a1@@ >= @@v2@@ ) goto LABEL_9 ; @@result@@ = * @@v1@@ ; if ( ! * @@v1@@ ) { while ( Number ) { @@v1@@ += Number ; if ( ( unsigned __int64 ) @@v1@@ >= @@v2@@ ) break ; @@result@@ = * @@v1@@ ; if ( * @@v1@@ ) return @@result@@ ; } LABEL_9 : abort ( ) ; } return @@result@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 __fastcall hash_get_n_buckets_used ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 __fastcall hash_get_n_entries ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__locale_t newlocale ( int @@category_mask@@ , const char * @@locale@@ , __locale_t @@base@@ ) { return newlocale ( @@category_mask@@ , @@locale@@ , @@base@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
__int64 __fastcall hash_do_for_each ( __int64 @@a1@@ , unsigned __int8 ( __fastcall * @@a2@@ ) ( __int64 , __int64 ) , __int64 @@a3@@ ) { __int64 * @@v3@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 * @@v8@@ ; @@v3@@ = * ( __int64 * * ) @@a1@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= * ( _QWORD * ) @@a1@@ ) return Number L ; @@v6@@ = Number L ; while ( Number ) { @@v7@@ = * @@v3@@ ; if ( * @@v3@@ ) break ; LABEL_8 : @@v3@@ += Number ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= ( unsigned __int64 ) @@v3@@ ) return @@v6@@ ; } @@v8@@ = @@v3@@ ; while ( @@a2@@ ( @@v7@@ , @@a3@@ ) ) { @@v8@@ = ( __int64 * ) @@v8@@ [ Number ] ; ++ @@v6@@ ; if ( ! @@v8@@ ) goto LABEL_8 ; @@v7@@ = * @@v8@@ ; } return @@v6@@ ; }
unsigned __int64 __fastcall hash_get_max_bucket_length ( __int64 @@a1@@ ) { _QWORD * @@v1@@ ; unsigned __int64 @@v2@@ ; unsigned __int64 @@result@@ ; __int64 @@v4@@ ; unsigned __int64 @@i@@ ; @@v1@@ = * ( _QWORD * * ) @@a1@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; for ( @@result@@ = Number L ; ( unsigned __int64 ) @@v1@@ < @@v2@@ ; @@v1@@ += Number ) { if ( * @@v1@@ ) { @@v4@@ = @@v1@@ [ Number ] ; for ( @@i@@ = Number L ; @@v4@@ ; ++ @@i@@ ) @@v4@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; if ( @@result@@ < @@i@@ ) @@result@@ = @@i@@ ; } } return @@result@@ ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_2051D0 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2051B0 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2051C0 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall file_lines ( __int64 @@a1@@ , int @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned __int64 @@a5@@ , __int64 * @@a6@@ ) { __int64 @@v6@@ ; __int64 @@v8@@ ; __off_t @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; size_t @@v12@@ ; char * @@v13@@ ; __int64 @@v14@@ ; __int64 @@result@@ ; __int64 @@v16@@ ; char * @@v17@@ ; int * @@v18@@ ; __int64 @@v19@@ ; unsigned __int64 @@v21@@ ; char @@s@@ [ Number ] ; unsigned __int64 @@v23@@ ; @@v23@@ = __readfsqword ( Number ) ; @@v21@@ = @@a5@@ ; if ( ! @@a3@@ ) return Number L ; @@v6@@ = @@a3@@ ; @@v8@@ = ( __int64 ) ( @@a5@@ - @@a4@@ ) % Number ; if ( ! @@v8@@ ) @@v8@@ = Number ; @@v9@@ = @@a5@@ - @@v8@@ ; xlseek ( @@a2@@ , @@a5@@ - @@v8@@ , Number , @@a1@@ ) ; @@v10@@ = safe_read ( @@a2@@ , @@s@@ , @@v8@@ ) ; @@v11@@ = @@v10@@ ; if ( @@v10@@ == Number ) { LABEL_19 : @@v16@@ = quote ( @@a1@@ , @@s@@ ) ; @@v17@@ = dcgettext ( Number L , String , Number ) ; @@v18@@ = __errno_location ( ) ; error ( Number , * @@v18@@ , @@v17@@ , @@v16@@ ) ; @@result@@ = Number L ; } else { * @@a6@@ = @@v9@@ + @@v10@@ ; if ( ! @@v10@@ ) goto LABEL_12 ; if ( * ( ( _BYTE * ) & @@v21@@ + @@v10@@ + Number ) != Number ) -- @@v6@@ ; while ( Number ) { @@v12@@ = @@v11@@ ; do { @@v13@@ = ( char * ) memrchr ( @@s@@ , Number , @@v12@@ ) ; if ( ! @@v13@@ ) break ; @@v12@@ = @@v13@@ - @@s@@ ; if ( ! @@v6@@ ) { if ( @@v11@@ - Number != @@v12@@ ) xwrite_stdout_part_5 ( @@v13@@ + Number , @@v11@@ - Number - @@v12@@ ) ; * @@a6@@ += dump_remainder ( @@a1@@ , @@a2@@ , @@v21@@ - @@v11@@ - @@v9@@ ) ; return Number L ; } -- @@v6@@ ; } while ( @@v12@@ ) ; LABEL_12 : if ( @@v9@@ == @@a4@@ ) break ; @@v9@@ -= Number ; xlseek ( @@a2@@ , @@v9@@ , Number , @@a1@@ ) ; @@v14@@ = safe_read ( @@a2@@ , @@s@@ , Number ) ; @@v11@@ = @@v14@@ ; if ( @@v14@@ == Number ) goto LABEL_19 ; * @@a6@@ = @@v9@@ + @@v14@@ ; if ( ! @@v14@@ ) return Number L ; } xlseek ( @@a2@@ , @@v9@@ , Number , @@a1@@ ) ; @@v19@@ = dump_remainder ( @@a1@@ , @@a2@@ , @@v21@@ ) + @@v9@@ ; @@result@@ = Number L ; * @@a6@@ = @@v19@@ ; } return @@result@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
unsigned __int64 __fastcall hash_get_entries ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { _QWORD * @@v3@@ ; unsigned __int64 @@v4@@ ; _QWORD * @@v5@@ ; unsigned __int64 @@result@@ ; @@v3@@ = * ( _QWORD * * ) @@a1@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= * ( _QWORD * ) @@a1@@ ) return Number L ; @@v4@@ = Number L ; while ( ! * @@v3@@ ) { LABEL_9 : @@v3@@ += Number ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= ( unsigned __int64 ) @@v3@@ ) return @@v4@@ ; } if ( @@a3@@ <= @@v4@@ ) return @@v4@@ ; * ( _QWORD * ) ( @@a2@@ + Number * @@v4@@ ) = * @@v3@@ ; @@v5@@ = ( _QWORD * ) @@v3@@ [ Number ] ; @@result@@ = @@v4@@ + Number ; if ( ! @@v5@@ ) { LABEL_8 : @@v4@@ = @@result@@ ; goto LABEL_9 ; } while ( @@a3@@ != @@result@@ ) { ++ @@result@@ ; * ( _QWORD * ) ( @@a2@@ + Number * @@result@@ - Number ) = * @@v5@@ ; @@v5@@ = ( _QWORD * ) @@v5@@ [ Number ] ; if ( ! @@v5@@ ) goto LABEL_8 ; } return @@result@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
__int64 __fastcall open_safer ( const char * @@a1@@ , char @@a2@@ , unsigned int @@a3@@ ) { __int64 @@v3@@ ; int @@v4@@ ; @@v3@@ = Number L ; if ( ( @@a2@@ & Number ) != Number ) @@v3@@ = @@a3@@ ; @@v4@@ = open ( @@a1@@ , @@a2@@ , @@v3@@ ) ; return fd_safer ( @@v4@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void __fastcall xwrite_stdout_part_5 ( const void * @@a1@@ , size_t @@a2@@ ) { char * @@v2@@ ; int * @@v3@@ ; if ( ! fwrite_unlocked ( @@a1@@ , Number , @@a2@@ , stdout ) ) { @@v2@@ = dcgettext ( Number L , String , Number ) ; @@v3@@ = __errno_location ( ) ; error ( Number , * @@v3@@ , @@v2@@ ) ; } }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int64 posix2_version ( ) { unsigned int @@v0@@ ; char * @@v1@@ ; __int64 @@v3@@ ; char * @@v4@@ [ Number ] ; @@v0@@ = Number ; @@v4@@ [ Number ] = ( char * ) __readfsqword ( Number ) ; @@v1@@ = getenv ( String ) ; if ( @@v1@@ ) { if ( * @@v1@@ ) { @@v3@@ = strtol ( @@v1@@ , @@v4@@ , Number ) ; if ( ! * @@v4@@ [ Number ] ) { if ( @@v3@@ < ( __int64 ) Number ) { @@v0@@ = Number ; } else { @@v0@@ = Number ; if ( @@v3@@ <= Number ) @@v0@@ = @@v3@@ ; } } } } return @@v0@@ ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
__int64 __fastcall dump_remainder ( __int64 @@a1@@ , int @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; size_t @@v6@@ ; size_t @@v7@@ ; size_t @@v8@@ ; int * @@v10@@ ; __int64 @@v11@@ ; char * @@v12@@ ; char @@buf@@ [ Number ] ; unsigned __int64 @@v14@@ ; @@v3@@ = @@a3@@ ; @@v4@@ = Number L ; @@v5@@ = @@a3@@ ; @@v14@@ = __readfsqword ( Number ) ; while ( Number ) { @@v6@@ = Number ; if ( @@v5@@ <= Number ) @@v6@@ = @@v5@@ ; @@v7@@ = safe_read ( @@a2@@ , @@buf@@ , @@v6@@ ) ; @@v8@@ = @@v7@@ ; if ( @@v7@@ == Number ) break ; if ( @@v7@@ ) { @@v4@@ += @@v7@@ ; xwrite_stdout_part_5 ( @@buf@@ , @@v7@@ ) ; if ( @@v3@@ == Number ) continue ; @@v5@@ -= @@v8@@ ; if ( @@v5@@ ) { if ( @@v3@@ != Number ) continue ; } } return @@v4@@ ; } @@v10@@ = __errno_location ( ) ; if ( * @@v10@@ != Number ) { @@v11@@ = quote ( @@a1@@ , @@buf@@ ) ; @@v12@@ = dcgettext ( Number L , String , Number ) ; error ( Number , * @@v10@@ , @@v12@@ , @@v11@@ ) ; } return @@v4@@ ; }
__int64 __fastcall _xargmatch_internal ( __int64 @@a1@@ , const char * @@a2@@ , const char * * @@a3@@ , char * @@a4@@ , size_t @@a5@@ , void ( * @@a6@@ ) ( void ) ) { __int64 @@result@@ ; @@result@@ = argmatch ( @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; if ( @@result@@ < Number ) { argmatch_invalid ( @@a1@@ , ( __int64 ) @@a2@@ , @@result@@ ) ; argmatch_valid ( @@a3@@ , @@a4@@ , @@a5@@ ) ; @@a6@@ ( ) ; @@result@@ = Number ; } return @@result@@ ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
__int64 __fastcall make_printable_str ( char * @@a1@@ , __int64 @@a2@@ ) { char * @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; char * @@v5@@ ; char * @@v6@@ ; const char * @@v7@@ ; char @@v8@@ ; unsigned __int8 @@v10@@ ; char @@v11@@ [ Number ] ; unsigned __int64 @@v12@@ ; @@v2@@ = @@a1@@ ; @@v12@@ = __readfsqword ( Number ) ; if ( ! is_mul_ok ( @@a2@@ + Number , Number ) ) xalloc_die ( ) ; @@v3@@ = xmalloc ( Number * ( @@a2@@ + Number ) , @@a2@@ , ( ( unsigned __int64 ) ( @@a2@@ + Number ) * ( unsigned __int128 ) Number ) >> Number ) ; @@v4@@ = @@v3@@ ; if ( @@a2@@ ) { @@v5@@ = & @@a1@@ [ @@a2@@ ] ; @@v6@@ = ( char * ) @@v3@@ ; do { @@v8@@ = * @@v2@@ ; if ( * @@v2@@ == Number ) { @@v7@@ = String ; } else if ( @@v8@@ > Number ) { @@v7@@ = String ; if ( @@v8@@ != Number ) { @@v7@@ = String ; if ( @@v8@@ >= Number ) { @@v7@@ = String ; if ( @@v8@@ != Number ) { @@v7@@ = String ; if ( @@v8@@ != Number ) { LABEL_14 : @@v10@@ = * @@v2@@ ; if ( ( ( * __ctype_b_loc ( ) ) [ @@v10@@ ] & Number ) != Number ) { @@v11@@ [ Number ] = @@v10@@ ; @@v11@@ [ Number ] = Number ; } else { __sprintf_chk ( ) ; } @@v7@@ = @@v11@@ ; goto LABEL_8 ; } } } } } else { @@v7@@ = String ; if ( @@v8@@ != Number ) { @@v7@@ = String ; if ( @@v8@@ <= Number ) { @@v7@@ = String ; if ( @@v8@@ != Number ) goto LABEL_14 ; } } } LABEL_8 : ++ @@v2@@ ; @@v6@@ = stpcpy ( @@v6@@ , @@v7@@ ) ; } while ( @@v5@@ != @@v2@@ ) ; } return @@v4@@ ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
unsigned __int64 __fastcall check_fspec ( __int64 @@a1@@ , int @@a2@@ , _DWORD * @@a3@@ ) { const char * @@v5@@ ; char * @@v6@@ ; char * @@v8@@ ; int * @@v9@@ ; __off_t @@v10@@ ; char * @@v11@@ ; struct stat @@v12@@ ; unsigned __int64 @@v13@@ ; @@v5@@ = * ( const char * * ) @@a1@@ ; @@v13@@ = __readfsqword ( Number ) ; @@v6@@ = pretty_name_isra_2 ( @@v5@@ ) ; if ( __fxstat ( Number , * ( _DWORD * ) ( @@a1@@ + Number ) , & @@v12@@ ) ) { close_fd ( * ( _DWORD * ) ( @@a1@@ + Number ) , ( __int64 ) @@v6@@ ) ; * ( _DWORD * ) ( @@a1@@ + Number ) = Number ; * ( _DWORD * ) ( @@a1@@ + Number ) = * __errno_location ( ) ; return __readfsqword ( Number ) ^ @@v13@@ ; } if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) == Number ) { @@v10@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( @@v12@@ . st_size < @@v10@@ ) { @@v11@@ = dcgettext ( Number L , String , Number ) ; error ( Number , Number , @@v11@@ , @@v6@@ ) ; * @@a3@@ = @@a2@@ ; xlseek ( * ( _DWORD * ) ( @@a1@@ + Number ) , @@v12@@ . st_size , Number , ( __int64 ) @@v6@@ ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v12@@ . st_size ; } else if ( @@v12@@ . st_size == @@v10@@ && @@v12@@ . st_mtim . tv_nsec == * ( _QWORD * ) ( @@a1@@ + Number ) && @@v12@@ . st_mtim . tv_sec == * ( _QWORD * ) ( @@a1@@ + Number ) ) { return __readfsqword ( Number ) ^ @@v13@@ ; } } if ( * @@a3@@ != @@a2@@ ) { if ( print_headers ) { __printf_chk ( ) ; first_file_6680 = Number ; } * @@a3@@ = @@a2@@ ; } * ( _QWORD * ) ( @@a1@@ + Number ) += dump_remainder ( ( __int64 ) @@v6@@ , * ( _DWORD * ) ( @@a1@@ + Number ) , Number ) ; if ( fflush_unlocked ( stdout ) ) { @@v8@@ = dcgettext ( Number L , String , Number ) ; @@v9@@ = __errno_location ( ) ; error ( Number , * @@v9@@ , @@v8@@ ) ; } return __readfsqword ( Number ) ^ @@v13@@ ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_2081D0 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2081B0 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2081C0 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall set_initialize ( _QWORD * @@a1@@ , char @@a2@@ , _BYTE * @@a3@@ ) { __int64 @@result@@ ; _BYTE * @@v5@@ ; @@a1@@ [ Number ] = Number ; while ( Number ) { @@result@@ = get_next ( @@a1@@ , Number L ) ; if ( ( _DWORD ) @@result@@ == Number ) break ; @@a3@@ [ ( int ) @@result@@ ] = Number ; } if ( @@a2@@ ) { @@result@@ = ( __int64 ) ( @@a3@@ + Number ) ; @@v5@@ = @@a3@@ ; do * @@v5@@ ++ ^= Number ; while ( @@v5@@ != ( _BYTE * ) @@result@@ ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
_BYTE * __fastcall mdir_name ( void * @@src@@ ) { __int64 @@v1@@ ; _BYTE * @@v2@@ ; _BYTE * @@v3@@ ; _BYTE * @@v4@@ ; @@v1@@ = dir_len ( @@src@@ ) ; @@v2@@ = malloc ( @@v1@@ + ( @@v1@@ == Number ) + Number ) ; @@v3@@ = @@v2@@ ; if ( @@v2@@ ) { @@v4@@ = memcpy ( @@v2@@ , @@src@@ , @@v1@@ ) ; @@v3@@ = @@v4@@ ; if ( ! @@v1@@ ) { * @@v4@@ = Number ; @@v1@@ = Number L ; } @@v4@@ [ @@v1@@ ] = Number ; } return @@v3@@ ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
void __fastcall record_file ( __int64 @@a1@@ , void * @@a2@@ , _QWORD * @@a3@@ ) { _QWORD * @@v4@@ ; __int64 @@v5@@ ; if ( @@a1@@ ) { @@v4@@ = xmalloc ( Number ) ; * @@v4@@ = xstrdup ( @@a2@@ ) ; @@v4@@ [ Number ] = @@a3@@ [ Number ] ; @@v4@@ [ Number ] = * @@a3@@ ; @@v5@@ = hash_insert ( @@a1@@ , ( __int64 ) @@v4@@ ) ; if ( ! @@v5@@ ) xalloc_die ( ) ; if ( @@v4@@ != ( _QWORD * ) @@v5@@ ) triple_free ( @@v4@@ ) ; } }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall same_name ( _BYTE * @@a1@@ , _BYTE * @@a2@@ ) { unsigned int @@v2@@ ; const char * @@v3@@ ; const char * @@v4@@ ; size_t @@v5@@ ; char * @@v7@@ ; char * @@v8@@ ; int * @@v9@@ ; int * @@v10@@ ; struct stat @@v11@@ ; struct stat @@stat_buf@@ ; unsigned __int64 @@v13@@ ; @@v2@@ = Number ; @@v13@@ = __readfsqword ( Number ) ; @@v3@@ = last_component ( @@a1@@ ) ; @@v4@@ = last_component ( @@a2@@ ) ; @@v5@@ = base_len ( @@v3@@ ) ; if ( @@v5@@ == base_len ( @@v4@@ ) && ! memcmp ( @@v3@@ , @@v4@@ , @@v5@@ ) ) { @@v7@@ = ( char * ) dir_name ( @@a1@@ ) ; @@v8@@ = ( char * ) dir_name ( @@a2@@ ) ; if ( __xstat ( Number , @@v7@@ , & @@v11@@ ) ) { @@v10@@ = __errno_location ( ) ; error ( Number , * @@v10@@ , String , @@v7@@ ) ; } if ( __xstat ( Number , @@v8@@ , & @@stat_buf@@ ) ) { @@v9@@ = __errno_location ( ) ; error ( Number , * @@v9@@ , String , @@v8@@ ) ; } @@v2@@ = Number ; if ( @@v11@@ . st_ino == @@stat_buf@@ . st_ino ) LOBYTE ( @@v2@@ ) = @@v11@@ . st_dev == @@stat_buf@@ . st_dev ; free ( @@v7@@ ) ; free ( @@v8@@ ) ; } return @@v2@@ ; }
__int64 __fastcall hash_find_entry ( __int64 * @@a1@@ , __int64 @@a2@@ , __m128i * * @@a3@@ , char @@a4@@ ) { __int64 @@v5@@ ; __m128i * @@v8@@ ; __int64 @@v9@@ ; __int64 * @@v10@@ ; const __m128i * @@v12@@ ; @@v5@@ = * @@a1@@ ; @@v8@@ = ( __m128i * ) ( Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) + @@v5@@ ) ; if ( @@a1@@ [ Number ] <= ( unsigned __int64 ) @@v8@@ ) abort ( ) ; * @@a3@@ = @@v8@@ ; @@v9@@ = @@v8@@ -> m128i_i64 [ Number ] ; if ( @@v8@@ -> m128i_i64 [ Number ] ) { if ( @@v9@@ != @@a2@@ ) { if ( ! ( ( unsigned __int8 ( __fastcall * ) ( __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ ) ) { @@v10@@ = ( __int64 * ) @@v8@@ -> m128i_i64 [ Number ] ; if ( @@v10@@ ) { @@v9@@ = * @@v10@@ ; if ( @@a2@@ != * @@v10@@ ) { while ( ! ( ( unsigned __int8 ( __fastcall * ) ( __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ ) ) { @@v8@@ = ( __m128i * ) @@v8@@ -> m128i_i64 [ Number ] ; @@v10@@ = ( __int64 * ) @@v8@@ -> m128i_i64 [ Number ] ; if ( ! @@v10@@ ) return Number L ; @@v9@@ = * @@v10@@ ; if ( * @@v10@@ == @@a2@@ ) goto LABEL_12 ; } @@v10@@ = ( __int64 * ) @@v8@@ -> m128i_i64 [ Number ] ; @@v9@@ = * @@v10@@ ; } LABEL_12 : if ( @@a4@@ ) { @@v8@@ -> m128i_i64 [ Number ] = @@v10@@ [ Number ] ; * @@v10@@ = Number L ; @@v10@@ [ Number ] = @@a1@@ [ Number ] ; @@a1@@ [ Number ] = ( __int64 ) @@v10@@ ; } return @@v9@@ ; } return Number L ; } @@v9@@ = @@v8@@ -> m128i_i64 [ Number ] ; } if ( @@a4@@ ) { @@v12@@ = ( const __m128i * ) @@v8@@ -> m128i_i64 [ Number ] ; if ( @@v12@@ ) { * @@v8@@ = _mm_loadu_si128 ( @@v12@@ ) ; @@v12@@ -> m128i_i64 [ Number ] = Number L ; @@v12@@ -> m128i_i64 [ Number ] = @@a1@@ [ Number ] ; @@a1@@ [ Number ] = ( __int64 ) @@v12@@ ; return @@v9@@ ; } @@v8@@ -> m128i_i64 [ Number ] = Number L ; } return @@v9@@ ; } return Number L ; }
int __fastcall argmatch_valid ( _QWORD * @@a1@@ , char * @@a2@@ , size_t @@a3@@ ) { const void * @@v5@@ ; __int64 @@v6@@ ; char * @@v7@@ ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; if ( * @@a1@@ ) { @@v5@@ = Number L ; @@v6@@ = Number L ; do { while ( ! @@v6@@ || memcmp ( @@v5@@ , @@a2@@ , @@a3@@ ) ) { ++ @@v6@@ ; @@v5@@ = @@a2@@ ; __fprintf_chk ( ) ; @@a2@@ += @@a3@@ ; if ( ! @@a1@@ [ @@v6@@ ] ) goto LABEL_7 ; } ++ @@v6@@ ; @@a2@@ += @@a3@@ ; __fprintf_chk ( ) ; } while ( @@a1@@ [ @@v6@@ ] ) ; } LABEL_7 : @@v7@@ = stderr -> _IO_write_ptr ; if ( @@v7@@ >= stderr -> _IO_write_end ) { LODWORD ( @@v7@@ ) = __overflow ( stderr , Number ) ; } else { stderr -> _IO_write_ptr = @@v7@@ + Number ; * @@v7@@ = Number ; } return ( int ) @@v7@@ ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
__int64 __fastcall hash_do_for_each ( __int64 @@a1@@ , unsigned __int8 ( __fastcall * @@a2@@ ) ( __int64 , __int64 ) , __int64 @@a3@@ ) { __int64 * @@v3@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 * @@v8@@ ; @@v3@@ = * ( __int64 * * ) @@a1@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= * ( _QWORD * ) @@a1@@ ) return Number L ; @@v6@@ = Number L ; while ( Number ) { @@v7@@ = * @@v3@@ ; if ( * @@v3@@ ) break ; LABEL_8 : @@v3@@ += Number ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= ( unsigned __int64 ) @@v3@@ ) return @@v6@@ ; } @@v8@@ = @@v3@@ ; while ( @@a2@@ ( @@v7@@ , @@a3@@ ) ) { @@v8@@ = ( __int64 * ) @@v8@@ [ Number ] ; ++ @@v6@@ ; if ( ! @@v8@@ ) goto LABEL_8 ; @@v7@@ = * @@v8@@ ; } return @@v6@@ ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
__int64 __fastcall rpl_fcntl ( int @@a1@@ , int @@a2@@ , __int64 @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { int @@v6@@ ; int @@v8@@ ; int @@v9@@ ; int @@v10@@ ; int @@v11@@ ; int * @@v12@@ ; int @@v13@@ ; int * @@v14@@ ; int @@v15@@ ; @@v15@@ = @@a3@@ ; if ( @@a2@@ != Number ) return ( unsigned int ) fcntl ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( have_dupfd_cloexec_3202 < Number ) { @@v6@@ = ( ( __int64 ( __fastcall * ) ( int , _DWORD , _DWORD , int , int , int , char ) ) rpl_fcntl ) ( @@a1@@ , Number , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ , Number ) ; if ( @@v6@@ < Number || have_dupfd_cloexec_3202 != Number ) return ( unsigned int ) @@v6@@ ; } else { @@v6@@ = fcntl ( @@a1@@ , Number , ( unsigned int ) @@a3@@ ) ; if ( @@v6@@ >= Number || * __errno_location ( ) != Number ) { have_dupfd_cloexec_3202 = Number ; return ( unsigned int ) @@v6@@ ; } @@v6@@ = ( ( __int64 ( __fastcall * ) ( int , _DWORD , int , int , int , int , char ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v15@@ , @@v8@@ , @@v9@@ , @@v10@@ , Number ) ; if ( @@v6@@ < Number ) return ( unsigned int ) @@v6@@ ; have_dupfd_cloexec_3202 = Number ; } @@v11@@ = fcntl ( @@v6@@ , Number ) ; if ( @@v11@@ < Number || fcntl ( @@v6@@ , Number , @@v11@@ | Number ) == Number ) { @@v12@@ = __errno_location ( ) ; @@v13@@ = * @@v12@@ ; @@v14@@ = @@v12@@ ; close ( @@v6@@ ) ; @@v6@@ = Number ; * @@v14@@ = @@v13@@ ; } return ( unsigned int ) @@v6@@ ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
__int64 __fastcall offtostr ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; __int64 @@result@@ ; int @@v4@@ ; bool @@v5@@ ; @@v2@@ = @@a2@@ + Number ; * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; if ( @@a1@@ < Number ) { while ( Number ) { @@v4@@ = Number * ( @@a1@@ / Number ) + Number - @@a1@@ ; @@v5@@ = ( __int64 ) ( ( unsigned __int128 ) ( Number * ( __int128 ) @@a1@@ ) >> Number ) >> Number == @@a1@@ >> Number ; @@a1@@ /= Number L ; * ( _BYTE * ) ( @@v2@@ - Number ) = @@v4@@ ; if ( @@v5@@ ) break ; -- @@v2@@ ; } * ( _BYTE * ) ( @@v2@@ - Number ) = Number ; @@result@@ = @@v2@@ - Number ; } else { do { * ( _BYTE * ) -- @@v2@@ = @@a1@@ % Number + Number ; @@a1@@ /= Number ; } while ( @@a1@@ ) ; @@result@@ = @@v2@@ ; } return @@result@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
__int64 __fastcall hash_print_statistics ( __int64 @@a1@@ ) { unsigned __int64 @@v1@@ ; _QWORD * @@v2@@ ; unsigned __int64 @@i@@ ; __int64 @@v4@@ ; unsigned __int64 @@j@@ ; @@v1@@ = Number L ; @@v2@@ = * ( _QWORD * * ) @@a1@@ ; for ( @@i@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; ( unsigned __int64 ) @@v2@@ < @@i@@ ; @@v2@@ += Number ) { if ( * @@v2@@ ) { @@v4@@ = @@v2@@ [ Number ] ; for ( @@j@@ = Number L ; @@v4@@ ; ++ @@j@@ ) @@v4@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; if ( @@v1@@ < @@j@@ ) @@v1@@ = @@j@@ ; } } __fprintf_chk ( ) ; __fprintf_chk ( ) ; __fprintf_chk ( ) ; return __fprintf_chk ( ) ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
__int64 __fastcall dup_safer ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number L , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 __fastcall hash_get_first ( __int64 @@a1@@ ) { __int64 * @@v1@@ ; unsigned __int64 @@v2@@ ; __int64 @@result@@ ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; @@v1@@ = * ( __int64 * * ) @@a1@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( * ( _QWORD * ) @@a1@@ >= @@v2@@ ) goto LABEL_9 ; @@result@@ = * @@v1@@ ; if ( ! * @@v1@@ ) { while ( Number ) { @@v1@@ += Number ; if ( ( unsigned __int64 ) @@v1@@ >= @@v2@@ ) break ; @@result@@ = * @@v1@@ ; if ( * @@v1@@ ) return @@result@@ ; } LABEL_9 : abort ( ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
int __xstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _xstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
ssize_t __fastcall safe_read ( int @@fd@@ , void * @@buf@@ , size_t @@nbytes@@ ) { ssize_t @@v4@@ ; int @@v5@@ ; while ( Number ) { @@v4@@ = read ( @@fd@@ , @@buf@@ , @@nbytes@@ ) ; if ( @@v4@@ >= Number ) break ; @@v5@@ = * __errno_location ( ) ; if ( @@v5@@ != Number ) { if ( @@nbytes@@ <= Number || @@v5@@ != Number ) return @@v4@@ ; @@nbytes@@ = Number L ; } } return @@v4@@ ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; __int64 @@v14@@ ; __int64 @@v15@@ ; __int64 @@v16@@ ; __int64 @@v17@@ ; unsigned __int64 @@v18@@ ; _BYTE * @@v19@@ ; unsigned __int64 @@v22@@ ; int @@v23@@ ; int @@v24@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v23@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v24@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v22@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v24@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v22@@ <= @@v13@@ ) { @@v18@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v19@@ = ( _BYTE * ) xmalloc ( @@v18@@ , @@v18@@ , @@v14@@ , @@v15@@ , @@v16@@ , @@v17@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v19@@ ; @@v12@@ = @@v19@@ ; quotearg_buffer_restyled ( @@v19@@ , @@v18@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v24@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v23@@ ; return @@v12@@ ; }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
_QWORD * __fastcall hash_initialize ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 ( __fastcall * @@a3@@ ) ( __int64 a1 , unsigned __int64 a2 ) , bool ( __fastcall * @@a4@@ ) ( __int64 a1 , __int64 a2 ) , __int64 @@a5@@ ) { unsigned __int64 ( __fastcall * @@v5@@ ) ( __int64 , unsigned __int64 ) ; bool ( __fastcall * @@v6@@ ) ( __int64 , __int64 ) ; char * @@v9@@ ; _QWORD * @@v10@@ ; float * * @@v11@@ ; float @@v12@@ ; float @@v13@@ ; float @@v14@@ ; unsigned __int64 @@v15@@ ; char * @@v16@@ ; void * @@v17@@ ; @@v5@@ = @@a3@@ ; @@v6@@ = @@a4@@ ; if ( ! @@a3@@ ) @@v5@@ = raw_hasher ; if ( ! @@a4@@ ) @@v6@@ = raw_comparator ; @@v9@@ = ( char * ) malloc ( Number ) ; @@v10@@ = @@v9@@ ; if ( @@v9@@ ) { @@v11@@ = ( float * * ) ( @@v9@@ + Number ) ; if ( @@a2@@ ) { * ( ( _QWORD * ) @@v9@@ + Number ) = @@a2@@ ; if ( ! ( unsigned __int8 ) check_tuning_isra_0 ( @@v11@@ ) ) goto LABEL_20 ; if ( * ( _BYTE * ) ( @@a2@@ + Number ) ) { LABEL_15 : @@v15@@ = next_prime ( @@a1@@ ) ; if ( @@v15@@ <= Number ) { @@v10@@ [ Number ] = @@v15@@ ; if ( @@v15@@ ) { @@v16@@ = ( char * ) calloc ( @@v15@@ , Number ) ; * @@v10@@ = @@v16@@ ; if ( @@v16@@ ) { @@v10@@ [ Number ] = Number L ; @@v10@@ [ Number ] = Number L ; @@v10@@ [ Number ] = @@v5@@ ; @@v10@@ [ Number ] = @@v6@@ ; @@v10@@ [ Number ] = & @@v16@@ [ Number * @@v15@@ ] ; @@v10@@ [ Number ] = @@a5@@ ; @@v10@@ [ Number ] = Number L ; return @@v10@@ ; } } } LABEL_20 : @@v17@@ = @@v10@@ ; @@v10@@ = Number L ; free ( @@v17@@ ) ; return @@v10@@ ; } @@v12@@ = * ( float * ) ( @@a2@@ + Number ) ; } else { * ( ( _QWORD * ) @@v9@@ + Number ) = & default_tuning ; @@v12@@ = Number ; if ( ! ( unsigned __int8 ) check_tuning_isra_0 ( @@v11@@ ) ) goto LABEL_20 ; } if ( @@a1@@ < Number ) @@v13@@ = ( float ) ( @@a1@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@a1@@ >> Number ) ) + ( float ) ( @@a1@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@a1@@ >> Number ) ) ; else @@v13@@ = ( float ) ( int ) @@a1@@ ; @@v14@@ = @@v13@@ / @@v12@@ ; if ( @@v14@@ >= Number ) goto LABEL_20 ; if ( @@v14@@ < Number ) @@a1@@ = ( unsigned int ) ( int ) @@v14@@ ; else @@a1@@ = ( unsigned int ) ( int ) ( float ) ( @@v14@@ - Number ) ^ Number ; goto LABEL_15 ; } return @@v10@@ ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
char __fastcall two_arguments ( ) { bool @@v0@@ ; bool @@v1@@ ; const char * @@v2@@ ; __int64 @@v3@@ ; const char * @@v4@@ ; __int64 @@v5@@ ; const char * @@v6@@ ; __int64 @@v7@@ ; char @@result@@ ; _BYTE * @@v9@@ ; @@v2@@ = String ; @@v3@@ = Number L ; @@v4@@ = * ( const char * * ) ( argv + Number L * pos ) ; @@v5@@ = Number L * pos ; @@v6@@ = @@v4@@ ; do { if ( ! @@v3@@ ) break ; @@v0@@ = * @@v6@@ < ( unsigned int ) * @@v2@@ ; @@v1@@ = * @@v6@@ ++ == * @@v2@@ ++ ; -- @@v3@@ ; } while ( @@v1@@ ) ; if ( ( ! @@v0@@ && ! @@v1@@ ) == @@v0@@ ) { @@v9@@ = * ( _BYTE * * ) ( argv + @@v5@@ + Number ) ; pos += Number ; @@result@@ = * @@v9@@ == Number ; } else { if ( * @@v4@@ != Number || ! @@v4@@ [ Number ] || @@v4@@ [ Number ] ) beyond ( @@v2@@ , @@v6@@ , pos , @@v3@@ , argv , @@v5@@ ) ; @@v7@@ = * ( _QWORD * ) ( argv + Number L * pos ) ; if ( ! test_unop_part_1 ( @@v7@@ ) ) { dcgettext ( Number L , String , Number ) ; test_syntax_error ( ) ; } @@result@@ = unary_operator ( @@v7@@ , @@v6@@ ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; int @@v13@@ ; _BYTE * @@v14@@ ; __int64 @@v15@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v13@@ = * @@v6@@ ; @@v15@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v14@@ = ( _BYTE * ) xmalloc ( @@v15@@ + Number , @@v15@@ + Number , @@v8@@ , @@v9@@ , @@v10@@ , @@v11@@ ) ; quotearg_buffer_restyled ( @@v14@@ , @@v15@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v13@@ ; if ( @@a3@@ ) * @@a3@@ = @@v15@@ ; return @@v14@@ ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
int __cdecl main ( int argc , const char * * argv , const char * * envp ) { __int64 @@v4@@ ; unsigned int @@v5@@ ; init_student ( @@v4@@ , @@v5@@ ) ; printf ( String , ( unsigned int ) @@v4@@ , ( unsigned int ) SBYTE4 ( @@v4@@ ) , @@v5@@ ) ; modify ( @@v4@@ , @@v5@@ ) ; printf ( String , ( unsigned int ) @@v4@@ , ( unsigned int ) SBYTE4 ( @@v4@@ ) , @@v5@@ ) ; return Number ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_20E250 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20E230 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20E240 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) _frame_dummy_init_array_entry [ @@i@@ ] ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
char __fastcall different ( const void * @@a1@@ , const void * @@a2@@ , size_t @@a3@@ , size_t @@a4@@ ) { char @@result@@ ; if ( check_chars <= @@a3@@ ) @@a3@@ = check_chars ; if ( check_chars <= @@a4@@ ) @@a4@@ = check_chars ; @@result@@ = ignore_case ; if ( ignore_case ) { if ( @@a3@@ == @@a4@@ ) @@result@@ = ( unsigned int ) memcasecmp ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a3@@ ) != Number ; } else if ( hard_LC_COLLATE ) { @@result@@ = ( unsigned int ) xmemcoll ( @@a1@@ , @@a3@@ , @@a2@@ , @@a4@@ ) != Number ; } else { @@result@@ = Number ; if ( @@a3@@ == @@a4@@ ) @@result@@ = memcmp ( @@a1@@ , @@a2@@ , @@a3@@ ) != Number ; } return @@result@@ ; }
int __fastcall rpl_nanosleep ( __time_t * @@a1@@ , struct timespec * @@a2@@ ) { __time_t @@v2@@ ; int @@result@@ ; __syscall_slong_t @@v4@@ ; __time_t @@v5@@ ; bool @@v6@@ ; __syscall_slong_t @@v7@@ ; struct timespec @@v8@@ ; unsigned __int64 @@v9@@ ; @@v2@@ = * @@a1@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v8@@ . tv_nsec = Number L ; if ( @@v2@@ > Number ) { while ( Number ) { @@v8@@ . tv_sec = Number L ; @@v2@@ -= Number L ; @@result@@ = nanosleep ( & @@v8@@ , @@a2@@ ) ; if ( @@result@@ ) break ; if ( @@v2@@ <= Number ) goto LABEL_8 ; } if ( @@a2@@ ) { @@v4@@ = @@a2@@ -> tv_nsec + @@a1@@ [ Number ] ; @@v5@@ = @@a2@@ -> tv_sec + @@v2@@ ; @@a2@@ -> tv_nsec = @@v4@@ ; @@v6@@ = @@a1@@ [ Number ] <= Number ; @@a2@@ -> tv_sec = @@v5@@ ; if ( ! @@v6@@ ) { @@a2@@ -> tv_sec = @@v5@@ + Number ; @@a2@@ -> tv_nsec = @@v4@@ - Number ; } } } else { LABEL_8 : @@v7@@ = @@a1@@ [ Number ] ; @@v8@@ . tv_sec = @@v2@@ ; @@v8@@ . tv_nsec = @@v7@@ ; @@result@@ = nanosleep ( & @@v8@@ , @@a2@@ ) ; } return @@result@@ ; }
__int64 __fastcall star_digits_closebracket ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; __int64 @@result@@ ; __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; __int64 @@v6@@ ; int @@v7@@ ; @@v2@@ = * @@a1@@ ; @@result@@ = Number L ; if ( * ( _BYTE * ) ( * @@a1@@ + @@a2@@ ) == Number ) { @@v4@@ = @@a1@@ [ Number ] ; if ( ! * ( _BYTE * ) ( @@v4@@ + @@a2@@ ) ) { @@v5@@ = @@a1@@ [ Number ] ; @@v6@@ = @@a2@@ + Number ; if ( @@a2@@ + Number < @@v5@@ ) { @@v7@@ = * ( unsigned __int8 * ) ( @@v2@@ + @@a2@@ + Number ) ; if ( ( unsigned int ) ( @@v7@@ - Number ) > Number ) { LABEL_12 : @@result@@ = Number L ; if ( ( _BYTE ) @@v7@@ == Number ) @@result@@ = * ( unsigned __int8 * ) ( @@v4@@ + @@v6@@ ) ^ Number ; } else { @@result@@ = * ( unsigned __int8 * ) ( @@v4@@ + @@a2@@ + Number ) ; if ( ( _BYTE ) @@result@@ ) { @@result@@ = Number L ; } else { do { if ( ++ @@v6@@ >= @@v5@@ ) break ; @@v7@@ = * ( unsigned __int8 * ) ( @@v2@@ + @@v6@@ ) ; if ( ( unsigned int ) ( @@v7@@ - Number ) > Number ) goto LABEL_12 ; } while ( ! * ( _BYTE * ) ( @@v4@@ + @@v6@@ ) ) ; } } } } } return @@result@@ ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
int isatty ( int @@fd@@ ) { return isatty ( @@fd@@ ) ; }
_QWORD * __fastcall readlinebuffer_delim ( _QWORD * @@a1@@ , _IO_FILE * @@a2@@ , char @@a3@@ ) { __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ ; int @@v7@@ ; char * @@v8@@ ; int @@v9@@ ; char @@v10@@ ; _BYTE * @@v11@@ ; __int64 @@v12@@ ; __int64 @@v13@@ ; __int64 @@v14@@ ; char * @@v15@@ ; _QWORD * @@result@@ ; int @@v17@@ ; char @@v18@@ ; __int64 @@v19@@ ; char @@v20@@ ; char @@v21@@ ; @@v3@@ = @@a1@@ [ Number ] ; @@v4@@ = @@v3@@ + * @@a1@@ ; if ( ( @@a2@@ -> _flags & Number ) == Number ) { @@v6@@ = @@a1@@ [ Number ] ; @@v7@@ = @@a3@@ ; while ( Number ) { @@v8@@ = @@a2@@ -> _IO_read_ptr ; if ( @@v8@@ >= @@a2@@ -> _IO_read_end ) { @@v21@@ = @@a3@@ ; @@v19@@ = @@v4@@ ; @@v17@@ = __uflow ( @@a2@@ ) ; @@v9@@ = @@v17@@ ; @@v4@@ = @@v19@@ ; @@a3@@ = @@v21@@ ; if ( @@v17@@ == Number ) { if ( @@v3@@ == @@v6@@ || ( @@a2@@ -> _flags & Number ) != Number ) return Number L ; if ( * ( _BYTE * ) ( @@v6@@ - Number ) == @@v21@@ ) { LABEL_8 : @@result@@ = @@a1@@ ; @@a1@@ [ Number ] = @@v6@@ - @@v3@@ ; return @@result@@ ; } @@v9@@ = @@v7@@ ; @@v10@@ = @@v21@@ ; } else { @@v10@@ = @@v17@@ ; } } else { @@a2@@ -> _IO_read_ptr = @@v8@@ + Number ; @@v9@@ = ( unsigned __int8 ) * @@v8@@ ; @@v10@@ = * @@v8@@ ; } @@v11@@ = ( _BYTE * ) @@v6@@ ; if ( @@v6@@ == @@v4@@ ) { @@v12@@ = * @@a1@@ ; @@v20@@ = @@a3@@ ; @@v18@@ = @@v10@@ ; @@v13@@ = x2realloc ( @@v3@@ , @@a1@@ ) ; @@v14@@ = * @@a1@@ ; @@v15@@ = ( char * ) ( @@v13@@ + @@v12@@ ) ; @@a1@@ [ Number ] = @@v13@@ ; @@v3@@ = @@v13@@ ; @@a3@@ = @@v20@@ ; @@v6@@ = @@v13@@ + @@v12@@ + Number ; @@v4@@ = @@v13@@ + @@v14@@ ; * @@v15@@ = @@v18@@ ; if ( @@v9@@ == @@v7@@ ) goto LABEL_8 ; } else { ++ @@v6@@ ; * @@v11@@ = @@v10@@ ; if ( @@v9@@ == @@v7@@ ) goto LABEL_8 ; } } } return Number L ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
int __lxstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _lxstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
__int64 __fastcall append_normal_char ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@result@@ ; __int64 @@v4@@ ; @@result@@ = xmalloc ( Number L , @@a2@@ , @@a3@@ ) ; @@v4@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@result@@ + Number ) = Number L ; * ( _DWORD * ) @@result@@ = Number ; * ( _BYTE * ) ( @@result@@ + Number ) = @@a2@@ ; if ( ! @@v4@@ ) __assert_fail ( String , String , Number , String ) ; * ( _QWORD * ) ( @@v4@@ + Number ) = @@result@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@result@@ ; return @@result@@ ; }
int __cdecl __noreturn main ( int @@argc@@ , const char * * @@argv@@ , const char * * envp ) { unsigned __int8 @@v3@@ ; __int64 @@v4@@ ; char * @@v5@@ ; set_program_name ( * @@argv@@ ) ; setlocale ( Number , String ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; exit_failure = Number ; atexit ( close_stdout ) ; argv = ( __int64 ) @@argv@@ ; argc = @@argc@@ ; pos = Number ; if ( @@argc@@ > Number ) { @@v3@@ = posixtest ( ( unsigned int ) ( @@argc@@ - Number ) ) ; if ( pos != argc ) { @@v4@@ = quote ( * ( _QWORD * ) ( argv + Number L * pos ) ) ; @@v5@@ = dcgettext ( Number L , String , Number ) ; test_syntax_error ( @@v5@@ , @@v4@@ ) ; } exit ( @@v3@@ ^ Number ) ; } exit ( Number ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
int fflush_unlocked ( FILE * @@stream@@ ) { return fflush_unlocked ( @@stream@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
bool __fastcall binop ( const char * @@a1@@ ) { bool @@result@@ ; @@result@@ = Number ; if ( strcmp ( @@a1@@ , String ) && strcmp ( @@a1@@ , String ) && strcmp ( @@a1@@ , String ) && strcmp ( @@a1@@ , String ) && strcmp ( @@a1@@ , String ) && strcmp ( @@a1@@ , String ) && strcmp ( @@a1@@ , String ) && strcmp ( @@a1@@ , String ) && strcmp ( @@a1@@ , String ) ) { if ( strcmp ( @@a1@@ , String ) ) @@result@@ = strcmp ( @@a1@@ , String ) == Number ; } return @@result@@ ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
struct tm * localtime ( const time_t * @@timer@@ ) { return localtime ( @@timer@@ ) ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
void __fastcall argmatch_invalid ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { char * @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; if ( @@a3@@ == Number ) @@v3@@ = dcgettext ( Number L , String , Number ) ; else @@v3@@ = dcgettext ( Number L , String , Number ) ; @@v4@@ = quote_n ( Number L , @@a1@@ ) ; @@v5@@ = quotearg_n_style ( Number L , Number L , @@a2@@ ) ; error ( Number , Number , @@v3@@ , @@v5@@ , @@v4@@ ) ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
int __xstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _xstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
int unsetenv ( const char * @@name@@ ) { return unsetenv ( @@name@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
__int64 __fastcall memcasecmp ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { const __int32_t * * @@v4@@ ; __int64 @@v5@@ ; const __int32_t * @@v6@@ ; __int64 @@result@@ ; if ( ! @@a3@@ ) return Number L ; @@v4@@ = __ctype_toupper_loc ( ) ; @@v5@@ = Number L ; @@v6@@ = * @@v4@@ ; do { @@result@@ = ( unsigned int ) ( @@v6@@ [ * ( unsigned __int8 * ) ( @@a1@@ + @@v5@@ ) ] - @@v6@@ [ * ( unsigned __int8 * ) ( @@a2@@ + @@v5@@ ) ] ) ; if ( ( _DWORD ) @@result@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != @@a3@@ ) ; return @@result@@ ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_2071D0 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2071B0 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2071C0 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; program_invocation_short_name = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_20B4D0 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20B4B0 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20B4C0 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall argmatch_to_argument ( void * @@s1@@ , __int64 * @@a2@@ , char * @@a3@@ , size_t @@a4@@ ) { __int64 @@v4@@ ; __int64 * @@v7@@ ; @@v4@@ = * @@a2@@ ; if ( * @@a2@@ ) { @@v7@@ = @@a2@@ + Number ; do { if ( ! memcmp ( @@s1@@ , @@a3@@ , @@a4@@ ) ) break ; @@v4@@ = * @@v7@@ ; @@a3@@ += @@a4@@ ; ++ @@v7@@ ; } while ( @@v4@@ ) ; } return @@v4@@ ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
char * nl_langinfo ( nl_item @@item@@ ) { return nl_langinfo ( @@item@@ ) ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 __fastcall umaxtostr ( unsigned __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; @@v2@@ = @@a2@@ + Number ; * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; do { * ( _BYTE * ) -- @@v2@@ = @@a1@@ % Number + Number ; @@a1@@ /= Number ; } while ( @@a1@@ ) ; return @@v2@@ ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
__int64 __fastcall year_isra_0 ( int * @@a1@@ , int * @@a2@@ , __int64 @@a3@@ , char @@a4@@ ) { __int64 @@result@@ ; struct tm * @@v5@@ ; int @@v6@@ ; time_t @@v7@@ ; unsigned __int64 @@v8@@ ; @@v8@@ = __readfsqword ( Number ) ; if ( @@a3@@ == Number ) { @@v6@@ = * @@a2@@ ; @@result@@ = Number L ; * @@a1@@ = * @@a2@@ ; if ( * @@a2@@ > Number ) return @@result@@ ; if ( ( @@a4@@ & Number ) == Number ) { * @@a1@@ = @@v6@@ + Number ; return @@result@@ ; } return Number L ; } if ( ! @@a3@@ ) { time ( & @@v7@@ ) ; @@v5@@ = localtime ( & @@v7@@ ) ; if ( @@v5@@ ) { * @@a1@@ = @@v5@@ -> tm_year ; return Number L ; } return Number L ; } if ( @@a3@@ != Number ) abort ( ) ; if ( ( @@a4@@ & Number ) == Number ) return Number L ; * @@a1@@ = @@a2@@ [ Number ] + Number * * @@a2@@ - Number ; return Number L ; }
__int64 __fastcall show_date ( char * @@a1@@ , time_t @@a2@@ , __int64 @@a3@@ ) { struct tm * @@v3@@ ; struct tm * @@v4@@ ; char * @@v5@@ ; unsigned int @@v6@@ ; __int64 @@v8@@ ; char * @@v9@@ ; struct tm * @@v10@@ ; time_t @@timer@@ ; __int64 @@v12@@ ; char @@v13@@ [ Number ] ; unsigned __int64 @@v14@@ ; @@timer@@ = @@a2@@ ; @@v12@@ = @@a3@@ ; @@v14@@ = __readfsqword ( Number ) ; @@v3@@ = localtime ( & @@timer@@ ) ; if ( @@v3@@ ) { @@v4@@ = @@v3@@ ; if ( @@a1@@ == String ) { @@v10@@ = @@v3@@ ; setlocale ( Number , String ) ; @@v4@@ = @@v10@@ ; } fprintftime ( stdout , @@a1@@ , @@v4@@ , Number L , ( unsigned int ) @@v12@@ ) ; @@v5@@ = stdout -> _IO_write_ptr ; if ( @@v5@@ >= stdout -> _IO_write_end ) { __overflow ( stdout , Number ) ; } else { stdout -> _IO_write_ptr = @@v5@@ + Number ; * @@v5@@ = Number ; } @@v6@@ = Number ; if ( @@a1@@ == String ) setlocale ( Number , String ) ; } else { @@v6@@ = Number ; @@v8@@ = imaxtostr ( @@timer@@ , @@v13@@ ) ; @@v9@@ = dcgettext ( Number L , String , Number ) ; error ( Number , Number , @@v9@@ , @@v8@@ ) ; } return @@v6@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
int clock_gettime ( clockid_t @@clock_id@@ , struct timespec * @@tp@@ ) { return clock_gettime ( @@clock_id@@ , @@tp@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
time_t time ( time_t * @@timer@@ ) { return time ( @@timer@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
char * * __fastcall lookup_zone ( __int64 @@a1@@ , const char * @@a2@@ ) { const char * @@v3@@ ; char * * @@v4@@ ; const char * @@v6@@ ; const char * * @@v7@@ ; const char * @@v8@@ ; @@v3@@ = String ; @@v4@@ = & universal_time_zone_table ; do { if ( ! strcmp ( @@a2@@ , @@v3@@ ) ) return @@v4@@ ; @@v4@@ += Number ; @@v3@@ = * @@v4@@ ; } while ( * @@v4@@ ) ; @@v6@@ = * ( const char * * ) ( @@a1@@ + Number ) ; @@v7@@ = ( const char * * ) ( @@a1@@ + Number ) ; if ( ! @@v6@@ ) { LABEL_6 : @@v4@@ = & time_zone_table ; @@v8@@ = String ; while ( strcmp ( @@a2@@ , @@v8@@ ) ) { @@v4@@ += Number ; @@v8@@ = * @@v4@@ ; if ( ! * @@v4@@ ) return Number L ; } return @@v4@@ ; } while ( strcmp ( @@a2@@ , @@v6@@ ) ) { @@v7@@ += Number ; @@v6@@ = * @@v7@@ ; if ( ! * @@v7@@ ) goto LABEL_6 ; } return ( char * * ) @@v7@@ ; }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
time_t mktime ( struct tm * @@tp@@ ) { return mktime ( @@tp@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
int fileno ( FILE * @@stream@@ ) { return fileno ( @@stream@@ ) ; }
__int64 __fastcall argmatch ( const char * @@a1@@ , const char * * @@a2@@ , char * @@a3@@ , size_t @@a4@@ ) { char * @@v5@@ ; size_t @@v6@@ ; const char * @@v7@@ ; size_t @@v8@@ ; __int64 @@v9@@ ; bool @@v10@@ ; char @@v11@@ ; __int64 @@v12@@ ; __int64 @@v14@@ ; char @@v15@@ ; @@v5@@ = @@a3@@ ; @@v6@@ = strlen ( @@a1@@ ) ; @@v7@@ = * @@a2@@ ; @@v14@@ = Number ; if ( ! * @@a2@@ ) return @@v14@@ ; @@v8@@ = @@v6@@ ; @@v15@@ = Number ; @@v9@@ = Number L ; do { while ( strncmp ( @@v7@@ , @@a1@@ , @@v8@@ ) ) { LABEL_7 : ++ @@v9@@ ; @@v5@@ += @@a4@@ ; @@v7@@ = @@a2@@ [ @@v9@@ ] ; if ( ! @@v7@@ ) goto LABEL_12 ; } if ( strlen ( @@v7@@ ) == @@v8@@ ) return @@v9@@ ; if ( @@v14@@ != Number ) { if ( @@a3@@ ) { @@v10@@ = memcmp ( & @@a3@@ [ @@a4@@ * @@v14@@ ] , @@v5@@ , @@a4@@ ) == Number ; @@v11@@ = @@v15@@ ; if ( ! @@v10@@ ) @@v11@@ = Number ; @@v15@@ = @@v11@@ ; } else { @@v15@@ = Number ; } goto LABEL_7 ; } @@v14@@ = @@v9@@ ++ ; @@v5@@ += @@a4@@ ; @@v7@@ = @@a2@@ [ @@v9@@ ] ; } while ( @@v7@@ ) ; LABEL_12 : @@v12@@ = Number ; if ( ! @@v15@@ ) @@v12@@ = @@v14@@ ; return @@v12@@ ; }
DIR * fdopendir ( int @@fd@@ ) { return fdopendir ( @@fd@@ ) ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_20F210 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20F1F0 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_20F200 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
__int64 __fastcall find_field_isra_2 ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; const unsigned __int16 * @@v6@@ ; unsigned __int64 @@v7@@ ; @@v2@@ = Number L ; @@v3@@ = skip_fields ; @@v4@@ = Number L ; @@v5@@ = @@a1@@ - Number ; if ( skip_fields ) { do { if ( @@v5@@ > @@v4@@ ) { @@v6@@ = * __ctype_b_loc ( ) ; while ( ( @@v6@@ [ * ( unsigned __int8 * ) ( @@a2@@ + @@v4@@ ) ] & Number ) != Number ) { if ( @@v5@@ <= ++ @@v4@@ ) goto LABEL_9 ; } if ( @@v5@@ > @@v4@@ ) { do ++ @@v4@@ ; while ( @@v5@@ > @@v4@@ && ( @@v6@@ [ * ( unsigned __int8 * ) ( @@a2@@ + @@v4@@ ) ] & Number ) == Number ) ; } } LABEL_9 : ++ @@v2@@ ; } while ( @@v2@@ != @@v3@@ ) ; } @@v7@@ = @@v4@@ ; if ( skip_chars && @@v5@@ > @@v4@@ ) { do ++ @@v7@@ ; while ( skip_chars > @@v7@@ - @@v4@@ && @@v5@@ > @@v7@@ ) ; } return @@a2@@ + @@v7@@ ; }
__int64 __fastcall digits_to_date_time ( __int64 @@a1@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 a5 , __int64 a6 , __int128 @@a7@@ , unsigned __int64 @@a8@@ ) { __int64 @@result@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; __m128i @@v11@@ ; @@result@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v9@@ = * ( ( _QWORD * ) & @@a7@@ + Number ) ; @@v10@@ = @@a8@@ ; if ( @@result@@ && ! * ( _QWORD * ) ( @@a1@@ + Number ) && ! * ( _BYTE * ) ( @@a1@@ + Number ) ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) || @@a8@@ > Number ) { @@result@@ = @@a8@@ ; @@v11@@ = _mm_loadu_si128 ( ( const __m128i * ) & @@a7@@ ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@a8@@ ; * ( __m128i * ) ( @@a1@@ + Number ) = @@v11@@ ; return @@result@@ ; } * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; goto LABEL_13 ; } if ( @@a8@@ <= Number ) { ++ * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( @@v10@@ > Number ) { * ( _QWORD * ) ( @@a1@@ + Number ) = @@v9@@ / Number ; @@result@@ = Number * ( @@v9@@ / Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v9@@ % Number ; LABEL_10 : * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _DWORD * ) ( @@a1@@ + Number ) = Number ; return @@result@@ ; } LABEL_13 : * ( _QWORD * ) ( @@a1@@ + Number ) = @@v9@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; goto LABEL_10 ; } * ( _QWORD * ) ( @@a1@@ + Number ) = @@result@@ + Number ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v10@@ - Number ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v9@@ % Number ; @@result@@ = Number * @@v9@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v9@@ / Number % Number ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v9@@ / Number ; return @@result@@ ; }
void free ( void * @@ptr@@ ) { __imp_free ( @@ptr@@ ) ; }
void __fastcall fwrite_lowcase ( FILE * @@stream@@ , unsigned __int8 * @@a2@@ , __int64 @@a3@@ ) { unsigned __int8 * @@v3@@ ; unsigned __int8 * @@v4@@ ; const __int32_t * * @@v5@@ ; __int64 @@v6@@ ; if ( @@a3@@ ) { @@v3@@ = @@a2@@ ; @@v4@@ = & @@a2@@ [ @@a3@@ ] ; @@v5@@ = __ctype_tolower_loc ( ) ; do { @@v6@@ = * @@v3@@ ++ ; fputc ( ( * @@v5@@ ) [ @@v6@@ ] , @@stream@@ ) ; } while ( @@v3@@ != @@v4@@ ) ; } }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
void __fastcall argmatch_invalid ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { char * @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; if ( @@a3@@ == Number ) @@v3@@ = dcgettext ( Number L , String , Number ) ; else @@v3@@ = dcgettext ( Number L , String , Number ) ; @@v4@@ = quote_n ( Number L , @@a1@@ ) ; @@v5@@ = quotearg_n_style ( Number L , Number L , @@a2@@ ) ; error ( Number , Number , @@v3@@ , @@v5@@ , @@v4@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
char __fastcall movefile ( __int64 @@a1@@ , __int64 @@a2@@ , char @@a3@@ , __int64 @@a4@@ ) { __int64 @@v6@@ ; void * @@v7@@ ; char @@v8@@ ; char @@v9@@ ; if ( remove_trailing_slashes ) { @@v9@@ = @@a3@@ ; ( ( void ( * ) ( void ) ) strip_trailing_slashes ) ( ) ; @@a3@@ = @@v9@@ ; } if ( ! @@a3@@ ) return do_move ( @@a1@@ , @@a2@@ , @@a4@@ ) ; @@v6@@ = last_component ( @@a1@@ ) ; @@v7@@ = ( void * ) file_name_concat ( @@a2@@ , @@v6@@ , Number L ) ; strip_trailing_slashes ( @@v7@@ ) ; @@v8@@ = do_move ( @@a1@@ , ( __int64 ) @@v7@@ , @@a4@@ ) ; free ( @@v7@@ ) ; return @@v8@@ ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
int __xstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _xstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
int __fastcall argmatch_valid ( _QWORD * @@a1@@ , char * @@a2@@ , size_t @@a3@@ ) { const void * @@v5@@ ; __int64 @@v6@@ ; char * @@v7@@ ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; if ( * @@a1@@ ) { @@v5@@ = Number L ; @@v6@@ = Number L ; do { while ( ! @@v6@@ || memcmp ( @@v5@@ , @@a2@@ , @@a3@@ ) ) { ++ @@v6@@ ; @@v5@@ = @@a2@@ ; __fprintf_chk ( ) ; @@a2@@ += @@a3@@ ; if ( ! @@a1@@ [ @@v6@@ ] ) goto LABEL_7 ; } ++ @@v6@@ ; @@a2@@ += @@a3@@ ; __fprintf_chk ( ) ; } while ( @@a1@@ [ @@v6@@ ] ) ; } LABEL_7 : @@v7@@ = stderr -> _IO_write_ptr ; if ( @@v7@@ >= stderr -> _IO_write_end ) { LODWORD ( @@v7@@ ) = __overflow ( stderr , Number ) ; } else { stderr -> _IO_write_ptr = @@v7@@ + Number ; * @@v7@@ = Number ; } return ( int ) @@v7@@ ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
bool __fastcall writable_destination ( char * @@name@@ , __int16 @@a2@@ ) { if ( ( @@a2@@ & Number ) == Number ) return Number ; if ( ( unsigned __int8 ) can_write_any_file ( ) ) return Number ; return euidaccess ( @@name@@ , Number ) == Number ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
unsigned __int64 __fastcall overwrite_prompt_isra_14 ( char * @@a1@@ , unsigned int * @@a2@@ ) { int @@v3@@ ; char @@v5@@ [ Number ] ; unsigned __int64 @@v6@@ ; @@v3@@ = * @@a2@@ ; @@v6@@ = __readfsqword ( Number ) ; if ( writable_destination ( @@a1@@ , @@v3@@ ) ) { quote ( @@a1@@ ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { strmode ( * @@a2@@ , @@v5@@ ) ; @@v5@@ [ Number ] = Number ; quote ( @@a1@@ ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } return __readfsqword ( Number ) ^ @@v6@@ ; }
__int64 __fastcall imaxtostr ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; __int64 @@result@@ ; int @@v4@@ ; bool @@v5@@ ; @@v2@@ = @@a2@@ + Number ; * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; if ( @@a1@@ < Number ) { while ( Number ) { @@v4@@ = Number * ( @@a1@@ / Number ) + Number - @@a1@@ ; @@v5@@ = ( __int64 ) ( ( unsigned __int128 ) ( Number * ( __int128 ) @@a1@@ ) >> Number ) >> Number == @@a1@@ >> Number ; @@a1@@ /= Number L ; * ( _BYTE * ) ( @@v2@@ - Number ) = @@v4@@ ; if ( @@v5@@ ) break ; -- @@v2@@ ; } * ( _BYTE * ) ( @@v2@@ - Number ) = Number ; @@result@@ = @@v2@@ - Number ; } else { do { * ( _BYTE * ) -- @@v2@@ = @@a1@@ % Number + Number ; @@a1@@ /= Number ; } while ( @@a1@@ ) ; @@result@@ = @@v2@@ ; } return @@result@@ ; }
int __fastcall memcoll ( void * @@s1@@ , size_t @@n@@ , void * @@s2@@ , __int64 @@a4@@ ) { const char * @@v5@@ ; int * @@v7@@ ; size_t @@v8@@ ; char * @@v9@@ ; __int64 @@v10@@ ; char @@v11@@ ; size_t @@v12@@ ; size_t @@v13@@ ; int @@result@@ ; __int64 @@v15@@ ; __int64 @@v16@@ ; int @@v17@@ ; char @@v18@@ ; char @@v19@@ ; @@v5@@ = ( const char * ) @@s1@@ ; @@v7@@ = __errno_location ( ) ; if ( @@n@@ != @@a4@@ || ( @@result@@ = memcmp ( @@s1@@ , @@s2@@ , @@n@@ ) ) != Number ) { @@v8@@ = @@n@@ + Number ; @@v18@@ = * ( ( _BYTE * ) @@s1@@ + @@n@@ ) ; @@v9@@ = ( char * ) @@s2@@ + @@a4@@ ; @@v10@@ = @@a4@@ + Number ; @@v11@@ = * @@v9@@ ; * ( ( _BYTE * ) @@s1@@ + @@n@@ ) = Number ; * @@v9@@ = Number ; @@v19@@ = @@v11@@ ; do { * @@v7@@ = Number ; @@result@@ = strcoll ( @@v5@@ , ( const char * ) @@s2@@ ) ; if ( @@result@@ ) { @@v15@@ = @@v8@@ - Number ; @@v16@@ = @@v10@@ - Number ; goto LABEL_7 ; } @@v12@@ = strlen ( @@v5@@ ) + Number ; @@v13@@ = strlen ( ( const char * ) @@s2@@ ) + Number ; @@v5@@ += @@v12@@ ; @@s2@@ = ( char * ) @@s2@@ + @@v13@@ ; @@v10@@ -= @@v13@@ ; @@v8@@ -= @@v12@@ ; if ( ! @@v8@@ ) { @@v15@@ = Number ; @@v17@@ = @@v10@@ != Number ; @@v16@@ = @@v10@@ - Number ; @@result@@ = - @@v17@@ ; goto LABEL_7 ; } } while ( @@v10@@ ) ; @@v15@@ = @@v8@@ - Number ; @@v16@@ = Number ; @@result@@ = Number ; LABEL_7 : @@v5@@ [ @@v15@@ ] = @@v18@@ ; * ( ( _BYTE * ) @@s2@@ + @@v16@@ ) = @@v19@@ ; } else { * @@v7@@ = Number ; } return @@result@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
char __fastcall chown_failure_ok ( __int64 @@a1@@ ) { int * @@v1@@ ; char @@result@@ ; @@v1@@ = __errno_location ( ) ; @@result@@ = * @@v1@@ == Number || * @@v1@@ == Number ; if ( @@result@@ ) @@result@@ = * ( _BYTE * ) ( @@a1@@ + Number ) ^ Number ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number , @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
bool __fastcall src_to_dest_compare ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@result@@ ; @@result@@ = Number ; if ( * @@a1@@ == * @@a2@@ ) @@result@@ = @@a1@@ [ Number ] == @@a2@@ [ Number ] ; return @@result@@ ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 __fastcall remember_copied ( void * @@src@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ ) { void * @@v6@@ ; __int64 @@v7@@ ; void * @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; @@v6@@ = ( void * ) xmalloc ( Number L , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; @@v7@@ = xstrdup ( @@src@@ ) ; @@v8@@ = src_to_dest ; * ( ( _QWORD * ) @@v6@@ + Number ) = @@v7@@ ; * ( _QWORD * ) @@v6@@ = @@a2@@ ; * ( ( _QWORD * ) @@v6@@ + Number ) = @@a3@@ ; @@v9@@ = hash_insert ( @@v8@@ , @@v6@@ ) ; if ( ! @@v9@@ ) xalloc_die ( ) ; @@v10@@ = @@v9@@ ; if ( @@v6@@ == ( void * ) @@v9@@ ) return Number L ; free ( * ( ( void * * ) @@v6@@ + Number ) ) ; free ( @@v6@@ ) ; return * ( _QWORD * ) ( @@v10@@ + Number ) ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
__int64 __fastcall full_write ( int @@fd@@ , void * @@buf@@ , size_t @@n@@ ) { size_t @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; if ( ! @@n@@ ) return Number L ; @@v4@@ = @@n@@ ; @@v5@@ = Number L ; do { @@v6@@ = safe_write ( @@fd@@ , @@buf@@ , @@v4@@ ) ; if ( @@v6@@ == Number ) break ; if ( ! @@v6@@ ) { * __errno_location ( ) = Number ; return @@v5@@ ; } @@v5@@ += @@v6@@ ; @@buf@@ = ( char * ) @@buf@@ + @@v6@@ ; @@v4@@ -= @@v6@@ ; } while ( @@v4@@ ) ; return @@v5@@ ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
unsigned __int64 __fastcall raw_hasher ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return __ROR8__ ( @@a1@@ , Number ) % @@a2@@ ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
unsigned __int64 __fastcall triple_hash_no_name ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) % @@a2@@ ; }
__int64 __fastcall hash_get_n_buckets_used ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
__int64 __fastcall hash_lookup ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; _QWORD * @@v4@@ ; __int64 @@v5@@ ; @@v2@@ = * @@a1@@ ; @@v4@@ = ( _QWORD * ) ( Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) + @@v2@@ ) ; if ( @@a1@@ [ Number ] <= ( unsigned __int64 ) @@v4@@ ) abort ( ) ; @@v5@@ = * @@v4@@ ; if ( ! * @@v4@@ ) return Number L ; while ( @@v5@@ != @@a2@@ ) { if ( ( ( unsigned __int8 ( __fastcall * ) ( __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ ) ) return * @@v4@@ ; @@v4@@ = ( _QWORD * ) @@v4@@ [ Number ] ; if ( ! @@v4@@ ) return Number L ; @@v5@@ = * @@v4@@ ; } return @@v5@@ ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; FILE * @@v11@@ ; char * @@v12@@ ; char * @@v13@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String String String String String String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String String String String String String String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = stdout ; @@v10@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v11@@ = stdout ; @@v12@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v12@@ , @@v11@@ ) ; @@v13@@ = setlocale ( Number , Number L ) ; if ( @@v13@@ ) { if ( strncmp ( @@v13@@ , String , Number ) ) { last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
__int64 __fastcall hash_reset_tuning ( __int64 @@a1@@ ) { __int64 @@result@@ ; * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; * ( _QWORD * ) @@a1@@ = Number ; @@result@@ = Number ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number ; return @@result@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
__int64 __fastcall xget_version ( void * @@a1@@ , char * @@a2@@ ) { char * @@v2@@ ; if ( @@a2@@ && * @@a2@@ ) return get_version_part_0 ( ( __int64 ) @@a1@@ , ( __int64 ) @@a2@@ ) ; @@v2@@ = getenv ( String ) ; if ( @@v2@@ && * @@v2@@ ) { @@a1@@ = & unk_12360 ; @@a2@@ = @@v2@@ ; return get_version_part_0 ( ( __int64 ) @@a1@@ , ( __int64 ) @@a2@@ ) ; } return Number L ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
void __fastcall close_stdin_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
__int64 __fastcall dir_name ( void * @@a1@@ ) { __int64 @@result@@ ; @@result@@ = mdir_name ( @@a1@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
DIR * opendir ( const char * @@name@@ ) { return opendir ( @@name@@ ) ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
void __fastcall hash_clear ( _QWORD * @@a1@@ ) { _QWORD * @@v1@@ ; _QWORD * @@v2@@ ; void ( __fastcall * @@v3@@ ) ( _QWORD ) ; _QWORD * @@v4@@ ; __int64 @@v5@@ ; @@v1@@ = ( _QWORD * ) * @@a1@@ ; if ( * @@a1@@ < @@a1@@ [ Number ] ) { do { if ( * @@v1@@ ) { @@v2@@ = ( _QWORD * ) @@v1@@ [ Number ] ; @@v3@@ = ( void ( __fastcall * ) ( _QWORD ) ) @@a1@@ [ Number ] ; if ( @@v2@@ ) { do { if ( @@v3@@ ) { @@v3@@ ( * @@v2@@ ) ; @@v3@@ = ( void ( __fastcall * ) ( _QWORD ) ) @@a1@@ [ Number ] ; } @@v4@@ = ( _QWORD * ) @@v2@@ [ Number ] ; @@v5@@ = @@a1@@ [ Number ] ; * @@v2@@ = Number L ; @@v2@@ [ Number ] = @@v5@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v2@@ = @@v4@@ ; } while ( @@v4@@ ) ; } if ( @@v3@@ ) @@v3@@ ( * @@v1@@ ) ; * @@v1@@ = Number L ; @@v1@@ [ Number ] = Number L ; } @@v1@@ += Number ; } while ( @@a1@@ [ Number ] > ( unsigned __int64 ) @@v1@@ ) ; } @@a1@@ [ Number ] = Number L ; @@a1@@ [ Number ] = Number L ; }
unsigned __int64 __fastcall next_prime ( unsigned __int64 @@a1@@ ) { unsigned __int64 @@v1@@ ; unsigned __int64 @@v2@@ ; __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; if ( @@a1@@ < Number ) @@a1@@ = Number L ; @@v1@@ = @@a1@@ | Number ; if ( @@v1@@ != Number ) { while ( Number ) { @@v2@@ = @@v1@@ % Number ; if ( @@v1@@ <= Number ) goto LABEL_9 ; if ( @@v1@@ % Number ) break ; LABEL_10 : @@v1@@ += Number L ; if ( @@v1@@ == Number ) return @@v1@@ ; } @@v3@@ = Number L ; @@v4@@ = Number L ; @@v5@@ = Number L ; while ( Number ) { @@v5@@ += Number L ; @@v4@@ += @@v3@@ ; @@v2@@ = @@v1@@ % @@v5@@ ; if ( @@v4@@ >= @@v1@@ ) break ; @@v3@@ += Number L ; if ( ! ( @@v1@@ % @@v5@@ ) ) goto LABEL_10 ; } LABEL_9 : if ( @@v2@@ ) return @@v1@@ ; goto LABEL_10 ; } return @@v1@@ ; }
int closedir ( DIR * @@dirp@@ ) { return closedir ( @@dirp@@ ) ; }
int __fastcall rpl_fflush ( FILE * @@stream@@ ) { if ( ! @@stream@@ || ! __freading ( @@stream@@ ) || ( @@stream@@ -> _flags & Number ) == Number ) { return fflush ( @@stream@@ ) ; } rpl_fseeko ( @@stream@@ , Number L , Number ) ; return fflush ( @@stream@@ ) ; }
__int64 __fastcall hash_get_n_entries ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
int __xstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _xstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
__int64 __fastcall hash_print_statistics ( __int64 @@a1@@ ) { unsigned __int64 @@v1@@ ; _QWORD * @@v2@@ ; unsigned __int64 @@i@@ ; __int64 @@v4@@ ; unsigned __int64 @@j@@ ; @@v1@@ = Number L ; @@v2@@ = * ( _QWORD * * ) @@a1@@ ; for ( @@i@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; ( unsigned __int64 ) @@v2@@ < @@i@@ ; @@v2@@ += Number ) { if ( * @@v2@@ ) { @@v4@@ = @@v2@@ [ Number ] ; for ( @@j@@ = Number L ; @@v4@@ ; ++ @@j@@ ) @@v4@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; if ( @@v1@@ < @@j@@ ) @@v1@@ = @@j@@ ; } } __fprintf_chk ( ) ; __fprintf_chk ( ) ; __fprintf_chk ( ) ; return __fprintf_chk ( ) ; }
int __fastcall rpl_fseeko ( FILE * @@stream@@ , __off_t @@offset@@ , int @@whence@@ ) { int @@v5@@ ; int @@v6@@ ; if ( @@stream@@ -> _IO_read_end != @@stream@@ -> _IO_read_ptr || @@stream@@ -> _IO_write_ptr != @@stream@@ -> _IO_write_base || @@stream@@ -> _IO_save_base ) { return fseeko ( @@stream@@ , @@offset@@ , @@whence@@ ) ; } if ( @@whence@@ == Number && @@offset@@ > Number ) { @@v5@@ = fileno ( @@stream@@ ) ; if ( lseek ( @@v5@@ , Number L , Number ) != Number ) { @@stream@@ -> _flags &= Number ; return fseeko ( @@stream@@ , @@offset@@ , @@whence@@ ) ; } } else { @@v6@@ = fileno ( @@stream@@ ) ; if ( lseek ( @@v6@@ , @@offset@@ , @@whence@@ ) != Number ) { @@stream@@ -> _flags &= Number ; return Number ; } } return Number ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
__int64 __fastcall check_tuning_isra_0 ( float * * @@a1@@ ) { float * @@v1@@ ; __int64 @@result@@ ; float @@v3@@ ; float @@v4@@ ; float @@v5@@ ; @@v1@@ = * @@a1@@ ; @@result@@ = Number L ; if ( * @@a1@@ != ( float * ) & default_tuning ) { @@v3@@ = @@v1@@ [ Number ] ; if ( @@v3@@ <= Number || @@v3@@ >= Number || @@v1@@ [ Number ] <= Number || * @@v1@@ < Number || ( @@v4@@ = * @@v1@@ + Number , @@v5@@ = @@v1@@ [ Number ] , @@v5@@ <= @@v4@@ ) || @@v5@@ > Number || @@v3@@ <= @@v4@@ ) { * @@a1@@ = ( float * ) & default_tuning ; @@result@@ = Number L ; } } return @@result@@ ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
unsigned __int64 __fastcall hash_string ( unsigned __int8 * @@a1@@ , unsigned __int64 @@a2@@ ) { __int64 @@v2@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@v4@@ ; @@v2@@ = * @@a1@@ ; for ( @@i@@ = Number L ; ( _BYTE ) @@v2@@ ; @@i@@ = @@v4@@ % @@a2@@ ) { ++ @@a1@@ ; @@v4@@ = @@v2@@ + Number * @@i@@ ; @@v2@@ = * @@a1@@ ; } return @@i@@ ; }
__int64 __fastcall fts_sort ( _QWORD * @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { __int64 @@v5@@ ; bool @@v6@@ ; int ( * @@v7@@ ) ( const void * , const void * ) ; void * @@v8@@ ; void * @@v9@@ ; _QWORD * @@v10@@ ; __int64 * @@v11@@ ; size_t @@v12@@ ; __int64 @@result@@ ; __int64 @@v14@@ ; __int64 * @@i@@ ; __int64 @@v16@@ ; __int64 @@v17@@ ; @@v5@@ = @@a2@@ ; @@v6@@ = @@a1@@ [ Number ] < @@a3@@ ; @@v7@@ = ( int ( * ) ( const void * , const void * ) ) @@a1@@ [ Number ] ; @@v8@@ = ( void * ) @@a1@@ [ Number ] ; if ( ! @@v6@@ ) goto LABEL_5 ; @@a1@@ [ Number ] = @@a3@@ + Number ; if ( @@a3@@ + Number > Number ) { LABEL_15 : free ( @@v8@@ ) ; @@a1@@ [ Number ] = Number L ; @@a1@@ [ Number ] = Number L ; return @@a2@@ ; } @@v9@@ = realloc ( @@v8@@ , Number * ( @@a3@@ + Number ) ) ; @@v8@@ = @@v9@@ ; if ( ! @@v9@@ ) { @@v8@@ = ( void * ) @@a1@@ [ Number ] ; goto LABEL_15 ; } @@a1@@ [ Number ] = @@v9@@ ; LABEL_5 : if ( @@a2@@ ) { @@v10@@ = @@v8@@ ; do { * @@v10@@ ++ = @@v5@@ ; @@v5@@ = * ( _QWORD * ) ( @@v5@@ + Number ) ; } while ( @@v5@@ ) ; } qsort ( @@v8@@ , @@a3@@ , Number , @@v7@@ ) ; @@v11@@ = ( __int64 * ) @@a1@@ [ Number ] ; @@v12@@ = @@a3@@ - Number ; @@result@@ = * @@v11@@ ; if ( @@a3@@ == Number ) { @@v17@@ = * @@v11@@ ; } else { @@v14@@ = * @@v11@@ ; for ( @@i@@ = ( __int64 * ) @@a1@@ [ Number ] ; ; @@v14@@ = * @@i@@ ) { @@v16@@ = @@i@@ [ Number ] ; ++ @@i@@ ; -- @@v12@@ ; * ( _QWORD * ) ( @@v14@@ + Number ) = @@v16@@ ; if ( ! @@v12@@ ) break ; } @@v17@@ = @@v11@@ [ @@a3@@ - Number ] ; } * ( _QWORD * ) ( @@v17@@ + Number ) = Number L ; return @@result@@ ; }
int rename ( const char * @@old@@ , const char * @@a2@@ ) { return rename ( @@old@@ , @@a2@@ ) ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
bool __fastcall hash_table_ok ( __int64 @@a1@@ ) { _QWORD * @@v1@@ ; unsigned __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; bool @@result@@ ; @@v1@@ = * ( _QWORD * * ) @@a1@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v3@@ = Number L ; @@v4@@ = Number L ; if ( * ( _QWORD * ) @@a1@@ < @@v2@@ ) { do { if ( * @@v1@@ ) { @@v5@@ = @@v1@@ [ Number ] ; ++ @@v4@@ ; ++ @@v3@@ ; for ( ; @@v5@@ ; ++ @@v3@@ ) @@v5@@ = * ( _QWORD * ) ( @@v5@@ + Number ) ; } @@v1@@ += Number ; } while ( ( unsigned __int64 ) @@v1@@ < @@v2@@ ) ; } @@result@@ = Number ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) == @@v4@@ ) @@result@@ = * ( _QWORD * ) ( @@a1@@ + Number ) == @@v3@@ ; return @@result@@ ; }
_QWORD * __fastcall hash_initialize ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 ( __fastcall * @@a3@@ ) ( __int64 a1 , unsigned __int64 a2 ) , bool ( __fastcall * @@a4@@ ) ( __int64 a1 , __int64 a2 ) , __int64 @@a5@@ ) { unsigned __int64 ( __fastcall * @@v5@@ ) ( __int64 , unsigned __int64 ) ; bool ( __fastcall * @@v6@@ ) ( __int64 , __int64 ) ; char * @@v9@@ ; _QWORD * @@v10@@ ; float * * @@v11@@ ; float @@v12@@ ; float @@v13@@ ; float @@v14@@ ; unsigned __int64 @@v15@@ ; char * @@v16@@ ; void * @@v17@@ ; @@v5@@ = @@a3@@ ; @@v6@@ = @@a4@@ ; if ( ! @@a3@@ ) @@v5@@ = raw_hasher ; if ( ! @@a4@@ ) @@v6@@ = raw_comparator ; @@v9@@ = ( char * ) malloc ( Number ) ; @@v10@@ = @@v9@@ ; if ( @@v9@@ ) { @@v11@@ = ( float * * ) ( @@v9@@ + Number ) ; if ( @@a2@@ ) { * ( ( _QWORD * ) @@v9@@ + Number ) = @@a2@@ ; if ( ! ( unsigned __int8 ) check_tuning_isra_0 ( @@v11@@ ) ) goto LABEL_20 ; if ( * ( _BYTE * ) ( @@a2@@ + Number ) ) { LABEL_15 : @@v15@@ = next_prime ( @@a1@@ ) ; if ( @@v15@@ <= Number ) { @@v10@@ [ Number ] = @@v15@@ ; if ( @@v15@@ ) { @@v16@@ = ( char * ) calloc ( @@v15@@ , Number ) ; * @@v10@@ = @@v16@@ ; if ( @@v16@@ ) { @@v10@@ [ Number ] = Number L ; @@v10@@ [ Number ] = Number L ; @@v10@@ [ Number ] = @@v5@@ ; @@v10@@ [ Number ] = @@v6@@ ; @@v10@@ [ Number ] = & @@v16@@ [ Number * @@v15@@ ] ; @@v10@@ [ Number ] = @@a5@@ ; @@v10@@ [ Number ] = Number L ; return @@v10@@ ; } } } LABEL_20 : @@v17@@ = @@v10@@ ; @@v10@@ = Number L ; free ( @@v17@@ ) ; return @@v10@@ ; } @@v12@@ = * ( float * ) ( @@a2@@ + Number ) ; } else { * ( ( _QWORD * ) @@v9@@ + Number ) = & default_tuning ; @@v12@@ = Number ; if ( ! ( unsigned __int8 ) check_tuning_isra_0 ( @@v11@@ ) ) goto LABEL_20 ; } if ( @@a1@@ < Number ) @@v13@@ = ( float ) ( @@a1@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@a1@@ >> Number ) ) + ( float ) ( @@a1@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@a1@@ >> Number ) ) ; else @@v13@@ = ( float ) ( int ) @@a1@@ ; @@v14@@ = @@v13@@ / @@v12@@ ; if ( @@v14@@ >= Number ) goto LABEL_20 ; if ( @@v14@@ < Number ) @@a1@@ = ( unsigned int ) ( int ) @@v14@@ ; else @@a1@@ = ( unsigned int ) ( int ) ( float ) ( @@v14@@ - Number ) ^ Number ; goto LABEL_15 ; } return @@v10@@ ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
unsigned __int64 __fastcall leave_dir_isra_14 ( __int16 @@a1@@ , __int64 * * @@a2@@ , _QWORD * @@a3@@ ) { __int64 * @@v3@@ ; __int64 * @@v4@@ ; __int64 * @@v6@@ ; void * @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v11@@ = __readfsqword ( Number ) ; if ( ( @@a1@@ & Number ) != Number ) { @@v6@@ = * @@a2@@ ; @@v10@@ [ Number ] = @@a3@@ [ Number ] ; @@v10@@ [ Number ] = @@a3@@ [ Number ] ; @@v7@@ = ( void * ) hash_delete ( @@v6@@ , @@v10@@ ) ; if ( @@v7@@ ) { free ( @@v7@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; } goto LABEL_11 ; } @@v3@@ = ( __int64 * ) @@a3@@ [ Number ] ; if ( ! @@v3@@ || @@v3@@ [ Number ] < Number ) return __readfsqword ( Number ) ^ @@v11@@ ; @@v4@@ = * @@a2@@ ; if ( ! ( * @@a2@@ ) [ Number ] ) LABEL_11 : abort ( ) ; if ( * @@v4@@ == @@a3@@ [ Number ] && @@v4@@ [ Number ] == @@a3@@ [ Number ] ) { @@v8@@ = @@v3@@ [ Number ] ; @@v9@@ = @@v3@@ [ Number ] ; @@v4@@ [ Number ] = @@v8@@ ; * @@v4@@ = @@v9@@ ; } return __readfsqword ( Number ) ^ @@v11@@ ; }
unsigned __int64 __fastcall hash_get_entries ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { _QWORD * @@v3@@ ; unsigned __int64 @@v4@@ ; _QWORD * @@v5@@ ; unsigned __int64 @@result@@ ; @@v3@@ = * ( _QWORD * * ) @@a1@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= * ( _QWORD * ) @@a1@@ ) return Number L ; @@v4@@ = Number L ; while ( ! * @@v3@@ ) { LABEL_9 : @@v3@@ += Number ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= ( unsigned __int64 ) @@v3@@ ) return @@v4@@ ; } if ( @@a3@@ <= @@v4@@ ) return @@v4@@ ; * ( _QWORD * ) ( @@a2@@ + Number * @@v4@@ ) = * @@v3@@ ; @@v5@@ = ( _QWORD * ) @@v3@@ [ Number ] ; @@result@@ = @@v4@@ + Number ; if ( ! @@v5@@ ) { LABEL_8 : @@v4@@ = @@result@@ ; goto LABEL_9 ; } while ( @@a3@@ != @@result@@ ) { ++ @@result@@ ; * ( _QWORD * ) ( @@a2@@ + Number * @@result@@ - Number ) = * @@v5@@ ; @@v5@@ = ( _QWORD * ) @@v5@@ [ Number ] ; if ( ! @@v5@@ ) goto LABEL_8 ; } return @@result@@ ; }
char __fastcall do_move ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { char @@result@@ ; char @@v5@@ ; int @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; int * @@v9@@ ; char @@v10@@ ; char @@v11@@ ; char @@v12@@ [ Number ] ; int @@v13@@ ; char @@v14@@ ; char @@v15@@ ; char @@v17@@ ; char @@v18@@ ; char @@v19@@ ; __int64 @@v20@@ [ Number ] ; @@v20@@ [ Number ] = __readfsqword ( Number ) ; @@result@@ = copy ( @@a1@@ , @@a2@@ , Number L , @@a3@@ , & @@v10@@ , & @@v11@@ ) ; if ( @@result@@ ) { if ( @@v10@@ ) { @@result@@ = Number ; } else if ( @@v11@@ != Number && @@a1@@ ) { @@v12@@ [ Number ] = Number ; @@v15@@ = Number ; @@v14@@ = Number ; @@v13@@ = Number ; @@v17@@ = Number ; @@v18@@ = Number ; @@v19@@ = Number ; if ( ! get_root_dev_ino ( & dev_ino_buf_6619 ) ) { @@v7@@ = quote ( String ) ; @@v8@@ = dcgettext ( Number L , String , Number ) ; @@v9@@ = __errno_location ( ) ; error ( Number , * @@v9@@ , @@v8@@ , @@v7@@ ) ; } @@v5@@ = * ( _BYTE * ) ( @@a3@@ + Number ) ; @@v20@@ [ Number ] = @@a1@@ ; @@v20@@ [ Number ] = Number L ; @@v18@@ = @@v5@@ ; @@v6@@ = rm ( @@v20@@ , @@v12@@ ) ; if ( ( unsigned int ) ( @@v6@@ - Number ) > Number ) __assert_fail ( String , String , Number , String ) ; @@result@@ = @@v6@@ != Number ; } } return @@result@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
__int64 __fastcall hash_lookup ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; _QWORD * @@v4@@ ; __int64 @@v5@@ ; @@v2@@ = * @@a1@@ ; @@v4@@ = ( _QWORD * ) ( Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) + @@v2@@ ) ; if ( @@a1@@ [ Number ] <= ( unsigned __int64 ) @@v4@@ ) abort ( ) ; @@v5@@ = * @@v4@@ ; if ( ! * @@v4@@ ) return Number L ; while ( @@v5@@ != @@a2@@ ) { if ( ( ( unsigned __int8 ( __fastcall * ) ( __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ ) ) return * @@v4@@ ; @@v4@@ = ( _QWORD * ) @@v4@@ [ Number ] ; if ( ! @@v4@@ ) return Number L ; @@v5@@ = * @@v4@@ ; } return @@v5@@ ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
__int64 __fastcall dest_info_init ( __int64 @@a1@@ ) { __int64 @@result@@ ; @@result@@ = hash_initialize ( Number L , Number L , triple_hash , triple_compare , triple_free ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@result@@ ; return @@result@@ ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 __fastcall i_ring_empty ( __int64 @@a1@@ ) { return * ( unsigned __int8 * ) ( @@a1@@ + Number ) ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall triple_compare ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { __int64 @@result@@ ; @@result@@ = Number L ; if ( @@a1@@ [ Number ] == @@a2@@ [ Number ] && @@a1@@ [ Number ] == @@a2@@ [ Number ] ) { @@result@@ = same_name ( * @@a1@@ , * @@a2@@ ) ; } return @@result@@ ; }
bool __fastcall cp_options_default ( __int64 @@a1@@ ) { bool @@result@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _OWORD * ) @@a1@@ = Number L ; * ( _OWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _OWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _OWORD * ) ( @@a1@@ + Number ) = Number L ; @@result@@ = geteuid ( ) == Number ; * ( _BYTE * ) ( @@a1@@ + Number ) = @@result@@ ; * ( _BYTE * ) ( @@a1@@ + Number ) = @@result@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall i_ring_push ( __int64 @@a1@@ , int @@a2@@ ) { char @@v2@@ ; int @@v3@@ ; _DWORD * @@v4@@ ; __int64 @@result@@ ; int @@v6@@ ; @@v2@@ = * ( _BYTE * ) ( @@a1@@ + Number ) ^ Number ; @@v3@@ = ( @@v2@@ + ( unsigned __int8 ) * ( _DWORD * ) ( @@a1@@ + Number ) ) & Number ; @@v4@@ = ( _DWORD * ) ( @@a1@@ + Number L * ( ( @@v2@@ + ( unsigned __int8 ) * ( _DWORD * ) ( @@a1@@ + Number ) ) & Number ) ) ; @@result@@ = ( unsigned int ) * @@v4@@ ; * @@v4@@ = @@a2@@ ; @@v6@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@v3@@ ; if ( @@v6@@ == @@v3@@ ) * ( _DWORD * ) ( @@a1@@ + Number ) = ( ( _BYTE ) @@v6@@ + @@v2@@ ) & Number ; * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; return @@result@@ ; }
void __fastcall src_to_dest_free ( void * @@ptr@@ ) { free ( * ( ( void * * ) @@ptr@@ + Number ) ) ; free ( @@ptr@@ ) ; }
unsigned __int64 __fastcall hash_pjw ( char * @@a1@@ , unsigned __int64 @@a2@@ ) { __int64 @@v2@@ ; unsigned __int64 @@v3@@ ; @@v2@@ = * @@a1@@ ; if ( ! ( _BYTE ) @@v2@@ ) return Number L ; @@v3@@ = Number L ; do { ++ @@a1@@ ; @@v3@@ = @@v2@@ + __ROL8__ ( @@v3@@ , Number ) ; @@v2@@ = * @@a1@@ ; } while ( ( _BYTE ) @@v2@@ ) ; return @@v3@@ % @@a2@@ ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
char * __fastcall areadlink_with_size ( char * @@path@@ , unsigned __int64 @@a2@@ ) { size_t @@v2@@ ; char * @@v3@@ ; char * @@v4@@ ; ssize_t @@v5@@ ; char * @@v7@@ ; @@v2@@ = @@a2@@ + Number ; if ( @@a2@@ >= Number ) @@v2@@ = Number L ; while ( Number ) { @@v3@@ = ( char * ) malloc ( @@v2@@ ) ; @@v4@@ = @@v3@@ ; if ( @@v3@@ ) { while ( Number ) { @@v5@@ = readlink ( @@path@@ , @@v3@@ , @@v2@@ ) ; if ( @@v5@@ < Number && * __errno_location ( ) != Number ) { @@v7@@ = @@v4@@ ; @@v4@@ = Number L ; free ( @@v7@@ ) ; return @@v4@@ ; } if ( @@v2@@ > @@v5@@ ) { @@v4@@ [ @@v5@@ ] = Number ; return @@v4@@ ; } free ( @@v4@@ ) ; if ( @@v2@@ > Number ) break ; @@v2@@ *= Number L ; @@v3@@ = ( char * ) malloc ( @@v2@@ ) ; @@v4@@ = @@v3@@ ; if ( ! @@v3@@ ) return @@v4@@ ; } if ( @@v2@@ <= Number ) { @@v2@@ = Number ; continue ; } @@v4@@ = Number L ; * __errno_location ( ) = Number ; } break ; } return @@v4@@ ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
int __fastcall rpl_linkat ( int @@fd@@ , char * @@path@@ , int @@a3@@ , const char * @@a4@@ , int @@a5@@ ) { int @@v6@@ ; char * @@v8@@ ; int @@v9@@ ; char * @@v10@@ ; _BYTE * @@v11@@ ; void * @@v12@@ ; _BYTE * @@v13@@ ; int @@v14@@ ; int @@v15@@ ; int @@tofda@@ ; int * @@v19@@ ; if ( ! @@a5@@ ) return linkat ( @@fd@@ , @@path@@ , @@a3@@ , @@a4@@ , Number ) ; if ( ( @@a5@@ & Number ) != Number ) { @@v6@@ = Number ; * __errno_location ( ) = Number ; return @@v6@@ ; } if ( have_follow_really_4922 < Number ) { @@v19@@ = __errno_location ( ) ; } else { @@v6@@ = linkat ( @@fd@@ , @@path@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; if ( @@v6@@ != Number || ( @@v19@@ = __errno_location ( ) , * @@v19@@ != Number ) ) { have_follow_really_4922 = Number ; return @@v6@@ ; } have_follow_really_4922 = Number ; } @@v8@@ = @@path@@ ; @@v9@@ = Number ; while ( Number ) { @@v11@@ = ( _BYTE * ) areadlinkat ( @@fd@@ , @@v8@@ ) ; @@v12@@ = @@v11@@ ; if ( ! @@v11@@ ) break ; if ( * @@v11@@ != Number ) { @@v13@@ = mdir_name ( @@v8@@ ) ; if ( @@path@@ != @@v8@@ ) free ( @@v8@@ ) ; if ( ! @@v13@@ ) { @@v6@@ = Number ; free ( @@v12@@ ) ; * @@v19@@ = Number ; return @@v6@@ ; } @@v8@@ = ( char * ) mfile_name_concat ( @@v13@@ , @@v12@@ , Number L ) ; free ( @@v13@@ ) ; free ( @@v12@@ ) ; if ( ! @@v8@@ ) { @@v6@@ = Number ; * @@v19@@ = Number ; return @@v6@@ ; } goto LABEL_11 ; } if ( @@path@@ == @@v8@@ ) { -- @@v9@@ ; @@v8@@ = @@v11@@ ; if ( ! @@v9@@ ) { LABEL_20 : * @@v19@@ = Number ; @@v14@@ = Number ; goto LABEL_21 ; } } else { @@v10@@ = @@v8@@ ; @@v8@@ = @@v11@@ ; free ( @@v10@@ ) ; LABEL_11 : if ( ! -- @@v9@@ ) goto LABEL_20 ; } } @@v14@@ = * @@v19@@ ; if ( * @@v19@@ != Number ) { LABEL_21 : @@tofda@@ = @@v14@@ ; @@v6@@ = Number ; if ( @@path@@ != @@v8@@ ) { free ( @@v8@@ ) ; * @@v19@@ = @@tofda@@ ; } return @@v6@@ ; } @@v6@@ = linkat ( @@fd@@ , @@v8@@ , @@a3@@ , @@a4@@ , Number ) ; if ( @@path@@ != @@v8@@ ) { @@v15@@ = * @@v19@@ ; free ( @@v8@@ ) ; * @@v19@@ = @@v15@@ ; } return @@v6@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
bool __fastcall triple_compare_ino_str ( __int64 @@a1@@ , __int64 @@a2@@ ) { bool @@result@@ ; @@result@@ = Number ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) == * ( _QWORD * ) ( @@a2@@ + Number ) && * ( _QWORD * ) ( @@a1@@ + Number ) == * ( _QWORD * ) ( @@a2@@ + Number ) ) { @@result@@ = strcmp ( * ( const char * * ) @@a1@@ , * ( const char * * ) @@a2@@ ) == Number ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_2081D0 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2081B0 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_2081C0 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
bool __fastcall seen_file ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 * @@a3@@ ) { bool @@result@@ ; __int64 @@v4@@ ; __int64 @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; @@result@@ = Number ; if ( @@a1@@ ) { @@v4@@ = @@a3@@ [ Number ] ; @@v5@@ [ Number ] = @@a2@@ ; @@v5@@ [ Number ] = @@v4@@ ; @@v5@@ [ Number ] = * @@a3@@ ; @@result@@ = hash_lookup ( @@a1@@ , ( __int64 ) @@v5@@ ) != Number ; } return @@result@@ ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
unsigned __int64 __fastcall triple_hash ( _QWORD * @@a1@@ , unsigned __int64 @@a2@@ ) { return ( @@a1@@ [ Number ] ^ ( unsigned __int64 ) hash_pjw ( * @@a1@@ ) ) % @@a2@@ ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
bool __fastcall triple_compare_ino_str ( __int64 @@a1@@ , __int64 @@a2@@ ) { bool @@result@@ ; @@result@@ = Number ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) == * ( _QWORD * ) ( @@a2@@ + Number ) && * ( _QWORD * ) ( @@a1@@ + Number ) == * ( _QWORD * ) ( @@a2@@ + Number ) ) { @@result@@ = strcmp ( * ( const char * * ) @@a1@@ , * ( const char * * ) @@a2@@ ) == Number ; } return @@result@@ ; }
_BYTE * __fastcall mdir_name ( void * @@src@@ ) { __int64 @@v1@@ ; _BYTE * @@v2@@ ; _BYTE * @@v3@@ ; _BYTE * @@v4@@ ; @@v1@@ = dir_len ( @@src@@ ) ; @@v2@@ = malloc ( @@v1@@ + ( @@v1@@ == Number ) + Number ) ; @@v3@@ = @@v2@@ ; if ( @@v2@@ ) { @@v4@@ = memcpy ( @@v2@@ , @@src@@ , @@v1@@ ) ; @@v3@@ = @@v4@@ ; if ( ! @@v1@@ ) { * @@v4@@ = Number ; @@v1@@ = Number L ; } @@v4@@ [ @@v1@@ ] = Number ; } return @@v3@@ ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
__int64 __fastcall filemodestring ( __int64 @@a1@@ , __int64 @@a2@@ ) { return strmode ( * ( _DWORD * ) ( @@a1@@ + Number ) , @@a2@@ ) ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall dir_len ( _BYTE * @@a1@@ ) { unsigned __int64 @@v1@@ ; _BYTE * @@v2@@ ; __int64 @@v3@@ ; @@v1@@ = * @@a1@@ == Number ; @@v2@@ = last_component ( @@a1@@ ) ; if ( @@v2@@ - @@a1@@ <= @@v1@@ ) return @@v2@@ - @@a1@@ ; @@v3@@ = @@v2@@ - @@a1@@ - Number ; if ( * ( @@v2@@ - Number ) != Number ) return @@v2@@ - @@a1@@ ; while ( @@v1@@ != @@v3@@ && @@a1@@ [ @@v3@@ - Number ] == Number ) -- @@v3@@ ; return @@v3@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 __fastcall same_name ( _BYTE * @@a1@@ , _BYTE * @@a2@@ ) { unsigned int @@v2@@ ; const char * @@v3@@ ; const char * @@v4@@ ; size_t @@v5@@ ; char * @@v7@@ ; char * @@v8@@ ; int * @@v9@@ ; int * @@v10@@ ; struct stat @@v11@@ ; struct stat @@stat_buf@@ ; unsigned __int64 @@v13@@ ; @@v2@@ = Number ; @@v13@@ = __readfsqword ( Number ) ; @@v3@@ = last_component ( @@a1@@ ) ; @@v4@@ = last_component ( @@a2@@ ) ; @@v5@@ = base_len ( @@v3@@ ) ; if ( @@v5@@ == base_len ( @@v4@@ ) && ! memcmp ( @@v3@@ , @@v4@@ , @@v5@@ ) ) { @@v7@@ = ( char * ) dir_name ( @@a1@@ ) ; @@v8@@ = ( char * ) dir_name ( @@a2@@ ) ; if ( __xstat ( Number , @@v7@@ , & @@v11@@ ) ) { @@v10@@ = __errno_location ( ) ; error ( Number , * @@v10@@ , String , @@v7@@ ) ; } if ( __xstat ( Number , @@v8@@ , & @@stat_buf@@ ) ) { @@v9@@ = __errno_location ( ) ; error ( Number , * @@v9@@ , String , @@v8@@ ) ; } @@v2@@ = Number ; if ( @@v11@@ . st_ino == @@stat_buf@@ . st_ino ) LOBYTE ( @@v2@@ ) = @@v11@@ . st_dev == @@stat_buf@@ . st_dev ; free ( @@v7@@ ) ; free ( @@v8@@ ) ; } return @@v2@@ ; }
void * __fastcall mfile_name_concat ( void * @@src@@ , void * @@a2@@ , _QWORD * @@a3@@ ) { const char * @@v4@@ ; const char * @@v5@@ ; size_t @@v6@@ ; size_t @@v7@@ ; _BOOL8 @@v8@@ ; void * @@v9@@ ; void * @@v10@@ ; _BYTE * @@v11@@ ; char * @@v12@@ ; size_t @@n@@ ; char @@v15@@ ; @@v4@@ = ( const char * ) @@a2@@ ; @@v5@@ = last_component ( @@src@@ ) ; @@v6@@ = base_len ( @@v5@@ ) ; @@v7@@ = @@v6@@ + @@v5@@ - ( _BYTE * ) @@src@@ ; @@v8@@ = @@v6@@ ; if ( @@v6@@ ) @@v8@@ = @@v5@@ [ @@v6@@ - Number ] != Number ; @@v15@@ = * ( _BYTE * ) @@a2@@ ; if ( * ( _BYTE * ) @@a2@@ == Number ) { do ++ @@v4@@ ; while ( * @@v4@@ == Number ) ; } @@n@@ = strlen ( @@v4@@ ) ; @@v9@@ = malloc ( @@n@@ + @@v8@@ + @@v7@@ + Number ) ; @@v10@@ = @@v9@@ ; if ( @@v9@@ ) { @@v11@@ = mempcpy ( @@v9@@ , @@src@@ , @@v7@@ ) ; * @@v11@@ = Number ; @@v12@@ = & @@v11@@ [ @@v8@@ ] ; if ( @@a3@@ ) * @@a3@@ = & @@v12@@ [ - ( @@v15@@ == Number ) ] ; * ( _BYTE * ) mempcpy ( @@v12@@ , @@v4@@ , @@n@@ ) = Number ; } return @@v10@@ ; }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v2@@ ; char * @@v3@@ ; FILE * @@v4@@ ; char * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; char * @@v9@@ ; char * @@v10@@ ; bool @@v11@@ ; bool @@v12@@ ; const char * @@v13@@ ; __int64 @@v14@@ ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v2@@ = stdout ; @@v3@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v3@@ , @@v2@@ ) ; @@v4@@ = stdout ; @@v5@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v5@@ , @@v4@@ ) ; @@v6@@ = dcgettext ( Number L , String String String String , Number ) ; __printf_chk ( ) ; last_component ( program_name , @@v6@@ ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = Number L ; @@v10@@ = setlocale ( Number , Number L ) ; @@v11@@ = Number ; @@v12@@ = @@v10@@ == Number L ; if ( @@v10@@ ) { @@v13@@ = String ; @@v9@@ = @@v10@@ ; @@v14@@ = Number L ; do { if ( ! @@v14@@ ) break ; @@v11@@ = ( unsigned __int8 ) * @@v9@@ < ( unsigned int ) * @@v13@@ ; @@v12@@ = * @@v9@@ ++ == * @@v13@@ ++ ; -- @@v14@@ ; } while ( @@v12@@ ) ; if ( ( ! @@v11@@ && ! @@v12@@ ) != @@v11@@ ) { last_component ( program_name , @@v9@@ ) ; @@v9@@ = dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name , @@v9@@ ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; exit ( @@status@@ ) ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 __fastcall lutimens ( char * @@path@@ , const __m128i * @@a2@@ ) { int @@v2@@ ; struct timespec * @@v3@@ ; int @@v4@@ ; unsigned int @@v5@@ ; __time_t @@v7@@ ; __syscall_slong_t @@v8@@ ; struct timespec * @@times@@ ; __int128 @@v10@@ [ Number ] ; struct stat @@stat_buf@@ ; unsigned __int64 @@v12@@ ; @@v12@@ = __readfsqword ( Number ) ; if ( ! @@a2@@ ) { @@v3@@ = Number L ; @@v2@@ = Number ; @@times@@ = Number L ; if ( lutimensat_works_really < Number ) { lutimensat_works_really = Number ; LABEL_17 : if ( __lxstat ( Number , @@path@@ , & @@stat_buf@@ ) ) return ( unsigned int ) Number ; goto LABEL_12 ; } goto LABEL_6 ; } @@v10@@ [ Number ] = ( __int128 ) _mm_loadu_si128 ( @@a2@@ ) ; @@times@@ = ( struct timespec * ) @@v10@@ ; @@v10@@ [ Number ] = ( __int128 ) _mm_loadu_si128 ( @@a2@@ + Number ) ; @@v2@@ = validate_timespec ( @@v10@@ ) ; if ( @@v2@@ < Number ) return ( unsigned int ) Number ; if ( lutimensat_works_really >= Number ) { if ( @@v2@@ == Number ) { if ( __lxstat ( Number , @@path@@ , & @@stat_buf@@ ) ) return ( unsigned int ) Number ; @@v3@@ = @@times@@ ; if ( @@times@@ -> tv_nsec == Number ) { @@v8@@ = @@stat_buf@@ . st_atim . tv_nsec ; @@v2@@ = Number ; @@times@@ -> tv_sec = @@stat_buf@@ . st_atim . tv_sec ; @@v3@@ -> tv_nsec = @@v8@@ ; } else { @@v2@@ = Number ; if ( @@times@@ [ Number ] . tv_nsec == Number ) { @@v7@@ = @@stat_buf@@ . st_mtim . tv_sec ; @@times@@ [ Number ] . tv_nsec = @@stat_buf@@ . st_mtim . tv_nsec ; @@v3@@ [ Number ] . tv_sec = @@v7@@ ; } } } else { @@v3@@ = @@times@@ ; } LABEL_6 : @@v4@@ = utimensat ( Number , @@path@@ , @@v3@@ , Number ) ; @@v5@@ = @@v4@@ ; if ( @@v4@@ <= Number ) { if ( ! @@v4@@ || * __errno_location ( ) != Number ) { utimensat_works_really = Number ; lutimensat_works_really = Number ; return @@v5@@ ; } } else { * __errno_location ( ) = Number ; } } lutimensat_works_really = Number ; if ( ! @@v2@@ ) goto LABEL_17 ; if ( @@v2@@ == Number ) { if ( ! @@times@@ ) { LABEL_12 : if ( ( @@stat_buf@@ . st_mode & Number ) != Number ) return ( unsigned int ) fdutimens ( @@path@@ , Number , ( const __m128i * ) @@times@@ ) ; * __errno_location ( ) = Number ; return ( unsigned int ) Number ; } } else { if ( __lxstat ( Number , @@path@@ , & @@stat_buf@@ ) ) return ( unsigned int ) Number ; if ( ! @@times@@ ) goto LABEL_12 ; } @@v5@@ = Number ; if ( ! ( unsigned __int8 ) update_timespec ( & @@stat_buf@@ , & @@times@@ ) ) goto LABEL_12 ; return @@v5@@ ; }
char * __fastcall fts_alloc ( __int64 @@a1@@ , const void * @@a2@@ , size_t @@a3@@ ) { char * @@v4@@ ; char * @@v5@@ ; __int64 @@v6@@ ; @@v4@@ = ( char * ) malloc ( @@a3@@ + Number ) ; @@v5@@ = @@v4@@ ; if ( @@v4@@ ) { memcpy ( @@v4@@ + Number , @@a2@@ , @@a3@@ ) ; @@v6@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v5@@ [ @@a3@@ + Number ] = Number ; * ( ( _QWORD * ) @@v5@@ + Number ) = @@a3@@ ; * ( ( _QWORD * ) @@v5@@ + Number ) = @@a1@@ ; * ( ( _DWORD * ) @@v5@@ + Number ) = Number ; * ( _DWORD * ) ( @@v5@@ + Number ) = Number ; * ( ( _QWORD * ) @@v5@@ + Number ) = @@v6@@ ; * ( ( _QWORD * ) @@v5@@ + Number ) = Number L ; * ( ( _QWORD * ) @@v5@@ + Number ) = Number L ; } return @@v5@@ ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
bool __fastcall setup_dir_isra_4 ( __int16 @@a1@@ , __int64 * @@a2@@ ) { __int64 @@v2@@ ; bool @@result@@ ; void * @@v4@@ ; if ( ( @@a1@@ & Number ) != Number ) { @@v2@@ = hash_initialize ( Number L , Number L , AD_hash , AD_compare , & free ) ; * @@a2@@ = @@v2@@ ; @@result@@ = @@v2@@ != Number ; } else { @@v4@@ = malloc ( Number ) ; * @@a2@@ = ( __int64 ) @@v4@@ ; @@result@@ = Number ; if ( @@v4@@ ) { cycle_check_init ( ) ; @@result@@ = Number ; } } return @@result@@ ; }
bool __fastcall euidaccess_stat ( _DWORD * @@a1@@ , char @@a2@@ ) { __uid_t @@v3@@ ; unsigned int @@v4@@ ; __gid_t @@v5@@ ; __gid_t @@v6@@ ; if ( ( @@a2@@ & Number ) == Number ) return Number ; @@v3@@ = geteuid ( ) ; if ( @@v3@@ ) { @@v4@@ = @@a1@@ [ Number ] ; } else { if ( ( @@a2@@ & Number ) == Number ) return Number ; @@v4@@ = @@a1@@ [ Number ] ; if ( ( @@v4@@ & Number ) != Number ) return Number ; } if ( @@a1@@ [ Number ] == @@v3@@ ) { @@v4@@ >>= Number ; } else { @@v5@@ = getegid ( ) ; @@v6@@ = @@a1@@ [ Number ] ; if ( @@v6@@ == @@v5@@ || group_member ( @@v6@@ ) ) @@v4@@ >>= Number ; } return ( @@a2@@ & Number & ~ @@v4@@ ) == Number ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
unsigned __int64 __fastcall raw_hasher ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return __ROR8__ ( @@a1@@ , Number ) % @@a2@@ ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
__int64 __fastcall hash_get_n_buckets_used ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
unsigned __int64 __fastcall hash_pjw ( char * @@a1@@ , unsigned __int64 @@a2@@ ) { __int64 @@v2@@ ; unsigned __int64 @@v3@@ ; @@v2@@ = * @@a1@@ ; if ( ! ( _BYTE ) @@v2@@ ) return Number L ; @@v3@@ = Number L ; do { ++ @@a1@@ ; @@v3@@ = @@v2@@ + __ROL8__ ( @@v3@@ , Number ) ; @@v2@@ = * @@a1@@ ; } while ( ( _BYTE ) @@v2@@ ) ; return @@v3@@ % @@a2@@ ; }
__int64 __fastcall hash_get_n_entries ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
int __fastcall argmatch_valid ( _QWORD * @@a1@@ , char * @@a2@@ , size_t @@a3@@ ) { const void * @@v5@@ ; __int64 @@v6@@ ; char * @@v7@@ ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; if ( * @@a1@@ ) { @@v5@@ = Number L ; @@v6@@ = Number L ; do { while ( ! @@v6@@ || memcmp ( @@v5@@ , @@a2@@ , @@a3@@ ) ) { ++ @@v6@@ ; @@v5@@ = @@a2@@ ; __fprintf_chk ( ) ; @@a2@@ += @@a3@@ ; if ( ! @@a1@@ [ @@v6@@ ] ) goto LABEL_7 ; } ++ @@v6@@ ; @@a2@@ += @@a3@@ ; __fprintf_chk ( ) ; } while ( @@a1@@ [ @@v6@@ ] ) ; } LABEL_7 : @@v7@@ = stderr -> _IO_write_ptr ; if ( @@v7@@ >= stderr -> _IO_write_end ) { LODWORD ( @@v7@@ ) = __overflow ( stderr , Number ) ; } else { stderr -> _IO_write_ptr = @@v7@@ + Number ; * @@v7@@ = Number ; } return ( int ) @@v7@@ ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 __fastcall hash_get_first ( __int64 @@a1@@ ) { __int64 * @@v1@@ ; unsigned __int64 @@v2@@ ; __int64 @@result@@ ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; @@v1@@ = * ( __int64 * * ) @@a1@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( * ( _QWORD * ) @@a1@@ >= @@v2@@ ) goto LABEL_9 ; @@result@@ = * @@v1@@ ; if ( ! * @@v1@@ ) { while ( Number ) { @@v1@@ += Number ; if ( ( unsigned __int64 ) @@v1@@ >= @@v2@@ ) break ; @@result@@ = * @@v1@@ ; if ( * @@v1@@ ) return @@result@@ ; } LABEL_9 : abort ( ) ; } return @@result@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
void __fastcall cycle_check_init ( __int64 @@a1@@ ) { * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _DWORD * ) ( @@a1@@ + Number ) = Number ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
unsigned __int64 __fastcall hash_string ( unsigned __int8 * @@a1@@ , unsigned __int64 @@a2@@ ) { __int64 @@v2@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@v4@@ ; @@v2@@ = * @@a1@@ ; for ( @@i@@ = Number L ; ( _BYTE ) @@v2@@ ; @@i@@ = @@v4@@ % @@a2@@ ) { ++ @@a1@@ ; @@v4@@ = @@v2@@ + Number * @@i@@ ; @@v2@@ = * @@a1@@ ; } return @@i@@ ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_2051D0 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2051B0 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_2051C0 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
__int64 __fastcall hash_reset_tuning ( __int64 @@a1@@ ) { __int64 @@result@@ ; * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; * ( _QWORD * ) @@a1@@ = Number ; @@result@@ = Number ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number ; return @@result@@ ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
struct passwd * getpwnam ( const char * @@name@@ ) { return getpwnam ( @@name@@ ) ; }
__int64 __fastcall plain_read ( void * @@buf@@ , size_t @@nbytes@@ ) { __int64 @@result@@ ; @@result@@ = safe_read ( Number , @@buf@@ , @@nbytes@@ ) ; if ( @@result@@ == Number ) { plain_read_part_1 ( ) ; @@result@@ = Number ; } return @@result@@ ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
void __fastcall i_ring_init ( __int64 @@a1@@ , int @@a2@@ ) { * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
unsigned __int64 __fastcall read_and_xlate ( void * @@buf@@ , size_t @@nbytes@@ ) { unsigned __int64 @@result@@ ; unsigned __int64 @@i@@ ; @@result@@ = safe_read ( Number , @@buf@@ , @@nbytes@@ ) ; if ( @@result@@ == Number ) { plain_read_part_1 ( ) ; @@result@@ = Number ; } else if ( ! @@result@@ ) { return @@result@@ ; } for ( @@i@@ = Number L ; @@i@@ < @@result@@ ; ++ @@i@@ ) * ( ( _BYTE * ) @@buf@@ + @@i@@ ) = xlate [ * ( ( unsigned __int8 * ) @@buf@@ + @@i@@ ) ] ; return @@result@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 __fastcall i_ring_pop ( __int64 @@a1@@ ) { _DWORD * @@v1@@ ; int @@v2@@ ; __int64 @@result@@ ; if ( * ( _BYTE * ) ( @@a1@@ + Number ) ) abort ( ) ; @@v1@@ = ( _DWORD * ) ( @@a1@@ + Number L * * ( unsigned int * ) ( @@a1@@ + Number ) ) ; @@v2@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; @@result@@ = ( unsigned int ) * @@v1@@ ; * @@v1@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; if ( @@v2@@ == * ( _DWORD * ) ( @@a1@@ + Number ) ) * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; else * ( _DWORD * ) ( @@a1@@ + Number ) = ( ( _BYTE ) @@v2@@ + Number ) & Number ; return @@result@@ ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
bool __fastcall is_char_class_member ( int @@a1@@ , unsigned __int8 @@a2@@ ) { int @@v2@@ ; switch ( @@a1@@ ) { case Number : @@v2@@ = ( * __ctype_b_loc ( ) ) [ @@a2@@ ] & Number ; break ; case Number : @@v2@@ = ( * __ctype_b_loc ( ) ) [ @@a2@@ ] & Number ; break ; case Number : @@v2@@ = ( * __ctype_b_loc ( ) ) [ @@a2@@ ] & Number ; break ; case Number : @@v2@@ = ( * __ctype_b_loc ( ) ) [ @@a2@@ ] & Number ; break ; case Number : @@v2@@ = ( * __ctype_b_loc ( ) ) [ @@a2@@ ] & Number ; break ; case Number : @@v2@@ = ( * __ctype_b_loc ( ) ) [ @@a2@@ ] & Number ; break ; case Number : @@v2@@ = ( * __ctype_b_loc ( ) ) [ @@a2@@ ] & Number ; break ; case Number : @@v2@@ = ( * __ctype_b_loc ( ) ) [ @@a2@@ ] & Number ; break ; case Number : @@v2@@ = ( * __ctype_b_loc ( ) ) [ @@a2@@ ] & Number ; break ; case Number : @@v2@@ = ( * __ctype_b_loc ( ) ) [ @@a2@@ ] & Number ; break ; case Number : @@v2@@ = ( * __ctype_b_loc ( ) ) [ @@a2@@ ] & Number ; break ; case Number : @@v2@@ = ( * __ctype_b_loc ( ) ) [ @@a2@@ ] & Number ; break ; default : abort ( ) ; } return @@v2@@ != Number ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; FILE * @@v11@@ ; char * @@v12@@ ; FILE * @@v13@@ ; char * @@v14@@ ; FILE * @@v15@@ ; char * @@v16@@ ; char * @@v17@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String String String String String String String String String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String String String String String String String String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = stdout ; @@v10@@ = dcgettext ( Number L , String String String String String String String String String , Number ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; @@v11@@ = stdout ; @@v12@@ = dcgettext ( Number L , String String String String String String String String , Number ) ; fputs_unlocked ( @@v12@@ , @@v11@@ ) ; @@v13@@ = stdout ; @@v14@@ = dcgettext ( Number L , String String String String String String String String String , Number ) ; fputs_unlocked ( @@v14@@ , @@v13@@ ) ; last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v15@@ = stdout ; @@v16@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v16@@ , @@v15@@ ) ; @@v17@@ = setlocale ( Number , Number L ) ; if ( @@v17@@ ) { if ( strncmp ( @@v17@@ , String , Number ) ) { last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; program_invocation_short_name = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; __m128i * @@v10@@ ; __int64 @@v11@@ ; unsigned __int64 * @@v12@@ ; _BYTE * @@v13@@ ; unsigned __int64 @@v14@@ ; __int64 @@v15@@ ; __int64 @@v16@@ ; __int64 @@v17@@ ; unsigned __int64 @@v18@@ ; _BYTE * @@v19@@ ; unsigned __int64 @@v22@@ ; int @@v23@@ ; int @@v24@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v23@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = Number * @@v8@@ ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v9@@ , @@v8@@ ) ; slotvec = @@v7@@ ; @@v11@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v10@@ = ( __m128i * ) xrealloc ( slotvec , @@v9@@ , @@v8@@ ) ; @@v11@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v10@@ ; slotvec = @@v10@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v11@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v12@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v13@@ = ( _BYTE * ) @@v12@@ [ Number ] ; @@v24@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v22@@ = * @@v12@@ ; @@v14@@ = quotearg_buffer_restyled ( @@v13@@ , * @@v12@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v24@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v22@@ <= @@v14@@ ) { @@v18@@ = @@v14@@ + Number ; * @@v12@@ = @@v14@@ + Number ; if ( @@v13@@ != ( _BYTE * ) & slot0 ) free ( @@v13@@ ) ; @@v19@@ = ( _BYTE * ) xmalloc ( @@v18@@ , @@v18@@ , @@v15@@ , @@v16@@ , @@v17@@ ) ; @@v12@@ [ Number ] = ( unsigned __int64 ) @@v19@@ ; @@v13@@ = @@v19@@ ; quotearg_buffer_restyled ( @@v19@@ , @@v18@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v24@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v23@@ ; return @@v13@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
unsigned __int8 * __fastcall make_printable_char ( unsigned __int8 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { unsigned __int8 * @@v3@@ ; @@v3@@ = ( unsigned __int8 * ) xmalloc ( Number L , @@a2@@ , @@a3@@ ) ; if ( ( ( * __ctype_b_loc ( ) ) [ @@a1@@ ] & Number ) != Number ) { * @@v3@@ = @@a1@@ ; @@v3@@ [ Number ] = Number ; } else { __sprintf_chk ( ) ; } return @@v3@@ ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; int @@v12@@ ; _BYTE * @@v13@@ ; __int64 @@v14@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v12@@ = * @@v6@@ ; @@v14@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v13@@ = ( _BYTE * ) xmalloc ( @@v14@@ + Number , @@v14@@ + Number , @@v8@@ , @@v9@@ , @@v10@@ ) ; quotearg_buffer_restyled ( @@v13@@ , @@v14@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v12@@ ; if ( @@a3@@ ) * @@a3@@ = @@v14@@ ; return @@v13@@ ; }
unsigned __int64 __fastcall read_and_delete ( void * @@buf@@ , size_t @@nbytes@@ ) { unsigned __int64 @@result@@ ; __int64 @@v5@@ ; unsigned __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@i@@ ; while ( Number ) { @@result@@ = safe_read ( Number , @@buf@@ , @@nbytes@@ ) ; if ( @@result@@ == Number ) { plain_read_part_1 ( ) ; @@result@@ = Number ; } else if ( ! @@result@@ ) { return @@result@@ ; } if ( ! in_delete_set [ * ( unsigned __int8 * ) @@buf@@ ] ) break ; @@v5@@ = Number L ; @@v6@@ = Number L ; if ( @@result@@ > Number ) { do { LABEL_5 : @@v7@@ = * ( ( unsigned __int8 * ) @@buf@@ + @@v6@@ ) ; if ( ! in_delete_set [ @@v7@@ ] ) * ( ( _BYTE * ) @@buf@@ + @@v5@@ ++ ) = @@v7@@ ; ++ @@v6@@ ; } while ( @@result@@ > @@v6@@ ) ; if ( @@v5@@ ) return @@v5@@ ; } } for ( @@i@@ = Number L ; ; ++ @@i@@ ) { @@v5@@ = @@i@@ + Number ; if ( @@i@@ + Number >= @@result@@ || in_delete_set [ * ( ( unsigned __int8 * ) @@buf@@ + @@i@@ + Number ) ] ) { break ; } } @@v6@@ = @@i@@ + Number ; if ( @@result@@ > @@v6@@ ) goto LABEL_5 ; return @@v5@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; _BYTE * @@v16@@ ; unsigned __int64 @@v19@@ ; int @@v20@@ ; int @@v21@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v20@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v21@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v19@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v21@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v19@@ <= @@v13@@ ) { @@v15@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v16@@ = ( _BYTE * ) xmalloc ( @@v15@@ , @@v15@@ , @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v16@@ ; @@v12@@ = @@v16@@ ; quotearg_buffer_restyled ( @@v16@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v21@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v20@@ ; return @@v12@@ ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_216250 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_216230 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_216240 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
__int64 __fastcall savedirstream ( DIR * @@dirp@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ ) { size_t @@v5@@ ; unsigned __int64 @@v6@@ ; __int64 @@v7@@ ; int * @@v8@@ ; struct dirent * @@v9@@ ; char @@v10@@ ; char * @@v11@@ ; size_t @@v12@@ ; size_t @@v13@@ ; size_t @@v14@@ ; unsigned __int64 @@v15@@ ; __int64 @@v16@@ ; int @@v17@@ ; void * @@v19@@ ; size_t @@n@@ ; size_t @@na@@ ; size_t @@v22@@ ; if ( ! @@dirp@@ ) return Number L ; @@v5@@ = Number L ; @@v6@@ = Number L ; @@v7@@ = xmalloc ( Number L , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; @@v8@@ = __errno_location ( ) ; while ( Number ) { * @@v8@@ = Number ; @@v9@@ = readdir ( @@dirp@@ ) ; if ( ! @@v9@@ ) break ; @@v10@@ = @@v9@@ -> d_name [ Number ] ; @@v11@@ = @@v9@@ -> d_name ; if ( @@v10@@ == Number ) { if ( @@v9@@ -> d_name [ Number ] == Number ) { @@v10@@ = @@v9@@ -> d_name [ Number ] ; goto LABEL_3 ; } if ( @@v9@@ -> d_name [ Number ] ) { LABEL_8 : @@v12@@ = strlen ( @@v9@@ -> d_name ) ; @@v13@@ = @@v12@@ + Number ; @@v14@@ = @@v12@@ + Number + @@v5@@ ; if ( __CFADD__ ( @@v12@@ + Number , @@v5@@ ) ) LABEL_21 : xalloc_die ( ) ; if ( @@v6@@ <= @@v14@@ ) { do { @@v15@@ = Number * @@v6@@ ; if ( Number * @@v6@@ < @@v6@@ ) goto LABEL_21 ; @@v6@@ *= Number L ; } while ( @@v14@@ >= @@v15@@ ) ; @@v22@@ = @@v12@@ + Number + @@v5@@ ; @@n@@ = @@v12@@ + Number ; @@v16@@ = xrealloc ( @@v7@@ , @@v15@@ , @@v13@@ ) ; @@v14@@ = @@v22@@ ; @@v13@@ = @@n@@ ; @@v7@@ = @@v16@@ ; } @@na@@ = @@v14@@ ; memcpy ( ( void * ) ( @@v7@@ + @@v5@@ ) , @@v11@@ , @@v13@@ ) ; @@v5@@ = @@na@@ ; } } else { LABEL_3 : if ( @@v10@@ ) goto LABEL_8 ; } } * ( _BYTE * ) ( @@v7@@ + @@v5@@ ) = Number ; @@v17@@ = * @@v8@@ ; if ( closedir ( @@dirp@@ ) ) @@v17@@ = * @@v8@@ ; if ( @@v17@@ ) { @@v19@@ = ( void * ) @@v7@@ ; @@v7@@ = Number L ; free ( @@v19@@ ) ; * @@v8@@ = @@v17@@ ; } return @@v7@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; __int64 @@v8@@ ; int @@v10@@ ; _BYTE * @@v11@@ ; __int64 @@v12@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = * @@v6@@ ; @@v12@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v11@@ = ( _BYTE * ) xmalloc ( @@v12@@ + Number , @@v12@@ + Number , @@v8@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v12@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v10@@ ; if ( @@a3@@ ) * @@a3@@ = @@v12@@ ; return @@v11@@ ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall validate_timespec ( _QWORD * @@a1@@ ) { unsigned __int64 @@v1@@ ; unsigned __int64 @@v2@@ ; int @@v3@@ ; int @@v4@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) __assert_fail ( String , String , Number , String ) ; @@v1@@ = @@a1@@ [ Number ] ; if ( @@v1@@ - Number > Number && @@v1@@ > Number || ( @@v2@@ = @@a1@@ [ Number ] , @@v2@@ - Number > Number ) && @@v2@@ > Number ) { * __errno_location ( ) = Number ; @@result@@ = Number ; } else { @@v3@@ = Number ; @@v4@@ = Number ; if ( @@v1@@ - Number <= Number ) { * @@a1@@ = Number L ; @@v3@@ = @@v1@@ == Number ; @@v4@@ = Number ; } if ( @@v2@@ - Number <= Number ) { @@a1@@ [ Number ] = Number L ; @@v4@@ = Number ; @@v3@@ += @@v2@@ == Number ; } @@result@@ = @@v4@@ + ( unsigned int ) ( @@v3@@ == Number ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
int isatty ( int @@fd@@ ) { return isatty ( @@fd@@ ) ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
int fileno ( FILE * @@stream@@ ) { return fileno ( @@stream@@ ) ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
int fileno ( FILE * @@stream@@ ) { return fileno ( @@stream@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_20B4D0 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_20B4B0 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_20B4C0 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
wint_t btowc ( int @@c@@ ) { return btowc ( @@c@@ ) ; }
char * __fastcall areadlinkat ( int @@fd@@ , char * @@path@@ ) { int @@v2@@ ; size_t @@v3@@ ; char * @@v4@@ ; ssize_t @@v5@@ ; size_t @@v6@@ ; int * @@v7@@ ; char * @@v8@@ ; size_t @@v10@@ ; char * @@v11@@ ; char * @@v12@@ ; ssize_t @@v13@@ ; char @@ptr@@ [ Number ] ; unsigned __int64 @@v15@@ ; @@v2@@ = Number ; @@v3@@ = Number L ; @@v15@@ = __readfsqword ( Number ) ; @@v4@@ = @@ptr@@ ; while ( Number ) { @@v5@@ = readlinkat ( @@fd@@ , @@path@@ , @@v4@@ , @@v3@@ ) ; @@v6@@ = @@v5@@ ; if ( @@v5@@ < Number ) { @@v13@@ = @@v5@@ ; @@v7@@ = __errno_location ( ) ; @@v6@@ = @@v13@@ ; if ( * @@v7@@ != Number ) { if ( @@v4@@ != @@ptr@@ ) { @@v8@@ = @@v4@@ ; @@v4@@ = Number L ; free ( @@v8@@ ) ; return @@v4@@ ; } return Number L ; } } if ( @@v6@@ < @@v3@@ ) break ; if ( @@v4@@ != @@ptr@@ ) free ( @@v4@@ ) ; @@v3@@ *= Number L ; if ( ! -- @@v2@@ ) { @@v4@@ = Number L ; * __errno_location ( ) = Number ; return @@v4@@ ; } @@v4@@ = ( char * ) malloc ( @@v3@@ ) ; if ( ! @@v4@@ ) return Number L ; } @@v4@@ [ @@v6@@ ] = Number ; @@v10@@ = @@v6@@ + Number ; if ( @@v4@@ == @@ptr@@ ) { @@v12@@ = ( char * ) malloc ( @@v6@@ + Number ) ; @@v4@@ = @@v12@@ ; if ( @@v12@@ ) memcpy ( @@v12@@ , @@ptr@@ , @@v10@@ ) ; } else if ( @@v3@@ > @@v10@@ ) { @@v11@@ = ( char * ) realloc ( @@v4@@ , @@v6@@ + Number ) ; if ( @@v11@@ ) @@v4@@ = @@v11@@ ; } return @@v4@@ ; }
size_t __fastcall writeline ( __int64 @@a1@@ , char @@a2@@ , __int64 @@a3@@ ) { size_t @@result@@ ; if ( @@a3@@ ) { if ( ! @@a2@@ ) { @@result@@ = ( unsigned __int8 ) output_first_repeated ^ Number ; if ( output_first_repeated != Number ) return @@result@@ ; goto LABEL_4 ; } @@result@@ = ( unsigned __int8 ) output_later_repeated ^ Number ; } else { @@result@@ = ( unsigned __int8 ) output_unique ^ Number ; } if ( ( _BYTE ) @@result@@ ) return @@result@@ ; LABEL_4 : if ( ! countmode ) __printf_chk ( ) ; return fwrite_unlocked ( * ( const void * * ) ( @@a1@@ + Number ) , Number , * ( _QWORD * ) ( @@a1@@ + Number ) , stdout ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
int fflush_unlocked ( FILE * @@stream@@ ) { return fflush_unlocked ( @@stream@@ ) ; }
__int64 __fastcall dup_cloexec ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
char * _do_global_dtors_aux ( ) { char * @@result@@ ; if ( ! _bss_start ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; _bss_start = Number ; } return @@result@@ ; }
_QWORD * __fastcall readlinebuffer ( _QWORD * @@a1@@ , _IO_FILE * @@a2@@ ) { return readlinebuffer_delim ( @@a1@@ , @@a2@@ , Number ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
__int64 __fastcall size_opt ( char * @@a1@@ , const char * @@a2@@ ) { char * @@v2@@ ; __int64 @@v4@@ ; if ( ( unsigned int ) xstrtoul ( @@a1@@ ) > Number ) { @@v2@@ = dcgettext ( Number L , @@a2@@ , Number ) ; error ( Number , Number , String , @@a1@@ , @@v2@@ ) ; } return @@v4@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; program_invocation_short_name = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
__int64 __fastcall cycle_check ( __int64 @@a1@@ , __int64 * @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@result@@ ; __int64 @@v5@@ ; if ( * ( _DWORD * ) ( @@a1@@ + Number ) != Number ) __assert_fail ( String , String , Number , String ) ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v3@@ = @@a2@@ [ Number ] ; if ( ! @@v2@@ ) { * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; goto LABEL_7 ; } if ( * ( _QWORD * ) @@a1@@ == @@v3@@ && * @@a2@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ) { return Number L ; } @@result@@ = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v2@@ + Number ; if ( ( ( @@v2@@ + Number ) & @@v2@@ ) == Number ) { if ( @@v2@@ == Number ) return Number L ; LABEL_7 : @@v5@@ = * @@a2@@ ; * ( _QWORD * ) @@a1@@ = @@v3@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v5@@ ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall output ( void * @@src@@ , __int64 @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; char * @@v4@@ ; size_t @@v5@@ ; char * @@v6@@ ; const void * @@v7@@ ; char * @@v8@@ ; __int64 @@result@@ ; @@v2@@ = bytes_in_buffer_6579 ; if ( @@src@@ ) { @@v3@@ = Number - bytes_in_buffer_6579 ; @@v4@@ = ( char * ) @@src@@ ; @@v5@@ = @@a2@@ - ( _QWORD ) @@src@@ ; if ( @@a2@@ - ( __int64 ) @@src@@ < Number - bytes_in_buffer_6579 ) { @@v8@@ = ( char * ) & buffer_6578 + bytes_in_buffer_6579 ; } else { do { @@v6@@ = ( char * ) & buffer_6578 + @@v2@@ ; @@v7@@ = @@v4@@ ; @@v5@@ -= @@v3@@ ; @@v4@@ += @@v3@@ ; @@v2@@ = Number L ; memcpy ( @@v6@@ , @@v7@@ , @@v3@@ ) ; @@v3@@ = Number ; fwrite_unlocked ( & buffer_6578 , Number , Number , stdout ) ; bytes_in_buffer_6579 = Number L ; } while ( @@v5@@ > Number ) ; @@v8@@ = ( char * ) & buffer_6578 ; } @@result@@ = ( __int64 ) memcpy ( @@v8@@ , @@v4@@ , @@v5@@ ) ; bytes_in_buffer_6579 = @@v5@@ + @@v2@@ ; } else { @@result@@ = fwrite_unlocked ( & buffer_6578 , Number , bytes_in_buffer_6579 , stdout ) ; bytes_in_buffer_6579 = Number L ; } return @@result@@ ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
void __fastcall initbuffer ( __int64 @@a1@@ ) { * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _OWORD * ) @@a1@@ = Number L ; }
__int64 __fastcall xmemcoll ( void * @@a1@@ , size_t @@a2@@ , void * @@a3@@ , __int64 @@a4@@ ) { unsigned int @@v6@@ ; int @@v7@@ ; char * @@v8@@ ; char * @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; char * @@v12@@ ; @@v6@@ = memcoll ( @@a1@@ , @@a2@@ , @@a3@@ ) ; @@v7@@ = * __errno_location ( ) ; if ( @@v7@@ ) { @@v8@@ = dcgettext ( Number L , String , Number ) ; error ( Number , @@v7@@ , @@v8@@ ) ; @@v9@@ = dcgettext ( Number L , String , Number ) ; error ( Number , Number , @@v9@@ ) ; @@v10@@ = quotearg_n_style_mem ( Number L , Number L , @@a3@@ , @@a4@@ ) ; @@v11@@ = quotearg_n_style_mem ( Number L , Number L , @@a1@@ , @@a2@@ ) ; @@v12@@ = dcgettext ( Number L , String , Number ) ; error ( exit_failure , Number , @@v12@@ , @@v11@@ , @@v10@@ ) ; } return @@v6@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
void __fastcall freebuffer ( __int64 @@a1@@ ) { free ( * ( void * * ) ( @@a1@@ + Number ) ) ; }
struct passwd * getpwuid ( __uid_t @@uid@@ ) { return getpwuid ( @@uid@@ ) ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; FILE * @@v11@@ ; char * @@v12@@ ; FILE * @@v13@@ ; char * @@v14@@ ; FILE * @@v15@@ ; char * @@v16@@ ; FILE * @@v17@@ ; char * @@v18@@ ; FILE * @@v19@@ ; char * @@v20@@ ; char * @@v21@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String String String String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = stdout ; @@v10@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; @@v11@@ = stdout ; @@v12@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v12@@ , @@v11@@ ) ; @@v13@@ = stdout ; @@v14@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v14@@ , @@v13@@ ) ; @@v15@@ = stdout ; @@v16@@ = dcgettext ( Number L , String String String , Number ) ; fputs_unlocked ( @@v16@@ , @@v15@@ ) ; @@v17@@ = stdout ; @@v18@@ = dcgettext ( Number L , String String String String , Number ) ; fputs_unlocked ( @@v18@@ , @@v17@@ ) ; last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v19@@ = stdout ; @@v20@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v20@@ , @@v19@@ ) ; @@v21@@ = setlocale ( Number , Number L ) ; if ( @@v21@@ ) { if ( strncmp ( @@v21@@ , String , Number ) ) { last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
__int64 __fastcall argmatch_to_argument ( void * @@s1@@ , __int64 * @@a2@@ , char * @@a3@@ , size_t @@a4@@ ) { __int64 @@v4@@ ; __int64 * @@v7@@ ; @@v4@@ = * @@a2@@ ; if ( * @@a2@@ ) { @@v7@@ = @@a2@@ + Number ; do { if ( ! memcmp ( @@s1@@ , @@a3@@ , @@a4@@ ) ) break ; @@v4@@ = * @@v7@@ ; @@a3@@ += @@a4@@ ; ++ @@v7@@ ; } while ( @@v4@@ ) ; } return @@v4@@ ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
__int64 __fastcall argmatch ( const char * @@a1@@ , const char * * @@a2@@ , char * @@a3@@ , size_t @@a4@@ ) { char * @@v5@@ ; size_t @@v6@@ ; const char * @@v7@@ ; size_t @@v8@@ ; __int64 @@v9@@ ; bool @@v10@@ ; char @@v11@@ ; __int64 @@v12@@ ; __int64 @@v14@@ ; char @@v15@@ ; @@v5@@ = @@a3@@ ; @@v6@@ = strlen ( @@a1@@ ) ; @@v7@@ = * @@a2@@ ; @@v14@@ = Number ; if ( ! * @@a2@@ ) return @@v14@@ ; @@v8@@ = @@v6@@ ; @@v15@@ = Number ; @@v9@@ = Number L ; do { while ( strncmp ( @@v7@@ , @@a1@@ , @@v8@@ ) ) { LABEL_7 : ++ @@v9@@ ; @@v5@@ += @@a4@@ ; @@v7@@ = @@a2@@ [ @@v9@@ ] ; if ( ! @@v7@@ ) goto LABEL_12 ; } if ( strlen ( @@v7@@ ) == @@v8@@ ) return @@v9@@ ; if ( @@v14@@ != Number ) { if ( @@a3@@ ) { @@v10@@ = memcmp ( & @@a3@@ [ @@a4@@ * @@v14@@ ] , @@v5@@ , @@a4@@ ) == Number ; @@v11@@ = @@v15@@ ; if ( ! @@v10@@ ) @@v11@@ = Number ; @@v15@@ = @@v11@@ ; } else { @@v15@@ = Number ; } goto LABEL_7 ; } @@v14@@ = @@v9@@ ++ ; @@v5@@ += @@a4@@ ; @@v7@@ = @@a2@@ [ @@v9@@ ] ; } while ( @@v7@@ ) ; LABEL_12 : @@v12@@ = Number ; if ( ! @@v15@@ ) @@v12@@ = @@v14@@ ; return @@v12@@ ; }
__int64 __fastcall protect_fd ( int @@a1@@ ) { unsigned int @@v1@@ ; int @@v2@@ ; @@v1@@ = Number ; @@v2@@ = open ( String , Number ) ; if ( @@a1@@ != @@v2@@ ) { @@v1@@ = Number ; if ( @@v2@@ >= Number ) { close ( @@v2@@ ) ; * __errno_location ( ) = Number ; } } return @@v1@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; int @@v12@@ ; _BYTE * @@v13@@ ; __int64 @@v14@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v12@@ = * @@v6@@ ; @@v14@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v13@@ = ( _BYTE * ) xmalloc ( @@v14@@ + Number , @@v14@@ + Number , @@v8@@ , @@v9@@ , @@v10@@ ) ; quotearg_buffer_restyled ( @@v13@@ , @@v14@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v12@@ ; if ( @@a3@@ ) * @@a3@@ = @@v14@@ ; return @@v13@@ ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
__int64 posix2_version ( ) { unsigned int @@v0@@ ; char * @@v1@@ ; __int64 @@v3@@ ; char * @@v4@@ [ Number ] ; @@v0@@ = Number ; @@v4@@ [ Number ] = ( char * ) __readfsqword ( Number ) ; @@v1@@ = getenv ( String ) ; if ( @@v1@@ ) { if ( * @@v1@@ ) { @@v3@@ = strtol ( @@v1@@ , @@v4@@ , Number ) ; if ( ! * @@v4@@ [ Number ] ) { if ( @@v3@@ < ( __int64 ) Number ) { @@v0@@ = Number ; } else { @@v0@@ = Number ; if ( @@v3@@ <= Number ) @@v0@@ = @@v3@@ ; } } } } return @@v0@@ ; }
__int64 __fastcall _xargmatch_internal ( __int64 @@a1@@ , const char * @@a2@@ , const char * * @@a3@@ , char * @@a4@@ , size_t @@a5@@ , void ( * @@a6@@ ) ( void ) ) { __int64 @@result@@ ; @@result@@ = argmatch ( @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; if ( @@result@@ < Number ) { argmatch_invalid ( @@a1@@ , ( __int64 ) @@a2@@ , @@result@@ ) ; argmatch_valid ( @@a3@@ , @@a4@@ , @@a5@@ ) ; @@a6@@ ( ) ; @@result@@ = Number ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
FILE * __fastcall freopen_safer ( const char * @@a1@@ , const char * @@a2@@ , FILE * @@a3@@ ) { int @@v4@@ ; int * @@v5@@ ; char @@v6@@ ; char @@v7@@ ; char @@v8@@ ; FILE * @@v9@@ ; int @@v10@@ ; @@v4@@ = fileno ( @@a3@@ ) ; @@v5@@ = __errno_location ( ) ; if ( @@v4@@ == Number ) { @@v6@@ = Number ; @@v7@@ = Number ; } else { if ( @@v4@@ == Number ) { @@v6@@ = Number ; } else { if ( ! @@v4@@ ) { @@v6@@ = Number ; @@v7@@ = Number ; @@v8@@ = Number ; LABEL_11 : @@v9@@ = freopen ( @@a1@@ , @@a2@@ , @@a3@@ ) ; goto LABEL_12 ; } @@v6@@ = dup2 ( Number , Number ) != Number ; } @@v7@@ = dup2 ( Number , Number ) != Number ; } if ( ! dup2 ( Number , Number ) ) { @@v8@@ = Number ; if ( ! @@v7@@ ) goto LABEL_9 ; goto LABEL_20 ; } @@v8@@ = protect_fd ( Number ) ; if ( ! @@v8@@ ) { @@v8@@ = Number ; @@v9@@ = Number L ; LABEL_12 : @@v10@@ = * @@v5@@ ; if ( ! @@v6@@ ) goto LABEL_13 ; goto LABEL_26 ; } if ( @@v7@@ ) { LABEL_20 : @@v7@@ = protect_fd ( Number ) ; if ( ! @@v7@@ ) { @@v9@@ = Number L ; @@v10@@ = * @@v5@@ ; if ( @@v6@@ ) close ( Number ) ; LABEL_23 : close ( Number ) ; if ( ! @@v8@@ ) goto LABEL_15 ; goto LABEL_24 ; } } LABEL_9 : if ( ! @@v6@@ ) goto LABEL_11 ; @@v6@@ = protect_fd ( Number ) ; if ( @@v6@@ ) goto LABEL_11 ; @@v10@@ = * @@v5@@ ; @@v9@@ = Number L ; LABEL_26 : close ( Number ) ; LABEL_13 : if ( @@v7@@ ) goto LABEL_23 ; if ( ! @@v8@@ ) goto LABEL_15 ; LABEL_24 : close ( Number ) ; LABEL_15 : if ( ! @@v9@@ ) * @@v5@@ = @@v10@@ ; return @@v9@@ ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
bool __fastcall hard_locale ( int @@a1@@ ) { char * @@v1@@ ; bool @@result@@ ; @@v1@@ = setlocale ( @@a1@@ , Number L ) ; @@result@@ = Number ; if ( @@v1@@ ) { @@result@@ = Number ; if ( strcmp ( @@v1@@ , String ) ) @@result@@ = strcmp ( @@v1@@ , String ) != Number ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
__int64 __fastcall check_dst_limits_calc_pos ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ , unsigned __int64 @@a5@@ , __int64 @@a6@@ ) { __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; unsigned __int64 @@v8@@ ; int @@v9@@ ; __int64 @@result@@ ; @@v6@@ = * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@a2@@ ; @@v7@@ = * ( _QWORD * ) ( @@v6@@ + Number ) ; if ( @@v7@@ > @@a5@@ ) return Number ; @@v8@@ = * ( _QWORD * ) ( @@v6@@ + Number ) ; if ( @@v8@@ < @@a5@@ ) return Number L ; @@v9@@ = ( @@v7@@ == @@a5@@ ) | Number ; if ( @@v8@@ == @@a5@@ ) return check_dst_limits_calc_pos_1 ( @@a1@@ , @@v9@@ , @@a3@@ , @@a4@@ , @@a6@@ ) ; @@result@@ = Number L ; if ( @@v7@@ == @@a5@@ ) { @@v9@@ = Number ; return check_dst_limits_calc_pos_1 ( @@a1@@ , @@v9@@ , @@a3@@ , @@a4@@ , @@a6@@ ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_208230 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_208210 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_208220 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
__int64 __fastcall re_node_set_insert_last ( _QWORD * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v3@@ ; void * @@v4@@ ; __int64 @@v6@@ ; @@v3@@ = @@a1@@ [ Number ] ; @@v4@@ = ( void * ) @@a1@@ [ Number ] ; if ( * @@a1@@ != @@v3@@ ) goto LABEL_2 ; @@v6@@ = @@v3@@ + Number ; * @@a1@@ = Number * @@v6@@ ; @@v4@@ = realloc ( @@v4@@ , Number * @@v6@@ ) ; if ( @@v4@@ ) { @@a1@@ [ Number ] = @@v4@@ ; @@v3@@ = @@a1@@ [ Number ] ; LABEL_2 : @@a1@@ [ Number ] = @@v3@@ + Number ; * ( ( _QWORD * ) @@v4@@ + @@v3@@ ) = @@a2@@ ; return Number L ; } return Number L ; }
int isatty ( int @@fd@@ ) { return isatty ( @@fd@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
__int64 __fastcall extend_buffers ( __int64 @@a1@@ ) { unsigned __int64 @@v1@@ ; unsigned int @@v3@@ ; void * @@v4@@ ; void * @@v5@@ ; int @@v6@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; @@v1@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( @@v1@@ > Number ) return Number L ; @@v3@@ = re_string_realloc_buffers ( @@a1@@ , Number * @@v1@@ ) ; if ( @@v3@@ ) return @@v3@@ ; @@v4@@ = * ( void * * ) ( @@a1@@ + Number ) ; if ( ! @@v4@@ ) goto LABEL_6 ; @@v5@@ = realloc ( @@v4@@ , Number L * * ( _QWORD * ) ( @@a1@@ + Number ) + Number ) ; if ( ! @@v5@@ ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v5@@ ; LABEL_6 : @@v6@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; if ( ! * ( _BYTE * ) ( @@a1@@ + Number ) ) { if ( @@v6@@ > Number ) { build_wcs_buffer ( @@a1@@ ) ; return Number L ; } @@v8@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( @@v8@@ ) { @@v9@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= @@v9@@ ) @@v9@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v10@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( @@v9@@ > @@v10@@ ) { while ( Number ) { * ( _BYTE * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@v10@@ ) = * ( _BYTE * ) ( @@v8@@ + * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@v10@@ + * ( _QWORD * ) @@a1@@ ) ) ; if ( @@v9@@ == ++ @@v10@@ ) break ; @@v8@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; } } * ( _QWORD * ) ( @@a1@@ + Number ) = @@v10@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v10@@ ; } return @@v3@@ ; } if ( @@v6@@ > Number ) return build_wcs_upper_buffer ( @@a1@@ ) ; build_upper_buffer ( ( _QWORD * ) @@a1@@ ) ; return Number L ; }
int dirfd ( DIR * @@dirp@@ ) { return dirfd ( @@dirp@@ ) ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
struct dirent * readdir ( DIR * @@dirp@@ ) { return readdir ( @@dirp@@ ) ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
int fchdir ( int @@fd@@ ) { return fchdir ( @@fd@@ ) ; }
int unlink ( const char * @@name@@ ) { return unlink ( @@name@@ ) ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 __fastcall check_arrival_expand_ecl_sub ( _QWORD * @@a1@@ , _QWORD * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ , unsigned int @@a5@@ ) { __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; unsigned __int64 * @@v12@@ ; __int64 @@result@@ ; while ( Number ) { if ( re_node_set_contains_isra_3 ( @@a2@@ [ Number ] , @@a2@@ + Number , @@a3@@ ) ) return Number L ; @@v8@@ = * @@a1@@ + Number * @@a3@@ ; if ( * ( unsigned __int8 * ) ( @@v8@@ + Number ) == @@a5@@ && * ( _QWORD * ) @@v8@@ == @@a4@@ ) { break ; } if ( ! ( unsigned __int8 ) re_node_set_insert ( @@a2@@ , @@a3@@ ) ) return Number L ; @@v9@@ = Number * @@a3@@ ; @@v10@@ = @@v9@@ + @@a1@@ [ Number ] ; @@v11@@ = * ( _QWORD * ) ( @@v10@@ + Number ) ; if ( ! @@v11@@ ) return Number L ; @@v12@@ = * ( unsigned __int64 * * ) ( @@v10@@ + Number ) ; if ( @@v11@@ == Number ) { @@result@@ = check_arrival_expand_ecl_sub ( @@a1@@ , @@a2@@ , @@v12@@ [ Number ] , @@a4@@ , @@a5@@ ) ; if ( ( _DWORD ) @@result@@ ) return @@result@@ ; @@v12@@ = * ( unsigned __int64 * * ) ( @@a1@@ [ Number ] + @@v9@@ + Number ) ; } @@a3@@ = * @@v12@@ ; } if ( @@a5@@ != Number || ( unsigned __int8 ) re_node_set_insert ( @@a2@@ , @@a3@@ ) ) return Number L ; return Number L ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_208230 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_208210 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_208220 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
__int64 __fastcall excise ( __int64 @@a1@@ , __int64 @@a2@@ , _BYTE * @@a3@@ , char @@a4@@ ) { const char * @@v8@@ ; int @@v9@@ ; __int64 @@result@@ ; int * @@v11@@ ; int @@v12@@ ; __int64 @@v13@@ ; char * @@v14@@ ; _QWORD * @@i@@ ; struct stat @@v16@@ ; unsigned __int64 @@v17@@ ; @@v8@@ = * ( const char * * ) ( @@a2@@ + Number ) ; @@v9@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; @@v17@@ = __readfsqword ( Number ) ; if ( unlinkat ( @@v9@@ , @@v8@@ , ( @@a4@@ != Number ) << Number ) ) { @@v11@@ = __errno_location ( ) ; @@v12@@ = * @@v11@@ ; if ( * @@v11@@ == Number ) { if ( __fxstatat ( Number , * ( _DWORD * ) ( @@a1@@ + Number ) , * ( const char * * ) ( @@a2@@ + Number ) , & @@v16@@ , Number ) && * @@v11@@ == Number ) { @@result@@ = Number L ; if ( * @@a3@@ ) return @@result@@ ; } else { * @@v11@@ = Number ; } } else if ( * @@a3@@ && ( @@v12@@ == Number || @@v12@@ == Number ) ) { return Number L ; } if ( * ( _WORD * ) ( @@a2@@ + Number ) == Number ) * @@v11@@ = * ( _DWORD * ) ( @@a2@@ + Number ) ; @@v13@@ = quote ( * ( _QWORD * ) ( @@a2@@ + Number ) ) ; @@v14@@ = dcgettext ( Number L , String , Number ) ; error ( Number , * @@v11@@ , @@v14@@ , @@v13@@ ) ; for ( @@i@@ = * ( _QWORD * * ) ( @@a2@@ + Number ) ; ( __int64 ) @@i@@ [ Number ] >= Number ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { if ( @@i@@ [ Number ] ) break ; @@i@@ [ Number ] = Number L ; } @@result@@ = Number L ; } else { @@result@@ = Number L ; if ( @@a3@@ [ Number ] ) { quote ( * ( _QWORD * ) ( @@a2@@ + Number ) ) ; if ( @@a4@@ ) dcgettext ( Number L , String , Number ) ; else dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@result@@ = Number L ; } } return @@result@@ ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
char * __fastcall create_token_tree_isra_18 ( _QWORD * @@a1@@ , int * @@a2@@ , _QWORD * @@a3@@ , _QWORD * @@a4@@ , const __m128i * @@a5@@ ) { int @@v6@@ ; __int64 @@v7@@ ; int @@v8@@ ; _QWORD * @@v9@@ ; __int64 @@v10@@ ; char * @@result@@ ; __m128i * @@v12@@ ; _QWORD * @@v13@@ ; _QWORD * @@v14@@ ; _QWORD * @@v15@@ ; const __m128i * @@v16@@ ; @@v6@@ = * @@a2@@ ; if ( * @@a2@@ == Number ) { @@v16@@ = @@a5@@ ; @@v15@@ = @@a4@@ ; @@v14@@ = @@a3@@ ; @@v9@@ = malloc ( Number ) ; if ( ! @@v9@@ ) return Number L ; @@v13@@ = ( _QWORD * ) * @@a1@@ ; @@v8@@ = Number ; * @@a1@@ = @@v9@@ ; @@v7@@ = Number L ; @@a5@@ = @@v16@@ ; @@a4@@ = @@v15@@ ; @@a3@@ = @@v14@@ ; * @@v9@@ = @@v13@@ ; @@v10@@ = Number L ; } else { @@v7@@ = @@v6@@ ; @@v8@@ = @@v6@@ + Number ; @@v9@@ = ( _QWORD * ) * @@a1@@ ; @@v10@@ = ( ( __int64 ) @@v6@@ << Number ) + Number ; } * @@a2@@ = @@v8@@ ; @@result@@ = ( char * ) @@v9@@ + @@v10@@ ; @@v12@@ = ( __m128i * ) & @@v9@@ [ Number * @@v7@@ ] ; @@v12@@ -> m128i_i64 [ Number ] = Number L ; @@v12@@ [ Number ] . m128i_i64 [ Number ] = ( __int64 ) @@a3@@ ; @@v12@@ [ Number ] . m128i_i64 [ Number ] = ( __int64 ) @@a4@@ ; @@v12@@ [ Number ] = _mm_loadu_si128 ( @@a5@@ ) ; @@v12@@ [ Number ] . m128i_i8 [ Number ] &= Number ; @@v12@@ [ Number ] . m128i_i64 [ Number ] = Number L ; @@v12@@ [ Number ] . m128i_i64 [ Number ] = Number L ; @@v12@@ [ Number ] . m128i_i64 [ Number ] = Number ; if ( @@a3@@ ) * @@a3@@ = @@result@@ ; if ( @@a4@@ ) * @@a4@@ = @@result@@ ; return @@result@@ ; }
int group_member ( __gid_t @@gid@@ ) { return group_member ( @@gid@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
int clock_gettime ( clockid_t @@clock_id@@ , struct timespec * @@tp@@ ) { return clock_gettime ( @@clock_id@@ , @@tp@@ ) ; }
__int64 __fastcall copy ( char * @@a1@@ , char * @@a2@@ , char @@a3@@ , __m128i * @@a4@@ , __int64 @@a5@@ , _BYTE * @@a6@@ ) { __int32 @@v6@@ ; unsigned int @@v7@@ ; char @@v9@@ ; unsigned __int64 @@v10@@ ; @@v10@@ = __readfsqword ( Number ) ; if ( ! @@a4@@ ) __assert_fail ( String , String , Number , String ) ; if ( @@a4@@ -> m128i_i32 [ Number ] > Number ) __assert_fail ( String , String , Number , String ) ; @@v6@@ = @@a4@@ -> m128i_i32 [ Number ] ; if ( ( unsigned int ) ( @@v6@@ - Number ) > Number ) __assert_fail ( String , String , Number , String ) ; @@v7@@ = @@a4@@ [ Number ] . m128i_u32 [ Number ] ; if ( @@v7@@ > Number ) __assert_fail ( String , String , Number , String ) ; if ( @@a4@@ [ Number ] . m128i_i8 [ Number ] && @@a4@@ [ Number ] . m128i_i8 [ Number ] ) __assert_fail ( String , String , Number , String ) ; if ( @@v6@@ != Number && @@v7@@ == Number ) __assert_fail ( String , String , Number , String ) ; @@v9@@ = Number ; top_level_dst_name = ( __int64 ) @@a2@@ ; top_level_src_name = ( __int64 ) @@a1@@ ; return copy_internal ( @@a1@@ , @@a2@@ , @@a3@@ , Number L , Number L , @@a4@@ , Number , & @@v9@@ , @@a5@@ , @@a6@@ ) ; }
__int64 __fastcall check_subexp_matching_top_isra_21 ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , _QWORD * @@a3@@ , __int64 @@a4@@ ) { _QWORD * @@v4@@ ; unsigned __int64 @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; __int64 @@v12@@ ; _QWORD * @@v13@@ ; _QWORD * @@v14@@ ; bool @@v15@@ ; _QWORD * @@v17@@ ; __int64 @@v18@@ ; __int64 @@v19@@ ; _QWORD * @@v20@@ ; __int64 @@v21@@ ; __int64 @@v22@@ ; @@v4@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; if ( ! * @@a2@@ ) return Number L ; @@v7@@ = Number L ; while ( Number ) { while ( Number ) { @@v8@@ = * ( _QWORD * ) ( * @@a3@@ + Number * @@v7@@ ) ; @@v9@@ = * @@v4@@ + Number * @@v8@@ ; if ( * ( _BYTE * ) ( @@v9@@ + Number ) == Number ) { @@v10@@ = * ( _QWORD * ) @@v9@@ ; if ( @@v10@@ <= Number ) { @@v11@@ = @@v4@@ [ Number ] ; if ( _bittest64 ( & @@v11@@ , @@v10@@ ) ) break ; } } if ( ++ @@v7@@ >= * @@a2@@ ) return Number L ; } @@v12@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v13@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; if ( @@v12@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ) break ; LABEL_8 : @@v20@@ = @@v13@@ ; @@v18@@ = @@v12@@ ; @@v22@@ = @@a4@@ ; @@v14@@ = calloc ( Number , Number ) ; @@v20@@ [ @@v18@@ ] = @@v14@@ ; if ( ! @@v14@@ ) return Number L ; ++ @@v7@@ ; @@a4@@ = @@v22@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v18@@ + Number ; @@v15@@ = @@v7@@ < * @@a2@@ ; @@v14@@ [ Number ] = @@v8@@ ; * @@v14@@ = @@v22@@ ; if ( ! @@v15@@ ) return Number L ; } @@v19@@ = @@a4@@ ; @@v21@@ = Number * @@v12@@ ; @@v17@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number * @@v12@@ ) ; @@v13@@ = @@v17@@ ; @@a4@@ = @@v19@@ ; if ( @@v17@@ ) { * ( _QWORD * ) ( @@a1@@ + Number ) = @@v17@@ ; @@v12@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v21@@ ; goto LABEL_8 ; } return Number L ; }
int __lxstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _lxstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
int rpmatch ( const char * @@response@@ ) { return rpmatch ( @@response@@ ) ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
int __fastcall chmod_or_fchmod ( const char * @@a1@@ , int @@a2@@ , __mode_t @@a3@@ ) { int @@result@@ ; if ( @@a2@@ == Number ) @@result@@ = chmod ( @@a1@@ , @@a3@@ ) ; else @@result@@ = fchmod ( @@a2@@ , @@a3@@ ) ; return @@result@@ ; }
int __freading ( FILE * @@fp@@ ) { return _freading ( @@fp@@ ) ; }
int unlink ( const char * @@name@@ ) { return unlink ( @@name@@ ) ; }
__int64 __fastcall build_equiv_class_isra_29 ( __int64 @@a1@@ , const char * @@a2@@ ) { if ( strlen ( @@a2@@ ) != Number ) return Number L ; * ( _QWORD * ) ( @@a1@@ + ( ( ( unsigned __int64 ) * ( unsigned __int8 * ) @@a2@@ >> Number ) & Number ) ) |= Number L << ( * @@a2@@ & Number ) ; return Number L ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
int __fxstatat ( int @@ver@@ , int @@fildes@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ , int @@flag@@ ) { return _fxstatat ( @@ver@@ , @@fildes@@ , @@filename@@ , @@stat_buf@@ , @@flag@@ ) ; }
__mode_t umask ( __mode_t @@mask@@ ) { return umask ( @@mask@@ ) ; }
__int64 __fastcall set_acl ( const char * @@a1@@ , int @@a2@@ , __mode_t @@a3@@ ) { unsigned int @@v3@@ ; __int64 @@v4@@ ; char * @@v5@@ ; int * @@v6@@ ; @@v3@@ = chmod_or_fchmod ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( @@v3@@ ) { @@v4@@ = quote ( @@a1@@ ) ; @@v5@@ = dcgettext ( Number L , String , Number ) ; @@v6@@ = __errno_location ( ) ; error ( Number , * @@v6@@ , @@v5@@ , @@v4@@ ) ; } return @@v3@@ ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
int fflush ( FILE * @@stream@@ ) { return fflush ( @@stream@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; _bss_start = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
char * __fastcall rpl_re_compile_pattern ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v3@@ ; int @@v4@@ ; char * @@result@@ ; @@v3@@ = rpl_re_syntax_options ; * ( _BYTE * ) ( @@a3@@ + Number ) = ( Number * ( ( rpl_re_syntax_options & Number ) != Number ) ) | * ( _BYTE * ) ( @@a3@@ + Number ) & Number | Number ; @@v4@@ = re_compile_internal ( @@a3@@ , @@a1@@ , @@a2@@ , @@v3@@ ) ; if ( @@v4@@ ) @@result@@ = dcgettext ( Number L , & _re_error_msgid [ _re_error_msgid_idx [ @@v4@@ ] ] , Number ) ; else @@result@@ = Number L ; return @@result@@ ; }
bool __fastcall seen_file ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 * @@a3@@ ) { bool @@result@@ ; __int64 @@v4@@ ; __int64 @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; @@result@@ = Number ; if ( @@a1@@ ) { @@v4@@ = @@a3@@ [ Number ] ; @@v5@@ [ Number ] = @@a2@@ ; @@v5@@ [ Number ] = @@v4@@ ; @@v5@@ [ Number ] = * @@a3@@ ; @@result@@ = hash_lookup ( @@a1@@ , @@v5@@ ) != Number ; } return @@result@@ ; }
int __fxstat ( int @@ver@@ , int @@fildes@@ , struct stat * @@stat_buf@@ ) { return _fxstat ( @@ver@@ , @@fildes@@ , @@stat_buf@@ ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
size_t __fastcall rpl_regerror ( unsigned int @@a1@@ , __int64 a2 , char * @@a3@@ , size_t @@a4@@ ) { char * @@v6@@ ; size_t @@v7@@ ; size_t @@v8@@ ; size_t @@v9@@ ; if ( @@a1@@ > Number ) abort ( ) ; @@v6@@ = dcgettext ( Number L , & _re_error_msgid [ _re_error_msgid_idx [ @@a1@@ ] ] , Number ) ; @@v7@@ = strlen ( @@v6@@ ) ; @@v8@@ = @@v7@@ + Number ; if ( @@a4@@ ) { @@v9@@ = @@v7@@ + Number ; if ( @@v8@@ > @@a4@@ ) { @@v9@@ = @@a4@@ - Number ; @@a3@@ [ @@a4@@ - Number ] = Number ; } memcpy ( @@a3@@ , @@v6@@ , @@v9@@ ) ; } return @@v8@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
__int64 __fastcall cache_fstatat_constprop_4 ( int @@fildes@@ , char * @@filename@@ , struct stat * @@stat_buf@@ ) { __off_t @@v3@@ ; int * @@v6@@ ; __ino_t @@v7@@ ; @@v3@@ = @@stat_buf@@ -> st_size ; if ( @@v3@@ == Number ) { if ( __fxstatat ( Number , @@fildes@@ , @@filename@@ , @@stat_buf@@ , Number ) ) { @@stat_buf@@ -> st_size = Number ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * @@v6@@ ; @@stat_buf@@ -> st_ino = @@v7@@ ; goto LABEL_6 ; } @@v3@@ = @@stat_buf@@ -> st_size ; } if ( @@v3@@ >= Number ) return Number L ; @@v6@@ = __errno_location ( ) ; @@v7@@ = @@stat_buf@@ -> st_ino ; LABEL_6 : * @@v6@@ = @@v7@@ ; return Number ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; program_invocation_short_name = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
__int64 __fastcall rpl_re_search ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ , unsigned __int64 @@a4@@ , __int64 @@a5@@ , unsigned __int64 * @@a6@@ ) { return re_search_stub ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a3@@ , @@a6@@ , Number ) ; }
int __fastcall fchmod_or_lchmod ( int @@a1@@ , const char * @@a2@@ , __mode_t @@a3@@ ) { int @@result@@ ; if ( @@a1@@ < Number ) @@result@@ = chmod ( @@a2@@ , @@a3@@ ) ; else @@result@@ = fchmod ( @@a1@@ , @@a3@@ ) ; return @@result@@ ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
int __fastcall emit_verbose ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ ) { __int64 @@v5@@ ; __int64 @@v6@@ ; char * @@v7@@ ; quote_n ( Number L , @@a2@@ , @@a3@@ , @@a4@@ ) ; quote_n ( Number L , @@a1@@ , @@v5@@ , @@v6@@ ) ; __printf_chk ( ) ; if ( @@a3@@ ) { quote ( @@a3@@ ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } @@v7@@ = stdout -> _IO_write_ptr ; if ( @@v7@@ >= stdout -> _IO_write_end ) { LODWORD ( @@v7@@ ) = __overflow ( stdout , Number ) ; } else { stdout -> _IO_write_ptr = @@v7@@ + Number ; * @@v7@@ = Number ; } return ( int ) @@v7@@ ; }
__int64 __fastcall get_version ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; if ( @@a2@@ && * ( _BYTE * ) @@a2@@ ) @@result@@ = get_version_part_0 ( @@a1@@ , @@a2@@ ) ; else @@result@@ = Number L ; return @@result@@ ; }
__int64 __fastcall rpl_re_search_2 ( __int64 @@a1@@ , const void * @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ , unsigned __int64 @@a6@@ , __int64 @@a7@@ , unsigned __int64 * @@a8@@ , __int64 @@a9@@ ) { return re_search_2_stub ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ , @@a7@@ , @@a8@@ , @@a9@@ , Number ) ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall src_info_init ( __int64 @@a1@@ ) { __int64 @@result@@ ; @@result@@ = hash_initialize ( Number L , Number L , triple_hash_no_name , triple_compare , triple_free ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@result@@ ; return @@result@@ ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; FILE * @@v11@@ ; char * @@v12@@ ; FILE * @@v13@@ ; char * @@v14@@ ; FILE * @@v15@@ ; char * @@v16@@ ; FILE * @@v17@@ ; char * @@v18@@ ; FILE * @@v19@@ ; char * @@v20@@ ; char * @@v21@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String String String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String String String String String String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = stdout ; @@v10@@ = dcgettext ( Number L , String String String String String String , Number ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; @@v11@@ = stdout ; @@v12@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v12@@ , @@v11@@ ) ; @@v13@@ = stdout ; @@v14@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v14@@ , @@v13@@ ) ; @@v15@@ = stdout ; @@v16@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v16@@ , @@v15@@ ) ; @@v17@@ = stdout ; @@v18@@ = dcgettext ( Number L , String String String String , Number ) ; fputs_unlocked ( @@v18@@ , @@v17@@ ) ; last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v19@@ = stdout ; @@v20@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v20@@ , @@v19@@ ) ; @@v21@@ = setlocale ( Number , Number L ) ; if ( @@v21@@ ) { if ( strncmp ( @@v21@@ , String , Number ) ) { last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
unsigned __int64 __fastcall src_to_dest_hash ( _QWORD * @@a1@@ , unsigned __int64 @@a2@@ ) { return * @@a1@@ % @@a2@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
unsigned __int64 __fastcall forget_created ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v3@@ ; __int64 @@v5@@ [ Number ] ; unsigned __int64 @@v6@@ ; @@v5@@ [ Number ] = @@a1@@ ; @@v5@@ [ Number ] = @@a2@@ ; @@v5@@ [ Number ] = Number L ; @@v6@@ = __readfsqword ( Number ) ; @@v2@@ = hash_delete ( src_to_dest , @@v5@@ ) ; if ( @@v2@@ ) { @@v3@@ = ( void * ) @@v2@@ ; free ( * ( void * * ) ( @@v2@@ + Number ) ) ; free ( @@v3@@ ) ; } return __readfsqword ( Number ) ^ @@v6@@ ; }
__int64 __fastcall src_to_dest_lookup ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; __int64 @@result@@ ; __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = @@a1@@ ; @@v4@@ [ Number ] = @@a2@@ ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v2@@ = hash_lookup ( src_to_dest , @@v4@@ ) ; if ( @@v2@@ ) @@result@@ = * ( _QWORD * ) ( @@v2@@ + Number ) ; else @@result@@ = Number L ; return @@result@@ ; }
_BYTE * __fastcall mdir_name ( void * @@src@@ ) { __int64 @@v1@@ ; _BYTE * @@v2@@ ; _BYTE * @@v3@@ ; _BYTE * @@v4@@ ; @@v1@@ = dir_len ( @@src@@ ) ; @@v2@@ = malloc ( @@v1@@ + ( @@v1@@ == Number ) + Number ) ; @@v3@@ = @@v2@@ ; if ( @@v2@@ ) { @@v4@@ = memcpy ( @@v2@@ , @@src@@ , @@v1@@ ) ; @@v3@@ = @@v4@@ ; if ( ! @@v1@@ ) { * @@v4@@ = Number ; @@v1@@ = Number L ; } @@v4@@ [ @@v1@@ ] = Number ; } return @@v3@@ ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 __fastcall copy_acl ( __int64 @@a1@@ , __int64 a2 , const char * @@a3@@ , int @@a4@@ , __mode_t @@a5@@ ) { int @@v6@@ ; __int64 @@result@@ ; __int64 @@v8@@ ; char * @@v9@@ ; int * @@v10@@ ; const char * @@v11@@ ; int * @@v12@@ ; @@v6@@ = qset_acl ( @@a3@@ , @@a4@@ , @@a5@@ ) ; if ( @@v6@@ == Number ) { @@v11@@ = ( const char * ) quote ( @@a1@@ ) ; @@v12@@ = __errno_location ( ) ; error ( Number , * @@v12@@ , String , @@v11@@ ) ; @@result@@ = Number ; } else if ( @@v6@@ == Number ) { @@v8@@ = quote ( @@a3@@ ) ; @@v9@@ = dcgettext ( Number L , String , Number ) ; @@v10@@ = __errno_location ( ) ; error ( Number , * @@v10@@ , @@v9@@ , @@v8@@ ) ; @@result@@ = Number ; } else { @@result@@ = Number L ; } return @@result@@ ; }
void __fastcall record_file ( __int64 @@a1@@ , void * @@a2@@ , _QWORD * @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ ) { _QWORD * @@v6@@ ; __int64 @@v7@@ ; if ( @@a1@@ ) { @@v6@@ = ( _QWORD * ) xmalloc ( Number L , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; * @@v6@@ = xstrdup ( @@a2@@ ) ; @@v6@@ [ Number ] = @@a3@@ [ Number ] ; @@v6@@ [ Number ] = * @@a3@@ ; @@v7@@ = hash_insert ( @@a1@@ , @@v6@@ ) ; if ( ! @@v7@@ ) xalloc_die ( ) ; if ( @@v6@@ != ( _QWORD * ) @@v7@@ ) triple_free ( @@v6@@ ) ; } }
unsigned __int64 __fastcall AD_hash ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) % @@a2@@ ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall preorder ( _QWORD * @@a1@@ , __int64 ( __fastcall * @@a2@@ ( ) ( void , bintreet0 ) ) ( __int64 , _QWORD * ) , __int64 @@a3@@ ) { _QWORD * @@v4@@ ; __int64 @@result@@ ; _QWORD * @@v6@@ ; _QWORD * @@v7@@ ; @@v4@@ = @@a1@@ ; for ( @@result@@ = @@a2@@ ( ) ( void , bintreet0 ) ( @@a3@@ , @@a1@@ ) ; ! ( _DWORD ) @@result@@ ; @@result@@ = @@a2@@ ( ) ( void , bintreet0 ) ( @@a3@@ , @@v6@@ ) ) { @@v6@@ = ( _QWORD * ) @@v4@@ [ Number ] ; @@v7@@ = Number L ; if ( ! @@v6@@ ) { while ( Number ) { @@v6@@ = ( _QWORD * ) @@v4@@ [ Number ] ; if ( @@v6@@ != @@v7@@ ) { if ( @@v6@@ ) break ; } @@v7@@ = @@v4@@ ; if ( ! * @@v4@@ ) return @@result@@ ; @@v4@@ = ( _QWORD * ) * @@v4@@ ; } } @@v4@@ = @@v6@@ ; } return @@result@@ ; }
unsigned __int64 __fastcall triple_hash ( _QWORD * @@a1@@ , unsigned __int64 @@a2@@ ) { return ( @@a1@@ [ Number ] ^ ( unsigned __int64 ) hash_pjw ( * @@a1@@ ) ) % @@a2@@ ; }
__int64 __fastcall triple_compare ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { __int64 @@result@@ ; @@result@@ = Number L ; if ( @@a1@@ [ Number ] == @@a2@@ [ Number ] && @@a1@@ [ Number ] == @@a2@@ [ Number ] ) { @@result@@ = same_name ( * @@a1@@ , * @@a2@@ ) ; } return @@result@@ ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
__int64 __fastcall fts_compare_ino ( __int64 @@a1@@ , __int64 @@a2@@ ) { unsigned __int64 @@v2@@ ; __int64 @@result@@ ; @@v2@@ = * ( _QWORD * ) ( * ( _QWORD * ) @@a2@@ + Number L ) ; if ( * ( _QWORD * ) ( * ( _QWORD * ) @@a1@@ + Number L ) < @@v2@@ ) @@result@@ = Number ; else @@result@@ = * ( _QWORD * ) ( * ( _QWORD * ) @@a1@@ + Number L ) > @@v2@@ ; return @@result@@ ; }
void __fastcall triple_free ( void * @@ptr@@ ) { free ( * ( void * * ) @@ptr@@ ) ; free ( @@ptr@@ ) ; }
__int64 __fastcall duplicate_node ( __int64 * @@a1@@ , __int64 @@a2@@ , __int16 @@a3@@ ) { __int64 @@v3@@ ; __int64 @@result@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; unsigned int @@v9@@ ; unsigned int @@v10@@ ; @@v3@@ = Number * @@a2@@ ; @@result@@ = re_dfa_add_node ( ( __int64 ) @@a1@@ , * ( _QWORD * ) ( * @@a1@@ + Number * @@a2@@ ) , * ( _QWORD * ) ( * @@a1@@ + Number * @@a2@@ + Number ) ) ; if ( @@result@@ != Number ) { @@v7@@ = * @@a1@@ ; @@v8@@ = * @@a1@@ + Number * @@result@@ ; @@v9@@ = ( ( @@a3@@ & Number ) << Number ) | * ( _DWORD * ) ( @@v8@@ + Number ) & Number ; * ( _DWORD * ) ( @@v8@@ + Number ) = @@v9@@ ; @@v10@@ = @@v9@@ & Number | ( ( ( @@a3@@ & Number | ( unsigned __int16 ) ( * ( _DWORD * ) ( @@v7@@ + @@v3@@ + Number ) >> Number ) ) & Number ) << Number ) ; * ( _DWORD * ) ( @@v8@@ + Number ) = @@v10@@ ; * ( _BYTE * ) ( @@v8@@ + Number ) = BYTE2 ( @@v10@@ ) | Number ; * ( _QWORD * ) ( @@a1@@ [ Number ] + Number * @@result@@ ) = @@a2@@ ; } return @@result@@ ; }
void __fastcall cwd_advance_fd ( __int64 @@a1@@ , int @@a2@@ , char @@a3@@ ) { int @@v4@@ ; int @@v5@@ ; @@v4@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; if ( @@v4@@ == @@a2@@ && @@v4@@ != Number ) abort ( ) ; if ( @@a3@@ ) { @@v5@@ = i_ring_push ( @@a1@@ + Number ) ; if ( @@v5@@ < Number ) { LABEL_6 : * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; return ; } close ( @@v5@@ ) ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; } else { if ( ( * ( _BYTE * ) ( @@a1@@ + Number ) & Number ) != Number || @@v4@@ < Number ) goto LABEL_6 ; close ( @@v4@@ ) ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; } }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
void __fastcall match_ctx_clean ( _QWORD * @@a1@@ ) { unsigned __int64 @@v1@@ ; __int64 @@v2@@ ; unsigned __int64 @@v3@@ ; void * * @@v4@@ ; __int64 @@v5@@ ; if ( @@a1@@ [ Number ] ) { @@v1@@ = Number L ; do { @@v2@@ = * ( _QWORD * ) ( @@a1@@ [ Number ] + Number * @@v1@@ ) ; if ( * ( _QWORD * ) ( @@v2@@ + Number ) ) { @@v3@@ = Number L ; do { @@v4@@ = * ( void * * * ) ( * ( _QWORD * ) ( @@v2@@ + Number ) + Number * @@v3@@ ++ ) ; free ( @@v4@@ [ Number ] ) ; free ( @@v4@@ ) ; } while ( * ( _QWORD * ) ( @@v2@@ + Number ) > @@v3@@ ) ; } free ( * ( void * * ) ( @@v2@@ + Number ) ) ; @@v5@@ = * ( _QWORD * ) ( @@v2@@ + Number ) ; if ( @@v5@@ ) { free ( * ( void * * ) ( @@v5@@ + Number ) ) ; free ( * ( void * * ) ( @@v2@@ + Number ) ) ; } ++ @@v1@@ ; free ( ( void * ) @@v2@@ ) ; } while ( @@a1@@ [ Number ] > @@v1@@ ) ; } @@a1@@ [ Number ] = Number L ; @@a1@@ [ Number ] = Number L ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name_0 = @@a1@@ ; }
__int64 __fastcall enter_dir_isra_11 ( __int16 @@a1@@ , _QWORD * @@a2@@ , __int64 @@a3@@ ) { _QWORD * @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; __int64 @@result@@ ; if ( ( @@a1@@ & Number ) != Number ) { @@v4@@ = malloc ( Number ) ; if ( @@v4@@ ) { @@v5@@ = * ( _QWORD * ) ( @@a3@@ + Number ) ; @@v6@@ = * @@a2@@ ; @@v4@@ [ Number ] = @@a3@@ ; * @@v4@@ = @@v5@@ ; @@v4@@ [ Number ] = * ( _QWORD * ) ( @@a3@@ + Number ) ; @@v7@@ = hash_insert ( @@v6@@ , @@v4@@ ) ; if ( @@v4@@ == ( _QWORD * ) @@v7@@ ) return Number L ; free ( @@v4@@ ) ; if ( @@v7@@ ) { @@v8@@ = * ( _QWORD * ) ( @@v7@@ + Number ) ; * ( _WORD * ) ( @@a3@@ + Number ) = Number ; * ( _QWORD * ) @@a3@@ = @@v8@@ ; return Number L ; } } @@result@@ = Number L ; } else { @@result@@ = cycle_check ( * @@a2@@ , @@a3@@ + Number ) ; if ( ! ( _BYTE ) @@result@@ ) return Number L ; * ( _QWORD * ) @@a3@@ = @@a3@@ ; * ( _WORD * ) ( @@a3@@ + Number ) = Number ; } return @@result@@ ; }
unsigned __int64 __fastcall buffer_lcm ( unsigned __int64 @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v4@@ ; unsigned __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; unsigned __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; if ( @@a1@@ ) { if ( @@a2@@ ) { @@v6@@ = @@a2@@ ; @@v7@@ = @@a1@@ ; while ( Number ) { @@v8@@ = @@v7@@ % @@v6@@ ; if ( ! ( @@v7@@ % @@v6@@ ) ) break ; @@v7@@ = @@v6@@ ; @@v6@@ = @@v8@@ ; } @@v9@@ = @@a1@@ / @@v6@@ ; @@v4@@ = @@a1@@ / @@v6@@ * @@a2@@ ; if ( @@v9@@ * @@a2@@ <= @@a3@@ && @@v4@@ / @@a2@@ == @@v9@@ ) { return @@v4@@ ; } } } else { @@a1@@ = Number ; if ( @@a2@@ ) @@a1@@ = @@a2@@ ; } if ( @@a1@@ <= @@a3@@ ) @@a3@@ = @@a1@@ ; return @@a3@@ ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
__int64 __fastcall dir_len ( _BYTE * @@a1@@ ) { unsigned __int64 @@v1@@ ; _BYTE * @@v2@@ ; __int64 @@v3@@ ; @@v1@@ = * @@a1@@ == Number ; @@v2@@ = last_component ( @@a1@@ ) ; if ( @@v2@@ - @@a1@@ <= @@v1@@ ) return @@v2@@ - @@a1@@ ; @@v3@@ = @@v2@@ - @@a1@@ - Number ; if ( * ( @@v2@@ - Number ) != Number ) return @@v2@@ - @@a1@@ ; while ( @@v1@@ != @@v3@@ && @@a1@@ [ @@v3@@ - Number ] == Number ) -- @@v3@@ ; return @@v3@@ ; }
__int64 __fastcall hash_get_n_buckets ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int64 __fastcall check_arrival_expand_ecl ( _QWORD * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , unsigned int @@a4@@ ) { unsigned __int64 @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; __int64 @@v12@@ ; __int64 @@v13@@ ; __int64 @@v14@@ ; unsigned int @@v15@@ ; __m128i @@v16@@ ; __int64 @@result@@ ; unsigned int @@v18@@ ; __m128i @@v19@@ ; void * @@ptr@@ ; unsigned __int64 @@v21@@ ; @@v7@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@v21@@ = __readfsqword ( Number ) ; @@v19@@ = ( __m128i ) @@v7@@ ; @@ptr@@ = malloc ( Number * @@v7@@ ) ; if ( @@ptr@@ ) { if ( ! @@v7@@ ) { LABEL_12 : free ( * ( void * * ) ( @@a2@@ + Number ) ) ; @@v16@@ = _mm_load_si128 ( & @@v19@@ ) ; * ( _QWORD * ) ( @@a2@@ + Number ) = @@ptr@@ ; @@result@@ = Number L ; * ( __m128i * ) @@a2@@ = @@v16@@ ; return @@result@@ ; } @@v8@@ = Number L ; while ( Number ) { @@v9@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number * @@v8@@ ) ; @@v10@@ = @@a1@@ [ Number ] + Number * @@v9@@ ; @@v11@@ = * ( _QWORD * ) ( @@v10@@ + Number ) ; if ( ! @@v11@@ ) goto LABEL_13 ; @@v12@@ = * ( _QWORD * ) ( @@v10@@ + Number ) ; @@v13@@ = Number L ; while ( Number ) { @@v14@@ = * @@a1@@ + Number L * * ( _QWORD * ) ( @@v12@@ + Number * @@v13@@ ) ; if ( @@a4@@ == * ( unsigned __int8 * ) ( @@v14@@ + Number ) && @@a3@@ == * ( _QWORD * ) @@v14@@ ) { break ; } if ( @@v11@@ == ++ @@v13@@ ) goto LABEL_13 ; } if ( * ( _QWORD * ) ( @@v12@@ + Number * @@v13@@ ) == Number ) { LABEL_13 : @@v15@@ = re_node_set_merge ( ( __int64 ) & @@v19@@ , @@v10@@ ) ; if ( @@v15@@ ) { LABEL_14 : @@v18@@ = @@v15@@ ; free ( @@ptr@@ ) ; return @@v18@@ ; } } else { @@v15@@ = check_arrival_expand_ecl_sub ( @@a1@@ , & @@v19@@ , @@v9@@ , @@a3@@ , @@a4@@ ) ; if ( @@v15@@ ) goto LABEL_14 ; } if ( * ( _QWORD * ) ( @@a2@@ + Number ) <= ( unsigned __int64 ) ++ @@v8@@ ) goto LABEL_12 ; } } return Number L ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
__int64 __fastcall file_name_concat ( void * @@a1@@ , void * @@a2@@ ) { __int64 @@result@@ ; @@result@@ = mfile_name_concat ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
unsigned __int64 __fastcall hash_get_max_bucket_length ( __int64 @@a1@@ ) { _QWORD * @@v1@@ ; unsigned __int64 @@v2@@ ; unsigned __int64 @@result@@ ; __int64 @@v4@@ ; unsigned __int64 @@i@@ ; @@v1@@ = * ( _QWORD * * ) @@a1@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; for ( @@result@@ = Number L ; ( unsigned __int64 ) @@v1@@ < @@v2@@ ; @@v1@@ += Number ) { if ( * @@v1@@ ) { @@v4@@ = @@v1@@ [ Number ] ; for ( @@i@@ = Number L ; @@v4@@ ; ++ @@i@@ ) @@v4@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; if ( @@result@@ < @@i@@ ) @@result@@ = @@i@@ ; } } return @@result@@ ; }
char * __fastcall file_type ( __int64 @@a1@@ ) { int @@v1@@ ; char * @@result@@ ; @@v1@@ = * ( _DWORD * ) ( @@a1@@ + Number ) & Number ; switch ( @@v1@@ ) { case Number : if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) @@result@@ = dcgettext ( Number L , String , Number ) ; else @@result@@ = dcgettext ( Number L , String , Number ) ; break ; case Number : @@result@@ = dcgettext ( Number L , String , Number ) ; break ; case Number : @@result@@ = dcgettext ( Number L , String , Number ) ; break ; case Number : @@result@@ = dcgettext ( Number L , String , Number ) ; break ; case Number : @@result@@ = dcgettext ( Number L , String , Number ) ; break ; case Number : @@result@@ = dcgettext ( Number L , String , Number ) ; break ; case Number : @@result@@ = dcgettext ( Number L , String , Number ) ; break ; default : @@result@@ = dcgettext ( Number L , String , Number ) ; break ; } return @@result@@ ; }
unsigned __int64 __fastcall LCO_hash ( _QWORD * @@a1@@ , unsigned __int64 @@a2@@ ) { return * @@a1@@ % @@a2@@ ; }
bool __fastcall AD_compare ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@result@@ ; @@result@@ = Number ; if ( @@a1@@ [ Number ] == @@a2@@ [ Number ] ) @@result@@ = * @@a1@@ == * @@a2@@ ; return @@result@@ ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
__int64 __fastcall merge_state_array ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ ) { __int64 @@v8@@ ; __int64 @@result@@ ; _QWORD * @@v10@@ ; void * @@v11@@ ; __int64 @@v12@@ ; __int64 @@v13@@ ; unsigned int @@v14@@ ; void * @@v15@@ [ Number ] ; @@v15@@ [ Number ] = ( void * ) __readfsqword ( Number ) ; if ( ! @@a4@@ ) return Number L ; @@v8@@ = Number L ; while ( Number ) { while ( Number ) { @@v12@@ = * ( _QWORD * ) ( @@a2@@ + Number * @@v8@@ ) ; @@v13@@ = * ( _QWORD * ) ( @@a3@@ + Number * @@v8@@ ) ; if ( @@v12@@ ) break ; * ( _QWORD * ) ( @@a2@@ + Number * @@v8@@ ++ ) = @@v13@@ ; if ( @@a4@@ == @@v8@@ ) return Number L ; } if ( @@v13@@ ) { @@result@@ = re_node_set_init_union ( @@v15@@ , @@v12@@ + Number , @@v13@@ + Number ) ; @@v14@@ = @@result@@ ; if ( ( _DWORD ) @@result@@ ) break ; @@v10@@ = re_acquire_state ( & @@v14@@ , @@a1@@ , ( __int64 ) @@v15@@ ) ; @@v11@@ = @@v15@@ [ Number ] ; * ( _QWORD * ) ( @@a2@@ + Number * @@v8@@ ) = @@v10@@ ; free ( @@v11@@ ) ; @@result@@ = @@v14@@ ; if ( @@v14@@ ) break ; } if ( @@a4@@ == ++ @@v8@@ ) return Number L ; } return @@result@@ ; }
__int64 __fastcall hash_get_next ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; __int64 * @@v6@@ ; _QWORD * @@v7@@ ; __int64 @@v8@@ ; __int64 @@result@@ ; @@v2@@ = * @@a1@@ ; @@v4@@ = ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) ; @@v5@@ = @@a1@@ [ Number ] ; @@v6@@ = ( __int64 * ) ( @@v2@@ + Number * @@v4@@ ) ; if ( @@v5@@ <= ( unsigned __int64 ) @@v6@@ ) abort ( ) ; if ( ! @@v6@@ ) goto LABEL_10 ; @@v7@@ = ( _QWORD * ) @@v6@@ [ Number ] ; if ( * @@v6@@ != @@a2@@ ) { do { if ( ! @@v7@@ ) goto LABEL_10 ; @@v8@@ = * @@v7@@ ; @@v7@@ = ( _QWORD * ) @@v7@@ [ Number ] ; } while ( @@v8@@ != @@a2@@ ) ; } if ( @@v7@@ ) return * @@v7@@ ; LABEL_10 : while ( Number ) { @@v6@@ += Number ; if ( @@v5@@ <= ( unsigned __int64 ) @@v6@@ ) break ; @@result@@ = * @@v6@@ ; if ( * @@v6@@ ) return @@result@@ ; } return Number L ; }
__int64 __fastcall fts_stat ( __int64 @@a1@@ , __int64 @@a2@@ , char @@a3@@ ) { struct stat * @@v4@@ ; bool @@v5@@ ; int @@v6@@ ; const char * @@v7@@ ; int * @@v8@@ ; int @@v9@@ ; int * @@v10@@ ; __int64 @@result@@ ; int @@v12@@ ; __int64 @@v13@@ ; @@v4@@ = ( struct stat * ) ( @@a2@@ + Number ) ; @@v5@@ = * ( _QWORD * ) ( @@a2@@ + Number ) == Number L ; @@v6@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; @@v7@@ = * ( const char * * ) ( @@a2@@ + Number ) ; if ( @@v5@@ && ( @@v6@@ & Number ) != Number || ( @@v6@@ & Number ) != Number || @@a3@@ ) { if ( ! __xstat ( Number , @@v7@@ , @@v4@@ ) ) goto LABEL_11 ; @@v8@@ = __errno_location ( ) ; @@v9@@ = * @@v8@@ ; @@v10@@ = @@v8@@ ; if ( * @@v8@@ == Number && ! __lxstat ( Number , * ( const char * * ) ( @@a2@@ + Number ) , @@v4@@ ) ) { * @@v10@@ = Number ; return Number L ; } * ( _DWORD * ) ( @@a2@@ + Number ) = @@v9@@ ; LABEL_6 : * ( _QWORD * ) ( @@a2@@ + Number ) = Number L ; @@v4@@ -> __unused [ Number ] = Number L ; memset ( ( void * ) ( ( unsigned __int64 ) & @@v4@@ -> st_ino & Number ) , Number , Number L * ( ( ( unsigned int ) @@v4@@ - ( ( ( _DWORD ) @@v4@@ + Number ) & Number ) + Number ) >> Number ) ) ; return Number L ; } if ( __fxstatat ( Number , * ( _DWORD * ) ( @@a1@@ + Number ) , @@v7@@ , @@v4@@ , Number ) ) { * ( _DWORD * ) ( @@a2@@ + Number ) = * __errno_location ( ) ; goto LABEL_6 ; } LABEL_11 : @@v12@@ = * ( _DWORD * ) ( @@a2@@ + Number ) & Number ; if ( @@v12@@ == Number ) { @@v13@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( ( * ( _BYTE * ) ( @@a1@@ + Number ) & Number ) == Number ) @@v13@@ -= Number L ; @@v5@@ = * ( _BYTE * ) ( @@a2@@ + Number ) == Number ; * ( _QWORD * ) ( @@a2@@ + Number ) = @@v13@@ ; @@result@@ = Number L ; if ( @@v5@@ && ( ! * ( _BYTE * ) ( @@a2@@ + Number ) || ( * ( _DWORD * ) ( @@a2@@ + Number ) & Number ) == Number ) ) { @@result@@ = * ( _QWORD * ) ( @@a2@@ + Number ) == Number L ? Number : Number ; } } else if ( @@v12@@ == Number ) { @@result@@ = Number L ; } else { @@result@@ = Number * ( unsigned int ) ( @@v12@@ == Number ) + Number ; } return @@result@@ ; }
bool __fastcall LCO_compare ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { return * @@a1@@ == * @@a2@@ ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_208210 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2081F0 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_208200 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
__int64 __fastcall check_halt_state_context_isra_23 ( __int64 @@a1@@ , __int64 @@a2@@ , _QWORD * @@a3@@ , unsigned __int64 @@a4@@ ) { char @@v6@@ ; __int64 @@v7@@ ; int @@v8@@ ; int @@v9@@ ; int @@v10@@ ; __int64 @@result@@ ; __int64 @@v12@@ ; int @@v13@@ ; @@v6@@ = re_string_context_at ( @@a1@@ , @@a4@@ , * ( _DWORD * ) ( @@a1@@ + Number ) ) ; if ( @@a2@@ ) { @@v7@@ = Number L ; @@v8@@ = @@v6@@ & Number ; @@v9@@ = @@v6@@ & Number ; @@v10@@ = @@v6@@ & Number ; while ( Number ) { @@result@@ = * ( _QWORD * ) ( * @@a3@@ + Number * @@v7@@ ) ; @@v12@@ = * * ( _QWORD * * ) ( @@a1@@ + Number ) + Number * @@result@@ ; @@v13@@ = * ( _DWORD * ) ( @@v12@@ + Number ) >> Number ; if ( * ( _BYTE * ) ( @@v12@@ + Number ) != Number ) goto LABEL_3 ; if ( ( @@v13@@ & Number ) == Number ) return @@result@@ ; if ( ( @@v13@@ & Number ) != Number ) break ; if ( ( @@v13@@ & Number ) == Number ) goto LABEL_9 ; if ( @@v10@@ ) goto LABEL_3 ; if ( ( @@v13@@ & Number ) != Number ) { LABEL_10 : if ( ! @@v9@@ ) goto LABEL_3 ; } LABEL_11 : if ( ( @@v13@@ & Number ) == Number || @@v8@@ ) return @@result@@ ; LABEL_3 : if ( ++ @@v7@@ == @@a2@@ ) return Number L ; } if ( ! @@v10@@ || ( @@v13@@ & Number ) != Number ) goto LABEL_3 ; LABEL_9 : if ( ( @@v13@@ & Number ) != Number ) goto LABEL_10 ; goto LABEL_11 ; } return Number L ; }
void __fastcall hash_clear ( _QWORD * @@a1@@ ) { _QWORD * @@v1@@ ; _QWORD * @@v2@@ ; void ( __fastcall * @@v3@@ ) ( _QWORD ) ; _QWORD * @@v4@@ ; __int64 @@v5@@ ; @@v1@@ = ( _QWORD * ) * @@a1@@ ; if ( * @@a1@@ < @@a1@@ [ Number ] ) { do { if ( * @@v1@@ ) { @@v2@@ = ( _QWORD * ) @@v1@@ [ Number ] ; @@v3@@ = ( void ( __fastcall * ) ( _QWORD ) ) @@a1@@ [ Number ] ; if ( @@v2@@ ) { do { if ( @@v3@@ ) { @@v3@@ ( * @@v2@@ ) ; @@v3@@ = ( void ( __fastcall * ) ( _QWORD ) ) @@a1@@ [ Number ] ; } @@v4@@ = ( _QWORD * ) @@v2@@ [ Number ] ; @@v5@@ = @@a1@@ [ Number ] ; * @@v2@@ = Number L ; @@v2@@ [ Number ] = @@v5@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v2@@ = @@v4@@ ; } while ( @@v4@@ ) ; } if ( @@v3@@ ) @@v3@@ ( * @@v1@@ ) ; * @@v1@@ = Number L ; @@v1@@ [ Number ] = Number L ; } @@v1@@ += Number ; } while ( @@a1@@ [ Number ] > ( unsigned __int64 ) @@v1@@ ) ; } @@a1@@ [ Number ] = Number L ; @@a1@@ [ Number ] = Number L ; }
__int64 __fastcall fd_ring_clear ( __int64 @@a1@@ ) { int @@v1@@ ; __int64 @@result@@ ; while ( Number ) { @@result@@ = i_ring_empty ( @@a1@@ ) ; if ( ( _BYTE ) @@result@@ ) break ; @@v1@@ = i_ring_pop ( @@a1@@ ) ; if ( @@v1@@ >= Number ) close ( @@v1@@ ) ; } return @@result@@ ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
unsigned __int64 __fastcall next_prime ( unsigned __int64 @@a1@@ ) { unsigned __int64 @@v1@@ ; unsigned __int64 @@v2@@ ; __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; if ( @@a1@@ < Number ) @@a1@@ = Number L ; @@v1@@ = @@a1@@ | Number ; if ( @@v1@@ != Number ) { while ( Number ) { @@v2@@ = @@v1@@ % Number ; if ( @@v1@@ <= Number ) goto LABEL_9 ; if ( @@v1@@ % Number ) break ; LABEL_10 : @@v1@@ += Number L ; if ( @@v1@@ == Number ) return @@v1@@ ; } @@v3@@ = Number L ; @@v4@@ = Number L ; @@v5@@ = Number L ; while ( Number ) { @@v5@@ += Number L ; @@v4@@ += @@v3@@ ; @@v2@@ = @@v1@@ % @@v5@@ ; if ( @@v4@@ >= @@v1@@ ) break ; @@v3@@ += Number L ; if ( ! ( @@v1@@ % @@v5@@ ) ) goto LABEL_10 ; } LABEL_9 : if ( @@v2@@ ) return @@v1@@ ; goto LABEL_10 ; } return @@v1@@ ; }
__int64 __fastcall rpl_re_set_syntax ( __int64 @@a1@@ ) { __int64 @@result@@ ; @@result@@ = rpl_re_syntax_options ; rpl_re_syntax_options = @@a1@@ ; return @@result@@ ; }
__int64 __fastcall open_safer ( const char * @@a1@@ , char @@a2@@ , unsigned int @@a3@@ ) { __int64 @@v3@@ ; int @@v4@@ ; @@v3@@ = Number L ; if ( ( @@a2@@ & Number ) != Number ) @@v3@@ = @@a3@@ ; @@v4@@ = open ( @@a1@@ , @@a2@@ , @@v3@@ ) ; return fd_safer ( @@v4@@ ) ; }
__int64 __fastcall fts_palloc_isra_2 ( void * * @@a1@@ , size_t * @@a2@@ , __int64 @@a3@@ ) { void * @@v4@@ ; size_t @@v5@@ ; void * @@v6@@ ; __int64 @@result@@ ; @@v4@@ = * @@a1@@ ; @@v5@@ = * @@a2@@ + @@a3@@ + Number ; if ( * @@a2@@ > @@v5@@ ) { free ( @@v4@@ ) ; * @@a1@@ = Number L ; * __errno_location ( ) = Number ; @@result@@ = Number L ; } else { * @@a2@@ = @@v5@@ ; @@v6@@ = realloc ( @@v4@@ , @@v5@@ ) ; if ( @@v6@@ ) { * @@a1@@ = @@v6@@ ; @@result@@ = Number L ; } else { free ( * @@a1@@ ) ; * @@a1@@ = Number L ; @@result@@ = Number L ; } } return @@result@@ ; }
__int64 __fastcall _xargmatch_internal ( __int64 @@a1@@ , char * @@a2@@ , const char * * @@a3@@ , char * @@a4@@ , size_t @@a5@@ , void ( * @@a6@@ ) ( void ) ) { __int64 @@result@@ ; @@result@@ = argmatch ( @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; if ( @@result@@ < Number ) { argmatch_invalid ( @@a1@@ , ( wchar_t * ) @@a2@@ , @@result@@ ) ; argmatch_valid ( @@a3@@ , @@a4@@ , @@a5@@ ) ; @@a6@@ ( ) ; @@result@@ = Number ; } return @@result@@ ; }
__int64 __fastcall check_tuning_isra_0 ( float * * @@a1@@ ) { float * @@v1@@ ; __int64 @@result@@ ; float @@v3@@ ; float @@v4@@ ; float @@v5@@ ; @@v1@@ = * @@a1@@ ; @@result@@ = Number L ; if ( * @@a1@@ != ( float * ) & default_tuning ) { @@v3@@ = @@v1@@ [ Number ] ; if ( @@v3@@ <= Number || @@v3@@ >= Number || @@v1@@ [ Number ] <= Number || * @@v1@@ < Number || ( @@v4@@ = * @@v1@@ + Number , @@v5@@ = @@v1@@ [ Number ] , @@v5@@ <= @@v4@@ ) || @@v5@@ > Number || @@v3@@ <= @@v4@@ ) { * @@a1@@ = ( float * ) & default_tuning ; @@result@@ = Number L ; } } return @@result@@ ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
_BYTE * __fastcall quote ( wchar_t * @@a1@@ ) { return quotearg_n_style ( Number , Number , @@a1@@ ) ; }
__int64 __fastcall fts_set ( __int64 a1 , __int64 @@a2@@ , unsigned int @@a3@@ ) { __int64 @@result@@ ; if ( @@a3@@ > Number ) { * __errno_location ( ) = Number ; @@result@@ = Number L ; } else { * ( _WORD * ) ( @@a2@@ + Number ) = @@a3@@ ; @@result@@ = Number L ; } return @@result@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
__int64 __fastcall rpl_regcomp ( __int64 @@a1@@ , const char * @@a2@@ , int @@a3@@ ) { __int64 @@v4@@ ; void * @@v5@@ ; __int64 @@v6@@ ; char @@v7@@ ; unsigned __int64 @@v8@@ ; unsigned int @@v9@@ ; unsigned int @@v10@@ ; * ( _QWORD * ) @@a1@@ = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; @@v4@@ = ( @@a3@@ & Number ) == Number ? Number L : Number L ; @@v5@@ = malloc ( Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v5@@ ; if ( @@v5@@ ) { @@v6@@ = @@v4@@ | ( @@a3@@ << Number ) & Number ; if ( ( @@a3@@ & Number ) != Number ) { * ( _BYTE * ) ( @@a1@@ + Number ) |= Number ; @@v6@@ = @@v6@@ & Number | Number ; } else { * ( _BYTE * ) ( @@a1@@ + Number ) &= Number ; } @@v7@@ = * ( _BYTE * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _BYTE * ) ( @@a1@@ + Number ) = @@v7@@ & Number | ( Number * ( ( @@a3@@ & Number ) != Number ) ) ; @@v8@@ = strlen ( @@a2@@ ) ; @@v9@@ = re_compile_internal ( @@a1@@ , ( __int64 ) @@a2@@ , @@v8@@ , @@v6@@ ) ; @@v10@@ = @@v9@@ ; if ( @@v9@@ == Number ) { @@v10@@ = Number ; } else if ( ! @@v9@@ ) { rpl_re_compile_fastmap ( @@a1@@ ) ; return @@v10@@ ; } free ( * ( void * * ) ( @@a1@@ + Number ) ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; return @@v10@@ ; } return Number L ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 __fastcall hash_print_statistics ( __int64 @@a1@@ ) { unsigned __int64 @@v1@@ ; _QWORD * @@v2@@ ; unsigned __int64 @@i@@ ; __int64 @@v4@@ ; unsigned __int64 @@j@@ ; @@v1@@ = Number L ; @@v2@@ = * ( _QWORD * * ) @@a1@@ ; for ( @@i@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; ( unsigned __int64 ) @@v2@@ < @@i@@ ; @@v2@@ += Number ) { if ( * @@v2@@ ) { @@v4@@ = @@v2@@ [ Number ] ; for ( @@j@@ = Number L ; @@v4@@ ; ++ @@j@@ ) @@v4@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; if ( @@v1@@ < @@j@@ ) @@v1@@ = @@j@@ ; } } __fprintf_chk ( ) ; __fprintf_chk ( ) ; __fprintf_chk ( ) ; return __fprintf_chk ( ) ; }
__int64 __fastcall hash_find_entry ( __int64 * @@a1@@ , __int64 @@a2@@ , __m128i * * @@a3@@ , char @@a4@@ ) { __int64 @@v5@@ ; __m128i * @@v8@@ ; __int64 @@v9@@ ; __int64 * @@v10@@ ; const __m128i * @@v12@@ ; @@v5@@ = * @@a1@@ ; @@v8@@ = ( __m128i * ) ( Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) + @@v5@@ ) ; if ( @@a1@@ [ Number ] <= ( unsigned __int64 ) @@v8@@ ) abort ( ) ; * @@a3@@ = @@v8@@ ; @@v9@@ = @@v8@@ -> m128i_i64 [ Number ] ; if ( @@v8@@ -> m128i_i64 [ Number ] ) { if ( @@v9@@ != @@a2@@ ) { if ( ! ( ( unsigned __int8 ( __fastcall * ) ( __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ ) ) { @@v10@@ = ( __int64 * ) @@v8@@ -> m128i_i64 [ Number ] ; if ( @@v10@@ ) { @@v9@@ = * @@v10@@ ; if ( @@a2@@ != * @@v10@@ ) { while ( ! ( ( unsigned __int8 ( __fastcall * ) ( __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ ) ) { @@v8@@ = ( __m128i * ) @@v8@@ -> m128i_i64 [ Number ] ; @@v10@@ = ( __int64 * ) @@v8@@ -> m128i_i64 [ Number ] ; if ( ! @@v10@@ ) return Number L ; @@v9@@ = * @@v10@@ ; if ( * @@v10@@ == @@a2@@ ) goto LABEL_12 ; } @@v10@@ = ( __int64 * ) @@v8@@ -> m128i_i64 [ Number ] ; @@v9@@ = * @@v10@@ ; } LABEL_12 : if ( @@a4@@ ) { @@v8@@ -> m128i_i64 [ Number ] = @@v10@@ [ Number ] ; * @@v10@@ = Number L ; @@v10@@ [ Number ] = @@a1@@ [ Number ] ; @@a1@@ [ Number ] = ( __int64 ) @@v10@@ ; } return @@v9@@ ; } return Number L ; } @@v9@@ = @@v8@@ -> m128i_i64 [ Number ] ; } if ( @@a4@@ ) { @@v12@@ = ( const __m128i * ) @@v8@@ -> m128i_i64 [ Number ] ; if ( @@v12@@ ) { * @@v8@@ = _mm_loadu_si128 ( @@v12@@ ) ; @@v12@@ -> m128i_i64 [ Number ] = Number L ; @@v12@@ -> m128i_i64 [ Number ] = @@a1@@ [ Number ] ; @@a1@@ [ Number ] = ( __int64 ) @@v12@@ ; return @@v9@@ ; } @@v8@@ -> m128i_i64 [ Number ] = Number L ; } return @@v9@@ ; } return Number L ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
int fileno ( FILE * @@stream@@ ) { return fileno ( @@stream@@ ) ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
unsigned __int64 __fastcall hash_get_entries ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { _QWORD * @@v3@@ ; unsigned __int64 @@v4@@ ; _QWORD * @@v5@@ ; unsigned __int64 @@result@@ ; @@v3@@ = * ( _QWORD * * ) @@a1@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= * ( _QWORD * ) @@a1@@ ) return Number L ; @@v4@@ = Number L ; while ( ! * @@v3@@ ) { LABEL_9 : @@v3@@ += Number ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= ( unsigned __int64 ) @@v3@@ ) return @@v4@@ ; } if ( @@a3@@ <= @@v4@@ ) return @@v4@@ ; * ( _QWORD * ) ( @@a2@@ + Number * @@v4@@ ) = * @@v3@@ ; @@v5@@ = ( _QWORD * ) @@v3@@ [ Number ] ; @@result@@ = @@v4@@ + Number ; if ( ! @@v5@@ ) { LABEL_8 : @@v4@@ = @@result@@ ; goto LABEL_9 ; } while ( @@a3@@ != @@result@@ ) { ++ @@result@@ ; * ( _QWORD * ) ( @@a2@@ + Number * @@result@@ - Number ) = * @@v5@@ ; @@v5@@ = ( _QWORD * ) @@v5@@ [ Number ] ; if ( ! @@v5@@ ) goto LABEL_8 ; } return @@result@@ ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
wint_t towlower ( wint_t @@wc@@ ) { return towlower ( @@wc@@ ) ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
bool __fastcall hash_table_ok ( __int64 @@a1@@ ) { _QWORD * @@v1@@ ; unsigned __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; bool @@result@@ ; @@v1@@ = * ( _QWORD * * ) @@a1@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v3@@ = Number L ; @@v4@@ = Number L ; if ( * ( _QWORD * ) @@a1@@ < @@v2@@ ) { do { if ( * @@v1@@ ) { @@v5@@ = @@v1@@ [ Number ] ; ++ @@v4@@ ; ++ @@v3@@ ; for ( ; @@v5@@ ; ++ @@v3@@ ) @@v5@@ = * ( _QWORD * ) ( @@v5@@ + Number ) ; } @@v1@@ += Number ; } while ( ( unsigned __int64 ) @@v1@@ < @@v2@@ ) ; } @@result@@ = Number ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) == @@v4@@ ) @@result@@ = * ( _QWORD * ) ( @@a1@@ + Number ) == @@v3@@ ; return @@result@@ ; }
void __fastcall hash_free ( void * @@ptr@@ ) { _QWORD * @@v2@@ ; unsigned __int64 @@v3@@ ; _QWORD * @@v4@@ ; _QWORD * @@v5@@ ; _QWORD * @@v6@@ ; _QWORD * @@v7@@ ; _QWORD * @@v8@@ ; @@v2@@ = * ( _QWORD * * ) @@ptr@@ ; @@v3@@ = * ( ( _QWORD * ) @@ptr@@ + Number ) ; if ( * ( ( _QWORD * ) @@ptr@@ + Number ) && * ( ( _QWORD * ) @@ptr@@ + Number ) ) { if ( ( unsigned __int64 ) @@v2@@ >= @@v3@@ ) goto LABEL_14 ; do { if ( * @@v2@@ ) { @@v4@@ = @@v2@@ ; do { ( * ( ( void ( * * ) ( void ) ) @@ptr@@ + Number ) ) ( ) ; @@v4@@ = ( _QWORD * ) @@v4@@ [ Number ] ; } while ( @@v4@@ ) ; @@v3@@ = * ( ( _QWORD * ) @@ptr@@ + Number ) ; } @@v2@@ += Number ; } while ( @@v3@@ > ( unsigned __int64 ) @@v2@@ ) ; @@v2@@ = * ( _QWORD * * ) @@ptr@@ ; } if ( ( unsigned __int64 ) @@v2@@ < @@v3@@ ) { do { @@v5@@ = ( _QWORD * ) @@v2@@ [ Number ] ; if ( @@v5@@ ) { do { @@v6@@ = ( _QWORD * ) @@v5@@ [ Number ] ; free ( @@v5@@ ) ; @@v5@@ = @@v6@@ ; } while ( @@v6@@ ) ; } @@v2@@ += Number ; } while ( * ( ( _QWORD * ) @@ptr@@ + Number ) > ( unsigned __int64 ) @@v2@@ ) ; } LABEL_14 : @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@ptr@@ + Number ) ; if ( @@v7@@ ) { do { @@v8@@ = ( _QWORD * ) @@v7@@ [ Number ] ; free ( @@v7@@ ) ; @@v7@@ = @@v8@@ ; } while ( @@v8@@ ) ; } free ( * ( void * * ) @@ptr@@ ) ; free ( @@ptr@@ ) ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
void __fastcall __noreturn regexp_error ( __int64 @@a1@@ , __int64 @@a2@@ , char @@a3@@ ) { __int64 @@v4@@ ; FILE * @@v5@@ ; FILE * @@v6@@ ; _QWORD @@v7@@ [ Number ] ; @@v4@@ = * ( int * ) ( @@a1@@ + Number ) ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quote ( * ( _QWORD * ) ( global_argv + Number * @@v4@@ ) ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; if ( @@a2@@ ) { umaxtostr ( @@a2@@ , @@v7@@ ) ; dcgettext ( Number L , String , Number ) ; @@v5@@ = stderr ; @@v6@@ = ( FILE * ) ( & dword_0 + Number ) ; __fprintf_chk ( ) ; } else { @@v6@@ = stderr ; @@v5@@ = ( FILE * ) ( byte_9 + Number ) ; fputc ( Number , stderr ) ; } if ( ! @@a3@@ ) { dump_rest_of_file ( @@v5@@ , @@v6@@ ) ; close_output_file ( ) ; } cleanup_fatal ( @@v5@@ , @@v6@@ ) ; }
__int64 __fastcall hash_do_for_each ( __int64 @@a1@@ , unsigned __int8 ( __fastcall * @@a2@@ ) ( __int64 , __int64 ) , __int64 @@a3@@ ) { __int64 * @@v3@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 * @@v8@@ ; @@v3@@ = * ( __int64 * * ) @@a1@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= * ( _QWORD * ) @@a1@@ ) return Number L ; @@v6@@ = Number L ; while ( Number ) { @@v7@@ = * @@v3@@ ; if ( * @@v3@@ ) break ; LABEL_8 : @@v3@@ += Number ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= ( unsigned __int64 ) @@v3@@ ) return @@v6@@ ; } @@v8@@ = @@v3@@ ; while ( @@a2@@ ( @@v7@@ , @@a3@@ ) ) { @@v8@@ = ( __int64 * ) @@v8@@ [ Number ] ; ++ @@v6@@ ; if ( ! @@v8@@ ) goto LABEL_8 ; @@v7@@ = * @@v8@@ ; } return @@v6@@ ; }
__int64 __fastcall rpl_fcntl ( int @@a1@@ , int @@a2@@ , __int64 @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { int @@v6@@ ; int @@v8@@ ; int @@v9@@ ; int @@v10@@ ; int @@v11@@ ; int * @@v12@@ ; int @@v13@@ ; int * @@v14@@ ; int @@v15@@ ; @@v15@@ = @@a3@@ ; if ( @@a2@@ != Number ) return ( unsigned int ) fcntl ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( have_dupfd_cloexec_3202 < Number ) { @@v6@@ = ( ( __int64 ( __fastcall * ) ( int , _DWORD , _DWORD , int , int , int , char ) ) rpl_fcntl ) ( @@a1@@ , Number , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ , Number ) ; if ( @@v6@@ < Number || have_dupfd_cloexec_3202 != Number ) return ( unsigned int ) @@v6@@ ; } else { @@v6@@ = fcntl ( @@a1@@ , Number , ( unsigned int ) @@a3@@ ) ; if ( @@v6@@ >= Number || * __errno_location ( ) != Number ) { have_dupfd_cloexec_3202 = Number ; return ( unsigned int ) @@v6@@ ; } @@v6@@ = ( ( __int64 ( __fastcall * ) ( int , _DWORD , int , int , int , int , char ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v15@@ , @@v8@@ , @@v9@@ , @@v10@@ , Number ) ; if ( @@v6@@ < Number ) return ( unsigned int ) @@v6@@ ; have_dupfd_cloexec_3202 = Number ; } @@v11@@ = fcntl ( @@v6@@ , Number ) ; if ( @@v11@@ < Number || fcntl ( @@v6@@ , Number , @@v11@@ | Number ) == Number ) { @@v12@@ = __errno_location ( ) ; @@v13@@ = * @@v12@@ ; @@v14@@ = @@v12@@ ; close ( @@v6@@ ) ; @@v6@@ = Number ; * @@v14@@ = @@v13@@ ; } return ( unsigned int ) @@v6@@ ; }
ssize_t __fastcall safe_write ( int @@fd@@ , void * @@buf@@ , size_t @@n@@ ) { ssize_t @@v4@@ ; int @@v5@@ ; while ( Number ) { @@v4@@ = write ( @@fd@@ , @@buf@@ , @@n@@ ) ; if ( @@v4@@ >= Number ) break ; @@v5@@ = * __errno_location ( ) ; if ( @@v5@@ != Number ) { if ( @@v5@@ != Number || @@n@@ <= Number ) return @@v4@@ ; @@n@@ = Number L ; } } return @@v4@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
DIR * __fastcall opendir_safer ( const char * @@a1@@ ) { DIR * @@v1@@ ; DIR * @@v2@@ ; unsigned int @@v3@@ ; int @@v5@@ ; DIR * @@v6@@ ; int * @@v7@@ ; int @@v8@@ ; @@v1@@ = opendir ( @@a1@@ ) ; @@v2@@ = @@v1@@ ; if ( ! @@v1@@ ) return @@v2@@ ; @@v3@@ = dirfd ( @@v1@@ ) ; if ( @@v3@@ > Number ) return @@v2@@ ; @@v5@@ = dup_safer ( @@v3@@ ) ; @@v6@@ = fdopendir ( @@v5@@ ) ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; if ( ! @@v6@@ ) close ( @@v5@@ ) ; closedir ( @@v2@@ ) ; * @@v7@@ = @@v8@@ ; return @@v6@@ ; }
_QWORD * __fastcall hash_initialize ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 ( __fastcall * @@a3@@ ) ( __int64 a1 , unsigned __int64 a2 ) , bool ( __fastcall * @@a4@@ ) ( __int64 a1 , __int64 a2 ) , __int64 @@a5@@ ) { unsigned __int64 ( __fastcall * @@v5@@ ) ( __int64 , unsigned __int64 ) ; bool ( __fastcall * @@v6@@ ) ( __int64 , __int64 ) ; char * @@v9@@ ; _QWORD * @@v10@@ ; float * * @@v11@@ ; float @@v12@@ ; float @@v13@@ ; float @@v14@@ ; unsigned __int64 @@v15@@ ; char * @@v16@@ ; void * @@v17@@ ; @@v5@@ = @@a3@@ ; @@v6@@ = @@a4@@ ; if ( ! @@a3@@ ) @@v5@@ = raw_hasher ; if ( ! @@a4@@ ) @@v6@@ = raw_comparator ; @@v9@@ = ( char * ) malloc ( Number ) ; @@v10@@ = @@v9@@ ; if ( @@v9@@ ) { @@v11@@ = ( float * * ) ( @@v9@@ + Number ) ; if ( @@a2@@ ) { * ( ( _QWORD * ) @@v9@@ + Number ) = @@a2@@ ; if ( ! ( unsigned __int8 ) check_tuning_isra_0 ( @@v11@@ ) ) goto LABEL_20 ; if ( * ( _BYTE * ) ( @@a2@@ + Number ) ) { LABEL_15 : @@v15@@ = next_prime ( @@a1@@ ) ; if ( @@v15@@ <= Number ) { @@v10@@ [ Number ] = @@v15@@ ; if ( @@v15@@ ) { @@v16@@ = ( char * ) calloc ( @@v15@@ , Number ) ; * @@v10@@ = @@v16@@ ; if ( @@v16@@ ) { @@v10@@ [ Number ] = Number L ; @@v10@@ [ Number ] = Number L ; @@v10@@ [ Number ] = @@v5@@ ; @@v10@@ [ Number ] = @@v6@@ ; @@v10@@ [ Number ] = & @@v16@@ [ Number * @@v15@@ ] ; @@v10@@ [ Number ] = @@a5@@ ; @@v10@@ [ Number ] = Number L ; return @@v10@@ ; } } } LABEL_20 : @@v17@@ = @@v10@@ ; @@v10@@ = Number L ; free ( @@v17@@ ) ; return @@v10@@ ; } @@v12@@ = * ( float * ) ( @@a2@@ + Number ) ; } else { * ( ( _QWORD * ) @@v9@@ + Number ) = & default_tuning ; @@v12@@ = Number ; if ( ! ( unsigned __int8 ) check_tuning_isra_0 ( @@v11@@ ) ) goto LABEL_20 ; } if ( @@a1@@ < Number ) @@v13@@ = ( float ) ( @@a1@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@a1@@ >> Number ) ) + ( float ) ( @@a1@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@a1@@ >> Number ) ) ; else @@v13@@ = ( float ) ( int ) @@a1@@ ; @@v14@@ = @@v13@@ / @@v12@@ ; if ( @@v14@@ >= Number ) goto LABEL_20 ; if ( @@v14@@ < Number ) @@a1@@ = ( unsigned int ) ( int ) @@v14@@ ; else @@a1@@ = ( unsigned int ) ( int ) ( float ) ( @@v14@@ - Number ) ^ Number ; goto LABEL_15 ; } return @@v10@@ ; }
unsigned __int64 close_output_file ( ) { const char * @@v1@@ ; int @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; sigset_t @@v7@@ ; char @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; if ( ! output_stream ) return __readfsqword ( Number ) ^ @@v9@@ ; if ( ( output_stream -> _flags & Number ) != Number ) { @@v5@@ = quote ( output_filename ) ; @@v6@@ = dcgettext ( Number L , String , Number ) ; error ( Number , Number , @@v6@@ , @@v5@@ ) ; LABEL_13 : output_stream = Number L ; cleanup_fatal ( ) ; } if ( fclose ( output_stream ) ) { @@v4@@ = __errno_location ( ) ; error ( Number , * @@v4@@ , String , output_filename ) ; goto LABEL_13 ; } if ( ! * ( _QWORD * ) & bytes_written && elide_empty_files ) { sigprocmask ( bytes_written , & caught_signals , & @@v7@@ ) ; @@v1@@ = output_filename ; @@v2@@ = unlink ( output_filename ) ; @@v3@@ = * __errno_location ( ) ; files_created = ( __PAIR64__ ( files_created , @@v2@@ ) - Number ) >> Number ; sigprocmask ( Number , & @@v7@@ , Number L ) ; if ( @@v2@@ ) error ( Number , @@v3@@ , String , @@v1@@ ) ; } else if ( ! suppress_count ) { umaxtostr ( * ( _QWORD * ) & bytes_written , @@v8@@ ) ; __fprintf_chk ( ) ; } output_stream = Number L ; return __readfsqword ( Number ) ^ @@v9@@ ; }
bool __fastcall strip_trailing_slashes ( char * @@a1@@ ) { const char * @@v1@@ ; const char * @@v2@@ ; bool @@v3@@ ; @@v1@@ = last_component ( @@a1@@ ) ; if ( ! * @@v1@@ ) @@v1@@ = @@a1@@ ; @@v2@@ = & @@v1@@ [ base_len ( @@v1@@ ) ] ; @@v3@@ = * @@v2@@ == Number ; * @@v2@@ = Number ; return ! @@v3@@ ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
__int64 __fastcall bsd_sum_file ( char * @@filename@@ , int @@a2@@ ) { bool @@v3@@ ; _BOOL4 @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; char * @@v7@@ ; __int64 @@v8@@ ; int @@i@@ ; char * @@v10@@ ; char * @@v11@@ ; unsigned int @@v12@@ ; int * @@v14@@ ; int * @@v15@@ ; _QWORD @@v16@@ [ Number ] ; @@v16@@ [ Number ] = __readfsqword ( Number ) ; @@v3@@ = strcmp ( @@filename@@ , String ) == Number ; @@v4@@ = ! @@v3@@ ; if ( @@v3@@ ) { @@v5@@ = stdin ; have_read_stdin = Number ; } else { @@v5@@ = fopen ( @@filename@@ , String ) ; if ( ! @@v5@@ ) goto LABEL_17 ; } @@v6@@ = @@v5@@ -> _IO_read_ptr ; @@v7@@ = @@v5@@ -> _IO_read_end ; @@v8@@ = Number L ; for ( @@i@@ = Number ; ; @@i@@ = ( unsigned __int16 ) @@i@@ ) { if ( @@v6@@ < @@v7@@ ) { @@v10@@ = @@v6@@ + Number ; @@v5@@ -> _IO_read_ptr = @@v6@@ + Number ; LOWORD ( @@v6@@ ) = ( unsigned __int8 ) * @@v6@@ ; goto LABEL_5 ; } LODWORD ( @@v6@@ ) = __uflow ( @@v5@@ ) ; if ( ( _DWORD ) @@v6@@ == Number ) break ; @@v10@@ = @@v5@@ -> _IO_read_ptr ; @@v7@@ = @@v5@@ -> _IO_read_end ; LABEL_5 : ++ @@v8@@ ; LOWORD ( @@i@@ ) = ( _WORD ) @@v6@@ + ( @@i@@ >> Number ) + ( ( _WORD ) @@i@@ << Number ) ; @@v6@@ = @@v10@@ ; } if ( ( @@v5@@ -> _flags & Number ) == Number ) { if ( ! @@v4@@ || ! fclose ( @@v5@@ ) ) { human_readable ( @@v8@@ , @@v16@@ , Number L , Number L , Number L ) ; __printf_chk ( ) ; if ( @@a2@@ > Number ) __printf_chk ( ) ; @@v11@@ = stdout -> _IO_write_ptr ; @@v12@@ = Number ; if ( @@v11@@ >= stdout -> _IO_write_end ) { __overflow ( stdout , Number ) ; } else { stdout -> _IO_write_ptr = @@v11@@ + Number ; * @@v11@@ = Number ; } return @@v12@@ ; } LABEL_17 : @@v14@@ = __errno_location ( ) ; @@v12@@ = Number ; error ( Number , * @@v14@@ , String , @@filename@@ ) ; return @@v12@@ ; } @@v15@@ = __errno_location ( ) ; @@v12@@ = Number ; error ( Number , * @@v15@@ , String , @@filename@@ ) ; if ( @@v4@@ ) fclose ( @@v5@@ ) ; return @@v12@@ ; }
__int64 __fastcall utimens ( char * @@a1@@ , const __m128i * @@a2@@ ) { return fdutimens ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 __fastcall openat_safer ( int @@a1@@ , const char * @@a2@@ , char @@a3@@ , unsigned int @@a4@@ ) { __int64 @@v4@@ ; int @@v5@@ ; @@v4@@ = Number L ; if ( ( @@a3@@ & Number ) != Number ) @@v4@@ = @@a4@@ ; @@v5@@ = openat ( @@a1@@ , @@a2@@ , @@a3@@ , @@v4@@ ) ; return fd_safer ( @@v5@@ ) ; }
unsigned __int64 __fastcall new_control_record ( __int64 a1 , __int64 @@a2@@ ) { unsigned __int64 @@v2@@ ; __int64 @@v3@@ ; unsigned __int64 @@result@@ ; __int64 @@v5@@ ; @@v2@@ = control_used ; @@v3@@ = controls ; if ( control_used == control_allocated_6763 ) { if ( controls ) { if ( ( unsigned __int64 ) control_used > Number ) xalloc_die ( controls , @@a2@@ , Number ) ; @@v2@@ = ( ( unsigned __int64 ) ( control_used + Number ) >> Number ) + control_used ; } else if ( ! control_used ) { @@v5@@ = Number L ; @@v2@@ = Number L ; goto LABEL_7 ; } @@v5@@ = Number * @@v2@@ ; LABEL_7 : control_allocated_6763 = @@v2@@ ; @@v3@@ = xrealloc ( controls , @@v5@@ ) ; controls = @@v3@@ ; @@v2@@ = control_used ; } control_used = @@v2@@ + Number ; @@result@@ = @@v3@@ + Number * @@v2@@ ; * ( _BYTE * ) ( @@result@@ + Number ) = Number ; * ( _QWORD * ) ( @@result@@ + Number ) = Number L ; * ( _BYTE * ) ( @@result@@ + Number ) = Number ; * ( _QWORD * ) ( @@result@@ + Number ) = Number L ; * ( _QWORD * ) @@result@@ = Number L ; return @@result@@ ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
__int64 yesno ( ) { unsigned int @@v0@@ ; __ssize_t @@v1@@ ; char * @@lineptr@@ ; size_t @@n@@ [ Number ] ; @@v0@@ = Number ; @@lineptr@@ = Number L ; @@n@@ [ Number ] = __readfsqword ( Number ) ; @@n@@ [ Number ] = Number L ; @@v1@@ = __getdelim ( & @@lineptr@@ , @@n@@ , Number , stdin ) ; if ( @@v1@@ > Number ) { @@lineptr@@ [ @@v1@@ - Number ] = Number ; LOBYTE ( @@v0@@ ) = rpmatch ( @@lineptr@@ ) > Number ; } free ( @@lineptr@@ ) ; return @@v0@@ ; }
__int64 __fastcall human_options ( char * @@nptr@@ , int * @@a2@@ , __int64 * @@a3@@ ) { char * @@v4@@ ; int @@v5@@ ; int @@v6@@ ; int @@v7@@ ; __int64 @@result@@ ; __int64 @@v9@@ ; char * @@v10@@ ; @@v4@@ = @@nptr@@ ; if ( @@nptr@@ || ( @@v4@@ = getenv ( String ) ) != Number L || ( @@v4@@ = getenv ( String ) ) != Number L ) { @@v5@@ = Number ; if ( * @@v4@@ == Number ) { ++ @@v4@@ ; @@v5@@ = Number ; } @@v6@@ = argmatch ( @@v4@@ , & block_size_args , block_size_opts , Number L ) ; if ( @@v6@@ >= Number ) { * @@a3@@ = Number L ; @@v7@@ = block_size_opts [ @@v6@@ ] | @@v5@@ ; @@result@@ = Number L ; * @@a2@@ = @@v7@@ ; return @@result@@ ; } @@result@@ = xstrtoumax ( @@v4@@ ) ; if ( ( _DWORD ) @@result@@ ) { @@v9@@ = * @@a3@@ ; * @@a2@@ = Number ; LABEL_15 : if ( ! @@v9@@ ) { * @@a3@@ = getenv ( String ) == Number L ? Number L : Number L ; @@result@@ = Number L ; } return @@result@@ ; } if ( ( unsigned __int8 ) ( * @@v4@@ - Number ) > Number ) { if ( @@v4@@ != @@v10@@ ) { while ( ( unsigned __int8 ) ( * ++ @@v4@@ - Number ) > Number ) { if ( @@v4@@ == @@v10@@ ) goto LABEL_22 ; } goto LABEL_13 ; } LABEL_22 : if ( * ( @@v10@@ - Number ) == Number ) { @@v5@@ |= Number ; if ( * ( @@v10@@ - Number ) != Number ) goto LABEL_13 ; } else { LOBYTE ( @@v5@@ ) = @@v5@@ | Number ; } @@v5@@ |= Number ; } LABEL_13 : @@v9@@ = * @@a3@@ ; * @@a2@@ = @@v5@@ ; goto LABEL_15 ; } if ( getenv ( String ) ) * @@a3@@ = Number L ; else * @@a3@@ = Number L ; @@result@@ = Number L ; * @@a2@@ = Number ; return @@result@@ ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_216250 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_216230 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_216240 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall freadahead ( __int64 @@a1@@ ) { __int64 @@result@@ ; @@result@@ = Number L ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= * ( _QWORD * ) ( @@a1@@ + Number ) ) { @@result@@ = * ( _QWORD * ) ( @@a1@@ + Number ) - * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( ( * ( _DWORD * ) @@a1@@ & Number ) != Number ) @@result@@ += * ( _QWORD * ) ( @@a1@@ + Number ) - * ( _QWORD * ) ( @@a1@@ + Number ) ; } return @@result@@ ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
__int64 __fastcall quote_n ( __int64 @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
void __fastcall argmatch_invalid ( __int64 @@a1@@ , wchar_t * @@a2@@ , __int64 @@a3@@ ) { char * @@v3@@ ; __int64 @@v4@@ ; _BYTE * @@v5@@ ; if ( @@a3@@ == Number ) @@v3@@ = dcgettext ( Number L , String , Number ) ; else @@v3@@ = dcgettext ( Number L , String , Number ) ; @@v4@@ = quote_n ( Number L , @@a1@@ ) ; @@v5@@ = quotearg_n_style ( Number , Number , @@a2@@ ) ; error ( Number , Number , @@v3@@ , @@v5@@ , @@v4@@ ) ; }
__int64 __fastcall savedir ( const char * @@a1@@ , __int64 @@a2@@ ) { DIR * @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; @@v2@@ = opendir_safer ( @@a1@@ ) ; return savedirstream ( @@v2@@ , @@a2@@ , @@v3@@ , @@v4@@ , @@v5@@ ) ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
unsigned __int64 __fastcall dev_info_hash ( _QWORD * @@a1@@ , unsigned __int64 @@a2@@ ) { return * @@a1@@ % @@a2@@ ; }
__ino_t * __fastcall get_root_dev_ino ( __ino_t * @@a1@@ ) { struct stat @@v2@@ ; unsigned __int64 @@v3@@ ; @@v3@@ = __readfsqword ( Number ) ; if ( __lxstat ( Number , String , & @@v2@@ ) ) return Number L ; * @@a1@@ = @@v2@@ . st_ino ; @@a1@@ [ Number ] = @@v2@@ . st_dev ; return @@a1@@ ; }
__int64 __fastcall _xargmatch_internal ( __int64 @@a1@@ , char * @@a2@@ , const char * * @@a3@@ , char * @@a4@@ , size_t @@a5@@ , void ( * @@a6@@ ) ( void ) ) { __int64 @@result@@ ; @@result@@ = argmatch ( @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; if ( @@result@@ < Number ) { argmatch_invalid ( @@a1@@ , ( wchar_t * ) @@a2@@ , @@result@@ ) ; argmatch_valid ( @@a3@@ , @@a4@@ , @@a5@@ ) ; @@a6@@ ( ) ; @@result@@ = Number ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
__int64 __fastcall fdsavedir ( int @@a1@@ , __int64 @@a2@@ ) { DIR * @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; @@v2@@ = fdopendir ( @@a1@@ ) ; return savedirstream ( @@v2@@ , @@a2@@ , @@v3@@ , @@v4@@ , @@v5@@ ) ; }
__int64 __fastcall update_timespec ( _QWORD * @@a1@@ , struct timespec * * @@a2@@ ) { struct timespec * @@v2@@ ; __syscall_slong_t @@v3@@ ; __syscall_slong_t @@v4@@ ; __int64 @@result@@ ; __time_t @@v6@@ ; __time_t @@v7@@ ; @@v2@@ = * @@a2@@ ; @@v3@@ = ( * @@a2@@ ) -> tv_nsec ; @@v4@@ = ( * @@a2@@ ) [ Number ] . tv_nsec ; if ( @@v3@@ != Number ) { if ( @@v3@@ == Number ) { if ( @@v4@@ == Number ) { * @@a2@@ = Number L ; return Number L ; } gettime ( * @@a2@@ ) ; @@v4@@ = @@v2@@ [ Number ] . tv_nsec ; if ( @@v4@@ != Number ) { LABEL_4 : @@result@@ = Number L ; if ( @@v4@@ != Number ) return @@result@@ ; LABEL_11 : gettime ( @@v2@@ + Number ) ; return Number L ; } } else if ( @@v4@@ != Number ) { goto LABEL_4 ; } @@v6@@ = @@a1@@ [ Number ] ; @@v2@@ [ Number ] . tv_nsec = @@a1@@ [ Number ] ; @@v2@@ [ Number ] . tv_sec = @@v6@@ ; return Number L ; } @@result@@ = Number L ; if ( @@v4@@ != Number ) { @@v7@@ = @@a1@@ [ Number ] ; @@v2@@ -> tv_nsec = @@a1@@ [ Number ] ; @@result@@ = Number L ; @@v2@@ -> tv_sec = @@v7@@ ; if ( @@v4@@ == Number ) goto LABEL_11 ; } return @@result@@ ; }
__int64 __fastcall fd_safer ( int @@fd@@ , __int64 @@a2@@ , __int64 @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { unsigned int @@v6@@ ; unsigned int @@v7@@ ; int * @@v8@@ ; int @@v9@@ ; int * @@v10@@ ; @@v6@@ = @@fd@@ ; if ( ( unsigned int ) @@fd@@ <= Number ) { @@v7@@ = dup_safer ( @@fd@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; @@v8@@ = __errno_location ( ) ; @@v9@@ = * @@v8@@ ; @@v10@@ = @@v8@@ ; close ( @@fd@@ ) ; @@v6@@ = @@v7@@ ; * @@v10@@ = @@v9@@ ; } return @@v6@@ ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_208210 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2081F0 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_208200 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
bool __fastcall dev_info_compare ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { return * @@a1@@ == * @@a2@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall gl_futimens ( int @@fd2@@ , char * @@path@@ , const __m128i * @@a3@@ ) { return fdutimens ( @@path@@ , @@fd2@@ , @@a3@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
__int64 __fastcall xfts_open ( const char * * @@a1@@ , int @@a2@@ , __int64 @@a3@@ ) { __int64 @@result@@ ; @@result@@ = fts_open ( @@a1@@ , @@a2@@ | Number , @@a3@@ ) ; if ( ! @@result@@ ) { if ( * __errno_location ( ) != Number ) xalloc_die ( ) ; __assert_fail ( String , String , Number , String ) ; } return @@result@@ ; }
char can_write_any_file ( ) { char @@result@@ ; __uid_t @@v1@@ ; if ( initialized_2987 ) return can_write_2988 ; @@v1@@ = geteuid ( ) ; initialized_2987 = Number ; @@result@@ = @@v1@@ == Number ; can_write_2988 = @@result@@ ; return @@result@@ ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall mark_opt_subexp ( __int64 @@a1@@ , __int64 @@a2@@ ) { if ( * ( _BYTE * ) ( @@a2@@ + Number ) != Number || @@a1@@ != * ( _QWORD * ) ( @@a2@@ + Number ) ) { return Number L ; } * ( _BYTE * ) ( @@a2@@ + Number ) |= Number ; return Number L ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
__int64 __fastcall argmatch_to_argument ( void * @@s1@@ , __int64 * @@a2@@ , char * @@a3@@ , size_t @@a4@@ ) { __int64 @@v4@@ ; __int64 * @@v7@@ ; @@v4@@ = * @@a2@@ ; if ( * @@a2@@ ) { @@v7@@ = @@a2@@ + Number ; do { if ( ! memcmp ( @@s1@@ , @@a3@@ , @@a4@@ ) ) break ; @@v4@@ = * @@v7@@ ; @@a3@@ += @@a4@@ ; ++ @@v7@@ ; } while ( @@v4@@ ) ; } return @@v4@@ ; }
__int64 __fastcall re_string_realloc_buffers ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { void * @@v3@@ ; void * @@v4@@ ; void * @@v5@@ ; void * @@v7@@ ; if ( * ( int * ) ( @@a1@@ + Number ) > Number ) { if ( ! is_mul_ok ( @@a2@@ , Number ) ) return Number L ; @@v3@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number * @@a2@@ ) ; if ( ! @@v3@@ ) return Number L ; @@v4@@ = * ( void * * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v3@@ ; if ( @@v4@@ ) { @@v5@@ = realloc ( @@v4@@ , Number * @@a2@@ ) ; if ( ! @@v5@@ ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v5@@ ; } } if ( ! * ( _BYTE * ) ( @@a1@@ + Number ) ) { LABEL_8 : * ( _QWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; return Number L ; } @@v7@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , @@a2@@ ) ; if ( @@v7@@ ) { * ( _QWORD * ) ( @@a1@@ + Number ) = @@v7@@ ; goto LABEL_8 ; } return Number L ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; char * @@v11@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String String String String String String String String String String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v9@@ = stdout ; @@v10@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; @@v11@@ = setlocale ( Number , Number L ) ; if ( @@v11@@ ) { if ( strncmp ( @@v11@@ , String , Number ) ) { last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
__int64 __fastcall set_cloexec_flag ( int @@a1@@ , char @@a2@@ , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { int @@v6@@ ; int @@v7@@ ; int @@v8@@ ; int @@v9@@ ; int @@v10@@ ; unsigned int @@v11@@ ; __int64 @@result@@ ; @@v6@@ = rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( @@v6@@ < Number ) return Number ; @@v9@@ = @@v6@@ ; @@v10@@ = @@v6@@ | Number ; @@v11@@ = @@v9@@ & Number ; if ( @@a2@@ ) @@v11@@ = @@v10@@ ; @@result@@ = Number L ; if ( @@v11@@ != @@v9@@ ) @@result@@ = ( unsigned int ) - ( ( unsigned int ) rpl_fcntl ( @@a1@@ , Number , @@v11@@ , @@v9@@ , @@v7@@ , @@v8@@ ) == Number ) ; return @@result@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall duplicate_node ( __int64 * @@a1@@ , __int64 @@a2@@ , __int16 @@a3@@ ) { __int64 @@v3@@ ; __int64 @@result@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; unsigned int @@v9@@ ; unsigned int @@v10@@ ; @@v3@@ = Number * @@a2@@ ; @@result@@ = re_dfa_add_node ( ( __int64 ) @@a1@@ , * ( _QWORD * ) ( * @@a1@@ + Number * @@a2@@ ) , * ( _QWORD * ) ( * @@a1@@ + Number * @@a2@@ + Number ) ) ; if ( @@result@@ != Number ) { @@v7@@ = * @@a1@@ ; @@v8@@ = * @@a1@@ + Number * @@result@@ ; @@v9@@ = ( ( @@a3@@ & Number ) << Number ) | * ( _DWORD * ) ( @@v8@@ + Number ) & Number ; * ( _DWORD * ) ( @@v8@@ + Number ) = @@v9@@ ; @@v10@@ = @@v9@@ & Number | ( ( ( @@a3@@ & Number | ( unsigned __int16 ) ( * ( _DWORD * ) ( @@v7@@ + @@v3@@ + Number ) >> Number ) ) & Number ) << Number ) ; * ( _DWORD * ) ( @@v8@@ + Number ) = @@v10@@ ; * ( _BYTE * ) ( @@v8@@ + Number ) = BYTE2 ( @@v10@@ ) | Number ; * ( _QWORD * ) ( @@a1@@ [ Number ] + Number * @@result@@ ) = @@a2@@ ; } return @@result@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
bool __fastcall cycle_warning_required ( __int64 @@a1@@ , __int64 @@a2@@ ) { bool @@result@@ ; int @@v3@@ ; @@result@@ = Number ; @@v3@@ = * ( _DWORD * ) ( @@a1@@ + Number ) & Number ; if ( @@v3@@ != Number ) { @@result@@ = Number ; if ( @@v3@@ == Number ) @@result@@ = * ( _QWORD * ) ( @@a2@@ + Number ) != Number L ; } return @@result@@ ; }
__int64 __fastcall dup_safer ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
void __fastcall match_ctx_clean ( _QWORD * @@a1@@ ) { unsigned __int64 @@v1@@ ; __int64 @@v2@@ ; unsigned __int64 @@v3@@ ; void * * @@v4@@ ; __int64 @@v5@@ ; if ( @@a1@@ [ Number ] ) { @@v1@@ = Number L ; do { @@v2@@ = * ( _QWORD * ) ( @@a1@@ [ Number ] + Number * @@v1@@ ) ; if ( * ( _QWORD * ) ( @@v2@@ + Number ) ) { @@v3@@ = Number L ; do { @@v4@@ = * ( void * * * ) ( * ( _QWORD * ) ( @@v2@@ + Number ) + Number * @@v3@@ ++ ) ; free ( @@v4@@ [ Number ] ) ; free ( @@v4@@ ) ; } while ( * ( _QWORD * ) ( @@v2@@ + Number ) > @@v3@@ ) ; } free ( * ( void * * ) ( @@v2@@ + Number ) ) ; @@v5@@ = * ( _QWORD * ) ( @@v2@@ + Number ) ; if ( @@v5@@ ) { free ( * ( void * * ) ( @@v5@@ + Number ) ) ; free ( * ( void * * ) ( @@v2@@ + Number ) ) ; } ++ @@v1@@ ; free ( ( void * ) @@v2@@ ) ; } while ( @@a1@@ [ Number ] > @@v1@@ ) ; } @@a1@@ [ Number ] = Number L ; @@a1@@ [ Number ] = Number L ; }
__int64 __fastcall argmatch ( const char * @@a1@@ , const char * * @@a2@@ , char * @@a3@@ , size_t @@a4@@ ) { char * @@v5@@ ; size_t @@v6@@ ; const char * @@v7@@ ; size_t @@v8@@ ; __int64 @@v9@@ ; bool @@v10@@ ; char @@v11@@ ; __int64 @@v12@@ ; __int64 @@v14@@ ; char @@v15@@ ; @@v5@@ = @@a3@@ ; @@v6@@ = strlen ( @@a1@@ ) ; @@v7@@ = * @@a2@@ ; @@v14@@ = Number ; if ( ! * @@a2@@ ) return @@v14@@ ; @@v8@@ = @@v6@@ ; @@v15@@ = Number ; @@v9@@ = Number L ; do { while ( strncmp ( @@v7@@ , @@a1@@ , @@v8@@ ) ) { LABEL_7 : ++ @@v9@@ ; @@v5@@ += @@a4@@ ; @@v7@@ = @@a2@@ [ @@v9@@ ] ; if ( ! @@v7@@ ) goto LABEL_12 ; } if ( strlen ( @@v7@@ ) == @@v8@@ ) return @@v9@@ ; if ( @@v14@@ != Number ) { if ( @@a3@@ ) { @@v10@@ = memcmp ( & @@a3@@ [ @@a4@@ * @@v14@@ ] , @@v5@@ , @@a4@@ ) == Number ; @@v11@@ = @@v15@@ ; if ( ! @@v10@@ ) @@v11@@ = Number ; @@v15@@ = @@v11@@ ; } else { @@v15@@ = Number ; } goto LABEL_7 ; } @@v14@@ = @@v9@@ ++ ; @@v5@@ += @@a4@@ ; @@v7@@ = @@a2@@ [ @@v9@@ ] ; } while ( @@v7@@ ) ; LABEL_12 : @@v12@@ = Number ; if ( ! @@v15@@ ) @@v12@@ = @@v14@@ ; return @@v12@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 __fastcall calc_next ( __int64 a1 , __int64 @@a2@@ ) { char @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@result@@ ; __int64 @@v6@@ ; @@v2@@ = * ( _BYTE * ) ( @@a2@@ + Number ) ; @@v3@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( @@v2@@ == Number ) { * ( _QWORD * ) ( @@v3@@ + Number ) = @@a2@@ ; @@result@@ = Number L ; } else if ( @@v2@@ == Number ) { @@v6@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; * ( _QWORD * ) ( @@v3@@ + Number ) = * ( _QWORD * ) ( @@v6@@ + Number ) ; * ( _QWORD * ) ( @@v6@@ + Number ) = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@result@@ = Number L ; } else { if ( @@v3@@ ) * ( _QWORD * ) ( @@v3@@ + Number ) = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@v4@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( @@v4@@ ) * ( _QWORD * ) ( @@v4@@ + Number ) = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@result@@ = Number L ; } return @@result@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
char * __fastcall duplicate_tree ( _QWORD * * @@a1@@ , __int64 @@a2@@ ) { _QWORD * * @@v2@@ ; _QWORD * @@v3@@ ; __int64 * @@v4@@ ; char * @@result@@ ; _QWORD * * @@v6@@ ; _QWORD * @@v7@@ ; __int64 @@v8@@ [ Number ] ; @@v2@@ = @@a1@@ ; @@v3@@ = * @@a1@@ ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ = @@v8@@ ; while ( Number ) { @@result@@ = create_token_tree_isra_18 ( ( _QWORD * ) ( @@a2@@ + Number ) , ( int * ) ( @@a2@@ + Number ) , Number L , Number L , ( const __m128i * ) ( @@v2@@ + Number ) ) ; * @@v4@@ = ( __int64 ) @@result@@ ; if ( ! @@result@@ ) break ; * ( _QWORD * ) @@result@@ = @@v3@@ ; @@v3@@ = ( _QWORD * ) * @@v4@@ ; * ( _BYTE * ) ( * @@v4@@ + Number ) |= Number ; if ( @@v2@@ [ Number ] ) { @@v4@@ = @@v3@@ + Number ; @@v2@@ = ( _QWORD * * ) @@v2@@ [ Number ] ; } else { @@v6@@ = Number L ; while ( Number ) { @@v7@@ = @@v2@@ [ Number ] ; if ( @@v7@@ ) { if ( @@v7@@ != @@v6@@ ) break ; } @@v3@@ = ( _QWORD * ) * @@v3@@ ; @@v6@@ = @@v2@@ ; if ( ! * @@v2@@ ) return ( char * ) @@v8@@ [ Number ] ; @@v2@@ = ( _QWORD * * ) * @@v2@@ ; } @@v4@@ = @@v3@@ + Number ; @@v2@@ = ( _QWORD * * ) @@v2@@ [ Number ] ; } } return @@result@@ ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
__int64 __fastcall print_group_list ( __int64 @@a1@@ , __uid_t @@a2@@ , __gid_t @@a3@@ , __gid_t @@a4@@ , unsigned __int8 @@a5@@ ) { unsigned int @@v6@@ ; struct passwd * @@v8@@ ; unsigned int @@v9@@ ; char * @@v10@@ ; __int64 @@v11@@ ; int @@v12@@ ; char * @@v13@@ ; __int64 @@v14@@ ; __int64 @@v15@@ ; int @@v16@@ ; char * @@v17@@ ; char @@v18@@ ; __int64 @@v20@@ ; int * @@v21@@ ; __int64 @@v22@@ ; char * @@v23@@ ; char * @@v24@@ ; void * @@ptr@@ [ Number ] ; @@v6@@ = @@a5@@ ; @@ptr@@ [ Number ] = ( void * ) __readfsqword ( Number ) ; @@v8@@ = getpwuid ( @@a2@@ ) ; @@v9@@ = print_group ( @@a3@@ , @@v6@@ ) ; if ( ( _BYTE ) @@v9@@ ) LOBYTE ( @@v9@@ ) = @@v8@@ != Number L ; if ( @@a3@@ != @@a4@@ ) { @@v10@@ = stdout -> _IO_write_ptr ; if ( @@v10@@ >= stdout -> _IO_write_end ) { __overflow ( stdout , Number ) ; } else { stdout -> _IO_write_ptr = @@v10@@ + Number ; * @@v10@@ = Number ; } if ( ! ( unsigned __int8 ) print_group ( @@a4@@ , @@v6@@ ) ) @@v9@@ = Number ; } @@v11@@ = Number ; if ( @@v8@@ ) @@v11@@ = @@v8@@ -> pw_gid ; @@v12@@ = xgetgroups ( @@a1@@ , @@v11@@ , @@ptr@@ ) ; if ( @@v12@@ < Number ) { @@v21@@ = __errno_location ( ) ; if ( @@a1@@ ) { @@v22@@ = quote ( @@a1@@ , @@v11@@ , @@v20@@ ) ; @@v23@@ = dcgettext ( Number L , String , Number ) ; error ( Number , * @@v21@@ , @@v23@@ , @@v22@@ ) ; } else { @@v24@@ = dcgettext ( Number L , String , Number ) ; error ( Number , * @@v21@@ , @@v24@@ ) ; } @@v9@@ = Number ; } else { @@v13@@ = ( char * ) @@ptr@@ [ Number ] ; if ( @@v12@@ ) { @@v14@@ = Number L ; @@v15@@ = Number L * ( unsigned int ) ( @@v12@@ - Number ) + Number ; do { @@v16@@ = * ( _DWORD * ) & @@v13@@ [ @@v14@@ ] ; if ( @@v16@@ != @@a3@@ && @@v16@@ != @@a4@@ ) { @@v17@@ = stdout -> _IO_write_ptr ; if ( @@v17@@ >= stdout -> _IO_write_end ) { __overflow ( stdout , Number ) ; } else { stdout -> _IO_write_ptr = @@v17@@ + Number ; * @@v17@@ = Number ; } @@v18@@ = print_group ( * ( _DWORD * ) ( ( char * ) @@ptr@@ [ Number ] + @@v14@@ ) , @@v6@@ ) ; @@v13@@ = ( char * ) @@ptr@@ [ Number ] ; if ( ! @@v18@@ ) @@v9@@ = Number ; } @@v14@@ += Number L ; } while ( @@v15@@ != @@v14@@ ) ; } free ( @@v13@@ ) ; } return @@v9@@ ; }
__int64 __fastcall rpl_fcntl ( int @@a1@@ , int @@a2@@ , __int64 @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { int @@v6@@ ; int @@v8@@ ; int @@v9@@ ; int @@v10@@ ; int @@v11@@ ; int * @@v12@@ ; int @@v13@@ ; int * @@v14@@ ; int @@v15@@ ; @@v15@@ = @@a3@@ ; if ( @@a2@@ != Number ) return ( unsigned int ) fcntl ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( have_dupfd_cloexec_3202 < Number ) { @@v6@@ = rpl_fcntl ( @@a1@@ , Number , ( unsigned int ) @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( @@v6@@ < Number || have_dupfd_cloexec_3202 != Number ) return ( unsigned int ) @@v6@@ ; } else { @@v6@@ = fcntl ( @@a1@@ , Number , ( unsigned int ) @@a3@@ ) ; if ( @@v6@@ >= Number || * __errno_location ( ) != Number ) { have_dupfd_cloexec_3202 = Number ; return ( unsigned int ) @@v6@@ ; } @@v6@@ = rpl_fcntl ( @@a1@@ , Number , @@v15@@ , @@v8@@ , @@v9@@ , @@v10@@ ) ; if ( @@v6@@ < Number ) return ( unsigned int ) @@v6@@ ; have_dupfd_cloexec_3202 = Number ; } @@v11@@ = fcntl ( @@v6@@ , Number ) ; if ( @@v11@@ < Number || fcntl ( @@v6@@ , Number , @@v11@@ | Number ) == Number ) { @@v12@@ = __errno_location ( ) ; @@v13@@ = * @@v12@@ ; @@v14@@ = @@v12@@ ; close ( @@v6@@ ) ; @@v6@@ = Number ; * @@v14@@ = @@v13@@ ; } return ( unsigned int ) @@v6@@ ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
__int64 __fastcall check_subexp_matching_top_isra_21 ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , _QWORD * @@a3@@ , __int64 @@a4@@ ) { _QWORD * @@v4@@ ; unsigned __int64 @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; __int64 @@v12@@ ; _QWORD * @@v13@@ ; _QWORD * @@v14@@ ; bool @@v15@@ ; _QWORD * @@v17@@ ; __int64 @@v18@@ ; __int64 @@v19@@ ; _QWORD * @@v20@@ ; __int64 @@v21@@ ; __int64 @@v22@@ ; @@v4@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; if ( ! * @@a2@@ ) return Number L ; @@v7@@ = Number L ; while ( Number ) { while ( Number ) { @@v8@@ = * ( _QWORD * ) ( * @@a3@@ + Number * @@v7@@ ) ; @@v9@@ = * @@v4@@ + Number * @@v8@@ ; if ( * ( _BYTE * ) ( @@v9@@ + Number ) == Number ) { @@v10@@ = * ( _QWORD * ) @@v9@@ ; if ( @@v10@@ <= Number ) { @@v11@@ = @@v4@@ [ Number ] ; if ( _bittest64 ( & @@v11@@ , @@v10@@ ) ) break ; } } if ( ++ @@v7@@ >= * @@a2@@ ) return Number L ; } @@v12@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v13@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; if ( @@v12@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ) break ; LABEL_8 : @@v20@@ = @@v13@@ ; @@v18@@ = @@v12@@ ; @@v22@@ = @@a4@@ ; @@v14@@ = calloc ( Number , Number ) ; @@v20@@ [ @@v18@@ ] = @@v14@@ ; if ( ! @@v14@@ ) return Number L ; ++ @@v7@@ ; @@a4@@ = @@v22@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v18@@ + Number ; @@v15@@ = @@v7@@ < * @@a2@@ ; @@v14@@ [ Number ] = @@v8@@ ; * @@v14@@ = @@v22@@ ; if ( ! @@v15@@ ) return Number L ; } @@v19@@ = @@a4@@ ; @@v21@@ = Number * @@v12@@ ; @@v17@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number * @@v12@@ ) ; @@v13@@ = @@v17@@ ; @@a4@@ = @@v19@@ ; if ( @@v17@@ ) { * ( _QWORD * ) ( @@a1@@ + Number ) = @@v17@@ ; @@v12@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v21@@ ; goto LABEL_8 ; } return Number L ; }
struct group * getgrgid ( __gid_t @@gid@@ ) { return getgrgid ( @@gid@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_2071F0 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2071D0 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_2071E0 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
unsigned __int64 create_output_file ( ) { char * @@v0@@ ; FILE * @@v1@@ ; int @@v2@@ ; unsigned __int64 @@result@@ ; sigset_t @@_0@@ ; unsigned __int64 @@vars88@@ ; @@vars88@@ = __readfsqword ( Number ) ; @@v0@@ = make_filename ( ) ; output_filename = @@v0@@ ; sigprocmask ( Number , & caught_signals , & @@_0@@ ) ; @@v1@@ = ( FILE * ) fopen_safer ( @@v0@@ , String ) ; output_stream = @@v1@@ ; @@v2@@ = * __errno_location ( ) ; files_created += @@v1@@ != Number L ; sigprocmask ( Number , & @@_0@@ , Number L ) ; if ( ! @@v1@@ ) { error ( Number , @@v2@@ , String , output_filename ) ; cleanup_fatal ( ) ; } @@result@@ = __readfsqword ( Number ) ^ @@vars88@@ ; * ( _QWORD * ) & bytes_written = Number L ; return @@result@@ ; }
__int64 __fastcall build_equiv_class_isra_29 ( __int64 @@a1@@ , const char * @@a2@@ ) { if ( strlen ( @@a2@@ ) != Number ) return Number L ; * ( _QWORD * ) ( @@a1@@ + ( ( ( unsigned __int64 ) * ( unsigned __int8 * ) @@a2@@ >> Number ) & Number ) ) |= Number L << ( * @@a2@@ & Number ) ; return Number L ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
__int64 __fastcall print_group ( __gid_t @@gid@@ , unsigned int @@a2@@ ) { unsigned int @@v2@@ ; char * @@v3@@ ; @@v2@@ = Number ; if ( ( _BYTE ) @@a2@@ ) { @@v2@@ = @@a2@@ ; if ( ! getgrgid ( @@gid@@ ) ) { @@v2@@ = Number ; @@v3@@ = dcgettext ( Number L , String , Number ) ; error ( Number , Number , @@v3@@ , @@gid@@ ) ; } } __printf_chk ( ) ; return @@v2@@ ; }
char * __fastcall rpl_re_compile_pattern ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v3@@ ; int @@v4@@ ; char * @@result@@ ; @@v3@@ = rpl_re_syntax_options ; * ( _BYTE * ) ( @@a3@@ + Number ) = ( Number * ( ( rpl_re_syntax_options & Number ) != Number ) ) | * ( _BYTE * ) ( @@a3@@ + Number ) & Number | Number ; @@v4@@ = re_compile_internal ( @@a3@@ , @@a1@@ , @@a2@@ , @@v3@@ ) ; if ( @@v4@@ ) @@result@@ = dcgettext ( Number L , & _re_error_msgid [ _re_error_msgid_idx [ @@v4@@ ] ] , Number ) ; else @@result@@ = Number L ; return @@result@@ ; }
__int64 __fastcall remove_line ( void * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; _QWORD * @@v3@@ ; unsigned __int64 @@v4@@ ; _QWORD * @@v5@@ ; __int64 @@v6@@ ; __int64 @@result@@ ; _QWORD * @@v8@@ ; @@v2@@ = prev_buf_6633 ; if ( prev_buf_6633 ) { @@a1@@ = * ( void * * ) ( prev_buf_6633 + Number ) ; free ( @@a1@@ ) ; * ( _QWORD * ) ( @@v2@@ + Number ) = Number L ; prev_buf_6633 = Number L ; } @@v3@@ = ( _QWORD * ) head ; if ( ! head ) { if ( have_read_eof || ! ( unsigned __int8 ) load_buffer_part_5 ( ( __int64 ) @@a1@@ , @@a2@@ , head ) ) return Number L ; @@v3@@ = ( _QWORD * ) head ; } @@v4@@ = @@v3@@ [ Number ] ; if ( @@v4@@ > current_line ) current_line = @@v3@@ [ Number ] ; @@v5@@ = ( _QWORD * ) @@v3@@ [ Number ] ; @@v3@@ [ Number ] = @@v4@@ + Number ; @@v6@@ = @@v5@@ [ Number ] + Number L ; @@v5@@ [ Number ] = @@v6@@ ; @@result@@ = ( __int64 ) & @@v5@@ [ Number * @@v6@@ + Number ] ; if ( * @@v5@@ == @@v6@@ ) { @@v8@@ = ( _QWORD * ) @@v5@@ [ Number ] ; @@v3@@ [ Number ] = @@v8@@ ; if ( ! @@v8@@ || ! * @@v8@@ ) { prev_buf_6633 = ( __int64 ) @@v3@@ ; head = @@v3@@ [ Number ] ; } } return @@result@@ ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
size_t __fastcall rpl_regerror ( unsigned int @@a1@@ , __int64 a2 , char * @@a3@@ , size_t @@a4@@ ) { char * @@v6@@ ; size_t @@v7@@ ; size_t @@v8@@ ; size_t @@v9@@ ; if ( @@a1@@ > Number ) abort ( ) ; @@v6@@ = dcgettext ( Number L , & _re_error_msgid [ _re_error_msgid_idx [ @@a1@@ ] ] , Number ) ; @@v7@@ = strlen ( @@v6@@ ) ; @@v8@@ = @@v7@@ + Number ; if ( @@a4@@ ) { @@v9@@ = @@v7@@ + Number ; if ( @@v8@@ > @@a4@@ ) { @@v9@@ = @@a4@@ - Number ; @@a3@@ [ @@a4@@ - Number ] = Number ; } memcpy ( @@a3@@ , @@v6@@ , @@v9@@ ) ; } return @@v8@@ ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
int iswlower ( wint_t @@wc@@ ) { return iswlower ( @@wc@@ ) ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
void __fastcall rpl_regfree ( __int64 @@a1@@ ) { void * @@v2@@ ; void * @@v3@@ ; void * @@v4@@ ; @@v2@@ = * ( void * * ) @@a1@@ ; if ( @@v2@@ ) free_dfa_content ( @@v2@@ ) ; @@v3@@ = * ( void * * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) @@a1@@ = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; free ( @@v3@@ ) ; @@v4@@ = * ( void * * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; free ( @@v4@@ ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
int iswalnum ( wint_t @@wc@@ ) { return iswalnum ( @@wc@@ ) ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
__int64 __fastcall rpl_re_match_2 ( __int64 @@a1@@ , const void * @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ , unsigned __int64 @@a6@@ , unsigned __int64 * @@a7@@ , __int64 @@a8@@ ) { return re_search_2_stub ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ , Number L , @@a7@@ , @@a8@@ , Number ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@result@@ ; __int64 @@v3@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; } return @@result@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; _BYTE * @@v16@@ ; unsigned __int64 @@v19@@ ; int @@v20@@ ; int @@v21@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v20@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v21@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v19@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v21@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v19@@ <= @@v13@@ ) { @@v15@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v16@@ = ( _BYTE * ) xmalloc ( @@v15@@ , @@v15@@ , @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v16@@ ; @@v12@@ = @@v16@@ ; quotearg_buffer_restyled ( @@v16@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v21@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v20@@ ; return @@v12@@ ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_2071F0 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2071D0 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2071E0 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
wctype_t wctype ( const char * @@property@@ ) { return wctype ( @@property@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@result@@ ; size_t @@v2@@ ; @@result@@ = strlen ( @@a1@@ ) ; if ( @@result@@ > Number ) { @@v2@@ = @@result@@ - Number ; if ( @@a1@@ [ @@result@@ - Number ] == Number ) { while ( @@v2@@ != Number ) { if ( @@a1@@ [ @@v2@@ - Number ] != Number ) return @@v2@@ ; -- @@v2@@ ; } @@result@@ = Number L ; } } return @@result@@ ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
char * nl_langinfo ( nl_item @@item@@ ) { return nl_langinfo ( @@item@@ ) ; }
__int64 __fastcall mkstemp_safer ( char * @@a1@@ ) { int @@v1@@ ; @@v1@@ = mkstemp ( @@a1@@ ) ; return fd_safer ( @@v1@@ ) ; }
wint_t towlower ( wint_t @@wc@@ ) { return towlower ( @@wc@@ ) ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; __int64 @@v8@@ ; int @@v10@@ ; _BYTE * @@v11@@ ; __int64 @@v12@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = * @@v6@@ ; @@v12@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v11@@ = ( _BYTE * ) xmalloc ( @@v12@@ + Number , @@v12@@ + Number , @@v8@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v12@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v10@@ ; if ( @@a3@@ ) * @@a3@@ = @@v12@@ ; return @@v11@@ ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; FILE * @@v11@@ ; char * @@v12@@ ; char * @@v13@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String String String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String String String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = stdout ; @@v10@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v11@@ = stdout ; @@v12@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v12@@ , @@v11@@ ) ; @@v13@@ = setlocale ( Number , Number L ) ; if ( @@v13@@ ) { if ( strncmp ( @@v13@@ , String , Number ) ) { last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_21A330 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_21A310 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_21A320 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
wint_t towupper ( wint_t @@wc@@ ) { return towupper ( @@wc@@ ) ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall peek_token_bracket ( _BYTE * @@a1@@ , __int64 @@a2@@ , char @@a3@@ ) { unsigned __int64 @@v3@@ ; __int64 @@v4@@ ; bool @@v5@@ ; char @@v6@@ ; __int64 @@result@@ ; char @@v8@@ ; char @@v9@@ ; @@v3@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) <= @@v3@@ ) { @@a1@@ [ Number ] = Number ; return Number L ; } @@v4@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@v5@@ = * ( _DWORD * ) ( @@a2@@ + Number ) <= Number ; @@v6@@ = * ( _BYTE * ) ( @@v4@@ + @@v3@@ ) ; * @@a1@@ = @@v6@@ ; if ( ! @@v5@@ && @@v3@@ != * ( _QWORD * ) ( @@a2@@ + Number ) && * ( _DWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number * @@v3@@ ) == Number ) { goto LABEL_19 ; } switch ( @@v6@@ ) { case String : if ( ( @@a3@@ & Number ) == Number || @@v3@@ + Number >= * ( _QWORD * ) ( @@a2@@ + Number ) ) { LABEL_19 : @@a1@@ [ Number ] = Number ; return Number L ; } * ( _QWORD * ) ( @@a2@@ + Number ) = @@v3@@ + Number ; @@v9@@ = * ( _BYTE * ) ( @@v4@@ + @@v3@@ + Number ) ; @@a1@@ [ Number ] = Number ; * @@a1@@ = @@v9@@ ; @@result@@ = Number L ; break ; case String : if ( @@v3@@ + Number < * ( _QWORD * ) ( @@a2@@ + Number ) ) { @@v8@@ = * ( _BYTE * ) ( @@v4@@ + @@v3@@ + Number ) ; * @@a1@@ = @@v8@@ ; switch ( @@v8@@ ) { case String : if ( ( @@a3@@ & Number ) != Number ) { @@a1@@ [ Number ] = Number ; return Number L ; } break ; case String : @@a1@@ [ Number ] = Number ; return Number L ; case String : @@a1@@ [ Number ] = Number ; return Number L ; } } @@a1@@ [ Number ] = Number ; * @@a1@@ = Number ; return Number L ; case String : @@a1@@ [ Number ] = Number ; @@result@@ = Number L ; break ; case String : @@a1@@ [ Number ] = Number ; @@result@@ = Number L ; break ; case String : @@a1@@ [ Number ] = Number ; return Number L ; default : goto LABEL_19 ; } return @@result@@ ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quotearg_n_style ( Number L , Number L , @@a1@@ ) ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
_BYTE * __fastcall quotearg_char_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { _DWORD * @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = qword_2193B0 ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v3@@ = ( _DWORD * ) @@v5@@ + ( @@a3@@ >> Number ) + Number ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_219390 ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_2193A0 ) ; * @@v3@@ ^= ( ( ( * @@v3@@ >> ( @@a3@@ & Number ) ) & Number ) == Number ) << ( @@a3@@ & Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v5@@ ) ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_2193B0 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_219390 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_2193A0 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
void __fastcall build_upper_buffer ( _QWORD * @@a1@@ ) { unsigned __int64 @@v1@@ ; unsigned __int64 @@v2@@ ; const unsigned __int16 * * @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; char @@v6@@ ; _BYTE * @@v7@@ ; @@v1@@ = @@a1@@ [ Number ] ; if ( @@a1@@ [ Number ] <= @@v1@@ ) @@v1@@ = @@a1@@ [ Number ] ; @@v2@@ = @@a1@@ [ Number ] ; if ( @@v1@@ > @@v2@@ ) { @@v3@@ = __ctype_b_loc ( ) ; do { while ( Number ) { @@v4@@ = @@a1@@ [ Number ] ; @@v5@@ = * ( unsigned __int8 * ) ( @@a1@@ [ Number ] + @@v2@@ + * @@a1@@ ) ; @@v6@@ = * ( _BYTE * ) ( @@a1@@ [ Number ] + @@v2@@ + * @@a1@@ ) ; if ( @@v4@@ ) { @@v5@@ = * ( unsigned __int8 * ) ( @@v4@@ + @@v5@@ ) ; @@v6@@ = @@v5@@ ; } @@v7@@ = ( _BYTE * ) ( @@v2@@ + @@a1@@ [ Number ] ) ; if ( ( ( * @@v3@@ ) [ @@v5@@ ] & Number ) == Number ) break ; ++ @@v2@@ ; * @@v7@@ = ( * __ctype_toupper_loc ( ) ) [ @@v5@@ ] ; if ( @@v1@@ == @@v2@@ ) goto LABEL_10 ; } ++ @@v2@@ ; * @@v7@@ = @@v6@@ ; } while ( @@v1@@ != @@v2@@ ) ; } LABEL_10 : @@a1@@ [ Number ] = @@v2@@ ; @@a1@@ [ Number ] = @@v2@@ ; }
__int64 __fastcall postorder ( _QWORD * @@a1@@ , __int64 ( __fastcall * @@a2@@ ( ) ( void , bintreet0 ) ) ( __int64 , _QWORD * ) , __int64 @@a3@@ ) { _QWORD * @@v5@@ ; __int64 @@result@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; while ( Number ) { @@v5@@ = ( _QWORD * ) @@a1@@ [ Number ] ; if ( ! @@v5@@ ) { @@v5@@ = ( _QWORD * ) @@a1@@ [ Number ] ; if ( ! @@v5@@ ) break ; } LABEL_2 : @@a1@@ = @@v5@@ ; } for ( @@result@@ = @@a2@@ ( ) ( void , bintreet0 ) ( @@a3@@ , @@a1@@ ) ; ! ( _DWORD ) @@result@@ ; @@result@@ = @@a2@@ ( ) ( void , bintreet0 ) ( @@a3@@ , @@v7@@ ) ) { @@v7@@ = ( _QWORD * ) * @@a1@@ ; if ( ! * @@a1@@ ) break ; @@v5@@ = ( _QWORD * ) @@v7@@ [ Number ] ; @@v8@@ = @@v5@@ == @@a1@@ ; @@a1@@ = ( _QWORD * ) * @@a1@@ ; if ( @@v5@@ != Number L && ! @@v8@@ ) goto LABEL_2 ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __m128i * @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 * @@v10@@ ; _BYTE * @@v11@@ ; unsigned __int64 @@v12@@ ; __int64 @@v13@@ ; __int64 @@v14@@ ; __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; _BYTE * @@v17@@ ; unsigned __int64 @@v20@@ ; int @@v21@@ ; int @@v22@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v21@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L ) ; slotvec = @@v7@@ ; @@v9@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v8@@ = ( __m128i * ) xrealloc ( slotvec ) ; @@v9@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v8@@ ; slotvec = @@v8@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v9@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v10@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v11@@ = ( _BYTE * ) @@v10@@ [ Number ] ; @@v22@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v20@@ = * @@v10@@ ; @@v12@@ = quotearg_buffer_restyled ( @@v11@@ , * @@v10@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v22@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v20@@ <= @@v12@@ ) { @@v16@@ = @@v12@@ + Number ; * @@v10@@ = @@v12@@ + Number ; if ( @@v11@@ != ( _BYTE * ) & slot0 ) free ( @@v11@@ ) ; @@v17@@ = ( _BYTE * ) xmalloc ( @@v16@@ , @@v16@@ , @@v13@@ , @@v14@@ , @@v15@@ ) ; @@v10@@ [ Number ] = ( unsigned __int64 ) @@v17@@ ; @@v11@@ = @@v17@@ ; quotearg_buffer_restyled ( @@v17@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v22@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v21@@ ; return @@v11@@ ; }
__int64 __fastcall mark_opt_subexp ( __int64 @@a1@@ , __int64 @@a2@@ ) { if ( * ( _BYTE * ) ( @@a2@@ + Number ) != Number || @@a1@@ != * ( _QWORD * ) ( @@a2@@ + Number ) ) { return Number L ; } * ( _BYTE * ) ( @@a2@@ + Number ) |= Number ; return Number L ; }
void __fastcall free_token ( __int64 @@a1@@ ) { int @@v1@@ ; @@v1@@ = * ( _DWORD * ) ( @@a1@@ + Number ) & Number ; if ( @@v1@@ == Number ) { free_charset ( * ( void * * ) @@a1@@ ) ; } else if ( @@v1@@ == Number ) { free ( * ( void * * ) @@a1@@ ) ; } }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
__int64 __fastcall register_state ( _QWORD * @@a1@@ , _QWORD * @@a2@@ , __int64 @@a3@@ ) { __int64 @@v4@@ ; void * @@v6@@ ; __int64 @@v7@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; _QWORD * @@v11@@ ; __int64 @@v12@@ ; @@v4@@ = @@a2@@ [ Number ] ; * @@a2@@ = @@a3@@ ; @@a2@@ [ Number ] = Number L ; @@a2@@ [ Number ] = @@v4@@ ; @@v6@@ = malloc ( Number * @@v4@@ ) ; @@a2@@ [ Number ] = @@v6@@ ; if ( ! @@v6@@ ) return Number L ; if ( @@v4@@ ) { @@v7@@ = Number L ; while ( ( * ( _BYTE * ) ( * @@a1@@ + Number L * * ( _QWORD * ) ( @@a2@@ [ Number ] + Number * @@v7@@ ) + Number ) & Number ) != Number || ( unsigned __int8 ) re_node_set_insert_last ( @@a2@@ + Number , * ( _QWORD * ) ( @@a2@@ [ Number ] + Number * @@v7@@ ) ) ) { if ( @@a2@@ [ Number ] <= ( unsigned __int64 ) ++ @@v7@@ ) goto LABEL_8 ; } return Number L ; } LABEL_8 : @@v9@@ = @@a1@@ [ Number ] + Number * ( @@a1@@ [ Number ] & @@a3@@ ) ; @@v10@@ = * ( _QWORD * ) @@v9@@ ; @@v11@@ = * ( _QWORD * * ) ( @@v9@@ + Number ) ; @@v12@@ = * ( _QWORD * ) @@v9@@ + Number L ; if ( * ( _QWORD * ) ( @@v9@@ + Number ) <= * ( _QWORD * ) @@v9@@ ) { @@v11@@ = realloc ( * ( void * * ) ( @@v9@@ + Number ) , Number * @@v12@@ ) ; if ( @@v11@@ ) { @@v10@@ = * ( _QWORD * ) @@v9@@ ; * ( _QWORD * ) ( @@v9@@ + Number ) = @@v11@@ ; * ( _QWORD * ) ( @@v9@@ + Number ) = Number * @@v12@@ ; @@v12@@ = @@v10@@ + Number ; goto LABEL_9 ; } return Number L ; } LABEL_9 : * ( _QWORD * ) @@v9@@ = @@v12@@ ; @@v11@@ [ @@v10@@ ] = @@a2@@ ; return Number L ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
__int64 __fastcall re_string_realloc_buffers ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { void * @@v3@@ ; void * @@v4@@ ; void * @@v5@@ ; void * @@v7@@ ; if ( * ( int * ) ( @@a1@@ + Number ) > Number ) { if ( ! is_mul_ok ( @@a2@@ , Number ) ) return Number L ; @@v3@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number * @@a2@@ ) ; if ( ! @@v3@@ ) return Number L ; @@v4@@ = * ( void * * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v3@@ ; if ( @@v4@@ ) { @@v5@@ = realloc ( @@v4@@ , Number * @@a2@@ ) ; if ( ! @@v5@@ ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v5@@ ; } } if ( ! * ( _BYTE * ) ( @@a1@@ + Number ) ) { LABEL_8 : * ( _QWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; return Number L ; } @@v7@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , @@a2@@ ) ; if ( @@v7@@ ) { * ( _QWORD * ) ( @@a1@@ + Number ) = @@v7@@ ; goto LABEL_8 ; } return Number L ; }
unsigned __int64 __fastcall re_node_set_contains_isra_3 ( __int64 @@a1@@ , __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@result@@ ; __int64 @@v5@@ ; unsigned __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; unsigned __int64 @@v8@@ ; @@v3@@ = @@a1@@ - Number ; @@result@@ = Number L ; if ( @@v3@@ <= Number ) { @@v5@@ = * @@a2@@ ; @@v6@@ = Number L ; while ( @@v6@@ < @@v3@@ ) { @@v7@@ = ( @@v6@@ + @@v3@@ ) >> Number ; if ( @@a3@@ <= * ( _QWORD * ) ( @@v5@@ + Number * @@v7@@ ) ) { while ( @@v6@@ < @@v7@@ ) { @@v8@@ = ( @@v6@@ + @@v7@@ ) >> Number ; if ( * ( _QWORD * ) ( @@v5@@ + Number * @@v8@@ ) < @@a3@@ ) goto LABEL_11 ; @@v7@@ = ( @@v6@@ + @@v7@@ ) >> Number ; } break ; } @@v8@@ = ( @@v6@@ + @@v3@@ ) >> Number ; @@v7@@ = @@v3@@ ; LABEL_11 : @@v6@@ = @@v8@@ + Number ; @@v3@@ = @@v7@@ ; } @@result@@ = Number L ; if ( @@a3@@ == * ( _QWORD * ) ( @@v5@@ + Number * @@v6@@ ) ) @@result@@ = @@v6@@ + Number ; } return @@result@@ ; }
void __fastcall free_charset ( void * @@ptr@@ ) { free ( * ( void * * ) @@ptr@@ ) ; free ( * ( ( void * * ) @@ptr@@ + Number ) ) ; free ( @@ptr@@ ) ; }
void __fastcall build_upper_buffer ( _QWORD * @@a1@@ ) { unsigned __int64 @@v1@@ ; unsigned __int64 @@v2@@ ; const unsigned __int16 * * @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; char @@v6@@ ; _BYTE * @@v7@@ ; @@v1@@ = @@a1@@ [ Number ] ; if ( @@a1@@ [ Number ] <= @@v1@@ ) @@v1@@ = @@a1@@ [ Number ] ; @@v2@@ = @@a1@@ [ Number ] ; if ( @@v1@@ > @@v2@@ ) { @@v3@@ = __ctype_b_loc ( ) ; do { while ( Number ) { @@v4@@ = @@a1@@ [ Number ] ; @@v5@@ = * ( unsigned __int8 * ) ( @@a1@@ [ Number ] + @@v2@@ + * @@a1@@ ) ; @@v6@@ = * ( _BYTE * ) ( @@a1@@ [ Number ] + @@v2@@ + * @@a1@@ ) ; if ( @@v4@@ ) { @@v5@@ = * ( unsigned __int8 * ) ( @@v4@@ + @@v5@@ ) ; @@v6@@ = @@v5@@ ; } @@v7@@ = ( _BYTE * ) ( @@v2@@ + @@a1@@ [ Number ] ) ; if ( ( ( * @@v3@@ ) [ @@v5@@ ] & Number ) == Number ) break ; ++ @@v2@@ ; * @@v7@@ = ( * __ctype_toupper_loc ( ) ) [ @@v5@@ ] ; if ( @@v1@@ == @@v2@@ ) goto LABEL_10 ; } ++ @@v2@@ ; * @@v7@@ = @@v6@@ ; } while ( @@v1@@ != @@v2@@ ) ; } LABEL_10 : @@a1@@ [ Number ] = @@v2@@ ; @@a1@@ [ Number ] = @@v2@@ ; }
__int64 __fastcall peek_token_bracket ( _BYTE * @@a1@@ , __int64 @@a2@@ , char @@a3@@ ) { unsigned __int64 @@v3@@ ; __int64 @@v4@@ ; bool @@v5@@ ; char @@v6@@ ; __int64 @@result@@ ; char @@v8@@ ; char @@v9@@ ; @@v3@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) <= @@v3@@ ) { @@a1@@ [ Number ] = Number ; return Number L ; } @@v4@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@v5@@ = * ( _DWORD * ) ( @@a2@@ + Number ) <= Number ; @@v6@@ = * ( _BYTE * ) ( @@v4@@ + @@v3@@ ) ; * @@a1@@ = @@v6@@ ; if ( ! @@v5@@ && @@v3@@ != * ( _QWORD * ) ( @@a2@@ + Number ) && * ( _DWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number * @@v3@@ ) == Number ) { goto LABEL_19 ; } switch ( @@v6@@ ) { case String : if ( ( @@a3@@ & Number ) == Number || @@v3@@ + Number >= * ( _QWORD * ) ( @@a2@@ + Number ) ) { LABEL_19 : @@a1@@ [ Number ] = Number ; return Number L ; } * ( _QWORD * ) ( @@a2@@ + Number ) = @@v3@@ + Number ; @@v9@@ = * ( _BYTE * ) ( @@v4@@ + @@v3@@ + Number ) ; @@a1@@ [ Number ] = Number ; * @@a1@@ = @@v9@@ ; @@result@@ = Number L ; break ; case String : if ( @@v3@@ + Number < * ( _QWORD * ) ( @@a2@@ + Number ) ) { @@v8@@ = * ( _BYTE * ) ( @@v4@@ + @@v3@@ + Number ) ; * @@a1@@ = @@v8@@ ; switch ( @@v8@@ ) { case String : if ( ( @@a3@@ & Number ) != Number ) { @@a1@@ [ Number ] = Number ; return Number L ; } break ; case String : @@a1@@ [ Number ] = Number ; return Number L ; case String : @@a1@@ [ Number ] = Number ; return Number L ; } } @@a1@@ [ Number ] = Number ; * @@a1@@ = Number ; return Number L ; case String : @@a1@@ [ Number ] = Number ; @@result@@ = Number L ; break ; case String : @@a1@@ [ Number ] = Number ; @@result@@ = Number L ; break ; case String : @@a1@@ [ Number ] = Number ; return Number L ; default : goto LABEL_19 ; } return @@result@@ ; }
void __fastcall free_token ( __int64 @@a1@@ ) { int @@v1@@ ; @@v1@@ = * ( _DWORD * ) ( @@a1@@ + Number ) & Number ; if ( @@v1@@ == Number ) { free_charset ( * ( void * * ) @@a1@@ ) ; } else if ( @@v1@@ == Number ) { free ( * ( void * * ) @@a1@@ ) ; } }
__int64 __fastcall calc_first ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { __int64 @@v2@@ ; __int64 @@result@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; if ( * ( ( _BYTE * ) @@a2@@ + Number ) == Number ) { @@v4@@ = @@a2@@ [ Number ] ; @@v5@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; @@v6@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; @@a2@@ [ Number ] = @@v5@@ ; @@a2@@ [ Number ] = @@v6@@ ; @@result@@ = Number L ; } else { @@a2@@ [ Number ] = @@a2@@ ; @@v2@@ = re_dfa_add_node ( ( __int64 ) @@a1@@ , @@a2@@ [ Number ] , @@a2@@ [ Number ] ) ; @@a2@@ [ Number ] = @@v2@@ ; if ( @@v2@@ == Number ) { @@result@@ = Number L ; } else { @@result@@ = Number L ; if ( * ( ( _BYTE * ) @@a2@@ + Number ) == Number ) * ( _DWORD * ) ( * @@a1@@ + Number * @@v2@@ + Number ) = ( ( @@a2@@ [ Number ] & Number ) << Number ) | * ( _DWORD * ) ( * @@a1@@ + Number * @@v2@@ + Number ) & Number ; } } return @@result@@ ; }
__int64 __fastcall free_tree ( __int64 a1 , __int64 @@a2@@ ) { free_token ( @@a2@@ + Number ) ; return Number L ; }
__int64 __fastcall re_node_set_compare_part_2 ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; __int64 @@result@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@result@@ = Number L ; if ( @@v2@@ == * ( _QWORD * ) ( @@a2@@ + Number ) ) { @@v4@@ = Number * @@v2@@ - Number ; do { if ( ( unsigned __int64 ) -- @@v2@@ > Number ) return Number L ; @@v5@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@v4@@ ) ; @@v6@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + @@v4@@ ) ; @@v4@@ -= Number L ; } while ( @@v5@@ == @@v6@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
void __fastcall re_string_destruct ( __int64 @@a1@@ ) { free ( * ( void * * ) ( @@a1@@ + Number ) ) ; free ( * ( void * * ) ( @@a1@@ + Number ) ) ; if ( * ( _BYTE * ) ( @@a1@@ + Number ) ) free ( * ( void * * ) ( @@a1@@ + Number ) ) ; }
__int64 __fastcall re_node_set_init_copy_isra_19 ( _QWORD * @@a1@@ , __int64 * @@a2@@ , const void * * @@a3@@ ) { __int64 @@v3@@ ; __int64 @@v4@@ ; void * @@v6@@ ; __int64 @@result@@ ; @@v3@@ = * @@a2@@ ; @@a1@@ [ Number ] = * @@a2@@ ; @@v4@@ = * @@a2@@ ; if ( * @@a2@@ ) { * @@a1@@ = @@v3@@ ; @@v6@@ = malloc ( Number * @@v3@@ ) ; @@a1@@ [ Number ] = @@v6@@ ; if ( @@v6@@ ) { memcpy ( @@v6@@ , * @@a3@@ , Number * @@v4@@ ) ; @@result@@ = Number L ; } else { @@a1@@ [ Number ] = Number L ; * @@a1@@ = Number L ; @@result@@ = Number L ; } } else { @@a1@@ [ Number ] = Number L ; @@result@@ = Number L ; * ( _OWORD * ) @@a1@@ = Number L ; } return @@result@@ ; }
_QWORD * __fastcall re_node_set_insert ( _QWORD * @@a1@@ , unsigned __int64 @@a2@@ ) { __int64 @@v3@@ ; unsigned __int64 * @@v4@@ ; _QWORD * @@result@@ ; unsigned __int64 * @@v6@@ ; unsigned __int64 @@v7@@ ; unsigned __int64 @@i@@ ; bool @@v9@@ ; if ( * @@a1@@ ) { @@v3@@ = @@a1@@ [ Number ] ; @@v4@@ = ( unsigned __int64 * ) @@a1@@ [ Number ] ; if ( ! @@v3@@ ) { * @@v4@@ = @@a2@@ ; ++ @@a1@@ [ Number ] ; return ( _QWORD * ) ( & dword_0 + Number ) ; } if ( * @@a1@@ != @@v3@@ ) { if ( @@a2@@ < * @@v4@@ ) goto LABEL_8 ; goto LABEL_12 ; } * @@a1@@ = Number * @@v3@@ ; @@v4@@ = ( unsigned __int64 * ) realloc ( @@v4@@ , Number * @@v3@@ ) ; if ( @@v4@@ ) { @@v9@@ = * @@v4@@ <= @@a2@@ ; @@a1@@ [ Number ] = @@v4@@ ; @@v3@@ = @@a1@@ [ Number ] ; if ( ! @@v9@@ ) { if ( ! @@v3@@ ) { LABEL_11 : * ( unsigned __int64 * ) ( ( char * ) @@v4@@ + @@v3@@ ) = @@a2@@ ; @@result@@ = ( _QWORD * ) ( & dword_0 + Number ) ; ++ @@a1@@ [ Number ] ; return @@result@@ ; } LABEL_8 : @@v6@@ = & @@v4@@ [ @@v3@@ ] ; do { @@v7@@ = * -- @@v6@@ ; @@v6@@ [ Number ] = @@v7@@ ; } while ( @@v6@@ != @@v4@@ ) ; @@v3@@ = Number L ; goto LABEL_11 ; } LABEL_12 : @@v3@@ *= Number L ; for ( @@i@@ = * ( unsigned __int64 * ) ( ( char * ) @@v4@@ + @@v3@@ - Number ) ; @@i@@ > @@a2@@ ; @@i@@ = * ( unsigned __int64 * ) ( ( char * ) @@v4@@ + @@v3@@ - Number ) ) { * ( unsigned __int64 * ) ( ( char * ) @@v4@@ + @@v3@@ ) = @@i@@ ; @@v3@@ -= Number L ; } goto LABEL_11 ; } @@result@@ = Number L ; } else { * @@a1@@ = Number L ; @@a1@@ [ Number ] = Number L ; @@result@@ = malloc ( Number ) ; @@a1@@ [ Number ] = @@result@@ ; if ( @@result@@ ) { * @@result@@ = @@a2@@ ; @@result@@ = ( _QWORD * ) ( & dword_0 + Number ) ; } else { @@a1@@ [ Number ] = Number L ; * @@a1@@ = Number L ; } } return @@result@@ ; }
__int64 __fastcall optimize_subexps ( __int64 @@a1@@ , __int64 @@a2@@ ) { char @@v2@@ ; __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; _QWORD * @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; @@v2@@ = * ( _BYTE * ) ( @@a2@@ + Number ) ; if ( @@v2@@ != Number ) { if ( @@v2@@ == Number ) { @@v4@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( @@v4@@ ) { if ( * ( _BYTE * ) ( @@v4@@ + Number ) == Number ) { @@v5@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; @@v6@@ = * ( _QWORD * * ) ( @@v4@@ + Number ) ; * ( _QWORD * ) ( @@a2@@ + Number ) = @@v6@@ ; if ( @@v6@@ ) * @@v6@@ = @@a2@@ ; * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@v5@@ ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L * * ( _QWORD * ) ( @@a2@@ + Number ) ) ; if ( @@v5@@ <= Number ) * ( _QWORD * ) ( @@a1@@ + Number ) &= __ROL8__ ( Number , @@v5@@ ) ; } } } return Number L ; } @@v7@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( ! @@v7@@ ) return Number L ; @@v8@@ = * ( _QWORD * ) ( @@v7@@ + Number L * * ( int * ) ( @@a2@@ + Number ) ) ; * ( _QWORD * ) ( @@a2@@ + Number ) = @@v8@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) |= Number << @@v8@@ ; return Number L ; }
unsigned __int64 __fastcall re_node_set_contains_isra_3 ( __int64 @@a1@@ , __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@result@@ ; __int64 @@v5@@ ; unsigned __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; unsigned __int64 @@v8@@ ; @@v3@@ = @@a1@@ - Number ; @@result@@ = Number L ; if ( @@v3@@ <= Number ) { @@v5@@ = * @@a2@@ ; @@v6@@ = Number L ; while ( @@v6@@ < @@v3@@ ) { @@v7@@ = ( @@v6@@ + @@v3@@ ) >> Number ; if ( @@a3@@ <= * ( _QWORD * ) ( @@v5@@ + Number * @@v7@@ ) ) { while ( @@v6@@ < @@v7@@ ) { @@v8@@ = ( @@v6@@ + @@v7@@ ) >> Number ; if ( * ( _QWORD * ) ( @@v5@@ + Number * @@v8@@ ) < @@a3@@ ) goto LABEL_11 ; @@v7@@ = ( @@v6@@ + @@v7@@ ) >> Number ; } break ; } @@v8@@ = ( @@v6@@ + @@v3@@ ) >> Number ; @@v7@@ = @@v3@@ ; LABEL_11 : @@v6@@ = @@v8@@ + Number ; @@v3@@ = @@v7@@ ; } @@result@@ = Number L ; if ( @@a3@@ == * ( _QWORD * ) ( @@v5@@ + Number * @@v6@@ ) ) @@result@@ = @@v6@@ + Number ; } return @@result@@ ; }
__int64 __fastcall re_string_context_at ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , char @@a3@@ ) { wint_t @@v3@@ ; __int64 @@result@@ ; unsigned __int64 @@v5@@ ; __int64 @@v6@@ ; if ( @@a2@@ > Number ) return * ( unsigned int * ) ( @@a1@@ + Number ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) == @@a2@@ ) return ( @@a3@@ & Number ) == Number ? Number : Number ; if ( * ( int * ) ( @@a1@@ + Number ) <= Number ) { @@v5@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ ) ; @@v6@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * ( @@v5@@ >> Number ) ) ; @@result@@ = Number L ; if ( _bittest64 ( & @@v6@@ , @@v5@@ ) ) return @@result@@ ; @@result@@ = Number L ; if ( ( _BYTE ) @@v5@@ != Number ) return @@result@@ ; return Number * ( unsigned int ) ( * ( _BYTE * ) ( @@a1@@ + Number ) != Number ) ; } while ( Number ) { @@v3@@ = * ( _DWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@a2@@ ) ; if ( @@v3@@ != Number ) break ; if ( -- @@a2@@ > Number ) return * ( unsigned int * ) ( @@a1@@ + Number ) ; } if ( * ( _BYTE * ) ( @@a1@@ + Number ) && ( iswalnum ( @@v3@@ ) || @@v3@@ == Number ) ) return Number L ; @@result@@ = Number L ; if ( @@v3@@ == Number ) return Number * ( unsigned int ) ( * ( _BYTE * ) ( @@a1@@ + Number ) != Number ) ; return @@result@@ ; }
__int64 __fastcall clean_state_log_if_needed ( _QWORD * @@a1@@ , unsigned __int64 @@a2@@ ) { unsigned __int64 @@v2@@ ; unsigned __int64 @@v3@@ ; __int64 @@result@@ ; @@v2@@ = @@a1@@ [ Number ] ; if ( @@a1@@ [ Number ] > @@a2@@ && ( ( @@v3@@ = @@a1@@ [ Number ] , @@v3@@ > @@a2@@ ) || @@v3@@ >= @@a1@@ [ Number ] ) || ( @@result@@ = extend_buffers ( ( __int64 ) @@a1@@ ) , ! ( _DWORD ) @@result@@ ) ) { if ( @@v2@@ < @@a2@@ ) { memset ( ( void * ) ( @@a1@@ [ Number ] + Number * @@v2@@ + Number ) , Number , Number * ( @@a2@@ - @@v2@@ ) ) ; @@a1@@ [ Number ] = @@a2@@ ; } @@result@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall lower_subexps ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; char * @@v5@@ ; char * @@v6@@ ; unsigned int @@v7@@ ; unsigned __int64 @@v8@@ ; @@v2@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@v8@@ = __readfsqword ( Number ) ; @@v7@@ = Number ; if ( @@v2@@ ) { if ( * ( _BYTE * ) ( @@v2@@ + Number ) == Number ) { @@v6@@ = lower_subexp ( & @@v7@@ , @@a1@@ , @@v2@@ ) ; * ( _QWORD * ) ( @@a2@@ + Number ) = @@v6@@ ; if ( @@v6@@ ) * ( _QWORD * ) @@v6@@ = @@a2@@ ; } } @@v3@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( @@v3@@ ) { if ( * ( _BYTE * ) ( @@v3@@ + Number ) == Number ) { @@v5@@ = lower_subexp ( & @@v7@@ , @@a1@@ , @@v3@@ ) ; * ( _QWORD * ) ( @@a2@@ + Number ) = @@v5@@ ; if ( @@v5@@ ) * ( _QWORD * ) @@v5@@ = @@a2@@ ; } } return @@v7@@ ; }
__int64 __fastcall calc_next ( __int64 a1 , __int64 @@a2@@ ) { char @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@result@@ ; __int64 @@v6@@ ; @@v2@@ = * ( _BYTE * ) ( @@a2@@ + Number ) ; @@v3@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( @@v2@@ == Number ) { * ( _QWORD * ) ( @@v3@@ + Number ) = @@a2@@ ; @@result@@ = Number L ; } else if ( @@v2@@ == Number ) { @@v6@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; * ( _QWORD * ) ( @@v3@@ + Number ) = * ( _QWORD * ) ( @@v6@@ + Number ) ; * ( _QWORD * ) ( @@v6@@ + Number ) = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@result@@ = Number L ; } else { if ( @@v3@@ ) * ( _QWORD * ) ( @@v3@@ + Number ) = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@v4@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( @@v4@@ ) * ( _QWORD * ) ( @@v4@@ + Number ) = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@result@@ = Number L ; } return @@result@@ ; }
void __fastcall free_fail_stack_return_part_28 ( __int64 @@a1@@ ) { __int64 @@v2@@ ; unsigned __int64 @@v3@@ ; void * @@v4@@ ; if ( * ( _QWORD * ) @@a1@@ ) { @@v2@@ = Number L ; @@v3@@ = Number L ; do { ++ @@v3@@ ; free ( * ( void * * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@v2@@ + Number ) ) ; @@v4@@ = * ( void * * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@v2@@ + Number ) ; @@v2@@ += Number L ; free ( @@v4@@ ) ; } while ( @@v3@@ < * ( _QWORD * ) @@a1@@ ) ; } free ( * ( void * * ) ( @@a1@@ + Number ) ) ; }
void __fastcall free_state ( void * @@ptr@@ ) { void * * @@v1@@ ; free ( * ( ( void * * ) @@ptr@@ + Number ) ) ; free ( * ( ( void * * ) @@ptr@@ + Number ) ) ; @@v1@@ = ( void * * ) * ( ( _QWORD * ) @@ptr@@ + Number ) ; if ( @@v1@@ != ( void * * ) ( ( char * ) @@ptr@@ + Number ) ) { free ( @@v1@@ [ Number ] ) ; free ( * ( ( void * * ) @@ptr@@ + Number ) ) ; } free ( * ( ( void * * ) @@ptr@@ + Number ) ) ; free ( * ( ( void * * ) @@ptr@@ + Number ) ) ; free ( * ( ( void * * ) @@ptr@@ + Number ) ) ; free ( @@ptr@@ ) ; }
__int64 __fastcall check_node_accept ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int8 @@v4@@ ; __int64 @@result@@ ; unsigned int @@v6@@ ; unsigned int @@v7@@ ; unsigned int @@v8@@ ; unsigned int @@v9@@ ; unsigned int @@v10@@ ; __int64 @@v11@@ ; @@v3@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@a3@@ ) ; @@v4@@ = * ( _BYTE * ) ( @@a2@@ + Number ) ; if ( @@v4@@ == Number ) { @@v11@@ = * ( _QWORD * ) ( * ( _QWORD * ) @@a2@@ + Number * ( ( unsigned __int64 ) ( unsigned __int8 ) @@v3@@ >> Number ) ) ; @@result@@ = Number L ; if ( ! _bittest64 ( & @@v11@@ , @@v3@@ ) ) return @@result@@ ; goto LABEL_9 ; } if ( @@v4@@ <= Number ) { if ( @@v4@@ == Number ) { @@result@@ = Number L ; if ( * ( _BYTE * ) @@a2@@ != ( _BYTE ) @@v3@@ ) return @@result@@ ; goto LABEL_9 ; } return Number L ; } if ( @@v4@@ == Number ) goto LABEL_6 ; if ( @@v4@@ != Number ) return Number L ; @@result@@ = Number L ; if ( ( @@v3@@ & Number ) != Number L ) return @@result@@ ; LABEL_6 : if ( ( _BYTE ) @@v3@@ == Number ) { @@result@@ = Number L ; if ( ( * ( _BYTE * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L ) & Number ) == Number ) return @@result@@ ; } else if ( ! ( _BYTE ) @@v3@@ ) { @@result@@ = Number L ; if ( * ( char * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L ) < Number ) return @@result@@ ; } LABEL_9 : @@v6@@ = * ( _DWORD * ) ( @@a2@@ + Number ) ; @@result@@ = Number L ; if ( ( @@v6@@ & Number ) == Number ) return @@result@@ ; @@v7@@ = @@v6@@ >> Number ; @@v8@@ = re_string_context_at ( @@a1@@ , @@a3@@ , * ( _DWORD * ) ( @@a1@@ + Number ) ) ; @@v9@@ = @@v8@@ ; if ( ( @@v7@@ & Number ) != Number ) { @@result@@ = Number L ; if ( ( @@v9@@ & Number ) == Number || ( @@v7@@ & Number ) != Number ) return @@result@@ ; } else if ( ( @@v7@@ & Number ) != Number && ( @@v8@@ & Number ) != Number ) { return Number L ; } if ( ( @@v7@@ & Number ) == Number || ( @@result@@ = Number L , ( @@v9@@ & Number ) != Number ) ) { @@result@@ = Number L ; @@v10@@ = ( @@v9@@ >> Number ) & Number ; if ( ( @@v7@@ & Number ) != Number ) @@result@@ = @@v10@@ ; } return @@result@@ ; }
char * __fastcall duplicate_tree ( _QWORD * * @@a1@@ , __int64 @@a2@@ ) { _QWORD * * @@v2@@ ; _QWORD * @@v3@@ ; __int64 * @@v4@@ ; char * @@result@@ ; _QWORD * * @@v6@@ ; _QWORD * @@v7@@ ; __int64 @@v8@@ [ Number ] ; @@v2@@ = @@a1@@ ; @@v3@@ = * @@a1@@ ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ = @@v8@@ ; while ( Number ) { @@result@@ = create_token_tree_isra_18 ( ( _QWORD * ) ( @@a2@@ + Number ) , ( int * ) ( @@a2@@ + Number ) , Number L , Number L , ( const __m128i * ) ( @@v2@@ + Number ) ) ; * @@v4@@ = ( __int64 ) @@result@@ ; if ( ! @@result@@ ) break ; * ( _QWORD * ) @@result@@ = @@v3@@ ; @@v3@@ = ( _QWORD * ) * @@v4@@ ; * ( _BYTE * ) ( * @@v4@@ + Number ) |= Number ; if ( @@v2@@ [ Number ] ) { @@v4@@ = @@v3@@ + Number ; @@v2@@ = ( _QWORD * * ) @@v2@@ [ Number ] ; } else { @@v6@@ = Number L ; while ( Number ) { @@v7@@ = @@v2@@ [ Number ] ; if ( @@v7@@ ) { if ( @@v7@@ != @@v6@@ ) break ; } @@v3@@ = ( _QWORD * ) * @@v3@@ ; @@v6@@ = @@v2@@ ; if ( ! * @@v2@@ ) return ( char * ) @@v8@@ [ Number ] ; @@v2@@ = ( _QWORD * * ) * @@v2@@ ; } @@v4@@ = @@v3@@ + Number ; @@v2@@ = ( _QWORD * * ) @@v2@@ [ Number ] ; } } return @@result@@ ; }
char * __fastcall parse_reg_exp ( __int64 * @@a1@@ , __int64 * @@a2@@ , __m128i * @@a3@@ , __int64 @@a4@@ , void * @@a5@@ , _DWORD * @@a6@@ ) { __int64 @@v9@@ ; char * @@v10@@ ; char * @@v11@@ ; char * @@v12@@ ; __m128i @@v15@@ ; unsigned __int64 @@v16@@ ; @@v9@@ = * @@a2@@ ; @@v16@@ = __readfsqword ( Number ) ; @@v10@@ = parse_branch ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; @@v11@@ = @@v10@@ ; if ( * @@a6@@ && ! @@v10@@ ) return Number L ; while ( @@a3@@ -> m128i_i8 [ Number ] == Number ) { @@a1@@ [ Number ] += ( int ) peek_token ( ( unsigned __int8 * ) @@a3@@ , @@a1@@ , @@a4@@ | Number ) ; if ( ( @@a3@@ -> m128i_i8 [ Number ] & Number ) == Number || @@a3@@ -> m128i_i8 [ Number ] == Number && @@a5@@ ) { @@v12@@ = Number L ; } else { @@v12@@ = parse_branch ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( * @@a6@@ && ! @@v12@@ ) return Number L ; } @@v15@@ . m128i_i8 [ Number ] = Number ; @@v11@@ = create_token_tree_isra_18 ( ( _QWORD * ) ( @@v9@@ + Number ) , ( int * ) ( @@v9@@ + Number ) , @@v11@@ , @@v12@@ , & @@v15@@ ) ; if ( ! @@v11@@ ) { * @@a6@@ = Number ; return @@v11@@ ; } } return @@v11@@ ; }
void __fastcall re_node_set_remove_at_isra_4_part_5 ( unsigned __int64 * @@a1@@ , __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { __int64 @@v3@@ ; if ( @@a3@@ < * @@a1@@ ) { @@v3@@ = * @@a2@@ ; do { ++ @@a3@@ ; * ( _QWORD * ) ( @@v3@@ + Number * @@a3@@ - Number ) = * ( _QWORD * ) ( @@v3@@ + Number * @@a3@@ ) ; } while ( @@a3@@ < * @@a1@@ ) ; } }
__int64 __fastcall fetch_number ( __int64 * @@a1@@ , unsigned __int8 * @@a2@@ , __int64 @@a3@@ ) { unsigned __int64 @@v4@@ ; unsigned __int8 @@v5@@ ; __int64 @@v6@@ ; @@v4@@ = Number ; while ( Number ) { @@a1@@ [ Number ] += ( int ) peek_token ( @@a2@@ , @@a1@@ , @@a3@@ ) ; @@v5@@ = @@a2@@ [ Number ] ; @@v6@@ = * @@a2@@ ; if ( @@v5@@ == Number ) break ; if ( ( _BYTE ) @@v6@@ == Number || @@v5@@ == Number ) return @@v4@@ ; if ( @@v5@@ != Number || ( unsigned __int8 ) ( @@v6@@ - Number ) > Number || @@v4@@ == Number ) { @@v4@@ = Number ; } else if ( @@v4@@ == Number ) { @@v4@@ = ( unsigned __int8 ) @@v6@@ - Number ; } else { @@v4@@ = @@v6@@ + Number * @@v4@@ - Number ; if ( @@v4@@ >= Number ) @@v4@@ = Number ; } } return Number ; }
__int64 __fastcall pop_fail_stack_isra_26 ( unsigned __int64 * @@a1@@ , _QWORD * @@a2@@ , _QWORD * @@a3@@ , __int64 @@a4@@ , void * @@a5@@ , __int64 @@a6@@ ) { unsigned __int64 @@v6@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; @@v6@@ = * @@a1@@ - Number ; * @@a1@@ = @@v6@@ ; if ( @@v6@@ > Number ) __assert_fail ( String , String , Number , String ) ; @@v8@@ = Number * @@v6@@ ; @@v9@@ = Number * @@v6@@ + * @@a2@@ ; * @@a3@@ = * ( _QWORD * ) @@v9@@ ; memcpy ( @@a5@@ , * ( const void * * ) ( @@v9@@ + Number ) , Number * @@a4@@ ) ; free ( * ( void * * ) ( @@a6@@ + Number ) ) ; free ( * ( void * * ) ( * @@a2@@ + @@v8@@ + Number ) ) ; @@v10@@ = * @@a2@@ + @@v8@@ ; * ( __m128i * ) @@a6@@ = _mm_loadu_si128 ( ( const __m128i * ) ( @@v10@@ + Number ) ) ; * ( _QWORD * ) ( @@a6@@ + Number ) = * ( _QWORD * ) ( @@v10@@ + Number ) ; return * ( _QWORD * ) ( @@v10@@ + Number ) ; }
__int64 __fastcall rpl_regexec ( __int64 @@a1@@ , const char * @@a2@@ , unsigned __int64 @@a3@@ , __int64 * @@a4@@ , int @@a5@@ ) { size_t @@v8@@ ; unsigned __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; int @@v11@@ ; if ( ( @@a5@@ & Number ) == Number ) { if ( ( @@a5@@ & Number ) != Number ) { @@v9@@ = * @@a4@@ ; @@v10@@ = @@a4@@ [ Number ] ; if ( ( * ( _BYTE * ) ( @@a1@@ + Number ) & Number ) != Number ) goto LABEL_4 ; } else { @@v8@@ = strlen ( @@a2@@ ) ; @@v9@@ = Number L ; @@v10@@ = @@v8@@ ; if ( ( * ( _BYTE * ) ( @@a1@@ + Number ) & Number ) != Number ) { LABEL_4 : @@v11@@ = re_search_internal ( @@a1@@ , ( __int64 ) @@a2@@ , @@v10@@ , @@v9@@ , @@v10@@ , @@v10@@ , Number L , Number L , @@a5@@ ) ; return @@v11@@ != Number ; } } @@v11@@ = re_search_internal ( @@a1@@ , ( __int64 ) @@a2@@ , @@v10@@ , @@v9@@ , @@v10@@ , @@v10@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; return @@v11@@ != Number ; } return Number L ; }
char * __fastcall parse_branch ( __int64 * @@a1@@ , __int64 * @@a2@@ , __m128i * @@a3@@ , __int64 @@a4@@ , void * @@a5@@ , _DWORD * @@a6@@ ) { __int64 @@v10@@ ; char * @@v11@@ ; char * @@v12@@ ; __int64 @@v14@@ ; __m128i @@v15@@ ; unsigned __int64 @@v16@@ ; @@v16@@ = __readfsqword ( Number ) ; @@v14@@ = * @@a2@@ ; @@v10@@ = parse_expression ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; @@v11@@ = ( char * ) @@v10@@ ; if ( * @@a6@@ && ! @@v10@@ ) return Number L ; while ( ( @@a3@@ -> m128i_i8 [ Number ] & Number ) != Number && ( @@a3@@ -> m128i_i8 [ Number ] != Number || ! @@a5@@ ) ) { @@v12@@ = ( char * ) parse_expression ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( * @@a6@@ && ! @@v12@@ ) return Number L ; if ( @@v11@@ && @@v12@@ ) { @@v15@@ . m128i_i8 [ Number ] = Number ; @@v11@@ = create_token_tree_isra_18 ( ( _QWORD * ) ( @@v14@@ + Number ) , ( int * ) ( @@v14@@ + Number ) , @@v11@@ , @@v12@@ , & @@v15@@ ) ; if ( ! @@v11@@ ) { * @@a6@@ = Number ; return @@v11@@ ; } } else if ( ! @@v11@@ ) { @@v11@@ = @@v12@@ ; } } return @@v11@@ ; }
__int64 __fastcall rpl_re_compile_fastmap ( __int64 @@a1@@ ) { __m128i * @@v1@@ ; _QWORD * @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; @@v1@@ = * ( __m128i * * ) ( @@a1@@ + Number ) ; @@v2@@ = * ( _QWORD * * ) @@a1@@ ; @@v1@@ -> m128i_i64 [ Number ] = Number L ; @@v1@@ [ Number ] . m128i_i64 [ Number ] = Number L ; memset ( ( void * ) ( ( unsigned __int64 ) & @@v1@@ -> m128i_u64 [ Number ] & Number ) , Number , Number L * ( ( ( unsigned int ) @@v1@@ - ( ( ( _DWORD ) @@v1@@ + Number ) & Number ) + Number ) >> Number ) ) ; re_compile_fastmap_iter_isra_32 ( ( __int64 * ) @@a1@@ , ( _QWORD * ) ( @@v2@@ [ Number ] + Number L ) , ( _QWORD * ) ( @@v2@@ [ Number ] + Number L ) , @@v1@@ ) ; @@v3@@ = @@v2@@ [ Number ] ; if ( @@v2@@ [ Number ] != @@v3@@ ) { re_compile_fastmap_iter_isra_32 ( ( __int64 * ) @@a1@@ , ( _QWORD * ) ( @@v3@@ + Number ) , ( _QWORD * ) ( @@v3@@ + Number ) , @@v1@@ ) ; @@v3@@ = @@v2@@ [ Number ] ; } @@v4@@ = @@v2@@ [ Number ] ; if ( @@v4@@ != @@v3@@ ) { re_compile_fastmap_iter_isra_32 ( ( __int64 * ) @@a1@@ , ( _QWORD * ) ( @@v4@@ + Number ) , ( _QWORD * ) ( @@v4@@ + Number ) , @@v1@@ ) ; @@v3@@ = @@v2@@ [ Number ] ; } @@v5@@ = @@v2@@ [ Number ] ; if ( @@v5@@ != @@v3@@ ) re_compile_fastmap_iter_isra_32 ( ( __int64 * ) @@a1@@ , ( _QWORD * ) ( @@v5@@ + Number ) , ( _QWORD * ) ( @@v5@@ + Number ) , @@v1@@ ) ; * ( _BYTE * ) ( @@a1@@ + Number ) |= Number ; return Number L ; }
__int64 __fastcall calc_first ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { __int64 @@v2@@ ; __int64 @@result@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; if ( * ( ( _BYTE * ) @@a2@@ + Number ) == Number ) { @@v4@@ = @@a2@@ [ Number ] ; @@v5@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; @@v6@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; @@a2@@ [ Number ] = @@v5@@ ; @@a2@@ [ Number ] = @@v6@@ ; @@result@@ = Number L ; } else { @@a2@@ [ Number ] = @@a2@@ ; @@v2@@ = re_dfa_add_node ( ( __int64 ) @@a1@@ , @@a2@@ [ Number ] , @@a2@@ [ Number ] ) ; @@a2@@ [ Number ] = @@v2@@ ; if ( @@v2@@ == Number ) { @@result@@ = Number L ; } else { @@result@@ = Number L ; if ( * ( ( _BYTE * ) @@a2@@ + Number ) == Number ) * ( _DWORD * ) ( * @@a1@@ + Number * @@v2@@ + Number ) = ( ( @@a2@@ [ Number ] & Number ) << Number ) | * ( _DWORD * ) ( * @@a1@@ + Number * @@v2@@ + Number ) & Number ; } } return @@result@@ ; }
ssize_t __fastcall safe_read ( int @@fd@@ , void * @@buf@@ , size_t @@nbytes@@ ) { ssize_t @@v4@@ ; int @@v5@@ ; while ( Number ) { @@v4@@ = read ( @@fd@@ , @@buf@@ , @@nbytes@@ ) ; if ( @@v4@@ >= Number ) break ; @@v5@@ = * __errno_location ( ) ; if ( @@v5@@ != Number ) { if ( @@nbytes@@ <= Number || @@v5@@ != Number ) return @@v4@@ ; @@nbytes@@ = Number L ; } } return @@v4@@ ; }
__int64 __fastcall re_search_2_stub ( __int64 @@a1@@ , const void * @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ , unsigned __int64 @@a6@@ , __int64 @@a7@@ , unsigned __int64 * @@a8@@ , __int64 @@a9@@ , char @@a10@@ ) { unsigned __int64 @@v10@@ ; unsigned __int64 @@v12@@ ; char * @@v13@@ ; __int64 @@v15@@ ; char * @@v17@@ ; const void * @@v18@@ ; @@v10@@ = @@a5@@ + @@a3@@ ; if ( __CFADD__ ( @@a5@@ , @@a3@@ ) ) return Number ; @@v12@@ = @@a6@@ ; if ( ! @@a5@@ ) { @@a4@@ = ( __int64 ) @@a2@@ ; @@v13@@ = Number L ; goto LABEL_4 ; } @@v13@@ = Number L ; if ( @@a3@@ ) { @@v17@@ = ( char * ) malloc ( @@a5@@ + @@a3@@ ) ; @@v13@@ = @@v17@@ ; if ( @@v17@@ ) { memcpy ( @@v17@@ , @@a2@@ , @@a3@@ ) ; @@v18@@ = ( const void * ) @@a4@@ ; @@a4@@ = ( __int64 ) @@v13@@ ; memcpy ( & @@v13@@ [ @@a3@@ ] , @@v18@@ , @@a5@@ ) ; @@v12@@ = @@a6@@ ; goto LABEL_4 ; } return Number ; } LABEL_4 : @@v15@@ = re_search_stub ( @@a1@@ , @@a4@@ , @@v10@@ , @@v12@@ , @@a7@@ , @@a9@@ , @@a8@@ , @@a10@@ ) ; free ( @@v13@@ ) ; return @@v15@@ ; }
__int64 __fastcall rpl_regexec ( __int64 @@a1@@ , const char * @@a2@@ , unsigned __int64 @@a3@@ , __int64 * @@a4@@ , int @@a5@@ ) { size_t @@v8@@ ; unsigned __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; int @@v11@@ ; if ( ( @@a5@@ & Number ) == Number ) { if ( ( @@a5@@ & Number ) != Number ) { @@v9@@ = * @@a4@@ ; @@v10@@ = @@a4@@ [ Number ] ; if ( ( * ( _BYTE * ) ( @@a1@@ + Number ) & Number ) != Number ) goto LABEL_4 ; } else { @@v8@@ = strlen ( @@a2@@ ) ; @@v9@@ = Number L ; @@v10@@ = @@v8@@ ; if ( ( * ( _BYTE * ) ( @@a1@@ + Number ) & Number ) != Number ) { LABEL_4 : @@v11@@ = re_search_internal ( @@a1@@ , ( __int64 ) @@a2@@ , @@v10@@ , @@v9@@ , @@v10@@ , @@v10@@ , Number L , Number L , @@a5@@ ) ; return @@v11@@ != Number ; } } @@v11@@ = re_search_internal ( @@a1@@ , ( __int64 ) @@a2@@ , @@v10@@ , @@v9@@ , @@v10@@ , @@v10@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; return @@v11@@ != Number ; } return Number L ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( @@a1@@ , @@a2@@ , Number ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
__int64 __fastcall re_node_set_init_copy_isra_19 ( _QWORD * @@a1@@ , __int64 * @@a2@@ , const void * * @@a3@@ ) { __int64 @@v3@@ ; __int64 @@v4@@ ; void * @@v6@@ ; __int64 @@result@@ ; @@v3@@ = * @@a2@@ ; @@a1@@ [ Number ] = * @@a2@@ ; @@v4@@ = * @@a2@@ ; if ( * @@a2@@ ) { * @@a1@@ = @@v3@@ ; @@v6@@ = malloc ( Number * @@v3@@ ) ; @@a1@@ [ Number ] = @@v6@@ ; if ( @@v6@@ ) { memcpy ( @@v6@@ , * @@a3@@ , Number * @@v4@@ ) ; @@result@@ = Number L ; } else { @@a1@@ [ Number ] = Number L ; * @@a1@@ = Number L ; @@result@@ = Number L ; } } else { @@a1@@ [ Number ] = Number L ; @@result@@ = Number L ; * ( _OWORD * ) @@a1@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall rpl_re_match ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ , unsigned __int64 @@a4@@ , unsigned __int64 * @@a5@@ ) { return re_search_stub ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , Number L , @@a3@@ , @@a5@@ , Number ) ; }
__int64 __fastcall rpl_fcntl ( int @@a1@@ , int @@a2@@ , __int64 @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { int @@v6@@ ; int @@v8@@ ; int @@v9@@ ; int @@v10@@ ; int @@v11@@ ; int * @@v12@@ ; int @@v13@@ ; int * @@v14@@ ; int @@v15@@ ; @@v15@@ = @@a3@@ ; if ( @@a2@@ != Number ) return ( unsigned int ) fcntl ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( have_dupfd_cloexec_3202 < Number ) { @@v6@@ = ( ( __int64 ( __fastcall * ) ( int , _DWORD , _DWORD , int , int , int , char ) ) rpl_fcntl ) ( @@a1@@ , Number , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ , Number ) ; if ( @@v6@@ < Number || have_dupfd_cloexec_3202 != Number ) return ( unsigned int ) @@v6@@ ; } else { @@v6@@ = fcntl ( @@a1@@ , Number , ( unsigned int ) @@a3@@ ) ; if ( @@v6@@ >= Number || * __errno_location ( ) != Number ) { have_dupfd_cloexec_3202 = Number ; return ( unsigned int ) @@v6@@ ; } @@v6@@ = ( ( __int64 ( __fastcall * ) ( int , _DWORD , int , int , int , int , char ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v15@@ , @@v8@@ , @@v9@@ , @@v10@@ , Number ) ; if ( @@v6@@ < Number ) return ( unsigned int ) @@v6@@ ; have_dupfd_cloexec_3202 = Number ; } @@v11@@ = fcntl ( @@v6@@ , Number ) ; if ( @@v11@@ < Number || fcntl ( @@v6@@ , Number , @@v11@@ | Number ) == Number ) { @@v12@@ = __errno_location ( ) ; @@v13@@ = * @@v12@@ ; @@v14@@ = @@v12@@ ; close ( @@v6@@ ) ; @@v6@@ = Number ; * @@v14@@ = @@v13@@ ; } return ( unsigned int ) @@v6@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( ) ; } return @@result@@ ; }
__int64 __fastcall rpl_re_match_2 ( __int64 @@a1@@ , const void * @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ , unsigned __int64 @@a6@@ , unsigned __int64 * @@a7@@ , __int64 @@a8@@ ) { return re_search_2_stub ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ , Number L , @@a7@@ , @@a8@@ , Number ) ; }
__int64 __fastcall re_string_context_at ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , char @@a3@@ ) { wint_t @@v3@@ ; __int64 @@result@@ ; unsigned __int64 @@v5@@ ; __int64 @@v6@@ ; if ( @@a2@@ > Number ) return * ( unsigned int * ) ( @@a1@@ + Number ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) == @@a2@@ ) return ( @@a3@@ & Number ) == Number ? Number : Number ; if ( * ( int * ) ( @@a1@@ + Number ) <= Number ) { @@v5@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ ) ; @@v6@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * ( @@v5@@ >> Number ) ) ; @@result@@ = Number L ; if ( _bittest64 ( & @@v6@@ , @@v5@@ ) ) return @@result@@ ; @@result@@ = Number L ; if ( ( _BYTE ) @@v5@@ != Number ) return @@result@@ ; return Number * ( unsigned int ) ( * ( _BYTE * ) ( @@a1@@ + Number ) != Number ) ; } while ( Number ) { @@v3@@ = * ( _DWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@a2@@ ) ; if ( @@v3@@ != Number ) break ; if ( -- @@a2@@ > Number ) return * ( unsigned int * ) ( @@a1@@ + Number ) ; } if ( * ( _BYTE * ) ( @@a1@@ + Number ) && ( iswalnum ( @@v3@@ ) || @@v3@@ == Number ) ) return Number L ; @@result@@ = Number L ; if ( @@v3@@ == Number ) return Number * ( unsigned int ) ( * ( _BYTE * ) ( @@a1@@ + Number ) != Number ) ; return @@result@@ ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
__int64 __fastcall rpl_re_set_registers ( __int64 @@a1@@ , _QWORD * @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ ) { __int64 @@result@@ ; if ( @@a3@@ ) { @@result@@ = * ( _BYTE * ) ( @@a1@@ + Number ) & Number | Number ; * ( _BYTE * ) ( @@a1@@ + Number ) = * ( _BYTE * ) ( @@a1@@ + Number ) & Number | Number ; * @@a2@@ = @@a3@@ ; @@a2@@ [ Number ] = @@a4@@ ; @@a2@@ [ Number ] = @@a5@@ ; } else { * ( _BYTE * ) ( @@a1@@ + Number ) &= Number ; * @@a2@@ = Number L ; @@a2@@ [ Number ] = Number L ; @@a2@@ [ Number ] = Number L ; } return @@result@@ ; }
void __fastcall free_fail_stack_return_part_28 ( __int64 @@a1@@ ) { __int64 @@v2@@ ; unsigned __int64 @@v3@@ ; void * @@v4@@ ; if ( * ( _QWORD * ) @@a1@@ ) { @@v2@@ = Number L ; @@v3@@ = Number L ; do { ++ @@v3@@ ; free ( * ( void * * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@v2@@ + Number ) ) ; @@v4@@ = * ( void * * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@v2@@ + Number ) ; @@v2@@ += Number L ; free ( @@v4@@ ) ; } while ( @@v3@@ < * ( _QWORD * ) @@a1@@ ) ; } free ( * ( void * * ) ( @@a1@@ + Number ) ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) _frame_dummy_init_array_entry [ @@i@@ ] ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
char * __fastcall parse_reg_exp ( __int64 * @@a1@@ , __int64 * @@a2@@ , __m128i * @@a3@@ , __int64 @@a4@@ , void * @@a5@@ , _DWORD * @@a6@@ ) { __int64 @@v9@@ ; char * @@v10@@ ; char * @@v11@@ ; char * @@v12@@ ; __m128i @@v15@@ ; unsigned __int64 @@v16@@ ; @@v9@@ = * @@a2@@ ; @@v16@@ = __readfsqword ( Number ) ; @@v10@@ = parse_branch ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; @@v11@@ = @@v10@@ ; if ( * @@a6@@ && ! @@v10@@ ) return Number L ; while ( @@a3@@ -> m128i_i8 [ Number ] == Number ) { @@a1@@ [ Number ] += ( int ) peek_token ( ( unsigned __int8 * ) @@a3@@ , @@a1@@ , @@a4@@ | Number ) ; if ( ( @@a3@@ -> m128i_i8 [ Number ] & Number ) == Number || @@a3@@ -> m128i_i8 [ Number ] == Number && @@a5@@ ) { @@v12@@ = Number L ; } else { @@v12@@ = parse_branch ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( * @@a6@@ && ! @@v12@@ ) return Number L ; } @@v15@@ . m128i_i8 [ Number ] = Number ; @@v11@@ = create_token_tree_isra_18 ( ( _QWORD * ) ( @@v9@@ + Number ) , ( int * ) ( @@v9@@ + Number ) , @@v11@@ , @@v12@@ , & @@v15@@ ) ; if ( ! @@v11@@ ) { * @@a6@@ = Number ; return @@v11@@ ; } } return @@v11@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
__int64 __fastcall dup_safer ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ , char @@a7@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ , @@a7@@ ) ; }
void __fastcall rpl_regfree ( __int64 @@a1@@ ) { void * @@v2@@ ; void * @@v3@@ ; void * @@v4@@ ; @@v2@@ = * ( void * * ) @@a1@@ ; if ( @@v2@@ ) free_dfa_content ( @@v2@@ ) ; @@v3@@ = * ( void * * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) @@a1@@ = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; free ( @@v3@@ ) ; @@v4@@ = * ( void * * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; free ( @@v4@@ ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
ssize_t __fastcall safe_read ( int @@fd@@ , void * @@buf@@ , size_t @@nbytes@@ ) { ssize_t @@v4@@ ; int @@v5@@ ; while ( Number ) { @@v4@@ = read ( @@fd@@ , @@buf@@ , @@nbytes@@ ) ; if ( @@v4@@ >= Number ) break ; @@v5@@ = * __errno_location ( ) ; if ( @@v5@@ != Number ) { if ( @@nbytes@@ <= Number || @@v5@@ != Number ) return @@v4@@ ; @@nbytes@@ = Number L ; } } return @@v4@@ ; }
void * __fastcall x2realloc ( void * @@a1@@ , size_t * @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; void * @@result@@ ; @@v2@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v2@@ > Number ) xalloc_die ( ) ; @@v3@@ = ( ( @@v2@@ + Number ) >> Number ) + @@v2@@ ; * @@a2@@ = @@v3@@ ; @@result@@ = xrealloc ( @@a1@@ , @@v3@@ ) ; } else { if ( ! @@v2@@ ) @@v2@@ = Number L ; * @@a2@@ = @@v2@@ ; @@result@@ = xrealloc ( Number L , @@v2@@ ) ; } return @@result@@ ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; char * @@v11@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String String String String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v9@@ = stdout ; @@v10@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; @@v11@@ = setlocale ( Number , Number L ) ; if ( @@v11@@ ) { if ( strncmp ( @@v11@@ , String , Number ) ) { last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 __fastcall sysv_sum_file ( char * @@file@@ , int @@a2@@ ) { bool @@v2@@ ; _BOOL4 @@v3@@ ; int @@v4@@ ; int @@v5@@ ; __int64 @@i@@ ; __int64 @@v7@@ ; char * @@v8@@ ; int @@v9@@ ; char * @@v10@@ ; unsigned int @@v11@@ ; int * @@v13@@ ; int * @@v14@@ ; char @@v15@@ [ Number ] ; char @@buf@@ [ Number ] ; unsigned __int64 @@v17@@ ; @@v17@@ = __readfsqword ( Number ) ; @@v2@@ = strcmp ( @@file@@ , String ) == Number ; @@v3@@ = ! @@v2@@ ; if ( @@v2@@ ) { have_read_stdin = Number ; @@v4@@ = Number ; } else { @@v4@@ = open ( @@file@@ , Number ) ; if ( @@v4@@ == Number ) { LABEL_19 : @@v14@@ = __errno_location ( ) ; @@v11@@ = Number ; error ( Number , * @@v14@@ , String , @@file@@ ) ; return @@v11@@ ; } } @@v5@@ = Number ; for ( @@i@@ = Number L ; ; @@i@@ += @@v7@@ ) { @@v7@@ = safe_read ( @@v4@@ , @@buf@@ , Number ) ; if ( ! @@v7@@ ) break ; if ( @@v7@@ == Number ) { @@v13@@ = __errno_location ( ) ; @@v11@@ = Number ; error ( Number , * @@v13@@ , String , @@file@@ ) ; if ( @@v3@@ ) close ( @@v4@@ ) ; return @@v11@@ ; } @@v8@@ = @@buf@@ ; do { @@v9@@ = ( unsigned __int8 ) * @@v8@@ ++ ; @@v5@@ += @@v9@@ ; } while ( & @@buf@@ [ @@v7@@ ] != @@v8@@ ) ; } if ( @@v3@@ && close ( @@v4@@ ) ) goto LABEL_19 ; human_readable ( @@i@@ , @@v15@@ , Number L , Number L , Number L ) ; __printf_chk ( ) ; if ( @@a2@@ ) __printf_chk ( ) ; @@v10@@ = stdout -> _IO_write_ptr ; @@v11@@ = Number ; if ( @@v10@@ >= stdout -> _IO_write_end ) { __overflow ( stdout , Number ) ; } else { stdout -> _IO_write_ptr = @@v10@@ + Number ; * @@v10@@ = Number ; } return @@v11@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
unsigned __int64 __fastcall version_etc ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , char @@a7@@ ) { unsigned int @@v7@@ ; char * @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; _QWORD @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; char @@v16@@ [ Number ] ; __int64 @@v17@@ ; __int64 @@v18@@ ; @@v7@@ = Number ; @@v15@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ ; @@v8@@ = & @@a7@@ ; @@v18@@ = @@a6@@ ; for ( @@i@@ = Number L ; @@i@@ != Number ; ++ @@i@@ ) { if ( @@v7@@ > Number ) { @@v11@@ = @@v8@@ ; @@v8@@ += Number ; } else { @@v10@@ = @@v7@@ ; @@v7@@ += Number ; @@v11@@ = & @@v16@@ [ @@v10@@ ] ; } @@v12@@ = * ( _QWORD * ) @@v11@@ ; @@v14@@ [ @@i@@ ] = @@v12@@ ; if ( ! @@v12@@ ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v14@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned int * @@a5@@ ) { __int64 @@v5@@ ; unsigned int @@v6@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; _QWORD @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v5@@ = Number L ; @@v11@@ = __readfsqword ( Number ) ; do { @@v6@@ = * @@a5@@ ; if ( * @@a5@@ > Number ) { @@v7@@ = ( _QWORD * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v7@@ + Number ; } else { @@v7@@ = ( _QWORD * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + @@v6@@ ) ; * @@a5@@ = @@v6@@ + Number ; } @@v8@@ = * @@v7@@ == Number L ; @@v10@@ [ @@v5@@ ] = * @@v7@@ ; if ( @@v8@@ ) break ; ++ @@v5@@ ; } while ( @@v5@@ != Number ) ; version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v10@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
long double __fastcall adjust_value_part_0 ( int @@a1@@ , long double @@a2@@ ) { unsigned __int64 @@v7@@ ; long double @@v8@@ ; long double @@result@@ ; if ( @@a2@@ >= Number ) @@v7@@ = ( __int64 ) ( @@a2@@ - Number ) ^ Number ; else @@v7@@ = ( __int64 ) @@a2@@ ; @@v8@@ = ( long double ) @@v7@@ ; if ( @@a1@@ ) return @@v8@@ ; @@result@@ = @@v8@@ ; if ( @@a2@@ != @@v8@@ ) @@result@@ = ( long double ) ( @@v7@@ + Number ) ; return @@result@@ ; }
__int128 * __fastcall set_quoting_style ( __int128 * @@a1@@ , int @@a2@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
__int64 __fastcall quotearg_buffer ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ , __int128 * @@a5@@ ) { __int128 * @@v5@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; __int64 @@result@@ ; @@v5@@ = @@a5@@ ; if ( ! @@a5@@ ) @@v5@@ = & default_quoting_options ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; @@result@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v5@@ , * ( ( _DWORD * ) @@v5@@ + Number ) , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v9@@ = @@v8@@ ; return @@result@@ ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
int __cdecl __noreturn main ( int @@argc@@ , const char * * @@argv@@ , const char * * envp ) { __int64 ( __fastcall * @@v3@@ ) ( char * ) ; int @@v4@@ ; char @@v5@@ ; char @@v6@@ ; int * @@v7@@ ; @@v3@@ = bsd_sum_file ; set_program_name ( * @@argv@@ ) ; setlocale ( Number , String ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; setvbuf ( stdout , Number L , Number , Number L ) ; have_read_stdin = Number ; while ( Number ) { @@v4@@ = getopt_long ( @@argc@@ , ( char * const * ) @@argv@@ , String , & longopts , Number L ) ; if ( @@v4@@ == Number ) { if ( @@argc@@ - optind > Number ) { @@v5@@ = Number ; while ( optind < @@argc@@ ) { @@v6@@ = @@v3@@ ( ( char * ) @@argv@@ [ optind ] ) ; ++ optind ; @@v5@@ &= @@v6@@ ; } } else { @@v5@@ = @@v3@@ ( String ) ; } if ( have_read_stdin && fclose ( stdin ) == Number ) { @@v7@@ = __errno_location ( ) ; error ( Number , * @@v7@@ , String ) ; } exit ( ( unsigned __int8 ) @@v5@@ ^ Number ) ; } if ( @@v4@@ == Number ) usage ( Number ) ; if ( @@v4@@ <= Number ) break ; if ( @@v4@@ == Number ) { @@v3@@ = bsd_sum_file ; } else { if ( @@v4@@ != Number ) goto LABEL_11 ; @@v3@@ = sysv_sum_file ; } } if ( @@v4@@ == Number ) { version_etc ( ( _DWORD ) stdout , ( unsigned int ) String , ( unsigned int ) & unk_54A0 , ( _DWORD ) Version , ( unsigned int ) String , ( unsigned int ) String , Number ) ; exit ( Number ) ; } LABEL_11 : usage ( Number ) ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
_BYTE * __fastcall quotearg_alloc_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int128 * @@a4@@ ) { __int128 * @@v5@@ ; int * @@v6@@ ; int @@v7@@ ; int @@v9@@ ; _BYTE * @@v10@@ ; __int64 @@v11@@ ; @@v5@@ = @@a4@@ ; if ( ! @@a4@@ ) @@v5@@ = & default_quoting_options ; @@v6@@ = __errno_location ( ) ; @@v7@@ = * ( ( _DWORD * ) @@v5@@ + Number ) | ( @@a3@@ == Number L ) ; @@v9@@ = * @@v6@@ ; @@v11@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; @@v10@@ = ( _BYTE * ) xmalloc ( @@v11@@ + Number ) ; quotearg_buffer_restyled ( @@v10@@ , @@v11@@ + Number , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v5@@ , @@v7@@ , ( __int64 ) @@v5@@ + Number , * ( ( char * * ) @@v5@@ + Number ) , * ( ( const char * * ) @@v5@@ + Number ) ) ; * @@v6@@ = @@v9@@ ; if ( @@a3@@ ) * @@a3@@ = @@v11@@ ; return @@v10@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; program_invocation_short_name = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
_BYTE * __fastcall quotearg_colon ( wchar_t * @@a1@@ ) { return quotearg_char_mem ( @@a1@@ , Number , Number ) ; }
__int64 __fastcall version_etc_ar ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@v5@@ ; @@v5@@ = Number L ; if ( * @@a5@@ ) { do ++ @@v5@@ ; while ( @@a5@@ [ @@v5@@ ] ) ; } return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@a5@@ , @@v5@@ ) ; }
void * __fastcall xzalloc ( size_t @@n@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@n@@ ) ; return memset ( @@v1@@ , Number , @@n@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
ssize_t __fastcall safe_read ( int @@fd@@ , void * @@buf@@ , size_t @@nbytes@@ ) { ssize_t @@v4@@ ; int @@v5@@ ; while ( Number ) { @@v4@@ = read ( @@fd@@ , @@buf@@ , @@nbytes@@ ) ; if ( @@v4@@ >= Number ) break ; @@v5@@ = * __errno_location ( ) ; if ( @@v5@@ != Number ) { if ( @@nbytes@@ <= Number || @@v5@@ != Number ) return @@v4@@ ; @@nbytes@@ = Number L ; } } return @@v4@@ ; }
void __fastcall argmatch_invalid ( __int64 @@a1@@ , wchar_t * @@a2@@ , __int64 @@a3@@ ) { char * @@v3@@ ; __int64 @@v4@@ ; _BYTE * @@v5@@ ; if ( @@a3@@ == Number ) @@v3@@ = dcgettext ( Number L , String , Number ) ; else @@v3@@ = dcgettext ( Number L , String , Number ) ; @@v4@@ = quote_n ( Number L , @@a1@@ ) ; @@v5@@ = quotearg_n_style ( Number , Number , @@a2@@ ) ; error ( Number , Number , @@v3@@ , @@v5@@ , @@v4@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
__int64 __fastcall argmatch_to_argument ( void * @@s1@@ , __int64 * @@a2@@ , char * @@a3@@ , size_t @@a4@@ ) { __int64 @@v4@@ ; __int64 * @@v7@@ ; @@v4@@ = * @@a2@@ ; if ( * @@a2@@ ) { @@v7@@ = @@a2@@ + Number ; do { if ( ! memcmp ( @@s1@@ , @@a3@@ , @@a4@@ ) ) break ; @@v4@@ = * @@v7@@ ; @@a3@@ += @@a4@@ ; ++ @@v7@@ ; } while ( @@v4@@ ) ; } return @@v4@@ ; }
__int64 __fastcall argmatch ( const char * @@a1@@ , const char * * @@a2@@ , char * @@a3@@ , size_t @@a4@@ ) { char * @@v5@@ ; size_t @@v6@@ ; const char * @@v7@@ ; size_t @@v8@@ ; __int64 @@v9@@ ; bool @@v10@@ ; char @@v11@@ ; __int64 @@v12@@ ; __int64 @@v14@@ ; char @@v15@@ ; @@v5@@ = @@a3@@ ; @@v6@@ = strlen ( @@a1@@ ) ; @@v7@@ = * @@a2@@ ; @@v14@@ = Number ; if ( ! * @@a2@@ ) return @@v14@@ ; @@v8@@ = @@v6@@ ; @@v15@@ = Number ; @@v9@@ = Number L ; do { while ( strncmp ( @@v7@@ , @@a1@@ , @@v8@@ ) ) { LABEL_7 : ++ @@v9@@ ; @@v5@@ += @@a4@@ ; @@v7@@ = @@a2@@ [ @@v9@@ ] ; if ( ! @@v7@@ ) goto LABEL_12 ; } if ( strlen ( @@v7@@ ) == @@v8@@ ) return @@v9@@ ; if ( @@v14@@ != Number ) { if ( @@a3@@ ) { @@v10@@ = memcmp ( & @@a3@@ [ @@a4@@ * @@v14@@ ] , @@v5@@ , @@a4@@ ) == Number ; @@v11@@ = @@v15@@ ; if ( ! @@v10@@ ) @@v11@@ = Number ; @@v15@@ = @@v11@@ ; } else { @@v15@@ = Number ; } goto LABEL_7 ; } @@v14@@ = @@v9@@ ++ ; @@v5@@ += @@a4@@ ; @@v7@@ = @@a2@@ [ @@v9@@ ] ; } while ( @@v7@@ ) ; LABEL_12 : @@v12@@ = Number ; if ( ! @@v15@@ ) @@v12@@ = @@v14@@ ; return @@v12@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
_BYTE * __fastcall quote_n ( int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number , @@a2@@ ) ; }
int unlink ( const char * @@name@@ ) { return unlink ( @@name@@ ) ; }
_BYTE * __fastcall quotearg_n_options ( int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ ) { int * @@v6@@ ; __m128i * @@v7@@ ; __int64 @@v8@@ ; __m128i * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 * @@v11@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; unsigned __int64 @@v18@@ ; int @@v19@@ ; int @@v20@@ ; @@v6@@ = __errno_location ( ) ; @@v7@@ = ( __m128i * ) slotvec ; @@v19@@ = * @@v6@@ ; if ( @@a1@@ < Number ) abort ( ) ; if ( nslots <= ( unsigned int ) @@a1@@ ) { @@v8@@ = Number L * ( unsigned int ) ( @@a1@@ + Number ) ; if ( slotvec == & slotvec0 ) { @@v7@@ = ( __m128i * ) xrealloc ( Number L , @@v8@@ ) ; slotvec = @@v7@@ ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; * @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & slotvec0 ) ; } else { @@v9@@ = ( __m128i * ) xrealloc ( slotvec , @@v8@@ ) ; @@v10@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v7@@ = @@v9@@ ; slotvec = @@v9@@ ; } memset ( & @@v7@@ [ nslots ] , Number , Number * ( @@v10@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v11@@ = ( unsigned __int64 * ) & @@v7@@ [ @@a1@@ ] ; @@v12@@ = ( _BYTE * ) @@v11@@ [ Number ] ; @@v20@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v18@@ = * @@v11@@ ; @@v13@@ = quotearg_buffer_restyled ( @@v12@@ , * @@v11@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; if ( @@v18@@ <= @@v13@@ ) { @@v14@@ = @@v13@@ + Number ; * @@v11@@ = @@v13@@ + Number ; if ( @@v12@@ != ( _BYTE * ) & slot0 ) free ( @@v12@@ ) ; @@v15@@ = ( _BYTE * ) xmalloc ( @@v14@@ ) ; @@v11@@ [ Number ] = ( unsigned __int64 ) @@v15@@ ; @@v12@@ = @@v15@@ ; quotearg_buffer_restyled ( @@v15@@ , @@v14@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v20@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( const char * * ) ( @@a4@@ + Number ) ) ; } * @@v6@@ = @@v19@@ ; return @@v12@@ ; }
int raise ( int @@sig@@ ) { return raise ( @@sig@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
int iswalnum ( wint_t @@wc@@ ) { return iswalnum ( @@wc@@ ) ; }
wctype_t wctype ( const char * @@property@@ ) { return wctype ( @@property@@ ) ; }
wint_t towupper ( wint_t @@wc@@ ) { return towupper ( @@wc@@ ) ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
char * nl_langinfo ( nl_item @@item@@ ) { return nl_langinfo ( @@item@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
int __fastcall interrupt_handler ( int @@sig@@ ) { if ( remove_files ) delete_all_files_part_0 ( Number ) ; return raise ( @@sig@@ ) ; }
__int64 __fastcall delete_all_files_part_0 ( char @@a1@@ ) { __int64 @@result@@ ; unsigned int @@v2@@ ; char * @@v3@@ ; int * @@v4@@ ; @@result@@ = ( unsigned int ) files_created ; if ( files_created ) { @@v2@@ = Number ; do { while ( Number ) { @@v3@@ = make_filename ( ) ; if ( unlink ( @@v3@@ ) ) { if ( ! @@a1@@ ) break ; } @@result@@ = ( unsigned int ) files_created ; if ( ++ @@v2@@ >= files_created ) goto LABEL_7 ; } @@v4@@ = __errno_location ( ) ; ++ @@v2@@ ; error ( Number , * @@v4@@ , String , @@v3@@ ) ; @@result@@ = ( unsigned int ) files_created ; } while ( @@v2@@ < files_created ) ; LABEL_7 : files_created = Number ; } else { files_created = Number ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ ) { __m128i @@v3@@ ; __int128 @@v5@@ [ Number ] ; __int64 @@v6@@ ; char @@v7@@ [ Number ] ; __int128 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; * ( _QWORD * ) @@v7@@ = @@a2@@ ; * ( _OWORD * ) & @@v7@@ [ Number ] = Number L ; @@v10@@ = __readfsqword ( Number ) ; @@v8@@ = Number L ; @@v3@@ = _mm_load_si128 ( ( const __m128i * ) @@v7@@ ) ; @@v6@@ = @@v9@@ ; @@v5@@ [ Number ] = ( __int128 ) @@v3@@ ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & @@v7@@ [ Number ] ) ; @@v5@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v8@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall find_line ( unsigned __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { _QWORD * @@v3@@ ; unsigned __int64 @@v4@@ ; _QWORD * @@v5@@ ; unsigned __int64 @@v6@@ ; __int64 @@i@@ ; @@v3@@ = ( _QWORD * ) head ; if ( ! head ) { if ( have_read_eof || ! ( unsigned __int8 ) load_buffer_part_5 ( @@a1@@ , @@a2@@ , @@a3@@ ) ) return Number L ; @@v3@@ = ( _QWORD * ) head ; } @@v4@@ = @@v3@@ [ Number ] ; if ( @@v4@@ > @@a1@@ ) return Number L ; if ( @@a1@@ >= @@v4@@ + @@v3@@ [ Number ] ) { while ( Number ) { @@v5@@ = ( _QWORD * ) @@v3@@ [ Number ] ; if ( ! @@v5@@ ) { if ( have_read_eof || ! ( unsigned __int8 ) load_buffer_part_5 ( @@a1@@ , @@a2@@ , @@v4@@ ) ) { return Number L ; } @@v5@@ = ( _QWORD * ) @@v3@@ [ Number ] ; } @@v4@@ = @@v5@@ [ Number ] ; @@v3@@ = @@v5@@ ; if ( @@v4@@ + @@v5@@ [ Number ] > @@a1@@ ) goto LABEL_10 ; } } @@v5@@ = @@v3@@ ; LABEL_10 : @@v6@@ = @@a1@@ - @@v4@@ ; for ( @@i@@ = @@v5@@ [ Number ] ; @@v6@@ > Number ; @@i@@ = * ( _QWORD * ) ( @@i@@ + Number ) ) { @@v6@@ -= Number L ; } return @@i@@ + Number * @@v6@@ + Number ; }
__int64 __fastcall keep_new_line_isra_2 ( __int64 * * @@a1@@ , __int64 * * @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ ) { __int64 * @@v6@@ ; __int64 @@v7@@ ; __int64 @@result@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; __int64 * @@v11@@ ; _QWORD * @@v12@@ ; __int64 * @@v13@@ ; if ( ! * @@a1@@ ) { @@v13@@ = ( __int64 * ) xmalloc ( Number L , @@a2@@ , @@a3@@ ) ; * @@a2@@ = @@v13@@ ; @@v13@@ [ Number ] = Number L ; * @@v13@@ = Number L ; @@v13@@ [ Number ] = Number L ; @@v13@@ [ Number ] = Number L ; * @@a1@@ = @@v13@@ ; } @@v6@@ = * @@a2@@ ; @@v7@@ = * * @@a2@@ ; if ( @@v7@@ == Number ) { @@v12@@ = ( _QWORD * ) xmalloc ( Number L , @@a2@@ , @@a3@@ ) ; @@v12@@ [ Number ] = Number L ; * @@v12@@ = Number L ; @@v12@@ [ Number ] = Number L ; @@v12@@ [ Number ] = Number L ; @@v6@@ [ Number ] = ( __int64 ) @@v12@@ ; @@v6@@ = ( __int64 * ) ( * @@a2@@ ) [ Number ] ; * @@a2@@ = @@v6@@ ; @@v7@@ = * @@v6@@ ; } @@result@@ = @@v7@@ + Number ; @@v9@@ = @@v6@@ [ Number ] ; @@v10@@ = @@v9@@ + Number ; @@v11@@ = & @@v6@@ [ Number * @@v9@@ ] ; @@v11@@ [ Number ] = @@a3@@ ; @@v11@@ [ Number ] = @@a4@@ ; * @@v6@@ = @@result@@ ; @@v6@@ [ Number ] = @@v10@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_char ( wchar_t * @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@result@@ ; @@result@@ = malloc ( @@a1@@ ) ; if ( ! @@result@@ ) { if ( @@a1@@ ) xalloc_die ( ) ; } return @@result@@ ; }
__int64 __fastcall version_etc_arn ( FILE * @@stream@@ , __int64 a2 , __int64 a3 , __int64 a4 , __int64 @@a5@@ , __int64 @@a6@@ ) { char * @@v8@@ ; const char * @@v10@@ ; __int64 @@v11@@ ; __fprintf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; @@v8@@ = dcgettext ( Number L , String String String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@stream@@ ) ; switch ( @@a6@@ ) { case Number L : abort ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; goto LABEL_11 ; case Number L : @@v11@@ = * ( _QWORD * ) ( @@a5@@ + Number ) ; dcgettext ( Number L , String , Number ) ; LABEL_11 : __fprintf_chk ( ) ; return @@v11@@ ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : dcgettext ( Number L , String , Number ) ; return __fprintf_chk ( ) ; case Number L : @@v10@@ = String ; goto LABEL_5 ; default : @@v10@@ = String ; LABEL_5 : dcgettext ( Number L , @@v10@@ , Number ) ; return __fprintf_chk ( ) ; } }
char * __fastcall set_program_name ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@result@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v1@@ = ( __int64 ) @@a1@@ ; @@result@@ = strrchr ( @@a1@@ , Number ) ; if ( @@result@@ ) { if ( @@result@@ + Number - @@a1@@ > Number && ! memcmp ( @@result@@ - Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; if ( ! memcmp ( @@result@@ + Number , String , Number ) ) { @@v1@@ = ( __int64 ) ( @@result@@ + Number ) ; program_invocation_short_name = ( __int64 ) ( @@result@@ + Number ) ; } } } program_name = @@v1@@ ; program_invocation_name = @@v1@@ ; return @@result@@ ; }
void __fastcall close_stdout_set_file_name ( __int64 @@a1@@ ) { file_name = @@a1@@ ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v1@@ ; _BYTE * @@result@@ ; _BYTE * @@v3@@ ; char @@v4@@ ; @@v1@@ = * @@a1@@ ; for ( @@result@@ = @@a1@@ ; * @@result@@ == Number ; @@v1@@ = * @@result@@ ) { ++ @@result@@ ; } if ( @@v1@@ ) { @@v3@@ = @@result@@ ; @@v4@@ = Number ; do { while ( @@v1@@ == Number ) { @@v1@@ = * ++ @@v3@@ ; @@v4@@ = Number ; if ( ! * @@v3@@ ) return @@result@@ ; } if ( @@v4@@ ) { @@result@@ = @@v3@@ ; @@v4@@ = Number ; } @@v1@@ = * ++ @@v3@@ ; } while ( * @@v3@@ ) ; } return @@result@@ ; }
__int64 __fastcall get_quoting_style ( __int128 * @@a1@@ ) { if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; return * ( unsigned int * ) @@a1@@ ; }
FILE * __fastcall fopen_safer ( const char * @@a1@@ , const char * @@a2@@ ) { FILE * @@v2@@ ; FILE * @@v3@@ ; unsigned int @@v4@@ ; int @@v6@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; int * @@v10@@ ; int @@v11@@ ; int * @@v12@@ ; @@v2@@ = fopen ( @@a1@@ , @@a2@@ ) ; @@v3@@ = @@v2@@ ; if ( @@v2@@ ) { @@v4@@ = fileno ( @@v2@@ ) ; if ( @@v4@@ <= Number ) { @@v6@@ = dup_safer ( @@v4@@ ) ; if ( @@v6@@ < Number ) { @@v10@@ = __errno_location ( ) ; @@v11@@ = * @@v10@@ ; @@v12@@ = @@v10@@ ; fclose ( @@v3@@ ) ; @@v3@@ = Number L ; * @@v12@@ = @@v11@@ ; } else if ( fclose ( @@v3@@ ) || ( @@v3@@ = fdopen ( @@v6@@ , @@a2@@ ) ) == Number L ) { @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; close ( @@v6@@ ) ; * @@v9@@ = @@v8@@ ; @@v3@@ = Number L ; } } } return @@v3@@ ; }
int __fastcall argmatch_valid ( _QWORD * @@a1@@ , char * @@a2@@ , size_t @@a3@@ ) { const void * @@v5@@ ; __int64 @@v6@@ ; char * @@v7@@ ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; if ( * @@a1@@ ) { @@v5@@ = Number L ; @@v6@@ = Number L ; do { while ( ! @@v6@@ || memcmp ( @@v5@@ , @@a2@@ , @@a3@@ ) ) { ++ @@v6@@ ; @@v5@@ = @@a2@@ ; __fprintf_chk ( ) ; @@a2@@ += @@a3@@ ; if ( ! @@a1@@ [ @@v6@@ ] ) goto LABEL_7 ; } ++ @@v6@@ ; @@a2@@ += @@a3@@ ; __fprintf_chk ( ) ; } while ( @@a1@@ [ @@v6@@ ] ) ; } LABEL_7 : @@v7@@ = stderr -> _IO_write_ptr ; if ( @@v7@@ >= stderr -> _IO_write_end ) { LODWORD ( @@v7@@ ) = __overflow ( stderr , Number ) ; } else { stderr -> _IO_write_ptr = @@v7@@ + Number ; * @@v7@@ = Number ; } return ( int ) @@v7@@ ; }
__int64 __fastcall set_quoting_flags ( __int128 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@result@@ = * ( ( unsigned int * ) @@a1@@ + Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
int iswlower ( wint_t @@wc@@ ) { return iswlower ( @@wc@@ ) ; }
__int64 __fastcall set_char_quoting ( __int128 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { _DWORD * @@v3@@ ; int @@v4@@ ; char @@v5@@ ; __int64 @@result@@ ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; @@v3@@ = ( _DWORD * ) @@a1@@ + ( @@a2@@ >> Number ) + Number ; @@v4@@ = * @@v3@@ >> ( @@a2@@ & Number ) ; @@v5@@ = @@v4@@ ^ @@a3@@ ; @@result@@ = @@v4@@ & Number ; * @@v3@@ ^= ( @@v5@@ & Number ) << ( @@a2@@ & Number ) ; return @@result@@ ; }
_BYTE * __fastcall quotearg ( wchar_t * @@a1@@ ) { return quotearg_n_options ( Number , @@a1@@ , Number , ( __int64 ) & default_quoting_options ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
_BYTE * __fastcall quotearg_style ( unsigned int @@a1@@ , wchar_t * @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
int sigemptyset ( sigset_t * @@set@@ ) { return sigemptyset ( @@set@@ ) ; }
_BYTE * __fastcall quotearg_alloc ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ , __int128 * @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
wint_t btowc ( int @@c@@ ) { return btowc ( @@c@@ ) ; }
_BYTE * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
_BYTE * __fastcall quotearg_mem ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) & default_quoting_options ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
_BYTE * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , wchar_t * @@a2@@ , unsigned __int64 @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall preorder ( _QWORD * @@a1@@ , __int64 ( __fastcall * @@a2@@ ( ) ( void , bintreet0 ) ) ( __int64 , _QWORD * ) , __int64 @@a3@@ ) { _QWORD * @@v4@@ ; __int64 @@result@@ ; _QWORD * @@v6@@ ; _QWORD * @@v7@@ ; @@v4@@ = @@a1@@ ; for ( @@result@@ = @@a2@@ ( ) ( void , bintreet0 ) ( @@a3@@ , @@a1@@ ) ; ! ( _DWORD ) @@result@@ ; @@result@@ = @@a2@@ ( ) ( void , bintreet0 ) ( @@a3@@ , @@v6@@ ) ) { @@v6@@ = ( _QWORD * ) @@v4@@ [ Number ] ; @@v7@@ = Number L ; if ( ! @@v6@@ ) { while ( Number ) { @@v6@@ = ( _QWORD * ) @@v4@@ [ Number ] ; if ( @@v6@@ != @@v7@@ ) { if ( @@v6@@ ) break ; } @@v7@@ = @@v4@@ ; if ( ! * @@v4@@ ) return @@result@@ ; @@v4@@ = ( _QWORD * ) * @@v4@@ ; } } @@v4@@ = @@v6@@ ; } return @@result@@ ; }
size_t __fastcall save_line_to_file ( __int64 @@a1@@ ) { size_t @@result@@ ; fwrite_unlocked ( * ( const void * * ) ( @@a1@@ + Number ) , Number , * ( _QWORD * ) @@a1@@ , output_stream ) ; @@result@@ = * ( _QWORD * ) @@a1@@ ; * ( _QWORD * ) & bytes_written += * ( _QWORD * ) @@a1@@ ; return @@result@@ ; }
_BYTE * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , wchar_t * @@a4@@ , unsigned __int64 @@a5@@ ) { __int128 @@v6@@ [ Number ] ; __m128i @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & default_quoting_options ) ; @@v8@@ = qword_21A330 ; LODWORD ( @@v6@@ [ Number ] ) = Number ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) & xmmword_21A310 ) ; @@v7@@ = _mm_load_si128 ( ( const __m128i * ) & xmmword_21A320 ) ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v7@@ . m128i_i64 [ Number ] = @@a2@@ ; @@v8@@ = @@a3@@ ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v6@@ ) ; }
__int64 __fastcall register_state ( _QWORD * @@a1@@ , _QWORD * @@a2@@ , __int64 @@a3@@ ) { __int64 @@v4@@ ; void * @@v6@@ ; __int64 @@v7@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; _QWORD * @@v11@@ ; __int64 @@v12@@ ; @@v4@@ = @@a2@@ [ Number ] ; * @@a2@@ = @@a3@@ ; @@a2@@ [ Number ] = Number L ; @@a2@@ [ Number ] = @@v4@@ ; @@v6@@ = malloc ( Number * @@v4@@ ) ; @@a2@@ [ Number ] = @@v6@@ ; if ( ! @@v6@@ ) return Number L ; if ( @@v4@@ ) { @@v7@@ = Number L ; while ( ( * ( _BYTE * ) ( * @@a1@@ + Number L * * ( _QWORD * ) ( @@a2@@ [ Number ] + Number * @@v7@@ ) + Number ) & Number ) != Number || ( unsigned __int8 ) re_node_set_insert_last ( @@a2@@ + Number , * ( _QWORD * ) ( @@a2@@ [ Number ] + Number * @@v7@@ ) ) ) { if ( @@a2@@ [ Number ] <= ( unsigned __int64 ) ++ @@v7@@ ) goto LABEL_8 ; } return Number L ; } LABEL_8 : @@v9@@ = @@a1@@ [ Number ] + Number * ( @@a1@@ [ Number ] & @@a3@@ ) ; @@v10@@ = * ( _QWORD * ) @@v9@@ ; @@v11@@ = * ( _QWORD * * ) ( @@v9@@ + Number ) ; @@v12@@ = * ( _QWORD * ) @@v9@@ + Number L ; if ( * ( _QWORD * ) ( @@v9@@ + Number ) <= * ( _QWORD * ) @@v9@@ ) { @@v11@@ = realloc ( * ( void * * ) ( @@v9@@ + Number ) , Number * @@v12@@ ) ; if ( @@v11@@ ) { @@v10@@ = * ( _QWORD * ) @@v9@@ ; * ( _QWORD * ) ( @@v9@@ + Number ) = @@v11@@ ; * ( _QWORD * ) ( @@v9@@ + Number ) = Number * @@v12@@ ; @@v12@@ = @@v10@@ + Number ; goto LABEL_9 ; } return Number L ; } LABEL_9 : * ( _QWORD * ) @@v9@@ = @@v12@@ ; @@v11@@ [ @@v10@@ ] = @@a2@@ ; return Number L ; }
void __fastcall __noreturn handle_line_error_isra_1 ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; _QWORD @@_0@@ [ Number ] ; @@_0@@ [ Number ] = __readfsqword ( Number ) ; @@v2@@ = umaxtostr ( @@a1@@ , @@_0@@ ) ; quote ( @@v2@@ ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; if ( @@a2@@ ) { umaxtostr ( @@a2@@ , @@_0@@ ) ; dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { fputc ( Number , stderr ) ; } cleanup_fatal ( ) ; }
__int64 __fastcall check_dst_limits_calc_pos ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ , unsigned __int64 @@a5@@ , __int64 @@a6@@ ) { __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; unsigned __int64 @@v8@@ ; int @@v9@@ ; __int64 @@result@@ ; @@v6@@ = * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@a2@@ ; @@v7@@ = * ( _QWORD * ) ( @@v6@@ + Number ) ; if ( @@v7@@ > @@a5@@ ) return Number ; @@v8@@ = * ( _QWORD * ) ( @@v6@@ + Number ) ; if ( @@v8@@ < @@a5@@ ) return Number L ; @@v9@@ = ( @@v7@@ == @@a5@@ ) | Number ; if ( @@v8@@ == @@a5@@ ) return check_dst_limits_calc_pos_1 ( @@a1@@ , @@v9@@ , @@a3@@ , @@a4@@ , @@a6@@ ) ; @@result@@ = Number L ; if ( @@v7@@ == @@a5@@ ) { @@v9@@ = Number ; return check_dst_limits_calc_pos_1 ( @@a1@@ , @@v9@@ , @@a3@@ , @@a4@@ , @@a6@@ ) ; } return @@result@@ ; }
__int64 __fastcall clean_state_log_if_needed ( _QWORD * @@a1@@ , unsigned __int64 @@a2@@ ) { unsigned __int64 @@v2@@ ; unsigned __int64 @@v3@@ ; __int64 @@result@@ ; @@v2@@ = @@a1@@ [ Number ] ; if ( @@a1@@ [ Number ] > @@a2@@ && ( ( @@v3@@ = @@a1@@ [ Number ] , @@v3@@ > @@a2@@ ) || @@v3@@ >= @@a1@@ [ Number ] ) || ( @@result@@ = extend_buffers ( ( __int64 ) @@a1@@ ) , ! ( _DWORD ) @@result@@ ) ) { if ( @@v2@@ < @@a2@@ ) { memset ( ( void * ) ( @@a1@@ [ Number ] + Number * @@v2@@ + Number ) , Number , Number * ( @@a2@@ - @@v2@@ ) ) ; @@a1@@ [ Number ] = @@a2@@ ; } @@result@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall re_node_set_insert_last ( _QWORD * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v3@@ ; void * @@v4@@ ; __int64 @@v6@@ ; @@v3@@ = @@a1@@ [ Number ] ; @@v4@@ = ( void * ) @@a1@@ [ Number ] ; if ( * @@a1@@ != @@v3@@ ) goto LABEL_2 ; @@v6@@ = @@v3@@ + Number ; * @@a1@@ = Number * @@v6@@ ; @@v4@@ = realloc ( @@v4@@ , Number * @@v6@@ ) ; if ( @@v4@@ ) { @@a1@@ [ Number ] = @@v4@@ ; @@v3@@ = @@a1@@ [ Number ] ; LABEL_2 : @@a1@@ [ Number ] = @@v3@@ + Number ; * ( ( _QWORD * ) @@v4@@ + @@v3@@ ) = @@a2@@ ; return Number L ; } return Number L ; }
void __fastcall __noreturn usage ( int @@status@@ ) { FILE * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; FILE * @@v11@@ ; char * @@v12@@ ; FILE * @@v13@@ ; char * @@v14@@ ; FILE * @@v15@@ ; char * @@v16@@ ; FILE * @@v17@@ ; char * @@v18@@ ; char * @@v19@@ ; if ( @@status@@ ) { dcgettext ( Number L , String , Number ) ; __fprintf_chk ( ) ; } else { dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v1@@ = stdout ; @@v2@@ = dcgettext ( Number L , String String String , Number ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; @@v3@@ = stdout ; @@v4@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = dcgettext ( Number L , String String String , Number ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = stdout ; @@v8@@ = dcgettext ( Number L , String String String , Number ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = stdout ; @@v10@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; @@v11@@ = stdout ; @@v12@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v12@@ , @@v11@@ ) ; @@v13@@ = stdout ; @@v14@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v14@@ , @@v13@@ ) ; @@v15@@ = stdout ; @@v16@@ = dcgettext ( Number L , String String String String String String String String , Number ) ; fputs_unlocked ( @@v16@@ , @@v15@@ ) ; last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; @@v17@@ = stdout ; @@v18@@ = dcgettext ( Number L , String , Number ) ; fputs_unlocked ( @@v18@@ , @@v17@@ ) ; @@v19@@ = setlocale ( Number , Number L ) ; if ( @@v19@@ ) { if ( strncmp ( @@v19@@ , String , Number ) ) { last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } } last_component ( program_name ) ; dcgettext ( Number L , String , Number ) ; __printf_chk ( ) ; } exit ( @@status@@ ) ; }
void __fastcall re_string_destruct ( __int64 @@a1@@ ) { free ( * ( void * * ) ( @@a1@@ + Number ) ) ; free ( * ( void * * ) ( @@a1@@ + Number ) ) ; if ( * ( _BYTE * ) ( @@a1@@ + Number ) ) free ( * ( void * * ) ( @@a1@@ + Number ) ) ; }
void __fastcall close_stdout_set_ignore_EPIPE ( char @@a1@@ ) { ignore_EPIPE = @@a1@@ ; }
__int64 __fastcall extend_buffers ( __int64 @@a1@@ ) { unsigned __int64 @@v1@@ ; unsigned int @@v3@@ ; void * @@v4@@ ; void * @@v5@@ ; int @@v6@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; @@v1@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( @@v1@@ > Number ) return Number L ; @@v3@@ = re_string_realloc_buffers ( @@a1@@ , Number * @@v1@@ ) ; if ( @@v3@@ ) return @@v3@@ ; @@v4@@ = * ( void * * ) ( @@a1@@ + Number ) ; if ( ! @@v4@@ ) goto LABEL_6 ; @@v5@@ = realloc ( @@v4@@ , Number L * * ( _QWORD * ) ( @@a1@@ + Number ) + Number ) ; if ( ! @@v5@@ ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v5@@ ; LABEL_6 : @@v6@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; if ( ! * ( _BYTE * ) ( @@a1@@ + Number ) ) { if ( @@v6@@ > Number ) { build_wcs_buffer ( @@a1@@ ) ; return Number L ; } @@v8@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( @@v8@@ ) { @@v9@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= @@v9@@ ) @@v9@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v10@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( @@v9@@ > @@v10@@ ) { while ( Number ) { * ( _BYTE * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@v10@@ ) = * ( _BYTE * ) ( @@v8@@ + * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@v10@@ + * ( _QWORD * ) @@a1@@ ) ) ; if ( @@v9@@ == ++ @@v10@@ ) break ; @@v8@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; } } * ( _QWORD * ) ( @@a1@@ + Number ) = @@v10@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v10@@ ; } return @@v3@@ ; } if ( @@v6@@ > Number ) return build_wcs_upper_buffer ( @@a1@@ ) ; build_upper_buffer ( ( _QWORD * ) @@a1@@ ) ; return Number L ; }
void __fastcall re_node_set_remove_at_isra_4_part_5 ( unsigned __int64 * @@a1@@ , __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { __int64 @@v3@@ ; if ( @@a3@@ < * @@a1@@ ) { @@v3@@ = * @@a2@@ ; do { ++ @@a3@@ ; * ( _QWORD * ) ( @@v3@@ + Number * @@a3@@ - Number ) = * ( _QWORD * ) ( @@v3@@ + Number * @@a3@@ ) ; } while ( @@a3@@ < * @@a1@@ ) ; } }
__int64 __fastcall clone_quoting_options ( __int128 * @@a1@@ ) { __int128 * @@v1@@ ; int * @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; @@v1@@ = @@a1@@ ; @@v2@@ = __errno_location ( ) ; @@v3@@ = * @@v2@@ ; @@v4@@ = @@v2@@ ; if ( ! @@a1@@ ) @@v1@@ = & default_quoting_options ; @@result@@ = xmemdup ( @@v1@@ , Number ) ; * @@v4@@ = @@v3@@ ; return @@result@@ ; }
__int64 __fastcall free_tree ( __int64 a1 , __int64 @@a2@@ ) { free_token ( @@a2@@ + Number ) ; return Number L ; }
__int128 * __fastcall set_custom_quoting ( __int128 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int128 * @@result@@ ; @@result@@ = & default_quoting_options ; if ( ! @@a1@@ ) @@a1@@ = & default_quoting_options ; * ( _DWORD * ) @@a1@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a2@@ ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@a3@@ ; return @@result@@ ; }
__int64 __fastcall re_node_set_compare_part_2 ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; __int64 @@result@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@result@@ = Number L ; if ( @@v2@@ == * ( _QWORD * ) ( @@a2@@ + Number ) ) { @@v4@@ = Number * @@v2@@ - Number ; do { if ( ( unsigned __int64 ) -- @@v2@@ > Number ) return Number L ; @@v5@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@v4@@ ) ; @@v6@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + @@v4@@ ) ; @@v4@@ -= Number L ; } while ( @@v5@@ == @@v6@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
_BYTE * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , wchar_t * @@a3@@ , unsigned __int64 @@a4@@ ) { __m128i @@v4@@ ; __int128 @@v6@@ [ Number ] ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; __int128 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; * ( _QWORD * ) @@v8@@ = @@a2@@ ; * ( _OWORD * ) & @@v8@@ [ Number ] = Number L ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) @@v8@@ ) ; @@v4@@ = _mm_load_si128 ( ( const __m128i * ) & @@v8@@ [ Number ] ) ; @@v7@@ = @@v10@@ ; @@v6@@ [ Number ] = ( __int128 ) @@v4@@ ; @@v6@@ [ Number ] = ( __int128 ) _mm_load_si128 ( ( const __m128i * ) ( ( char * ) & @@v9@@ + Number ) ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v6@@ ) ; }
__int64 __fastcall check_arrival_expand_ecl ( _QWORD * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , unsigned int @@a4@@ ) { unsigned __int64 @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; __int64 @@v12@@ ; __int64 @@v13@@ ; __int64 @@v14@@ ; unsigned int @@v15@@ ; __m128i @@v16@@ ; __int64 @@result@@ ; unsigned int @@v18@@ ; __m128i @@v19@@ ; void * @@ptr@@ ; unsigned __int64 @@v21@@ ; @@v7@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@v21@@ = __readfsqword ( Number ) ; @@v19@@ = ( __m128i ) @@v7@@ ; @@ptr@@ = malloc ( Number * @@v7@@ ) ; if ( @@ptr@@ ) { if ( ! @@v7@@ ) { LABEL_12 : free ( * ( void * * ) ( @@a2@@ + Number ) ) ; @@v16@@ = _mm_load_si128 ( & @@v19@@ ) ; * ( _QWORD * ) ( @@a2@@ + Number ) = @@ptr@@ ; @@result@@ = Number L ; * ( __m128i * ) @@a2@@ = @@v16@@ ; return @@result@@ ; } @@v8@@ = Number L ; while ( Number ) { @@v9@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number * @@v8@@ ) ; @@v10@@ = @@a1@@ [ Number ] + Number * @@v9@@ ; @@v11@@ = * ( _QWORD * ) ( @@v10@@ + Number ) ; if ( ! @@v11@@ ) goto LABEL_13 ; @@v12@@ = * ( _QWORD * ) ( @@v10@@ + Number ) ; @@v13@@ = Number L ; while ( Number ) { @@v14@@ = * @@a1@@ + Number L * * ( _QWORD * ) ( @@v12@@ + Number * @@v13@@ ) ; if ( @@a4@@ == * ( unsigned __int8 * ) ( @@v14@@ + Number ) && @@a3@@ == * ( _QWORD * ) @@v14@@ ) { break ; } if ( @@v11@@ == ++ @@v13@@ ) goto LABEL_13 ; } if ( * ( _QWORD * ) ( @@v12@@ + Number * @@v13@@ ) == Number ) { LABEL_13 : @@v15@@ = re_node_set_merge ( ( __int64 ) & @@v19@@ , @@v10@@ ) ; if ( @@v15@@ ) { LABEL_14 : @@v18@@ = @@v15@@ ; free ( @@ptr@@ ) ; return @@v18@@ ; } } else { @@v15@@ = check_arrival_expand_ecl_sub ( @@a1@@ , & @@v19@@ , @@v9@@ , @@a3@@ , @@a4@@ ) ; if ( @@v15@@ ) goto LABEL_14 ; } if ( * ( _QWORD * ) ( @@a2@@ + Number ) <= ( unsigned __int64 ) ++ @@v8@@ ) goto LABEL_12 ; } } return Number L ; }
__int64 __fastcall optimize_subexps ( __int64 @@a1@@ , __int64 @@a2@@ ) { char @@v2@@ ; __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; _QWORD * @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; @@v2@@ = * ( _BYTE * ) ( @@a2@@ + Number ) ; if ( @@v2@@ != Number ) { if ( @@v2@@ == Number ) { @@v4@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( @@v4@@ ) { if ( * ( _BYTE * ) ( @@v4@@ + Number ) == Number ) { @@v5@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; @@v6@@ = * ( _QWORD * * ) ( @@v4@@ + Number ) ; * ( _QWORD * ) ( @@a2@@ + Number ) = @@v6@@ ; if ( @@v6@@ ) * @@v6@@ = @@a2@@ ; * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@v5@@ ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L * * ( _QWORD * ) ( @@a2@@ + Number ) ) ; if ( @@v5@@ <= Number ) * ( _QWORD * ) ( @@a1@@ + Number ) &= __ROL8__ ( Number , @@v5@@ ) ; } } } return Number L ; } @@v7@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( ! @@v7@@ ) return Number L ; @@v8@@ = * ( _QWORD * ) ( @@v7@@ + Number L * * ( int * ) ( @@a2@@ + Number ) ) ; * ( _QWORD * ) ( @@a2@@ + Number ) = @@v8@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) |= Number << @@v8@@ ; return Number L ; }
_BYTE * __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , wchar_t * @@a3@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , Number ) ; }
__int64 __fastcall postorder ( _QWORD * @@a1@@ , __int64 ( __fastcall * @@a2@@ ( ) ( void , bintreet0 ) ) ( __int64 , _QWORD * ) , __int64 @@a3@@ ) { _QWORD * @@v5@@ ; __int64 @@result@@ ; _QWORD * @@v7@@ ; bool @@v8@@ ; while ( Number ) { @@v5@@ = ( _QWORD * ) @@a1@@ [ Number ] ; if ( ! @@v5@@ ) { @@v5@@ = ( _QWORD * ) @@a1@@ [ Number ] ; if ( ! @@v5@@ ) break ; } LABEL_2 : @@a1@@ = @@v5@@ ; } for ( @@result@@ = @@a2@@ ( ) ( void , bintreet0 ) ( @@a3@@ , @@a1@@ ) ; ! ( _DWORD ) @@result@@ ; @@result@@ = @@a2@@ ( ) ( void , bintreet0 ) ( @@a3@@ , @@v7@@ ) ) { @@v7@@ = ( _QWORD * ) * @@a1@@ ; if ( ! * @@a1@@ ) break ; @@v5@@ = ( _QWORD * ) @@v7@@ [ Number ] ; @@v8@@ = @@v5@@ == @@a1@@ ; @@a1@@ = ( _QWORD * ) * @@a1@@ ; if ( @@v5@@ != Number L && ! @@v8@@ ) goto LABEL_2 ; } return @@result@@ ; }
__int64 __fastcall lower_subexps ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; char * @@v5@@ ; char * @@v6@@ ; unsigned int @@v7@@ ; unsigned __int64 @@v8@@ ; @@v2@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@v8@@ = __readfsqword ( Number ) ; @@v7@@ = Number ; if ( @@v2@@ ) { if ( * ( _BYTE * ) ( @@v2@@ + Number ) == Number ) { @@v6@@ = lower_subexp ( & @@v7@@ , @@a1@@ , @@v2@@ ) ; * ( _QWORD * ) ( @@a2@@ + Number ) = @@v6@@ ; if ( @@v6@@ ) * ( _QWORD * ) @@v6@@ = @@a2@@ ; } } @@v3@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( @@v3@@ ) { if ( * ( _BYTE * ) ( @@v3@@ + Number ) == Number ) { @@v5@@ = lower_subexp ( & @@v7@@ , @@a1@@ , @@v3@@ ) ; * ( _QWORD * ) ( @@a2@@ + Number ) = @@v5@@ ; if ( @@v5@@ ) * ( _QWORD * ) @@v5@@ = @@a2@@ ; } } return @@v7@@ ; }
__int64 __fastcall check_node_accept ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int8 @@v4@@ ; __int64 @@result@@ ; unsigned int @@v6@@ ; unsigned int @@v7@@ ; unsigned int @@v8@@ ; unsigned int @@v9@@ ; unsigned int @@v10@@ ; __int64 @@v11@@ ; @@v3@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@a3@@ ) ; @@v4@@ = * ( _BYTE * ) ( @@a2@@ + Number ) ; if ( @@v4@@ == Number ) { @@v11@@ = * ( _QWORD * ) ( * ( _QWORD * ) @@a2@@ + Number * ( ( unsigned __int64 ) ( unsigned __int8 ) @@v3@@ >> Number ) ) ; @@result@@ = Number L ; if ( ! _bittest64 ( & @@v11@@ , @@v3@@ ) ) return @@result@@ ; goto LABEL_9 ; } if ( @@v4@@ <= Number ) { if ( @@v4@@ == Number ) { @@result@@ = Number L ; if ( * ( _BYTE * ) @@a2@@ != ( _BYTE ) @@v3@@ ) return @@result@@ ; goto LABEL_9 ; } return Number L ; } if ( @@v4@@ == Number ) goto LABEL_6 ; if ( @@v4@@ != Number ) return Number L ; @@result@@ = Number L ; if ( ( @@v3@@ & Number ) != Number L ) return @@result@@ ; LABEL_6 : if ( ( _BYTE ) @@v3@@ == Number ) { @@result@@ = Number L ; if ( ( * ( _BYTE * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L ) & Number ) == Number ) return @@result@@ ; } else if ( ! ( _BYTE ) @@v3@@ ) { @@result@@ = Number L ; if ( * ( char * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L ) < Number ) return @@result@@ ; } LABEL_9 : @@v6@@ = * ( _DWORD * ) ( @@a2@@ + Number ) ; @@result@@ = Number L ; if ( ( @@v6@@ & Number ) == Number ) return @@result@@ ; @@v7@@ = @@v6@@ >> Number ; @@v8@@ = re_string_context_at ( @@a1@@ , @@a3@@ , * ( _DWORD * ) ( @@a1@@ + Number ) ) ; @@v9@@ = @@v8@@ ; if ( ( @@v7@@ & Number ) != Number ) { @@result@@ = Number L ; if ( ( @@v9@@ & Number ) == Number || ( @@v7@@ & Number ) != Number ) return @@result@@ ; } else if ( ( @@v7@@ & Number ) != Number && ( @@v8@@ & Number ) != Number ) { return Number L ; } if ( ( @@v7@@ & Number ) == Number || ( @@result@@ = Number L , ( @@v9@@ & Number ) != Number ) ) { @@result@@ = Number L ; @@v10@@ = ( @@v9@@ >> Number ) & Number ; if ( ( @@v7@@ & Number ) != Number ) @@result@@ = @@v10@@ ; } return @@result@@ ; }
__int64 __fastcall merge_state_array ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ ) { __int64 @@v8@@ ; __int64 @@result@@ ; _QWORD * @@v10@@ ; void * @@v11@@ ; __int64 @@v12@@ ; __int64 @@v13@@ ; unsigned int @@v14@@ ; void * @@v15@@ [ Number ] ; @@v15@@ [ Number ] = ( void * ) __readfsqword ( Number ) ; if ( ! @@a4@@ ) return Number L ; @@v8@@ = Number L ; while ( Number ) { while ( Number ) { @@v12@@ = * ( _QWORD * ) ( @@a2@@ + Number * @@v8@@ ) ; @@v13@@ = * ( _QWORD * ) ( @@a3@@ + Number * @@v8@@ ) ; if ( @@v12@@ ) break ; * ( _QWORD * ) ( @@a2@@ + Number * @@v8@@ ++ ) = @@v13@@ ; if ( @@a4@@ == @@v8@@ ) return Number L ; } if ( @@v13@@ ) { @@result@@ = re_node_set_init_union ( @@v15@@ , @@v12@@ + Number , @@v13@@ + Number ) ; @@v14@@ = @@result@@ ; if ( ( _DWORD ) @@result@@ ) break ; @@v10@@ = re_acquire_state ( & @@v14@@ , @@a1@@ , ( __int64 ) @@v15@@ ) ; @@v11@@ = @@v15@@ [ Number ] ; * ( _QWORD * ) ( @@a2@@ + Number * @@v8@@ ) = @@v10@@ ; free ( @@v11@@ ) ; @@result@@ = @@v14@@ ; if ( @@v14@@ ) break ; } if ( @@a4@@ == ++ @@v8@@ ) return Number L ; } return @@result@@ ; }
_QWORD * __fastcall re_node_set_insert ( _QWORD * @@a1@@ , unsigned __int64 @@a2@@ ) { __int64 @@v3@@ ; unsigned __int64 * @@v4@@ ; _QWORD * @@result@@ ; unsigned __int64 * @@v6@@ ; unsigned __int64 @@v7@@ ; unsigned __int64 @@i@@ ; bool @@v9@@ ; if ( * @@a1@@ ) { @@v3@@ = @@a1@@ [ Number ] ; @@v4@@ = ( unsigned __int64 * ) @@a1@@ [ Number ] ; if ( ! @@v3@@ ) { * @@v4@@ = @@a2@@ ; ++ @@a1@@ [ Number ] ; return ( _QWORD * ) ( & dword_0 + Number ) ; } if ( * @@a1@@ != @@v3@@ ) { if ( @@a2@@ < * @@v4@@ ) goto LABEL_8 ; goto LABEL_12 ; } * @@a1@@ = Number * @@v3@@ ; @@v4@@ = ( unsigned __int64 * ) realloc ( @@v4@@ , Number * @@v3@@ ) ; if ( @@v4@@ ) { @@v9@@ = * @@v4@@ <= @@a2@@ ; @@a1@@ [ Number ] = @@v4@@ ; @@v3@@ = @@a1@@ [ Number ] ; if ( ! @@v9@@ ) { if ( ! @@v3@@ ) { LABEL_11 : * ( unsigned __int64 * ) ( ( char * ) @@v4@@ + @@v3@@ ) = @@a2@@ ; @@result@@ = ( _QWORD * ) ( & dword_0 + Number ) ; ++ @@a1@@ [ Number ] ; return @@result@@ ; } LABEL_8 : @@v6@@ = & @@v4@@ [ @@v3@@ ] ; do { @@v7@@ = * -- @@v6@@ ; @@v6@@ [ Number ] = @@v7@@ ; } while ( @@v6@@ != @@v4@@ ) ; @@v3@@ = Number L ; goto LABEL_11 ; } LABEL_12 : @@v3@@ *= Number L ; for ( @@i@@ = * ( unsigned __int64 * ) ( ( char * ) @@v4@@ + @@v3@@ - Number ) ; @@i@@ > @@a2@@ ; @@i@@ = * ( unsigned __int64 * ) ( ( char * ) @@v4@@ + @@v3@@ - Number ) ) { * ( unsigned __int64 * ) ( ( char * ) @@v4@@ + @@v3@@ ) = @@i@@ ; @@v3@@ -= Number L ; } goto LABEL_11 ; } @@result@@ = Number L ; } else { * @@a1@@ = Number L ; @@a1@@ [ Number ] = Number L ; @@result@@ = malloc ( Number ) ; @@a1@@ [ Number ] = @@result@@ ; if ( @@result@@ ) { * @@result@@ = @@a2@@ ; @@result@@ = ( _QWORD * ) ( & dword_0 + Number ) ; } else { @@a1@@ [ Number ] = Number L ; * @@a1@@ = Number L ; } } return @@result@@ ; }
__int64 __fastcall fetch_number ( __int64 * @@a1@@ , unsigned __int8 * @@a2@@ , __int64 @@a3@@ ) { unsigned __int64 @@v4@@ ; unsigned __int8 @@v5@@ ; __int64 @@v6@@ ; @@v4@@ = Number ; while ( Number ) { @@a1@@ [ Number ] += ( int ) peek_token ( @@a2@@ , @@a1@@ , @@a3@@ ) ; @@v5@@ = @@a2@@ [ Number ] ; @@v6@@ = * @@a2@@ ; if ( @@v5@@ == Number ) break ; if ( ( _BYTE ) @@v6@@ == Number || @@v5@@ == Number ) return @@v4@@ ; if ( @@v5@@ != Number || ( unsigned __int8 ) ( @@v6@@ - Number ) > Number || @@v4@@ == Number ) { @@v4@@ = Number ; } else if ( @@v4@@ == Number ) { @@v4@@ = ( unsigned __int8 ) @@v6@@ - Number ; } else { @@v4@@ = @@v6@@ + Number * @@v4@@ - Number ; if ( @@v4@@ >= Number ) @@v4@@ = Number ; } } return Number ; }
__int64 __fastcall pop_fail_stack_isra_26 ( unsigned __int64 * @@a1@@ , _QWORD * @@a2@@ , _QWORD * @@a3@@ , __int64 @@a4@@ , void * @@a5@@ , __int64 @@a6@@ ) { unsigned __int64 @@v6@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; @@v6@@ = * @@a1@@ - Number ; * @@a1@@ = @@v6@@ ; if ( @@v6@@ > Number ) __assert_fail ( String , String , Number , String ) ; @@v8@@ = Number * @@v6@@ ; @@v9@@ = Number * @@v6@@ + * @@a2@@ ; * @@a3@@ = * ( _QWORD * ) @@v9@@ ; memcpy ( @@a5@@ , * ( const void * * ) ( @@v9@@ + Number ) , Number * @@a4@@ ) ; free ( * ( void * * ) ( @@a6@@ + Number ) ) ; free ( * ( void * * ) ( * @@a2@@ + @@v8@@ + Number ) ) ; @@v10@@ = * @@a2@@ + @@v8@@ ; * ( __m128i * ) @@a6@@ = _mm_loadu_si128 ( ( const __m128i * ) ( @@v10@@ + Number ) ) ; * ( _QWORD * ) ( @@a6@@ + Number ) = * ( _QWORD * ) ( @@v10@@ + Number ) ; return * ( _QWORD * ) ( @@v10@@ + Number ) ; }
void __fastcall free_charset ( void * @@ptr@@ ) { free ( * ( void * * ) @@ptr@@ ) ; free ( * ( ( void * * ) @@ptr@@ + Number ) ) ; free ( @@ptr@@ ) ; }
__int64 __fastcall rpl_re_set_syntax ( __int64 @@a1@@ ) { __int64 @@result@@ ; @@result@@ = rpl_re_syntax_options ; rpl_re_syntax_options = @@a1@@ ; return @@result@@ ; }
__int64 __fastcall rpl_re_compile_fastmap ( __int64 @@a1@@ ) { __m128i * @@v1@@ ; _QWORD * @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; @@v1@@ = * ( __m128i * * ) ( @@a1@@ + Number ) ; @@v2@@ = * ( _QWORD * * ) @@a1@@ ; @@v1@@ -> m128i_i64 [ Number ] = Number L ; @@v1@@ [ Number ] . m128i_i64 [ Number ] = Number L ; memset ( ( void * ) ( ( unsigned __int64 ) & @@v1@@ -> m128i_u64 [ Number ] & Number ) , Number , Number L * ( ( ( unsigned int ) @@v1@@ - ( ( ( _DWORD ) @@v1@@ + Number ) & Number ) + Number ) >> Number ) ) ; re_compile_fastmap_iter_isra_32 ( ( __int64 * ) @@a1@@ , ( _QWORD * ) ( @@v2@@ [ Number ] + Number L ) , ( _QWORD * ) ( @@v2@@ [ Number ] + Number L ) , @@v1@@ ) ; @@v3@@ = @@v2@@ [ Number ] ; if ( @@v2@@ [ Number ] != @@v3@@ ) { re_compile_fastmap_iter_isra_32 ( ( __int64 * ) @@a1@@ , ( _QWORD * ) ( @@v3@@ + Number ) , ( _QWORD * ) ( @@v3@@ + Number ) , @@v1@@ ) ; @@v3@@ = @@v2@@ [ Number ] ; } @@v4@@ = @@v2@@ [ Number ] ; if ( @@v4@@ != @@v3@@ ) { re_compile_fastmap_iter_isra_32 ( ( __int64 * ) @@a1@@ , ( _QWORD * ) ( @@v4@@ + Number ) , ( _QWORD * ) ( @@v4@@ + Number ) , @@v1@@ ) ; @@v3@@ = @@v2@@ [ Number ] ; } @@v5@@ = @@v2@@ [ Number ] ; if ( @@v5@@ != @@v3@@ ) re_compile_fastmap_iter_isra_32 ( ( __int64 * ) @@a1@@ , ( _QWORD * ) ( @@v5@@ + Number ) , ( _QWORD * ) ( @@v5@@ + Number ) , @@v1@@ ) ; * ( _BYTE * ) ( @@a1@@ + Number ) |= Number ; return Number L ; }
void __fastcall free_state ( void * @@ptr@@ ) { void * * @@v1@@ ; free ( * ( ( void * * ) @@ptr@@ + Number ) ) ; free ( * ( ( void * * ) @@ptr@@ + Number ) ) ; @@v1@@ = ( void * * ) * ( ( _QWORD * ) @@ptr@@ + Number ) ; if ( @@v1@@ != ( void * * ) ( ( char * ) @@ptr@@ + Number ) ) { free ( @@v1@@ [ Number ] ) ; free ( * ( ( void * * ) @@ptr@@ + Number ) ) ; } free ( * ( ( void * * ) @@ptr@@ + Number ) ) ; free ( * ( ( void * * ) @@ptr@@ + Number ) ) ; free ( * ( ( void * * ) @@ptr@@ + Number ) ) ; free ( @@ptr@@ ) ; }
__int64 __fastcall re_search_2_stub ( __int64 @@a1@@ , const void * @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ , unsigned __int64 @@a6@@ , __int64 @@a7@@ , unsigned __int64 * @@a8@@ , __int64 @@a9@@ , char @@a10@@ ) { unsigned __int64 @@v10@@ ; unsigned __int64 @@v12@@ ; char * @@v13@@ ; __int64 @@v15@@ ; char * @@v17@@ ; const void * @@v18@@ ; @@v10@@ = @@a5@@ + @@a3@@ ; if ( __CFADD__ ( @@a5@@ , @@a3@@ ) ) return Number ; @@v12@@ = @@a6@@ ; if ( ! @@a5@@ ) { @@a4@@ = ( __int64 ) @@a2@@ ; @@v13@@ = Number L ; goto LABEL_4 ; } @@v13@@ = Number L ; if ( @@a3@@ ) { @@v17@@ = ( char * ) malloc ( @@a5@@ + @@a3@@ ) ; @@v13@@ = @@v17@@ ; if ( @@v17@@ ) { memcpy ( @@v17@@ , @@a2@@ , @@a3@@ ) ; @@v18@@ = ( const void * ) @@a4@@ ; @@a4@@ = ( __int64 ) @@v13@@ ; memcpy ( & @@v13@@ [ @@a3@@ ] , @@v18@@ , @@a5@@ ) ; @@v12@@ = @@a6@@ ; goto LABEL_4 ; } return Number ; } LABEL_4 : @@v15@@ = re_search_stub ( @@a1@@ , @@a4@@ , @@v10@@ , @@v12@@ , @@a7@@ , @@a9@@ , @@a8@@ , @@a10@@ ) ; free ( @@v13@@ ) ; return @@v15@@ ; }
__int64 __fastcall rpl_re_search ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ , unsigned __int64 @@a4@@ , __int64 @@a5@@ , unsigned __int64 * @@a6@@ ) { return re_search_stub ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a3@@ , @@a6@@ , Number ) ; }
__int64 __fastcall rpl_re_match ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ , unsigned __int64 @@a4@@ , unsigned __int64 * @@a5@@ ) { return re_search_stub ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , Number L , @@a3@@ , @@a5@@ , Number ) ; }
__int64 __fastcall check_arrival_expand_ecl_sub ( _QWORD * @@a1@@ , _QWORD * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ , unsigned int @@a5@@ ) { __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; unsigned __int64 * @@v12@@ ; __int64 @@result@@ ; while ( Number ) { if ( re_node_set_contains_isra_3 ( @@a2@@ [ Number ] , @@a2@@ + Number , @@a3@@ ) ) return Number L ; @@v8@@ = * @@a1@@ + Number * @@a3@@ ; if ( * ( unsigned __int8 * ) ( @@v8@@ + Number ) == @@a5@@ && * ( _QWORD * ) @@v8@@ == @@a4@@ ) { break ; } if ( ! ( unsigned __int8 ) re_node_set_insert ( @@a2@@ , @@a3@@ ) ) return Number L ; @@v9@@ = Number * @@a3@@ ; @@v10@@ = @@v9@@ + @@a1@@ [ Number ] ; @@v11@@ = * ( _QWORD * ) ( @@v10@@ + Number ) ; if ( ! @@v11@@ ) return Number L ; @@v12@@ = * ( unsigned __int64 * * ) ( @@v10@@ + Number ) ; if ( @@v11@@ == Number ) { @@result@@ = check_arrival_expand_ecl_sub ( @@a1@@ , @@a2@@ , @@v12@@ [ Number ] , @@a4@@ , @@a5@@ ) ; if ( ( _DWORD ) @@result@@ ) return @@result@@ ; @@v12@@ = * ( unsigned __int64 * * ) ( @@a1@@ [ Number ] + @@v9@@ + Number ) ; } @@a3@@ = * @@v12@@ ; } if ( @@a5@@ != Number || ( unsigned __int8 ) re_node_set_insert ( @@a2@@ , @@a3@@ ) ) return Number L ; return Number L ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; __int64 @@v3@@ ; @@result@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) { if ( @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; } return @@result@@ ; }
__int64 __fastcall rpl_re_set_registers ( __int64 @@a1@@ , _QWORD * @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ ) { __int64 @@result@@ ; if ( @@a3@@ ) { @@result@@ = * ( _BYTE * ) ( @@a1@@ + Number ) & Number | Number ; * ( _BYTE * ) ( @@a1@@ + Number ) = * ( _BYTE * ) ( @@a1@@ + Number ) & Number | Number ; * @@a2@@ = @@a3@@ ; @@a2@@ [ Number ] = @@a4@@ ; @@a2@@ [ Number ] = @@a5@@ ; } else { * ( _BYTE * ) ( @@a1@@ + Number ) &= Number ; * @@a2@@ = Number L ; @@a2@@ [ Number ] = Number L ; @@a2@@ [ Number ] = Number L ; } return @@result@@ ; }
void * __fastcall xstrdup ( void * @@src@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( ( const char * ) @@src@@ ) ; return xmemdup ( @@src@@ , @@v1@@ + Number ) ; }
char * __fastcall create_token_tree_isra_18 ( _QWORD * @@a1@@ , int * @@a2@@ , _QWORD * @@a3@@ , _QWORD * @@a4@@ , const __m128i * @@a5@@ ) { int @@v6@@ ; __int64 @@v7@@ ; int @@v8@@ ; _QWORD * @@v9@@ ; __int64 @@v10@@ ; char * @@result@@ ; __m128i * @@v12@@ ; _QWORD * @@v13@@ ; _QWORD * @@v14@@ ; _QWORD * @@v15@@ ; const __m128i * @@v16@@ ; @@v6@@ = * @@a2@@ ; if ( * @@a2@@ == Number ) { @@v16@@ = @@a5@@ ; @@v15@@ = @@a4@@ ; @@v14@@ = @@a3@@ ; @@v9@@ = malloc ( Number ) ; if ( ! @@v9@@ ) return Number L ; @@v13@@ = ( _QWORD * ) * @@a1@@ ; @@v8@@ = Number ; * @@a1@@ = @@v9@@ ; @@v7@@ = Number L ; @@a5@@ = @@v16@@ ; @@a4@@ = @@v15@@ ; @@a3@@ = @@v14@@ ; * @@v9@@ = @@v13@@ ; @@v10@@ = Number L ; } else { @@v7@@ = @@v6@@ ; @@v8@@ = @@v6@@ + Number ; @@v9@@ = ( _QWORD * ) * @@a1@@ ; @@v10@@ = ( ( __int64 ) @@v6@@ << Number ) + Number ; } * @@a2@@ = @@v8@@ ; @@result@@ = ( char * ) @@v9@@ + @@v10@@ ; @@v12@@ = ( __m128i * ) & @@v9@@ [ Number * @@v7@@ ] ; @@v12@@ -> m128i_i64 [ Number ] = Number L ; @@v12@@ [ Number ] . m128i_i64 [ Number ] = ( __int64 ) @@a3@@ ; @@v12@@ [ Number ] . m128i_i64 [ Number ] = ( __int64 ) @@a4@@ ; @@v12@@ [ Number ] = _mm_loadu_si128 ( @@a5@@ ) ; @@v12@@ [ Number ] . m128i_i8 [ Number ] &= Number ; @@v12@@ [ Number ] . m128i_i64 [ Number ] = Number L ; @@v12@@ [ Number ] . m128i_i64 [ Number ] = Number L ; @@v12@@ [ Number ] . m128i_i64 [ Number ] = Number ; if ( @@a3@@ ) * @@a3@@ = @@result@@ ; if ( @@a4@@ ) * @@a4@@ = @@result@@ ; return @@result@@ ; }
__int64 __fastcall dup_safer ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ , char @@a7@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ , @@a7@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@result@@ ; __int64 @@v3@@ ; @@result@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@result@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; return @@result@@ ; }
__int64 __fastcall check_halt_state_context_isra_23 ( __int64 @@a1@@ , __int64 @@a2@@ , _QWORD * @@a3@@ , unsigned __int64 @@a4@@ ) { char @@v6@@ ; __int64 @@v7@@ ; int @@v8@@ ; int @@v9@@ ; int @@v10@@ ; __int64 @@result@@ ; __int64 @@v12@@ ; int @@v13@@ ; @@v6@@ = re_string_context_at ( @@a1@@ , @@a4@@ , * ( _DWORD * ) ( @@a1@@ + Number ) ) ; if ( @@a2@@ ) { @@v7@@ = Number L ; @@v8@@ = @@v6@@ & Number ; @@v9@@ = @@v6@@ & Number ; @@v10@@ = @@v6@@ & Number ; while ( Number ) { @@result@@ = * ( _QWORD * ) ( * @@a3@@ + Number * @@v7@@ ) ; @@v12@@ = * * ( _QWORD * * ) ( @@a1@@ + Number ) + Number * @@result@@ ; @@v13@@ = * ( _DWORD * ) ( @@v12@@ + Number ) >> Number ; if ( * ( _BYTE * ) ( @@v12@@ + Number ) != Number ) goto LABEL_3 ; if ( ( @@v13@@ & Number ) == Number ) return @@result@@ ; if ( ( @@v13@@ & Number ) != Number ) break ; if ( ( @@v13@@ & Number ) == Number ) goto LABEL_9 ; if ( @@v10@@ ) goto LABEL_3 ; if ( ( @@v13@@ & Number ) != Number ) { LABEL_10 : if ( ! @@v9@@ ) goto LABEL_3 ; } LABEL_11 : if ( ( @@v13@@ & Number ) == Number || @@v8@@ ) return @@result@@ ; LABEL_3 : if ( ++ @@v7@@ == @@a2@@ ) return Number L ; } if ( ! @@v10@@ || ( @@v13@@ & Number ) != Number ) goto LABEL_3 ; LABEL_9 : if ( ( @@v13@@ & Number ) != Number ) goto LABEL_10 ; goto LABEL_11 ; } return Number L ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
int __fastcall close_stream ( FILE * @@stream@@ ) { size_t @@v1@@ ; int @@v2@@ ; size_t @@v3@@ ; int @@result@@ ; @@v1@@ = __fpending ( @@stream@@ ) ; @@v2@@ = @@stream@@ -> _flags ; @@v3@@ = @@v1@@ ; @@result@@ = fclose ( @@stream@@ ) ; if ( ( @@v2@@ & Number ) != Number ) { if ( ! @@result@@ ) * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( @@result@@ ) { @@result@@ = Number ; if ( ! @@v3@@ ) @@result@@ = - ( * __errno_location ( ) != Number ) ; } return @@result@@ ; }
char * __fastcall parse_branch ( __int64 * @@a1@@ , __int64 * @@a2@@ , __m128i * @@a3@@ , __int64 @@a4@@ , void * @@a5@@ , _DWORD * @@a6@@ ) { __int64 @@v10@@ ; char * @@v11@@ ; char * @@v12@@ ; __int64 @@v14@@ ; __m128i @@v15@@ ; unsigned __int64 @@v16@@ ; @@v16@@ = __readfsqword ( Number ) ; @@v14@@ = * @@a2@@ ; @@v10@@ = parse_expression ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; @@v11@@ = ( char * ) @@v10@@ ; if ( * @@a6@@ && ! @@v10@@ ) return Number L ; while ( ( @@a3@@ -> m128i_i8 [ Number ] & Number ) != Number && ( @@a3@@ -> m128i_i8 [ Number ] != Number || ! @@a5@@ ) ) { @@v12@@ = ( char * ) parse_expression ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( * @@a6@@ && ! @@v12@@ ) return Number L ; if ( @@v11@@ && @@v12@@ ) { @@v15@@ . m128i_i8 [ Number ] = Number ; @@v11@@ = create_token_tree_isra_18 ( ( _QWORD * ) ( @@v14@@ + Number ) , ( int * ) ( @@v14@@ + Number ) , @@v11@@ , @@v12@@ , & @@v15@@ ) ; if ( ! @@v11@@ ) { * @@a6@@ = Number ; return @@v11@@ ; } } else if ( ! @@v11@@ ) { @@v11@@ = @@v12@@ ; } } return @@v11@@ ; }
__int64 __fastcall rpl_regcomp ( __int64 @@a1@@ , const char * @@a2@@ , int @@a3@@ ) { __int64 @@v4@@ ; void * @@v5@@ ; __int64 @@v6@@ ; char @@v7@@ ; unsigned __int64 @@v8@@ ; unsigned int @@v9@@ ; unsigned int @@v10@@ ; * ( _QWORD * ) @@a1@@ = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; @@v4@@ = ( @@a3@@ & Number ) == Number ? Number L : Number L ; @@v5@@ = malloc ( Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v5@@ ; if ( @@v5@@ ) { @@v6@@ = @@v4@@ | ( @@a3@@ << Number ) & Number ; if ( ( @@a3@@ & Number ) != Number ) { * ( _BYTE * ) ( @@a1@@ + Number ) |= Number ; @@v6@@ = @@v6@@ & Number | Number ; } else { * ( _BYTE * ) ( @@a1@@ + Number ) &= Number ; } @@v7@@ = * ( _BYTE * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _BYTE * ) ( @@a1@@ + Number ) = @@v7@@ & Number | ( Number * ( ( @@a3@@ & Number ) != Number ) ) ; @@v8@@ = strlen ( @@a2@@ ) ; @@v9@@ = re_compile_internal ( @@a1@@ , ( __int64 ) @@a2@@ , @@v8@@ , @@v6@@ ) ; @@v10@@ = @@v9@@ ; if ( @@v9@@ == Number ) { @@v10@@ = Number ; } else if ( ! @@v9@@ ) { rpl_re_compile_fastmap ( @@a1@@ ) ; return @@v10@@ ; } free ( * ( void * * ) ( @@a1@@ + Number ) ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; return @@v10@@ ; } return Number L ; }
__int64 __fastcall rpl_re_search_2 ( __int64 @@a1@@ , const void * @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ , unsigned __int64 @@a6@@ , __int64 @@a7@@ , unsigned __int64 * @@a8@@ , __int64 @@a9@@ ) { return re_search_2_stub ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ , @@a7@@ , @@a8@@ , @@a9@@ , Number ) ; }
__int64 __fastcall umaxtostr ( unsigned __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; @@v2@@ = @@a2@@ + Number ; * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; do { * ( _BYTE * ) -- @@v2@@ = @@a1@@ % Number + Number ; @@a1@@ /= Number ; } while ( @@a1@@ ) ; return @@v2@@ ; }
void * __fastcall xzalloc ( size_t @@n@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@n@@ ) ; }
void * __fastcall xmemdup ( void * @@src@@ , size_t @@n@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@n@@ , @@n@@ ) ; return memcpy ( @@v2@@ , @@src@@ , @@n@@ ) ; }
__int64 __fastcall fd_reopen ( int @@fd2@@ , char * @@file@@ , int @@oflag@@ , unsigned int @@a4@@ ) { int @@v4@@ ; unsigned int @@v5@@ ; int @@v6@@ ; int * @@v7@@ ; int @@v8@@ ; int * @@v9@@ ; @@v4@@ = open ( @@file@@ , @@oflag@@ , @@a4@@ ) ; @@v5@@ = @@v4@@ ; if ( @@fd2@@ != @@v4@@ && @@v4@@ >= Number ) { @@v6@@ = dup2 ( @@v4@@ , @@fd2@@ ) ; @@v7@@ = __errno_location ( ) ; @@v8@@ = * @@v7@@ ; @@v9@@ = @@v7@@ ; close ( @@v5@@ ) ; @@v5@@ = @@v6@@ ; * @@v9@@ = @@v8@@ ; } return @@v5@@ ; }
