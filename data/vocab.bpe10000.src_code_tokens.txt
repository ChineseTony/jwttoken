__int64 __fastcall bad_cast ( __int64 @@int64@@ ) { return @@int64@@ ; }
__int64 __fastcall io_blksize ( __int64 a1 , __int64 a2 , __int64 a3 , __int64 a4 , __int64 a5 , __int64 a6 , int a7 , int a8 , int a9 , int a10 , int a11 , int a12 , int a13 , __int64 @@int64@@ ) { __int64 @@int64@@ ; if ( @@int64@@ <= Number || ( unsigned __int64 ) @@int64@@ > Number || @@int64@@ <= Number ) { @@int64@@ = Number ; } else { @@int64@@ = @@int64@@ ; } return @@int64@@ ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
__int64 __fastcall full_read ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = Number L ; while ( @@int64@@ ) { @@int64@@ = safe_read ( @@unsignedint@@ , @@int64@@ , @@int64@@ ) ; if ( @@int64@@ == Number ) break ; if ( ! @@int64@@ ) { * __errno_location ( ) = Number ; return @@int64@@ ; } @@int64@@ += @@int64@@ ; @@int64@@ += @@int64@@ ; @@int64@@ -= @@int64@@ ; } return @@int64@@ ; }
__int64 __fastcall bytes_split ( unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { const char * @@constchar@@ ; int * @@int@@ ; __int64 @@int64@@ ; char @@char@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; @@char@@ = Number ; @@unsignedint64@@ = @@unsignedint64@@ ; do { @@int64@@ = full_read ( Number L , @@int64@@ , @@int64@@ ) ; if ( @@int64@@ == Number ) { @@constchar@@ = infile ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , String , @@constchar@@ ) ; } @@int64@@ = @@int64@@ ; @@unsignedint64@@ = @@int64@@ ; while ( @@unsignedint64@@ >= @@unsignedint64@@ ) { cwrite ( @@char@@ , @@int64@@ , @@unsignedint64@@ ) ; @@int64@@ += @@unsignedint64@@ ; @@unsignedint64@@ -= @@unsignedint64@@ ; @@char@@ = Number ; @@unsignedint64@@ = @@unsignedint64@@ ; } if ( @@unsignedint64@@ ) { cwrite ( @@char@@ , @@int64@@ , @@unsignedint64@@ ) ; @@unsignedint64@@ -= @@unsignedint64@@ ; @@char@@ = Number ; } @@int64@@ = @@int64@@ ; } while ( @@int64@@ == @@int64@@ ) ; return @@int64@@ ; }
__int64 __fastcall lines_split ( unsigned __int64 @@unsignedint64@@ , char * @@char@@ , __int64 @@int64@@ ) { const char * @@constchar@@ ; int * @@int@@ ; __int64 @@int64@@ ; char @@char@@ ; void * @@void@@ ; char * @@char@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; char * @@char@@ ; @@char@@ = Number ; @@int64@@ = Number L ; do { @@int64@@ = full_read ( Number L , @@char@@ , @@int64@@ ) ; if ( @@int64@@ == Number ) { @@constchar@@ = infile ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , String , @@constchar@@ ) ; } @@int64@@ = ( __int64 ) @@char@@ ; @@void@@ = @@char@@ ; @@char@@ = & @@char@@ [ @@int64@@ ] ; @@char@@ [ @@int64@@ ] = Number ; while ( Number ) { @@char@@ = ( char * ) memchr ( @@void@@ , Number , @@char@@ - ( _BYTE * ) @@void@@ + Number ) ; if ( @@char@@ == @@char@@ ) break ; @@void@@ = @@char@@ + Number ; if ( ++ @@int64@@ >= @@unsignedint64@@ ) { cwrite ( @@char@@ , @@int64@@ , ( __int64 ) @@void@@ - @@int64@@ ) ; @@int64@@ = ( __int64 ) @@void@@ ; @@char@@ = Number ; @@int64@@ = Number L ; } } if ( @@char@@ != ( char * ) @@int64@@ ) { cwrite ( @@char@@ , @@int64@@ , ( __int64 ) & @@char@@ [ - @@int64@@ ] ) ; @@char@@ = Number ; } @@int64@@ = @@int64@@ ; } while ( @@int64@@ == @@int64@@ ) ; return @@int64@@ ; }
__int64 __fastcall full_write ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = Number L ; while ( @@int64@@ ) { @@int64@@ = safe_write ( @@unsignedint@@ , @@int64@@ , @@int64@@ ) ; if ( @@int64@@ == Number ) break ; if ( ! @@int64@@ ) { * __errno_location ( ) = Number ; return @@int64@@ ; } @@int64@@ += @@int64@@ ; @@int64@@ += @@int64@@ ; @@int64@@ -= @@int64@@ ; } return @@int64@@ ; }
void __fastcall line_bytes_split ( __int64 @@int64@@ ) { const char * @@constchar@@ ; int * @@int@@ ; char @@char@@ ; _BYTE * @@BYTE@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; _BYTE * @@BYTE@@ ; __int64 @@int64@@ ; @@char@@ = Number ; @@sizet@@ = Number L ; @@BYTE@@ = ( _BYTE * ) xmalloc ( @@int64@@ ) ; do { @@int64@@ = full_read ( Number L , & @@BYTE@@ [ @@sizet@@ ] , @@int64@@ - @@sizet@@ ) ; if ( @@int64@@ == Number ) { @@constchar@@ = infile ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , String , @@constchar@@ ) ; } @@sizet@@ = @@int64@@ + @@sizet@@ ; if ( @@sizet@@ != @@int64@@ ) { if ( ! @@sizet@@ ) break ; @@char@@ = Number ; } @@BYTE@@ = & @@BYTE@@ [ @@sizet@@ ] ; if ( @@sizet@@ == @@int64@@ ) { while ( @@BYTE@@ > @@BYTE@@ && * ( @@BYTE@@ - Number ) != Number ) -- @@BYTE@@ ; } if ( @@BYTE@@ == @@BYTE@@ ) @@BYTE@@ = & @@BYTE@@ [ @@sizet@@ ] ; cwrite ( Number , ( __int64 ) @@BYTE@@ , @@BYTE@@ - @@BYTE@@ ) ; @@sizet@@ = @@sizet@@ - ( @@BYTE@@ - @@BYTE@@ ) ; if ( @@sizet@@ ) memmove ( @@BYTE@@ , @@BYTE@@ , @@sizet@@ ) ; } while ( @@char@@ != Number ) ; free ( @@BYTE@@ ) ; }
bool __fastcall is_basic ( unsigned __int8 @@unsignedint8@@ ) { return ( ( * ( ( _DWORD * ) & is_basic_table + ( @@unsignedint8@@ >> Number ) ) >> ( @@unsignedint8@@ & Number ) ) & Number ) != Number ; }
__int64 __fastcall strnlen1 ( const void * @@constvoid@@ , size_t @@sizet@@ ) { __int64 @@int64@@ ; _BYTE * @@BYTE@@ ; @@BYTE@@ = memchr ( @@constvoid@@ , Number , @@sizet@@ ) ; if ( @@BYTE@@ ) @@int64@@ = @@BYTE@@ - ( _BYTE * ) @@constvoid@@ + Number ; else @@int64@@ = @@sizet@@ ; return @@int64@@ ; }
char * __fastcall proper_name_utf8 ( const char * @@constchar@@ , __int64 @@int64@@ ) { char * @@char@@ ; char * @@char@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; char * @@char@@ ; char * @@char@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; size_t @@sizet@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; @@char@@ = ( char * ) locale_charset ( ) ; @@char@@ = Number L ; @@char@@ = Number L ; @@int64@@ = Number L ; if ( ( unsigned int ) c_strcasecmp ( @@char@@ , String ) ) { @@char@@ = ( char * ) xstr_iconv ( @@int64@@ , String , @@char@@ ) ; @@int64@@ = ( __int64 ) @@char@@ ; @@sizet@@ = strlen ( @@char@@ ) ; @@char@@ = ( char * ) xmalloc ( @@sizet@@ + Number ) ; memcpy ( @@char@@ , @@char@@ , @@sizet@@ ) ; memcpy ( & @@char@@ [ @@sizet@@ ] , String , Number ) ; @@char@@ = ( char * ) xstr_iconv ( @@int64@@ , String , @@char@@ ) ; free ( @@char@@ ) ; if ( @@char@@ ) { if ( strchr ( @@char@@ , Number ) ) { free ( @@char@@ ) ; } else { @@char@@ = @@char@@ ; @@int64@@ = ( __int64 ) @@char@@ ; } } } else { @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; } if ( @@int64@@ ) { @@char@@ = ( char * ) @@int64@@ ; } else if ( @@int64@@ ) { @@char@@ = ( char * ) @@int64@@ ; } else { @@char@@ = ( char * ) @@constchar@@ ; } @@char@@ = @@char@@ ; if ( ! strcmp ( @@char@@ , @@constchar@@ ) ) { if ( @@char@@ && @@char@@ != @@char@@ ) free ( @@char@@ ) ; if ( @@char@@ && @@char@@ != @@char@@ ) free ( @@char@@ ) ; @@char@@ = @@char@@ ; } else if ( ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@char@@ , ( __int64 ) @@constchar@@ ) || @@int64@@ && ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@char@@ , @@int64@@ ) || @@int64@@ && ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@char@@ , @@int64@@ ) ) { if ( @@char@@ ) free ( @@char@@ ) ; if ( @@char@@ ) free ( @@char@@ ) ; @@char@@ = @@char@@ ; } else { @@sizet@@ = strlen ( @@char@@ ) ; @@sizet@@ = strlen ( @@char@@ ) ; @@char@@ = ( char * ) xmalloc ( @@sizet@@ + @@sizet@@ + Number ) ; sprintf ( @@char@@ , String , @@char@@ , @@char@@ ) ; if ( @@char@@ ) free ( @@char@@ ) ; if ( @@char@@ ) free ( @@char@@ ) ; @@char@@ = @@char@@ ; } return @@char@@ ; }
bool __fastcall is_basic_0 ( unsigned __int8 @@unsignedint8@@ ) { return ( ( * ( ( _DWORD * ) & is_basic_table + ( @@unsignedint8@@ >> Number ) ) >> ( @@unsignedint8@@ & Number ) ) & Number ) != Number ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall xstr_cd_iconv ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = str_cd_iconv ( @@int64@@ , @@int64@@ ) ; if ( ! @@int64@@ && * __errno_location ( ) == Number ) xalloc_die ( ) ; return @@int64@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_20E108 ; @@int648@@ [ Number ] = qword_20E110 ; @@int648@@ [ Number ] = qword_20E118 ; @@int648@@ [ Number ] = qword_20E120 ; @@int648@@ [ Number ] = qword_20E128 ; @@int648@@ [ Number ] = qword_20E130 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
__int64 __fastcall xstr_iconv ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = str_iconv ( @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( ! @@int64@@ && * __errno_location ( ) == Number ) xalloc_die ( ) ; return @@int64@@ ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@unsignedint64@@ , int @@int@@ ) { __int64 @@int64@@ ; if ( is_mul_ok ( @@int@@ , * @@unsignedint64@@ ) ) { * @@unsignedint64@@ *= @@int@@ ; @@int64@@ = Number L ; } else { * @@unsignedint64@@ = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall bkm_scale_by_power ( unsigned __int64 * @@unsignedint64@@ , int @@int@@ , int @@int@@ ) { unsigned int @@unsignedint@@ ; for ( @@unsignedint@@ = Number ; @@int@@ -- ; @@unsignedint@@ |= bkm_scale ( @@unsignedint64@@ , @@int@@ ) ) { ; } return @@unsignedint@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
__int64 __fastcall x2nrealloc ( __int64 @@int64@@ , unsigned __int64 * @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = * @@unsignedint64@@ ; if ( @@int64@@ ) { if ( @@unsignedint64@@ >= Number / @@unsignedint64@@ ) xalloc_die ( ) ; @@unsignedint64@@ += ( @@unsignedint64@@ + Number ) >> Number ; } else if ( ! @@unsignedint64@@ ) { @@unsignedint64@@ = ( Number / @@unsignedint64@@ == Number ) + Number / @@unsignedint64@@ ; } * @@unsignedint64@@ = @@unsignedint64@@ ; return xrealloc ( @@int64@@ , @@unsignedint64@@ * @@unsignedint64@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
__int64 __fastcall open_safer ( const char * @@constchar@@ , char @@char@@ , unsigned int @@unsignedint@@ ) { unsigned int @@unsignedint@@ ; unsigned int @@unsignedint@@ ; @@unsignedint@@ = Number ; if ( ( @@char@@ & Number ) != Number ) @@unsignedint@@ = @@unsignedint@@ ; @@unsignedint@@ = open ( @@constchar@@ , @@char@@ , @@unsignedint@@ ) ; return fd_safer ( @@unsignedint@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
char * __fastcall str_iconv ( char * @@char@@ , char * @@char@@ , char * @@char@@ ) { char * @@char@@ ; int @@int@@ ; int @@int@@ ; iconv_t @@iconvt@@ ; void * @@void@@ ; char * @@char@@ ; if ( * @@char@@ && ( unsigned int ) c_strcasecmp ( ( unsigned __int8 * ) @@char@@ , ( unsigned __int8 * ) @@char@@ ) ) { @@iconvt@@ = iconv_open ( @@char@@ , @@char@@ ) ; if ( @@iconvt@@ == ( iconv_t ) Number ) return Number L ; @@void@@ = str_cd_iconv ( @@char@@ , @@iconvt@@ ) ; if ( @@void@@ ) { if ( iconv_close ( @@iconvt@@ ) < Number ) { @@int@@ = * __errno_location ( ) ; free ( @@void@@ ) ; * __errno_location ( ) = @@int@@ ; return Number L ; } } else { @@int@@ = * __errno_location ( ) ; iconv_close ( @@iconvt@@ ) ; * __errno_location ( ) = @@int@@ ; } @@char@@ = ( char * ) @@void@@ ; } else { @@char@@ = strdup ( @@char@@ ) ; if ( ! @@char@@ ) * __errno_location ( ) = Number ; @@char@@ = @@char@@ ; } return @@char@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
__int64 __fastcall bkm_scale_0 ( unsigned __int64 * @@unsignedint64@@ , int @@int@@ ) { __int64 @@int64@@ ; if ( is_mul_ok ( @@int@@ , * @@unsignedint64@@ ) ) { * @@unsignedint64@@ *= @@int@@ ; @@int64@@ = Number L ; } else { * @@unsignedint64@@ = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
size_t __fastcall mbslen ( const char * @@constchar@@ ) { __int64 @@int64@@ ; char @@char4@@ [ Number ] ; int @@int@@ ; char @@char@@ ; const char * @@constchar@@ ; __int64 @@int64@@ ; char @@char@@ ; int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( __ctype_get_mb_cur_max ( ) <= Number ) return strlen ( @@constchar@@ ) ; @@int64@@ = Number L ; @@constchar@@ = @@constchar@@ ; @@char4@@ [ Number ] = Number ; memset ( & @@int@@ , Number , Number ) ; for ( @@char@@ = Number ; ; @@char@@ = Number ) { mbuiter_multi_next_1 ( ( __int64 ) @@char4@@ ) ; if ( @@char@@ == Number && ! @@int@@ ) break ; ++ @@int64@@ ; @@constchar@@ += @@int64@@ ; } return @@int64@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_20E038 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
__int64 __fastcall knuth_morris_pratt_unibyte ( _BYTE * @@BYTE@@ , char * @@char@@ , _QWORD * @@QWORD@@ ) { void * @@void@@ ; unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; char * @@char@@ ; _BYTE * @@BYTE@@ ; char @@char@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; size_t @@sizet@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@BYTE@@ = @@BYTE@@ ; @@char@@ = @@char@@ ; @@QWORD@@ = @@QWORD@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@sizet@@ = strlen ( @@char@@ ) ; if ( @@sizet@@ > Number ) { @@unsignedint64@@ = Number L ; } else if ( Number * @@sizet@@ > Number ) { @@unsignedint64@@ = mmalloca ( Number * @@sizet@@ ) ; } else { @@void@@ = alloca ( Number * ( ( Number * ( @@sizet@@ + Number ) + Number ) / Number ) ) ; @@unsignedint64@@ = Number * ( ( ( unsigned __int64 ) & @@QWORD@@ + Number ) >> Number ) + Number ; } @@unsignedint64@@ = @@unsignedint64@@ ; if ( ! @@unsignedint64@@ ) return Number L ; * ( _QWORD * ) ( @@unsignedint64@@ + Number ) = Number L ; @@int64@@ = Number L ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@sizet@@ ; ++ @@unsignedint64@@ ) { @@char@@ = @@char@@ [ @@unsignedint64@@ - Number ] ; while ( Number ) { if ( @@char@@ == @@char@@ [ @@int64@@ ] ) { ++ @@int64@@ ; * ( _QWORD * ) ( @@unsignedint64@@ + Number * @@unsignedint64@@ ) = @@unsignedint64@@ - @@int64@@ ; goto LABEL_15 ; } if ( ! @@int64@@ ) break ; @@int64@@ -= * ( _QWORD * ) ( Number * @@int64@@ + @@unsignedint64@@ ) ; } * ( _QWORD * ) ( @@unsignedint64@@ + Number * @@unsignedint64@@ ) = @@unsignedint64@@ ; LABEL_15 : ; } * @@QWORD@@ = Number L ; @@int64@@ = Number L ; @@BYTE@@ = @@BYTE@@ ; @@BYTE@@ = @@BYTE@@ ; while ( * @@BYTE@@ ) { if ( @@char@@ [ @@int64@@ ] == * @@BYTE@@ ) { ++ @@int64@@ ; ++ @@BYTE@@ ; if ( @@int64@@ == @@sizet@@ ) { * @@QWORD@@ = @@BYTE@@ ; break ; } } else if ( @@int64@@ ) { @@BYTE@@ += * ( _QWORD * ) ( Number * @@int64@@ + @@unsignedint64@@ ) ; @@int64@@ -= * ( _QWORD * ) ( Number * @@int64@@ + @@unsignedint64@@ ) ; } else { ++ @@BYTE@@ ; ++ @@BYTE@@ ; } } freea ( @@unsignedint64@@ ) ; return Number L ; }
__int64 __fastcall compile_regex ( __int64 @@int64@@ ) { void * @@void@@ ; size_t @@sizet@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; @@int64@@ = @@int64@@ + Number ; @@char@@ = * ( char * * ) @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ + Number ; if ( ignore_case ) @@void@@ = & folded_chars ; else @@void@@ = Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@void@@ ; @@sizet@@ = strlen ( @@char@@ ) ; @@int64@@ = rpl_re_compile_pattern ( @@char@@ , @@sizet@@ , @@int64@@ ) ; if ( @@int64@@ ) { @@int64@@ = quote ( @@char@@ ) ; @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ , @@int64@@ , @@int64@@ ) ; } return rpl_re_compile_fastmap ( @@int64@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ ) { return xmalloc ( @@int64@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
__int64 __fastcall xnrealloc ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { if ( ! is_mul_ok ( @@unsignedint64@@ , @@unsignedint64@@ ) ) xalloc_die ( ) ; return xrealloc ( @@int64@@ , @@unsignedint64@@ * @@unsignedint64@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
__int64 __fastcall fd_reopen ( int @@int@@ , const char * @@constchar@@ , int @@int@@ , unsigned int @@unsignedint@@ ) { int @@int@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; @@int@@ = open ( @@constchar@@ , @@int@@ , @@unsignedint@@ ) ; if ( @@int@@ == @@int@@ || @@int@@ < Number ) return ( unsigned int ) @@int@@ ; @@unsignedint@@ = dup2 ( @@int@@ , @@int@@ ) ; @@int@@ = * __errno_location ( ) ; close ( @@int@@ ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint@@ ; }
unsigned __int64 __fastcall swallow_file_in_memory ( const char * @@constchar@@ , _QWORD * @@QWORD@@ ) { bool @@bool@@ ; int @@int@@ ; int * @@int@@ ; int * @@int@@ ; int * @@int@@ ; int * @@int@@ ; int * @@int@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; ssize_t @@ssizet@@ ; struct stat @@structstat@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@bool@@ = ! @@constchar@@ || ! * @@constchar@@ || ! strcmp ( @@constchar@@ , String ) ; @@bool@@ = @@bool@@ ; if ( @@bool@@ ) { @@int@@ = Number ; @@int@@ = fstat ( Number , & @@structstat@@ ) ; } else { @@int@@ = open ( @@constchar@@ , Number ) ; if ( @@int@@ < Number ) { @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , String , @@constchar@@ ) ; } @@int@@ = fstat ( @@int@@ , & @@structstat@@ ) ; } if ( @@int@@ < Number ) { @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , String , @@constchar@@ ) ; } if ( ( @@structstat@@ . st_mode & Number ) == Number ) { * @@QWORD@@ = xmalloc ( @@structstat@@ . st_size ) ; @@ssizet@@ = read ( @@int@@ , ( void * ) * @@QWORD@@ , @@structstat@@ . st_size ) ; if ( @@ssizet@@ != @@structstat@@ . st_size ) { @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , String , @@constchar@@ ) ; } @@QWORD@@ [ Number ] = @@ssizet@@ + * @@QWORD@@ ; } else { * @@QWORD@@ = xmalloc ( Number L ) ; @@int64@@ = Number L ; @@int64@@ = Number L ; while ( Number ) { @@int@@ = read ( @@int@@ , ( void * ) ( @@int64@@ + * @@QWORD@@ ) , @@int64@@ - @@int64@@ ) ; if ( @@int@@ <= Number ) break ; @@int64@@ += @@int@@ ; if ( @@int64@@ == @@int64@@ ) { @@int64@@ += Number L ; * @@QWORD@@ = xrealloc ( * @@QWORD@@ , @@int64@@ ) ; } } if ( @@int@@ < Number ) { @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , String , @@constchar@@ ) ; } @@QWORD@@ [ Number ] = @@int64@@ + * @@QWORD@@ ; } if ( ! @@bool@@ && close ( @@int@@ ) ) { @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , String , @@constchar@@ ) ; } return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
const char * locale_charset ( ) { const char * @@constchar@@ ; char * @@char@@ ; char * @@char@@ ; @@constchar@@ = nl_langinfo ( Number ) ; if ( ! @@constchar@@ ) @@constchar@@ = ( const char * ) & unk_B60E ; for ( @@char@@ = ( char * ) get_charset_aliases ( ) ; * @@char@@ ; @@char@@ = & @@char@@ [ strlen ( @@char@@ ) + Number ] ) { if ( ! strcmp ( @@constchar@@ , @@char@@ ) || * @@char@@ == Number && ! @@char@@ [ Number ] ) { @@constchar@@ = & @@char@@ [ strlen ( @@char@@ ) + Number ] ; break ; } @@char@@ = & @@char@@ [ strlen ( @@char@@ ) + Number ] ; } if ( ! * @@constchar@@ ) @@constchar@@ = String ; return @@constchar@@ ; }
unsigned __int64 fix_output_parameters ( ) { int @@int@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; unsigned __int8 * @@unsignedint8@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( auto_reference ) { reference_max_width = Number ; for ( @@int@@ = Number ; @@int@@ < number_input_files ; ++ @@int@@ ) { @@unsignedint@@ = * ( _DWORD * ) ( Number L * @@int@@ + file_line_count ) + Number ; if ( @@int@@ > Number ) @@unsignedint@@ -= * ( _DWORD * ) ( Number L * @@int@@ - Number + file_line_count ) ; sprintf ( @@char@@ , String , @@unsignedint@@ ) ; @@int@@ = strlen ( @@char@@ ) ; if ( * ( _QWORD * ) ( Number L * @@int@@ + input_file_name ) ) @@int@@ += strlen ( * ( const char * * ) ( Number L * @@int@@ + input_file_name ) ) ; if ( @@int@@ > reference_max_width ) reference_max_width = @@int@@ ; } reference = ( char * ) xmalloc ( ++ reference_max_width + Number L ) ; } if ( ( auto_reference || input_reference ) && right_reference != Number ) line_width -= reference_max_width + gap_size ; half_line_width = line_width / Number ; before_max_width = line_width / Number - gap_size ; keyafter_max_width = line_width / Number ; if ( truncation_string && * truncation_string ) truncation_string_length = strlen ( truncation_string ) ; else truncation_string = Number L ; if ( gnu_extensions ) { before_max_width -= Number * truncation_string_length ; if ( before_max_width < Number ) before_max_width = Number ; keyafter_max_width -= Number * truncation_string_length ; } else { keyafter_max_width -= Number * truncation_string_length + Number ; } for ( @@int@@ = Number ; @@int@@ <= Number ; ++ @@int@@ ) edited_flag [ @@int@@ ] = ( ( * __ctype_b_loc ( ) ) [ @@int@@ ] & Number ) != Number ; byte_2296CC = Number ; if ( output_format == Number ) { byte_2296E2 = Number ; } else if ( ( unsigned int ) output_format >= Number && output_format == Number ) { for ( @@unsignedint8@@ = String ; * @@unsignedint8@@ ; ++ @@unsignedint8@@ ) edited_flag [ ( unsigned __int8 ) to_uchar ( * @@unsignedint8@@ ) ] = Number ; for ( @@int@@ = Number ; @@int@@ <= Number ; ++ @@int@@ ) edited_flag [ @@int@@ ] = diacrit_diac [ ( unsigned __int8 ) @@int@@ ] != Number ; } return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall umaxtostr ( unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = @@int64@@ + Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = Number ; do { * ( _BYTE * ) -- @@int64@@ = @@unsignedint64@@ % Number + Number ; @@unsignedint64@@ /= Number ; } while ( @@unsignedint64@@ ) ; return @@int64@@ ; }
__int64 __fastcall c_tolower ( int @@int@@ ) { __int64 @@int64@@ ; if ( @@int@@ <= Number || @@int@@ > Number ) @@int64@@ = ( unsigned int ) @@int@@ ; else @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; return @@int64@@ ; }
bool __fastcall is_basic_0 ( unsigned __int8 @@unsignedint8@@ ) { return ( ( is_basic_table [ @@unsignedint8@@ >> Number ] >> ( @@unsignedint8@@ & Number ) ) & Number ) != Number ; }
unsigned __int64 __fastcall mmalloca ( unsigned __int64 @@unsignedint64@@ ) { char * @@char@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@unsignedint64@@ + Number < @@unsignedint64@@ ) return Number L ; @@char@@ = ( char * ) malloc ( @@unsignedint64@@ + Number ) ; if ( ! @@char@@ ) return Number L ; @@unsignedint64@@ = ( unsigned __int64 ) ( @@char@@ + Number ) ; * ( _DWORD * ) ( @@unsignedint64@@ - Number ) = Number ; * ( _QWORD * ) ( @@unsignedint64@@ - Number ) = mmalloca_results [ @@unsignedint64@@ % Number ] ; mmalloca_results [ @@unsignedint64@@ % Number ] = @@unsignedint64@@ ; return @@unsignedint64@@ ; }
bool __fastcall is_basic_1 ( unsigned __int8 @@unsignedint8@@ ) { return ( ( * ( ( _DWORD * ) & is_basic_table + ( @@unsignedint8@@ >> Number ) ) >> ( @@unsignedint8@@ & Number ) ) & Number ) != Number ; }
__int64 __fastcall c_toupper ( int @@int@@ ) { __int64 @@int64@@ ; if ( @@int@@ <= Number || @@int@@ > Number ) @@int64@@ = ( unsigned int ) @@int@@ ; else @@int64@@ = ( unsigned int ) ( @@int@@ - Number ) ; return @@int64@@ ; }
int __fastcall argmatch_valid ( __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { char * @@char@@ ; __int64 @@int64@@ ; void * @@void@@ ; @@void@@ = Number L ; @@char@@ = gettext ( String ) ; fprintf ( stderr , @@char@@ ) ; for ( @@int64@@ = Number L ; * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; ++ @@int64@@ ) { if ( @@int64@@ && ! memcmp ( @@void@@ , ( const void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) , @@sizet@@ ) ) { fprintf ( stderr , String , * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) ) ; } else { fprintf ( stderr , String , * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) ) ; @@void@@ = ( void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) ; } } return putc_unlocked ( Number , stderr ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
bool __fastcall is_basic_2 ( unsigned __int8 @@unsignedint8@@ ) { return ( ( * ( ( _DWORD * ) & is_basic_table + ( @@unsignedint8@@ >> Number ) ) >> ( @@unsignedint8@@ & Number ) ) & Number ) != Number ; }
void __fastcall freea ( unsigned __int64 @@unsignedint64@@ ) { _QWORD * @@QWORD@@ ; if ( @@unsignedint64@@ && * ( _DWORD * ) ( @@unsignedint64@@ - Number ) == Number ) { for ( @@QWORD@@ = & mmalloca_results [ @@unsignedint64@@ % Number ] ; * @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) ( * @@QWORD@@ - Number L ) ) { if ( @@unsignedint64@@ == * @@QWORD@@ ) { * @@QWORD@@ = * ( _QWORD * ) ( @@unsignedint64@@ - Number ) ; free ( ( void * ) ( @@unsignedint64@@ - Number ) ) ; return ; } } } }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall _xargmatch_internal ( __int64 @@int64@@ , const char * @@constchar@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ , void ( * @ @ VAR_615 @ @ void ( ) ( void ) @ @ argmatchexitfn ) ( void ) ) { __int64 @@int64@@ ; @@int64@@ = argmatch ( @@constchar@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; if ( @@int64@@ >= Number ) return @@int64@@ ; argmatch_invalid ( @@int64@@ , ( __int64 ) @@constchar@@ , @@int64@@ ) ; argmatch_valid ( @@int64@@ , @@int64@@ , @@sizet@@ ) ; @ @ VAR_615 @ @ void ( ) ( void ) @ @ argmatchexitfn ( ) ; return Number ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
__int64 __fastcall mem_cd_iconv ( char * @@char@@ , size_t @@sizet@@ , void * @@void@@ , void * * @@void@@ , size_t * @@sizet@@ ) { int @@int@@ ; char * @@char@@ ; size_t @@sizet@@ ; char * @@char@@ ; size_t @@sizet@@ ; void * @@void@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; char @@char@@ $D1F1B2789FC85C59BE59CF61C76BFA1E [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; iconv ( @@void@@ , Number L , Number L , Number L , Number L ) ; @@sizet@@ = Number L ; @@char@@ = @@char@@ ; @@sizet@@ = @@sizet@@ ; while ( @@sizet@@ ) { @@char@@ = @@char@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; @@sizet@@ = Number L ; @@sizet@@ = iconv ( @@void@@ , & @@char@@ , & @@sizet@@ , & @@char@@ , & @@sizet@@ ) ; if ( @@sizet@@ == Number && * __errno_location ( ) != Number ) { if ( * __errno_location ( ) != Number ) return Number ; break ; } @@sizet@@ += @@char@@ - @@char@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; } @@char@@ = @@char@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; @@sizet@@ = Number L ; @@sizet@@ = iconv ( @@void@@ , Number L , Number L , & @@char@@ , & @@sizet@@ ) ; if ( @@sizet@@ == Number ) return Number ; @@sizet@@ += @@char@@ - @@char@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; @@sizet@@ = @@sizet@@ ; if ( ! @@sizet@@ ) { * @@sizet@@ = Number L ; return Number L ; } if ( * @@void@@ && @@sizet@@ <= * @@sizet@@ ) { @@void@@ = * @@void@@ ; } else { @@void@@ = malloc ( @@sizet@@ ) ; if ( ! @@void@@ ) { * __errno_location ( ) = Number ; return Number ; } } iconv ( @@void@@ , Number L , Number L , Number L , Number L ) ; @@char@@ = @@char@@ ; @@sizet@@ = @@sizet@@ ; @@char@@ = ( char * ) @@void@@ ; @@sizet@@ = @@sizet@@ ; while ( @@sizet@@ ) { @@sizet@@ = iconv ( @@void@@ , & @@char@@ , & @@sizet@@ , & @@char@@ , & @@sizet@@ ) ; if ( @@sizet@@ == Number ) { if ( * __errno_location ( ) != Number ) goto LABEL_26 ; break ; } } @@sizet@@ = iconv ( @@void@@ , Number L , Number L , & @@char@@ , & @@sizet@@ ) ; if ( @@sizet@@ != Number ) { if ( @@sizet@@ ) abort ( ) ; * @@void@@ = @@void@@ ; * @@sizet@@ = @@sizet@@ ; return Number L ; } LABEL_26 : if ( @@void@@ != * @@void@@ ) { @@int@@ = * __errno_location ( ) ; free ( @@void@@ ) ; * __errno_location ( ) = @@int@@ ; } return Number ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 __fastcall rpl_fcntl ( int @@int@@ , int @@int@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ ) { int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; if ( @@int@@ != Number ) return ( unsigned int ) fcntl ( @@int@@ , @@int@@ , @@int64@@ ) ; @@int@@ = @@int64@@ ; if ( have_dupfd_cloexec_2895 < Number ) { @@int@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@int@@ , Number , @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ ) ; } else { @@int@@ = fcntl ( @@int@@ , Number , ( unsigned int ) @@int64@@ ) ; if ( @@int@@ < Number && * __errno_location ( ) == Number ) { @@int@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@int@@ , Number , @@int@@ , @@int@@ , @@int@@ , @@int@@ ) ; if ( @@int@@ < Number ) return ( unsigned int ) @@int@@ ; have_dupfd_cloexec_2895 = Number ; } else { have_dupfd_cloexec_2895 = Number ; } } if ( @@int@@ >= Number && have_dupfd_cloexec_2895 == Number ) { @@int@@ = fcntl ( @@int@@ , Number ) ; if ( @@int@@ < Number || fcntl ( @@int@@ , Number , @@int@@ | Number ) == Number ) { @@int@@ = * __errno_location ( ) ; close ( @@int@@ ) ; * __errno_location ( ) = @@int@@ ; @@int@@ = Number ; } } return ( unsigned int ) @@int@@ ; }
FILE * __fastcall freopen_safer ( const char * @@constchar@@ , const char * @@constchar@@ , FILE * @@FILE@@ ) { int @@int@@ ; FILE * @@FILE@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; int @@int@@ ; @@char@@ = Number ; @@char@@ = Number ; @@char@@ = Number ; @@int@@ = fileno ( @@FILE@@ ) ; if ( @@int@@ != Number ) { if ( @@int@@ != Number ) { if ( ! @@int@@ ) goto LABEL_10 ; if ( dup2 ( Number , Number ) != Number ) @@char@@ = Number ; } if ( dup2 ( Number , Number ) != Number ) @@char@@ = Number ; } if ( dup2 ( Number , Number ) ) @@char@@ = Number ; LABEL_10 : if ( @@char@@ && ( unsigned __int8 ) protect_fd ( Number ) != Number ) { @@FILE@@ = Number L ; } else if ( @@char@@ && ( unsigned __int8 ) protect_fd ( Number ) != Number ) { @@FILE@@ = Number L ; } else if ( @@char@@ && ( unsigned __int8 ) protect_fd ( Number ) != Number ) { @@FILE@@ = Number L ; } else { @@FILE@@ = freopen ( @@constchar@@ , @@constchar@@ , @@FILE@@ ) ; } @@int@@ = * __errno_location ( ) ; if ( @@char@@ ) close ( Number ) ; if ( @@char@@ ) close ( Number ) ; if ( @@char@@ ) close ( Number ) ; if ( ! @@FILE@@ ) * __errno_location ( ) = @@int@@ ; return @@FILE@@ ; }
__int64 __fastcall compare_occurs ( const void * @@constvoid@@ , const void * @@constvoid@@ ) { __int64 @@int64@@ ; unsigned int @@unsignedint@@ ; @@unsignedint@@ = compare_words ( @@constvoid@@ , @@constvoid@@ ) ; if ( @@unsignedint@@ ) @@int64@@ = @@unsignedint@@ ; else @@int64@@ = * ( _QWORD * ) @@constvoid@@ - * ( _QWORD * ) @@constvoid@@ ; return @@int64@@ ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
__int64 __fastcall search_table ( const void * @@constvoid@@ , _QWORD * @@QWORD@@ ) { int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; @@int@@ = Number ; @@int@@ = @@QWORD@@ [ Number ] - Number ; while ( @@int@@ <= @@int@@ ) { @@int@@ = ( @@int@@ + @@int@@ ) / Number ; @@int@@ = compare_words ( @@constvoid@@ , ( const void * ) ( * @@QWORD@@ + Number L * @@int@@ ) ) ; if ( @@int@@ >= Number ) { if ( @@int@@ <= Number ) return Number L ; @@int@@ = @@int@@ + Number ; } else { @@int@@ = @@int@@ - Number ; } } return Number L ; }
unsigned __int64 __fastcall digest_word_file ( const char * @@constchar@@ , _QWORD * @@QWORD@@ ) { _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; swallow_file_in_memory ( @@constchar@@ , & @@BYTE@@ ) ; * @@QWORD@@ = Number L ; @@QWORD@@ [ Number ] = Number L ; @@QWORD@@ [ Number ] = Number L ; @@BYTE@@ = @@BYTE@@ ; while ( ( unsigned __int64 ) @@BYTE@@ < @@unsignedint64@@ ) { @@BYTE@@ = @@BYTE@@ ; while ( ( unsigned __int64 ) @@BYTE@@ < @@unsignedint64@@ && * @@BYTE@@ != Number ) ++ @@BYTE@@ ; if ( @@BYTE@@ > @@BYTE@@ ) { if ( @@QWORD@@ [ Number ] == @@QWORD@@ [ Number ] ) { if ( @@QWORD@@ [ Number ] > Number ) xalloc_die ( ) ; @@QWORD@@ [ Number ] = Number L * @@QWORD@@ [ Number ] + Number ; * @@QWORD@@ = xrealloc ( * @@QWORD@@ , Number L * @@QWORD@@ [ Number ] ) ; } * ( _QWORD * ) ( Number L * @@QWORD@@ [ Number ] + * @@QWORD@@ ) = @@BYTE@@ ; * ( _WORD * ) ( * @@QWORD@@ + Number L * @@QWORD@@ [ Number ] ++ + Number ) = ( _WORD ) @@BYTE@@ - ( _WORD ) @@BYTE@@ ; } if ( ( unsigned __int64 ) @@BYTE@@ < @@unsignedint64@@ ) ++ @@BYTE@@ ; } qsort ( ( void * ) * @@QWORD@@ , @@QWORD@@ [ Number ] , Number , ( __compar_fn_t ) compare_words ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
unsigned __int64 __fastcall digest_break_file ( const char * @@constchar@@ ) { unsigned __int8 * @@unsignedint8@@ ; void * @@void@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; swallow_file_in_memory ( @@constchar@@ , @@void@@ ) ; memset ( word_fastmap , Number , Number ) ; for ( @@unsignedint8@@ = ( unsigned __int8 * ) @@void@@ [ Number ] ; @@unsignedint8@@ < @@void@@ [ Number ] ; ++ @@unsignedint8@@ ) { word_fastmap [ ( unsigned __int8 ) to_uchar ( * @@unsignedint8@@ ) ] = Number ; } if ( gnu_extensions != Number ) { byte_229540 = Number ; byte_229529 = Number ; byte_22952A = Number ; } free ( @@void@@ [ Number ] ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
__int64 __fastcall strnlen1 ( const void * @@constvoid@@ , size_t @@sizet@@ ) { __int64 @@int64@@ ; _BYTE * @@BYTE@@ ; @@BYTE@@ = memchr ( @@constvoid@@ , Number , @@sizet@@ ) ; if ( @@BYTE@@ ) @@int64@@ = @@BYTE@@ - ( _BYTE * ) @@constvoid@@ + Number ; else @@int64@@ = @@sizet@@ ; return @@int64@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
__int64 __fastcall xstr_cd_iconv ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = str_cd_iconv ( @@int64@@ , @@int64@@ ) ; if ( ! @@int64@@ && * __errno_location ( ) == Number ) xalloc_die ( ) ; return @@int64@@ ; }
int output_one_tex_line ( ) { __int64 @@int64@@ ; unsigned __int8 * @@unsignedint8@@ ; __int64 @@int64@@ ; unsigned __int8 * @@unsignedint8@@ ; unsigned __int64 @@unsignedint64@@ ; printf ( String , macro_name [ Number ] ) ; putchar_unlocked ( Number ) ; print_field ( ( unsigned __int8 * ) tail , qword_2297D8 ) ; fwrite_unlocked ( & off_23078 , Number , Number , stdout ) ; print_field ( ( unsigned __int8 * ) before , qword_2297F8 ) ; fwrite_unlocked ( & off_23078 , Number , Number , stdout ) ; @@unsignedint8@@ = ( unsigned __int8 * ) keyafter ; @@unsignedint64@@ = qword_229818 ; @@unsignedint8@@ = ( unsigned __int8 * ) keyafter ; if ( word_regex ) { @@int64@@ = rpl_re_match ( & unk_229288 , keyafter , qword_229818 - keyafter , Number L , Number L ) ; if ( @@int64@@ == Number ) matcher_error ( ) ; if ( @@int64@@ == Number ) @@int64@@ = Number L ; else @@int64@@ = @@int64@@ ; @@unsignedint8@@ += @@int64@@ ; } else if ( word_fastmap [ ( unsigned __int8 ) to_uchar ( * ( _BYTE * ) keyafter ) ] ) { while ( ( unsigned __int64 ) @@unsignedint8@@ < qword_229818 && word_fastmap [ ( unsigned __int8 ) to_uchar ( * @@unsignedint8@@ ) ] ) ++ @@unsignedint8@@ ; } else { ++ @@unsignedint8@@ ; } print_field ( @@unsignedint8@@ , ( unsigned __int64 ) @@unsignedint8@@ ) ; fwrite_unlocked ( & off_23078 , Number , Number , stdout ) ; print_field ( @@unsignedint8@@ , @@unsignedint64@@ ) ; fwrite_unlocked ( & off_23078 , Number , Number , stdout ) ; print_field ( ( unsigned __int8 * ) head , qword_229838 ) ; putchar_unlocked ( Number ) ; if ( auto_reference || input_reference ) { putchar_unlocked ( Number ) ; print_field ( ( unsigned __int8 * ) reference , qword_229858 ) ; putchar_unlocked ( Number ) ; } return putchar_unlocked ( Number ) ; }
size_t generate_all_output ( ) { size_t @@sizet@@ ; size_t @@sizet@@ ; char * @@char@@ ; tail = Number L ; qword_2297D8 = Number L ; tail_truncation = Number ; head = Number L ; qword_229838 = Number L ; head_truncation = Number ; @@char@@ = ( char * ) occurs_table ; for ( @@sizet@@ = Number L ; ; ++ @@sizet@@ ) { @@sizet@@ = number_of_occurs ; if ( @@sizet@@ >= number_of_occurs ) break ; define_all_fields ( ( __int64 ) @@char@@ ) ; if ( output_format == Number ) { output_one_roff_line ( ) ; } else if ( ( unsigned int ) output_format < Number ) { output_one_dumb_line ( ) ; } else if ( output_format == Number ) { output_one_tex_line ( ) ; } @@char@@ += Number ; } return @@sizet@@ ; }
_QWORD * __fastcall bitset_set ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { _QWORD * @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) ( Number * ( @@unsignedint64@@ >> Number ) + @@int64@@ ) ; * @@QWORD@@ |= Number L << ( @@unsignedint64@@ & Number ) ; return @@QWORD@@ ; }
__int64 __fastcall argmatch ( const char * @@constchar@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { __int64 @@int64@@ ; char @@char@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; size_t @@sizet@@ ; @@int64@@ = Number ; @@char@@ = Number ; @@sizet@@ = strlen ( @@constchar@@ ) ; for ( @@int64@@ = Number L ; * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; ++ @@int64@@ ) { if ( ! strncmp ( * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) , @@constchar@@ , @@sizet@@ ) ) { if ( @@sizet@@ == strlen ( * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) ) ) return @@int64@@ ; if ( @@int64@@ == Number ) { @@int64@@ = @@int64@@ ; } else if ( ! @@int64@@ || memcmp ( ( const void * ) ( @@sizet@@ * @@int64@@ + @@int64@@ ) , ( const void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) , @@sizet@@ ) ) { @@char@@ = Number ; } } } if ( @@char@@ ) @@int64@@ = Number ; else @@int64@@ = @@int64@@ ; return @@int64@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_229058 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall xstr_iconv ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = str_iconv ( @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( ! @@int64@@ && * __errno_location ( ) == Number ) xalloc_die ( ) ; return @@int64@@ ; }
bool __fastcall is_basic ( unsigned __int8 @@unsignedint8@@ ) { return ( ( is_basic_table [ @@unsignedint8@@ >> Number ] >> ( @@unsignedint8@@ & Number ) ) & Number ) != Number ; }
void * __fastcall bitset_set_all ( void * @@void@@ ) { return memset ( @@void@@ , Number , Number ) ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
void __fastcall argmatch_invalid ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { char * @@char@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; char * @@char@@ ; if ( @@int64@@ == Number ) @@char@@ = gettext ( String ) ; else @@char@@ = gettext ( String ) ; @@char@@ = @@char@@ ; @@int64@@ = quote_n ( Number L , @@int64@@ ) ; @@int64@@ = quotearg_n_style ( Number L , Number L , @@int64@@ ) ; error ( Number , Number , @@char@@ , @@int64@@ , @@int64@@ ) ; }
unsigned __int64 __fastcall re_string_skip_chars ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , wchar_t * @@wchart@@ ) { _BOOL4 @@BOOL4@@ ; wchar_t @@wchart@@ ; wchar_t @@wchart@@ ; unsigned __int64 @@unsignedint64@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@wchart@@ = Number ; for ( @@unsignedint64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) + * ( _QWORD * ) ( @@int64@@ + Number ) ; @@unsignedint64@@ < @@unsignedint64@@ ; @@unsignedint64@@ += @@sizet@@ ) { @@sizet@@ = * ( _QWORD * ) ( @@int64@@ + Number ) - @@unsignedint64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@sizet@@ = mbrtowc ( & @@wchart@@ , ( const char * ) ( * ( _QWORD * ) @@int64@@ + @@unsignedint64@@ ) , @@sizet@@ , ( mbstate_t * ) ( @@int64@@ + Number ) ) ; @@BOOL4@@ = @@sizet@@ == Number || @@sizet@@ == Number ; if ( ! @@BOOL4@@ && @@sizet@@ ) { @@wchart@@ = @@wchart@@ ; } else { if ( @@sizet@@ && @@sizet@@ ) @@wchart@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) @@int64@@ + @@unsignedint64@@ ) ; else @@wchart@@ = Number ; @@sizet@@ = Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; } } * @@wchart@@ = @@wchart@@ ; return @@unsignedint64@@ ; }
char * __fastcall proper_name_utf8 ( const char * @@constchar@@ , __int64 @@int64@@ ) { char * @@char@@ ; char * @@char@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; char * @@char@@ ; char * @@char@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; size_t @@sizet@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; @@char@@ = ( char * ) locale_charset ( ) ; @@char@@ = Number L ; @@char@@ = Number L ; @@int64@@ = Number L ; if ( ( unsigned int ) c_strcasecmp ( @@char@@ , String ) ) { @@char@@ = ( char * ) xstr_iconv ( @@int64@@ , String , @@char@@ ) ; @@int64@@ = ( __int64 ) @@char@@ ; @@sizet@@ = strlen ( @@char@@ ) ; @@char@@ = ( char * ) xmalloc ( @@sizet@@ + Number ) ; memcpy ( @@char@@ , @@char@@ , @@sizet@@ ) ; memcpy ( & @@char@@ [ @@sizet@@ ] , String , Number ) ; @@char@@ = ( char * ) xstr_iconv ( @@int64@@ , String , @@char@@ ) ; free ( @@char@@ ) ; if ( @@char@@ ) { if ( strchr ( @@char@@ , Number ) ) { free ( @@char@@ ) ; } else { @@char@@ = @@char@@ ; @@int64@@ = ( __int64 ) @@char@@ ; } } } else { @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; } if ( @@int64@@ ) { @@char@@ = ( char * ) @@int64@@ ; } else if ( @@int64@@ ) { @@char@@ = ( char * ) @@int64@@ ; } else { @@char@@ = ( char * ) @@constchar@@ ; } @@char@@ = @@char@@ ; if ( ! strcmp ( @@char@@ , @@constchar@@ ) ) { if ( @@char@@ && @@char@@ != @@char@@ ) free ( @@char@@ ) ; if ( @@char@@ && @@char@@ != @@char@@ ) free ( @@char@@ ) ; @@char@@ = @@char@@ ; } else if ( ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@char@@ , ( __int64 ) @@constchar@@ ) || @@int64@@ && ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@char@@ , @@int64@@ ) || @@int64@@ && ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@char@@ , @@int64@@ ) ) { if ( @@char@@ ) free ( @@char@@ ) ; if ( @@char@@ ) free ( @@char@@ ) ; @@char@@ = @@char@@ ; } else { @@sizet@@ = strlen ( @@char@@ ) ; @@sizet@@ = strlen ( @@char@@ ) ; @@char@@ = ( char * ) xmalloc ( @@sizet@@ + @@sizet@@ + Number ) ; sprintf ( @@char@@ , String , @@char@@ , @@char@@ ) ; if ( @@char@@ ) free ( @@char@@ ) ; if ( @@char@@ ) free ( @@char@@ ) ; @@char@@ = @@char@@ ; } return @@char@@ ; }
__int64 __fastcall re_string_wchar_at ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; if ( * ( _DWORD * ) ( @@int64@@ + Number ) == Number ) @@int64@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + @@int64@@ ) ; else @@int64@@ = * ( unsigned int * ) ( Number * @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; return @@int64@@ ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
__int64 __fastcall argmatch_to_argument ( const void * @@constvoid@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; ++ @@int64@@ ) { if ( ! memcmp ( @@constvoid@@ , ( const void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) , @@sizet@@ ) ) return * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; } return Number L ; }
__int64 __fastcall re_string_context_at ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , char @@char@@ ) { __int64 @@int64@@ ; int @@int@@ ; wint_t @@wintt@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@unsignedint64@@ > Number ) return * ( unsigned int * ) ( @@int64@@ + Number ) ; if ( @@unsignedint64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ) { if ( ( @@char@@ & Number ) != Number ) @@int64@@ = Number L ; else @@int64@@ = Number L ; } else if ( * ( int * ) ( @@int64@@ + Number ) <= Number ) { @@int@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + @@unsignedint64@@ ) ; if ( bitset_contain ( * ( _QWORD * ) ( @@int64@@ + Number ) , * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + @@unsignedint64@@ ) ) ) { @@int64@@ = Number L ; } else if ( @@int@@ == Number && * ( _BYTE * ) ( @@int64@@ + Number ) ) { @@int64@@ = Number L ; } else { @@int64@@ = Number L ; } } else { @@unsignedint64@@ = @@unsignedint64@@ ; while ( * ( _DWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) == Number ) { if ( -- @@unsignedint64@@ > Number ) return * ( unsigned int * ) ( @@int64@@ + Number ) ; } @@wintt@@ = * ( _DWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) && ( iswalnum ( @@wintt@@ ) || @@wintt@@ == Number ) ) { @@int64@@ = Number L ; } else if ( @@wintt@@ == Number && * ( _BYTE * ) ( @@int64@@ + Number ) ) { @@int64@@ = Number L ; } else { @@int64@@ = Number L ; } } return @@int64@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 __fastcall re_string_realloc_buffers ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { void * @@void@@ ; void * @@void@@ ; void * @@void@@ ; if ( * ( int * ) ( @@int64@@ + Number ) > Number ) { if ( ! is_mul_ok ( Number , @@unsignedint64@@ ) ) return Number L ; @@void@@ = realloc ( * ( void * * ) ( @@int64@@ + Number ) , Number * @@unsignedint64@@ ) ; if ( ! @@void@@ ) return Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@void@@ ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) { @@void@@ = realloc ( * ( void * * ) ( @@int64@@ + Number ) , Number * @@unsignedint64@@ ) ; if ( ! @@void@@ ) return Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@void@@ ; } } if ( * ( _BYTE * ) ( @@int64@@ + Number ) ) { @@void@@ = realloc ( * ( void * * ) ( @@int64@@ + Number ) , @@unsignedint64@@ ) ; if ( ! @@void@@ ) return Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@void@@ ; } * ( _QWORD * ) ( @@int64@@ + Number ) = @@unsignedint64@@ ; return Number L ; }
unsigned __int64 __fastcall re_node_set_contains ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( ( unsigned __int64 ) ( * ( _QWORD * ) ( @@int64@@ + Number ) - Number L ) > Number ) return Number L ; @@unsignedint64@@ = Number L ; @@unsignedint64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) - Number L ; while ( @@unsignedint64@@ < @@unsignedint64@@ ) { if ( @@unsignedint64@@ <= * ( _QWORD * ) ( Number * ( ( @@unsignedint64@@ + @@unsignedint64@@ ) >> Number ) + * ( _QWORD * ) ( @@int64@@ + Number ) ) ) @@unsignedint64@@ = ( @@unsignedint64@@ + @@unsignedint64@@ ) >> Number ; else @@unsignedint64@@ = ( ( @@unsignedint64@@ + @@unsignedint64@@ ) >> Number ) + Number ; } if ( @@unsignedint64@@ == * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ) @@unsignedint64@@ = @@unsignedint64@@ + Number ; else @@unsignedint64@@ = Number L ; return @@unsignedint64@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
char * __fastcall rpl_re_compile_pattern ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { char * @@char@@ ; int @@int@@ ; * ( _BYTE * ) ( @@int64@@ + Number ) = ( Number * ( ( rpl_re_syntax_options & Number ) != Number ) ) | * ( _BYTE * ) ( @@int64@@ + Number ) & Number ; * ( _BYTE * ) ( @@int64@@ + Number ) |= Number ; @@int@@ = re_compile_internal ( @@int64@@ , @@int64@@ , @@int64@@ , rpl_re_syntax_options ) ; if ( @@int@@ ) @@char@@ = gettext ( & _re_error_msgid [ _re_error_msgid_idx [ @@int@@ ] ] ) ; else @@char@@ = Number L ; return @@char@@ ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
__int64 __fastcall re_string_peek_byte_case ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; if ( ! * ( _BYTE * ) ( @@int64@@ + Number ) ) return * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + * ( _QWORD * ) ( @@int64@@ + Number ) + @@int64@@ ) ; if ( * ( int * ) ( @@int64@@ + Number ) > Number && ( * ( _DWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * ( * ( _QWORD * ) ( @@int64@@ + Number ) + @@int64@@ ) ) == Number || * ( _QWORD * ) ( @@int64@@ + Number ) != * ( _QWORD * ) ( @@int64@@ + Number ) + @@int64@@ + Number && * ( _DWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * ( * ( _QWORD * ) ( @@int64@@ + Number ) + @@int64@@ + Number ) ) == Number ) ) { return * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + * ( _QWORD * ) ( @@int64@@ + Number ) + @@int64@@ ) ; } @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) + @@int64@@ ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) ) @@int64@@ = * ( _QWORD * ) ( Number * @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) && ( * ( _BYTE * ) ( * ( _QWORD * ) @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) + @@int64@@ ) & Number ) != Number ) { @@int64@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + * ( _QWORD * ) ( @@int64@@ + Number ) + @@int64@@ ) ; } else { @@int64@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) + @@int64@@ ) ; } return @@int64@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall re_node_set_insert_last ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; void * @@void@@ ; if ( * ( _QWORD * ) @@int64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ) { * ( _QWORD * ) @@int64@@ = Number * ( * ( _QWORD * ) @@int64@@ + Number L ) ; @@void@@ = realloc ( * ( void * * ) ( @@int64@@ + Number ) , Number L * * ( _QWORD * ) @@int64@@ ) ; if ( ! @@void@@ ) return Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@void@@ ; } @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ + Number ; * ( _QWORD * ) ( @@int64@@ + Number * @@int64@@ ) = @@int64@@ ; return Number L ; }
bool __fastcall bitset_contain ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { return ( ( * ( _QWORD * ) ( Number * ( @@unsignedint64@@ >> Number ) + @@int64@@ ) >> ( @@unsignedint64@@ & Number ) ) & Number L ) != Number ; }
size_t __fastcall rpl_regerror ( int @@int@@ , __int64 a2 , _BYTE * @@BYTE@@ , size_t @@sizet@@ ) { size_t @@sizet@@ ; const char * @@constchar@@ ; size_t @@sizet@@ ; if ( @@int@@ < Number || @@int@@ > Number ) abort ( ) ; @@constchar@@ = gettext ( & _re_error_msgid [ _re_error_msgid_idx [ @@int@@ ] ] ) ; @@sizet@@ = strlen ( @@constchar@@ ) + Number ; if ( @@sizet@@ ) { @@sizet@@ = @@sizet@@ ; if ( @@sizet@@ > @@sizet@@ ) { @@sizet@@ = @@sizet@@ - Number ; @@BYTE@@ [ @@sizet@@ - Number ] = Number ; } memcpy ( @@BYTE@@ , @@constchar@@ , @@sizet@@ ) ; } return @@sizet@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
_QWORD * __fastcall bitset_mask ( __int64 @@int64@@ , __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; int @@int@@ ; for ( @@int@@ = Number ; @@int@@ <= Number ; ++ @@int@@ ) { @@QWORD@@ = ( _QWORD * ) ( Number L * @@int@@ + @@int64@@ ) ; * @@QWORD@@ &= * ( _QWORD * ) ( Number L * @@int@@ + @@int64@@ ) ; } return @@QWORD@@ ; }
unsigned __int64 __fastcall re_node_set_remove_at ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint64@@ ; @@unsignedint64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( @@unsignedint64@@ < @@unsignedint64@@ ) { -- * ( _QWORD * ) ( @@int64@@ + Number ) ; while ( Number ) { @@unsignedint64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( @@unsignedint64@@ >= @@unsignedint64@@ ) break ; * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@unsignedint64@@ ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * ( @@unsignedint64@@ + Number ) ) ; ++ @@unsignedint64@@ ; } } return @@unsignedint64@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_229888 ; @@int648@@ [ Number ] = qword_229890 ; @@int648@@ [ Number ] = qword_229898 ; @@int648@@ [ Number ] = qword_2298A0 ; @@int648@@ [ Number ] = qword_2298A8 ; @@int648@@ [ Number ] = qword_2298B0 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
__int64 __fastcall init_dfa ( void * * @@void@@ , unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; wint_t @@wintt@@ ; size_t @@sizet@@ ; const char * @@constchar@@ ; memset ( @@void@@ , Number , Number ) ; * ( ( _DWORD * ) @@void@@ + Number ) = Number ; if ( @@unsignedint64@@ >= Number ) return Number L ; @@void@@ [ Number ] = ( void * ) ( @@unsignedint64@@ + Number ) ; * @@void@@ = malloc ( Number L * ( _QWORD ) @@void@@ [ Number ] ) ; for ( @@sizet@@ = Number L ; @@sizet@@ <= @@unsignedint64@@ ; @@sizet@@ *= Number L ) { ; } @@void@@ [ Number ] = calloc ( Number , @@sizet@@ ) ; @@void@@ [ Number ] = ( void * ) ( @@sizet@@ - Number ) ; * ( ( _DWORD * ) @@void@@ + Number ) = __ctype_get_mb_cur_max ( ) ; @@constchar@@ = nl_langinfo ( Number ) ; if ( ! strcasecmp ( @@constchar@@ , String ) || ! strcasecmp ( @@constchar@@ , String ) ) * ( ( _BYTE * ) @@void@@ + Number ) |= Number ; * ( ( _BYTE * ) @@void@@ + Number ) &= Number ; if ( * ( ( int * ) @@void@@ + Number ) > Number ) { if ( ( ( _BYTE ) @@void@@ [ Number ] & Number ) != Number ) { @@void@@ [ Number ] = & utf8_sb_map ; } else { @@void@@ [ Number ] = calloc ( Number , Number ) ; if ( ! @@void@@ [ Number ] ) return Number L ; @@int@@ = Number ; @@int@@ = Number ; while ( @@int@@ <= Number ) { for ( @@int@@ = Number ; @@int@@ <= Number ; ++ @@int@@ ) { @@wintt@@ = btowc ( @@int@@ ) ; if ( @@wintt@@ != Number ) * ( ( _QWORD * ) @@void@@ [ Number ] + @@int@@ ) |= Number L << @@int@@ ; if ( ( @@int@@ & Number ) == Number && @@wintt@@ != @@int@@ ) * ( ( _BYTE * ) @@void@@ + Number ) |= Number ; ++ @@int@@ ; } ++ @@int@@ ; } } } if ( * @@void@@ && @@void@@ [ Number ] ) @@int64@@ = Number L ; else @@int64@@ = Number L ; return @@int64@@ ; }
__int64 __fastcall re_string_construct ( __int64 @@int64@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; unsigned int @@unsignedint@@ ; unsigned int @@unsignedint@@ ; unsigned int @@unsignedint@@ ; memset ( ( void * ) @@int64@@ , Number , Number ) ; re_string_construct_common ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@int64@@ , @@unsignedint8@@ , @@int64@@ ) ; if ( @@unsignedint64@@ ) { @@unsignedint@@ = re_string_realloc_buffers ( @@int64@@ , @@unsignedint64@@ + Number ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; } if ( * ( _BYTE * ) ( @@int64@@ + Number ) ) @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; else @@int64@@ = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; if ( ! @@unsignedint8@@ ) { if ( * ( int * ) ( @@int64@@ + Number ) <= Number ) { if ( @@int64@@ ) { re_string_translate_buffer ( @@int64@@ ) ; } else { * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; } } else { build_wcs_buffer ( @@int64@@ ) ; } return Number L ; } if ( * ( int * ) ( @@int64@@ + Number ) <= Number ) { build_upper_buffer ( @@int64@@ ) ; return Number L ; } do { @@unsignedint@@ = build_wcs_upper_buffer ( @@int64@@ ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; if ( @@unsignedint64@@ <= * ( _QWORD * ) ( @@int64@@ + Number ) || * ( _QWORD * ) ( @@int64@@ + Number ) > ( unsigned __int64 ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + * ( int * ) ( @@int64@@ + Number ) ) ) { return Number L ; } @@unsignedint@@ = re_string_realloc_buffers ( @@int64@@ , Number L * * ( _QWORD * ) ( @@int64@@ + Number ) ) ; } while ( ! @@unsignedint@@ ) ; return @@unsignedint@@ ; }
void * __fastcall bitset_empty ( void * @@void@@ ) { return memset ( @@void@@ , Number , Number ) ; }
_QWORD * __fastcall bitset_clear ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { _QWORD * @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) ( Number * ( @@unsignedint64@@ >> Number ) + @@int64@@ ) ; * @@QWORD@@ &= ~ ( Number L << ( @@unsignedint64@@ & Number ) ) ; return @@QWORD@@ ; }
char * __fastcall create_ci_newstate ( _QWORD * @@QWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { char * @@char@@ ; int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; char * @@char@@ ; __int64 @@int64@@ ; @@char@@ = ( char * ) calloc ( Number , Number ) ; if ( ! @@char@@ ) return Number L ; if ( ( unsigned int ) re_node_set_init_copy ( @@char@@ + Number , @@int64@@ ) ) { free ( @@char@@ ) ; @@char@@ = Number L ; } else { * ( ( _QWORD * ) @@char@@ + Number ) = @@char@@ + Number ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { @@int64@@ = * @@QWORD@@ + Number L * * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; @@int@@ = * ( unsigned __int8 * ) ( @@int64@@ + Number ) ; if ( @@int@@ != Number || ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number ) { @@char@@ [ Number ] = ( Number * ( ( * ( _BYTE * ) ( @@int64@@ + Number ) & Number ) != Number || ( @@char@@ [ Number ] & Number ) != Number ) ) | @@char@@ [ Number ] & Number ; if ( @@int@@ == Number ) { @@char@@ [ Number ] |= Number ; } else if ( @@int@@ == Number ) { @@char@@ [ Number ] |= Number ; } else if ( @@int@@ == Number || ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number ) { @@char@@ [ Number ] |= Number ; } } } if ( ( unsigned int ) register_state ( @@QWORD@@ , @@char@@ , @@int64@@ ) ) { free_state ( ( void * * ) @@char@@ ) ; @@char@@ = Number L ; } @@char@@ = @@char@@ ; } return @@char@@ ; }
__int64 __fastcall duplicate_node ( _QWORD * @@QWORD@@ , __int64 @@int64@@ , __int16 @@int16@@ ) { __int64 @@int64@@ ; @@int64@@ = re_dfa_add_node ( ( __int64 ) @@QWORD@@ , * ( _QWORD * ) ( Number * @@int64@@ + * @@QWORD@@ ) , * ( _QWORD * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) ) ; if ( @@int64@@ != Number ) { * ( _DWORD * ) ( * @@QWORD@@ + Number * @@int64@@ + Number ) = ( ( @@int16@@ & Number ) << Number ) | * ( _DWORD * ) ( * @@QWORD@@ + Number * @@int64@@ + Number ) & Number ; * ( _DWORD * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) = ( ( ( ( * ( _DWORD * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) >> Number ) & Number | ( * ( _DWORD * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) >> Number ) & Number ) & Number ) << Number ) | * ( _DWORD * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) & Number ; * ( _BYTE * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) |= Number ; * ( _QWORD * ) ( @@QWORD@@ [ Number ] + Number * @@int64@@ ) = @@int64@@ ; } return @@int64@@ ; }
void __fastcall re_string_destruct ( __int64 @@int64@@ ) { free ( * ( void * * ) ( @@int64@@ + Number ) ) ; free ( * ( void * * ) ( @@int64@@ + Number ) ) ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) ) free ( * ( void * * ) ( @@int64@@ + Number ) ) ; }
_QWORD * __fastcall bitset_merge ( __int64 @@int64@@ , __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; int @@int@@ ; for ( @@int@@ = Number ; @@int@@ <= Number ; ++ @@int@@ ) { @@QWORD@@ = ( _QWORD * ) ( Number L * @@int@@ + @@int64@@ ) ; * @@QWORD@@ |= * ( _QWORD * ) ( Number L * @@int@@ + @@int64@@ ) ; } return @@QWORD@@ ; }
__int64 __fastcall re_string_char_size_at ( __int64 @@int64@@ , __int64 @@int64@@ ) { int @@int@@ ; if ( * ( _DWORD * ) ( @@int64@@ + Number ) == Number ) return Number L ; for ( @@int@@ = Number ; ( unsigned __int64 ) ( @@int64@@ + @@int@@ ) < * ( _QWORD * ) ( @@int64@@ + Number ) && * ( _DWORD * ) ( Number * ( @@int@@ + @@int64@@ ) + * ( _QWORD * ) ( @@int64@@ + Number ) ) == Number ; ++ @@int@@ ) { ; } return ( unsigned int ) @@int@@ ; }
__int64 __fastcall re_node_set_alloc ( _QWORD * @@QWORD@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; * @@QWORD@@ = @@int64@@ ; @@QWORD@@ [ Number ] = Number L ; @@QWORD@@ [ Number ] = malloc ( Number * @@int64@@ ) ; if ( @@QWORD@@ [ Number ] ) @@int64@@ = Number L ; else @@int64@@ = Number L ; return @@int64@@ ; }
__int64 __fastcall parse_reg_exp ( __int64 @@int64@@ , __int64 * @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , _DWORD * @@DWORD@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = * @@int64@@ ; @@int64@@ = parse_branch ( @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@DWORD@@ ) ; if ( * @@DWORD@@ && ! @@int64@@ ) return Number L ; while ( * ( _BYTE * ) ( @@int64@@ + Number ) == Number ) { fetch_token ( @@int64@@ , @@int64@@ , @@int64@@ | Number ) ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) == Number || * ( _BYTE * ) ( @@int64@@ + Number ) == Number || @@int64@@ && * ( _BYTE * ) ( @@int64@@ + Number ) == Number ) { @@int64@@ = Number L ; } else { @@int64@@ = parse_branch ( @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@DWORD@@ ) ; if ( * @@DWORD@@ && ! @@int64@@ ) return Number L ; } @@int64@@ = create_tree ( @@int64@@ , @@int64@@ , @@int64@@ , Number L ) ; if ( ! @@int64@@ ) { * @@DWORD@@ = Number ; return Number L ; } } return @@int64@@ ; }
__int64 __fastcall optimize_subexps ( __int64 @@int64@@ , __int64 @@int64@@ ) { unsigned __int64 @@unsignedint64@@ ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) == Number && * ( _QWORD * ) ( @@int64@@ + Number ) ) { * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( Number L * ( int ) * ( _QWORD * ) ( @@int64@@ + Number ) + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; * ( _QWORD * ) ( @@int64@@ + Number ) |= Number << * ( _QWORD * ) ( @@int64@@ + Number ) ; } else if ( * ( _BYTE * ) ( @@int64@@ + Number ) == Number && * ( _QWORD * ) ( @@int64@@ + Number ) && * ( _BYTE * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) == Number ) { @@unsignedint64@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) * * ( _QWORD * * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@unsignedint64@@ ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L * * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= Number ) * ( _QWORD * ) ( @@int64@@ + Number ) &= ~ ( Number L << @@unsignedint64@@ ) ; } return Number L ; }
__int64 __fastcall re_string_allocate ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ , __int64 @@int64@@ ) { unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned int @@unsignedint@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint64@@ ; if ( @@unsignedint64@@ < * ( int * ) ( @@int64@@ + Number ) ) @@unsignedint64@@ = * ( int * ) ( @@int64@@ + Number ) ; @@unsignedint64@@ = @@int64@@ + Number ; if ( @@unsignedint64@@ <= @@int64@@ + Number ) @@unsignedint64@@ = @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint64@@ ; re_string_construct_common ( @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@unsignedint8@@ , @@int64@@ ) ; @@unsignedint@@ = re_string_realloc_buffers ( @@int64@@ , @@unsignedint64@@ ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ + Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = ( * ( _BYTE * ) ( @@int64@@ + Number ) & Number ) != Number ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) ) @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; else @@int64@@ = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) || * ( int * ) ( @@int64@@ + Number ) > Number ) @@int64@@ = Number L ; else @@int64@@ = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; return Number L ; }
__int64 __fastcall re_string_construct_common ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , char @@char@@ , __int64 @@int64@@ ) { bool @@bool@@ ; __int64 @@int64@@ ; * ( _QWORD * ) @@int64@@ = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _BYTE * ) ( @@int64@@ + Number ) = @@char@@ ; @@bool@@ = @@int64@@ || @@char@@ ; * ( _BYTE * ) ( @@int64@@ + Number ) = @@bool@@ ; * ( _DWORD * ) ( @@int64@@ + Number ) = * ( _DWORD * ) ( @@int64@@ + Number ) ; * ( _BYTE * ) ( @@int64@@ + Number ) = ( * ( _BYTE * ) ( @@int64@@ + Number ) & Number ) != Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = ( * ( _BYTE * ) ( @@int64@@ + Number ) & Number ) != Number ; * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; return @@int64@@ ; }
__int64 __fastcall re_node_set_init_2 ( _QWORD * @@QWORD@@ , unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { * @@QWORD@@ = Number L ; @@QWORD@@ [ Number ] = malloc ( Number ) ; if ( ! @@QWORD@@ [ Number ] ) return Number L ; if ( @@unsignedint64@@ == @@unsignedint64@@ ) { @@QWORD@@ [ Number ] = Number L ; * ( _QWORD * ) @@QWORD@@ [ Number ] = @@unsignedint64@@ ; } else { @@QWORD@@ [ Number ] = Number L ; if ( @@unsignedint64@@ >= @@unsignedint64@@ ) { * ( _QWORD * ) @@QWORD@@ [ Number ] = @@unsignedint64@@ ; * ( _QWORD * ) ( @@QWORD@@ [ Number ] + Number L ) = @@unsignedint64@@ ; } else { * ( _QWORD * ) @@QWORD@@ [ Number ] = @@unsignedint64@@ ; * ( _QWORD * ) ( @@QWORD@@ [ Number ] + Number L ) = @@unsignedint64@@ ; } } return Number L ; }
__int64 __fastcall parse_bracket_symbol ( __int64 @@int64@@ , _QWORD * @@QWORD@@ , char * @@char@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; int @@int@@ ; char @@char@@ ; char @@char@@ ; int @@int@@ ; @@char@@ = * @@char@@ ; @@int@@ = Number ; if ( @@QWORD@@ [ Number ] <= @@QWORD@@ [ Number ] ) return Number L ; while ( Number ) { if ( @@int@@ > Number ) return Number L ; if ( @@char@@ [ Number ] == Number ) { @@char@@ = re_string_fetch_byte_case ( ( __int64 ) @@QWORD@@ ) ; } else { @@int64@@ = @@QWORD@@ [ Number ] ; @@int64@@ = @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ + Number ; @@char@@ = * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) ; } if ( @@QWORD@@ [ Number ] <= @@QWORD@@ [ Number ] ) return Number L ; if ( @@char@@ == @@char@@ && * ( _BYTE * ) ( @@QWORD@@ [ Number ] + @@QWORD@@ [ Number ] ) == Number ) { break ; } * ( _BYTE * ) ( @@int@@ ++ + * ( _QWORD * ) ( @@int64@@ + Number ) ) = @@char@@ ; } ++ @@QWORD@@ [ Number ] ; * ( _BYTE * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + @@int@@ ) = Number ; @@int@@ = ( unsigned __int8 ) @@char@@ [ Number ] ; switch ( @@int@@ ) { case Number : * ( _DWORD * ) @@int64@@ = Number ; break ; case Number : * ( _DWORD * ) @@int64@@ = Number ; break ; case Number : * ( _DWORD * ) @@int64@@ = Number ; break ; } return Number L ; }
__int64 __fastcall link_nfa_nodes ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; unsigned int @@unsignedint@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@unsignedint@@ = Number ; switch ( * ( _BYTE * ) ( @@int64@@ + Number ) ) { case Number : if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) __assert_fail ( String , String , Number , String ) ; return @@int64@@ ; case Number : * ( _QWORD * ) ( Number * @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) == Number ) re_node_set_init_1 ( ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ ) , * ( _QWORD * ) ( Number * @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; break ; case Number : case Number : case Number : @@unsignedint@@ = re_node_set_init_1 ( ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ ) , * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) ) ; break ; case Number : case Number : * ( _BYTE * ) ( @@int64@@ + Number ) |= Number ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) @@unsignedint64@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) + Number L ) ; else @@unsignedint64@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) @@unsignedint64@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) + Number L ) ; else @@unsignedint64@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) ; if ( @@unsignedint64@@ > Number ) __assert_fail ( String , String , Number , String ) ; if ( @@unsignedint64@@ > Number ) __assert_fail ( String , String , Number , String ) ; @@unsignedint@@ = re_node_set_init_2 ( ( _QWORD * ) ( Number * @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) , @@unsignedint64@@ , @@unsignedint64@@ ) ; break ; case Number : return @@unsignedint@@ ; default : if ( ( * ( _BYTE * ) ( @@int64@@ + Number ) & Number ) != Number ) __assert_fail ( String , String , Number , String ) ; * ( _QWORD * ) ( Number * @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) ; break ; } return @@unsignedint@@ ; }
__int64 __fastcall re_string_fetch_byte_case ( __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned int @@unsignedint@@ ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) ) { if ( * ( _BYTE * ) ( @@int64@@ + Number ) ) { if ( * ( _QWORD * ) ( @@int64@@ + Number ) == * ( _QWORD * ) ( @@int64@@ + Number ) || * ( _DWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L * * ( _QWORD * ) ( @@int64@@ + Number ) ) != Number ) { @@unsignedint@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) + * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L * * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; if ( ( @@unsignedint@@ & Number ) != Number ) { @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ + Number ; @@int64@@ = * ( unsigned __int8 * ) ( @@int64@@ + @@int64@@ ) ; } else { @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ + ( int ) re_string_char_size_at ( @@int64@@ , @@int64@@ ) ; @@int64@@ = @@unsignedint@@ ; } } else { @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ + Number ; @@int64@@ = * ( unsigned __int8 * ) ( @@int64@@ + @@int64@@ ) ; } } else { @@int64@@ = * ( _QWORD * ) @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ + Number ; @@int64@@ = * ( unsigned __int8 * ) ( @@int64@@ + @@int64@@ + @@int64@@ ) ; } } else { @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ + Number ; @@int64@@ = * ( unsigned __int8 * ) ( @@int64@@ + @@int64@@ ) ; } return @@int64@@ ; }
__int64 __fastcall re_node_set_init_1 ( _QWORD * @@QWORD@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; * @@QWORD@@ = Number L ; @@QWORD@@ [ Number ] = Number L ; @@QWORD@@ [ Number ] = malloc ( Number ) ; if ( @@QWORD@@ [ Number ] ) { * ( _QWORD * ) @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = Number L ; } else { @@QWORD@@ [ Number ] = Number L ; * @@QWORD@@ = @@QWORD@@ [ Number ] ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall re_node_set_compare ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; if ( ! @@int64@@ || ! @@int64@@ || * ( _QWORD * ) ( @@int64@@ + Number ) != * ( _QWORD * ) ( @@int64@@ + Number ) ) { return Number L ; } @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; while ( ( unsigned __int64 ) -- @@int64@@ <= Number ) { if ( * ( _QWORD * ) ( Number * @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) != * ( _QWORD * ) ( Number * @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ) return Number L ; } return Number L ; }
void __fastcall free_token ( __int64 @@int64@@ ) { if ( * ( _BYTE * ) ( @@int64@@ + Number ) != Number || ( * ( _BYTE * ) ( @@int64@@ + Number ) & Number ) != Number ) { if ( * ( _BYTE * ) ( @@int64@@ + Number ) == Number && ( * ( _BYTE * ) ( @@int64@@ + Number ) & Number ) == Number ) free ( * ( void * * ) @@int64@@ ) ; } else { free_charset ( * ( void * * * ) @@int64@@ ) ; } }
__int64 __fastcall build_collating_symbol ( __int64 @@int64@@ , __int64 a2 , __int64 a3 , const char * @@constchar@@ ) { if ( strlen ( @@constchar@@ ) != Number ) return Number L ; bitset_set ( @@int64@@ , * ( unsigned __int8 * ) @@constchar@@ ) ; return Number L ; }
__int64 __fastcall calc_state_hash ( __int64 @@int64@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) + @@unsignedint@@ ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { @@int64@@ += * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; } return @@int64@@ ; }
__int64 __fastcall re_node_set_init_copy ( void * @@void@@ , __int64 @@int64@@ ) { * ( ( _QWORD * ) @@void@@ + Number ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) { * ( _QWORD * ) @@void@@ = * ( ( _QWORD * ) @@void@@ + Number ) ; * ( ( _QWORD * ) @@void@@ + Number ) = malloc ( Number L * * ( _QWORD * ) @@void@@ ) ; if ( ! * ( ( _QWORD * ) @@void@@ + Number ) ) { * ( ( _QWORD * ) @@void@@ + Number ) = Number L ; * ( _QWORD * ) @@void@@ = * ( ( _QWORD * ) @@void@@ + Number ) ; return Number L ; } memcpy ( * ( ( void * * ) @@void@@ + Number ) , * ( const void * * ) ( @@int64@@ + Number ) , Number L * * ( _QWORD * ) ( @@int64@@ + Number ) ) ; } else { memset ( @@void@@ , Number , Number ) ; } return Number L ; }
__int64 __fastcall rpl_re_search_2 ( int @@int@@ , int @@int@@ , int @@int@@ , int @@int@@ , int @@int@@ , int @@int@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return re_search_2_stub ( @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int64@@ , @@int64@@ , @@int64@@ , Number ) ; }
_QWORD * __fastcall re_acquire_state ( _DWORD * @@DWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; unsigned __int64 * @@unsignedint64@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) { @@int64@@ = calc_state_hash ( @@int64@@ , Number ) ; @@unsignedint64@@ = ( unsigned __int64 * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * ( @@int64@@ & * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * @@unsignedint64@@ ; ++ @@unsignedint64@@ ) { @@QWORD@@ = * ( _QWORD * * ) ( Number * @@unsignedint64@@ + @@unsignedint64@@ [ Number ] ) ; if ( @@int64@@ == * @@QWORD@@ && ( unsigned __int8 ) re_node_set_compare ( ( __int64 ) ( @@QWORD@@ + Number ) , @@int64@@ ) ) { return @@QWORD@@ ; } } @@int64@@ = create_ci_newstate ( @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( ! @@int64@@ ) * @@DWORD@@ = Number ; @@QWORD@@ = ( _QWORD * ) @@int64@@ ; } else { * @@DWORD@@ = Number ; @@QWORD@@ = Number L ; } return @@QWORD@@ ; }
_QWORD * __fastcall rpl_re_set_registers ( __int64 @@int64@@ , _QWORD * @@QWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; if ( @@int64@@ ) { * ( _BYTE * ) ( @@int64@@ + Number ) = * ( _BYTE * ) ( @@int64@@ + Number ) & Number | Number ; * @@QWORD@@ = @@int64@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; } else { * ( _BYTE * ) ( @@int64@@ + Number ) &= Number ; * @@QWORD@@ = Number L ; @@QWORD@@ [ Number ] = Number L ; @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ [ Number ] = @@QWORD@@ [ Number ] ; } return @@QWORD@@ ; }
__int64 __fastcall parse_bracket_element ( __int64 @@int64@@ , __int64 @@int64@@ , _BYTE * @@BYTE@@ , int @@int@@ , __int64 a5 , char @@char@@ , char @@char@@ ) { __int64 @@int64@@ ; int @@int@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int@@ = re_string_char_size_at ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( @@int@@ <= Number ) { * ( _QWORD * ) ( @@int64@@ + Number ) += @@int@@ ; if ( @@BYTE@@ [ Number ] == Number || @@BYTE@@ [ Number ] == Number || @@BYTE@@ [ Number ] == Number ) { @@int64@@ = parse_bracket_symbol ( @@int64@@ , @@int64@@ , @@BYTE@@ ) ; } else if ( @@BYTE@@ [ Number ] == Number && @@char@@ != Number && ( peek_token_bracket ( @@char@@ , @@int64@@ , @@char@@ ) , @@char@@ [ Number ] != Number ) ) { @@int64@@ = Number L ; } else { * ( _DWORD * ) @@int64@@ = Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = * @@BYTE@@ ; @@int64@@ = Number L ; } } else { * ( _DWORD * ) @@int64@@ = Number ; * ( _DWORD * ) ( @@int64@@ + Number ) = re_string_wchar_at ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ; * ( _QWORD * ) ( @@int64@@ + Number ) += @@int@@ ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall register_state ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; void * @@void@@ ; __int64 @@int64@@ ; * @@QWORD@@ = @@int64@@ ; if ( ( unsigned int ) re_node_set_alloc ( @@QWORD@@ + Number , @@QWORD@@ [ Number ] ) ) return Number L ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@QWORD@@ [ Number ] ; ++ @@unsignedint64@@ ) { @@int64@@ = * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@QWORD@@ [ Number ] ) ; if ( ( * ( _BYTE * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) & Number ) == Number && ( unsigned __int8 ) re_node_set_insert_last ( ( __int64 ) ( @@QWORD@@ + Number ) , @@int64@@ ) != Number ) { return Number L ; } } @@int64@@ = @@QWORD@@ [ Number ] + Number * ( @@int64@@ & @@QWORD@@ [ Number ] ) ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) <= * ( _QWORD * ) @@int64@@ ) { @@int64@@ = * ( _QWORD * ) @@int64@@ + Number L ; @@int64@@ = Number * @@int64@@ ; @@void@@ = realloc ( * ( void * * ) ( @@int64@@ + Number ) , Number * @@int64@@ ) ; if ( ! @@void@@ ) return Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@void@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; } @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = ( * ( _QWORD * ) @@int64@@ ) ++ ; * ( _QWORD * ) ( @@int64@@ + Number * @@int64@@ ) = @@QWORD@@ ; return Number L ; }
bool __fastcall re_node_set_insert ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; void * @@void@@ ; if ( ! * ( _QWORD * ) @@int64@@ ) return ( unsigned int ) re_node_set_init_1 ( ( _QWORD * ) @@int64@@ , @@unsignedint64@@ ) == Number ; if ( ! * ( _QWORD * ) ( @@int64@@ + Number ) ) { * * ( _QWORD * * ) ( @@int64@@ + Number ) = @@unsignedint64@@ ; ++ * ( _QWORD * ) ( @@int64@@ + Number ) ; return Number ; } if ( * ( _QWORD * ) @@int64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ) { * ( _QWORD * ) @@int64@@ *= Number L ; @@void@@ = realloc ( * ( void * * ) ( @@int64@@ + Number ) , Number L * * ( _QWORD * ) @@int64@@ ) ; if ( ! @@void@@ ) return Number ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@void@@ ; } if ( @@unsignedint64@@ >= * * ( _QWORD * * ) ( @@int64@@ + Number ) ) { for ( @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@unsignedint64@@ < * ( _QWORD * ) ( Number * @@int64@@ - Number + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; -- @@int64@@ ) { * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ - Number ) ; } } else { for ( @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ ; -- @@int64@@ ) { * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ - Number ) ; } } * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ ) = @@unsignedint64@@ ; ++ * ( _QWORD * ) ( @@int64@@ + Number ) ; return Number ; }
__int64 __fastcall rpl_re_set_syntax ( __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = rpl_re_syntax_options ; rpl_re_syntax_options = @@int64@@ ; return @@int64@@ ; }
_BOOL8 __fastcall check_halt_node_context ( _QWORD * @@QWORD@@ , __int64 @@int64@@ , char @@char@@ ) { if ( * ( _BYTE * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) != Number ) return Number L ; if ( ( ( * ( _DWORD * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) >> Number ) & Number ) == Number ) return Number L ; return ( ( * ( _DWORD * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) & Number ) == Number || ( @@char@@ & Number ) != Number ) && ( ( * ( _DWORD * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) & Number ) == Number || ( @@char@@ & Number ) == Number ) && ( ( * ( _DWORD * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) & Number ) == Number || ( @@char@@ & Number ) != Number ) && ( ( * ( _DWORD * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) & Number ) == Number || ( @@char@@ & Number ) != Number ) ; }
__int64 __fastcall mark_opt_subexp ( __int64 @@int64@@ , __int64 @@int64@@ ) { if ( * ( _BYTE * ) ( @@int64@@ + Number ) == Number && @@int64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ) { * ( _BYTE * ) ( @@int64@@ + Number ) |= Number ; } return Number L ; }
__int64 __fastcall free_workarea_compile ( __int64 * @@int64@@ ) { __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; @@int64@@ = * @@int64@@ ; for ( @@QWORD@@ = * ( _QWORD * * ) ( * @@int64@@ + Number ) ; @@QWORD@@ ; @@QWORD@@ = @@QWORD@@ ) { @@QWORD@@ = ( _QWORD * ) * @@QWORD@@ ; free ( @@QWORD@@ ) ; } * ( _QWORD * ) ( @@int64@@ + Number ) = Number L ; * ( _DWORD * ) ( @@int64@@ + Number ) = Number ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number L ; free ( * ( void * * ) ( @@int64@@ + Number ) ) ; @@int64@@ = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number L ; return @@int64@@ ; }
__int64 __fastcall re_acquire_state_context ( _DWORD * @@DWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; unsigned __int64 * @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) { @@int64@@ = calc_state_hash ( @@int64@@ , @@unsignedint@@ ) ; @@unsignedint64@@ = ( unsigned __int64 * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * ( @@int64@@ & * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * @@unsignedint64@@ ; ++ @@unsignedint64@@ ) { @@int64@@ = * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@unsignedint64@@ [ Number ] ) ; if ( @@int64@@ == * ( _QWORD * ) @@int64@@ && @@unsignedint@@ == ( * ( _BYTE * ) ( @@int64@@ + Number ) & Number ) && ( unsigned __int8 ) re_node_set_compare ( * ( _QWORD * ) ( @@int64@@ + Number ) , @@int64@@ ) ) { return @@int64@@ ; } } @@int64@@ = create_cd_newstate ( @@int64@@ , @@int64@@ , @@unsignedint@@ , @@int64@@ ) ; if ( ! @@int64@@ ) * @@DWORD@@ = Number ; @@int64@@ = @@int64@@ ; } else { * @@DWORD@@ = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall rpl_re_match ( int @@int@@ , int @@int@@ , int @@int@@ , int @@int@@ , __int64 @@int64@@ ) { return re_search_stub ( @@int@@ , @@int@@ , @@int@@ , @@int@@ , Number , @@int@@ , @@int64@@ , Number ) ; }
__int64 __fastcall rpl_re_compile_fastmap ( __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; void * @@void@@ ; @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; @@void@@ = * ( void * * ) ( @@int64@@ + Number ) ; memset ( @@void@@ , Number , Number ) ; re_compile_fastmap_iter ( @@int64@@ , @@QWORD@@ [ Number ] , @@void@@ ) ; if ( @@QWORD@@ [ Number ] != @@QWORD@@ [ Number ] ) re_compile_fastmap_iter ( @@int64@@ , @@QWORD@@ [ Number ] , @@void@@ ) ; if ( @@QWORD@@ [ Number ] != @@QWORD@@ [ Number ] ) re_compile_fastmap_iter ( @@int64@@ , @@QWORD@@ [ Number ] , @@void@@ ) ; if ( @@QWORD@@ [ Number ] != @@QWORD@@ [ Number ] ) re_compile_fastmap_iter ( @@int64@@ , @@QWORD@@ [ Number ] , @@void@@ ) ; * ( _BYTE * ) ( @@int64@@ + Number ) |= Number ; return Number L ; }
_QWORD * __fastcall update_regs ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ , void * @@void@@ , __int64 @@int64@@ , _QWORD * @@QWORD@@ , unsigned __int64 @@unsignedint64@@ ) { _QWORD * @@QWORD@@ ; int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@QWORD@@ = ( _QWORD * ) * ( unsigned __int8 * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) ; @@int@@ = * ( unsigned __int8 * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) ; if ( @@int@@ == Number ) { @@unsignedint64@@ = * ( _QWORD * ) ( Number * @@int64@@ + * @@QWORD@@ ) + Number L ; @@QWORD@@ = ( _QWORD * ) @@unsignedint64@@ ; if ( @@unsignedint64@@ < @@unsignedint64@@ ) { @@QWORD@@ [ Number * @@unsignedint64@@ ] = @@QWORD@@ ; @@QWORD@@ = & @@QWORD@@ [ Number * @@unsignedint64@@ ] ; @@QWORD@@ [ Number ] = Number ; } } else if ( @@int@@ == Number ) { @@unsignedint64@@ = * ( _QWORD * ) ( Number * @@int64@@ + * @@QWORD@@ ) + Number L ; @@QWORD@@ = ( _QWORD * ) @@unsignedint64@@ ; if ( @@unsignedint64@@ < @@unsignedint64@@ ) { if ( ( unsigned __int64 ) @@QWORD@@ <= @@QWORD@@ [ Number * @@unsignedint64@@ ] ) { if ( ( * ( _BYTE * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) & Number ) == Number || * ( ( _QWORD * ) @@void@@ + Number * @@unsignedint64@@ ) == Number ) { @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ [ Number * @@unsignedint64@@ + Number ] = @@QWORD@@ ; } else { @@QWORD@@ = memcpy ( @@QWORD@@ , @@void@@ , Number * @@unsignedint64@@ ) ; } } else { @@QWORD@@ [ Number * @@unsignedint64@@ + Number ] = @@QWORD@@ ; @@QWORD@@ = memcpy ( @@void@@ , @@QWORD@@ , Number * @@unsignedint64@@ ) ; } } } return @@QWORD@@ ; }
__int64 __fastcall lower_subexps ( __int64 @@int64@@ , __int64 @@int64@@ ) { unsigned int @@unsignedint@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = @@int64@@ ; @@unsignedint@@ = Number ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) { if ( * ( _BYTE * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) == Number ) { * ( _QWORD * ) ( @@int64@@ + Number ) = lower_subexp ( & @@unsignedint@@ , @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) * * ( _QWORD * * ) ( @@int64@@ + Number ) = @@int64@@ ; } } if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) { if ( * ( _BYTE * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) == Number ) { * ( _QWORD * ) ( @@int64@@ + Number ) = lower_subexp ( & @@unsignedint@@ , @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) * * ( _QWORD * * ) ( @@int64@@ + Number ) = @@int64@@ ; } } return @@unsignedint@@ ; }
__int64 __fastcall rpl_re_search ( int @@int@@ , int @@int@@ , int @@int@@ , int @@int@@ , int @@int@@ , __int64 @@int64@@ ) { return re_search_stub ( @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int64@@ , Number ) ; }
void __fastcall free_dfa_content ( __int64 @@int64@@ ) { unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( * ( _QWORD * ) @@int64@@ ) { for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { free_token ( Number * @@unsignedint64@@ + * ( _QWORD * ) @@int64@@ ) ; } } free ( * ( void * * ) ( @@int64@@ + Number ) ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) free ( * ( void * * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@unsignedint64@@ + Number ) ) ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) free ( * ( void * * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@unsignedint64@@ + Number ) ) ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) free ( * ( void * * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@unsignedint64@@ + Number ) ) ; } free ( * ( void * * ) ( @@int64@@ + Number ) ) ; free ( * ( void * * ) ( @@int64@@ + Number ) ) ; free ( * ( void * * ) ( @@int64@@ + Number ) ) ; free ( * ( void * * ) @@int64@@ ) ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) { for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@unsignedint64@@ ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) @@int64@@ ; ++ @@unsignedint64@@ ) { free_state ( * ( void * * * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; } free ( * ( void * * ) ( @@int64@@ + Number ) ) ; } } free ( * ( void * * ) ( @@int64@@ + Number ) ) ; if ( * ( _UNKNOWN * * ) ( @@int64@@ + Number ) != & utf8_sb_map ) free ( * ( void * * ) ( @@int64@@ + Number ) ) ; free ( * ( void * * ) ( @@int64@@ + Number ) ) ; free ( ( void * ) @@int64@@ ) ; }
__int64 __fastcall postorder ( _QWORD * @@QWORD@@ , __int64 ( __fastcall * @ @ VAR_1268 @ @ int64 ( fastcall ) ( int64 , QWORD ) @ @ regerrcodet ( ) ( void , bintreet0 ) ) ( __int64 , _QWORD * ) , __int64 @@int64@@ ) { unsigned int @@unsignedint@@ ; _QWORD * @@QWORD@@ ; LABEL_5 : while ( @@QWORD@@ [ Number ] || @@QWORD@@ [ Number ] ) { if ( @@QWORD@@ [ Number ] ) @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; else @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; } while ( Number ) { @@unsignedint@@ = @ @ VAR_1268 @ @ int64 ( fastcall ) ( int64 , QWORD ) @ @ regerrcodet ( ) ( void , bintreet0 ) ( @@int64@@ , @@QWORD@@ ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; if ( ! * @@QWORD@@ ) return Number L ; @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) * @@QWORD@@ ; if ( @@QWORD@@ != ( _QWORD * ) @@QWORD@@ [ Number ] && @@QWORD@@ [ Number ] ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; goto LABEL_5 ; } } }
__int64 __fastcall add_epsilon_src_nodes ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { unsigned int @@unsignedint@@ ; unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@unsignedint@@ = Number ; @@QWORD@@ = re_acquire_state ( & @@unsignedint@@ , @@int64@@ , @@int64@@ ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; if ( ! @@QWORD@@ [ Number ] ) { @@unsignedint@@ = re_node_set_alloc ( @@QWORD@@ + Number , * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint@@ ) return Number L ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { re_node_set_merge ( ( __int64 ) ( @@QWORD@@ + Number ) , * ( _QWORD * ) ( @@int64@@ + Number ) + Number L * * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; } } return re_node_set_add_intersect ( @@int64@@ , @@int64@@ , ( __int64 ) ( @@QWORD@@ + Number ) ) ; }
__int64 __fastcall calc_next ( __int64 a1 , __int64 @@int64@@ ) { int @@int@@ ; @@int@@ = * ( unsigned __int8 * ) ( @@int64@@ + Number ) ; if ( @@int@@ == Number ) { * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) = @@int64@@ ; } else if ( @@int@@ == Number ) { * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) ; * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; } else { if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; } return Number L ; }
__int64 __fastcall rpl_re_match_2 ( int @@int@@ , int @@int@@ , int @@int@@ , int @@int@@ , int @@int@@ , int @@int@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return re_search_2_stub ( @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int@@ , Number L , @@int64@@ , @@int64@@ , Number ) ; }
__int64 __fastcall search_duplicated_node ( _QWORD * @@QWORD@@ , __int64 @@int64@@ , int @@int@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = @@QWORD@@ [ Number ] - Number L ; ( * ( _BYTE * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) & Number ) != Number && @@int64@@ ; -- @@int64@@ ) { if ( @@int64@@ == * ( _QWORD * ) ( Number * @@int64@@ + @@QWORD@@ [ Number ] ) && @@int@@ == ( ( * ( _DWORD * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) >> Number ) & Number ) ) { return @@int64@@ ; } } return Number ; }
__int64 __fastcall sift_states_iter_mb ( __int64 @@int64@@ , _QWORD * @@QWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { int @@int@@ ; __int64 @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int@@ = check_node_accept_bytes ( @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( @@int@@ > Number && @@unsignedint64@@ >= @@int@@ + @@int64@@ && ( ! * ( _QWORD * ) ( Number * ( @@int@@ + @@int64@@ ) + * @@QWORD@@ ) || ! re_node_set_contains ( * ( _QWORD * ) ( Number * ( @@int@@ + @@int64@@ ) + * @@QWORD@@ ) + Number L , * ( _QWORD * ) ( Number * @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ) ) { @@int@@ = Number ; } return ( unsigned int ) @@int@@ ; }
__int64 __fastcall lower_subexp ( _DWORD * @@DWORD@@ , __int64 * @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; _BOOL4 @@BOOL4@@ ; _BOOL4 @@BOOL4@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = * @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( ( @@int64@@ [ Number ] & Number ) != Number && * ( _QWORD * ) ( @@int64@@ + Number ) && ( * ( _QWORD * ) ( @@int64@@ + Number ) > Number || ( ( * ( _QWORD * ) ( @@int64@@ + Number ) >> * ( _QWORD * ) ( @@int64@@ + Number ) ) & Number L ) == Number ) ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; } @@int64@@ = create_tree ( @@int64@@ , Number L , Number L , Number L ) ; @@int64@@ = create_tree ( @@int64@@ , Number L , Number L , Number L ) ; if ( @@int64@@ ) @@int64@@ = create_tree ( @@int64@@ , @@int64@@ , @@int64@@ , Number L ) ; else @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = create_tree ( @@int64@@ , @@int64@@ , @@int64@@ , Number L ) ; @@BOOL4@@ = ! @@int64@@ || ! @@int64@@ ; @@BOOL4@@ = @@BOOL4@@ || ! @@int64@@ ; if ( ! @@BOOL4@@ && @@int64@@ ) { * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _BYTE * ) ( @@int64@@ + Number ) = ( Number * ( ( * ( _BYTE * ) ( @@int64@@ + Number ) & Number ) != Number ) ) | * ( _BYTE * ) ( @@int64@@ + Number ) & Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = ( Number * ( ( * ( _BYTE * ) ( @@int64@@ + Number ) & Number ) != Number ) ) | * ( _BYTE * ) ( @@int64@@ + Number ) & Number ; @@int64@@ = @@int64@@ ; } else { * @@DWORD@@ = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall calc_eclosure ( __int64 @@int64@@ ) { char @@char@@ ; unsigned int @@unsignedint@@ ; __int64 @@int64@@ ; char @@char@@ [ Number ] ; void * @@void@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@char@@ = Number ; for ( @@int64@@ = Number L ; ; ++ @@int64@@ ) { if ( @@int64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ) { if ( @@char@@ != Number ) return Number L ; @@char@@ = Number ; @@int64@@ = Number L ; } if ( ! * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ + Number ) ) break ; LABEL_11 : ; } @@unsignedint@@ = calc_eclosure_iter ( @@char@@ , @@int64@@ , @@int64@@ , Number L ) ; if ( ! @@unsignedint@@ ) { if ( ! * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ + Number ) ) { @@char@@ = Number ; free ( @@void@@ ) ; } goto LABEL_11 ; } return @@unsignedint@@ ; }
__int64 __fastcall calc_inveclosure ( _QWORD * @@QWORD@@ ) { unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@QWORD@@ [ Number ] ; ++ @@unsignedint64@@ ) { memset ( ( void * ) ( @@QWORD@@ [ Number ] + Number * @@unsignedint64@@ ) , Number , Number ) ; } for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@QWORD@@ [ Number ] ; ++ @@unsignedint64@@ ) { @@int64@@ = * ( _QWORD * ) ( @@QWORD@@ [ Number ] + Number * @@unsignedint64@@ + Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@QWORD@@ [ Number ] + Number * @@unsignedint64@@ + Number ) ; ++ @@unsignedint64@@ ) { if ( ( unsigned __int8 ) re_node_set_insert_last ( @@QWORD@@ [ Number ] + Number L * * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@int64@@ ) , @@unsignedint64@@ ) != Number ) return Number L ; } } return Number L ; }
__int64 __fastcall re_search_2_stub ( int @@int@@ , const void * @@constvoid@@ , size_t @@sizet@@ , const void * @@constvoid@@ , size_t @@sizet@@ , int @@int@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int64@@ ; char * @@char@@ ; size_t @@sizet@@ ; __int64 @@int64@@ ; @@sizet@@ = @@sizet@@ + @@sizet@@ ; @@char@@ = Number L ; if ( @@sizet@@ + @@sizet@@ < @@sizet@@ ) return Number ; if ( @@sizet@@ ) { if ( @@sizet@@ ) { @@char@@ = ( char * ) malloc ( @@sizet@@ ) ; if ( ! @@char@@ ) return Number ; memcpy ( @@char@@ , @@constvoid@@ , @@sizet@@ ) ; memcpy ( & @@char@@ [ @@sizet@@ ] , @@constvoid@@ , @@sizet@@ ) ; @@int64@@ = re_search_stub ( @@int@@ , ( _DWORD ) @@char@@ , @@sizet@@ , @@int@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@unsignedint8@@ ) ; } else { @@int64@@ = re_search_stub ( @@int@@ , ( _DWORD ) @@constvoid@@ , @@sizet@@ , @@int@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@unsignedint8@@ ) ; } } else { @@int64@@ = re_search_stub ( @@int@@ , ( _DWORD ) @@constvoid@@ , @@sizet@@ , @@int@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@unsignedint8@@ ) ; } @@int64@@ = @@int64@@ ; free ( @@char@@ ) ; return @@int64@@ ; }
__int64 __fastcall find_recover_state ( _DWORD * @@DWORD@@ , _QWORD * @@QWORD@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; do { @@unsignedint64@@ = @@QWORD@@ [ Number ] ; @@int64@@ = @@QWORD@@ [ Number ] ; do { if ( ++ @@int64@@ > @@unsignedint64@@ ) return Number L ; ++ @@QWORD@@ [ Number ] ; } while ( ! * ( _QWORD * ) ( Number * @@int64@@ + @@QWORD@@ [ Number ] ) ) ; @@int64@@ = merge_state_with_log ( @@DWORD@@ , ( __int64 ) @@QWORD@@ , Number L ) ; } while ( ! * @@DWORD@@ && ! @@int64@@ ) ; return @@int64@@ ; }
__int64 __fastcall parse_branch ( __int64 @@int64@@ , __int64 * @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , _DWORD * @@DWORD@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = * @@int64@@ ; @@int64@@ = parse_expression ( @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@DWORD@@ ) ; if ( * @@DWORD@@ && ! @@int64@@ ) return Number L ; while ( * ( _BYTE * ) ( @@int64@@ + Number ) != Number && * ( _BYTE * ) ( @@int64@@ + Number ) != Number && ( ! @@int64@@ || * ( _BYTE * ) ( @@int64@@ + Number ) != Number ) ) { @@int64@@ = parse_expression ( @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@DWORD@@ ) ; if ( * @@DWORD@@ && ! @@int64@@ ) return Number L ; if ( @@int64@@ && @@int64@@ ) { @@int64@@ = create_tree ( @@int64@@ , @@int64@@ , @@int64@@ , Number L ) ; if ( ! @@int64@@ ) { * @@DWORD@@ = Number ; return Number L ; } } else if ( ! @@int64@@ ) { @@int64@@ = @@int64@@ ; } } return @@int64@@ ; }
__int64 __fastcall peek_token_bracket ( _BYTE * @@BYTE@@ , __int64 @@int64@@ , char @@char@@ ) { char @@char@@ ; char @@char@@ ; unsigned int @@unsignedint@@ ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) <= * ( _QWORD * ) ( @@int64@@ + Number ) ) { @@BYTE@@ [ Number ] = Number ; return Number L ; } @@char@@ = * ( _BYTE * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; * @@BYTE@@ = @@char@@ ; if ( * ( int * ) ( @@int64@@ + Number ) > Number && * ( _QWORD * ) ( @@int64@@ + Number ) != * ( _QWORD * ) ( @@int64@@ + Number ) && * ( _DWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L * * ( _QWORD * ) ( @@int64@@ + Number ) ) == Number ) { @@BYTE@@ [ Number ] = Number ; return Number L ; } if ( @@char@@ == Number && ( @@char@@ & Number ) != Number && ( unsigned __int64 ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) < * ( _QWORD * ) ( @@int64@@ + Number ) ) { ++ * ( _QWORD * ) ( @@int64@@ + Number ) ; * @@BYTE@@ = * ( _BYTE * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; @@BYTE@@ [ Number ] = Number ; return Number L ; } switch ( @@char@@ ) { case String : if ( ( unsigned __int64 ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) >= * ( _QWORD * ) ( @@int64@@ + Number ) ) @@char@@ = Number ; else @@char@@ = * ( _BYTE * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) ; * @@BYTE@@ = @@char@@ ; @@unsignedint@@ = Number ; switch ( @@char@@ ) { case String : if ( ( @@char@@ & Number ) != Number ) { @@BYTE@@ [ Number ] = Number ; return @@unsignedint@@ ; } break ; case String : @@BYTE@@ [ Number ] = Number ; return @@unsignedint@@ ; case String : @@BYTE@@ [ Number ] = Number ; return @@unsignedint@@ ; } @@BYTE@@ [ Number ] = Number ; * @@BYTE@@ = Number ; return Number ; case String : @@BYTE@@ [ Number ] = Number ; break ; case String : @@BYTE@@ [ Number ] = Number ; break ; case String : @@BYTE@@ [ Number ] = Number ; break ; default : @@BYTE@@ [ Number ] = Number ; break ; } return Number L ; }
__int64 __fastcall parse ( __int64 @@int64@@ , __int64 * @@int64@@ , __int64 @@int64@@ , _DWORD * @@DWORD@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = * @@int64@@ ; * ( _QWORD * ) ( * @@int64@@ + Number ) = @@int64@@ ; fetch_token ( ( __int64 ) @@char@@ , @@int64@@ , @@int64@@ | Number ) ; @@int64@@ = parse_reg_exp ( @@int64@@ , @@int64@@ , @@char@@ , @@int64@@ , Number L , @@DWORD@@ ) ; if ( * @@DWORD@@ && ! @@int64@@ ) return Number L ; @@int64@@ = create_tree ( @@int64@@ , Number L , Number L , Number L ) ; if ( @@int64@@ ) @@int64@@ = create_tree ( @@int64@@ , @@int64@@ , @@int64@@ , Number L ) ; else @@int64@@ = @@int64@@ ; if ( @@int64@@ && @@int64@@ ) return @@int64@@ ; * @@DWORD@@ = Number ; return Number L ; }
__int64 __fastcall pop_fail_stack ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ , __int64 @@int64@@ , void * @@void@@ , __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = -- * @@QWORD@@ ; if ( * @@QWORD@@ > Number ) __assert_fail ( String , String , Number , String ) ; * @@QWORD@@ = * ( _QWORD * ) ( @@QWORD@@ [ Number ] + Number * @@int64@@ ) ; memcpy ( @@void@@ , * ( const void * * ) ( @@QWORD@@ [ Number ] + Number * @@int64@@ + Number ) , Number * @@int64@@ ) ; free ( * ( void * * ) ( @@int64@@ + Number ) ) ; free ( * ( void * * ) ( @@QWORD@@ [ Number ] + Number * @@int64@@ + Number ) ) ; @@QWORD@@ = ( _QWORD * ) ( @@QWORD@@ [ Number ] + Number * @@int64@@ ) ; @@int64@@ = @@QWORD@@ [ Number ] ; * ( _QWORD * ) @@int64@@ = @@QWORD@@ [ Number ] ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@QWORD@@ [ Number ] ; return * ( _QWORD * ) ( @@QWORD@@ [ Number ] + Number * @@int64@@ + Number ) ; }
__int64 __fastcall build_equiv_class ( __int64 @@int64@@ , __int64 a2 , __int64 a3 , const char * @@constchar@@ ) { if ( strlen ( @@constchar@@ ) != Number ) return Number L ; bitset_set ( @@int64@@ , * ( unsigned __int8 * ) @@constchar@@ ) ; return Number L ; }
__int64 __fastcall check_subexp_matching_top ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { unsigned int @@unsignedint@@ ; unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; @@QWORD@@ = * ( _QWORD * * ) ( @@int64@@ + Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { @@int64@@ = * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( * ( _BYTE * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) == Number && * ( _QWORD * ) ( Number * @@int64@@ + * @@QWORD@@ ) <= Number && ( ( @@QWORD@@ [ Number ] >> * ( _QWORD * ) ( Number * @@int64@@ + * @@QWORD@@ ) ) & Number L ) != Number ) { @@unsignedint@@ = match_ctx_add_subtop ( @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; } } return Number L ; }
__int64 __fastcall fetch_number ( __int64 @@int64@@ , unsigned __int8 * @@unsignedint8@@ , __int64 @@int64@@ ) { unsigned __int64 @@unsignedint64@@ ; unsigned __int8 @@unsignedint8@@ ; __int64 @@int64@@ ; for ( @@int64@@ = Number ; ; @@int64@@ = @@unsignedint64@@ ) { fetch_token ( ( __int64 ) @@unsignedint8@@ , @@int64@@ , @@int64@@ ) ; @@unsignedint8@@ = * @@unsignedint8@@ ; if ( @@unsignedint8@@ [ Number ] == Number ) return Number ; if ( @@unsignedint8@@ [ Number ] == Number || @@unsignedint8@@ == Number ) break ; if ( @@unsignedint8@@ [ Number ] != Number || @@unsignedint8@@ <= Number || @@unsignedint8@@ > Number || @@int64@@ == Number ) { @@unsignedint64@@ = Number ; } else if ( @@int64@@ == Number ) { @@unsignedint64@@ = @@unsignedint8@@ - Number ; } else { @@unsignedint64@@ = Number * @@int64@@ + @@unsignedint8@@ - Number ; } if ( @@unsignedint64@@ > Number ) @@unsignedint64@@ = Number ; } return @@int64@@ ; }
__int64 __fastcall parse_sub_exp ( __int64 @@int64@@ , __int64 * @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , _DWORD * @@DWORD@@ ) { unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int64@@ = * @@int64@@ ; @@unsignedint64@@ = @@int64@@ [ Number ] ; @@int64@@ [ Number ] = @@unsignedint64@@ + Number ; @@unsignedint64@@ = @@unsignedint64@@ ; fetch_token ( @@int64@@ , @@int64@@ , @@int64@@ | Number ) ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) == Number ) { @@int64@@ = Number L ; } else { @@int64@@ = parse_reg_exp ( @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@DWORD@@ ) ; if ( ! * @@DWORD@@ && * ( _BYTE * ) ( @@int64@@ + Number ) != Number ) * @@DWORD@@ = Number ; if ( * @@DWORD@@ ) return Number L ; } if ( @@unsignedint64@@ <= Number ) * ( _QWORD * ) ( @@int64@@ + Number ) |= Number << @@unsignedint64@@ ; @@int64@@ = create_tree ( @@int64@@ , @@int64@@ , Number L , Number L ) ; if ( @@int64@@ ) { * ( _QWORD * ) ( @@int64@@ + Number ) = @@unsignedint64@@ ; @@int64@@ = @@int64@@ ; } else { * @@DWORD@@ = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall build_sifted_states ( __int64 @@int64@@ , _QWORD * @@QWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@QWORD@@ = * ( _QWORD * * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( Number * @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) + Number L ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { @@unsignedint64@@ = * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; @@int@@ = Number ; if ( ( * ( _BYTE * ) ( Number * @@unsignedint64@@ + * @@QWORD@@ + Number ) & Number ) != Number ) @@int@@ = sift_states_iter_mb ( @@int64@@ , @@QWORD@@ , @@unsignedint64@@ , @@int64@@ , @@QWORD@@ [ Number ] ) ; if ( ! @@int@@ && ( unsigned __int8 ) check_node_accept ( @@int64@@ , * @@QWORD@@ + Number * @@unsignedint64@@ , @@int64@@ ) && * ( _QWORD * ) ( Number * ( @@int64@@ + Number ) + * @@QWORD@@ ) && re_node_set_contains ( * ( _QWORD * ) ( Number * ( @@int64@@ + Number ) + * @@QWORD@@ ) + Number L , * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@QWORD@@ [ Number ] ) ) ) { @@int@@ = Number ; } if ( @@int@@ && ( ! @@QWORD@@ [ Number ] || ! ( unsigned __int8 ) check_dst_limits ( @@int64@@ , @@QWORD@@ + Number , * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@QWORD@@ [ Number ] ) , @@int@@ + @@int64@@ , @@unsignedint64@@ , @@int64@@ ) ) && ! re_node_set_insert ( @@int64@@ , @@unsignedint64@@ ) ) { return Number L ; } } return Number L ; }
__int64 __fastcall build_charclass_op ( __int64 @@int64@@ , __int64 @@int64@@ , const char * @@constchar@@ , _BYTE * @@BYTE@@ , char @@char@@ , _DWORD * @@DWORD@@ ) { int @@int@@ ; __int64 @@int64@@ ; void * @@void@@ ; _BYTE * @@BYTE@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; void * @@void@@ ; char @@char@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = Number L ; @@void@@ = calloc ( Number , Number ) ; @@BYTE@@ = calloc ( Number , Number ) ; if ( ! @@void@@ || ! @@BYTE@@ ) { * @@DWORD@@ = Number ; return Number L ; } if ( @@char@@ ) @@BYTE@@ [ Number ] |= Number ; @@int@@ = build_charclass ( @@int64@@ , ( __int64 ) @@void@@ , ( __int64 ) @@BYTE@@ , & @@int64@@ , @@constchar@@ , Number ) ; if ( @@int@@ ) { free ( @@void@@ ) ; free_charset ( @@BYTE@@ ) ; * @@DWORD@@ = @@int@@ ; return Number L ; } while ( * @@BYTE@@ ) bitset_set ( ( __int64 ) @@void@@ , ( unsigned __int8 ) * @@BYTE@@ ++ ) ; if ( @@char@@ ) bitset_not ( ( __int64 ) @@void@@ ) ; if ( * ( int * ) ( @@int64@@ + Number ) > Number ) bitset_mask ( ( __int64 ) @@void@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ; @@char@@ = Number ; @@void@@ = @@void@@ ; @@int64@@ = create_token_tree ( @@int64@@ , Number L , Number L , & @@void@@ ) ; if ( @@int64@@ ) { if ( * ( int * ) ( @@int64@@ + Number ) <= Number ) { free_charset ( @@BYTE@@ ) ; return @@int64@@ ; } @@char@@ = Number ; @@void@@ = @@BYTE@@ ; * ( _BYTE * ) ( @@int64@@ + Number ) |= Number ; @@int64@@ = create_token_tree ( @@int64@@ , Number L , Number L , & @@void@@ ) ; if ( @@int64@@ ) { @@int64@@ = create_tree ( @@int64@@ , @@int64@@ , @@int64@@ , Number L ) ; if ( @@int64@@ ) return @@int64@@ ; } } free ( @@void@@ ) ; free_charset ( @@BYTE@@ ) ; * @@DWORD@@ = Number ; return Number L ; }
__int64 __fastcall check_arrival_expand_ecl_sub ( _QWORD * @@QWORD@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , unsigned int @@unsignedint@@ ) { unsigned __int64 @@unsignedint64@@ ; unsigned int @@unsignedint@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint64@@ ; for ( @@unsignedint64@@ = re_node_set_contains ( @@int64@@ , @@unsignedint64@@ ) ; ! @@unsignedint64@@ ; @@unsignedint64@@ = re_node_set_contains ( @@int64@@ , @@unsignedint64@@ ) ) { if ( @@unsignedint@@ == * ( unsigned __int8 * ) ( Number * @@unsignedint64@@ + * @@QWORD@@ + Number ) && @@int64@@ == * ( _QWORD * ) ( Number * @@unsignedint64@@ + * @@QWORD@@ ) ) { if ( @@unsignedint@@ == Number && ! re_node_set_insert ( @@int64@@ , @@unsignedint64@@ ) ) { return Number L ; } return Number L ; } if ( ! re_node_set_insert ( @@int64@@ , @@unsignedint64@@ ) ) return Number L ; if ( ! * ( _QWORD * ) ( @@QWORD@@ [ Number ] + Number * @@unsignedint64@@ + Number ) ) return Number L ; if ( * ( _QWORD * ) ( @@QWORD@@ [ Number ] + Number * @@unsignedint64@@ + Number ) == Number L ) { @@unsignedint@@ = check_arrival_expand_ecl_sub ( @@QWORD@@ , @@int64@@ , * ( _QWORD * ) ( * ( _QWORD * ) ( @@QWORD@@ [ Number ] + Number * @@unsignedint64@@ + Number ) + Number L ) , @@int64@@ , @@unsignedint@@ ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; } @@unsignedint64@@ = * * ( _QWORD * * ) ( @@QWORD@@ [ Number ] + Number * @@unsignedint64@@ + Number ) ; } return Number L ; }
__int64 __fastcall duplicate_tree ( __int64 * * @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 * @@int64@@ ; __int64 * @@int64@@ ; __int64 * @@int64@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = & @@int64@@ ; @@int64@@ = * @@int64@@ ; @@int64@@ = ( __int64 * ) @@int64@@ ; while ( Number ) { @@int64@@ = create_token_tree ( @@int64@@ , Number L , Number L , @@int64@@ + Number ) ; * @@int64@@ = @@int64@@ ; if ( ! * @@int64@@ ) break ; * ( _QWORD * ) * @@int64@@ = @@int64@@ ; * ( _BYTE * ) ( * @@int64@@ + Number ) |= Number ; @@int64@@ = ( __int64 * ) * @@int64@@ ; if ( @@int64@@ [ Number ] ) { @@int64@@ = ( __int64 * ) @@int64@@ [ Number ] ; @@int64@@ = @@int64@@ + Number ; } else { @@int64@@ = Number L ; while ( @@int64@@ == ( __int64 * ) @@int64@@ [ Number ] || ! @@int64@@ [ Number ] ) { @@int64@@ = @@int64@@ ; @@int64@@ = ( __int64 * ) * @@int64@@ ; @@int64@@ = ( __int64 * ) * @@int64@@ ; if ( ! @@int64@@ ) return @@int64@@ ; } @@int64@@ = ( __int64 * ) @@int64@@ [ Number ] ; @@int64@@ = @@int64@@ + Number ; } } return Number L ; }
__int64 __fastcall create_tree ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , char @@char@@ ) { char @@char24@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@char24@@ [ Number ] = @@char@@ ; return create_token_tree ( @@int64@@ , @@int64@@ , @@int64@@ , @@char24@@ ) ; }
__int64 __fastcall check_dst_limits_calc_pos_1 ( __int64 @@int64@@ , int @@int@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { int @@int@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; @@QWORD@@ = * ( _QWORD * * ) ( @@int64@@ + Number ) ; @@int64@@ = @@QWORD@@ [ Number ] + Number * @@int64@@ ; for ( @@unsignedint64@@ = Number L ; ; ++ @@unsignedint64@@ ) { if ( @@unsignedint64@@ >= * ( _QWORD * ) ( @@int64@@ + Number ) ) return ( @@int@@ >> Number ) & Number ; @@int64@@ = * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; @@int@@ = * ( unsigned __int8 * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) ; if ( @@int@@ == Number ) { if ( ( @@int@@ & Number ) != Number && @@unsignedint64@@ == * ( _QWORD * ) ( Number * @@int64@@ + * @@QWORD@@ ) ) { return Number ; } continue ; } if ( @@int@@ != Number ) break ; if ( ( @@int@@ & Number ) != Number && @@unsignedint64@@ == * ( _QWORD * ) ( Number * @@int64@@ + * @@QWORD@@ ) ) { return Number L ; } LABEL_29 : ; } if ( @@int@@ != Number || @@int64@@ == Number ) goto LABEL_29 ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ ; while ( Number ) { if ( @@int64@@ != * ( _QWORD * ) @@int64@@ || @@unsignedint64@@ <= Number && ( ( * ( unsigned __int16 * ) ( @@int64@@ + Number ) >> @@unsignedint64@@ ) & Number L ) == Number ) { goto LABEL_21 ; } @@int64@@ = * * ( _QWORD * * ) ( @@QWORD@@ [ Number ] + Number * @@int64@@ + Number ) ; if ( @@int64@@ == @@int64@@ ) break ; @@int@@ = check_dst_limits_calc_pos_1 ( @@int64@@ , @@int@@ , @@unsignedint64@@ , @@int64@@ , @@int64@@ ) ; if ( @@int@@ == Number ) return Number ; if ( ! @@int@@ && ( @@int@@ & Number ) != Number ) return Number L ; if ( @@unsignedint64@@ <= Number ) * ( _WORD * ) ( @@int64@@ + Number ) &= ~ ( unsigned __int16 ) ( Number L << @@unsignedint64@@ ) ; LABEL_21 : @@int64@@ = @@int64@@ ; @@int64@@ += Number L ; if ( ! * ( _BYTE * ) ( @@int64@@ + Number ) ) goto LABEL_29 ; } if ( ( @@int@@ & Number ) != Number ) @@int64@@ = Number ; else @@int64@@ = Number L ; return @@int64@@ ; }
__int64 __fastcall prune_impossible_nodes ( __int64 @@int64@@ ) { unsigned int @@unsignedint@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; char @@char@@ [ Number ] ; void * @@void@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ = Number L ; @@unsignedint64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( @@unsignedint64@@ > Number ) return Number L ; @@QWORD@@ = malloc ( Number * ( @@unsignedint64@@ + Number ) ) ; if ( @@QWORD@@ ) { if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) { @@QWORD@@ = malloc ( Number * ( @@unsignedint64@@ + Number ) ) ; if ( @@QWORD@@ ) { while ( Number ) { memset ( @@QWORD@@ , Number , Number * ( @@unsignedint64@@ + Number ) ) ; sift_ctx_init ( @@char@@ , @@QWORD@@ , @@QWORD@@ , @@int64@@ , @@unsignedint64@@ ) ; @@unsignedint@@ = sift_states_backward ( @@int64@@ , @@char@@ ) ; free ( @@void@@ ) ; if ( @@unsignedint@@ ) break ; if ( * @@QWORD@@ || * @@QWORD@@ ) { @@unsignedint@@ = merge_state_array ( @@int64@@ , @@QWORD@@ , @@QWORD@@ , @@unsignedint64@@ + Number ) ; free ( @@QWORD@@ ) ; @@QWORD@@ = Number L ; if ( ! @@unsignedint@@ ) goto LABEL_21 ; break ; } do { if ( -- @@unsignedint64@@ > Number ) { @@unsignedint@@ = Number ; goto LABEL_22 ; } } while ( ! * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) || ( * ( _BYTE * ) ( * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) + Number L ) & Number ) == Number ) ; @@int64@@ = check_halt_state_context ( @@int64@@ , * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) , @@unsignedint64@@ ) ; } } else { @@unsignedint@@ = Number ; } } else { sift_ctx_init ( @@char@@ , @@QWORD@@ , Number L , @@int64@@ , @@unsignedint64@@ ) ; @@unsignedint@@ = sift_states_backward ( @@int64@@ , @@char@@ ) ; free ( @@void@@ ) ; if ( ! @@unsignedint@@ ) { if ( * @@QWORD@@ ) { LABEL_21 : free ( * ( void * * ) ( @@int64@@ + Number ) ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@QWORD@@ ; @@QWORD@@ = Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@unsignedint64@@ ; @@unsignedint@@ = Number ; } else { @@unsignedint@@ = Number ; } } } } else { @@unsignedint@@ = Number ; } LABEL_22 : free ( @@QWORD@@ ) ; free ( @@QWORD@@ ) ; return @@unsignedint@@ ; }
_QWORD * __fastcall match_ctx_clean ( _QWORD * @@QWORD@@ ) { _QWORD * @@QWORD@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; void * @@void@@ ; void * * @@void@@ ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@QWORD@@ [ Number ] ; ++ @@unsignedint64@@ ) { @@void@@ = * ( void * * ) ( Number * @@unsignedint64@@ + @@QWORD@@ [ Number ] ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( ( _QWORD * ) @@void@@ + Number ) ; ++ @@unsignedint64@@ ) { @@void@@ = * ( void * * * ) ( Number * @@unsignedint64@@ + * ( ( _QWORD * ) @@void@@ + Number ) ) ; free ( @@void@@ [ Number ] ) ; free ( @@void@@ ) ; } free ( * ( ( void * * ) @@void@@ + Number ) ) ; if ( * ( ( _QWORD * ) @@void@@ + Number ) ) { free ( * ( void * * ) ( * ( ( _QWORD * ) @@void@@ + Number ) + Number L ) ) ; free ( * ( ( void * * ) @@void@@ + Number ) ) ; } free ( @@void@@ ) ; } @@QWORD@@ [ Number ] = Number L ; @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ [ Number ] = Number L ; return @@QWORD@@ ; }
__int64 __fastcall check_halt_state_context ( __int64 @@int64@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { char @@char@@ ; unsigned __int64 @@unsignedint64@@ ; @@char@@ = re_string_context_at ( @@int64@@ , @@unsignedint64@@ , * ( _DWORD * ) ( @@int64@@ + Number ) ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { if ( check_halt_node_context ( * ( _QWORD * * ) ( @@int64@@ + Number ) , * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) , @@char@@ ) ) { return * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; } } return Number L ; }
__int64 __fastcall find_subexp_node ( _QWORD * @@QWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ , int @@int@@ ) { unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { @@int64@@ = Number L * * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) + * @@QWORD@@ ; if ( @@int@@ == * ( unsigned __int8 * ) ( @@int64@@ + Number ) && @@int64@@ == * ( _QWORD * ) @@int64@@ ) { return * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; } } return Number ; }
__int64 __fastcall create_token_tree ( __int64 @@int64@@ , __int64 * @@int64@@ , __int64 * @@int64@@ , _QWORD * @@QWORD@@ ) { __int64 @@int64@@ ; int @@int@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; if ( * ( _DWORD * ) ( @@int64@@ + Number ) == Number ) { @@QWORD@@ = malloc ( Number ) ; if ( ! @@QWORD@@ ) return Number L ; * @@QWORD@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@QWORD@@ ; * ( _DWORD * ) ( @@int64@@ + Number ) = Number ; } @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) ; * ( _DWORD * ) ( @@int64@@ + Number ) = @@int@@ + Number ; @@int64@@ = @@int64@@ + ( ( __int64 ) @@int@@ << Number ) + Number ; * ( _QWORD * ) @@int64@@ = Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; @@int64@@ = @@QWORD@@ [ Number ] ; * ( _QWORD * ) ( @@int64@@ + Number ) = * @@QWORD@@ ; * ( _QWORD * ) ( @@int64@@ + ( ( __int64 ) @@int@@ << Number ) + Number ) = @@int64@@ ; * ( _BYTE * ) ( @@int64@@ + Number ) &= Number ; * ( _BYTE * ) ( @@int64@@ + Number ) &= Number ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number ; if ( @@int64@@ ) * @@int64@@ = @@int64@@ ; if ( @@int64@@ ) * @@int64@@ = @@int64@@ ; return @@int64@@ + ( ( __int64 ) @@int@@ << Number ) + Number ; }
__int64 __fastcall xnrealloc ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { if ( ! is_mul_ok ( @@unsignedint64@@ , @@unsignedint64@@ ) ) xalloc_die ( ) ; return xrealloc ( @@int64@@ , @@unsignedint64@@ * @@unsignedint64@@ ) ; }
__int64 __fastcall clean_state_log_if_needed ( _QWORD * @@QWORD@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned int @@unsignedint@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = @@QWORD@@ [ Number ] ; if ( @@unsignedint64@@ >= @@QWORD@@ [ Number ] || @@unsignedint64@@ >= @@QWORD@@ [ Number ] && @@QWORD@@ [ Number ] < @@QWORD@@ [ Number ] ) { @@unsignedint@@ = extend_buffers ( @@QWORD@@ ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; } if ( @@unsignedint64@@ < @@unsignedint64@@ ) { memset ( ( void * ) ( Number * ( @@unsignedint64@@ + Number ) + @@QWORD@@ [ Number ] ) , Number , Number * ( @@unsignedint64@@ - @@unsignedint64@@ ) ) ; @@QWORD@@ [ Number ] = @@unsignedint64@@ ; } return Number L ; }
__int64 __fastcall free_fail_stack_return ( __int64 @@int64@@ ) { unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) { for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) @@int64@@ ; ++ @@unsignedint64@@ ) { free ( * ( void * * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@unsignedint64@@ + Number ) ) ; free ( * ( void * * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@unsignedint64@@ + Number ) ) ; } free ( * ( void * * ) ( @@int64@@ + Number ) ) ; } return Number L ; }
__int64 __fastcall push_fail_stack ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , const void * @@constvoid@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; void * @@void@@ ; @@int64@@ = ( * ( _QWORD * ) @@int64@@ ) ++ ; @@int64@@ = @@int64@@ ; if ( * ( _QWORD * ) @@int64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ) { @@void@@ = realloc ( * ( void * * ) ( @@int64@@ + Number ) , Number L * * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( ! @@void@@ ) return Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) *= Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@void@@ ; } * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ ) = @@int64@@ ; * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ + Number ) = @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = malloc ( Number * @@int64@@ ) ; if ( ! * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ + Number ) ) return Number L ; memcpy ( * ( void * * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ + Number ) , @@constvoid@@ , Number * @@int64@@ ) ; return ( unsigned int ) re_node_set_init_copy ( ( void * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ + Number ) , @@int64@@ ) ; }
_BOOL8 __fastcall check_node_accept ( __int64 @@int64@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { int @@int@@ ; _BOOL8 @@BOOL8@@ ; char @@char@@ ; char @@char@@ ; @@char@@ = * ( _BYTE * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + @@unsignedint64@@ ) ; @@int@@ = * ( unsigned __int8 * ) ( @@int64@@ + Number ) ; if ( @@int@@ == Number ) { if ( ! bitset_contain ( * ( _QWORD * ) @@int64@@ , ( unsigned __int8 ) @@char@@ ) ) return Number L ; } else if ( * ( unsigned __int8 * ) ( @@int64@@ + Number ) > Number ) { if ( @@int@@ != Number ) { if ( @@int@@ != Number ) return Number L ; if ( @@char@@ < Number ) return Number L ; } if ( @@char@@ == Number && ( * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) & Number ) == Number || ! @@char@@ && ( * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) & Number ) != Number ) { return Number L ; } } else { if ( @@int@@ != Number ) return Number L ; if ( @@char@@ != * ( _BYTE * ) @@int64@@ ) return Number L ; } @@BOOL8@@ = Number ; if ( ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number ) { if ( ( @@char@@ = re_string_context_at ( @@int64@@ , @@unsignedint64@@ , * ( _DWORD * ) ( @@int64@@ + Number ) ) , ( ( * ( _DWORD * ) ( @@int64@@ + Number ) >> Number ) & Number ) != Number ) && ( @@char@@ & Number ) == Number || ( ( * ( _DWORD * ) ( @@int64@@ + Number ) >> Number ) & Number ) != Number && ( @@char@@ & Number ) != Number || ( ( * ( _DWORD * ) ( @@int64@@ + Number ) >> Number ) & Number ) != Number && ( @@char@@ & Number ) == Number || ( ( * ( _DWORD * ) ( @@int64@@ + Number ) >> Number ) & Number ) != Number && ( @@char@@ & Number ) == Number ) { @@BOOL8@@ = Number ; } } return @@BOOL8@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ ) { return xmalloc ( @@int64@@ ) ; }
__int64 __fastcall sub_epsilon_src_nodes ( _QWORD * @@QWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; unsigned int @@unsignedint@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; char @@char@@ [ Number ] ; void * @@void@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = @@QWORD@@ [ Number ] + Number * @@int64@@ ; memset ( @@char@@ , Number , Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { @@int64@@ = * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( @@int64@@ != @@int64@@ && ( * ( _BYTE * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) & Number ) != Number ) { @@unsignedint64@@ = * * ( _QWORD * * ) ( @@QWORD@@ [ Number ] + Number * @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@QWORD@@ [ Number ] + Number * @@int64@@ + Number ) <= Number ? Number : * ( _QWORD * ) ( * ( _QWORD * ) ( @@QWORD@@ [ Number ] + Number * @@int64@@ + Number ) + Number L ) ; if ( ( @@unsignedint64@@ = @@int64@@ , ! re_node_set_contains ( @@int64@@ , @@unsignedint64@@ ) ) && re_node_set_contains ( @@int64@@ , @@unsignedint64@@ ) || @@unsignedint64@@ - Number <= Number && ! re_node_set_contains ( @@int64@@ , @@unsignedint64@@ ) && re_node_set_contains ( @@int64@@ , @@unsignedint64@@ ) ) { @@unsignedint@@ = re_node_set_add_intersect ( ( __int64 ) @@char@@ , @@int64@@ , @@QWORD@@ [ Number ] + Number * @@int64@@ ) ; if ( @@unsignedint@@ ) { free ( @@void@@ ) ; return @@unsignedint@@ ; } } } } for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { @@unsignedint64@@ = * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( ! re_node_set_contains ( ( __int64 ) @@char@@ , @@unsignedint64@@ ) ) { @@unsignedint64@@ = re_node_set_contains ( @@int64@@ , @@unsignedint64@@ ) - Number ; re_node_set_remove_at ( @@int64@@ , @@unsignedint64@@ ) ; } } free ( @@void@@ ) ; return Number L ; }
__int64 __fastcall sift_states_backward ( __int64 @@int64@@ , __int64 @@int64@@ ) { int @@int@@ ; unsigned int @@unsignedint@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; __int64 @@int64@@ ; void * @@void@@ [ Number ] ; void * @@void@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int@@ = Number ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@unsignedint@@ = re_node_set_init_1 ( @@void@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; @@unsignedint@@ = update_cur_sifted_state ( @@int64@@ , @@int64@@ , @@int64@@ , @@void@@ ) ; if ( ! @@unsignedint@@ ) { while ( @@int64@@ ) { if ( * ( _QWORD * ) ( Number * @@int64@@ + * ( _QWORD * ) @@int64@@ ) ) @@int@@ = Number ; else @@int@@ = @@int@@ + Number ; @@int@@ = @@int@@ ; if ( @@int@@ > * ( _DWORD * ) ( @@int64@@ + Number ) ) { memset ( * ( void * * ) @@int64@@ , Number , Number * @@int64@@ ) ; free ( @@void@@ ) ; return Number L ; } @@void@@ [ Number ] = Number L ; -- @@int64@@ ; if ( ! * ( _QWORD * ) ( Number * @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) || ( @@unsignedint@@ = build_sifted_states ( @@int64@@ , @@int64@@ , @@int64@@ , @@void@@ ) ) == Number ) { @@unsignedint@@ = update_cur_sifted_state ( @@int64@@ , @@int64@@ , @@int64@@ , @@void@@ ) ; if ( ! @@unsignedint@@ ) continue ; } goto LABEL_15 ; } @@unsignedint@@ = Number ; } LABEL_15 : free ( @@void@@ ) ; return @@unsignedint@@ ; }
__int64 __fastcall merge_state_array ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { _QWORD * @@QWORD@@ ; unsigned int @@unsignedint@@ ; unsigned __int64 @@unsignedint64@@ ; void * @@void6@@ [ Number ] ; @@void6@@ [ Number ] = ( void * ) __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@unsignedint64@@ ; ++ @@unsignedint64@@ ) { if ( * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@int64@@ ) ) { if ( * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@int64@@ ) ) { @@unsignedint@@ = re_node_set_init_union ( @@void6@@ , * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@int64@@ ) + Number L , * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@int64@@ ) + Number L ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; @@QWORD@@ = ( _QWORD * ) ( Number * @@unsignedint64@@ + @@int64@@ ) ; * @@QWORD@@ = re_acquire_state ( & @@unsignedint@@ , @@int64@@ , ( __int64 ) @@void6@@ ) ; free ( @@void6@@ [ Number ] ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; } } else { * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@int64@@ ) = * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@int64@@ ) ; } } return Number L ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@unsignedint64@@ , int @@int@@ ) { __int64 @@int64@@ ; if ( is_mul_ok ( @@int@@ , * @@unsignedint64@@ ) ) { * @@unsignedint64@@ *= @@int@@ ; @@int64@@ = Number L ; } else { * @@unsignedint64@@ = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall search_cur_bkref_entry ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@unsignedint64@@ = Number L ; while ( @@unsignedint64@@ < @@unsignedint64@@ ) { if ( @@unsignedint64@@ <= * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * ( ( @@unsignedint64@@ + @@unsignedint64@@ ) >> Number ) + Number ) ) @@unsignedint64@@ = ( @@unsignedint64@@ + @@unsignedint64@@ ) >> Number ; else @@unsignedint64@@ = ( ( @@unsignedint64@@ + @@unsignedint64@@ ) >> Number ) + Number ; } if ( @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) && @@unsignedint64@@ == * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@unsignedint64@@ + Number ) ) { @@int64@@ = @@unsignedint64@@ ; } else { @@int64@@ = Number ; } return @@int64@@ ; }
__int64 __fastcall get_subexp_sub ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; unsigned int @@unsignedint@@ ; unsigned int @@unsignedint@@ ; @@unsignedint@@ = check_arrival ( ( _DWORD ) @@QWORD@@ , ( int ) @@QWORD@@ + Number , * @@QWORD@@ , @@QWORD@@ [ Number ] , @@int64@@ , @@int64@@ , Number ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; @@unsignedint@@ = match_ctx_add_entry ( @@QWORD@@ , @@int64@@ , @@int64@@ , * @@QWORD@@ , @@QWORD@@ [ Number ] ) ; if ( @@unsignedint@@ ) @@int64@@ = @@unsignedint@@ ; else @@int64@@ = clean_state_log_if_needed ( @@QWORD@@ , @@int64@@ + @@QWORD@@ [ Number ] - * @@QWORD@@ ) ; return @@int64@@ ; }
__int64 __fastcall update_cur_sifted_state ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; unsigned int @@unsignedint@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = @@QWORD@@ [ Number ] ; @@unsignedint@@ = Number ; if ( * ( _QWORD * ) ( Number * @@int64@@ + @@QWORD@@ [ Number ] ) ) @@int64@@ = * ( _QWORD * ) ( Number * @@int64@@ + @@QWORD@@ [ Number ] ) + Number L ; else @@int64@@ = Number L ; @@int64@@ = @@int64@@ ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) { if ( @@int64@@ ) { @@unsignedint@@ = add_epsilon_src_nodes ( @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; if ( @@QWORD@@ [ Number ] ) { @@unsignedint@@ = check_subexp_limits ( @@int64@@ , @@int64@@ , @@int64@@ , @@QWORD@@ + Number , @@QWORD@@ [ Number ] , @@int64@@ ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; } } @@QWORD@@ = ( _QWORD * ) ( * @@QWORD@@ + Number * @@int64@@ ) ; * @@QWORD@@ = re_acquire_state ( & @@unsignedint@@ , @@int64@@ , @@int64@@ ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; } else { * ( _QWORD * ) ( Number * @@int64@@ + * @@QWORD@@ ) = Number L ; } if ( @@int64@@ && ( * ( _BYTE * ) ( * ( _QWORD * ) ( Number * @@int64@@ + @@QWORD@@ [ Number ] ) + Number L ) & Number ) != Number && ( @@unsignedint@@ = sift_states_bkref ( @@QWORD@@ , @@QWORD@@ , @@int64@@ , @@int64@@ ) ) != Number ) { @@int64@@ = @@unsignedint@@ ; } else { @@int64@@ = Number L ; } return @@int64@@ ; }
bool __fastcall is_basic_1 ( unsigned __int8 @@unsignedint8@@ ) { return ( ( is_basic_table [ @@unsignedint8@@ >> Number ] >> ( @@unsignedint8@@ & Number ) ) & Number ) != Number ; }
const char * locale_charset ( ) { const char * @@constchar@@ ; char * @@char@@ ; char * @@char@@ ; @@constchar@@ = nl_langinfo ( Number ) ; if ( ! @@constchar@@ ) @@constchar@@ = ( const char * ) & unk_24D6E ; for ( @@char@@ = ( char * ) get_charset_aliases ( ) ; * @@char@@ ; @@char@@ = & @@char@@ [ strlen ( @@char@@ ) + Number ] ) { if ( ! strcmp ( @@constchar@@ , @@char@@ ) || * @@char@@ == Number && ! @@char@@ [ Number ] ) { @@constchar@@ = & @@char@@ [ strlen ( @@char@@ ) + Number ] ; break ; } @@char@@ = & @@char@@ [ strlen ( @@char@@ ) + Number ] ; } if ( ! * @@constchar@@ ) @@constchar@@ = String ; return @@constchar@@ ; }
__int64 __fastcall check_dst_limits ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; @@QWORD@@ = * ( _QWORD * * ) ( @@int64@@ + Number ) ; @@int64@@ = search_cur_bkref_entry ( @@int64@@ , @@int64@@ ) ; @@int64@@ = search_cur_bkref_entry ( @@int64@@ , @@int64@@ ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { @@int64@@ = * ( _QWORD * ) ( * @@QWORD@@ + Number L * * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L * * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ) ; @@int64@@ = ( int ) check_dst_limits_calc_pos ( @@int64@@ , * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) , @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( ( int ) check_dst_limits_calc_pos ( @@int64@@ , * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) , @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ ) != @@int64@@ ) return Number L ; } return Number L ; }
__int64 __fastcall check_arrival_expand_ecl ( _QWORD * @@QWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; unsigned int @@unsignedint@@ ; unsigned int @@unsignedint@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ [ Number ] ; void * @@void@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@unsignedint@@ = re_node_set_alloc ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { @@int64@@ = * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; @@int64@@ = @@QWORD@@ [ Number ] + Number * @@int64@@ ; if ( find_subexp_node ( @@QWORD@@ , @@int64@@ , @@int64@@ , @@unsignedint@@ ) == Number ) { @@unsignedint@@ = re_node_set_merge ( ( __int64 ) @@int64@@ , @@int64@@ ) ; if ( @@unsignedint@@ ) goto LABEL_6 ; } else { @@unsignedint@@ = check_arrival_expand_ecl_sub ( @@QWORD@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@unsignedint@@ ) ; if ( @@unsignedint@@ ) { LABEL_6 : free ( @@void@@ ) ; return @@unsignedint@@ ; } } } free ( * ( void * * ) ( @@int64@@ + Number ) ) ; @@int64@@ = @@int64@@ [ Number ] ; * ( _QWORD * ) @@int64@@ = @@int64@@ [ Number ] ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@void@@ ; return Number L ; }
__int64 __fastcall c_toupper ( int @@int@@ ) { __int64 @@int64@@ ; if ( @@int@@ <= Number || @@int@@ > Number ) @@int64@@ = ( unsigned int ) @@int@@ ; else @@int64@@ = ( unsigned int ) ( @@int@@ - Number ) ; return @@int64@@ ; }
__int64 __fastcall transit_state ( _DWORD * @@DWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int8 @@unsignedint8@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; if ( ( * ( _BYTE * ) ( @@int64@@ + Number ) & Number ) != Number ) { * @@DWORD@@ = transit_state_mb ( @@int64@@ , @@int64@@ ) ; if ( * @@DWORD@@ ) return Number L ; } @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ + Number ; @@unsignedint8@@ = * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) ; while ( Number ) { @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( @@int64@@ ) return * ( _QWORD * ) ( Number L * @@unsignedint8@@ + @@int64@@ ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( @@int64@@ ) break ; if ( ( unsigned __int8 ) build_trtable ( * ( _QWORD * ) ( @@int64@@ + Number ) , @@int64@@ ) != Number ) { * @@DWORD@@ = Number ; return Number L ; } } if ( ( re_string_context_at ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) - Number L , * ( _DWORD * ) ( @@int64@@ + Number ) ) & Number ) != Number ) @@int64@@ = Number * ( @@unsignedint8@@ + Number L ) ; else @@int64@@ = Number L * @@unsignedint8@@ ; return * ( _QWORD * ) ( @@int64@@ + @@int64@@ ) ; }
char * __fastcall str_iconv ( char * @@char@@ , char * @@char@@ , char * @@char@@ ) { char * @@char@@ ; int @@int@@ ; int @@int@@ ; iconv_t @@iconvt@@ ; void * @@void@@ ; char * @@char@@ ; if ( * @@char@@ && ( unsigned int ) c_strcasecmp ( ( unsigned __int8 * ) @@char@@ , ( unsigned __int8 * ) @@char@@ ) ) { @@iconvt@@ = iconv_open ( @@char@@ , @@char@@ ) ; if ( @@iconvt@@ == ( iconv_t ) Number ) return Number L ; @@void@@ = str_cd_iconv ( @@char@@ , @@iconvt@@ ) ; if ( @@void@@ ) { if ( iconv_close ( @@iconvt@@ ) < Number ) { @@int@@ = * __errno_location ( ) ; free ( @@void@@ ) ; * __errno_location ( ) = @@int@@ ; return Number L ; } } else { @@int@@ = * __errno_location ( ) ; iconv_close ( @@iconvt@@ ) ; * __errno_location ( ) = @@int@@ ; } @@char@@ = ( char * ) @@void@@ ; } else { @@char@@ = strdup ( @@char@@ ) ; if ( ! @@char@@ ) * __errno_location ( ) = Number ; @@char@@ = @@char@@ ; } return @@char@@ ; }
__int64 __fastcall check_dst_limits_calc_pos ( __int64 @@int64@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ ; if ( @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ) return Number ; if ( @@unsignedint64@@ > * ( _QWORD * ) ( @@int64@@ + Number ) ) return Number L ; if ( @@unsignedint64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ) @@int@@ = Number ; else @@int@@ = Number ; @@int@@ = @@int@@ | ( @@unsignedint64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( @@int@@ ) @@int64@@ = check_dst_limits_calc_pos_1 ( @@int64@@ , @@int@@ , @@unsignedint64@@ , @@int64@@ , @@int64@@ ) ; else @@int64@@ = Number L ; return @@int64@@ ; }
__int64 __fastcall match_ctx_init ( __int64 @@int64@@ , int @@int@@ , unsigned __int64 @@unsignedint64@@ ) { * ( _DWORD * ) ( @@int64@@ + Number ) = @@int@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number ; if ( ! @@unsignedint64@@ ) goto LABEL_7 ; if ( ! is_mul_ok ( Number , @@unsignedint64@@ ) ) return Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = malloc ( Number * @@unsignedint64@@ ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = malloc ( Number * @@unsignedint64@@ ) ; if ( ! * ( _QWORD * ) ( @@int64@@ + Number ) || ! * ( _QWORD * ) ( @@int64@@ + Number ) ) return Number L ; LABEL_7 : * ( _QWORD * ) ( @@int64@@ + Number ) = @@unsignedint64@@ ; * ( _DWORD * ) ( @@int64@@ + Number ) = Number ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@unsignedint64@@ ; return Number L ; }
void __fastcall freea ( unsigned __int64 @@unsignedint64@@ ) { _QWORD * @@QWORD@@ ; if ( @@unsignedint64@@ && * ( _DWORD * ) ( @@unsignedint64@@ - Number ) == Number ) { for ( @@QWORD@@ = & mmalloca_results [ @@unsignedint64@@ % Number ] ; * @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) ( * @@QWORD@@ - Number L ) ) { if ( @@unsignedint64@@ == * @@QWORD@@ ) { * @@QWORD@@ = * ( _QWORD * ) ( @@unsignedint64@@ - Number ) ; free ( ( void * ) ( @@unsignedint64@@ - Number ) ) ; return ; } } } }
bool __fastcall is_basic_2 ( unsigned __int8 @@unsignedint8@@ ) { return ( ( is_basic_table [ @@unsignedint8@@ >> Number ] >> ( @@unsignedint8@@ & Number ) ) & Number ) != Number ; }
__int64 __fastcall check_arrival_add_next_nodes ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; char @@char@@ [ Number ] ; __int64 @@int64@@ ; void * @@void@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@QWORD@@ = * ( _QWORD * * ) ( @@int64@@ + Number ) ; @@unsignedint@@ = Number ; memset ( @@char@@ , Number , Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { @@int@@ = Number ; @@int64@@ = * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( ( * ( _BYTE * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) & Number ) != Number ) { @@int@@ = check_node_accept_bytes ( @@QWORD@@ , @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( @@int@@ > Number ) { @@unsignedint64@@ = * ( _QWORD * ) ( Number * @@int64@@ + @@QWORD@@ [ Number ] ) ; @@int64@@ = @@int@@ + @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( Number * @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; @@int64@@ = Number L ; if ( @@int64@@ ) { @@unsignedint@@ = re_node_set_merge ( ( __int64 ) @@char@@ , @@int64@@ + Number ) ; if ( @@unsignedint@@ ) goto LABEL_6 ; } if ( ! re_node_set_insert ( ( __int64 ) @@char@@ , @@unsignedint64@@ ) ) goto LABEL_8 ; @@QWORD@@ = ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ ) ; * @@QWORD@@ = re_acquire_state ( & @@unsignedint@@ , ( __int64 ) @@QWORD@@ , ( __int64 ) @@char@@ ) ; if ( ! * ( _QWORD * ) ( Number * @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ) { if ( @@unsignedint@@ ) { LABEL_6 : free ( @@void@@ ) ; return @@unsignedint@@ ; } } } } if ( ( @@int@@ || ( unsigned __int8 ) check_node_accept ( @@int64@@ , * @@QWORD@@ + Number * @@int64@@ , @@int64@@ ) ) && ! re_node_set_insert ( @@int64@@ , * ( _QWORD * ) ( Number * @@int64@@ + @@QWORD@@ [ Number ] ) ) ) { LABEL_8 : free ( @@void@@ ) ; return Number L ; } } free ( @@void@@ ) ; return Number L ; }
__int64 __fastcall match_ctx_add_subtop ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; void * * @@void@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; void * @@void@@ ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) == * ( _QWORD * ) ( @@int64@@ + Number ) ) { @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = Number * @@int64@@ ; @@void@@ = realloc ( * ( void * * ) ( @@int64@@ + Number ) , Number * @@int64@@ ) ; if ( ! @@void@@ ) return Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@void@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; } @@void@@ = ( void * * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L * * ( _QWORD * ) ( @@int64@@ + Number ) ) ; * @@void@@ = calloc ( Number , Number ) ; if ( ! * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L * * ( _QWORD * ) ( @@int64@@ + Number ) ) ) return Number L ; * ( _QWORD * ) ( * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L * * ( _QWORD * ) ( @@int64@@ + Number ) ) + Number L ) = @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ + Number ; * * ( _QWORD * * ) ( @@int64@@ + Number * @@int64@@ ) = @@int64@@ ; return Number L ; }
__int64 __fastcall merge_state_with_log ( _DWORD * @@DWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned int @@unsignedint@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ [ Number ] ; void * @@void@@ ; unsigned __int64 @@unsignedint64@@ ; @@int64@@ = @@int64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@unsignedint64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( @@unsignedint64@@ <= * ( _QWORD * ) ( @@int64@@ + Number ) ) { if ( * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ) { @@int64@@ = Number L ; @@int64@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) + Number L ) ; if ( @@int64@@ ) { @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * @@DWORD@@ = re_node_set_init_union ( @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( * @@DWORD@@ ) return Number L ; } else { @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ [ Number ] = * ( _QWORD * ) @@int64@@ ; @@int64@@ [ Number ] = @@int64@@ ; @@void@@ = * ( void * * ) ( @@int64@@ + Number ) ; } @@unsignedint@@ = re_string_context_at ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) - Number L , * ( _DWORD * ) ( @@int64@@ + Number ) ) ; @@int64@@ = ( __int64 * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@unsignedint64@@ ) ; * @@int64@@ = re_acquire_state_context ( @@DWORD@@ , @@int64@@ , ( __int64 ) @@int64@@ , @@unsignedint@@ ) ; @@int64@@ = * @@int64@@ ; if ( @@int64@@ ) free ( @@void@@ ) ; } else { * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@unsignedint64@@ ) = @@int64@@ ; } } else { * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@unsignedint64@@ ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@unsignedint64@@ ; } if ( * ( _QWORD * ) ( @@int64@@ + Number ) && @@int64@@ ) { * @@DWORD@@ = check_subexp_matching_top ( @@int64@@ , @@int64@@ + Number , @@unsignedint64@@ ) ; if ( * @@DWORD@@ ) return Number L ; if ( ( * ( _BYTE * ) ( @@int64@@ + Number ) & Number ) != Number ) { * @@DWORD@@ = transit_state_bkref ( @@int64@@ , @@int64@@ + Number ) ; if ( * @@DWORD@@ ) return Number L ; @@int64@@ = * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; } } return @@int64@@ ; }
size_t __fastcall mbslen ( const char * @@constchar@@ ) { __int64 @@int64@@ ; char @@char4@@ [ Number ] ; int @@int@@ ; char @@char@@ ; const char * @@constchar@@ ; __int64 @@int64@@ ; char @@char@@ ; int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( __ctype_get_mb_cur_max ( ) <= Number ) return strlen ( @@constchar@@ ) ; @@int64@@ = Number L ; @@constchar@@ = @@constchar@@ ; @@char4@@ [ Number ] = Number ; memset ( & @@int@@ , Number , Number ) ; for ( @@char@@ = Number ; ; @@char@@ = Number ) { mbuiter_multi_next_1 ( ( __int64 ) @@char4@@ ) ; if ( @@char@@ == Number && ! @@int@@ ) break ; ++ @@int64@@ ; @@constchar@@ += @@int64@@ ; } return @@int64@@ ; }
_QWORD * __fastcall scan_arg ( _QWORD * @@QWORD@@ , unsigned __int8 * @@unsignedint8@@ ) { char * @@char@@ ; const unsigned __int16 * @@constunsignedint16@@ ; __int64 @@int64@@ ; int @@int@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int8 * @@unsignedint8@@ ; char * @@char@@ ; char * @@char@@ ; size_t @@sizet@@ ; __int64 @@int64@@ ; long double @@longdouble@@ ; size_t @@sizet@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint8@@ = @@unsignedint8@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( ( unsigned __int8 ) xstrtold ( @@unsignedint8@@ , Number L , & @@longdouble@@ , c_strtold ) != Number ) { @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ , @@unsignedint8@@ ) ; usage ( Number ) ; } while ( Number ) { @@constunsignedint16@@ = * __ctype_b_loc ( ) ; if ( ( @@constunsignedint16@@ [ ( unsigned __int8 ) to_uchar ( * @@unsignedint8@@ ) ] & Number ) == Number && * @@unsignedint8@@ != Number ) { break ; } ++ @@unsignedint8@@ ; } @@sizet@@ = strlen ( ( const char * ) @@unsignedint8@@ ) ; LODWORD ( @@int64@@ ) = Number ; if ( ! @@unsignedint8@@ [ strcspn ( ( const char * ) @@unsignedint8@@ , String ) ] && Number == @@longdouble@@ * Number ) { @@char@@ = strchr ( ( const char * ) @@unsignedint8@@ , Number ) ; if ( @@char@@ ) { @@sizet@@ = strcspn ( @@char@@ + Number , String ) ; if ( @@sizet@@ <= Number ) LODWORD ( @@int64@@ ) = @@sizet@@ ; if ( @@sizet@@ ) { LODWORD ( @@int64@@ ) = @@char@@ == ( char * ) @@unsignedint8@@ || ( unsigned int ) ( * ( @@char@@ - Number ) - Number ) > Number ; @@int64@@ = ( int ) @@int64@@ ; } else { @@int64@@ = Number ; } @@sizet@@ += @@int64@@ ; } else { LODWORD ( @@int64@@ ) = Number ; } @@char@@ = strchr ( ( const char * ) @@unsignedint8@@ , Number ) ; if ( ! @@char@@ ) @@char@@ = strchr ( ( const char * ) @@unsignedint8@@ , Number ) ; if ( @@char@@ ) { @@int64@@ = strtol ( @@char@@ + Number , Number L , Number ) ; if ( @@int64@@ >= Number ) @@int@@ = Number ; else @@int@@ = - ( int ) @@int64@@ ; LODWORD ( @@int64@@ ) = @@int64@@ + @@int@@ ; } } @@int64@@ = * ( ( _QWORD * ) & @@longdouble@@ + Number ) ; * @@QWORD@@ = * ( _QWORD * ) & @@longdouble@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int64@@ ; @@QWORD@@ [ Number ] = @@sizet@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; return @@QWORD@@ ; }
__int64 __fastcall c_tolower ( int @@int@@ ) { __int64 @@int64@@ ; if ( @@int@@ <= Number || @@int@@ > Number ) @@int64@@ = ( unsigned int ) @@int@@ ; else @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; return @@int64@@ ; }
void __fastcall match_ctx_free ( __int64 @@int64@@ ) { match_ctx_clean ( ( _QWORD * ) @@int64@@ ) ; free ( * ( void * * ) ( @@int64@@ + Number ) ) ; free ( * ( void * * ) ( @@int64@@ + Number ) ) ; }
__int64 __fastcall extend_buffers ( __int64 @@int64@@ ) { unsigned int @@unsignedint@@ ; unsigned int @@unsignedint@@ ; void * @@void@@ ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) > Number ) return Number L ; @@unsignedint@@ = re_string_realloc_buffers ( @@int64@@ , Number L * * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) { @@void@@ = realloc ( * ( void * * ) ( @@int64@@ + Number ) , Number * ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) ) ; if ( ! @@void@@ ) return Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@void@@ ; } if ( * ( _BYTE * ) ( @@int64@@ + Number ) ) { if ( * ( int * ) ( @@int64@@ + Number ) <= Number ) { build_upper_buffer ( ( _QWORD * ) @@int64@@ ) ; } else { @@unsignedint@@ = build_wcs_upper_buffer ( @@int64@@ ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; } } else if ( * ( int * ) ( @@int64@@ + Number ) <= Number ) { if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) re_string_translate_buffer ( ( _QWORD * ) @@int64@@ ) ; } else { build_wcs_buffer ( @@int64@@ ) ; } return Number L ; }
const char * __fastcall get_default_format ( __int64 a1 , __int64 a2 , __int64 a3 , __int64 a4 , __int64 a5 , __int64 a6 , int a7 , int a8 , __int64 @@int64@@ , int @@int@@ , int a11 , int a12 , int a13 , int @@int@@ , int a15 , int a16 , __int64 @@int64@@ , int @@int@@ ) { unsigned int @@unsignedint@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned int @@unsignedint@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint@@ = @@int@@ ; if ( @@int@@ >= @@int@@ ) @@unsignedint@@ = @@int@@ ; @@unsignedint@@ = @@unsignedint@@ ; if ( @@unsignedint@@ != Number && @@int@@ != Number ) { if ( ! equal_width ) { sprintf ( format_buf_5549 , String , @@unsignedint@@ ) ; return format_buf_5549 ; } @@unsignedint64@@ = @@int64@@ + ( int ) ( @@unsignedint@@ - @@int@@ ) ; @@unsignedint64@@ = @@int64@@ + ( int ) ( @@unsignedint@@ - @@int@@ ) ; if ( @@int@@ && ! @@unsignedint@@ ) -- @@unsignedint64@@ ; if ( ! @@int@@ && @@unsignedint@@ ) ++ @@unsignedint64@@ ; @@unsignedint64@@ = @@int64@@ + ( int ) ( @@unsignedint@@ - @@int@@ ) ; if ( @@unsignedint64@@ >= @@unsignedint64@@ ) @@unsignedint64@@ = @@unsignedint64@@ ; if ( @@unsignedint64@@ <= Number ) { sprintf ( format_buf_5549 , String , ( unsigned int ) @@unsignedint64@@ , @@unsignedint@@ ) ; return format_buf_5549 ; } } return String ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
unsigned __int64 __fastcall mmalloca ( unsigned __int64 @@unsignedint64@@ ) { char * @@char@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@unsignedint64@@ + Number < @@unsignedint64@@ ) return Number L ; @@char@@ = ( char * ) malloc ( @@unsignedint64@@ + Number ) ; if ( ! @@char@@ ) return Number L ; @@unsignedint64@@ = ( unsigned __int64 ) ( @@char@@ + Number ) ; * ( _DWORD * ) ( @@unsignedint64@@ - Number ) = Number ; * ( _QWORD * ) ( @@unsignedint64@@ - Number ) = mmalloca_results [ @@unsignedint64@@ % Number ] ; mmalloca_results [ @@unsignedint64@@ % Number ] = @@unsignedint64@@ ; return @@unsignedint64@@ ; }
_QWORD * __fastcall match_ctx_add_sublast ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; void * @@void@@ ; _QWORD * @@QWORD@@ ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) == * ( _QWORD * ) ( @@int64@@ + Number ) ) { @@int64@@ = Number L * * ( _QWORD * ) ( @@int64@@ + Number ) + Number ; @@void@@ = realloc ( * ( void * * ) ( @@int64@@ + Number ) , Number * @@int64@@ ) ; if ( ! @@void@@ ) return Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@void@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; } @@QWORD@@ = calloc ( Number , Number ) ; if ( @@QWORD@@ ) { * ( _QWORD * ) ( Number L * * ( _QWORD * ) ( @@int64@@ + Number ) + * ( _QWORD * ) ( @@int64@@ + Number ) ) = @@QWORD@@ ; * @@QWORD@@ = @@int64@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; ++ * ( _QWORD * ) ( @@int64@@ + Number ) ; } return @@QWORD@@ ; }
void * __fastcall sift_ctx_init ( _QWORD * @@QWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { * @@QWORD@@ = @@int64@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; return memset ( @@QWORD@@ + Number , Number , Number ) ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 __fastcall x2nrealloc ( __int64 @@int64@@ , unsigned __int64 * @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = * @@unsignedint64@@ ; if ( @@int64@@ ) { if ( @@unsignedint64@@ >= Number / @@unsignedint64@@ ) xalloc_die ( ) ; @@unsignedint64@@ += ( @@unsignedint64@@ + Number ) >> Number ; } else if ( ! @@unsignedint64@@ ) { @@unsignedint64@@ = ( Number / @@unsignedint64@@ == Number ) + Number / @@unsignedint64@@ ; } * @@unsignedint64@@ = @@unsignedint64@@ ; return xrealloc ( @@int64@@ , @@unsignedint64@@ * @@unsignedint64@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
long double __fastcall c_strtold ( const char * @@constchar@@ , char * * @@char@@ ) { struct __locale_struct * @@structlocalestruct@@ ; @@structlocalestruct@@ = ( struct __locale_struct * ) c_locale ( ) ; if ( @@structlocalestruct@@ ) return strtold_l ( @@constchar@@ , @@char@@ , @@structlocalestruct@@ ) ; if ( @@char@@ ) * @@char@@ = ( char * ) @@constchar@@ ; return Number ; }
__int64 __fastcall mem_cd_iconv ( char * @@char@@ , size_t @@sizet@@ , void * @@void@@ , void * * @@void@@ , size_t * @@sizet@@ ) { int @@int@@ ; char * @@char@@ ; size_t @@sizet@@ ; char * @@char@@ ; size_t @@sizet@@ ; void * @@void@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; char @@char@@ $D1F1B2789FC85C59BE59CF61C76BFA1E [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; iconv ( @@void@@ , Number L , Number L , Number L , Number L ) ; @@sizet@@ = Number L ; @@char@@ = @@char@@ ; @@sizet@@ = @@sizet@@ ; while ( @@sizet@@ ) { @@char@@ = @@char@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; @@sizet@@ = Number L ; @@sizet@@ = iconv ( @@void@@ , & @@char@@ , & @@sizet@@ , & @@char@@ , & @@sizet@@ ) ; if ( @@sizet@@ == Number && * __errno_location ( ) != Number ) { if ( * __errno_location ( ) != Number ) return Number ; break ; } @@sizet@@ += @@char@@ - @@char@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; } @@char@@ = @@char@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; @@sizet@@ = Number L ; @@sizet@@ = iconv ( @@void@@ , Number L , Number L , & @@char@@ , & @@sizet@@ ) ; if ( @@sizet@@ == Number ) return Number ; @@sizet@@ += @@char@@ - @@char@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; @@sizet@@ = @@sizet@@ ; if ( ! @@sizet@@ ) { * @@sizet@@ = Number L ; return Number L ; } if ( * @@void@@ && @@sizet@@ <= * @@sizet@@ ) { @@void@@ = * @@void@@ ; } else { @@void@@ = malloc ( @@sizet@@ ) ; if ( ! @@void@@ ) { * __errno_location ( ) = Number ; return Number ; } } iconv ( @@void@@ , Number L , Number L , Number L , Number L ) ; @@char@@ = @@char@@ ; @@sizet@@ = @@sizet@@ ; @@char@@ = ( char * ) @@void@@ ; @@sizet@@ = @@sizet@@ ; while ( @@sizet@@ ) { @@sizet@@ = iconv ( @@void@@ , & @@char@@ , & @@sizet@@ , & @@char@@ , & @@sizet@@ ) ; if ( @@sizet@@ == Number ) { if ( * __errno_location ( ) != Number ) goto LABEL_26 ; break ; } } @@sizet@@ = iconv ( @@void@@ , Number L , Number L , & @@char@@ , & @@sizet@@ ) ; if ( @@sizet@@ != Number ) { if ( @@sizet@@ ) abort ( ) ; * @@void@@ = @@void@@ ; * @@sizet@@ = @@sizet@@ ; return Number L ; } LABEL_26 : if ( @@void@@ != * @@void@@ ) { @@int@@ = * __errno_location ( ) ; free ( @@void@@ ) ; * __errno_location ( ) = @@int@@ ; } return Number ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_20D0E8 ; @@int648@@ [ Number ] = qword_20D0F0 ; @@int648@@ [ Number ] = qword_20D0F8 ; @@int648@@ [ Number ] = qword_20D100 ; @@int648@@ [ Number ] = qword_20D108 ; @@int648@@ [ Number ] = qword_20D110 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 __fastcall knuth_morris_pratt_unibyte ( _BYTE * @@BYTE@@ , char * @@char@@ , _QWORD * @@QWORD@@ ) { void * @@void@@ ; unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; char * @@char@@ ; _BYTE * @@BYTE@@ ; char @@char@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; size_t @@sizet@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@BYTE@@ = @@BYTE@@ ; @@char@@ = @@char@@ ; @@QWORD@@ = @@QWORD@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@sizet@@ = strlen ( @@char@@ ) ; if ( @@sizet@@ > Number ) { @@unsignedint64@@ = Number L ; } else if ( Number * @@sizet@@ > Number ) { @@unsignedint64@@ = mmalloca ( Number * @@sizet@@ ) ; } else { @@void@@ = alloca ( Number * ( ( Number * ( @@sizet@@ + Number ) + Number ) / Number ) ) ; @@unsignedint64@@ = Number * ( ( ( unsigned __int64 ) & @@QWORD@@ + Number ) >> Number ) + Number ; } @@unsignedint64@@ = @@unsignedint64@@ ; if ( ! @@unsignedint64@@ ) return Number L ; * ( _QWORD * ) ( @@unsignedint64@@ + Number ) = Number L ; @@int64@@ = Number L ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@sizet@@ ; ++ @@unsignedint64@@ ) { @@char@@ = @@char@@ [ @@unsignedint64@@ - Number ] ; while ( Number ) { if ( @@char@@ == @@char@@ [ @@int64@@ ] ) { ++ @@int64@@ ; * ( _QWORD * ) ( @@unsignedint64@@ + Number * @@unsignedint64@@ ) = @@unsignedint64@@ - @@int64@@ ; goto LABEL_15 ; } if ( ! @@int64@@ ) break ; @@int64@@ -= * ( _QWORD * ) ( Number * @@int64@@ + @@unsignedint64@@ ) ; } * ( _QWORD * ) ( @@unsignedint64@@ + Number * @@unsignedint64@@ ) = @@unsignedint64@@ ; LABEL_15 : ; } * @@QWORD@@ = Number L ; @@int64@@ = Number L ; @@BYTE@@ = @@BYTE@@ ; @@BYTE@@ = @@BYTE@@ ; while ( * @@BYTE@@ ) { if ( @@char@@ [ @@int64@@ ] == * @@BYTE@@ ) { ++ @@int64@@ ; ++ @@BYTE@@ ; if ( @@int64@@ == @@sizet@@ ) { * @@QWORD@@ = @@BYTE@@ ; break ; } } else if ( @@int64@@ ) { @@BYTE@@ += * ( _QWORD * ) ( Number * @@int64@@ + @@unsignedint64@@ ) ; @@int64@@ -= * ( _QWORD * ) ( Number * @@int64@@ + @@unsignedint64@@ ) ; } else { ++ @@BYTE@@ ; ++ @@BYTE@@ ; } } freea ( @@unsignedint64@@ ) ; return Number L ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
__int64 __fastcall xsum ( unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; if ( @@unsignedint64@@ + @@int64@@ < @@unsignedint64@@ ) @@int64@@ = Number ; else @@int64@@ = @@unsignedint64@@ + @@int64@@ ; return @@int64@@ ; }
__int64 __fastcall x2nrealloc ( __int64 @@int64@@ , unsigned __int64 * @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = * @@unsignedint64@@ ; if ( @@int64@@ ) { if ( @@unsignedint64@@ >= Number / @@unsignedint64@@ ) xalloc_die ( ) ; @@unsignedint64@@ += ( @@unsignedint64@@ + Number ) >> Number ; } else if ( ! @@unsignedint64@@ ) { @@unsignedint64@@ = ( Number / @@unsignedint64@@ == Number ) + Number / @@unsignedint64@@ ; } * @@unsignedint64@@ = @@unsignedint64@@ ; return xrealloc ( @@int64@@ , @@unsignedint64@@ * @@unsignedint64@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 decimal_point_char ( ) { __int64 @@int64@@ ; char * @@char@@ ; @@char@@ = nl_langinfo ( Number ) ; if ( * @@char@@ ) @@int64@@ = ( unsigned __int8 ) * @@char@@ ; else @@int64@@ = Number L ; return @@int64@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
_BOOL8 __fastcall rpl_isnanl ( __int64 a1 , __int64 a2 , __int64 a3 , __int64 a4 , __int64 a5 , __int64 a6 , __int128 @@int128@@ ) { if ( ( WORD4 ( @@int128@@ ) & Number ) == Number ) return DWORD1 ( @@int128@@ ) >> Number ; if ( ( WORD4 ( @@int128@@ ) & Number ) == Number ) return ( DWORD1 ( @@int128@@ ) ^ Number | ( unsigned int ) @@int128@@ ) != Number ; return ( DWORD1 ( @@int128@@ ) & Number ) == Number ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
unsigned __int64 __fastcall do_decode ( FILE * @@FILE@@ , FILE * @@FILE@@ , char @@char@@ ) { char * @@char@@ ; int * @@int@@ ; unsigned __int64 @@unsignedint64@@ ; size_t @@sizet@@ ; char * @@char@@ ; int * @@int@@ ; char * @@char@@ ; unsigned int @@unsignedint@@ ; char @@char@@ ; unsigned int @@unsignedint@@ ; size_t @@sizet@@ ; unsigned __int64 @@unsignedint64@@ ; size_t @@sizet@@ ; int @@int@@ ; char @@char@@ [ Number ] ; char @@char4104@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; base64_decode_ctx_init ( & @@int@@ ) ; do { @@unsignedint64@@ = Number L ; do { @@sizet@@ = fread_unlocked ( & @@char4104@@ [ @@unsignedint64@@ ] , Number , Number - @@unsignedint64@@ , @@FILE@@ ) ; if ( @@char@@ ) { @@sizet@@ = Number L ; while ( @@sizet@@ && @@sizet@@ < @@sizet@@ ) { if ( ( unsigned __int8 ) isbase64 ( ( unsigned int ) @@char4104@@ [ @@unsignedint64@@ + @@sizet@@ ] ) || @@char4104@@ [ @@unsignedint64@@ + @@sizet@@ ] == Number ) { ++ @@sizet@@ ; } else { memmove ( & @@char4104@@ [ @@sizet@@ + @@unsignedint64@@ ] , & @@char4104@@ [ @@unsignedint64@@ + Number + @@sizet@@ ] , -- @@sizet@@ - @@sizet@@ ) ; } } } @@unsignedint64@@ += @@sizet@@ ; if ( ferror_unlocked ( @@FILE@@ ) ) { @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ ) ; } } while ( @@unsignedint64@@ <= Number && ! feof_unlocked ( @@FILE@@ ) ) ; for ( @@unsignedint@@ = Number ; ; ++ @@unsignedint@@ ) { @@unsignedint@@ = feof_unlocked ( @@FILE@@ ) ? Number : Number ; if ( @@unsignedint@@ <= @@unsignedint@@ || @@unsignedint@@ == Number && ! @@int@@ ) { break ; } @@sizet@@ = Number L ; if ( @@unsignedint@@ ) @@unsignedint64@@ = Number L ; else @@unsignedint64@@ = @@unsignedint64@@ ; @@char@@ = base64_decode_ctx ( & @@int@@ , @@char4104@@ , @@unsignedint64@@ , @@char@@ , & @@sizet@@ ) ; @@sizet@@ = fwrite_unlocked ( @@char@@ , Number , @@sizet@@ , @@FILE@@ ) ; if ( @@sizet@@ < @@sizet@@ ) { @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ ) ; } if ( @@char@@ != Number ) { @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ ) ; } } } while ( ! feof_unlocked ( @@FILE@@ ) ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_20D028 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
void __fastcall base64_encode ( unsigned __int8 * @@unsignedint8@@ , __int64 @@int64@@ , char * @@char@@ , __int64 @@int64@@ ) { int @@int@@ ; char * @@char@@ ; char @@char@@ ; char @@char@@ ; int @@int@@ ; char * @@char@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; char * @@char@@ ; char @@char@@ ; char * @@char@@ ; while ( @@int64@@ ) { if ( ! @@int64@@ ) break ; @@int@@ = ( unsigned __int8 ) to_uchar ( * @@unsignedint8@@ ) >> Number ; @@char@@ = @@char@@ ++ ; * @@char@@ = b64str_2796 [ @@int@@ ] ; if ( ! -- @@int64@@ ) break ; @@char@@ = Number * to_uchar ( * @@unsignedint8@@ ) ; @@char@@ = -- @@int64@@ ? ( unsigned __int8 ) to_uchar ( @@unsignedint8@@ [ Number ] ) >> Number : Number ; @@int@@ = ( @@char@@ + @@char@@ ) & Number ; @@char@@ = @@char@@ ++ ; * @@char@@ = b64str_2796 [ @@int@@ ] ; if ( ! -- @@int64@@ ) break ; if ( @@int64@@ ) { @@char@@ = Number * to_uchar ( @@unsignedint8@@ [ Number ] ) ; @@char@@ = -- @@int64@@ ? ( unsigned __int8 ) to_uchar ( @@unsignedint8@@ [ Number ] ) >> Number : Number ; @@char@@ = b64str_2796 [ ( @@char@@ + @@char@@ ) & Number ] ; } else { @@char@@ = Number ; } @@char@@ = @@char@@ ++ ; * @@char@@ = @@char@@ ; if ( ! -- @@int64@@ ) break ; @@char@@ = @@int64@@ ? b64str_2796 [ to_uchar ( @@unsignedint8@@ [ Number ] ) & Number ] : Number ; @@char@@ = @@char@@ ++ ; * @@char@@ = @@char@@ ; if ( ! -- @@int64@@ ) break ; if ( @@int64@@ ) -- @@int64@@ ; if ( @@int64@@ ) @@unsignedint8@@ += Number ; } if ( @@int64@@ ) * @@char@@ = Number ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
__int64 __fastcall decode_4 ( unsigned __int8 * @@unsignedint8@@ , unsigned __int64 @@unsignedint64@@ , _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ ) { int @@int@@ ; char @@char@@ ; _BYTE * @@BYTE@@ ; int @@int@@ ; char @@char@@ ; _BYTE * @@BYTE@@ ; int @@int@@ ; unsigned __int8 @@unsignedint8@@ ; _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; @@BYTE@@ = ( _BYTE * ) * @@QWORD@@ ; if ( @@unsignedint64@@ <= Number ) return Number L ; if ( ( unsigned __int8 ) isbase64 ( * @@unsignedint8@@ ) != Number || ( unsigned __int8 ) isbase64 ( @@unsignedint8@@ [ Number ] ) != Number ) { return Number L ; } if ( * @@QWORD@@ ) { @@int@@ = Number * ( char ) b64 [ ( unsigned __int8 ) to_uchar ( * @@unsignedint8@@ ) ] ; @@char@@ = ( char ) b64 [ ( unsigned __int8 ) to_uchar ( @@unsignedint8@@ [ Number ] ) ] >> Number ; @@BYTE@@ = @@BYTE@@ ++ ; * @@BYTE@@ = @@char@@ | @@int@@ ; -- * @@QWORD@@ ; } if ( @@unsignedint64@@ == Number ) { * @@QWORD@@ = @@BYTE@@ ; return Number L ; } if ( @@unsignedint8@@ [ Number ] == Number ) { if ( @@unsignedint64@@ != Number ) { * @@QWORD@@ = @@BYTE@@ ; return Number L ; } if ( @@unsignedint8@@ [ Number ] != Number ) { * @@QWORD@@ = @@BYTE@@ ; return Number L ; } } else { if ( ( unsigned __int8 ) isbase64 ( @@unsignedint8@@ [ Number ] ) != Number ) { * @@QWORD@@ = @@BYTE@@ ; return Number L ; } if ( * @@QWORD@@ ) { @@int@@ = Number * ( char ) b64 [ ( unsigned __int8 ) to_uchar ( @@unsignedint8@@ [ Number ] ) ] ; @@char@@ = ( char ) b64 [ ( unsigned __int8 ) to_uchar ( @@unsignedint8@@ [ Number ] ) ] >> Number ; @@BYTE@@ = @@BYTE@@ ++ ; * @@BYTE@@ = @@char@@ | @@int@@ ; -- * @@QWORD@@ ; } if ( @@unsignedint64@@ == Number ) { * @@QWORD@@ = @@BYTE@@ ; return Number L ; } if ( @@unsignedint8@@ [ Number ] == Number ) { if ( @@unsignedint64@@ != Number ) { * @@QWORD@@ = @@BYTE@@ ; return Number L ; } } else { if ( ( unsigned __int8 ) isbase64 ( @@unsignedint8@@ [ Number ] ) != Number ) { * @@QWORD@@ = @@BYTE@@ ; return Number L ; } if ( * @@QWORD@@ ) { @@int@@ = ( char ) b64 [ ( unsigned __int8 ) to_uchar ( @@unsignedint8@@ [ Number ] ) ] << Number ; @@unsignedint8@@ = b64 [ ( unsigned __int8 ) to_uchar ( @@unsignedint8@@ [ Number ] ) ] ; @@BYTE@@ = @@BYTE@@ ++ ; * @@BYTE@@ = @@unsignedint8@@ | @@int@@ ; -- * @@QWORD@@ ; } } } * @@QWORD@@ = @@BYTE@@ ; return Number L ; }
__int64 __fastcall base64_decode_alloc_ctx ( int * @@int@@ , char * @@char@@ , unsigned __int64 @@unsignedint64@@ , void * * @@void@@ , _QWORD * @@QWORD@@ ) { __int64 @@int64@@ ; size_t @@sizet2@@ [ Number ] ; @@sizet2@@ [ Number ] = __readfsqword ( Number ) ; @@sizet2@@ [ Number ] = Number * ( @@unsignedint64@@ >> Number ) + Number ; * @@void@@ = malloc ( @@sizet2@@ [ Number ] ) ; if ( ! * @@void@@ ) return Number L ; if ( ! base64_decode_ctx ( @@int@@ , @@char@@ , @@unsignedint64@@ , ( __int64 ) * @@void@@ , ( __int64 * ) @@sizet2@@ ) ) { free ( * @@void@@ ) ; * @@void@@ = Number L ; @@int64@@ = Number L ; } else { if ( @@QWORD@@ ) * @@QWORD@@ = @@sizet2@@ [ Number ] ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall xnrealloc ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { if ( ! is_mul_ok ( @@unsignedint64@@ , @@unsignedint64@@ ) ) xalloc_die ( ) ; return xrealloc ( @@int64@@ , @@unsignedint64@@ * @@unsignedint64@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ ) { return xmalloc ( @@int64@@ ) ; }
unsigned __int64 __fastcall rpl_vasprintf ( void * * @@void@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; void * @@void@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@void@@ = ( void * ) vasnprintf ( Number L , & @@unsignedint64@@ , @@int64@@ , @@int64@@ ) ; if ( ! @@void@@ ) return Number ; if ( @@unsignedint64@@ <= Number ) { * @@void@@ = @@void@@ ; @@unsignedint64@@ = @@unsignedint64@@ ; } else { free ( @@void@@ ) ; * __errno_location ( ) = Number ; @@unsignedint64@@ = Number ; } return @@unsignedint64@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 __fastcall xstrtold ( _BYTE * @@BYTE@@ , _QWORD * @@QWORD@@ , long double * @@longdouble@@ , long double ( __fastcall * @ @ VAR_552 @ @ longdouble ( fastcall ) ( BYTE , BYTE ) @ @ longdouble ( ) ( constchar , char ) ) ( _BYTE * , _BYTE * * ) ) { unsigned __int8 @@unsignedint8@@ ; _BYTE * @@BYTE@@ ; long double @@longdouble@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@unsignedint8@@ = Number ; * __errno_location ( ) = Number ; @@longdouble@@ = @ @ VAR_552 @ @ longdouble ( fastcall ) ( BYTE , BYTE ) @ @ longdouble ( ) ( constchar , char ) ( @@BYTE@@ , & @@BYTE@@ ) ; if ( @@BYTE@@ == @@BYTE@@ || ! @@QWORD@@ && * @@BYTE@@ ) { @@unsignedint8@@ = Number ; } else if ( Number != @@longdouble@@ && * __errno_location ( ) == Number ) { @@unsignedint8@@ = Number ; } if ( @@QWORD@@ ) * @@QWORD@@ = @@BYTE@@ ; * @@longdouble@@ = @@longdouble@@ ; return @@unsignedint8@@ ; }
unsigned __int64 __fastcall xmax ( unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint64@@ ; if ( @@unsignedint64@@ >= @@unsignedint64@@ ) @@unsignedint64@@ = @@unsignedint64@@ ; return @@unsignedint64@@ ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return xmalloc ( @@int64@@ , @@int64@@ , @@int64@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
__int64 __fastcall xsum_0 ( unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; if ( @@unsignedint64@@ + @@int64@@ < @@unsignedint64@@ ) @@int64@@ = Number ; else @@int64@@ = @@unsignedint64@@ + @@int64@@ ; return @@int64@@ ; }
void __fastcall wrap_write ( char * @@char@@ , size_t @@sizet@@ , __int64 @@int64@@ , _QWORD * @@QWORD@@ , FILE * @@FILE@@ ) { char * @@char@@ ; int * @@int@@ ; size_t @@sizet@@ ; char * @@char@@ ; int * @@int@@ ; char * @@char@@ ; int * @@int@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; if ( @@int64@@ ) { @@sizet@@ = Number L ; while ( @@sizet@@ < @@sizet@@ ) { @@sizet@@ = @@sizet@@ - @@sizet@@ ; if ( @@int64@@ - * @@QWORD@@ <= @@sizet@@ - @@sizet@@ ) @@sizet@@ = @@int64@@ - * @@QWORD@@ ; @@sizet@@ = @@sizet@@ ; if ( @@sizet@@ ) { if ( @@sizet@@ > fwrite_unlocked ( & @@char@@ [ @@sizet@@ ] , Number , @@sizet@@ , stdout ) ) { @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ ) ; } * @@QWORD@@ += @@sizet@@ ; @@sizet@@ += @@sizet@@ ; } else { if ( fputs_unlocked ( String , @@FILE@@ ) < Number ) { @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ ) ; } * @@QWORD@@ = Number L ; } } } else if ( @@sizet@@ > fwrite_unlocked ( @@char@@ , Number , @@sizet@@ , stdout ) ) { @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ ) ; } }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall list_signals ( char @@char@@ , char * * @@char@@ ) { char * * @@char@@ ; int @@int@@ ; int @@int@@ ; signed int @@signedint@@ ; signed int @@signedint@@ ; int @@int@@ ; int @@int@@ ; unsigned int @@unsignedint@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; size_t @@sizet@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@char@@ = @@char@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@unsignedint@@ = Number ; if ( @@char@@ ) { @@unsignedint@@ = Number ; @@int@@ = Number ; for ( @@int@@ = Number ; @@int@@ <= Number ; @@int@@ *= Number ) ++ @@int@@ ; for ( @@int@@ = Number ; @@int@@ <= Number ; ++ @@int@@ ) { if ( ! ( unsigned int ) sig2str ( ( unsigned int ) @@int@@ , @@char@@ ) ) { @@sizet@@ = strlen ( @@char@@ ) ; if ( @@sizet@@ > @@unsignedint@@ ) @@unsignedint@@ = @@sizet@@ ; } } if ( @@char@@ ) { while ( * @@char@@ ) { @@signedint@@ = operand2sig ( * @@char@@ , @@char@@ ) ; if ( @@signedint@@ >= Number ) print_table_row ( @@int@@ , @@signedint@@ , @@unsignedint@@ , @@char@@ ) ; else @@unsignedint@@ = Number ; ++ @@char@@ ; } } else { for ( @@signedint@@ = Number ; @@signedint@@ <= Number ; ++ @@signedint@@ ) { if ( ! ( unsigned int ) sig2str ( ( unsigned int ) @@signedint@@ , @@char@@ ) ) print_table_row ( @@int@@ , @@signedint@@ , @@unsignedint@@ , @@char@@ ) ; } } } else if ( @@char@@ ) { while ( * @@char@@ ) { @@int@@ = operand2sig ( * @@char@@ , @@char@@ ) ; if ( @@int@@ >= Number ) { if ( ( unsigned int ) ( * * @@char@@ - Number ) > Number ) printf ( String , ( unsigned int ) @@int@@ ) ; else puts ( @@char@@ ) ; } else { @@unsignedint@@ = Number ; } ++ @@char@@ ; } } else { for ( @@int@@ = Number ; @@int@@ <= Number ; ++ @@int@@ ) { if ( ! ( unsigned int ) sig2str ( ( unsigned int ) @@int@@ , @@char@@ ) ) puts ( @@char@@ ) ; } } return @@unsignedint@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
unsigned __int64 __fastcall base64_encode_alloc ( unsigned __int8 * @@unsignedint8@@ , unsigned __int64 @@unsignedint64@@ , char * * @@char@@ ) { unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = Number * ( ( @@unsignedint64@@ + Number ) / Number ) + Number ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { * @@char@@ = ( char * ) malloc ( @@unsignedint64@@ ) ; if ( * @@char@@ ) { base64_encode ( @@unsignedint8@@ , @@unsignedint64@@ , * @@char@@ , @@unsignedint64@@ ) ; @@unsignedint64@@ = Number * ( ( @@unsignedint64@@ + Number ) / Number ) ; } else { @@unsignedint64@@ = Number * ( ( @@unsignedint64@@ + Number ) / Number ) + Number ; } } else { * @@char@@ = Number L ; @@unsignedint64@@ = Number L ; } return @@unsignedint64@@ ; }
unsigned __int64 __fastcall do_encode ( FILE * @@FILE@@ , FILE * @@FILE@@ , __int64 @@int64@@ ) { char * @@char@@ ; int * @@int@@ ; char * @@char@@ ; int * @@int@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; size_t @@sizet@@ ; char @@char3072@@ [ Number ] ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = Number L ; do { @@unsignedint64@@ = Number L ; do { @@sizet@@ = fread_unlocked ( & @@char3072@@ [ @@unsignedint64@@ ] , Number , Number - @@unsignedint64@@ , @@FILE@@ ) ; @@unsignedint64@@ += @@sizet@@ ; } while ( ! feof_unlocked ( @@FILE@@ ) && ! ferror_unlocked ( @@FILE@@ ) && @@unsignedint64@@ <= Number ) ; if ( @@unsignedint64@@ ) { base64_encode ( @@char3072@@ , @@unsignedint64@@ , @@char@@ , Number * ( ( @@unsignedint64@@ + Number ) / Number ) ) ; wrap_write ( @@char@@ , Number * ( ( @@unsignedint64@@ + Number ) / Number ) , @@int64@@ , & @@int64@@ , @@FILE@@ ) ; } } while ( ! feof_unlocked ( @@FILE@@ ) && ! ferror_unlocked ( @@FILE@@ ) && @@unsignedint64@@ == Number ) ; if ( @@int64@@ && @@int64@@ && fputs_unlocked ( String , @@FILE@@ ) < Number ) { @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ ) ; } if ( ferror_unlocked ( @@FILE@@ ) ) { @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ ) ; } return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
bool __fastcall base64_decode_ctx ( int * @@int@@ , char * @@char@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; char * @@char@@ ; int * @@int@@ ; bool @@bool@@ ; bool @@bool@@ ; int @@int@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int8 * @@unsignedint8@@ ; char * @@char@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = @@int@@ ; @@char@@ = @@char@@ ; @@unsignedint64@@ = @@unsignedint64@@ ; @@int64@@ = @@int64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = * @@int64@@ ; @@bool@@ = @@int@@ != Number L ; @@bool@@ = Number ; @@int@@ = Number ; if ( @@int@@ ) { @@int@@ = * @@int@@ ; @@bool@@ = @@unsignedint64@@ == Number ; } while ( Number ) { @@int64@@ = @@int64@@ ; if ( ! @@int@@ && ! @@bool@@ ) { while ( Number ) { @@int64@@ = @@int64@@ ; if ( ( unsigned __int8 ) decode_4 ( ( unsigned __int8 * ) @@char@@ , @@unsignedint64@@ , & @@int64@@ , & @@int64@@ ) != Number ) break ; @@char@@ += Number ; @@unsignedint64@@ -= Number L ; } } if ( ! @@unsignedint64@@ && ! @@bool@@ ) break ; if ( @@unsignedint64@@ && * @@char@@ == Number && @@bool@@ ) { ++ @@char@@ ; -- @@unsignedint64@@ ; } else { @@int64@@ += @@int64@@ - @@int64@@ ; @@int64@@ = @@int64@@ ; @@char@@ = & @@char@@ [ @@unsignedint64@@ ] ; if ( @@bool@@ ) @@unsignedint8@@ = ( unsigned __int8 * ) get_4 ( @@int@@ , & @@char@@ , ( unsigned __int64 ) @@char@@ , & @@unsignedint64@@ ) ; else @@unsignedint8@@ = ( unsigned __int8 * ) @@char@@ ; if ( ! @@unsignedint64@@ || @@unsignedint64@@ <= Number && ! @@bool@@ && @@bool@@ ) { @@unsignedint64@@ = Number L ; break ; } if ( ( unsigned __int8 ) decode_4 ( @@unsignedint8@@ , @@unsignedint64@@ , & @@int64@@ , & @@int64@@ ) != Number ) break ; @@unsignedint64@@ = @@char@@ - @@char@@ ; } } * @@int64@@ -= @@int64@@ ; return @@unsignedint64@@ == Number ; }
__int64 __fastcall isbase64 ( unsigned __int8 @@unsignedint8@@ ) { return ( unsigned int ) ~ b64 [ ( unsigned __int8 ) to_uchar ( @@unsignedint8@@ ) ] >> Number ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
int __fastcall print_table_row ( int @@int@@ , unsigned int @@unsignedint@@ , int @@int@@ , const char * @@constchar@@ ) { const char * @@constchar@@ ; char * @@char@@ ; @@char@@ = strsignal ( @@unsignedint@@ ) ; if ( @@char@@ ) @@constchar@@ = @@char@@ ; else @@constchar@@ = String ; return printf ( String , @@int@@ , @@unsignedint@@ , @@int@@ , @@constchar@@ , @@constchar@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_2080C8 ; @@int648@@ [ Number ] = qword_2080D0 ; @@int648@@ [ Number ] = qword_2080D8 ; @@int648@@ [ Number ] = qword_2080E0 ; @@int648@@ [ Number ] = qword_2080E8 ; @@int648@@ [ Number ] = qword_2080F0 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_208028 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
char * __fastcall get_4 ( _DWORD * @@DWORD@@ , char * * @@char@@ , unsigned __int64 @@unsignedint64@@ , _QWORD * @@QWORD@@ ) { char * @@char@@ ; char * @@char@@ ; unsigned int @@unsignedint@@ ; char @@char@@ ; char * @@char@@ ; char * @@char@@ ; if ( * @@DWORD@@ == Number ) * @@DWORD@@ = Number ; if ( * @@DWORD@@ || ( @@char@@ = * @@char@@ , ( __int64 ) ( @@unsignedint64@@ - ( _QWORD ) * @@char@@ ) <= Number ) || memchr ( @@char@@ , Number , Number ) ) { @@char@@ = * @@char@@ ; while ( ( unsigned __int64 ) @@char@@ < @@unsignedint64@@ ) { @@char@@ = @@char@@ ++ ; @@char@@ = * @@char@@ ; if ( * @@char@@ != Number ) { @@unsignedint@@ = ( * @@DWORD@@ ) ++ ; * ( ( _BYTE * ) @@DWORD@@ + @@unsignedint@@ + Number ) = @@char@@ ; if ( * @@DWORD@@ == Number ) break ; } } * @@char@@ = @@char@@ ; * @@QWORD@@ = ( unsigned int ) * @@DWORD@@ ; @@char@@ = ( char * ) ( @@DWORD@@ + Number ) ; } else { * @@char@@ += Number ; * @@QWORD@@ = Number L ; @@char@@ = @@char@@ ; } return @@char@@ ; }
__int64 __fastcall operand2sig ( const char * @@constchar@@ , __int64 @@int64@@ ) { int @@int@@ ; char * @@char@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; char * @@char@@ ; _BYTE * @@BYTE@@ ; void * @@void@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( ( unsigned int ) ( * @@constchar@@ - Number ) > Number ) { @@void@@ = ( void * ) xstrdup ( @@constchar@@ ) ; for ( @@BYTE@@ = @@void@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( strchr ( String , ( char ) * @@BYTE@@ ) ) * @@BYTE@@ -= Number ; } if ( ( unsigned int ) str2sig ( @@void@@ , & @@unsignedint@@ ) && ( * ( _BYTE * ) @@void@@ != Number || * ( ( _BYTE * ) @@void@@ + Number ) != Number || * ( ( _BYTE * ) @@void@@ + Number ) != Number || ( unsigned int ) str2sig ( ( char * ) @@void@@ + Number , & @@unsignedint@@ ) ) ) { @@unsignedint@@ = Number ; } free ( @@void@@ ) ; } else { * __errno_location ( ) = Number ; @@int64@@ = strtol ( @@constchar@@ , & @@char@@ , Number ) ; @@int@@ = @@int64@@ ; if ( @@constchar@@ == @@char@@ || * @@char@@ || * __errno_location ( ) || @@int64@@ != @@int@@ ) { @@int@@ = Number ; } else if ( ( char ) ( ( @@int@@ & Number ) + Number ) >> Number <= Number ) { @@int@@ = @@int@@ ; } else { @@int@@ = @@int@@ & Number ; } @@unsignedint@@ = @@int@@ ; } if ( ( @@unsignedint@@ & Number ) == Number && ! ( unsigned int ) sig2str ( @@unsignedint@@ , @@int64@@ ) ) { return @@unsignedint@@ ; } @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ , @@constchar@@ ) ; return Number ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
__int64 __fastcall send_signals ( int @@int@@ , char * * @@char@@ ) { char * @@char@@ ; int * @@int@@ ; char * * @@char@@ ; unsigned int @@unsignedint@@ ; __pid_t @@pidt@@ ; char * @@char@@ ; char * @@char@@ ; intmax_t @@intmaxt@@ ; unsigned __int64 @@unsignedint64@@ ; @@char@@ = @@char@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@unsignedint@@ = Number ; @@char@@ = * @@char@@ ; do { * __errno_location ( ) = Number ; @@intmaxt@@ = strtoimax ( @@char@@ , & @@char@@ , Number ) ; @@pidt@@ = @@intmaxt@@ ; if ( * __errno_location ( ) == Number || @@intmaxt@@ != @@pidt@@ || @@char@@ == @@char@@ || * @@char@@ ) { @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ , @@char@@ ) ; @@unsignedint@@ = Number ; } else if ( kill ( @@pidt@@ , @@int@@ ) ) { @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , String , @@char@@ ) ; @@unsignedint@@ = Number ; } @@char@@ = * ++ @@char@@ ; } while ( @@char@@ ) ; return @@unsignedint@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@unsignedint64@@ , int @@int@@ ) { __int64 @@int64@@ ; if ( is_mul_ok ( @@int@@ , * @@unsignedint64@@ ) ) { * @@unsignedint64@@ *= @@int@@ ; @@int64@@ = Number L ; } else { * @@unsignedint64@@ = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
_QWORD * __fastcall argv_iter_init_stream ( __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; @@QWORD@@ = malloc ( Number ) ; if ( ! @@QWORD@@ ) return Number L ; * @@QWORD@@ = @@int64@@ ; @@QWORD@@ [ Number ] = Number L ; @@QWORD@@ [ Number ] = Number L ; @@QWORD@@ [ Number ] = Number L ; @@QWORD@@ [ Number ] = Number L ; return @@QWORD@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 __fastcall bkm_scale_by_power ( unsigned __int64 * @@unsignedint64@@ , int @@int@@ , int @@int@@ ) { unsigned int @@unsignedint@@ ; for ( @@unsignedint@@ = Number ; @@int@@ -- ; @@unsignedint@@ |= bkm_scale ( @@unsignedint64@@ , @@int@@ ) ) { ; } return @@unsignedint@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return xmalloc ( @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
bool __fastcall is_basic ( unsigned __int8 @@unsignedint8@@ ) { return ( ( * ( ( _DWORD * ) & is_basic_table + ( @@unsignedint8@@ >> Number ) ) >> ( @@unsignedint8@@ & Number ) ) & Number ) != Number ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_207028 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall str2sig ( const char * @@constchar@@ , int * @@int@@ ) { __int64 @@int64@@ ; * @@int@@ = str2signum ( @@constchar@@ ) ; if ( * @@int@@ >= Number ) @@int64@@ = Number L ; else @@int64@@ = Number ; return @@int64@@ ; }
__int64 __fastcall compute_number_width ( int @@int@@ , int * @@int@@ ) { int @@int@@ ; int @@int@@ ; int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = Number ; if ( @@int@@ > Number && * @@int@@ <= Number ) { @@int@@ = Number ; @@unsignedint64@@ = Number L ; for ( @@int@@ = Number ; @@int@@ < @@int@@ ; ++ @@int@@ ) { if ( ! @@int@@ [ Number * @@int@@ ] ) { if ( ( @@int@@ [ Number * @@int@@ + Number ] & Number ) == Number ) @@unsignedint64@@ += * ( _QWORD * ) & @@int@@ [ Number * @@int@@ + Number ] ; else @@int@@ = Number ; } } while ( @@unsignedint64@@ > Number ) { ++ @@int@@ ; @@unsignedint64@@ /= Number ; } if ( @@int@@ < @@int@@ ) @@int@@ = @@int@@ ; } return ( unsigned int ) @@int@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_209028 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall wc_file ( const char * @@constchar@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; int * @@int@@ ; unsigned __int8 @@unsignedint8@@ ; int @@int@@ ; if ( @@constchar@@ && strcmp ( @@constchar@@ , String ) ) { @@int@@ = open ( @@constchar@@ , Number ) ; if ( @@int@@ == Number || ( @@unsignedint8@@ = wc ( @@int@@ , @@constchar@@ , @@int64@@ ) , close ( @@int@@ ) ) ) { @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , String , @@constchar@@ ) ; @@int64@@ = Number L ; } else { @@int64@@ = @@unsignedint8@@ ; } } else { have_read_stdin = Number ; @@int64@@ = wc ( Number , @@constchar@@ , @@int64@@ ) ; } return @@int64@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
unsigned __int64 __fastcall write_counts ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , const char * @@constchar@@ ) { const char * @@constchar@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; char * @@char@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@char@@ = String ; if ( print_lines ) { @@constchar@@ = ( const char * ) umaxtostr ( @@int64@@ , @@char@@ ) ; printf ( String , number_width , @@constchar@@ ) ; @@char@@ = String ; } if ( print_words ) { @@int64@@ = umaxtostr ( @@int64@@ , @@char@@ ) ; printf ( @@char@@ , ( unsigned int ) number_width , @@int64@@ ) ; @@char@@ = String ; } if ( print_chars ) { @@int64@@ = umaxtostr ( @@int64@@ , @@char@@ ) ; printf ( @@char@@ , ( unsigned int ) number_width , @@int64@@ ) ; @@char@@ = String ; } if ( print_bytes ) { @@int64@@ = umaxtostr ( @@int64@@ , @@char@@ ) ; printf ( @@char@@ , ( unsigned int ) number_width , @@int64@@ ) ; @@char@@ = String ; } if ( print_linelength ) { @@int64@@ = umaxtostr ( @@int64@@ , @@char@@ ) ; printf ( @@char@@ , ( unsigned int ) number_width , @@int64@@ ) ; } if ( @@constchar@@ ) printf ( String , @@constchar@@ ) ; putchar_unlocked ( Number ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
__int64 __fastcall argv_iter ( __int64 @@int64@@ , int * @@int@@ ) { int @@int@@ ; __int64 @@int64@@ ; __int64 * @@int64@@ ; if ( * ( _QWORD * ) @@int64@@ ) { if ( getdelim ( ( char * * ) ( @@int64@@ + Number ) , ( size_t * ) ( @@int64@@ + Number ) , Number , * ( FILE * * ) @@int64@@ ) >= Number ) { * @@int@@ = Number ; ++ * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; } else { if ( feof ( * ( FILE * * ) @@int64@@ ) ) @@int@@ = Number ; else @@int@@ = Number ; * @@int@@ = @@int@@ ; @@int64@@ = Number L ; } } else if ( * * ( _QWORD * * ) ( @@int64@@ + Number ) ) { * @@int@@ = Number ; @@int64@@ = * ( __int64 * * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ + Number ; @@int64@@ = * @@int64@@ ; } else { * @@int@@ = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
__int64 __fastcall argv_iter_n_args ( _QWORD * @@QWORD@@ ) { __int64 @@int64@@ ; if ( * @@QWORD@@ ) @@int64@@ = @@QWORD@@ [ Number ] ; else @@int64@@ = ( __int64 ) ( @@QWORD@@ [ Number ] - @@QWORD@@ [ Number ] ) >> Number ; return @@int64@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall umaxtostr ( unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = @@int64@@ + Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = Number ; do { * ( _BYTE * ) -- @@int64@@ = @@unsignedint64@@ % Number + Number ; @@unsignedint64@@ /= Number ; } while ( @@unsignedint64@@ ) ; return @@int64@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return xmalloc ( @@int64@@ , @@int64@@ , @@int64@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
unsigned __int64 __fastcall AD_hash ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) % @@unsignedint64@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_206028 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_209108 ; @@int648@@ [ Number ] = qword_209110 ; @@int648@@ [ Number ] = qword_209118 ; @@int648@@ [ Number ] = qword_209120 ; @@int648@@ [ Number ] = qword_209128 ; @@int648@@ [ Number ] = qword_209130 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
__int64 __fastcall enter_dir ( __int64 @@int64@@ , __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; if ( ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number ) { @@QWORD@@ = malloc ( Number ) ; if ( ! @@QWORD@@ ) return Number L ; * @@QWORD@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ [ Number ] = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = hash_insert ( * ( _QWORD * ) ( @@int64@@ + Number ) , @@QWORD@@ ) ; if ( ( _QWORD * ) @@int64@@ != @@QWORD@@ ) { free ( @@QWORD@@ ) ; if ( ! @@int64@@ ) return Number L ; * ( _QWORD * ) @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _WORD * ) ( @@int64@@ + Number ) = Number ; } } else if ( ( unsigned __int8 ) cycle_check ( * ( _QWORD * ) ( @@int64@@ + Number ) , @@int64@@ + Number ) ) { * ( _QWORD * ) @@int64@@ = @@int64@@ ; * ( _WORD * ) ( @@int64@@ + Number ) = Number ; } return Number L ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
__int64 __fastcall cwd_advance_fd ( __int64 @@int64@@ , int @@int@@ , char @@char@@ ) { __int64 @@int64@@ ; int @@int@@ ; int @@int@@ ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) ; if ( @@int@@ == @@int@@ && @@int@@ != Number ) abort ( ) ; if ( @@char@@ ) { @@int@@ = i_ring_push ( @@int64@@ + Number , ( unsigned int ) @@int@@ ) ; if ( @@int@@ >= Number ) close ( @@int@@ ) ; } else if ( ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) == Number && @@int@@ >= Number ) { close ( @@int@@ ) ; } @@int64@@ = @@int64@@ ; * ( _DWORD * ) ( @@int64@@ + Number ) = @@int@@ ; return @@int64@@ ; }
int __cdecl __noreturn main ( int @@int@@ , const char * * @@constchar@@ , const char * * @@constchar@@ ) { __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __uid_t @@uidt@@ ; struct passwd * @@structpasswd@@ ; set_program_name ( * @@constchar@@ , @@constchar@@ , @@constchar@@ ) ; setlocale ( Number , & shortopts ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; parse_long_options ( @@int@@ , ( _DWORD ) @@constchar@@ , ( unsigned int ) String , ( unsigned int ) String , ( _DWORD ) Version , ( unsigned int ) usage , String , Number L ) ; if ( getopt_long ( @@int@@ , ( char * const * ) @@constchar@@ , & shortopts , Number L , Number L ) != Number ) usage ( Number ) ; if ( @@int@@ != optind ) { @@int64@@ = quote ( @@constchar@@ [ optind ] ) ; @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ , @@int64@@ ) ; usage ( Number ) ; } @@uidt@@ = geteuid ( ) ; @@structpasswd@@ = getpwuid ( @@uidt@@ ) ; if ( @@structpasswd@@ ) { puts ( @@structpasswd@@ -> pw_name ) ; exit ( Number ) ; } @@int64@@ = program_name ; @@char@@ = gettext ( String ) ; fprintf ( stderr , @@char@@ , @@int64@@ , @@uidt@@ ) ; exit ( Number ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_207288 ; @@int648@@ [ Number ] = qword_207290 ; @@int648@@ [ Number ] = qword_207298 ; @@int648@@ [ Number ] = qword_2072A0 ; @@int648@@ [ Number ] = qword_2072A8 ; @@int648@@ [ Number ] = qword_2072B0 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
_BOOL8 __fastcall AD_compare ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ ) { return @@QWORD@@ [ Number ] == @@QWORD@@ [ Number ] && * @@QWORD@@ == * @@QWORD@@ ; }
__int64 __fastcall set_stat_type ( __int64 @@int64@@ , int @@int@@ ) { __int64 @@int64@@ ; int @@int@@ ; switch ( @@int@@ ) { case Number : @@int@@ = Number ; break ; case Number : @@int@@ = Number ; break ; case Number : @@int@@ = Number ; break ; case Number : @@int@@ = Number ; break ; case Number : @@int@@ = Number ; break ; case Number : @@int@@ = Number ; break ; case Number : @@int@@ = Number ; break ; default : @@int@@ = Number ; break ; } @@int64@@ = @@int64@@ ; * ( _DWORD * ) ( @@int64@@ + Number ) = @@int@@ ; return @@int64@@ ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
_QWORD * __fastcall argv_iter_init_argv ( __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; @@QWORD@@ = malloc ( Number ) ; if ( ! @@QWORD@@ ) return Number L ; * @@QWORD@@ = Number L ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; return @@QWORD@@ ; }
__int64 __fastcall setup_dir ( __int64 @@int64@@ ) { if ( ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number ) { * ( _QWORD * ) ( @@int64@@ + Number ) = hash_initialize ( Number L , Number L , AD_hash , AD_compare , & free ) ; if ( ! * ( _QWORD * ) ( @@int64@@ + Number ) ) return Number L ; } else { * ( _QWORD * ) ( @@int64@@ + Number ) = malloc ( Number ) ; if ( ! * ( _QWORD * ) ( @@int64@@ + Number ) ) return Number L ; cycle_check_init ( * ( _QWORD * ) ( @@int64@@ + Number ) ) ; } return Number L ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall compute_context_from_mask ( __int64 @@int64@@ , unsigned int * @@unsignedint@@ ) { __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; char @@char@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; @@char@@ = Number ; @@unsignedint@@ = context_new ( @@int64@@ ) ; if ( @@unsignedint@@ ) { if ( specified_user && ( unsigned int ) context_user_set ( @@unsignedint@@ , specified_user ) ) { @@int64@@ = quote ( specified_user ) ; @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ , String , @@int64@@ ) ; @@char@@ = Number ; } if ( specified_range && ( unsigned int ) context_range_set ( @@unsignedint@@ , specified_range ) ) { @@int64@@ = quote ( specified_range ) ; @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ , String , @@int64@@ ) ; @@char@@ = Number ; } if ( specified_role && ( unsigned int ) context_role_set ( @@unsignedint@@ , specified_role ) ) { @@int64@@ = quote ( specified_role ) ; @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ , String , @@int64@@ ) ; @@char@@ = Number ; } if ( specified_type && ( unsigned int ) context_type_set ( @@unsignedint@@ , specified_type ) ) { @@int64@@ = quote ( specified_type ) ; @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ , String , @@int64@@ ) ; @@char@@ = Number ; } if ( @@char@@ != Number ) { @@int@@ = * __errno_location ( ) ; context_free ( ) ; * __errno_location ( ) = @@int@@ ; @@int64@@ = Number L ; } else { * @@unsignedint@@ = @@unsignedint@@ ; @@int64@@ = Number L ; } } else { @@int64@@ = quotearg_colon ( @@int64@@ ) ; @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ , @@int64@@ ) ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall fts_padjust ( __int64 @@int64@@ , _QWORD * @@QWORD@@ ) { _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; for ( @@QWORD@@ = * ( _QWORD * * ) ( @@int64@@ + Number ) ; @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { if ( ( _QWORD * ) @@QWORD@@ [ Number ] != @@QWORD@@ + Number ) @@QWORD@@ [ Number ] = @@int64@@ + @@QWORD@@ [ Number ] - @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; } while ( Number ) { @@int64@@ = @@QWORD@@ [ Number ] ; if ( @@int64@@ < Number ) break ; if ( ( _QWORD * ) @@QWORD@@ [ Number ] != @@QWORD@@ + Number ) @@QWORD@@ [ Number ] = @@int64@@ + @@QWORD@@ [ Number ] - @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; if ( @@QWORD@@ [ Number ] ) @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; else @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; @@QWORD@@ = @@QWORD@@ ; } return @@int64@@ ; }
unsigned __int64 __fastcall LCO_hash ( _QWORD * @@QWORD@@ , unsigned __int64 @@unsignedint64@@ ) { return * @@QWORD@@ % @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
int __fastcall readtokens0_init ( __int64 @@int64@@ ) { * ( _QWORD * ) @@int64@@ = Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number L ; _obstack_begin ( ( struct obstack * ) ( @@int64@@ + Number ) , Number , Number , ( void * ( * ) ( __int64 ) ) & malloc , ( void ( * ) ( void * ) ) & free ) ; _obstack_begin ( ( struct obstack * ) ( @@int64@@ + Number ) , Number , Number , ( void * ( * ) ( __int64 ) ) & malloc , ( void ( * ) ( void * ) ) & free ) ; return _obstack_begin ( ( struct obstack * ) ( @@int64@@ + Number ) , Number , Number , ( void * ( * ) ( __int64 ) ) & malloc , ( void ( * ) ( void * ) ) & free ) ; }
_BOOL8 __fastcall leaf_optimization_applies ( int @@int@@ ) { _BOOL8 @@BOOL8@@ ; struct statfs @@structstatfs@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( fstatfs ( @@int@@ , & @@structstatfs@@ ) ) @@BOOL8@@ = Number L ; else @@BOOL8@@ = @@structstatfs@@ . f_type == Number ; return @@BOOL8@@ ; }
bool __fastcall LCO_compare ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ ) { return * @@QWORD@@ == * @@QWORD@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall hash_lookup ( __int64 * @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; @@int64@@ = * @@int64@@ ; @@QWORD@@ = ( _QWORD * ) ( @@int64@@ + Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@int64@@ [ Number ] ) ( @@int64@@ , @@int64@@ [ Number ] ) ) ; if ( ( unsigned __int64 ) @@QWORD@@ >= @@int64@@ [ Number ] ) abort ( ) ; if ( ! * @@QWORD@@ ) return Number L ; for ( @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { if ( @@int64@@ == * @@QWORD@@ || ( ( unsigned __int8 ( __fastcall * ) ( __int64 , _QWORD ) ) @@int64@@ [ Number ] ) ( @@int64@@ , * @@QWORD@@ ) ) { return * @@QWORD@@ ; } } return Number L ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
__int64 __fastcall next_prime ( unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = @@unsignedint64@@ ; if ( @@unsignedint64@@ <= Number ) @@int64@@ = Number L ; for ( @@int64@@ = @@int64@@ | Number ; @@int64@@ != Number && ! is_prime ( @@int64@@ ) ; @@int64@@ += Number L ) { ; } return @@int64@@ ; }
__int64 __fastcall link_count_optimize_ok ( __int64 @@int64@@ ) { __int64 @@int64@@ ; bool @@bool@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; _BYTE * @@BYTE@@ ; __int64 @@int644@@ [ Number ] ; @@int644@@ [ Number ] = __readfsqword ( Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) == Number ) return Number L ; if ( ! @@int64@@ ) { * ( _QWORD * ) ( @@int64@@ + Number ) = hash_initialize ( Number L , Number L , LCO_hash , LCO_compare , & free ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( ! @@int64@@ ) return Number L ; } @@int644@@ [ Number ] = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = hash_lookup ( @@int64@@ , @@int644@@ ) ; if ( @@int64@@ ) return * ( unsigned __int8 * ) ( @@int64@@ + Number ) ; @@BYTE@@ = malloc ( Number ) ; if ( ! @@BYTE@@ ) return Number L ; @@bool@@ = leaf_optimization_applies ( * ( _DWORD * ) ( @@int64@@ + Number ) ) ; @@BYTE@@ [ Number ] = @@bool@@ ; * ( _QWORD * ) @@BYTE@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = hash_insert ( @@int64@@ , @@BYTE@@ ) ; if ( @@int64@@ ) { if ( ( _BYTE * ) @@int64@@ != @@BYTE@@ ) abort ( ) ; @@int64@@ = @@bool@@ ; } else { free ( @@BYTE@@ ) ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall fts_set ( __int64 a1 , __int64 @@int64@@ , int @@int@@ ) { __int64 @@int64@@ ; if ( ! @@int@@ || @@int@@ == Number || @@int@@ == Number || @@int@@ == Number || @@int@@ == Number ) { * ( _WORD * ) ( @@int64@@ + Number ) = @@int@@ ; @@int64@@ = Number L ; } else { * __errno_location ( ) = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
size_t * __fastcall hash_initialize ( __int64 @@int64@@ , void * @@void@@ , unsigned __int64 ( __fastcall * @ @ VAR_698 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ) ( __int64 a1 , unsigned __int64 a2 ) , bool ( __fastcall * @ @ VAR_700 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ) ( __int64 a1 , __int64 a2 ) , size_t @@sizet@@ ) { size_t * @@sizet@@ ; bool ( __fastcall * @ @ VAR_699 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ) ( __int64 , __int64 ) ; unsigned __int64 ( __fastcall * @ @ VAR_697 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ) ( __int64 , unsigned __int64 ) ; void * @@void@@ ; size_t * @@sizet@@ ; @@void@@ = @@void@@ ; @ @ VAR_697 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher = @ @ VAR_698 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ; @ @ VAR_699 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator = @ @ VAR_700 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ; if ( ! @ @ VAR_698 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ) @ @ VAR_697 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher = raw_hasher ; if ( ! @ @ VAR_700 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ) @ @ VAR_699 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator = raw_comparator ; @@sizet@@ = ( size_t * ) malloc ( Number ) ; if ( ! @@sizet@@ ) return Number L ; if ( ! @@void@@ ) @@void@@ = & default_tuning ; @@sizet@@ [ Number ] = ( size_t ) @@void@@ ; if ( ( unsigned __int8 ) check_tuning ( ( __int64 ) @@sizet@@ ) == Number && ( @@sizet@@ [ Number ] = compute_bucket_size ( @@int64@@ , ( __int64 ) @@void@@ ) ) != Number && ( * @@sizet@@ = ( size_t ) calloc ( @@sizet@@ [ Number ] , Number ) ) != Number ) { @@sizet@@ [ Number ] = Number * @@sizet@@ [ Number ] + * @@sizet@@ ; @@sizet@@ [ Number ] = Number L ; @@sizet@@ [ Number ] = Number L ; @@sizet@@ [ Number ] = ( size_t ) @ @ VAR_697 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ; @@sizet@@ [ Number ] = ( size_t ) @ @ VAR_699 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ; @@sizet@@ [ Number ] = @@sizet@@ ; @@sizet@@ [ Number ] = Number L ; @@sizet@@ = @@sizet@@ ; } else { free ( @@sizet@@ ) ; @@sizet@@ = Number L ; } return @@sizet@@ ; }
__int64 __fastcall hash_get_n_buckets_used ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return xmalloc ( @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall fts_compar ( __int64 @@int64@@ , __int64 @@int64@@ ) { return ( * ( __int64 ( __fastcall * * ) ( __int64 , __int64 ) ) ( * ( _QWORD * ) ( * ( _QWORD * ) @@int64@@ + Number L ) + Number L ) ) ( @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
__int64 __fastcall i_ring_empty ( __int64 @@int64@@ ) { return * ( unsigned __int8 * ) ( @@int64@@ + Number ) ; }
_BOOL8 __fastcall hash_table_ok ( __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; @@int64@@ = Number L ; @@int64@@ = Number L ; for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { @@QWORD@@ = @@QWORD@@ ; ++ @@int64@@ ; ++ @@int64@@ ; while ( Number ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; if ( ! @@QWORD@@ ) break ; ++ @@int64@@ ; } } } return @@int64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) && @@int64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall xnrealloc ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { if ( ! is_mul_ok ( @@unsignedint64@@ , @@unsignedint64@@ ) ) xalloc_die ( ) ; return xrealloc ( @@int64@@ , @@unsignedint64@@ * @@unsignedint64@@ ) ; }
__int64 __fastcall hash_do_for_each ( __int64 @@int64@@ , unsigned __int8 ( __fastcall * @ @ VAR_668 @ @ unsignedint8 ( fastcall ) ( QWORD , int64 ) @ @ Hashprocessor ) ( _QWORD , __int64 ) , __int64 @@int64@@ ) { __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; @@int64@@ = Number L ; for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { for ( @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { if ( @ @ VAR_668 @ @ unsignedint8 ( fastcall ) ( QWORD , int64 ) @ @ Hashprocessor ( * @@QWORD@@ , @@int64@@ ) != Number ) return @@int64@@ ; ++ @@int64@@ ; } } } return @@int64@@ ; }
__int64 __fastcall i_ring_push ( __int64 @@int64@@ , int @@int@@ ) { int @@int@@ ; unsigned int @@unsignedint@@ ; @@int@@ = ( ( unsigned __int8 ) * ( _DWORD * ) ( @@int64@@ + Number ) + ( * ( _BYTE * ) ( @@int64@@ + Number ) ^ Number ) ) & Number ; @@unsignedint@@ = * ( _DWORD * ) ( @@int64@@ + Number L * ( ( ( unsigned __int8 ) * ( _DWORD * ) ( @@int64@@ + Number ) + ( * ( _BYTE * ) ( @@int64@@ + Number ) ^ Number ) ) & Number ) ) ; * ( _DWORD * ) ( @@int64@@ + Number L * ( ( ( unsigned __int8 ) * ( _DWORD * ) ( @@int64@@ + Number ) + ( * ( _BYTE * ) ( @@int64@@ + Number ) ^ Number ) ) & Number ) ) = @@int@@ ; * ( _DWORD * ) ( @@int64@@ + Number ) = @@int@@ ; if ( @@int@@ == * ( _DWORD * ) ( @@int64@@ + Number ) ) * ( _DWORD * ) ( @@int64@@ + Number ) = ( ( unsigned __int8 ) * ( _DWORD * ) ( @@int64@@ + Number ) + ( * ( _BYTE * ) ( @@int64@@ + Number ) ^ Number ) ) & Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = Number ; return @@unsignedint@@ ; }
__int64 __fastcall fts_sort ( __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { size_t @@sizet@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; int ( * @ @ VAR_577 @ @ int ( ) ( constvoid , constvoid ) @ @ int ( ) ( constvoid , constvoid ) ) ( const void * , const void * ) ; void * @@void@@ ; @@sizet@@ = @@sizet@@ ; @ @ VAR_577 @ @ int ( ) ( constvoid , constvoid ) @ @ int ( ) ( constvoid , constvoid ) = * ( int ( * * ) ( const void * , const void * ) ) ( @@int64@@ + Number ) ; if ( @@sizet@@ > * ( _QWORD * ) ( @@int64@@ + Number ) ) { * ( _QWORD * ) ( @@int64@@ + Number ) = @@sizet@@ + Number ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) > Number || ( @@void@@ = realloc ( * ( void * * ) ( @@int64@@ + Number ) , Number L * * ( _QWORD * ) ( @@int64@@ + Number ) ) ) == Number L ) { free ( * ( void * * ) ( @@int64@@ + Number ) ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number L ; return @@int64@@ ; } * ( _QWORD * ) ( @@int64@@ + Number ) = @@void@@ ; } @@QWORD@@ = * ( _QWORD * * ) ( @@int64@@ + Number ) ; for ( @@int64@@ = @@int64@@ ; @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ) { @@QWORD@@ = @@QWORD@@ ++ ; * @@QWORD@@ = @@int64@@ ; } qsort ( * ( void * * ) ( @@int64@@ + Number ) , @@sizet@@ , Number , @ @ VAR_577 @ @ int ( ) ( constvoid , constvoid ) @ @ int ( ) ( constvoid , constvoid ) ) ; @@QWORD@@ = * ( _QWORD * * ) ( @@int64@@ + Number ) ; @@int64@@ = * @@QWORD@@ ; while ( -- @@sizet@@ ) { * ( _QWORD * ) ( * @@QWORD@@ + Number L ) = @@QWORD@@ [ Number ] ; ++ @@QWORD@@ ; } * ( _QWORD * ) ( * @@QWORD@@ + Number L ) = Number L ; return @@int64@@ ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall x2nrealloc ( __int64 @@int64@@ , unsigned __int64 * @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = * @@unsignedint64@@ ; if ( @@int64@@ ) { if ( @@unsignedint64@@ >= Number / @@unsignedint64@@ ) xalloc_die ( ) ; @@unsignedint64@@ += ( @@unsignedint64@@ + Number ) >> Number ; } else if ( ! @@unsignedint64@@ ) { @@unsignedint64@@ = ( Number / @@unsignedint64@@ == Number ) + Number / @@unsignedint64@@ ; } * @@unsignedint64@@ = @@unsignedint64@@ ; return xrealloc ( @@int64@@ , @@unsignedint64@@ * @@unsignedint64@@ ) ; }
__int64 __fastcall openat_safer ( int @@int@@ , const char * @@constchar@@ , char @@char@@ , unsigned int @@unsignedint@@ ) { unsigned int @@unsignedint@@ ; unsigned int @@unsignedint@@ ; @@unsignedint@@ = Number ; if ( ( @@char@@ & Number ) != Number ) @@unsignedint@@ = @@unsignedint@@ ; @@unsignedint@@ = openat ( @@int@@ , @@constchar@@ , @@char@@ , @@unsignedint@@ ) ; return fd_safer ( @@unsignedint@@ ) ; }
__int64 __fastcall check_tuning ( __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( ( _UNKNOWN * ) @@int64@@ == & default_tuning ) return Number L ; if ( * ( float * ) ( @@int64@@ + Number ) > Number && ( float ) ( Number - Number ) > * ( float * ) ( @@int64@@ + Number ) && * ( float * ) ( @@int64@@ + Number ) > ( float ) ( Number + Number ) && * ( float * ) @@int64@@ >= Number && * ( float * ) ( @@int64@@ + Number ) > ( float ) ( * ( float * ) @@int64@@ + Number ) && * ( float * ) ( @@int64@@ + Number ) <= Number && * ( float * ) ( @@int64@@ + Number ) > ( float ) ( * ( float * ) @@int64@@ + Number ) ) { return Number L ; } * ( _QWORD * ) ( @@int64@@ + Number ) = & default_tuning ; return Number L ; }
unsigned __int64 __fastcall hash_get_entries ( __int64 @@int64@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; @@unsignedint64@@ = Number L ; for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { for ( @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { if ( @@unsignedint64@@ >= @@unsignedint64@@ ) return @@unsignedint64@@ ; @@int64@@ = @@unsignedint64@@ ++ ; * ( _QWORD * ) ( @@int64@@ + Number * @@int64@@ ) = * @@QWORD@@ ; } } } return @@unsignedint64@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 __fastcall free_entry ( __int64 @@int64@@ , _QWORD * @@QWORD@@ ) { __int64 @@int64@@ ; * @@QWORD@@ = Number L ; @@QWORD@@ [ Number ] = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@QWORD@@ ; return @@int64@@ ; }
unsigned __int64 __fastcall raw_hasher ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { return rotr_sz ( @@int64@@ , Number ) % @@unsignedint64@@ ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
void __fastcall free_dir ( __int64 @@int64@@ ) { if ( ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number ) { if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) hash_free ( * ( _QWORD * ) ( @@int64@@ + Number ) ) ; } else { free ( * ( void * * ) ( @@int64@@ + Number ) ) ; } }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
void * __fastcall allocate_entry ( __int64 @@int64@@ ) { __int64 @@int64@@ ; if ( ! * ( _QWORD * ) ( @@int64@@ + Number ) ) return malloc ( Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; return ( void * ) @@int64@@ ; }
__int64 __fastcall fts_set_stat_required ( __int64 @@int64@@ , char @@char@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; if ( * ( _WORD * ) ( @@int64@@ + Number ) != Number ) abort ( ) ; if ( @@char@@ ) @@int64@@ = Number L ; else @@int64@@ = Number L ; @@int64@@ = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; return @@int64@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 __fastcall transfer_entries ( __int64 @@int64@@ , __int64 @@int64@@ , char @@char@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 * @@int64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; for ( @@int64@@ = * ( __int64 * * ) @@int64@@ ; ( unsigned __int64 ) @@int64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ += Number ) { if ( * @@int64@@ ) { for ( @@QWORD@@ = ( _QWORD * ) @@int64@@ [ Number ] ; @@QWORD@@ ; @@QWORD@@ = @@QWORD@@ ) { @@int64@@ = * @@QWORD@@ ; @@int64@@ = * ( _QWORD * ) @@int64@@ ; @@QWORD@@ = ( _QWORD * ) ( @@int64@@ + Number * ( * ( __int64 ( __fastcall * * ) ( _QWORD , _QWORD ) ) ( @@int64@@ + Number ) ) ( * @@QWORD@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@QWORD@@ >= * ( _QWORD * ) ( @@int64@@ + Number ) ) abort ( ) ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; if ( * @@QWORD@@ ) { @@QWORD@@ [ Number ] = @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = @@QWORD@@ ; } else { * @@QWORD@@ = @@int64@@ ; ++ * ( _QWORD * ) ( @@int64@@ + Number ) ; free_entry ( @@int64@@ , @@QWORD@@ ) ; } } @@int64@@ = * @@int64@@ ; @@int64@@ [ Number ] = Number L ; if ( ! @@char@@ ) { @@int64@@ = * ( _QWORD * ) @@int64@@ ; @@QWORD@@ = ( _QWORD * ) ( @@int64@@ + Number * ( * ( __int64 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@int64@@ + Number ) ) ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@QWORD@@ >= * ( _QWORD * ) ( @@int64@@ + Number ) ) abort ( ) ; if ( * @@QWORD@@ ) { @@QWORD@@ = allocate_entry ( @@int64@@ ) ; if ( ! @@QWORD@@ ) return Number L ; * @@QWORD@@ = @@int64@@ ; @@QWORD@@ [ Number ] = @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = @@QWORD@@ ; } else { * @@QWORD@@ = @@int64@@ ; ++ * ( _QWORD * ) ( @@int64@@ + Number ) ; } * @@int64@@ = Number L ; -- * ( _QWORD * ) ( @@int64@@ + Number ) ; } } } return Number L ; }
__int64 __fastcall diropen ( __int64 @@int64@@ , int @@int@@ , __int64 a3 , int @@int@@ , int @@int@@ , int @@int@@ ) { int @@int@@ ; int @@int@@ ; unsigned int @@unsignedint@@ ; @@int@@ = ( * ( _DWORD * ) ( @@int64@@ + Number ) << Number ) & Number | Number ; if ( ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number ) @@int@@ = openat_safer ( * ( _DWORD * ) ( @@int64@@ + Number ) , @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int@@ ) ; else @@int@@ = open_safer ( @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int@@ ) ; @@unsignedint@@ = @@int@@ ; if ( @@int@@ >= Number ) set_cloexec_flag ( ( unsigned int ) @@int@@ , Number L ) ; return @@unsignedint@@ ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
__int64 __fastcall hash_find_entry ( __int64 @@int64@@ , __int64 @@int64@@ , _QWORD * @@QWORD@@ , char @@char@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; @@int64@@ = * ( _QWORD * ) @@int64@@ ; @@QWORD@@ = ( _QWORD * ) ( @@int64@@ + Number * ( * ( __int64 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@int64@@ + Number ) ) ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@QWORD@@ >= * ( _QWORD * ) ( @@int64@@ + Number ) ) abort ( ) ; * @@QWORD@@ = @@QWORD@@ ; if ( ! * @@QWORD@@ ) return Number L ; if ( @@int64@@ == * @@QWORD@@ || ( * ( unsigned __int8 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@int64@@ + Number ) ) ( @@int64@@ , * @@QWORD@@ ) ) { @@int64@@ = * @@QWORD@@ ; if ( @@char@@ ) { if ( @@QWORD@@ [ Number ] ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; @@int64@@ = @@QWORD@@ [ Number ] ; * @@QWORD@@ = * @@QWORD@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; free_entry ( @@int64@@ , @@QWORD@@ ) ; } else { * @@QWORD@@ = Number L ; } } @@int64@@ = @@int64@@ ; } else { for ( @@QWORD@@ = @@QWORD@@ ; ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { if ( ! @@QWORD@@ [ Number ] ) return Number L ; if ( @@int64@@ == * ( _QWORD * ) @@QWORD@@ [ Number ] || ( * ( unsigned __int8 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@int64@@ + Number ) ) ( @@int64@@ , * ( _QWORD * ) @@QWORD@@ [ Number ] ) ) { break ; } } @@int64@@ = * ( _QWORD * ) @@QWORD@@ [ Number ] ; if ( @@char@@ ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = @@QWORD@@ [ Number ] ; free_entry ( @@int64@@ , @@QWORD@@ ) ; } @@int64@@ = @@int64@@ ; } return @@int64@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_210108 ; @@int648@@ [ Number ] = qword_210110 ; @@int648@@ [ Number ] = qword_210118 ; @@int648@@ [ Number ] = qword_210120 ; @@int648@@ [ Number ] = qword_210128 ; @@int648@@ [ Number ] = qword_210130 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall fts_compare_ino ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; if ( * ( _QWORD * ) ( * ( _QWORD * ) @@int64@@ + Number L ) < * ( _QWORD * ) ( * ( _QWORD * ) @@int64@@ + Number L ) ) @@int64@@ = Number ; else @@int64@@ = * ( _QWORD * ) ( * ( _QWORD * ) @@int64@@ + Number L ) < * ( _QWORD * ) ( * ( _QWORD * ) @@int64@@ + Number L ) ; return @@int64@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
__int64 __fastcall fts_palloc ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; void * @@void@@ ; @@unsignedint64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) + @@int64@@ + Number ; if ( @@unsignedint64@@ >= * ( _QWORD * ) ( @@int64@@ + Number ) ) { * ( _QWORD * ) ( @@int64@@ + Number ) = @@unsignedint64@@ ; @@void@@ = realloc ( * ( void * * ) ( @@int64@@ + Number ) , * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( @@void@@ ) { * ( _QWORD * ) ( @@int64@@ + Number ) = @@void@@ ; @@int64@@ = Number L ; } else { free ( * ( void * * ) ( @@int64@@ + Number ) ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number L ; @@int64@@ = Number L ; } } else { free ( * ( void * * ) ( @@int64@@ + Number ) ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number L ; * __errno_location ( ) = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall lsetfileconat ( int @@int@@ , _BYTE * @@BYTE@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; int * @@int@@ ; int @@int@@ ; int * @@int@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; int @@int@@ ; char * @@char@@ ; int @@int@@ [ Number ] ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( @@int@@ == Number || * @@BYTE@@ == Number ) return lsetfilecon ( @@BYTE@@ , @@int64@@ ) ; @@char@@ = ( char * ) openat_proc_name ( @@char@@ , ( unsigned int ) @@int@@ , @@BYTE@@ ) ; if ( ! @@char@@ ) goto LABEL_33 ; @@unsignedint@@ = lsetfilecon ( @@char@@ , @@int64@@ ) ; @@int@@ = * __errno_location ( ) ; if ( @@char@@ != @@char@@ ) free ( @@char@@ ) ; if ( @@unsignedint@@ != Number ) return @@unsignedint@@ ; if ( @@int@@ == Number || @@int@@ == Number || @@int@@ == Number || @@int@@ == Number || @@int@@ == Number || @@int@@ == Number ) { LABEL_33 : if ( ( unsigned int ) save_cwd ( @@int@@ ) ) { @@int@@ = __errno_location ( ) ; openat_save_fail ( ( unsigned int ) * @@int@@ ) ; } if ( @@int@@ >= Number && @@int@@ == @@int@@ [ Number ] ) { free_cwd ( @@int@@ ) ; * __errno_location ( ) = Number ; @@int64@@ = Number ; } else if ( fchdir ( @@int@@ ) ) { @@int@@ = * __errno_location ( ) ; free_cwd ( @@int@@ ) ; * __errno_location ( ) = @@int@@ ; @@int64@@ = Number ; } else { @@unsignedint@@ = lsetfilecon ( @@BYTE@@ , @@int64@@ ) ; if ( @@unsignedint@@ == Number ) @@int@@ = * __errno_location ( ) ; else @@int@@ = Number ; @@int@@ = @@int@@ ; if ( ( unsigned int ) restore_cwd ( @@int@@ ) ) { @@int@@ = __errno_location ( ) ; openat_restore_fail ( ( unsigned int ) * @@int@@ ) ; } free_cwd ( @@int@@ ) ; if ( @@int@@ ) * __errno_location ( ) = @@int@@ ; @@int64@@ = @@unsignedint@@ ; } } else { * __errno_location ( ) = @@int@@ ; @@int64@@ = Number ; } return @@int64@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_2060C8 ; @@int648@@ [ Number ] = qword_2060D0 ; @@int648@@ [ Number ] = qword_2060D8 ; @@int648@@ [ Number ] = qword_2060E0 ; @@int648@@ [ Number ] = qword_2060E8 ; @@int648@@ [ Number ] = qword_2060F0 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
int __fastcall hash_print_statistics ( __int64 @@int64@@ , FILE * @@FILE@@ ) { double @@double@@ ; double @@double@@ ; double @@double@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int64@@ = hash_get_n_entries ( @@int64@@ ) ; @@int64@@ = hash_get_n_buckets ( @@int64@@ ) ; @@int64@@ = hash_get_n_buckets_used ( @@int64@@ ) ; @@unsignedint64@@ = hash_get_max_bucket_length ( @@int64@@ ) ; fprintf ( @@FILE@@ , String , @@int64@@ ) ; fprintf ( @@FILE@@ , String , @@int64@@ ) ; if ( @@int64@@ < Number ) @@double@@ = ( double ) ( int ) ( @@int64@@ & Number | ( ( unsigned __int64 ) @@int64@@ >> Number ) ) + ( double ) ( int ) ( @@int64@@ & Number | ( ( unsigned __int64 ) @@int64@@ >> Number ) ) ; else @@double@@ = ( double ) ( int ) @@int64@@ ; @@double@@ = Number * @@double@@ ; if ( @@int64@@ < Number ) @@double@@ = ( double ) ( int ) ( @@int64@@ & Number | ( ( unsigned __int64 ) @@int64@@ >> Number ) ) + ( double ) ( int ) ( @@int64@@ & Number | ( ( unsigned __int64 ) @@int64@@ >> Number ) ) ; else @@double@@ = ( double ) ( int ) @@int64@@ ; fprintf ( @@FILE@@ , String , @@int64@@ , @@double@@ / @@double@@ ) ; return fprintf ( @@FILE@@ , String , @@unsignedint64@@ ) ; }
int __fastcall restore_cwd ( __int64 @@int64@@ ) { int @@int@@ ; if ( * ( int * ) @@int64@@ < Number ) @@int@@ = chdir_long ( * ( _QWORD * ) ( @@int64@@ + Number ) ) ; else @@int@@ = fchdir ( * ( _DWORD * ) @@int64@@ ) ; return @@int@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
__int64 __fastcall getfileconat ( int @@int@@ , _BYTE * @@BYTE@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; int * @@int@@ ; int @@int@@ ; int * @@int@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; int @@int@@ ; char * @@char@@ ; int @@int@@ [ Number ] ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( @@int@@ == Number || * @@BYTE@@ == Number ) return getfilecon_0 ( @@BYTE@@ , @@int64@@ ) ; @@char@@ = ( char * ) openat_proc_name ( @@char@@ , ( unsigned int ) @@int@@ , @@BYTE@@ ) ; if ( ! @@char@@ ) goto LABEL_33 ; @@unsignedint@@ = getfilecon_0 ( @@char@@ , @@int64@@ ) ; @@int@@ = * __errno_location ( ) ; if ( @@char@@ != @@char@@ ) free ( @@char@@ ) ; if ( @@unsignedint@@ != Number ) return @@unsignedint@@ ; if ( @@int@@ == Number || @@int@@ == Number || @@int@@ == Number || @@int@@ == Number || @@int@@ == Number || @@int@@ == Number ) { LABEL_33 : if ( ( unsigned int ) save_cwd ( @@int@@ ) ) { @@int@@ = __errno_location ( ) ; openat_save_fail ( ( unsigned int ) * @@int@@ ) ; } if ( @@int@@ >= Number && @@int@@ == @@int@@ [ Number ] ) { free_cwd ( @@int@@ ) ; * __errno_location ( ) = Number ; @@int64@@ = Number ; } else if ( fchdir ( @@int@@ ) ) { @@int@@ = * __errno_location ( ) ; free_cwd ( @@int@@ ) ; * __errno_location ( ) = @@int@@ ; @@int64@@ = Number ; } else { @@unsignedint@@ = getfilecon_0 ( @@BYTE@@ , @@int64@@ ) ; if ( @@unsignedint@@ == Number ) @@int@@ = * __errno_location ( ) ; else @@int@@ = Number ; @@int@@ = @@int@@ ; if ( ( unsigned int ) restore_cwd ( @@int@@ ) ) { @@int@@ = __errno_location ( ) ; openat_restore_fail ( ( unsigned int ) * @@int@@ ) ; } free_cwd ( @@int@@ ) ; if ( @@int@@ ) * __errno_location ( ) = @@int@@ ; @@int64@@ = @@unsignedint@@ ; } } else { * __errno_location ( ) = @@int@@ ; @@int64@@ = Number ; } return @@int64@@ ; }
__int64 __fastcall change_file_context ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { int @@int@@ ; __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; __int64 @@int64@@ ; char * @@char@@ ; int @@int@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; unsigned int @@unsignedint@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; int @@int@@ ; char * @@char@@ ; char * @@char@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@char@@ = Number L ; @@unsignedint@@ = Number ; if ( specified_context ) { @@unsignedint@@ = context_new ( specified_context ) ; if ( ! @@unsignedint@@ ) abort ( ) ; } else { if ( affect_symlink_referent ) @@int@@ = getfileconat ( @@unsignedint@@ , @@int64@@ , & @@char@@ ) ; else @@int@@ = lgetfileconat ( @@unsignedint@@ , @@int64@@ , & @@char@@ ) ; @@int@@ = @@int@@ ; if ( @@int@@ < Number && * __errno_location ( ) != Number ) { @@int64@@ = quote ( @@int64@@ ) ; @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ , @@int64@@ ) ; return Number L ; } if ( ! @@char@@ ) { @@int64@@ = quote ( @@int64@@ ) ; @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ , @@int64@@ ) ; return Number L ; } if ( ( unsigned int ) compute_context_from_mask ( ( __int64 ) @@char@@ , & @@unsignedint@@ ) ) return Number L ; } @@char@@ = ( char * ) context_str ( @@unsignedint@@ ) ; if ( ! @@char@@ || strcmp ( @@char@@ , @@char@@ ) ) { if ( affect_symlink_referent ) @@int@@ = setfileconat ( @@unsignedint@@ , @@int64@@ , @@char@@ ) ; else @@int@@ = lsetfileconat ( @@unsignedint@@ , @@int64@@ , @@char@@ ) ; @@int@@ = @@int@@ ; if ( @@int@@ ) { @@unsignedint@@ = Number ; @@int64@@ = quote_n ( Number L , @@char@@ ) ; @@int64@@ = quote_n ( Number L , @@int64@@ ) ; @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ , @@int64@@ , @@int64@@ ) ; } } context_free ( ) ; freecon ( ) ; return @@unsignedint@@ ; }
unsigned __int64 __fastcall compute_bucket_size ( __int64 @@int64@@ , __int64 @@int64@@ ) { float @@float@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; float @@float@@ ; @@unsignedint64@@ = @@int64@@ ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) != Number ) { if ( @@int64@@ < Number ) @@float@@ = ( float ) ( @@int64@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@int64@@ >> Number ) ) + ( float ) ( @@int64@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@int64@@ >> Number ) ) ; else @@float@@ = ( float ) ( int ) @@int64@@ ; @@float@@ = @@float@@ / * ( float * ) ( @@int64@@ + Number ) ; if ( @@float@@ >= Number ) return Number L ; if ( @@float@@ >= Number ) @@unsignedint64@@ = ( unsigned int ) ( int ) ( float ) ( @@float@@ - Number ) ^ Number ; else @@unsignedint64@@ = ( unsigned int ) ( int ) @@float@@ ; } @@unsignedint64@@ = next_prime ( @@unsignedint64@@ ) ; if ( @@unsignedint64@@ <= Number ) @@unsignedint64@@ = @@unsignedint64@@ ; else @@unsignedint64@@ = Number L ; return @@unsignedint64@@ ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
__int64 __fastcall bsd_sum_file ( const char * @@constchar@@ , int @@int@@ ) { int @@int@@ ; int @@int@@ ; int * @@int@@ ; int * @@int@@ ; const char * @@constchar@@ ; _BYTE @@BYTE5@@ [ Number ] ; FILE * @@FILE@@ ; __int64 @@int64@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@BYTE5@@ [ Number ] = Number ; @@int64@@ = Number L ; @@int@@ = strcmp ( @@constchar@@ , String ) ; * ( _DWORD * ) @@BYTE5@@ = @@int@@ == Number ; if ( @@int@@ ) { @@FILE@@ = fopen ( @@constchar@@ , String ) ; if ( @@FILE@@ ) goto LABEL_6 ; goto LABEL_4 ; } @@FILE@@ = stdin ; have_read_stdin = Number ; for ( @@int@@ = getc_unlocked ( stdin ) ; @@int@@ != Number ; @@int@@ = getc_unlocked ( @@FILE@@ ) ) { ++ @@int64@@ ; * ( _DWORD * ) & @@BYTE5@@ [ Number ] = ( unsigned __int16 ) ( @@int@@ + ( * ( int * ) & @@BYTE5@@ [ Number ] >> Number ) + ( * ( _WORD * ) & @@BYTE5@@ [ Number ] << Number ) ) ; LABEL_6 : ; } if ( ferror_unlocked ( @@FILE@@ ) ) { @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , String , @@constchar@@ ) ; if ( @@BYTE5@@ [ Number ] != Number ) fclose ( @@FILE@@ ) ; return Number L ; } if ( @@BYTE5@@ [ Number ] != Number && fclose ( @@FILE@@ ) ) { LABEL_4 : @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , String , @@constchar@@ ) ; return Number L ; } @@constchar@@ = ( const char * ) human_readable ( @@int64@@ , @@char@@ , Number L , Number L , Number L ) ; printf ( String , * ( unsigned int * ) & @@BYTE5@@ [ Number ] , @@constchar@@ ) ; if ( @@int@@ > Number ) printf ( String , @@constchar@@ ) ; putchar_unlocked ( Number ) ; return Number L ; }
bool __fastcall is_zero_or_power_of_two ( __int64 @@int64@@ ) { return ( @@int64@@ & ( @@int64@@ - Number ) ) == Number ; }
unsigned __int64 __fastcall leave_dir ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 * @@int64@@ ; __int64 * @@int64@@ ; void * @@void@@ ; __int64 @@int643@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = ( __int64 * ) ( @@int64@@ + Number ) ; if ( ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number ) { @@int643@@ [ Number ] = * @@int64@@ ; @@int643@@ [ Number ] = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@void@@ = ( void * ) hash_delete ( * ( _QWORD * ) ( @@int64@@ + Number ) , @@int643@@ ) ; if ( ! @@void@@ ) abort ( ) ; free ( @@void@@ ) ; } else { @@int64@@ = * ( __int64 * * ) ( @@int64@@ + Number ) ; if ( @@int64@@ && @@int64@@ [ Number ] >= Number ) { if ( ! * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) ) abort ( ) ; if ( * * ( _QWORD * * ) ( @@int64@@ + Number ) == * ( _QWORD * ) ( @@int64@@ + Number ) && * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) == * @@int64@@ ) { * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) = @@int64@@ [ Number ] ; * * ( _QWORD * * ) ( @@int64@@ + Number ) = @@int64@@ [ Number ] ; } } } return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall hash_rehash ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; void * @@void@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@unsignedint64@@ = compute_bucket_size ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( ! @@unsignedint64@@ ) return Number L ; if ( @@unsignedint64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ) return Number L ; @@void@@ = calloc ( @@unsignedint64@@ , Number ) ; if ( ! @@void@@ ) return Number L ; @@unsignedint64@@ = @@unsignedint64@@ ; @@int64@@ = ( __int64 ) @@void@@ + Number * @@unsignedint64@@ ; @@int64@@ = Number L ; @@int64@@ = Number L ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( ( unsigned __int8 ) transfer_entries ( ( __int64 ) & @@void@@ , @@int64@@ , Number ) ) { free ( * ( void * * ) @@int64@@ ) ; * ( _QWORD * ) @@int64@@ = @@void@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@unsignedint64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; @@int64@@ = Number L ; } else { * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; if ( ( unsigned __int8 ) transfer_entries ( @@int64@@ , ( __int64 ) & @@void@@ , Number ) != Number || ( unsigned __int8 ) transfer_entries ( @@int64@@ , ( __int64 ) & @@void@@ , Number ) != Number ) { abort ( ) ; } free ( @@void@@ ) ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
__int64 __fastcall rpl_fcntl ( int @@int@@ , int @@int@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ ) { int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; if ( @@int@@ != Number ) return ( unsigned int ) fcntl ( @@int@@ , @@int@@ , @@int64@@ ) ; @@int@@ = @@int64@@ ; if ( have_dupfd_cloexec_2895 < Number ) { @@int@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@int@@ , Number , @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ ) ; } else { @@int@@ = fcntl ( @@int@@ , Number , ( unsigned int ) @@int64@@ ) ; if ( @@int@@ < Number && * __errno_location ( ) == Number ) { @@int@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@int@@ , Number , @@int@@ , @@int@@ , @@int@@ , @@int@@ ) ; if ( @@int@@ < Number ) return ( unsigned int ) @@int@@ ; have_dupfd_cloexec_2895 = Number ; } else { have_dupfd_cloexec_2895 = Number ; } } if ( @@int@@ >= Number && have_dupfd_cloexec_2895 == Number ) { @@int@@ = fcntl ( @@int@@ , Number ) ; if ( @@int@@ < Number || fcntl ( @@int@@ , Number , @@int@@ | Number ) == Number ) { @@int@@ = * __errno_location ( ) ; close ( @@int@@ ) ; * __errno_location ( ) = @@int@@ ; @@int@@ = Number ; } } return ( unsigned int ) @@int@@ ; }
size_t __fastcall fts_maxarglen ( const char * * @@constchar@@ ) { size_t @@sizet@@ ; size_t @@sizet@@ ; @@sizet@@ = Number L ; while ( * @@constchar@@ ) { @@sizet@@ = strlen ( * @@constchar@@ ) ; if ( @@sizet@@ > @@sizet@@ ) @@sizet@@ = @@sizet@@ ; ++ @@constchar@@ ; } return @@sizet@@ + Number ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
__int64 __fastcall hash_get_n_buckets ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
void * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
__int64 __fastcall hash_get_n_entries ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
void * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
unsigned __int64 __fastcall hash_get_max_bucket_length ( __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = Number L ; for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { @@QWORD@@ = @@QWORD@@ ; for ( @@unsignedint64@@ = Number L ; ; ++ @@unsignedint64@@ ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; if ( ! @@QWORD@@ ) break ; } if ( @@unsignedint64@@ > @@unsignedint64@@ ) @@unsignedint64@@ = @@unsignedint64@@ ; } } return @@unsignedint64@@ ; }
char * __fastcall group_number ( char * @@char@@ , size_t @@sizet@@ , unsigned __int8 * @@unsignedint8@@ , const char * @@constchar@@ ) { char * @@char@@ ; size_t @@sizet@@ ; char * @@char@@ ; unsigned __int8 @@unsignedint8@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@sizet@@ = Number ; @@sizet@@ = strlen ( @@constchar@@ ) ; @@sizet@@ = @@sizet@@ ; memcpy ( @@char@@ , @@char@@ , @@sizet@@ ) ; for ( @@char@@ = & @@char@@ [ @@sizet@@ ] ; ; memcpy ( @@char@@ , @@constchar@@ , @@sizet@@ ) ) { @@unsignedint8@@ = * @@unsignedint8@@ ; if ( * @@unsignedint8@@ ) { if ( @@unsignedint8@@ > Number ) @@sizet@@ = @@sizet@@ ; else @@sizet@@ = @@unsignedint8@@ ; @@sizet@@ = @@sizet@@ ; ++ @@unsignedint8@@ ; } if ( @@sizet@@ < @@sizet@@ ) @@sizet@@ = @@sizet@@ ; @@char@@ = & @@char@@ [ - @@sizet@@ ] ; @@sizet@@ -= @@sizet@@ ; memcpy ( @@char@@ , & @@char@@ [ @@sizet@@ ] , @@sizet@@ ) ; if ( ! @@sizet@@ ) break ; @@char@@ = & @@char@@ [ - @@sizet@@ ] ; } return @@char@@ ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
__int64 __fastcall lgetfileconat ( int @@int@@ , _BYTE * @@BYTE@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; int * @@int@@ ; int @@int@@ ; int * @@int@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; int @@int@@ ; char * @@char@@ ; int @@int@@ [ Number ] ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( @@int@@ == Number || * @@BYTE@@ == Number ) return lgetfilecon ( @@BYTE@@ , @@int64@@ ) ; @@char@@ = ( char * ) openat_proc_name ( @@char@@ , ( unsigned int ) @@int@@ , @@BYTE@@ ) ; if ( ! @@char@@ ) goto LABEL_33 ; @@unsignedint@@ = lgetfilecon ( @@char@@ , @@int64@@ ) ; @@int@@ = * __errno_location ( ) ; if ( @@char@@ != @@char@@ ) free ( @@char@@ ) ; if ( @@unsignedint@@ != Number ) return @@unsignedint@@ ; if ( @@int@@ == Number || @@int@@ == Number || @@int@@ == Number || @@int@@ == Number || @@int@@ == Number || @@int@@ == Number ) { LABEL_33 : if ( ( unsigned int ) save_cwd ( @@int@@ ) ) { @@int@@ = __errno_location ( ) ; openat_save_fail ( ( unsigned int ) * @@int@@ ) ; } if ( @@int@@ >= Number && @@int@@ == @@int@@ [ Number ] ) { free_cwd ( @@int@@ ) ; * __errno_location ( ) = Number ; @@int64@@ = Number ; } else if ( fchdir ( @@int@@ ) ) { @@int@@ = * __errno_location ( ) ; free_cwd ( @@int@@ ) ; * __errno_location ( ) = @@int@@ ; @@int64@@ = Number ; } else { @@unsignedint@@ = lgetfilecon ( @@BYTE@@ , @@int64@@ ) ; if ( @@unsignedint@@ == Number ) @@int@@ = * __errno_location ( ) ; else @@int@@ = Number ; @@int@@ = @@int@@ ; if ( ( unsigned int ) restore_cwd ( @@int@@ ) ) { @@int@@ = __errno_location ( ) ; openat_restore_fail ( ( unsigned int ) * @@int@@ ) ; } free_cwd ( @@int@@ ) ; if ( @@int@@ ) * __errno_location ( ) = @@int@@ ; @@int64@@ = @@unsignedint@@ ; } } else { * __errno_location ( ) = @@int@@ ; @@int64@@ = Number ; } return @@int64@@ ; }
void * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall hash_get_first ( unsigned __int64 * @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; if ( ! @@unsignedint64@@ [ Number ] ) return Number L ; for ( @@unsignedint64@@ = * @@unsignedint64@@ ; ; @@unsignedint64@@ += Number L ) { if ( @@unsignedint64@@ >= @@unsignedint64@@ [ Number ] ) abort ( ) ; if ( * ( _QWORD * ) @@unsignedint64@@ ) break ; } return * ( _QWORD * ) @@unsignedint64@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
__ino_t * __fastcall get_root_dev_ino ( __ino_t * @@inot@@ ) { struct stat @@structstat@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( ( unsigned int ) lstat ( String , & @@structstat@@ ) ) return Number L ; * @@inot@@ = @@structstat@@ . st_ino ; @@inot@@ [ Number ] = @@structstat@@ . st_dev ; return @@inot@@ ; }
void * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
unsigned __int64 __fastcall hash_string ( _BYTE * @@BYTE@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = Number L ; while ( * @@BYTE@@ ) @@unsignedint64@@ = ( Number * @@unsignedint64@@ + ( unsigned __int8 ) * @@BYTE@@ ++ ) % @@unsignedint64@@ ; return @@unsignedint64@@ ; }
__int64 __fastcall cycle_check ( __int64 @@int64@@ , _QWORD * @@QWORD@@ ) { if ( * ( _DWORD * ) ( @@int64@@ + Number ) != Number ) __assert_fail ( String , String , Number , String ) ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) && @@QWORD@@ [ Number ] == * ( _QWORD * ) @@int64@@ && * @@QWORD@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ) { return Number L ; } if ( is_zero_or_power_of_two ( ++ * ( _QWORD * ) ( @@int64@@ + Number ) ) ) { if ( ! * ( _QWORD * ) ( @@int64@@ + Number ) ) return Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = * @@QWORD@@ ; * ( _QWORD * ) @@int64@@ = @@QWORD@@ [ Number ] ; } return Number L ; }
void * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_2080C8 ; @@int648@@ [ Number ] = qword_2080D0 ; @@int648@@ [ Number ] = qword_2080D8 ; @@int648@@ [ Number ] = qword_2080E0 ; @@int648@@ [ Number ] = qword_2080E8 ; @@int648@@ [ Number ] = qword_2080F0 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
bool __fastcall is_prime ( unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = Number L ; @@unsignedint64@@ = Number L ; while ( @@unsignedint64@@ < @@unsignedint64@@ && @@unsignedint64@@ % @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@unsignedint64@@ += Number * @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint64@@ + Number ; } return @@unsignedint64@@ % @@unsignedint64@@ != Number ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
__int64 __fastcall setfileconat ( int @@int@@ , _BYTE * @@BYTE@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; int * @@int@@ ; int @@int@@ ; int * @@int@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; int @@int@@ ; char * @@char@@ ; int @@int@@ [ Number ] ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( @@int@@ == Number || * @@BYTE@@ == Number ) return setfilecon ( @@BYTE@@ , @@int64@@ ) ; @@char@@ = ( char * ) openat_proc_name ( @@char@@ , ( unsigned int ) @@int@@ , @@BYTE@@ ) ; if ( ! @@char@@ ) goto LABEL_33 ; @@unsignedint@@ = setfilecon ( @@char@@ , @@int64@@ ) ; @@int@@ = * __errno_location ( ) ; if ( @@char@@ != @@char@@ ) free ( @@char@@ ) ; if ( @@unsignedint@@ != Number ) return @@unsignedint@@ ; if ( @@int@@ == Number || @@int@@ == Number || @@int@@ == Number || @@int@@ == Number || @@int@@ == Number || @@int@@ == Number ) { LABEL_33 : if ( ( unsigned int ) save_cwd ( @@int@@ ) ) { @@int@@ = __errno_location ( ) ; openat_save_fail ( ( unsigned int ) * @@int@@ ) ; } if ( @@int@@ >= Number && @@int@@ == @@int@@ [ Number ] ) { free_cwd ( @@int@@ ) ; * __errno_location ( ) = Number ; @@int64@@ = Number ; } else if ( fchdir ( @@int@@ ) ) { @@int@@ = * __errno_location ( ) ; free_cwd ( @@int@@ ) ; * __errno_location ( ) = @@int@@ ; @@int64@@ = Number ; } else { @@unsignedint@@ = setfilecon ( @@BYTE@@ , @@int64@@ ) ; if ( @@unsignedint@@ == Number ) @@int@@ = * __errno_location ( ) ; else @@int@@ = Number ; @@int@@ = @@int@@ ; if ( ( unsigned int ) restore_cwd ( @@int@@ ) ) { @@int@@ = __errno_location ( ) ; openat_restore_fail ( ( unsigned int ) * @@int@@ ) ; } free_cwd ( @@int@@ ) ; if ( @@int@@ ) * __errno_location ( ) = @@int@@ ; @@int64@@ = @@unsignedint@@ ; } } else { * __errno_location ( ) = @@int@@ ; @@int64@@ = Number ; } return @@int64@@ ; }
int __fastcall cdb_fchdir ( int * @@int@@ ) { return fchdir ( * @@int@@ ) ; }
__int64 __fastcall argmatch_to_argument ( const void * @@constvoid@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; ++ @@int64@@ ) { if ( ! memcmp ( @@constvoid@@ , ( const void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) , @@sizet@@ ) ) return * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; } return Number L ; }
void __fastcall hash_free ( __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) && * ( _QWORD * ) ( @@int64@@ + Number ) ) { for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { for ( @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@int64@@ + Number ) ) ( * @@QWORD@@ ) ; } } } } for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { for ( @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; @@QWORD@@ ; @@QWORD@@ = @@QWORD@@ ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; free ( @@QWORD@@ ) ; } } for ( @@QWORD@@ = * ( _QWORD * * ) ( @@int64@@ + Number ) ; @@QWORD@@ ; @@QWORD@@ = @@QWORD@@ ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; free ( @@QWORD@@ ) ; } free ( * ( void * * ) @@int64@@ ) ; free ( ( void * ) @@int64@@ ) ; }
void * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * @@int64@@ ; void * @@void@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; void * @@void@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == ( __int64 * ) & slotvec0 ; if ( slotvec == ( __int64 * ) & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@void@@ = off_208028 ; * @@int64@@ = ( __int64 ) slotvec0 ; @@int64@@ [ Number ] = ( __int64 ) @@void@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = @@int64@@ [ Number * @@int@@ ] ; @@void@@ = ( void * ) @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@void@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = @@unsignedint64@@ + Number ; if ( @@void@@ != & slot0 ) free ( @@void@@ ) ; @@void@@ = ( void * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = ( __int64 ) @@void@@ ; quotearg_buffer_restyled ( ( __int64 ) @@void@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@void@@ ; }
__int64 __fastcall cdb_free ( int * @@int@@ ) { __int64 @@int64@@ ; @@int64@@ = ( unsigned int ) * @@int@@ ; if ( ( int ) @@int64@@ >= Number ) { @@int64@@ = close ( * @@int@@ ) == Number ; if ( ! ( _BYTE ) @@int64@@ ) __assert_fail ( String , String , Number , String ) ; } return @@int64@@ ; }
__int64 __fastcall save_cwd ( __int64 @@int64@@ , __int64 a2 , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number L ; * ( _DWORD * ) @@int64@@ = open_safer ( String , Number , @@unsignedint@@ ) ; if ( * ( int * ) @@int64@@ >= Number ) return Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = xgetcwd ( ) ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) @@int64@@ = Number L ; else @@int64@@ = Number ; return @@int64@@ ; }
__int64 __fastcall i_ring_pop ( __int64 @@int64@@ ) { unsigned int @@unsignedint@@ ; if ( ( unsigned __int8 ) i_ring_empty ( @@int64@@ ) ) abort ( ) ; @@unsignedint@@ = * ( _DWORD * ) ( @@int64@@ + Number L * * ( unsigned int * ) ( @@int64@@ + Number ) ) ; * ( _DWORD * ) ( @@int64@@ + Number L * * ( unsigned int * ) ( @@int64@@ + Number ) ) = * ( _DWORD * ) ( @@int64@@ + Number ) ; if ( * ( _DWORD * ) ( @@int64@@ + Number ) == * ( _DWORD * ) ( @@int64@@ + Number ) ) * ( _BYTE * ) ( @@int64@@ + Number ) = Number ; else * ( _DWORD * ) ( @@int64@@ + Number ) = ( ( unsigned __int8 ) * ( _DWORD * ) ( @@int64@@ + Number ) + Number ) & Number ; return @@unsignedint@@ ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
__int64 __fastcall open_safer ( const char * @@constchar@@ , char @@char@@ , unsigned int @@unsignedint@@ ) { unsigned int @@unsignedint@@ ; unsigned int @@unsignedint@@ ; @@unsignedint@@ = Number ; if ( ( @@char@@ & Number ) != Number ) @@unsignedint@@ = @@unsignedint@@ ; @@unsignedint@@ = open ( @@constchar@@ , @@char@@ , @@unsignedint@@ ) ; return fd_safer ( @@unsignedint@@ ) ; }
int __cdecl __noreturn main ( int @@int@@ , const char * * @@constchar@@ , const char * * @@constchar@@ ) { int * @@int@@ ; char @@char@@ ; int @@int@@ ; unsigned int @@unsignedint@@ ; __int64 ( __fastcall * @ @ VAR_150 @ @ int64 ( fastcall ) ( constchara1 , inta2 ) @ @ bool ( ) ( constchar , int ) ) ( const char * , int ) ; @ @ VAR_150 @ @ int64 ( fastcall ) ( constchara1 , inta2 ) @ @ bool ( ) ( constchar , int ) = bsd_sum_file ; set_program_name ( * @@constchar@@ , @@constchar@@ , @@constchar@@ ) ; setlocale ( Number , & locale ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; setvbuf ( stdout , Number L , Number , Number L ) ; have_read_stdin = Number ; while ( Number ) { @@int@@ = getopt_long ( @@int@@ , ( char * const * ) @@constchar@@ , String , & longopts , Number L ) ; if ( @@int@@ == Number ) { @@unsignedint@@ = @@int@@ - optind ; if ( @@int@@ - optind > Number ) { @@char@@ = Number ; while ( @@int@@ > optind ) { @@char@@ = ( unsigned __int8 ) ( @@char@@ & @ @ VAR_150 @ @ int64 ( fastcall ) ( constchara1 , inta2 ) @ @ bool ( ) ( constchar , int ) ( @@constchar@@ [ optind ] , @@unsignedint@@ ) ) != Number ; ++ optind ; } } else { @@char@@ = @ @ VAR_150 @ @ int64 ( fastcall ) ( constchara1 , inta2 ) @ @ bool ( ) ( constchar , int ) ( String , @@unsignedint@@ ) ; } if ( have_read_stdin ) { if ( fclose ( stdin ) == Number ) { @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , String ) ; } } exit ( ( unsigned __int8 ) @@char@@ ^ Number ) ; } if ( @@int@@ == Number ) usage ( Number ) ; if ( @@int@@ <= Number ) break ; if ( @@int@@ == Number ) { @ @ VAR_150 @ @ int64 ( fastcall ) ( constchara1 , inta2 ) @ @ bool ( ) ( constchar , int ) = bsd_sum_file ; } else { if ( @@int@@ != Number ) goto LABEL_13 ; @ @ VAR_150 @ @ int64 ( fastcall ) ( constchara1 , inta2 ) @ @ bool ( ) ( constchar , int ) = sysv_sum_file ; } } if ( @@int@@ == Number ) { version_etc ( ( _DWORD ) stdout , ( unsigned int ) String , ( unsigned int ) String , ( _DWORD ) Version , ( unsigned int ) String , ( unsigned int ) String , Number ) ; exit ( Number ) ; } LABEL_13 : usage ( Number ) ; }
__int64 __fastcall operand2sig ( const char * @@constchar@@ , __int64 @@int64@@ ) { int @@int@@ ; char * @@char@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; char * @@char@@ ; _BYTE * @@BYTE@@ ; void * @@void@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( ( unsigned int ) ( * @@constchar@@ - Number ) > Number ) { @@void@@ = ( void * ) xstrdup ( @@constchar@@ ) ; for ( @@BYTE@@ = @@void@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( strchr ( String , ( char ) * @@BYTE@@ ) ) * @@BYTE@@ -= Number ; } if ( ( unsigned int ) str2sig ( @@void@@ , & @@unsignedint@@ ) && ( * ( _BYTE * ) @@void@@ != Number || * ( ( _BYTE * ) @@void@@ + Number ) != Number || * ( ( _BYTE * ) @@void@@ + Number ) != Number || ( unsigned int ) str2sig ( ( char * ) @@void@@ + Number , & @@unsignedint@@ ) ) ) { @@unsignedint@@ = Number ; } free ( @@void@@ ) ; } else { * __errno_location ( ) = Number ; @@int64@@ = strtol ( @@constchar@@ , & @@char@@ , Number ) ; @@int@@ = @@int64@@ ; if ( @@constchar@@ == @@char@@ || * @@char@@ || * __errno_location ( ) || @@int64@@ != @@int@@ ) { @@int@@ = Number ; } else if ( ( char ) ( ( @@int@@ & Number ) + Number ) >> Number <= Number ) { @@int@@ = @@int@@ ; } else { @@int@@ = @@int@@ & Number ; } @@unsignedint@@ = @@int@@ ; } if ( ( @@unsignedint@@ & Number ) == Number && ! ( unsigned int ) sig2str ( @@unsignedint@@ , @@int64@@ ) ) { return @@unsignedint@@ ; } @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ , @@constchar@@ ) ; return Number ; }
__int64 __fastcall sysv_sum_file ( const char * @@constchar@@ , int @@int@@ ) { int @@int@@ ; int * @@int@@ ; __int64 @@int64@@ ; int * @@int@@ ; int * @@int@@ ; const char * @@constchar@@ ; bool @@bool@@ ; unsigned int @@unsignedint@@ ; unsigned int @@unsignedint@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; char @@char@@ [ Number ] ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = Number L ; @@unsignedint@@ = Number ; @@int@@ = strcmp ( @@constchar@@ , String ) ; @@bool@@ = @@int@@ == Number ; if ( ! @@int@@ ) { @@unsignedint@@ = Number ; have_read_stdin = Number ; goto LABEL_5 ; } @@unsignedint@@ = open ( @@constchar@@ , Number ) ; if ( @@unsignedint@@ == Number ) { @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , String , @@constchar@@ ) ; @@int64@@ = Number L ; } else { LABEL_5 : while ( Number ) { @@unsignedint64@@ = safe_read ( @@unsignedint@@ , @@char@@ , Number ) ; if ( ! @@unsignedint64@@ ) break ; if ( @@unsignedint64@@ == Number ) { @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , String , @@constchar@@ ) ; if ( ! @@bool@@ ) close ( @@unsignedint@@ ) ; return Number L ; } for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@unsignedint64@@ ; ++ @@unsignedint64@@ ) { @@unsignedint@@ += ( unsigned __int8 ) @@char@@ [ @@unsignedint64@@ ] ; } @@int64@@ += @@unsignedint64@@ ; } if ( ! @@bool@@ && close ( @@unsignedint@@ ) ) { @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , String , @@constchar@@ ) ; @@int64@@ = Number L ; } else { @@constchar@@ = ( const char * ) human_readable ( @@int64@@ , @@char@@ , Number L , Number L , Number L ) ; printf ( String , ( ( int ) ( HIWORD ( @@unsignedint@@ ) + ( unsigned __int16 ) @@unsignedint@@ ) >> Number ) + ( unsigned int ) ( unsigned __int16 ) ( HIWORD ( @@unsignedint@@ ) + @@unsignedint@@ ) , @@constchar@@ ) ; if ( @@int@@ ) printf ( String , @@constchar@@ ) ; putchar_unlocked ( Number ) ; @@int64@@ = Number L ; } } return @@int64@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
__int64 __fastcall human_options ( char * @@char@@ , int * @@int@@ , _QWORD * @@QWORD@@ ) { unsigned int @@unsignedint@@ ; @@unsignedint@@ = humblock ( @@char@@ , @@QWORD@@ , @@int@@ ) ; if ( ! * @@QWORD@@ ) { * @@QWORD@@ = default_block_size ( ) ; @@unsignedint@@ = Number ; } return @@unsignedint@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
__int64 __fastcall str2sig ( const char * @@constchar@@ , int * @@int@@ ) { __int64 @@int64@@ ; * @@int@@ = str2signum ( @@constchar@@ ) ; if ( * @@int@@ >= Number ) @@int64@@ = Number L ; else @@int64@@ = Number ; return @@int64@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
void * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@unsignedint64@@ , int @@int@@ ) { __int64 @@int64@@ ; if ( is_mul_ok ( @@int@@ , * @@unsignedint64@@ ) ) { * @@unsignedint64@@ *= @@int@@ ; @@int64@@ = Number L ; } else { * @@unsignedint64@@ = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_210028 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
void * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
void __fastcall argmatch_invalid ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { char * @@char@@ ; __int64 @@int64@@ ; void * @@void@@ ; char * @@char@@ ; if ( @@int64@@ == Number ) @@char@@ = gettext ( String ) ; else @@char@@ = gettext ( String ) ; @@char@@ = @@char@@ ; @@int64@@ = quote_n ( Number L , @@int64@@ ) ; @@void@@ = quotearg_n_style ( Number , Number , @@int64@@ ) ; error ( Number , Number , @@char@@ , @@void@@ , @@int64@@ ) ; }
__int64 __fastcall knuth_morris_pratt_unibyte ( _BYTE * @@BYTE@@ , char * @@char@@ , _QWORD * @@QWORD@@ ) { void * @@void@@ ; unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; char * @@char@@ ; _BYTE * @@BYTE@@ ; char @@char@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; size_t @@sizet@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@BYTE@@ = @@BYTE@@ ; @@char@@ = @@char@@ ; @@QWORD@@ = @@QWORD@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@sizet@@ = strlen ( @@char@@ ) ; if ( @@sizet@@ > Number ) { @@unsignedint64@@ = Number L ; } else if ( Number * @@sizet@@ > Number ) { @@unsignedint64@@ = mmalloca ( Number * @@sizet@@ ) ; } else { @@void@@ = alloca ( Number * ( ( Number * ( @@sizet@@ + Number ) + Number ) / Number ) ) ; @@unsignedint64@@ = Number * ( ( ( unsigned __int64 ) & @@QWORD@@ + Number ) >> Number ) + Number ; } @@unsignedint64@@ = @@unsignedint64@@ ; if ( ! @@unsignedint64@@ ) return Number L ; * ( _QWORD * ) ( @@unsignedint64@@ + Number ) = Number L ; @@int64@@ = Number L ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@sizet@@ ; ++ @@unsignedint64@@ ) { @@char@@ = @@char@@ [ @@unsignedint64@@ - Number ] ; while ( Number ) { if ( @@char@@ == @@char@@ [ @@int64@@ ] ) { ++ @@int64@@ ; * ( _QWORD * ) ( @@unsignedint64@@ + Number * @@unsignedint64@@ ) = @@unsignedint64@@ - @@int64@@ ; goto LABEL_15 ; } if ( ! @@int64@@ ) break ; @@int64@@ -= * ( _QWORD * ) ( Number * @@int64@@ + @@unsignedint64@@ ) ; } * ( _QWORD * ) ( @@unsignedint64@@ + Number * @@unsignedint64@@ ) = @@unsignedint64@@ ; LABEL_15 : ; } * @@QWORD@@ = Number L ; @@int64@@ = Number L ; @@BYTE@@ = @@BYTE@@ ; @@BYTE@@ = @@BYTE@@ ; while ( * @@BYTE@@ ) { if ( @@char@@ [ @@int64@@ ] == * @@BYTE@@ ) { ++ @@int64@@ ; ++ @@BYTE@@ ; if ( @@int64@@ == @@sizet@@ ) { * @@QWORD@@ = @@BYTE@@ ; break ; } } else if ( @@int64@@ ) { @@BYTE@@ += * ( _QWORD * ) ( Number * @@int64@@ + @@unsignedint64@@ ) ; @@int64@@ -= * ( _QWORD * ) ( Number * @@int64@@ + @@unsignedint64@@ ) ; } else { ++ @@BYTE@@ ; ++ @@BYTE@@ ; } } freea ( @@unsignedint64@@ ) ; return Number L ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return xmalloc ( @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall _xargmatch_internal ( __int64 @@int64@@ , const char * @@constchar@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ , void ( * @ @ VAR_600 @ @ void ( ) ( void ) @ @ argmatchexitfn ) ( void ) ) { __int64 @@int64@@ ; @@int64@@ = argmatch ( @@constchar@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; if ( @@int64@@ >= Number ) return @@int64@@ ; argmatch_invalid ( @@int64@@ , ( __int64 ) @@constchar@@ , @@int64@@ ) ; argmatch_valid ( @@int64@@ , @@int64@@ , @@sizet@@ ) ; @ @ VAR_600 @ @ void ( ) ( void ) @ @ argmatchexitfn ( ) ; return Number ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return xmalloc ( @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
void * __fastcall quote_n ( int @@int@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@int@@ , Number , @@int64@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
_BOOL8 __fastcall cycle_warning_required ( __int64 @@int64@@ , __int64 @@int64@@ ) { return ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number && ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) == Number || ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number && ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number && * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
int __fastcall send_sig ( __pid_t @@pidt@@ , int @@int@@ ) { sigs_to_ignore [ @@int@@ ] = Number ; return kill ( @@pidt@@ , @@int@@ ) ; }
__int64 __fastcall bkm_scale_by_power ( unsigned __int64 * @@unsignedint64@@ , int @@int@@ , int @@int@@ ) { unsigned int @@unsignedint@@ ; for ( @@unsignedint@@ = Number ; @@int@@ -- ; @@unsignedint@@ |= bkm_scale ( @@unsignedint64@@ , @@int@@ ) ) { ; } return @@unsignedint@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall set_cloexec_flag ( int @@int@@ , char @@char@@ , __int64 a3 , int @@int@@ , int @@int@@ , int @@int@@ ) { int @@int@@ ; int @@int@@ ; int @@int@@ ; unsigned int @@unsignedint@@ ; __int64 @@int64@@ ; int @@int@@ ; @@int@@ = rpl_fcntl ( @@int@@ , Number , Number , @@int@@ , @@int@@ , @@int@@ ) ; if ( @@int@@ < Number || ( ! @@char@@ ? ( @@unsignedint@@ = @@int@@ & Number ) : ( @@unsignedint@@ = @@int@@ | Number ) , @@int@@ != @@unsignedint@@ && ( unsigned int ) rpl_fcntl ( @@int@@ , Number , @@unsignedint@@ , @@int@@ , @@int@@ , @@int@@ ) == Number ) ) { @@int64@@ = Number ; } else { @@int64@@ = Number L ; } return @@int64@@ ; }
char * __fastcall proper_name_utf8 ( const char * @@constchar@@ , __int64 @@int64@@ ) { char * @@char@@ ; char * @@char@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; char * @@char@@ ; char * @@char@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; size_t @@sizet@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; @@char@@ = ( char * ) locale_charset ( ) ; @@char@@ = Number L ; @@char@@ = Number L ; @@int64@@ = Number L ; if ( ( unsigned int ) c_strcasecmp ( @@char@@ , String ) ) { @@char@@ = ( char * ) xstr_iconv ( @@int64@@ , String , @@char@@ ) ; @@int64@@ = ( __int64 ) @@char@@ ; @@sizet@@ = strlen ( @@char@@ ) ; @@char@@ = ( char * ) xmalloc ( @@sizet@@ + Number ) ; memcpy ( @@char@@ , @@char@@ , @@sizet@@ ) ; memcpy ( & @@char@@ [ @@sizet@@ ] , String , Number ) ; @@char@@ = ( char * ) xstr_iconv ( @@int64@@ , String , @@char@@ ) ; free ( @@char@@ ) ; if ( @@char@@ ) { if ( strchr ( @@char@@ , Number ) ) { free ( @@char@@ ) ; } else { @@char@@ = @@char@@ ; @@int64@@ = ( __int64 ) @@char@@ ; } } } else { @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; } if ( @@int64@@ ) { @@char@@ = ( char * ) @@int64@@ ; } else if ( @@int64@@ ) { @@char@@ = ( char * ) @@int64@@ ; } else { @@char@@ = ( char * ) @@constchar@@ ; } @@char@@ = @@char@@ ; if ( ! strcmp ( @@char@@ , @@constchar@@ ) ) { if ( @@char@@ && @@char@@ != @@char@@ ) free ( @@char@@ ) ; if ( @@char@@ && @@char@@ != @@char@@ ) free ( @@char@@ ) ; @@char@@ = @@char@@ ; } else if ( ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@char@@ , ( __int64 ) @@constchar@@ ) || @@int64@@ && ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@char@@ , @@int64@@ ) || @@int64@@ && ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@char@@ , @@int64@@ ) ) { if ( @@char@@ ) free ( @@char@@ ) ; if ( @@char@@ ) free ( @@char@@ ) ; @@char@@ = @@char@@ ; } else { @@sizet@@ = strlen ( @@char@@ ) ; @@sizet@@ = strlen ( @@char@@ ) ; @@char@@ = ( char * ) xmalloc ( @@sizet@@ + @@sizet@@ + Number ) ; sprintf ( @@char@@ , String , @@char@@ , @@char@@ ) ; if ( @@char@@ ) free ( @@char@@ ) ; if ( @@char@@ ) free ( @@char@@ ) ; @@char@@ = @@char@@ ; } return @@char@@ ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
__int64 __fastcall x2nrealloc ( __int64 @@int64@@ , unsigned __int64 * @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = * @@unsignedint64@@ ; if ( @@int64@@ ) { if ( @@unsignedint64@@ >= Number / @@unsignedint64@@ ) xalloc_die ( ) ; @@unsignedint64@@ += ( @@unsignedint64@@ + Number ) >> Number ; } else if ( ! @@unsignedint64@@ ) { @@unsignedint64@@ = ( Number / @@unsignedint64@@ == Number ) + Number / @@unsignedint64@@ ; } * @@unsignedint64@@ = @@unsignedint64@@ ; return xrealloc ( @@int64@@ , @@unsignedint64@@ * @@unsignedint64@@ ) ; }
__int64 __fastcall argmatch ( const char * @@constchar@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { __int64 @@int64@@ ; char @@char@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; size_t @@sizet@@ ; @@int64@@ = Number ; @@char@@ = Number ; @@sizet@@ = strlen ( @@constchar@@ ) ; for ( @@int64@@ = Number L ; * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; ++ @@int64@@ ) { if ( ! strncmp ( * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) , @@constchar@@ , @@sizet@@ ) ) { if ( @@sizet@@ == strlen ( * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) ) ) return @@int64@@ ; if ( @@int64@@ == Number ) { @@int64@@ = @@int64@@ ; } else if ( ! @@int64@@ || memcmp ( ( const void * ) ( @@sizet@@ * @@int64@@ + @@int64@@ ) , ( const void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) , @@sizet@@ ) ) { @@char@@ = Number ; } } } if ( @@char@@ ) @@int64@@ = Number ; else @@int64@@ = @@int64@@ ; return @@int64@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
void __fastcall free_cwd ( __int64 @@int64@@ ) { if ( * ( int * ) @@int64@@ >= Number ) close ( * ( _DWORD * ) @@int64@@ ) ; free ( * ( void * * ) ( @@int64@@ + Number ) ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
void * __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
char * __fastcall str_iconv ( char * @@char@@ , char * @@char@@ , char * @@char@@ ) { char * @@char@@ ; int @@int@@ ; int @@int@@ ; iconv_t @@iconvt@@ ; void * @@void@@ ; char * @@char@@ ; if ( * @@char@@ && ( unsigned int ) c_strcasecmp ( ( unsigned __int8 * ) @@char@@ , ( unsigned __int8 * ) @@char@@ ) ) { @@iconvt@@ = iconv_open ( @@char@@ , @@char@@ ) ; if ( @@iconvt@@ == ( iconv_t ) Number ) return Number L ; @@void@@ = str_cd_iconv ( @@char@@ , @@iconvt@@ ) ; if ( @@void@@ ) { if ( iconv_close ( @@iconvt@@ ) < Number ) { @@int@@ = * __errno_location ( ) ; free ( @@void@@ ) ; * __errno_location ( ) = @@int@@ ; return Number L ; } } else { @@int@@ = * __errno_location ( ) ; iconv_close ( @@iconvt@@ ) ; * __errno_location ( ) = @@int@@ ; } @@char@@ = ( char * ) @@void@@ ; } else { @@char@@ = strdup ( @@char@@ ) ; if ( ! @@char@@ ) * __errno_location ( ) = Number ; @@char@@ = @@char@@ ; } return @@char@@ ; }
__int64 __fastcall apply_time_suffix ( _QWORD * @@QWORD@@ , char @@char@@ ) { unsigned int @@unsignedint@@ ; unsigned int @@unsignedint@@ ; @@unsignedint@@ = Number ; if ( @@char@@ != Number ) { if ( @@char@@ > Number ) { if ( @@char@@ == Number ) goto LABEL_11 ; if ( @@char@@ != Number ) return Number L ; } else if ( @@char@@ ) { if ( @@char@@ != Number ) return Number L ; @@unsignedint@@ = Number ; goto LABEL_10 ; } return Number L ; } LABEL_10 : @@unsignedint@@ *= Number ; LABEL_11 : if ( @@unsignedint@@ > Number ) return Number L ; @@unsignedint@@ = Number * @@unsignedint@@ ; if ( * @@QWORD@@ > ( unsigned __int64 ) ( Number / @@unsignedint@@ ) ) return Number L ; * @@QWORD@@ *= @@unsignedint@@ ; return Number L ; }
__int64 __fastcall xnrealloc ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { if ( ! is_mul_ok ( @@unsignedint64@@ , @@unsignedint64@@ ) ) xalloc_die ( ) ; return xrealloc ( @@int64@@ , @@unsignedint64@@ * @@unsignedint64@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
__int64 __fastcall xstr_cd_iconv ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = str_cd_iconv ( @@int64@@ , @@int64@@ ) ; if ( ! @@int64@@ && * __errno_location ( ) == Number ) xalloc_die ( ) ; return @@int64@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ ) { return xmalloc ( @@int64@@ ) ; }
unsigned __int64 __fastcall mmalloca ( unsigned __int64 @@unsignedint64@@ ) { char * @@char@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@unsignedint64@@ + Number < @@unsignedint64@@ ) return Number L ; @@char@@ = ( char * ) malloc ( @@unsignedint64@@ + Number ) ; if ( ! @@char@@ ) return Number L ; @@unsignedint64@@ = ( unsigned __int64 ) ( @@char@@ + Number ) ; * ( _DWORD * ) ( @@unsignedint64@@ - Number ) = Number ; * ( _QWORD * ) ( @@unsignedint64@@ - Number ) = mmalloca_results [ @@unsignedint64@@ % Number ] ; mmalloca_results [ @@unsignedint64@@ % Number ] = @@unsignedint64@@ ; return @@unsignedint64@@ ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return xmalloc ( @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
const char * locale_charset ( ) { const char * @@constchar@@ ; char * @@char@@ ; char * @@char@@ ; @@constchar@@ = nl_langinfo ( Number ) ; if ( ! @@constchar@@ ) @@constchar@@ = ( const char * ) & unk_A16E ; for ( @@char@@ = ( char * ) get_charset_aliases ( ) ; * @@char@@ ; @@char@@ = & @@char@@ [ strlen ( @@char@@ ) + Number ] ) { if ( ! strcmp ( @@constchar@@ , @@char@@ ) || * @@char@@ == Number && ! @@char@@ [ Number ] ) { @@constchar@@ = & @@char@@ [ strlen ( @@char@@ ) + Number ] ; break ; } @@char@@ = & @@char@@ [ strlen ( @@char@@ ) + Number ] ; } if ( ! * @@constchar@@ ) @@constchar@@ = String ; return @@constchar@@ ; }
size_t __fastcall mbslen ( const char * @@constchar@@ ) { __int64 @@int64@@ ; char @@char4@@ [ Number ] ; int @@int@@ ; char @@char@@ ; const char * @@constchar@@ ; __int64 @@int64@@ ; char @@char@@ ; int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( __ctype_get_mb_cur_max ( ) <= Number ) return strlen ( @@constchar@@ ) ; @@int64@@ = Number L ; @@constchar@@ = @@constchar@@ ; @@char4@@ [ Number ] = Number ; memset ( & @@int@@ , Number , Number ) ; for ( @@char@@ = Number ; ; @@char@@ = Number ) { mbuiter_multi_next_1 ( ( __int64 ) @@char4@@ ) ; if ( @@char@@ == Number && ! @@int@@ ) break ; ++ @@int64@@ ; @@constchar@@ += @@int64@@ ; } return @@int64@@ ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 __fastcall c_tolower ( int @@int@@ ) { __int64 @@int64@@ ; if ( @@int@@ <= Number || @@int@@ > Number ) @@int64@@ = ( unsigned int ) @@int@@ ; else @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; return @@int64@@ ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 default_block_size ( ) { __int64 @@int64@@ ; if ( getenv ( String ) ) @@int64@@ = Number L ; else @@int64@@ = Number L ; return @@int64@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return xmalloc ( @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_20C038 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall c_toupper ( int @@int@@ ) { __int64 @@int64@@ ; if ( @@int@@ <= Number || @@int@@ > Number ) @@int64@@ = ( unsigned int ) @@int@@ ; else @@int64@@ = ( unsigned int ) ( @@int@@ - Number ) ; return @@int64@@ ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall humblock ( char * @@char@@ , _QWORD * @@QWORD@@ , int * @@int@@ ) { char * @@char@@ ; int @@int@@ ; int @@int@@ ; unsigned int @@unsignedint@@ ; __int64 @@int642@@ [ Number ] ; @@char@@ = @@char@@ ; @@int642@@ [ Number ] = __readfsqword ( Number ) ; @@int@@ = Number ; if ( @@char@@ || ( @@char@@ = getenv ( String ) ) != Number L || ( @@char@@ = getenv ( String ) ) != Number L ) { if ( * @@char@@ == Number ) { @@int@@ = Number ; ++ @@char@@ ; } @@int@@ = argmatch ( @@char@@ , & block_size_args , block_size_opts , Number L ) ; if ( @@int@@ < Number ) { @@unsignedint@@ = xstrtoumax ( @@char@@ , @@int642@@ , Number L , @@QWORD@@ , String ) ; if ( @@unsignedint@@ ) { * @@int@@ = Number ; return @@unsignedint@@ ; } while ( * @@char@@ <= Number || * @@char@@ > Number ) { if ( @@char@@ == ( char * ) @@int642@@ [ Number ] ) { @@int@@ |= Number ; if ( * ( _BYTE * ) ( @@int642@@ [ Number ] - Number ) == Number ) @@int@@ |= Number ; if ( * ( _BYTE * ) ( @@int642@@ [ Number ] - Number ) != Number || * ( _BYTE * ) ( @@int642@@ [ Number ] - Number ) == Number ) @@int@@ |= Number ; break ; } ++ @@char@@ ; } } else { @@int@@ |= block_size_opts [ @@int@@ ] ; * @@QWORD@@ = Number L ; } } else { * @@QWORD@@ = default_block_size ( ) ; } * @@int@@ = @@int@@ ; return Number L ; }
int __fastcall out_uint_o ( const char * @@constchar@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { strcpy ( ( char * ) & @@constchar@@ [ @@int64@@ ] , String ) ; return printf ( @@constchar@@ , @@int64@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
void __fastcall freea ( unsigned __int64 @@unsignedint64@@ ) { _QWORD * @@QWORD@@ ; if ( @@unsignedint64@@ && * ( _DWORD * ) ( @@unsignedint64@@ - Number ) == Number ) { for ( @@QWORD@@ = & mmalloca_results [ @@unsignedint64@@ % Number ] ; * @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) ( * @@QWORD@@ - Number L ) ) { if ( @@unsignedint64@@ == * @@QWORD@@ ) { * @@QWORD@@ = * ( _QWORD * ) ( @@unsignedint64@@ - Number ) ; free ( ( void * ) ( @@unsignedint64@@ - Number ) ) ; return ; } } } }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
char * __fastcall areadlink_with_size ( const char * @@constchar@@ , unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; char * @@char@@ ; int @@int@@ ; size_t @@sizet@@ ; char * @@char@@ ; ssize_t @@ssizet@@ ; if ( @@unsignedint64@@ >= Number ) @@int64@@ = Number L ; else @@int64@@ = @@unsignedint64@@ + Number ; @@sizet@@ = @@int64@@ ; LABEL_5 : for ( @@char@@ = ( char * ) malloc ( @@sizet@@ ) ; ; @@char@@ = ( char * ) malloc ( Number ) ) { @@char@@ = @@char@@ ; if ( ! @@char@@ ) return Number L ; @@ssizet@@ = readlink ( @@constchar@@ , @@char@@ , @@sizet@@ ) ; if ( @@ssizet@@ < Number && * __errno_location ( ) != Number ) { @@int@@ = * __errno_location ( ) ; free ( @@char@@ ) ; * __errno_location ( ) = @@int@@ ; return Number L ; } if ( @@ssizet@@ < @@sizet@@ ) { @@char@@ [ @@ssizet@@ ] = Number ; return @@char@@ ; } free ( @@char@@ ) ; if ( @@sizet@@ <= Number ) { @@sizet@@ *= Number L ; goto LABEL_5 ; } if ( @@sizet@@ > Number ) break ; @@sizet@@ = Number ; } * __errno_location ( ) = Number ; return Number L ; }
void * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
bool __fastcall is_basic_2 ( unsigned __int8 @@unsignedint8@@ ) { return ( ( * ( ( _DWORD * ) & is_basic_table + ( @@unsignedint8@@ >> Number ) ) >> ( @@unsignedint8@@ & Number ) ) & Number ) != Number ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
char * __fastcall file_type ( __int64 @@int64@@ ) { char * @@char@@ ; switch ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) { case Number : if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) @@char@@ = gettext ( String ) ; else @@char@@ = gettext ( String ) ; break ; case Number : @@char@@ = gettext ( String ) ; break ; case Number : @@char@@ = gettext ( String ) ; break ; case Number : @@char@@ = gettext ( String ) ; break ; case Number : @@char@@ = gettext ( String ) ; break ; case Number : @@char@@ = gettext ( String ) ; break ; case Number : @@char@@ = gettext ( String ) ; break ; default : @@char@@ = gettext ( String ) ; break ; } return @@char@@ ; }
void * __fastcall mdir_name ( _BYTE * @@BYTE@@ ) { _BYTE * @@BYTE@@ ; void * @@void@@ ; @@BYTE@@ = dir_len ( @@BYTE@@ ) ; @@void@@ = malloc ( ( size_t ) & @@BYTE@@ [ ( @@BYTE@@ == Number L ) + Number ] ) ; if ( ! @@void@@ ) return Number L ; memcpy ( @@void@@ , @@BYTE@@ , ( size_t ) @@BYTE@@ ) ; if ( ! @@BYTE@@ ) { @@BYTE@@ = ( _BYTE * ) ( & dword_0 + Number ) ; * ( _BYTE * ) @@void@@ = Number ; } @@BYTE@@ [ ( _QWORD ) @@void@@ ] = Number ; return @@void@@ ; }
void * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
void * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@unsignedint64@@ , int @@int@@ ) { __int64 @@int64@@ ; if ( is_mul_ok ( @@int@@ , * @@unsignedint64@@ ) ) { * @@unsignedint64@@ *= @@int@@ ; @@int64@@ = Number L ; } else { * @@unsignedint64@@ = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
int __fastcall argmatch_valid ( __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { char * @@char@@ ; __int64 @@int64@@ ; void * @@void@@ ; @@void@@ = Number L ; @@char@@ = gettext ( String ) ; fprintf ( stderr , @@char@@ ) ; for ( @@int64@@ = Number L ; * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; ++ @@int64@@ ) { if ( @@int64@@ && ! memcmp ( @@void@@ , ( const void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) , @@sizet@@ ) ) { fprintf ( stderr , String , * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) ) ; } else { fprintf ( stderr , String , * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) ) ; @@void@@ = ( void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) ; } } return putc_unlocked ( Number , stderr ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_2060C8 ; @@int648@@ [ Number ] = qword_2060D0 ; @@int648@@ [ Number ] = qword_2060D8 ; @@int648@@ [ Number ] = qword_2060E0 ; @@int648@@ [ Number ] = qword_2060E8 ; @@int648@@ [ Number ] = qword_2060F0 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_206028 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
bool __fastcall is_basic ( unsigned __int8 @@unsignedint8@@ ) { return ( ( * ( ( _DWORD * ) & is_basic_table + ( @@unsignedint8@@ >> Number ) ) >> ( @@unsignedint8@@ & Number ) ) & Number ) != Number ; }
_BYTE * __fastcall dir_len ( _BYTE * @@BYTE@@ ) { _BYTE * @@BYTE@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = * @@BYTE@@ == Number ; for ( @@BYTE@@ = ( _BYTE * ) ( last_component ( @@BYTE@@ ) - @@BYTE@@ ) ; @@unsignedint64@@ < ( unsigned __int64 ) @@BYTE@@ && @@BYTE@@ [ ( _QWORD ) ( @@BYTE@@ - Number ) ] == Number ; -- @@BYTE@@ ) { ; } return @@BYTE@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall strnlen1 ( const void * @@constvoid@@ , size_t @@sizet@@ ) { __int64 @@int64@@ ; _BYTE * @@BYTE@@ ; @@BYTE@@ = memchr ( @@constvoid@@ , Number , @@sizet@@ ) ; if ( @@BYTE@@ ) @@int64@@ = @@BYTE@@ - ( _BYTE * ) @@constvoid@@ + Number ; else @@int64@@ = @@sizet@@ ; return @@int64@@ ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
bool __fastcall is_basic_0 ( unsigned __int8 @@unsignedint8@@ ) { return ( ( * ( ( _DWORD * ) & is_basic_table + ( @@unsignedint8@@ >> Number ) ) >> ( @@unsignedint8@@ & Number ) ) & Number ) != Number ; }
__int64 __fastcall memcpy_lowcase ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { while ( @@int64@@ -- ) * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) = tolower ( * ( unsigned __int8 * ) ( @@int64@@ + @@int64@@ ) ) ; return @@int64@@ ; }
__int64 __fastcall xstr_iconv ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = str_iconv ( @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( ! @@int64@@ && * __errno_location ( ) == Number ) xalloc_die ( ) ; return @@int64@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
__int64 __fastcall nstrftime ( char * @@char@@ , __int64 @@int64@@ , const char * @@constchar@@ , __int64 @@int64@@ , int @@int@@ , int @@int@@ ) { return strftime_case_ ( Number , @@char@@ , @@int64@@ , ( char * ) @@constchar@@ , @@int64@@ , @@int@@ , @@int@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_206028 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 __fastcall set_other_indent ( char @@char@@ ) { __int64 @@int64@@ ; if ( split ) { @@int64@@ = ( unsigned int ) first_indent ; other_indent = first_indent ; } else if ( crown ) { if ( @@char@@ ) @@int64@@ = ( unsigned int ) in_column ; else @@int64@@ = ( unsigned int ) first_indent ; other_indent = @@int64@@ ; } else if ( tagged ) { if ( ! @@char@@ || in_column == first_indent ) { @@int64@@ = ( unsigned int ) first_indent ; if ( other_indent == first_indent ) { if ( first_indent ) @@int64@@ = Number L ; else @@int64@@ = Number L ; other_indent = @@int64@@ ; } } else { @@int64@@ = ( unsigned int ) in_column ; other_indent = in_column ; } } else { @@int64@@ = ( unsigned int ) first_indent ; other_indent = first_indent ; } return @@int64@@ ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
int __fastcall print_statfs ( const char * @@constchar@@ , __int64 @@int64@@ , char @@char@@ , __int64 @@int64@@ , __int64 * @@int64@@ ) { int @@int@@ ; const char * @@constchar@@ ; int @@int@@ ; __int64 @@int64@@ ; switch ( @@char@@ ) { case String : @@int@@ = out_file_context ( @@int64@@ , @@constchar@@ , @@int64@@ ) ; break ; case String : case String : @@int@@ = out_uint ( @@constchar@@ , @@int64@@ , @@int64@@ [ Number ] ) ; break ; case String : @@constchar@@ = human_fstype ( @@int64@@ ) ; @@int@@ = out_string ( @@constchar@@ , @@int64@@ , ( __int64 ) @@constchar@@ ) ; break ; case String : @@int@@ = out_int ( @@constchar@@ , @@int64@@ , @@int64@@ [ Number ] ) ; break ; case String : @@int@@ = out_int ( @@constchar@@ , @@int64@@ , @@int64@@ [ Number ] ) ; break ; case String : @@int@@ = out_uint ( @@constchar@@ , @@int64@@ , @@int64@@ [ Number ] ) ; break ; case String : @@int@@ = out_int ( @@constchar@@ , @@int64@@ , @@int64@@ [ Number ] ) ; break ; case String : @@int@@ = out_int ( @@constchar@@ , @@int64@@ , @@int64@@ [ Number ] ) ; break ; case String : @@int64@@ = Number L ; for ( @@int@@ = Number ; @@int@@ < Number && ( unsigned __int64 ) ( Number L * @@int@@ ) <= Number ; ++ @@int@@ ) { @@int64@@ |= ( unsigned __int64 ) * ( ( unsigned int * ) @@int64@@ + Number - @@int@@ + Number ) << ( Number * ( unsigned __int8 ) @@int@@ ) ; } @@int@@ = out_uint_x ( @@constchar@@ , @@int64@@ , @@int64@@ ) ; break ; case String : @@int@@ = out_uint ( @@constchar@@ , @@int64@@ , @@int64@@ [ Number ] ) ; break ; case String : @@int@@ = out_string ( @@constchar@@ , @@int64@@ , @@int64@@ ) ; break ; case String : @@int@@ = out_uint_x ( @@constchar@@ , @@int64@@ , * @@int64@@ ) ; break ; default : @@int@@ = fputc_unlocked ( Number , stdout ) ; break ; } return @@int@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall get_prefix ( FILE * @@FILE@@ ) { unsigned int @@unsignedint@@ ; int @@int@@ ; unsigned int @@unsignedint@@ ; char * @@char@@ ; in_column = Number ; @@unsignedint@@ = getc_unlocked ( @@FILE@@ ) ; @@unsignedint@@ = get_space ( @@FILE@@ , @@unsignedint@@ ) ; if ( prefix_length ) { next_prefix_indent = in_column ; for ( @@char@@ = prefix ; * @@char@@ ; ++ @@char@@ ) { if ( @@unsignedint@@ != ( unsigned __int8 ) * @@char@@ ) return @@unsignedint@@ ; ++ in_column ; @@unsignedint@@ = getc_unlocked ( @@FILE@@ ) ; } @@unsignedint@@ = get_space ( @@FILE@@ , @@unsignedint@@ ) ; } else { @@int@@ = prefix_lead_space ; if ( in_column <= prefix_lead_space ) @@int@@ = in_column ; next_prefix_indent = @@int@@ ; } return @@unsignedint@@ ; }
_BYTE * __fastcall filemodestring ( __int64 @@int64@@ , _BYTE * @@BYTE@@ ) { return strmode ( * ( _DWORD * ) ( @@int64@@ + Number ) , @@BYTE@@ ) ; }
_BYTE * __fastcall strmode ( __int16 @@int16@@ , _BYTE * @@BYTE@@ ) { char @@char@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; _BYTE * @@BYTE@@ ; * @@BYTE@@ = ftypelet ( @@int16@@ ) ; if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) { if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; } else if ( ( @@int16@@ & Number ) != Number ) { @@char@@ = Number ; } else { @@char@@ = Number ; } @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) { if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; } else if ( ( @@int16@@ & Number ) != Number ) { @@char@@ = Number ; } else { @@char@@ = Number ; } @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) { if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; } else if ( ( @@int16@@ & Number ) != Number ) { @@char@@ = Number ; } else { @@char@@ = Number ; } @@BYTE@@ [ Number ] = @@char@@ ; @@BYTE@@ [ Number ] = Number ; @@BYTE@@ = @@BYTE@@ + Number ; @@BYTE@@ [ Number ] = Number ; return @@BYTE@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall imaxtostr ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ + Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = Number ; if ( @@int64@@ >= Number ) { do { * ( _BYTE * ) -- @@int64@@ = ( char ) @@int64@@ % Number + Number ; @@int64@@ /= Number L ; } while ( @@int64@@ ) ; } else { do { * ( _BYTE * ) -- @@int64@@ = Number - ( char ) @@int64@@ % Number ; @@int64@@ /= Number L ; } while ( @@int64@@ ) ; * ( _BYTE * ) -- @@int64@@ = Number ; } return @@int64@@ ; }
__int64 fmt_paragraph ( ) { int @@int@@ ; __int64 @@int64@@ ; int @@int@@ ; int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; * ( _QWORD * ) ( word_limit + Number ) = Number L ; @@int@@ = * ( _DWORD * ) ( word_limit + Number ) ; * ( _DWORD * ) ( word_limit + Number ) = max_width ; for ( @@unsignedint64@@ = word_limit - Number ; @@unsignedint64@@ >= ( unsigned __int64 ) & unused_word_type ; @@unsignedint64@@ -= Number L ) { @@int64@@ = Number ; if ( ( _UNKNOWN * ) @@unsignedint64@@ == & unused_word_type ) @@int@@ = first_indent ; else @@int@@ = other_indent ; @@unsignedint64@@ = @@unsignedint64@@ ; @@int@@ = * ( _DWORD * ) ( @@unsignedint64@@ + Number ) + @@int@@ ; do { @@unsignedint64@@ += Number L ; @@int64@@ = line_cost ( @@unsignedint64@@ , ( unsigned int ) @@int@@ ) + * ( _QWORD * ) ( @@unsignedint64@@ + Number ) ; if ( ( _UNKNOWN * ) @@unsignedint64@@ == & unused_word_type && last_line_length > Number ) @@int64@@ += Number * ( @@int@@ - last_line_length ) * ( __int64 ) ( Number * ( @@int@@ - last_line_length ) ) / Number ; if ( @@int64@@ < @@int64@@ ) { @@int64@@ = @@int64@@ ; * ( _QWORD * ) ( @@unsignedint64@@ + Number ) = @@unsignedint64@@ ; * ( _DWORD * ) ( @@unsignedint64@@ + Number ) = @@int@@ ; } if ( @@unsignedint64@@ == word_limit ) break ; @@int@@ += * ( _DWORD * ) ( @@unsignedint64@@ - Number + Number ) + * ( _DWORD * ) ( @@unsignedint64@@ + Number ) ; } while ( @@int@@ < max_width ) ; * ( _QWORD * ) ( @@unsignedint64@@ + Number ) = @@int64@@ + base_cost ( @@unsignedint64@@ ) ; } @@int64@@ = word_limit ; * ( _DWORD * ) ( word_limit + Number ) = @@int@@ ; return @@int64@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
__int64 __fastcall get_stat_atime ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_20C3E8 ; @@int648@@ [ Number ] = qword_20C3F0 ; @@int648@@ [ Number ] = qword_20C3F8 ; @@int648@@ [ Number ] = qword_20C400 ; @@int648@@ [ Number ] = qword_20C408 ; @@int648@@ [ Number ] = qword_20C410 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
__int64 __fastcall get_paragraph ( __int64 @@int64@@ ) { char @@char@@ ; __int64 @@int64@@ ; unsigned int @@unsignedint@@ ; unsigned int @@unsignedint@@ ; last_line_length = Number ; for ( @@unsignedint@@ = next_char ; @@unsignedint@@ == Number || @@unsignedint@@ == Number || next_prefix_indent < prefix_lead_space || prefix_full_length + next_prefix_indent > in_column ; @@unsignedint@@ = get_prefix ( @@int64@@ ) ) { if ( ( unsigned int ) copy_rest ( @@int64@@ , @@unsignedint@@ ) == Number ) { next_char = Number ; return Number L ; } putchar_unlocked ( Number ) ; } prefix_indent = next_prefix_indent ; first_indent = in_column ; wptr = ( __int64 ) & parabuf ; word_limit = ( __int64 ) & unused_word_type ; @@unsignedint@@ = get_line ( @@int64@@ , @@unsignedint@@ ) ; @@char@@ = same_para ( @@unsignedint@@ ) ; set_other_indent ( @@char@@ ) ; if ( ! split ) { if ( crown ) { if ( ( unsigned __int8 ) same_para ( @@unsignedint@@ ) ) { do @@unsignedint@@ = get_line ( @@int64@@ , @@unsignedint@@ ) ; while ( ( unsigned __int8 ) same_para ( @@unsignedint@@ ) && in_column == other_indent ) ; } } else if ( tagged ) { if ( ( unsigned __int8 ) same_para ( @@unsignedint@@ ) && in_column != first_indent ) { do @@unsignedint@@ = get_line ( @@int64@@ , @@unsignedint@@ ) ; while ( ( unsigned __int8 ) same_para ( @@unsignedint@@ ) && in_column == other_indent ) ; } } else { while ( ( unsigned __int8 ) same_para ( @@unsignedint@@ ) && in_column == other_indent ) @@unsignedint@@ = get_line ( @@int64@@ , @@unsignedint@@ ) ; } } @@int64@@ = word_limit - Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = * ( _BYTE * ) ( word_limit - Number + Number ) | Number ; * ( _BYTE * ) ( word_limit - Number + Number ) = ( Number * ( ( * ( _BYTE * ) ( @@int64@@ + Number ) & Number ) != Number ) ) | * ( _BYTE * ) ( word_limit - Number + Number ) & Number ; next_char = @@unsignedint@@ ; return Number L ; }
__int64 __fastcall get_stat_mtime ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
bool __fastcall is_basic_1 ( unsigned __int8 @@unsignedint8@@ ) { return ( ( * ( ( _DWORD * ) & is_basic_table + ( @@unsignedint8@@ >> Number ) ) >> ( @@unsignedint8@@ & Number ) ) & Number ) != Number ; }
void * __fastcall human_access ( __int64 @@int64@@ ) { filemodestring ( @@int64@@ , & modebuf_5918 ) ; byte_20D0FA = Number ; return & modebuf_5918 ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
int __fastcall out_string ( const char * @@constchar@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { * ( _WORD * ) & @@constchar@@ [ @@int64@@ ] = Number ; return printf ( @@constchar@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
int __fastcall out_int ( const char * @@constchar@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { strcpy ( ( char * ) & @@constchar@@ [ @@int64@@ ] , String ) ; return printf ( @@constchar@@ , @@int64@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return xmalloc ( @@int64@@ , @@int64@@ , @@int64@@ ) ; }
int __fastcall out_uint_x ( const char * @@constchar@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { strcpy ( ( char * ) & @@constchar@@ [ @@int64@@ ] , String ) ; return printf ( @@constchar@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_20D168 ; @@int648@@ [ Number ] = qword_20D170 ; @@int648@@ [ Number ] = qword_20D178 ; @@int648@@ [ Number ] = qword_20D180 ; @@int648@@ [ Number ] = qword_20D188 ; @@int648@@ [ Number ] = qword_20D190 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
__int64 __fastcall mem_cd_iconv ( char * @@char@@ , size_t @@sizet@@ , void * @@void@@ , void * * @@void@@ , size_t * @@sizet@@ ) { int @@int@@ ; char * @@char@@ ; size_t @@sizet@@ ; char * @@char@@ ; size_t @@sizet@@ ; void * @@void@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; char @@char@@ $D1F1B2789FC85C59BE59CF61C76BFA1E [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; iconv ( @@void@@ , Number L , Number L , Number L , Number L ) ; @@sizet@@ = Number L ; @@char@@ = @@char@@ ; @@sizet@@ = @@sizet@@ ; while ( @@sizet@@ ) { @@char@@ = @@char@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; @@sizet@@ = Number L ; @@sizet@@ = iconv ( @@void@@ , & @@char@@ , & @@sizet@@ , & @@char@@ , & @@sizet@@ ) ; if ( @@sizet@@ == Number && * __errno_location ( ) != Number ) { if ( * __errno_location ( ) != Number ) return Number ; break ; } @@sizet@@ += @@char@@ - @@char@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; } @@char@@ = @@char@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; @@sizet@@ = Number L ; @@sizet@@ = iconv ( @@void@@ , Number L , Number L , & @@char@@ , & @@sizet@@ ) ; if ( @@sizet@@ == Number ) return Number ; @@sizet@@ += @@char@@ - @@char@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; @@sizet@@ = @@sizet@@ ; if ( ! @@sizet@@ ) { * @@sizet@@ = Number L ; return Number L ; } if ( * @@void@@ && @@sizet@@ <= * @@sizet@@ ) { @@void@@ = * @@void@@ ; } else { @@void@@ = malloc ( @@sizet@@ ) ; if ( ! @@void@@ ) { * __errno_location ( ) = Number ; return Number ; } } iconv ( @@void@@ , Number L , Number L , Number L , Number L ) ; @@char@@ = @@char@@ ; @@sizet@@ = @@sizet@@ ; @@char@@ = ( char * ) @@void@@ ; @@sizet@@ = @@sizet@@ ; while ( @@sizet@@ ) { @@sizet@@ = iconv ( @@void@@ , & @@char@@ , & @@sizet@@ , & @@char@@ , & @@sizet@@ ) ; if ( @@sizet@@ == Number ) { if ( * __errno_location ( ) != Number ) goto LABEL_26 ; break ; } } @@sizet@@ = iconv ( @@void@@ , Number L , Number L , & @@char@@ , & @@sizet@@ ) ; if ( @@sizet@@ != Number ) { if ( @@sizet@@ ) abort ( ) ; * @@void@@ = @@void@@ ; * @@sizet@@ = @@sizet@@ ; return Number L ; } LABEL_26 : if ( @@void@@ != * @@void@@ ) { @@int@@ = * __errno_location ( ) ; free ( @@void@@ ) ; * __errno_location ( ) = @@int@@ ; } return Number ; }
int __cdecl __noreturn main ( int @@int@@ , const char * * @@constchar@@ , const char * * @@constchar@@ ) { char * @@char@@ ; char * @@char@@ ; unsigned __int8 @@unsignedint8@@ ; char @@char@@ ; char @@char@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; const char * @@constchar@@ ; @@char@@ = Number ; @@char@@ = Number ; @@constchar@@ = Number L ; @@bool@@ = Number ; set_program_name ( * @@constchar@@ , @@constchar@@ , @@constchar@@ ) ; setlocale ( Number , & locale ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; while ( Number ) { while ( Number ) { while ( Number ) { @@int@@ = getopt_long ( @@int@@ , ( char * const * ) @@constchar@@ , String , & long_options , Number L ) ; if ( @@int@@ == Number ) { if ( @@int@@ == optind ) { @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ ) ; usage ( Number ) ; } for ( @@int@@ = optind ; @@int@@ < @@int@@ ; ++ @@int@@ ) { if ( @@char@@ ) @@unsignedint8@@ = do_statfs ( @@constchar@@ [ @@int@@ ] , @@char@@ , @@constchar@@ ) ; else @@unsignedint8@@ = do_stat ( ( char * ) @@constchar@@ [ @@int@@ ] , @@char@@ , @@constchar@@ ) ; @@bool@@ = ( @@bool@@ & @@unsignedint8@@ ) != Number ; } exit ( ! @@bool@@ ) ; } if ( @@int@@ != Number ) break ; @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ ) ; } if ( @@int@@ <= Number ) break ; if ( @@int@@ == Number ) { @@char@@ = Number ; } else if ( @@int@@ > Number ) { if ( @@int@@ == Number ) { @@char@@ = Number ; } else { if ( @@int@@ != Number ) goto LABEL_22 ; @@constchar@@ = ( const char * ) optarg ; interpret_backslash_escapes = Number ; trailing_delim = ( char * ) & locale ; } } else { if ( @@int@@ != Number ) goto LABEL_22 ; @@constchar@@ = ( const char * ) optarg ; interpret_backslash_escapes = Number ; trailing_delim = String ; } } if ( @@int@@ == Number ) usage ( Number ) ; if ( @@int@@ != Number ) { if ( @@int@@ == Number ) { version_etc ( ( _DWORD ) stdout , ( unsigned int ) String , ( unsigned int ) String , ( _DWORD ) Version , ( unsigned int ) String , Number , ( char ) @@constchar@@ ) ; exit ( Number ) ; } LABEL_22 : usage ( Number ) ; } follow_links = Number ; } }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
__int64 __fastcall ftypelet ( __int16 @@int16@@ ) { switch ( @@int16@@ & Number ) { case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; } return Number L ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
char * * __fastcall check_punctuation ( unsigned __int64 * @@unsignedint64@@ ) { bool @@bool@@ ; char * * @@char@@ ; unsigned __int8 @@unsignedint8@@ ; char * @@char@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = * @@unsignedint64@@ ; @@char@@ = ( char * ) ( * ( ( int * ) @@unsignedint64@@ + Number ) - Number L + * @@unsignedint64@@ ) ; @@unsignedint8@@ = * @@char@@ ; * ( ( _BYTE * ) @@unsignedint64@@ + Number ) = ( strchr ( String , * ( char * ) * @@unsignedint64@@ ) != Number L ) | @@unsignedint64@@ [ Number ] & Number ; * ( ( _BYTE * ) @@unsignedint64@@ + Number ) = ( Number * ( ( ( * __ctype_b_loc ( ) ) [ @@unsignedint8@@ ] & Number ) != Number ) ) | @@unsignedint64@@ [ Number ] & Number ; while ( @@unsignedint64@@ < ( unsigned __int64 ) @@char@@ && strchr ( String , * @@char@@ ) ) -- @@char@@ ; @@bool@@ = strchr ( String , * @@char@@ ) != Number L ; @@char@@ = ( char * * ) @@unsignedint64@@ ; * ( ( _BYTE * ) @@unsignedint64@@ + Number ) = ( Number * @@bool@@ ) | @@unsignedint64@@ [ Number ] & Number ; return @@char@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
__int64 __fastcall put_word ( char * * @@char@@ ) { char * @@char@@ ; int @@int@@ ; __int64 @@int64@@ ; int @@int@@ ; char * @@char@@ ; @@char@@ = * @@char@@ ; for ( @@int@@ = * ( ( _DWORD * ) @@char@@ + Number ) ; @@int@@ ; -- @@int@@ ) { @@char@@ = @@char@@ ++ ; putchar_unlocked ( * @@char@@ ) ; } @@int@@ = * ( ( _DWORD * ) @@char@@ + Number ) ; @@int64@@ = ( unsigned int ) ( @@int@@ + out_column ) ; out_column += @@int@@ ; return @@int64@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return xmalloc ( @@int64@@ , @@int64@@ , @@int64@@ ) ; }
int __cdecl __noreturn main ( int @@int@@ , const char * * @@constchar@@ , const char * * @@constchar@@ ) { char * @@char@@ ; int * @@int@@ ; unsigned __int8 @@unsignedint8@@ ; int @@int@@ ; set_program_name ( * @@constchar@@ , @@constchar@@ , @@constchar@@ ) ; setlocale ( Number , & locale ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; append = Number ; ignore_interrupts = Number ; while ( Number ) { @@int@@ = getopt_long ( @@int@@ , ( char * const * ) @@constchar@@ , String , & long_options , Number L ) ; if ( @@int@@ == Number ) { if ( ignore_interrupts ) signal ( Number , ( __sighandler_t ) ( ( char * ) & dword_0 + Number ) ) ; @@unsignedint8@@ = tee_files ( ( unsigned int ) ( @@int@@ - optind ) , & @@constchar@@ [ optind ] ) ; if ( close ( Number ) ) { @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ ) ; } exit ( @@unsignedint8@@ ^ Number ) ; } if ( @@int@@ == Number ) usage ( Number ) ; if ( @@int@@ <= Number ) break ; if ( @@int@@ == Number ) { append = Number ; } else { if ( @@int@@ != Number ) goto LABEL_13 ; ignore_interrupts = Number ; } } if ( @@int@@ == Number ) { version_etc ( ( _DWORD ) stdout , ( unsigned int ) String , ( unsigned int ) String , ( _DWORD ) Version , ( unsigned int ) String , ( unsigned int ) String , String , Number L ) ; exit ( Number ) ; } LABEL_13 : usage ( Number ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
void __fastcall __noreturn run_shell ( const char * @@constchar@@ , char * @@char@@ , const void * @@constvoid@@ , __int64 @@int64@@ ) { int @@int@@ ; size_t @@sizet@@ ; __int64 @@int64@@ ; int @@int@@ ; int * @@int@@ ; int @@int@@ ; __int64 @@int64@@ ; char * * @@char@@ ; char * @@char@@ ; char * @@char@@ ; if ( @@char@@ ) @@int@@ = Number ; else @@int@@ = Number ; @@char@@ = ( char * * ) xnmalloc ( @@int@@ + ( unsigned __int8 ) fast_startup + Number + @@int64@@ + Number , Number L ) ; @@int64@@ = Number L ; if ( simulate_login ) { @@char@@ = ( char * ) last_component ( @@constchar@@ ) ; @@sizet@@ = strlen ( @@char@@ ) ; @@char@@ = ( char * ) xmalloc ( @@sizet@@ + Number ) ; * @@char@@ = Number ; strcpy ( @@char@@ + Number , @@char@@ ) ; * @@char@@ = @@char@@ ; } else { * @@char@@ = ( char * ) last_component ( @@constchar@@ ) ; } if ( fast_startup ) { @@int64@@ = Number L ; @@char@@ [ Number ] = String ; } if ( @@char@@ ) { @@char@@ [ @@int64@@ ] = String ; @@int64@@ = @@int64@@ + Number ; @@int64@@ += Number L ; @@char@@ [ @@int64@@ ] = @@char@@ ; } memcpy ( & @@char@@ [ @@int64@@ ] , @@constvoid@@ , Number * @@int64@@ ) ; ( & @@char@@ [ @@int64@@ ] ) [ @@int64@@ ] = Number L ; execv ( @@constchar@@ , @@char@@ ) ; if ( * __errno_location ( ) == Number ) @@int@@ = Number ; else @@int@@ = Number ; @@int@@ = @@int@@ ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , String , @@constchar@@ ) ; exit ( @@int@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_2070A8 ; @@int648@@ [ Number ] = qword_2070B0 ; @@int648@@ [ Number ] = qword_2070B8 ; @@int648@@ [ Number ] = qword_2070C0 ; @@int648@@ [ Number ] = qword_2070C8 ; @@int648@@ [ Number ] = qword_2070D0 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_20D038 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_213108 ; @@int648@@ [ Number ] = qword_213110 ; @@int648@@ [ Number ] = qword_213118 ; @@int648@@ [ Number ] = qword_213120 ; @@int648@@ [ Number ] = qword_213128 ; @@int648@@ [ Number ] = qword_213130 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_2080C8 ; @@int648@@ [ Number ] = qword_2080D0 ; @@int648@@ [ Number ] = qword_2080D8 ; @@int648@@ [ Number ] = qword_2080E0 ; @@int648@@ [ Number ] = qword_2080E8 ; @@int648@@ [ Number ] = qword_2080F0 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
void __fastcall change_identity ( __int64 @@int64@@ ) { char * @@char@@ ; int * @@int@@ ; char * @@char@@ ; int * @@int@@ ; char * @@char@@ ; int * @@int@@ ; * __errno_location ( ) = Number ; if ( initgroups ( * ( const char * * ) @@int64@@ , * ( _DWORD * ) ( @@int64@@ + Number ) ) == Number ) { @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ ) ; } endgrent ( ) ; if ( setgid ( * ( _DWORD * ) ( @@int64@@ + Number ) ) ) { @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ ) ; } if ( setuid ( * ( _DWORD * ) ( @@int64@@ + Number ) ) ) { @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ ) ; } }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
unsigned __int64 __fastcall factor_wheel ( unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; const char * @@constchar@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; const char * @@constchar@@ ; @@unsignedint64@@ = @@unsignedint64@@ ; @@unsignedint64@@ = Number L ; @@constchar@@ = ( const char * ) & wheel_tab ; if ( @@unsignedint64@@ <= Number ) return Number L ; @@unsignedint64@@ = Number L ; do { for ( @@unsignedint64@@ = @@unsignedint64@@ / @@unsignedint64@@ ; @@unsignedint64@@ == @@unsignedint64@@ * @@unsignedint64@@ ; @@unsignedint64@@ /= @@unsignedint64@@ ) { if ( @@unsignedint64@@ >= @@unsignedint64@@ ) __assert_fail ( String , String , Number , String ) ; @@int64@@ = @@unsignedint64@@ ++ ; * ( _QWORD * ) ( @@int64@@ + Number * @@int64@@ ) = @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint64@@ ; } @@constchar@@ = @@constchar@@ ++ ; @@unsignedint64@@ += * ( unsigned __int8 * ) @@constchar@@ ; if ( @@constchar@@ == String ) @@constchar@@ = ( const char * ) & unk_4E85 ; } while ( @@unsignedint64@@ <= @@unsignedint64@@ ) ; if ( @@unsignedint64@@ != Number ) { if ( @@unsignedint64@@ >= @@unsignedint64@@ ) __assert_fail ( String , String , Number , String ) ; @@int64@@ = @@unsignedint64@@ ++ ; * ( _QWORD * ) ( @@int64@@ + Number * @@int64@@ ) = @@unsignedint64@@ ; } return @@unsignedint64@@ ; }
__int64 __fastcall get_line ( FILE * @@FILE@@ , char @@char@@ ) { _BYTE * @@BYTE@@ ; __int64 @@int64@@ ; bool @@bool@@ ; int @@int@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; LOBYTE ( @@unsignedint@@ ) = @@char@@ ; do { * ( _QWORD * ) word_limit = wptr ; do { if ( & wptr == ( __int64 * ) wptr ) { set_other_indent ( Number ) ; flush_paragraph ( ) ; } @@BYTE@@ = ( _BYTE * ) wptr ++ ; * @@BYTE@@ = @@unsignedint@@ ; @@unsignedint@@ = getc_unlocked ( @@FILE@@ ) ; } while ( @@unsignedint@@ != Number && ( ( * __ctype_b_loc ( ) ) [ @@unsignedint@@ ] & Number ) == Number ) ; @@int64@@ = word_limit ; * ( _DWORD * ) ( word_limit + Number ) = wptr - * ( _QWORD * ) word_limit ; in_column += * ( _DWORD * ) ( @@int64@@ + Number ) ; check_punctuation ( word_limit ) ; @@int@@ = in_column ; @@unsignedint@@ = get_space ( @@FILE@@ , @@unsignedint@@ ) ; * ( _DWORD * ) ( word_limit + Number ) = in_column - @@int@@ ; @@bool@@ = @@unsignedint@@ == Number || ( * ( _BYTE * ) ( word_limit + Number ) & Number ) != Number && ( @@unsignedint@@ == Number || * ( int * ) ( word_limit + Number ) > Number ) ; * ( _BYTE * ) ( word_limit + Number ) = ( Number * @@bool@@ ) | * ( _BYTE * ) ( word_limit + Number ) & Number ; if ( @@unsignedint@@ == Number || @@unsignedint@@ == Number || uniform ) { if ( ( * ( _BYTE * ) ( word_limit + Number ) & Number ) != Number ) @@int@@ = Number ; else @@int@@ = Number ; * ( _DWORD * ) ( word_limit + Number ) = @@int@@ ; } if ( & unk_213070 == ( _UNKNOWN * ) word_limit ) { set_other_indent ( Number ) ; flush_paragraph ( ) ; } word_limit += Number L ; } while ( @@unsignedint@@ != Number && @@unsignedint@@ != Number ) ; return get_prefix ( @@FILE@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 __fastcall bkm_scale_by_power ( unsigned __int64 * @@unsignedint64@@ , int @@int@@ , int @@int@@ ) { unsigned int @@unsignedint@@ ; for ( @@unsignedint@@ = Number ; @@int@@ -- ; @@unsignedint@@ |= bkm_scale ( @@unsignedint64@@ , @@int@@ ) ) { ; } return @@unsignedint@@ ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_2060C8 ; @@int648@@ [ Number ] = qword_2060D0 ; @@int648@@ [ Number ] = qword_2060D8 ; @@int648@@ [ Number ] = qword_2060E0 ; @@int648@@ [ Number ] = qword_2060E8 ; @@int648@@ [ Number ] = qword_2060F0 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
__int64 __fastcall get_stat_ctime ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
void * __fastcall human_time ( time_t @@timet@@ , __int64 @@int64@@ ) { time_t @@timet@@ ; __int64 @@int64@@ ; struct tm * @@structtm@@ ; @@timet@@ = @@timet@@ ; @@int64@@ = @@int64@@ ; @@structtm@@ = localtime ( & @@timet@@ ) ; if ( ! @@structtm@@ ) return ( void * ) timetostr ( @@timet@@ , ( __int64 ) & str_5922 ) ; nstrftime ( & str_5922 , Number L , String , @@structtm@@ , Number L , ( unsigned int ) @@int64@@ ) ; return & str_5922 ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
bool __fastcall correct_password ( __int64 @@int64@@ ) { bool @@bool@@ ; char * @@char@@ ; char * @@char@@ ; size_t @@sizet@@ ; char * @@char@@ ; struct spwd * @@structspwd@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@structspwd@@ = getspnam ( * ( const char * * ) @@int64@@ ) ; endspent ( ) ; if ( @@structspwd@@ ) @@char@@ = @@structspwd@@ -> sp_pwdp ; else @@char@@ = * ( char * * ) ( @@int64@@ + Number ) ; if ( ! getuid ( ) || ! @@char@@ || ! * @@char@@ ) return Number ; @@char@@ = gettext ( String ) ; @@char@@ = ( char * ) gnu_getpass ( @@char@@ ) ; if ( @@char@@ ) { @@constchar@@ = crypt ( @@char@@ , @@char@@ ) ; @@sizet@@ = strlen ( @@char@@ ) ; memset ( @@char@@ , Number , @@sizet@@ ) ; @@bool@@ = strcmp ( @@constchar@@ , @@char@@ ) == Number ; } else { @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ ) ; @@bool@@ = Number ; } return @@bool@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
int __fastcall out_uint ( const char * @@constchar@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { strcpy ( ( char * ) & @@constchar@@ [ @@int64@@ ] , String ) ; return printf ( @@constchar@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
unsigned __int64 __fastcall out_file_context ( __int64 @@int64@@ , const char * @@constchar@@ , __int64 @@int64@@ ) { unsigned int @@unsignedint@@ ; __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; const char * @@constchar@@ ; const char * @@constchar@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( follow_links ) @@unsignedint@@ = ( unsigned int ) getfilecon ( @@int64@@ , & @@constchar@@ ) >> Number ; else @@unsignedint@@ = ( unsigned int ) lgetfilecon ( @@int64@@ , & @@constchar@@ ) >> Number ; if ( ( _BYTE ) @@unsignedint@@ ) { @@int64@@ = quote ( @@int64@@ ) ; @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ , @@int64@@ ) ; @@constchar@@ = Number L ; } * ( _WORD * ) & @@constchar@@ [ @@int64@@ ] = Number ; if ( @@constchar@@ ) @@constchar@@ = @@constchar@@ ; else @@constchar@@ = String ; printf ( @@constchar@@ , @@constchar@@ ) ; if ( @@constchar@@ ) freecon ( ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
__int64 __fastcall xnrealloc ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { if ( ! is_mul_ok ( @@unsignedint64@@ , @@unsignedint64@@ ) ) xalloc_die ( ) ; return xrealloc ( @@int64@@ , @@unsignedint64@@ * @@unsignedint64@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
void * __fastcall xzalloc ( size_t @@sizet@@ ) { void * @@void@@ ; @@void@@ = xmalloc ( @@sizet@@ ) ; return memset ( @@void@@ , Number , @@sizet@@ ) ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@unsignedint64@@ , int @@int@@ ) { __int64 @@int64@@ ; if ( is_mul_ok ( @@int@@ , * @@unsignedint64@@ ) ) { * @@unsignedint64@@ *= @@int@@ ; @@int64@@ = Number L ; } else { * @@unsignedint64@@ = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
unsigned __int64 __fastcall print_factors_single ( unsigned __int64 @@unsignedint64@@ ) { const char * @@constchar@@ ; const char * @@constchar@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ [ Number ] ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@unsignedint64@@ = factor_wheel ( @@unsignedint64@@ , Number , ( __int64 ) @@int64@@ ) ; @@constchar@@ = ( const char * ) umaxtostr ( @@unsignedint64@@ , @@char@@ ) ; printf ( String , @@constchar@@ ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@unsignedint64@@ ; ++ @@unsignedint64@@ ) { @@constchar@@ = ( const char * ) umaxtostr ( @@int64@@ [ @@unsignedint64@@ ] , @@char@@ ) ; printf ( String , @@constchar@@ ) ; } putchar_unlocked ( Number ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
__int64 __fastcall x2nrealloc ( __int64 @@int64@@ , unsigned __int64 * @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = * @@unsignedint64@@ ; if ( @@int64@@ ) { if ( @@unsignedint64@@ >= Number / @@unsignedint64@@ ) xalloc_die ( ) ; @@unsignedint64@@ += ( @@unsignedint64@@ + Number ) >> Number ; } else if ( ! @@unsignedint64@@ ) { @@unsignedint64@@ = ( Number / @@unsignedint64@@ == Number ) + Number / @@unsignedint64@@ ; } * @@unsignedint64@@ = @@unsignedint64@@ ; return xrealloc ( @@int64@@ , @@unsignedint64@@ * @@unsignedint64@@ ) ; }
__int64 __fastcall readtoken ( FILE * @@FILE@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; char @@char@@ ; int @@int@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( ! @@int64@@ && ! saved_delim_3296 ) abort ( ) ; @@char@@ = Number ; if ( @@int64@@ != saved_delim_3296 && saved_delim_3296 ) { @@char@@ = Number ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@unsignedint64@@ ; ++ @@unsignedint64@@ ) { if ( * ( _BYTE * ) ( @@int64@@ + @@unsignedint64@@ ) != * ( _BYTE * ) ( saved_delim_3296 + @@unsignedint64@@ ) ) { @@char@@ = Number ; break ; } } } if ( @@char@@ != Number ) { saved_delim_3296 = @@int64@@ ; memset ( isdelim_3297 , Number , sizeof ( isdelim_3297 ) ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@unsignedint64@@ ; ++ @@unsignedint64@@ ) { isdelim_3297 [ * ( unsigned __int8 * ) ( @@int64@@ + @@unsignedint64@@ ) ] = Number ; } } do @@int@@ = getc_unlocked ( @@FILE@@ ) ; while ( @@int@@ >= Number && isdelim_3297 [ @@int@@ ] ) ; @@int64@@ = @@int64@@ [ Number ] ; @@int64@@ = * @@int64@@ ; @@unsignedint64@@ = Number L ; while ( Number ) { if ( @@int@@ < Number && ! @@unsignedint64@@ ) return Number ; if ( @@unsignedint64@@ == @@int64@@ ) @@int64@@ = x2nrealloc ( @@int64@@ , & @@int64@@ , Number L ) ; if ( @@int@@ < Number ) { * ( _BYTE * ) ( @@int64@@ + @@unsignedint64@@ ) = Number ; goto LABEL_28 ; } if ( isdelim_3297 [ @@int@@ ] ) break ; @@int64@@ = @@unsignedint64@@ ++ ; * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) = @@int@@ ; @@int@@ = getc_unlocked ( @@FILE@@ ) ; } * ( _BYTE * ) ( @@int64@@ + @@unsignedint64@@ ) = Number ; LABEL_28 : @@int64@@ [ Number ] = @@int64@@ ; * @@int64@@ = @@int64@@ ; return @@unsignedint64@@ ; }
int __cdecl __noreturn main ( int @@int@@ , const char * * @@constchar@@ , const char * * @@constchar@@ ) { bool @@bool@@ ; int @@int@@ ; int @@int@@ ; set_program_name ( * @@constchar@@ , @@constchar@@ , @@constchar@@ ) ; setlocale ( Number , shortopts ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; while ( Number ) { @@int@@ = getopt_long ( @@int@@ , ( char * const * ) @@constchar@@ , shortopts , & long_options , Number L ) ; if ( @@int@@ == Number ) break ; if ( @@int@@ == Number ) usage ( Number ) ; if ( @@int@@ != Number ) { if ( @@int@@ != Number ) usage ( Number ) ; version_etc ( ( _DWORD ) stdout , ( unsigned int ) String , ( unsigned int ) String , ( _DWORD ) Version , ( unsigned int ) String , Number , ( char ) @@constchar@@ ) ; exit ( Number ) ; } verbose = Number ; } if ( @@int@@ > optind ) { @@bool@@ = Number ; for ( @@int@@ = optind ; @@int@@ < @@int@@ ; ++ @@int@@ ) { if ( ( unsigned __int8 ) print_factors ( ( __int64 ) @@constchar@@ [ @@int@@ ] ) != Number ) @@bool@@ = Number ; } } else { @@bool@@ = do_stdin ( ) ; } exit ( ! @@bool@@ ) ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall print_factors ( __int64 @@int64@@ ) { int @@int@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint644@@ [ Number ] ; @@unsignedint644@@ [ Number ] = __readfsqword ( Number ) ; @@int@@ = xstrtoumax ( @@int64@@ , Number L , Number L , @@unsignedint644@@ , shortopts ) ; if ( @@int@@ ) { if ( @@int@@ == Number ) { @@int64@@ = quote ( @@int64@@ ) ; @@char@@ = gettext ( String ) ; } else { @@int64@@ = quote ( @@int64@@ ) ; @@char@@ = gettext ( String ) ; } error ( Number , Number , @@char@@ , @@int64@@ ) ; @@int64@@ = Number L ; } else { gettext ( String ) ; debug ( ) ; print_factors_single ( @@unsignedint644@@ [ Number ] ) ; @@int64@@ = Number L ; } return @@int64@@ ; }
bool __fastcall is_empty_dir ( int @@int@@ , const char * @@constchar@@ ) { bool @@bool@@ ; int @@int@@ ; int @@int@@ ; DIR * @@DIR@@ ; struct dirent * @@structdirent@@ ; @@int@@ = openat ( @@int@@ , @@constchar@@ , Number ) ; if ( @@int@@ < Number ) return Number ; @@DIR@@ = fdopendir ( @@int@@ ) ; if ( @@DIR@@ ) { * __errno_location ( ) = Number ; @@structdirent@@ = readdir_ignoring_dot_and_dotdot ( @@DIR@@ ) ; @@int@@ = * __errno_location ( ) ; closedir ( @@DIR@@ ) ; if ( @@structdirent@@ ) @@bool@@ = Number ; else @@bool@@ = @@int@@ == Number ; } else { close ( @@int@@ ) ; @@bool@@ = Number ; } return @@bool@@ ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@unsignedint64@@ , int @@int@@ ) { __int64 @@int64@@ ; if ( is_mul_ok ( @@int@@ , * @@unsignedint64@@ ) ) { * @@unsignedint64@@ *= @@int@@ ; @@int64@@ = Number L ; } else { * @@unsignedint64@@ = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
_BOOL8 __fastcall dot_or_dotdot_0 ( _BYTE * @@BYTE@@ ) { __int64 @@int64@@ ; char @@char@@ ; if ( * @@BYTE@@ != Number ) return Number L ; if ( @@BYTE@@ [ Number ] == Number ) @@int64@@ = Number L ; else @@int64@@ = Number L ; @@char@@ = @@BYTE@@ [ @@int64@@ ] ; return ! @@char@@ || @@char@@ == Number ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall get_stat_mtime ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
__int64 __fastcall umaxtostr ( unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = @@int64@@ + Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = Number ; do { * ( _BYTE * ) -- @@int64@@ = @@unsignedint64@@ % Number + Number ; @@unsignedint64@@ /= Number ; } while ( @@unsignedint64@@ ) ; return @@int64@@ ; }
__int64 __fastcall memcpy_uppcase ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { while ( @@int64@@ -- ) * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) = toupper ( * ( unsigned __int8 * ) ( @@int64@@ + @@int64@@ ) ) ; return @@int64@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
__int64 __fastcall is_ancestor ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ ) { while ( @@QWORD@@ ) { if ( @@QWORD@@ [ Number ] == @@QWORD@@ [ Number ] && @@QWORD@@ [ Number ] == * @@QWORD@@ ) { return Number L ; } @@QWORD@@ = ( _QWORD * ) * @@QWORD@@ ; } return Number L ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ ) { return xmalloc ( @@int64@@ ) ; }
void __fastcall rm_option_init ( __int64 @@int64@@ ) { __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; * ( _BYTE * ) @@int64@@ = Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = Number ; * ( _DWORD * ) ( @@int64@@ + Number ) = Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = Number ; * ( _QWORD * ) ( @@int64@@ + Number ) = get_root_dev_ino ( & dev_ino_buf_5763 ) ; if ( ! * ( _QWORD * ) ( @@int64@@ + Number ) ) { @@int64@@ = quote ( String ) ; @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ , @@int64@@ ) ; } }
__int64 __fastcall rpl_fcntl ( int @@int@@ , int @@int@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ ) { int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; if ( @@int@@ != Number ) return ( unsigned int ) fcntl ( @@int@@ , @@int@@ , @@int64@@ ) ; @@int@@ = @@int64@@ ; if ( have_dupfd_cloexec_2895 < Number ) { @@int@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@int@@ , Number , @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ ) ; } else { @@int@@ = fcntl ( @@int@@ , Number , ( unsigned int ) @@int64@@ ) ; if ( @@int@@ < Number && * __errno_location ( ) == Number ) { @@int@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@int@@ , Number , @@int@@ , @@int@@ , @@int@@ , @@int@@ ) ; if ( @@int@@ < Number ) return ( unsigned int ) @@int@@ ; have_dupfd_cloexec_2895 = Number ; } else { have_dupfd_cloexec_2895 = Number ; } } if ( @@int@@ >= Number && have_dupfd_cloexec_2895 == Number ) { @@int@@ = fcntl ( @@int@@ , Number ) ; if ( @@int@@ < Number || fcntl ( @@int@@ , Number , @@int@@ | Number ) == Number ) { @@int@@ = * __errno_location ( ) ; close ( @@int@@ ) ; * __errno_location ( ) = @@int@@ ; @@int@@ = Number ; } } return ( unsigned int ) @@int@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_207028 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
_BOOL8 __fastcall writable_destination ( const char * @@constchar@@ , __int16 @@int16@@ ) { return ( @@int16@@ & Number ) == Number || ( unsigned __int8 ) can_write_any_file ( ) || ! euidaccess ( @@constchar@@ , Number ) ; }
__int64 __fastcall fmt ( __int64 @@int64@@ ) { __int64 @@int64@@ ; tabs = Number ; other_indent = Number ; next_char = get_prefix ( @@int64@@ ) ; while ( Number ) { @@int64@@ = get_paragraph ( @@int64@@ ) ; if ( ! ( _BYTE ) @@int64@@ ) break ; fmt_paragraph ( ) ; put_paragraph ( word_limit ) ; } return @@int64@@ ; }
__int64 __fastcall do_move ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { char @@char@@ ; char @@char@@ ; unsigned __int8 @@unsignedint8@@ ; int @@int@@ ; __int64 @@int64@@ ; char @@char@@ [ Number ] ; __int64 @@int644@@ [ Number ] ; @@int644@@ [ Number ] = __readfsqword ( Number ) ; @@unsignedint8@@ = copy ( @@int64@@ , @@int64@@ , Number L , @@int64@@ , & @@char@@ , & @@char@@ ) ; if ( @@unsignedint8@@ ) { if ( @@char@@ ) { @@int64@@ = Number L ; @@unsignedint8@@ = Number ; } else { @@int64@@ = @@char@@ ? Number L : @@int64@@ ; } if ( @@int64@@ ) { rm_option_init ( ( __int64 ) @@char@@ ) ; @@char@@ [ Number ] = * ( _BYTE * ) ( @@int64@@ + Number ) ; @@int644@@ [ Number ] = @@int64@@ ; @@int644@@ [ Number ] = Number L ; @@int@@ = rm ( @@int644@@ , @@char@@ ) ; if ( @@int@@ != Number && @@int@@ != Number && @@int@@ != Number ) __assert_fail ( String , String , Number , String ) ; if ( @@int@@ == Number ) @@unsignedint8@@ = Number ; } } return @@unsignedint8@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_208028 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall movefile ( __int64 @@int64@@ , __int64 @@int64@@ , char @@char@@ , __int64 @@int64@@ ) { unsigned __int8 @@unsignedint8@@ ; __int64 @@int64@@ ; void * @@void@@ ; if ( remove_trailing_slashes ) strip_trailing_slashes ( @@int64@@ ) ; if ( ! @@char@@ ) return ( unsigned __int8 ) do_move ( @@int64@@ , @@int64@@ , @@int64@@ ) ; @@int64@@ = last_component ( @@int64@@ ) ; @@void@@ = ( void * ) file_name_concat ( @@int64@@ , @@int64@@ , Number L ) ; strip_trailing_slashes ( @@void@@ ) ; @@unsignedint8@@ = do_move ( @@int64@@ , ( __int64 ) @@void@@ , @@int64@@ ) ; free ( @@void@@ ) ; return @@unsignedint8@@ ; }
__int64 __fastcall copy_rest ( FILE * @@FILE@@ , unsigned int @@unsignedint@@ ) { char * @@char@@ ; unsigned int @@unsignedint@@ ; char * @@char@@ ; @@unsignedint@@ = @@unsignedint@@ ; out_column = Number ; if ( in_column > next_prefix_indent || @@unsignedint@@ != Number && @@unsignedint@@ != Number ) { put_space ( ( unsigned int ) next_prefix_indent ) ; for ( @@char@@ = prefix ; out_column != in_column && * @@char@@ ; ++ @@char@@ ) { @@char@@ = @@char@@ ; putchar_unlocked ( * @@char@@ ) ; ++ out_column ; } if ( @@unsignedint@@ != Number && @@unsignedint@@ != Number ) put_space ( ( unsigned int ) ( in_column - out_column ) ) ; if ( @@unsignedint@@ == Number && prefix_length + next_prefix_indent <= in_column ) putchar_unlocked ( Number ) ; } while ( @@unsignedint@@ != Number && @@unsignedint@@ != Number ) { putchar_unlocked ( @@unsignedint@@ ) ; @@unsignedint@@ = getc_unlocked ( @@FILE@@ ) ; } return @@unsignedint@@ ; }
unsigned __int64 __fastcall overwrite_prompt ( const char * @@constchar@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; char * @@char@@ ; char @@char@@ ; _BYTE @@BYTE11@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( ! writable_destination ( @@constchar@@ , * ( _DWORD * ) ( @@int64@@ + Number ) ) ) { strmode ( * ( unsigned int * ) ( @@int64@@ + Number ) , & @@char@@ ) ; @@BYTE11@@ [ Number ] = Number ; @@int64@@ = * ( _DWORD * ) ( @@int64@@ + Number ) & Number ; @@int64@@ = quote ( @@constchar@@ ) ; @@int64@@ = program_name ; @@char@@ = gettext ( String ) ; fprintf ( stderr , @@char@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@BYTE11@@ ) ; } else { @@int64@@ = quote ( @@constchar@@ ) ; @@int64@@ = program_name ; @@char@@ = gettext ( String ) ; fprintf ( stderr , @@char@@ , @@int64@@ , @@int64@@ ) ; } return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall rm ( _QWORD * @@QWORD@@ , __int64 @@int64@@ ) { char * @@char@@ ; int * @@int@@ ; char * @@char@@ ; int * @@int@@ ; unsigned int @@unsignedint@@ ; unsigned int @@unsignedint@@ ; unsigned int @@unsignedint@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; @@unsignedint@@ = Number ; if ( * @@QWORD@@ ) { @@unsignedint@@ = Number ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) ) @@unsignedint@@ = Number ; @@int64@@ = xfts_open ( @@QWORD@@ , @@unsignedint@@ , Number L ) ; while ( Number ) { @@int64@@ = fts_read ( @@int64@@ ) ; if ( ! @@int64@@ ) break ; @@unsignedint@@ = rm_fts ( @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( @@unsignedint@@ != Number && @@unsignedint@@ != Number && @@unsignedint@@ != Number ) { __assert_fail ( String , String , Number , _PRETTY_FUNCTION___5846 ) ; } if ( @@unsignedint@@ == Number || @@unsignedint@@ == Number && @@unsignedint@@ == Number ) { @@unsignedint@@ = @@unsignedint@@ ; } } if ( * __errno_location ( ) ) { @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ ) ; @@unsignedint@@ = Number ; } if ( ( unsigned int ) fts_close ( @@int64@@ ) ) { @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ ) ; @@unsignedint@@ = Number ; } } return @@unsignedint@@ ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall cache_fstatat ( int @@int@@ , char * @@char@@ , struct stat * @@structstat@@ , int @@int@@ ) { __ino_t @@inot@@ ; if ( @@structstat@@ -> st_size == Number && ( unsigned int ) fstatat ( @@int@@ , @@char@@ , @@structstat@@ , @@int@@ ) ) { @@structstat@@ -> st_size = Number ; @@structstat@@ -> st_ino = * __errno_location ( ) ; } if ( @@structstat@@ -> st_size >= Number ) return Number L ; @@inot@@ = @@structstat@@ -> st_ino ; * __errno_location ( ) = @@inot@@ ; return Number ; }
char * flush_paragraph ( ) { char * @@char@@ ; signed int @@signedint@@ ; const void * * @@constvoid@@ ; __int64 @@int64@@ ; const void * * @@constvoid@@ ; __int64 @@int64@@ ; if ( ( _UNKNOWN * ) word_limit == & unused_word_type ) { fwrite_unlocked ( & parabuf , Number , wptr - ( _QWORD ) & parabuf , stdout ) ; @@char@@ = ( char * ) & parabuf ; wptr = ( __int64 ) & parabuf ; } else { fmt_paragraph ( ) ; @@constvoid@@ = ( const void * * ) word_limit ; @@int64@@ = Number ; for ( @@int64@@ = qword_2094A0 ; @@int64@@ != word_limit ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ) { if ( @@int64@@ > * ( _QWORD * ) ( @@int64@@ + Number ) - * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) ) { @@constvoid@@ = ( const void * * ) @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) - * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) ; } if ( @@int64@@ <= Number ) @@int64@@ += Number L ; } put_paragraph ( @@constvoid@@ ) ; memmove ( & parabuf , * @@constvoid@@ , wptr - ( _QWORD ) * @@constvoid@@ ) ; @@signedint@@ = ( unsigned int ) * @@constvoid@@ - ( unsigned int ) & parabuf ; wptr -= @@signedint@@ ; for ( @@constvoid@@ = @@constvoid@@ ; ( unsigned __int64 ) @@constvoid@@ <= word_limit ; @@constvoid@@ += Number ) { * @@constvoid@@ = ( char * ) * @@constvoid@@ - @@signedint@@ ; } memmove ( & unused_word_type , @@constvoid@@ , Number * ( Number * ( ( word_limit - ( __int64 ) @@constvoid@@ ) >> Number ) + Number ) ) ; @@char@@ = ( char * ) ( & unused_word_type - ( _UNKNOWN * ) @@constvoid@@ + word_limit ) ; word_limit = ( __int64 ) @@char@@ ; } return @@char@@ ; }
__int64 __fastcall valid_options ( __int64 @@int64@@ ) { if ( ! @@int64@@ ) __assert_fail ( String , String , Number , String ) ; if ( * ( _DWORD * ) @@int64@@ > Number ) __assert_fail ( String , String , Number , String ) ; if ( * ( _DWORD * ) ( @@int64@@ + Number ) != Number && * ( _DWORD * ) ( @@int64@@ + Number ) != Number && * ( _DWORD * ) ( @@int64@@ + Number ) != Number ) { __assert_fail ( String , String , Number , String ) ; } if ( * ( _DWORD * ) ( @@int64@@ + Number ) && * ( _DWORD * ) ( @@int64@@ + Number ) != Number && * ( _DWORD * ) ( @@int64@@ + Number ) != Number ) { __assert_fail ( String , String , Number , String ) ; } if ( * ( _BYTE * ) ( @@int64@@ + Number ) == Number && * ( _BYTE * ) ( @@int64@@ + Number ) == Number ) __assert_fail ( String , String , Number , String ) ; if ( * ( _DWORD * ) ( @@int64@@ + Number ) == Number && * ( _DWORD * ) ( @@int64@@ + Number ) != Number ) { __assert_fail ( String , String , Number , String ) ; } return Number L ; }
_BOOL8 __fastcall abandon_move ( __int64 @@int64@@ , const char * @@constchar@@ , __int64 @@int64@@ ) { bool @@bool@@ ; if ( ! * ( _BYTE * ) ( @@int64@@ + Number ) ) __assert_fail ( String , String , Number , String ) ; @@bool@@ = Number ; if ( * ( _DWORD * ) ( @@int64@@ + Number ) != Number ) { if ( * ( _DWORD * ) ( @@int64@@ + Number ) != Number && ( * ( _DWORD * ) ( @@int64@@ + Number ) != Number || ! * ( _BYTE * ) ( @@int64@@ + Number ) || writable_destination ( @@constchar@@ , * ( _DWORD * ) ( @@int64@@ + Number ) ) ) || ( overwrite_prompt ( @@constchar@@ , @@int64@@ ) , ( unsigned __int8 ) yesno ( ) == Number ) ) { @@bool@@ = Number ; } } return @@bool@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall excise ( __int64 @@int64@@ , __int64 @@int64@@ , _BYTE * @@BYTE@@ , char @@char@@ ) { int @@int@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; int * @@int@@ ; __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; struct stat @@structstat@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( @@char@@ ) @@int@@ = Number ; else @@int@@ = Number ; if ( unlinkat ( * ( _DWORD * ) ( @@int64@@ + Number ) , * ( const char * * ) ( @@int64@@ + Number ) , @@int@@ ) ) { if ( * __errno_location ( ) == Number && ( ! ( unsigned int ) lstatat ( * ( _DWORD * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) , & @@structstat@@ ) || * __errno_location ( ) != Number ) ) { * __errno_location ( ) = Number ; } @@int@@ = __errno_location ( ) ; if ( ignorable_missing ( @@BYTE@@ , * @@int@@ ) ) { @@int64@@ = Number L ; } else { if ( * ( _WORD * ) ( @@int64@@ + Number ) == Number ) * __errno_location ( ) = * ( _DWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = quote ( * ( _QWORD * ) ( @@int64@@ + Number ) ) ; @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ , @@int64@@ ) ; mark_ancestor_dirs ( @@int64@@ ) ; @@int64@@ = Number L ; } } else { if ( @@BYTE@@ [ Number ] ) { @@int64@@ = quote ( * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( @@char@@ ) @@char@@ = gettext ( String ) ; else @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = Number L ; } return @@int64@@ ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
_BOOL8 __fastcall chown_failure_ok ( __int64 @@int64@@ ) { return ( * __errno_location ( ) == Number || * __errno_location ( ) == Number ) && * ( _BYTE * ) ( @@int64@@ + Number ) != Number ; }
__int64 __fastcall copy_acl ( __int64 @@int64@@ , unsigned int @@unsignedint@@ , const char * @@constchar@@ , int @@int@@ , __mode_t @@modet@@ ) { int @@int@@ ; const char * @@constchar@@ ; int * @@int@@ ; __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; __int64 @@int64@@ ; @@int@@ = qcopy_acl ( @@int64@@ , @@unsignedint@@ , @@constchar@@ , @@int@@ , @@modet@@ ) ; if ( @@int@@ == Number ) { @@constchar@@ = ( const char * ) quote ( @@int64@@ ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , String , @@constchar@@ ) ; @@int64@@ = Number ; } else if ( @@int@@ == Number ) { @@int64@@ = quote ( @@constchar@@ ) ; @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ , @@int64@@ ) ; @@int64@@ = Number ; } else { @@int64@@ = Number L ; } return @@int64@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
_BOOL8 __fastcall owner_failure_ok ( __int64 @@int64@@ ) { return ( * __errno_location ( ) == Number || * __errno_location ( ) == Number ) && * ( _BYTE * ) ( @@int64@@ + Number ) != Number ; }
int __fastcall emit_verbose ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { const char * @@constchar@@ ; const char * @@constchar@@ ; __int64 @@int64@@ ; char * @@char@@ ; @@constchar@@ = ( const char * ) quote_n ( Number L , @@int64@@ ) ; @@constchar@@ = ( const char * ) quote_n ( Number L , @@int64@@ ) ; printf ( String , @@constchar@@ , @@constchar@@ ) ; if ( @@int64@@ ) { @@int64@@ = quote ( @@int64@@ ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } return putchar_unlocked ( Number ) ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) { ; } return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_208028 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
unsigned __int64 __fastcall src_to_dest_hash ( _QWORD * @@QWORD@@ , unsigned __int64 @@unsignedint64@@ ) { return * @@QWORD@@ % @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
__int64 __fastcall copy ( char * @@char@@ , char * @@char@@ , char @@char@@ , unsigned int * @@unsignedint@@ , bool * @@bool@@ , _BYTE * @@BYTE@@ ) { char @@char@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( ! ( unsigned __int8 ) valid_options ( ( __int64 ) @@unsignedint@@ ) ) __assert_fail ( String , String , Number , String ) ; top_level_src_name = ( __int64 ) @@char@@ ; top_level_dst_name = ( __int64 ) @@char@@ ; @@char@@ = Number ; return copy_internal ( @@char@@ , @@char@@ , @@char@@ , Number L , Number L , @@unsignedint@@ , Number , & @@char@@ , @@bool@@ , @@BYTE@@ ) ; }
void * __fastcall find_backup_file_name ( const char * @@constchar@@ , int @@int@@ ) { int @@int@@ ; bool @@bool@@ ; void * @@void@@ ; size_t @@sizet@@ ; __int64 @@int64@@ ; size_t @@sizet@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = strlen ( @@constchar@@ ) ; @@bool@@ = Number ; @@sizet@@ = strlen ( simple_backup_suffix ) + Number ; @@sizet@@ = @@sizet@@ ; if ( @@sizet@@ <= Number ) @@sizet@@ = Number L ; @@unsignedint64@@ = @@int64@@ + @@sizet@@ + Number ; @@void@@ = ( void * ) xmalloc ( @@unsignedint64@@ ) ; memcpy ( @@void@@ , @@constchar@@ , @@int64@@ + Number ) ; if ( @@int@@ != Number ) { @@int@@ = numbered_backup ( ( __int64 * ) & @@void@@ , @@unsignedint64@@ , @@int64@@ ) ; switch ( @@int@@ ) { case Number : @@bool@@ = Number ; break ; case Number : return @@void@@ ; case Number : @@bool@@ = @@int@@ == Number ; break ; } } if ( @@bool@@ ) memcpy ( ( char * ) @@void@@ + @@int64@@ , simple_backup_suffix , @@sizet@@ ) ; check_extension ( ( const char * ) @@void@@ , @@int64@@ , Number ) ; return @@void@@ ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
_BOOL8 __fastcall src_to_dest_compare ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ ) { return * @@QWORD@@ == * @@QWORD@@ && @@QWORD@@ [ Number ] == @@QWORD@@ [ Number ] ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall clear_ungetc_buffer_preserving_position ( _DWORD * @@DWORD@@ ) { __int64 @@int64@@ ; @@int64@@ = * @@DWORD@@ & Number ; if ( ( _DWORD ) @@int64@@ ) @@int64@@ = rpl_fseeko ( @@DWORD@@ , Number L , Number L ) ; return @@int64@@ ; }
unsigned __int64 __fastcall forget_created ( __int64 @@int64@@ , __int64 @@int64@@ ) { void * * @@void@@ ; __int64 @@int643@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int643@@ [ Number ] = @@int64@@ ; @@int643@@ [ Number ] = @@int64@@ ; @@int643@@ [ Number ] = Number L ; @@void@@ = ( void * * ) hash_delete ( src_to_dest , @@int643@@ ) ; if ( @@void@@ ) src_to_dest_free ( @@void@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall src_to_dest_lookup ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int644@@ [ Number ] ; @@int644@@ [ Number ] = __readfsqword ( Number ) ; @@int644@@ [ Number ] = @@int64@@ ; @@int644@@ [ Number ] = @@int64@@ ; @@int64@@ = hash_lookup ( src_to_dest , @@int644@@ ) ; if ( @@int64@@ ) @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; else @@int64@@ = Number L ; return @@int64@@ ; }
__int64 __fastcall remember_copied ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = xmalloc ( Number L ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = xstrdup ( @@int64@@ ) ; * ( _QWORD * ) @@int64@@ = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; @@int64@@ = hash_insert ( src_to_dest , @@int64@@ ) ; if ( ! @@int64@@ ) xalloc_die ( ) ; if ( @@int64@@ == @@int64@@ ) return Number L ; src_to_dest_free ( ( void * * ) @@int64@@ ) ; return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
void __fastcall record_file ( __int64 @@int64@@ , __int64 @@int64@@ , _QWORD * @@QWORD@@ ) { _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) { @@QWORD@@ = ( _QWORD * ) xmalloc ( Number L ) ; * @@QWORD@@ = xstrdup ( @@int64@@ ) ; @@QWORD@@ [ Number ] = @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = * @@QWORD@@ ; @@int64@@ = hash_insert ( @@int64@@ , @@QWORD@@ ) ; if ( ! @@int64@@ ) xalloc_die ( ) ; if ( ( _QWORD * ) @@int64@@ != @@QWORD@@ ) triple_free ( @@QWORD@@ ) ; } }
unsigned __int64 __fastcall readtokens ( FILE * @@FILE@@ , __int64 @@int64@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ ) { void * * @@void@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; void * @@void@@ ; char @@char@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = ( __int64 * ) & @@char@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ + Number ; else @@int64@@ = Number L ; @@unsignedint64@@ = @@int64@@ ; @@int64@@ = xnmalloc ( @@int64@@ , Number L ) ; @@int64@@ = xnmalloc ( @@int64@@ , Number L ) ; @@unsignedint64@@ = Number L ; init_tokenbuffer ( @@int64@@ ) ; while ( Number ) { @@int64@@ = readtoken ( @@FILE@@ , @@int64@@ , @@unsignedint64@@ , @@int64@@ ) ; if ( @@unsignedint64@@ >= @@unsignedint64@@ ) { @@int64@@ = x2nrealloc ( @@int64@@ , & @@unsignedint64@@ , Number L ) ; @@int64@@ = xnrealloc ( @@int64@@ , @@unsignedint64@@ , Number L ) ; } if ( @@int64@@ == Number ) break ; @@void@@ = ( void * ) xnmalloc ( @@int64@@ + Number , Number L ) ; * ( _QWORD * ) ( @@int64@@ + Number * @@unsignedint64@@ ) = @@int64@@ ; @@void@@ = ( void * * ) ( Number * @@unsignedint64@@ + @@int64@@ ) ; * @@void@@ = memcpy ( @@void@@ , ( const void * ) @@int64@@ [ Number ] , @@int64@@ + Number ) ; ++ @@unsignedint64@@ ; } * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@int64@@ ) = Number L ; * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@int64@@ ) = Number L ; free ( ( void * ) @@int64@@ [ Number ] ) ; * @@QWORD@@ = @@int64@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@int64@@ ; return @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_207028 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall full_write ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = Number L ; while ( @@int64@@ ) { @@int64@@ = safe_write ( @@unsignedint@@ , @@int64@@ , @@int64@@ ) ; if ( @@int64@@ == Number ) break ; if ( ! @@int64@@ ) { * __errno_location ( ) = Number ; return @@int64@@ ; } @@int64@@ += @@int64@@ ; @@int64@@ += @@int64@@ ; @@int64@@ -= @@int64@@ ; } return @@int64@@ ; }
unsigned __int64 __fastcall triple_hash_no_name ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) % @@unsignedint64@@ ; }
_BYTE * __fastcall strmode ( __int16 @@int16@@ , _BYTE * @@BYTE@@ ) { char @@char@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; _BYTE * @@BYTE@@ ; * @@BYTE@@ = ftypelet ( @@int16@@ ) ; if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) { if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; } else if ( ( @@int16@@ & Number ) != Number ) { @@char@@ = Number ; } else { @@char@@ = Number ; } @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) { if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; } else if ( ( @@int16@@ & Number ) != Number ) { @@char@@ = Number ; } else { @@char@@ = Number ; } @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) { if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; } else if ( ( @@int16@@ & Number ) != Number ) { @@char@@ = Number ; } else { @@char@@ = Number ; } @@BYTE@@ [ Number ] = @@char@@ ; @@BYTE@@ [ Number ] = Number ; @@BYTE@@ = @@BYTE@@ + Number ; @@BYTE@@ [ Number ] = Number ; return @@BYTE@@ ; }
_BOOL8 __fastcall dot_or_dotdot ( _BYTE * @@BYTE@@ ) { __int64 @@int64@@ ; char @@char@@ ; if ( * @@BYTE@@ != Number ) return Number L ; if ( @@BYTE@@ [ Number ] == Number ) @@int64@@ = Number L ; else @@int64@@ = Number L ; @@char@@ = @@BYTE@@ [ @@int64@@ ] ; return ! @@char@@ || @@char@@ == Number ; }
int __fastcall call_fclose ( FILE * @@FILE@@ ) { int @@int@@ ; if ( @@FILE@@ ) @@int@@ = fclose ( @@FILE@@ ) ; return @@int@@ ; }
_BOOL8 __fastcall triple_compare ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ ) { return @@QWORD@@ [ Number ] == @@QWORD@@ [ Number ] && @@QWORD@@ [ Number ] == @@QWORD@@ [ Number ] && ( unsigned __int8 ) same_name ( * @@QWORD@@ , * @@QWORD@@ ) ; }
__int64 __fastcall cache_stat_init ( __int64 @@int64@@ ) { * ( _QWORD * ) ( @@int64@@ + Number ) = Number ; return @@int64@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
_BOOL8 __fastcall ignorable_missing ( _BYTE * @@BYTE@@ , int @@int@@ ) { return * @@BYTE@@ && nonexistent_file_errno ( @@int@@ ) ; }
size_t __fastcall fts_maxarglen ( const char * * @@constchar@@ ) { size_t @@sizet@@ ; size_t @@sizet@@ ; @@sizet@@ = Number L ; while ( * @@constchar@@ ) { @@sizet@@ = strlen ( * @@constchar@@ ) ; if ( @@sizet@@ > @@sizet@@ ) @@sizet@@ = @@sizet@@ ; ++ @@constchar@@ ; } return @@sizet@@ + Number ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
unsigned __int64 __fastcall hash_get_max_bucket_length ( __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = Number L ; for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { @@QWORD@@ = @@QWORD@@ ; for ( @@unsignedint64@@ = Number L ; ; ++ @@unsignedint64@@ ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; if ( ! @@QWORD@@ ) break ; } if ( @@unsignedint64@@ > @@unsignedint64@@ ) @@unsignedint64@@ = @@unsignedint64@@ ; } } return @@unsignedint64@@ ; }
__int64 __fastcall mark_ancestor_dirs ( __int64 @@int64@@ ) { __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; for ( @@QWORD@@ = * ( _QWORD * * ) ( @@int64@@ + Number ) ; ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { @@int64@@ = @@QWORD@@ [ Number ] ; if ( @@int64@@ < Number ) break ; @@int64@@ = @@QWORD@@ [ Number ] ; if ( @@int64@@ ) break ; @@QWORD@@ [ Number ] = Number L ; } return @@int64@@ ; }
unsigned __int64 __fastcall buffer_lcm ( unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@unsignedint64@@ ) { if ( @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ ; for ( @@unsignedint64@@ = @@unsignedint64@@ ; ; @@unsignedint64@@ = @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ % @@unsignedint64@@ ; if ( ! ( @@unsignedint64@@ % @@unsignedint64@@ ) ) break ; @@unsignedint64@@ = @@unsignedint64@@ ; } if ( @@unsignedint64@@ * ( @@unsignedint64@@ / @@unsignedint64@@ ) <= @@unsignedint64@@ && @@unsignedint64@@ / @@unsignedint64@@ == @@unsignedint64@@ * ( @@unsignedint64@@ / @@unsignedint64@@ ) / @@unsignedint64@@ ) { return @@unsignedint64@@ * ( @@unsignedint64@@ / @@unsignedint64@@ ) ; } } @@unsignedint64@@ = @@unsignedint64@@ ; } else { if ( @@unsignedint64@@ ) @@int64@@ = @@unsignedint64@@ ; else @@int64@@ = Number ; @@unsignedint64@@ = @@int64@@ ; } @@unsignedint64@@ = @@unsignedint64@@ ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) @@unsignedint64@@ = @@unsignedint64@@ ; return @@unsignedint64@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
unsigned __int64 __fastcall gcd ( unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; do { @@unsignedint64@@ = @@unsignedint64@@ % @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint64@@ ; } while ( @@unsignedint64@@ ) ; return @@unsignedint64@@ ; }
void * __fastcall mdir_name ( _BYTE * @@BYTE@@ ) { _BYTE * @@BYTE@@ ; void * @@void@@ ; @@BYTE@@ = dir_len ( @@BYTE@@ ) ; @@void@@ = malloc ( ( size_t ) & @@BYTE@@ [ ( @@BYTE@@ == Number L ) + Number ] ) ; if ( ! @@void@@ ) return Number L ; memcpy ( @@void@@ , @@BYTE@@ , ( size_t ) @@BYTE@@ ) ; if ( ! @@BYTE@@ ) { @@BYTE@@ = ( _BYTE * ) ( & dword_0 + Number ) ; * ( _BYTE * ) @@void@@ = Number ; } @@BYTE@@ [ ( _QWORD ) @@void@@ ] = Number ; return @@void@@ ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
__int64 __fastcall dir_name ( __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = mdir_name ( @@int64@@ ) ; if ( ! @@int64@@ ) xalloc_die ( ) ; return @@int64@@ ; }
__int64 __fastcall hash_get_first ( unsigned __int64 * @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; if ( ! @@unsignedint64@@ [ Number ] ) return Number L ; for ( @@unsignedint64@@ = * @@unsignedint64@@ ; ; @@unsignedint64@@ += Number L ) { if ( @@unsignedint64@@ >= @@unsignedint64@@ [ Number ] ) abort ( ) ; if ( * ( _QWORD * ) @@unsignedint64@@ ) break ; } return * ( _QWORD * ) @@unsignedint64@@ ; }
void * __fastcall mfile_name_concat ( _BYTE * @@BYTE@@ , _BYTE * @@BYTE@@ , _QWORD * @@QWORD@@ ) { _BOOL4 @@BOOL4@@ ; const char * @@constchar@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; _BOOL8 @@BOOL8@@ ; char * @@char@@ ; size_t @@sizet@@ ; void * @@void@@ ; _BYTE * @@BYTE@@ ; char * @@char@@ ; @@constchar@@ = last_component ( @@BYTE@@ ) ; @@sizet@@ = base_len ( @@constchar@@ ) ; @@sizet@@ = @@constchar@@ - @@BYTE@@ + @@sizet@@ ; @@BOOL4@@ = @@sizet@@ && @@constchar@@ [ @@sizet@@ - Number ] != Number ; @@BOOL8@@ = @@BOOL4@@ ; @@char@@ = longest_relative_suffix ( @@BYTE@@ ) ; @@sizet@@ = strlen ( @@char@@ ) ; @@void@@ = malloc ( @@BOOL8@@ + @@sizet@@ + @@sizet@@ + Number ) ; if ( ! @@void@@ ) return Number L ; @@BYTE@@ = mempcpy ( @@void@@ , @@BYTE@@ , @@sizet@@ ) ; * @@BYTE@@ = Number ; @@char@@ = & @@BYTE@@ [ @@BOOL8@@ ] ; if ( @@QWORD@@ ) * @@QWORD@@ = & @@char@@ [ - ( * @@BYTE@@ == Number ) ] ; * ( _BYTE * ) mempcpy ( @@char@@ , @@char@@ , @@sizet@@ ) = Number ; return @@void@@ ; }
__int64 __fastcall io_blksize ( __int64 a1 , __int64 a2 , __int64 a3 , __int64 a4 , __int64 a5 , __int64 a6 , int a7 , int a8 , int a9 , int a10 , int a11 , int a12 , int a13 , __int64 @@int64@@ ) { __int64 @@int64@@ ; if ( @@int64@@ <= Number || ( unsigned __int64 ) @@int64@@ > Number || @@int64@@ <= Number ) { @@int64@@ = Number ; } else { @@int64@@ = @@int64@@ ; } return @@int64@@ ; }
__int64 __fastcall ftypelet ( __int16 @@int16@@ ) { switch ( @@int16@@ & Number ) { case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; } return Number L ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
unsigned __int64 __fastcall hash_string ( _BYTE * @@BYTE@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = Number L ; while ( * @@BYTE@@ ) @@unsignedint64@@ = ( Number * @@unsignedint64@@ + ( unsigned __int8 ) * @@BYTE@@ ++ ) % @@unsignedint64@@ ; return @@unsignedint64@@ ; }
__int64 __fastcall diropen ( __int64 @@int64@@ , int @@int@@ , __int64 a3 , int @@int@@ , int @@int@@ , int @@int@@ ) { int @@int@@ ; int @@int@@ ; unsigned int @@unsignedint@@ ; @@int@@ = ( * ( _DWORD * ) ( @@int64@@ + Number ) << Number ) & Number | Number ; if ( ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number ) @@int@@ = openat_safer ( * ( _DWORD * ) ( @@int64@@ + Number ) , @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int@@ ) ; else @@int@@ = open_safer ( @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int@@ ) ; @@unsignedint@@ = @@int@@ ; if ( @@int@@ >= Number ) set_cloexec_flag ( ( unsigned int ) @@int@@ , Number L ) ; return @@unsignedint@@ ; }
__int64 __fastcall file_name_concat ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = mfile_name_concat ( @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( ! @@int64@@ ) xalloc_die ( ) ; return @@int64@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall fts_compar ( __int64 @@int64@@ , __int64 @@int64@@ ) { return ( * ( __int64 ( __fastcall * * ) ( __int64 , __int64 ) ) ( * ( _QWORD * ) ( * ( _QWORD * ) @@int64@@ + Number L ) + Number L ) ) ( @@int64@@ , @@int64@@ ) ; }
_BYTE * __fastcall longest_relative_suffix ( _BYTE * @@BYTE@@ ) { while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; return @@BYTE@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
bool __fastcall is_prime ( unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = Number L ; @@unsignedint64@@ = Number L ; while ( @@unsignedint64@@ < @@unsignedint64@@ && @@unsignedint64@@ % @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@unsignedint64@@ += Number * @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint64@@ + Number ; } return @@unsignedint64@@ % @@unsignedint64@@ != Number ; }
__int64 __fastcall set_owner ( __int64 @@int64@@ , const char * @@constchar@@ , unsigned int @@unsignedint@@ , _DWORD * @@DWORD@@ , char @@char@@ , __int64 @@int64@@ ) { int @@int@@ ; unsigned __int16 @@unsignedint16@@ ; __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; __uid_t @@uidt@@ ; __gid_t @@gidt@@ ; int @@int@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; int @@int@@ ; @@uidt@@ = @@DWORD@@ [ Number ] ; @@gidt@@ = @@DWORD@@ [ Number ] ; if ( @@char@@ != Number && ( * ( _BYTE * ) ( @@int64@@ + Number ) || * ( _BYTE * ) ( @@int64@@ + Number ) || * ( _BYTE * ) ( @@int64@@ + Number ) ) && ( ( @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) , ! * ( _BYTE * ) ( @@int64@@ + Number ) ) && ! * ( _BYTE * ) ( @@int64@@ + Number ) ? ( @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) ) : ( @@int@@ = @@DWORD@@ [ Number ] ) , ( @@unsignedint@@ = ( unsigned __int16 ) @@int@@ & ( unsigned __int16 ) @@int@@ & Number , @@unsignedint16@@ = ~ ( _WORD ) @@int@@ , HIBYTE ( @@unsignedint16@@ ) |= Number , ( ( unsigned __int16 ) @@int@@ & @@unsignedint16@@ & Number ) != Number ) && ( unsigned int ) qset_acl ( @@constchar@@ , @@unsignedint@@ , @@unsignedint@@ ) ) ) { if ( ( unsigned __int8 ) owner_failure_ok ( @@int64@@ ) != Number ) { @@int64@@ = quote ( @@constchar@@ ) ; @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ , @@int64@@ ) ; } @@int64@@ = ( unsigned int ) - * ( unsigned __int8 * ) ( @@int64@@ + Number ) ; } else { if ( @@unsignedint@@ == Number ) { if ( ! lchown ( @@constchar@@ , @@uidt@@ , @@gidt@@ ) ) return Number L ; if ( * __errno_location ( ) == Number || * __errno_location ( ) == Number ) { @@int@@ = * __errno_location ( ) ; lchown ( @@constchar@@ , Number , @@gidt@@ ) ; ignore_value ( ) ; * __errno_location ( ) = @@int@@ ; } } else { if ( ! fchown ( @@unsignedint@@ , @@uidt@@ , @@gidt@@ ) ) return Number L ; if ( * __errno_location ( ) == Number || * __errno_location ( ) == Number ) { @@int@@ = * __errno_location ( ) ; fchown ( @@unsignedint@@ , Number , @@gidt@@ ) ; ignore_value ( ) ; * __errno_location ( ) = @@int@@ ; } } if ( ( unsigned __int8 ) chown_failure_ok ( @@int64@@ ) != Number && ( @@int64@@ = quote ( @@constchar@@ ) , @@char@@ = gettext ( String ) , @@int@@ = __errno_location ( ) , error ( Number , * @@int@@ , @@char@@ , @@int64@@ ) , * ( _BYTE * ) ( @@int64@@ + Number ) ) ) { @@int64@@ = Number ; } else { @@int64@@ = Number L ; } } return @@int64@@ ; }
_BOOL8 __fastcall AD_compare ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ ) { return @@QWORD@@ [ Number ] == @@QWORD@@ [ Number ] && * @@QWORD@@ == * @@QWORD@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
void * __fastcall allocate_entry ( __int64 @@int64@@ ) { __int64 @@int64@@ ; if ( ! * ( _QWORD * ) ( @@int64@@ + Number ) ) return malloc ( Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; return ( void * ) @@int64@@ ; }
unsigned __int64 __fastcall AD_hash ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) % @@unsignedint64@@ ; }
__int64 __fastcall fts_sort ( __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { size_t @@sizet@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; int ( * @ @ VAR_1403 @ @ int ( ) ( constvoid , constvoid ) @ @ int ( ) ( constvoid , constvoid ) ) ( const void * , const void * ) ; void * @@void@@ ; @@sizet@@ = @@sizet@@ ; @ @ VAR_1403 @ @ int ( ) ( constvoid , constvoid ) @ @ int ( ) ( constvoid , constvoid ) = * ( int ( * * ) ( const void * , const void * ) ) ( @@int64@@ + Number ) ; if ( @@sizet@@ > * ( _QWORD * ) ( @@int64@@ + Number ) ) { * ( _QWORD * ) ( @@int64@@ + Number ) = @@sizet@@ + Number ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) > Number || ( @@void@@ = realloc ( * ( void * * ) ( @@int64@@ + Number ) , Number L * * ( _QWORD * ) ( @@int64@@ + Number ) ) ) == Number L ) { free ( * ( void * * ) ( @@int64@@ + Number ) ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number L ; return @@int64@@ ; } * ( _QWORD * ) ( @@int64@@ + Number ) = @@void@@ ; } @@QWORD@@ = * ( _QWORD * * ) ( @@int64@@ + Number ) ; for ( @@int64@@ = @@int64@@ ; @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ) { @@QWORD@@ = @@QWORD@@ ++ ; * @@QWORD@@ = @@int64@@ ; } qsort ( * ( void * * ) ( @@int64@@ + Number ) , @@sizet@@ , Number , @ @ VAR_1403 @ @ int ( ) ( constvoid , constvoid ) @ @ int ( ) ( constvoid , constvoid ) ) ; @@QWORD@@ = * ( _QWORD * * ) ( @@int64@@ + Number ) ; @@int64@@ = * @@QWORD@@ ; while ( -- @@sizet@@ ) { * ( _QWORD * ) ( * @@QWORD@@ + Number L ) = @@QWORD@@ [ Number ] ; ++ @@QWORD@@ ; } * ( _QWORD * ) ( * @@QWORD@@ + Number L ) = Number L ; return @@int64@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
__int64 __fastcall hash_get_n_buckets ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 __fastcall free_entry ( __int64 @@int64@@ , _QWORD * @@QWORD@@ ) { __int64 @@int64@@ ; * @@QWORD@@ = Number L ; @@QWORD@@ [ Number ] = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@QWORD@@ ; return @@int64@@ ; }
__int64 __fastcall enter_dir ( __int64 @@int64@@ , __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; if ( ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number ) { @@QWORD@@ = malloc ( Number ) ; if ( ! @@QWORD@@ ) return Number L ; * @@QWORD@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ [ Number ] = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = hash_insert ( * ( _QWORD * ) ( @@int64@@ + Number ) , @@QWORD@@ ) ; if ( ( _QWORD * ) @@int64@@ != @@QWORD@@ ) { free ( @@QWORD@@ ) ; if ( ! @@int64@@ ) return Number L ; * ( _QWORD * ) @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _WORD * ) ( @@int64@@ + Number ) = Number ; } } else if ( ( unsigned __int8 ) cycle_check ( * ( _QWORD * ) ( @@int64@@ + Number ) , @@int64@@ + Number ) ) { * ( _QWORD * ) @@int64@@ = @@int64@@ ; * ( _WORD * ) ( @@int64@@ + Number ) = Number ; } return Number L ; }
bool __fastcall seen_file ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 * @@int64@@ ) { __int64 @@int644@@ [ Number ] ; @@int644@@ [ Number ] = __readfsqword ( Number ) ; if ( ! @@int64@@ ) return Number ; @@int644@@ [ Number ] = @@int64@@ ; @@int644@@ [ Number ] = @@int64@@ [ Number ] ; @@int644@@ [ Number ] = * @@int64@@ ; return hash_lookup ( @@int64@@ , @@int644@@ ) != Number ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall hash_get_n_buckets_used ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
unsigned __int64 __fastcall LCO_hash ( _QWORD * @@QWORD@@ , unsigned __int64 @@unsignedint64@@ ) { return * @@QWORD@@ % @@unsignedint64@@ ; }
__int64 __fastcall hash_get_n_entries ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 __fastcall transfer_entries ( __int64 @@int64@@ , __int64 @@int64@@ , char @@char@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 * @@int64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; for ( @@int64@@ = * ( __int64 * * ) @@int64@@ ; ( unsigned __int64 ) @@int64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ += Number ) { if ( * @@int64@@ ) { for ( @@QWORD@@ = ( _QWORD * ) @@int64@@ [ Number ] ; @@QWORD@@ ; @@QWORD@@ = @@QWORD@@ ) { @@int64@@ = * @@QWORD@@ ; @@int64@@ = * ( _QWORD * ) @@int64@@ ; @@QWORD@@ = ( _QWORD * ) ( @@int64@@ + Number * ( * ( __int64 ( __fastcall * * ) ( _QWORD , _QWORD ) ) ( @@int64@@ + Number ) ) ( * @@QWORD@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@QWORD@@ >= * ( _QWORD * ) ( @@int64@@ + Number ) ) abort ( ) ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; if ( * @@QWORD@@ ) { @@QWORD@@ [ Number ] = @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = @@QWORD@@ ; } else { * @@QWORD@@ = @@int64@@ ; ++ * ( _QWORD * ) ( @@int64@@ + Number ) ; free_entry ( @@int64@@ , @@QWORD@@ ) ; } } @@int64@@ = * @@int64@@ ; @@int64@@ [ Number ] = Number L ; if ( ! @@char@@ ) { @@int64@@ = * ( _QWORD * ) @@int64@@ ; @@QWORD@@ = ( _QWORD * ) ( @@int64@@ + Number * ( * ( __int64 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@int64@@ + Number ) ) ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@QWORD@@ >= * ( _QWORD * ) ( @@int64@@ + Number ) ) abort ( ) ; if ( * @@QWORD@@ ) { @@QWORD@@ = allocate_entry ( @@int64@@ ) ; if ( ! @@QWORD@@ ) return Number L ; * @@QWORD@@ = @@int64@@ ; @@QWORD@@ [ Number ] = @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = @@QWORD@@ ; } else { * @@QWORD@@ = @@int64@@ ; ++ * ( _QWORD * ) ( @@int64@@ + Number ) ; } * @@int64@@ = Number L ; -- * ( _QWORD * ) ( @@int64@@ + Number ) ; } } } return Number L ; }
__int64 __fastcall xnmalloc ( unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { if ( ! is_mul_ok ( @@unsignedint64@@ , @@unsignedint64@@ ) ) xalloc_die ( ) ; return xmalloc ( @@unsignedint64@@ * @@unsignedint64@@ ) ; }
unsigned __int64 __fastcall triple_hash ( _QWORD * @@QWORD@@ , unsigned __int64 @@unsignedint64@@ ) { return ( ( unsigned __int64 ) hash_pjw ( * @@QWORD@@ , @@unsignedint64@@ ) ^ @@QWORD@@ [ Number ] ) % @@unsignedint64@@ ; }
bool __fastcall LCO_compare ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ ) { return * @@QWORD@@ == * @@QWORD@@ ; }
_BOOL8 __fastcall hash_table_ok ( __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; @@int64@@ = Number L ; @@int64@@ = Number L ; for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { @@QWORD@@ = @@QWORD@@ ; ++ @@int64@@ ; ++ @@int64@@ ; while ( Number ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; if ( ! @@QWORD@@ ) break ; ++ @@int64@@ ; } } } return @@int64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) && @@int64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ ) { return xmalloc ( @@int64@@ ) ; }
_BOOL8 __fastcall triple_compare_ino_str ( __int64 @@int64@@ , __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) == * ( _QWORD * ) ( @@int64@@ + Number ) && * ( _QWORD * ) ( @@int64@@ + Number ) == * ( _QWORD * ) ( @@int64@@ + Number ) && ! strcmp ( * ( const char * * ) @@int64@@ , * ( const char * * ) @@int64@@ ) ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
void * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
unsigned __int64 __fastcall hash_get_entries ( __int64 @@int64@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; @@unsignedint64@@ = Number L ; for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { for ( @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { if ( @@unsignedint64@@ >= @@unsignedint64@@ ) return @@unsignedint64@@ ; @@int64@@ = @@unsignedint64@@ ++ ; * ( _QWORD * ) ( @@int64@@ + Number * @@int64@@ ) = * @@QWORD@@ ; } } } return @@unsignedint64@@ ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
unsigned __int64 __fastcall check_extension ( const char * @@constchar@@ , __int64 @@int64@@ , char @@char@@ ) { unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; char * @@char@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int16 @@int16@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@char@@ = ( char * ) last_component ( @@constchar@@ ) ; @@unsignedint64@@ = base_len ( @@char@@ ) ; @@unsignedint64@@ = Number L ; if ( @@unsignedint64@@ > Number ) { @@int16@@ = * ( _WORD * ) @@char@@ ; * ( _WORD * ) @@char@@ = Number ; * __errno_location ( ) = Number ; @@int64@@ = pathconf ( @@constchar@@ , Number ) ; if ( @@int64@@ >= Number || ! * __errno_location ( ) ) @@unsignedint64@@ = @@int64@@ ; * ( _WORD * ) @@char@@ = @@int16@@ ; } if ( @@unsignedint64@@ < @@unsignedint64@@ ) { @@unsignedint64@@ = & @@constchar@@ [ @@int64@@ ] - @@char@@ ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) @@unsignedint64@@ = @@unsignedint64@@ - Number ; @@char@@ [ @@unsignedint64@@ ] = @@char@@ ; @@char@@ [ @@unsignedint64@@ + Number ] = Number ; } return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall link_count_optimize_ok ( __int64 @@int64@@ ) { __int64 @@int64@@ ; bool @@bool@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; _BYTE * @@BYTE@@ ; __int64 @@int644@@ [ Number ] ; @@int644@@ [ Number ] = __readfsqword ( Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) == Number ) return Number L ; if ( ! @@int64@@ ) { * ( _QWORD * ) ( @@int64@@ + Number ) = hash_initialize ( Number L , Number L , LCO_hash , LCO_compare , & free ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( ! @@int64@@ ) return Number L ; } @@int644@@ [ Number ] = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = hash_lookup ( @@int64@@ , @@int644@@ ) ; if ( @@int64@@ ) return * ( unsigned __int8 * ) ( @@int64@@ + Number ) ; @@BYTE@@ = malloc ( Number ) ; if ( ! @@BYTE@@ ) return Number L ; @@bool@@ = leaf_optimization_applies ( * ( _DWORD * ) ( @@int64@@ + Number ) ) ; @@BYTE@@ [ Number ] = @@bool@@ ; * ( _QWORD * ) @@BYTE@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = hash_insert ( @@int64@@ , @@BYTE@@ ) ; if ( @@int64@@ ) { if ( ( _BYTE * ) @@int64@@ != @@BYTE@@ ) abort ( ) ; @@int64@@ = @@bool@@ ; } else { free ( @@BYTE@@ ) ; @@int64@@ = Number L ; } return @@int64@@ ; }
void * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
unsigned __int64 __fastcall raw_hasher ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { return rotr_sz ( @@int64@@ , Number ) % @@unsignedint64@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
_BYTE * __fastcall dir_len ( _BYTE * @@BYTE@@ ) { _BYTE * @@BYTE@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = * @@BYTE@@ == Number ; for ( @@BYTE@@ = ( _BYTE * ) ( last_component ( @@BYTE@@ ) - @@BYTE@@ ) ; @@unsignedint64@@ < ( unsigned __int64 ) @@BYTE@@ && @@BYTE@@ [ ( _QWORD ) ( @@BYTE@@ - Number ) ] == Number ; -- @@BYTE@@ ) { ; } return @@BYTE@@ ; }
void * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 __fastcall hash_do_for_each ( __int64 @@int64@@ , unsigned __int8 ( __fastcall * @ @ VAR_1494 @ @ unsignedint8 ( fastcall ) ( QWORD , int64 ) @ @ Hashprocessor ) ( _QWORD , __int64 ) , __int64 @@int64@@ ) { __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; @@int64@@ = Number L ; for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { for ( @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { if ( @ @ VAR_1494 @ @ unsignedint8 ( fastcall ) ( QWORD , int64 ) @ @ Hashprocessor ( * @@QWORD@@ , @@int64@@ ) != Number ) return @@int64@@ ; ++ @@int64@@ ; } } } return @@int64@@ ; }
size_t * __fastcall hash_initialize ( __int64 @@int64@@ , void * @@void@@ , unsigned __int64 ( __fastcall * @ @ VAR_1524 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ) ( __int64 a1 , unsigned __int64 a2 ) , bool ( __fastcall * @ @ VAR_1526 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ) ( __int64 a1 , __int64 a2 ) , size_t @@sizet@@ ) { size_t * @@sizet@@ ; bool ( __fastcall * @ @ VAR_1525 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ) ( __int64 , __int64 ) ; unsigned __int64 ( __fastcall * @ @ VAR_1523 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ) ( __int64 , unsigned __int64 ) ; void * @@void@@ ; size_t * @@sizet@@ ; @@void@@ = @@void@@ ; @ @ VAR_1523 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher = @ @ VAR_1524 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ; @ @ VAR_1525 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator = @ @ VAR_1526 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ; if ( ! @ @ VAR_1524 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ) @ @ VAR_1523 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher = raw_hasher ; if ( ! @ @ VAR_1526 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ) @ @ VAR_1525 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator = raw_comparator ; @@sizet@@ = ( size_t * ) malloc ( Number ) ; if ( ! @@sizet@@ ) return Number L ; if ( ! @@void@@ ) @@void@@ = & default_tuning ; @@sizet@@ [ Number ] = ( size_t ) @@void@@ ; if ( ( unsigned __int8 ) check_tuning ( ( __int64 ) @@sizet@@ ) == Number && ( @@sizet@@ [ Number ] = compute_bucket_size ( @@int64@@ , ( __int64 ) @@void@@ ) ) != Number && ( * @@sizet@@ = ( size_t ) calloc ( @@sizet@@ [ Number ] , Number ) ) != Number ) { @@sizet@@ [ Number ] = Number * @@sizet@@ [ Number ] + * @@sizet@@ ; @@sizet@@ [ Number ] = Number L ; @@sizet@@ [ Number ] = Number L ; @@sizet@@ [ Number ] = ( size_t ) @ @ VAR_1523 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ; @@sizet@@ [ Number ] = ( size_t ) @ @ VAR_1525 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ; @@sizet@@ [ Number ] = @@sizet@@ ; @@sizet@@ [ Number ] = Number L ; @@sizet@@ = @@sizet@@ ; } else { free ( @@sizet@@ ) ; @@sizet@@ = Number L ; } return @@sizet@@ ; }
_BYTE * __fastcall filemodestring ( __int64 @@int64@@ , _BYTE * @@BYTE@@ ) { return strmode ( * ( _DWORD * ) ( @@int64@@ + Number ) , @@BYTE@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
void * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall check_tuning ( __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( ( _UNKNOWN * ) @@int64@@ == & default_tuning ) return Number L ; if ( * ( float * ) ( @@int64@@ + Number ) > Number && ( float ) ( Number - Number ) > * ( float * ) ( @@int64@@ + Number ) && * ( float * ) ( @@int64@@ + Number ) > ( float ) ( Number + Number ) && * ( float * ) @@int64@@ >= Number && * ( float * ) ( @@int64@@ + Number ) > ( float ) ( * ( float * ) @@int64@@ + Number ) && * ( float * ) ( @@int64@@ + Number ) <= Number && * ( float * ) ( @@int64@@ + Number ) > ( float ) ( * ( float * ) @@int64@@ + Number ) ) { return Number L ; } * ( _QWORD * ) ( @@int64@@ + Number ) = & default_tuning ; return Number L ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall i_ring_push ( __int64 @@int64@@ , int @@int@@ ) { int @@int@@ ; unsigned int @@unsignedint@@ ; @@int@@ = ( ( unsigned __int8 ) * ( _DWORD * ) ( @@int64@@ + Number ) + ( * ( _BYTE * ) ( @@int64@@ + Number ) ^ Number ) ) & Number ; @@unsignedint@@ = * ( _DWORD * ) ( @@int64@@ + Number L * ( ( ( unsigned __int8 ) * ( _DWORD * ) ( @@int64@@ + Number ) + ( * ( _BYTE * ) ( @@int64@@ + Number ) ^ Number ) ) & Number ) ) ; * ( _DWORD * ) ( @@int64@@ + Number L * ( ( ( unsigned __int8 ) * ( _DWORD * ) ( @@int64@@ + Number ) + ( * ( _BYTE * ) ( @@int64@@ + Number ) ^ Number ) ) & Number ) ) = @@int@@ ; * ( _DWORD * ) ( @@int64@@ + Number ) = @@int@@ ; if ( @@int@@ == * ( _DWORD * ) ( @@int64@@ + Number ) ) * ( _DWORD * ) ( @@int64@@ + Number ) = ( ( unsigned __int8 ) * ( _DWORD * ) ( @@int64@@ + Number ) + ( * ( _BYTE * ) ( @@int64@@ + Number ) ^ Number ) ) & Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = Number ; return @@unsignedint@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
unsigned __int64 __fastcall leave_dir ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 * @@int64@@ ; __int64 * @@int64@@ ; void * @@void@@ ; __int64 @@int643@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = ( __int64 * ) ( @@int64@@ + Number ) ; if ( ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number ) { @@int643@@ [ Number ] = * @@int64@@ ; @@int643@@ [ Number ] = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@void@@ = ( void * ) hash_delete ( * ( _QWORD * ) ( @@int64@@ + Number ) , @@int643@@ ) ; if ( ! @@void@@ ) abort ( ) ; free ( @@void@@ ) ; } else { @@int64@@ = * ( __int64 * * ) ( @@int64@@ + Number ) ; if ( @@int64@@ && @@int64@@ [ Number ] >= Number ) { if ( ! * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) ) abort ( ) ; if ( * * ( _QWORD * * ) ( @@int64@@ + Number ) == * ( _QWORD * ) ( @@int64@@ + Number ) && * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) == * @@int64@@ ) { * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) = @@int64@@ [ Number ] ; * * ( _QWORD * * ) ( @@int64@@ + Number ) = @@int64@@ [ Number ] ; } } } return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
void * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_21B128 ; @@int648@@ [ Number ] = qword_21B130 ; @@int648@@ [ Number ] = qword_21B138 ; @@int648@@ [ Number ] = qword_21B140 ; @@int648@@ [ Number ] = qword_21B148 ; @@int648@@ [ Number ] = qword_21B150 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
__int64 __fastcall hash_find_entry ( __int64 @@int64@@ , __int64 @@int64@@ , _QWORD * @@QWORD@@ , char @@char@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; @@int64@@ = * ( _QWORD * ) @@int64@@ ; @@QWORD@@ = ( _QWORD * ) ( @@int64@@ + Number * ( * ( __int64 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@int64@@ + Number ) ) ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@QWORD@@ >= * ( _QWORD * ) ( @@int64@@ + Number ) ) abort ( ) ; * @@QWORD@@ = @@QWORD@@ ; if ( ! * @@QWORD@@ ) return Number L ; if ( @@int64@@ == * @@QWORD@@ || ( * ( unsigned __int8 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@int64@@ + Number ) ) ( @@int64@@ , * @@QWORD@@ ) ) { @@int64@@ = * @@QWORD@@ ; if ( @@char@@ ) { if ( @@QWORD@@ [ Number ] ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; @@int64@@ = @@QWORD@@ [ Number ] ; * @@QWORD@@ = * @@QWORD@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; free_entry ( @@int64@@ , @@QWORD@@ ) ; } else { * @@QWORD@@ = Number L ; } } @@int64@@ = @@int64@@ ; } else { for ( @@QWORD@@ = @@QWORD@@ ; ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { if ( ! @@QWORD@@ [ Number ] ) return Number L ; if ( @@int64@@ == * ( _QWORD * ) @@QWORD@@ [ Number ] || ( * ( unsigned __int8 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@int64@@ + Number ) ) ( @@int64@@ , * ( _QWORD * ) @@QWORD@@ [ Number ] ) ) { break ; } } @@int64@@ = * ( _QWORD * ) @@QWORD@@ [ Number ] ; if ( @@char@@ ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = @@QWORD@@ [ Number ] ; free_entry ( @@int64@@ , @@QWORD@@ ) ; } @@int64@@ = @@int64@@ ; } return @@int64@@ ; }
__int64 __fastcall open_safer ( const char * @@constchar@@ , char @@char@@ , unsigned int @@unsignedint@@ ) { unsigned int @@unsignedint@@ ; unsigned int @@unsignedint@@ ; @@unsignedint@@ = Number ; if ( ( @@char@@ & Number ) != Number ) @@unsignedint@@ = @@unsignedint@@ ; @@unsignedint@@ = open ( @@constchar@@ , @@char@@ , @@unsignedint@@ ) ; return fd_safer ( @@unsignedint@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_2070C8 ; @@int648@@ [ Number ] = qword_2070D0 ; @@int648@@ [ Number ] = qword_2070D8 ; @@int648@@ [ Number ] = qword_2070E0 ; @@int648@@ [ Number ] = qword_2070E8 ; @@int648@@ [ Number ] = qword_2070F0 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
__int64 __fastcall get_stat_atime_ns ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 __fastcall fts_palloc ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; void * @@void@@ ; @@unsignedint64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) + @@int64@@ + Number ; if ( @@unsignedint64@@ >= * ( _QWORD * ) ( @@int64@@ + Number ) ) { * ( _QWORD * ) ( @@int64@@ + Number ) = @@unsignedint64@@ ; @@void@@ = realloc ( * ( void * * ) ( @@int64@@ + Number ) , * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( @@void@@ ) { * ( _QWORD * ) ( @@int64@@ + Number ) = @@void@@ ; @@int64@@ = Number L ; } else { free ( * ( void * * ) ( @@int64@@ + Number ) ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number L ; @@int64@@ = Number L ; } } else { free ( * ( void * * ) ( @@int64@@ + Number ) ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number L ; * __errno_location ( ) = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return xmalloc ( @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall get_stat_ctime_ns ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 __fastcall openat_safer ( int @@int@@ , const char * @@constchar@@ , char @@char@@ , unsigned int @@unsignedint@@ ) { unsigned int @@unsignedint@@ ; unsigned int @@unsignedint@@ ; @@unsignedint@@ = Number ; if ( ( @@char@@ & Number ) != Number ) @@unsignedint@@ = @@unsignedint@@ ; @@unsignedint@@ = openat ( @@int@@ , @@constchar@@ , @@char@@ , @@unsignedint@@ ) ; return fd_safer ( @@unsignedint@@ ) ; }
__int64 __fastcall linkat_follow ( unsigned int @@unsignedint@@ , _BYTE * @@BYTE@@ , int @@int@@ , const char * @@constchar@@ ) { __int64 @@int64@@ ; int @@int@@ ; int @@int@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; @@BYTE@@ = @@BYTE@@ ; @@int@@ = Number ; while ( @@int@@ -- ) { @@BYTE@@ = ( _BYTE * ) areadlinkat ( @@unsignedint@@ , @@BYTE@@ ) ; if ( ! @@BYTE@@ ) break ; if ( * @@BYTE@@ == Number ) { if ( @@BYTE@@ != @@BYTE@@ ) free ( @@BYTE@@ ) ; @@BYTE@@ = @@BYTE@@ ; } else { @@BYTE@@ = mdir_name ( @@BYTE@@ ) ; if ( @@BYTE@@ != @@BYTE@@ ) free ( @@BYTE@@ ) ; if ( ! @@BYTE@@ ) { free ( @@BYTE@@ ) ; * __errno_location ( ) = Number ; return Number ; } @@BYTE@@ = mfile_name_concat ( @@BYTE@@ , @@BYTE@@ , Number L ) ; free ( @@BYTE@@ ) ; free ( @@BYTE@@ ) ; if ( ! @@BYTE@@ ) { * __errno_location ( ) = Number ; return Number ; } } } if ( @@int@@ < Number ) { @@BYTE@@ = Number L ; * __errno_location ( ) = Number ; } if ( @@BYTE@@ || * __errno_location ( ) == Number ) { @@unsignedint@@ = linkat ( @@unsignedint@@ , @@BYTE@@ , @@int@@ , @@constchar@@ , Number ) ; if ( @@BYTE@@ != @@BYTE@@ ) { @@int@@ = * __errno_location ( ) ; free ( @@BYTE@@ ) ; * __errno_location ( ) = @@int@@ ; } @@int64@@ = @@unsignedint@@ ; } else { if ( @@BYTE@@ != @@BYTE@@ ) { @@int@@ = * __errno_location ( ) ; free ( @@BYTE@@ ) ; * __errno_location ( ) = @@int@@ ; } @@int64@@ = Number ; } return @@int64@@ ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
__int64 __fastcall fts_padjust ( __int64 @@int64@@ , _QWORD * @@QWORD@@ ) { _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; for ( @@QWORD@@ = * ( _QWORD * * ) ( @@int64@@ + Number ) ; @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { if ( ( _QWORD * ) @@QWORD@@ [ Number ] != @@QWORD@@ + Number ) @@QWORD@@ [ Number ] = @@int64@@ + @@QWORD@@ [ Number ] - @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; } while ( Number ) { @@int64@@ = @@QWORD@@ [ Number ] ; if ( @@int64@@ < Number ) break ; if ( ( _QWORD * ) @@QWORD@@ [ Number ] != @@QWORD@@ + Number ) @@QWORD@@ [ Number ] = @@int64@@ + @@QWORD@@ [ Number ] - @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; if ( @@QWORD@@ [ Number ] ) @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; else @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; @@QWORD@@ = @@QWORD@@ ; } return @@int64@@ ; }
__int64 __fastcall get_stat_mtime_ns ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
unsigned __int64 __fastcall dev_info_hash ( _QWORD * @@QWORD@@ , unsigned __int64 @@unsignedint64@@ ) { return * @@QWORD@@ % @@unsignedint64@@ ; }
_BOOL8 __fastcall target_directory_operand ( char * @@char@@ ) { int @@int@@ ; bool @@bool@@ ; __int64 @@int64@@ ; char * @@char@@ ; bool @@bool@@ ; int @@int@@ ; struct stat @@structstat@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( ( unsigned int ) stat ( @@char@@ , & @@structstat@@ ) ) @@int@@ = * __errno_location ( ) ; else @@int@@ = Number ; @@int@@ = @@int@@ ; @@bool@@ = ! @@int@@ && ( @@structstat@@ . st_mode & Number ) == Number ; @@bool@@ = @@bool@@ ; if ( @@int@@ && @@int@@ != Number ) { @@int64@@ = quote ( @@char@@ ) ; @@char@@ = gettext ( String ) ; error ( Number , @@int@@ , @@char@@ , @@int64@@ ) ; } return @@bool@@ ; }
void * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * @@int64@@ ; void * @@void@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; void * @@void@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == ( __int64 * ) & slotvec0 ; if ( slotvec == ( __int64 * ) & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@void@@ = off_21B038 ; * @@int64@@ = ( __int64 ) slotvec0 ; @@int64@@ [ Number ] = ( __int64 ) @@void@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = @@int64@@ [ Number * @@int@@ ] ; @@void@@ = ( void * ) @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@void@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = @@unsignedint64@@ + Number ; if ( @@void@@ != & slot0 ) free ( @@void@@ ) ; @@void@@ = ( void * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = ( __int64 ) @@void@@ ; quotearg_buffer_restyled ( ( __int64 ) @@void@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@void@@ ; }
__int64 __fastcall get_stat_atime_0 ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 __fastcall hash_lookup ( __int64 * @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; @@int64@@ = * @@int64@@ ; @@QWORD@@ = ( _QWORD * ) ( @@int64@@ + Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@int64@@ [ Number ] ) ( @@int64@@ , @@int64@@ [ Number ] ) ) ; if ( ( unsigned __int64 ) @@QWORD@@ >= @@int64@@ [ Number ] ) abort ( ) ; if ( ! * @@QWORD@@ ) return Number L ; for ( @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { if ( @@int64@@ == * @@QWORD@@ || ( ( unsigned __int8 ( __fastcall * ) ( __int64 , _QWORD ) ) @@int64@@ [ Number ] ) ( @@int64@@ , * @@QWORD@@ ) ) { return * @@QWORD@@ ; } } return Number L ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ ) { return xmalloc ( @@int64@@ ) ; }
int __fastcall gl_futimens ( int @@int@@ , char * @@char@@ , __int64 * @@int64@@ ) { return fdutimens ( @@char@@ , @@int@@ , @@int64@@ ) ; }
__int64 __fastcall write_protected_non_symlink ( int @@int@@ , char * @@char@@ , const char * @@constchar@@ , struct stat * @@structstat@@ ) { if ( ( unsigned __int8 ) can_write_any_file ( ) ) return Number L ; if ( ( unsigned int ) cache_fstatat ( @@int@@ , @@char@@ , @@structstat@@ , Number ) ) return Number ; if ( ( @@structstat@@ -> st_mode & Number ) == Number ) return Number L ; if ( ! faccessat ( @@int@@ , @@char@@ , Number , Number ) ) return Number L ; if ( strlen ( @@constchar@@ ) > Number ) return ( unsigned __int8 ) euidaccess_stat ( @@structstat@@ , Number L ) ^ Number ; if ( ! euidaccess ( @@constchar@@ , Number ) ) return Number L ; if ( * __errno_location ( ) != Number ) return Number ; * __errno_location ( ) = Number ; return Number L ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
unsigned __int64 __fastcall lcm ( unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { return @@unsignedint64@@ * ( @@unsignedint64@@ / gcd ( @@unsignedint64@@ , @@unsignedint64@@ ) ) ; }
__int64 __fastcall next_prime ( unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = @@unsignedint64@@ ; if ( @@unsignedint64@@ <= Number ) @@int64@@ = Number L ; for ( @@int64@@ = @@int64@@ | Number ; @@int64@@ != Number && ! is_prime ( @@int64@@ ) ; @@int64@@ += Number L ) { ; } return @@int64@@ ; }
char * __fastcall areadlinkat ( int @@int@@ , const char * @@constchar@@ ) { signed __int64 @@signedint64@@ ; int @@int@@ ; char * @@char@@ ; __int64 @@int64@@ ; signed __int64 @@signedint64@@ ; size_t @@sizet@@ ; char * @@char@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@char@@ = @@char@@ ; @@int64@@ = Number L ; while ( Number ) { @@signedint64@@ = readlinkat ( @@int@@ , @@constchar@@ , @@char@@ , @@int64@@ ) ; if ( @@signedint64@@ < Number && * __errno_location ( ) != Number ) { if ( @@char@@ != @@char@@ ) { @@int@@ = * __errno_location ( ) ; free ( @@char@@ ) ; * __errno_location ( ) = @@int@@ ; } return Number L ; } if ( @@int64@@ > ( unsigned __int64 ) @@signedint64@@ ) break ; if ( @@char@@ != @@char@@ ) free ( @@char@@ ) ; @@int64@@ *= Number L ; if ( @@int64@@ < Number ) { * __errno_location ( ) = Number ; return Number L ; } @@char@@ = ( char * ) malloc ( @@int64@@ ) ; if ( ! @@char@@ ) return Number L ; } @@signedint64@@ = @@signedint64@@ ; @@sizet@@ = @@signedint64@@ + Number ; @@char@@ [ @@signedint64@@ ] = Number ; if ( @@char@@ == @@char@@ ) { @@char@@ = ( char * ) malloc ( @@sizet@@ ) ; if ( ! @@char@@ ) return Number L ; memcpy ( @@char@@ , @@char@@ , @@sizet@@ ) ; } else if ( @@int64@@ > @@sizet@@ ) { @@char@@ = ( char * ) realloc ( @@char@@ , @@sizet@@ ) ; if ( @@char@@ ) @@char@@ = @@char@@ ; } return @@char@@ ; }
void * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
int __fastcall lutimens ( char * @@char@@ , __int64 * @@int64@@ ) { struct timespec * @@structtimespec@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; struct timespec * @@structtimespec@@ ; __syscall_slong_t @@syscallslongt@@ ; struct timespec * @@structtimespec@@ ; __syscall_slong_t @@syscallslongt@@ ; int @@int@@ ; int @@int@@ ; struct timespec * @@structtimespec@@ ; __int64 @@int64@@ [ Number ] ; struct stat @@structstat@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( @@int64@@ ) @@structtimespec@@ = ( struct timespec * ) @@int64@@ ; else @@structtimespec@@ = Number L ; @@structtimespec@@ = @@structtimespec@@ ; @@int@@ = Number ; if ( @@structtimespec@@ ) { @@int64@@ = @@int64@@ [ Number ] ; @@int64@@ [ Number ] = * @@int64@@ ; @@int64@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int64@@ [ Number ] ; @@int64@@ [ Number ] = @@int64@@ [ Number ] ; @@int64@@ [ Number ] = @@int64@@ ; @@int@@ = validate_timespec ( @@structtimespec@@ ) ; } if ( @@int@@ < Number ) return Number ; if ( lutimensat_works_really >= Number ) { if ( @@int@@ == Number ) { if ( ( unsigned int ) lstat ( @@char@@ , & @@structstat@@ ) ) return Number ; if ( @@structtimespec@@ -> tv_nsec == Number ) { @@structtimespec@@ = @@structtimespec@@ ; @@structtimespec@@ -> tv_sec = get_stat_atime_0 ( ( __int64 ) & @@structstat@@ ) ; @@structtimespec@@ -> tv_nsec = @@syscallslongt@@ ; } else if ( @@structtimespec@@ [ Number ] . tv_nsec == Number ) { @@structtimespec@@ = @@structtimespec@@ + Number ; @@structtimespec@@ [ Number ] . tv_sec = get_stat_mtime_0 ( ( __int64 ) & @@structstat@@ ) ; @@structtimespec@@ -> tv_nsec = @@syscallslongt@@ ; } @@int@@ = Number ; } @@int@@ = utimensat ( Number , @@char@@ , @@structtimespec@@ , Number ) ; if ( @@int@@ > Number ) * __errno_location ( ) = Number ; if ( ! @@int@@ || * __errno_location ( ) != Number ) { utimensat_works_really = Number ; lutimensat_works_really = Number ; return @@int@@ ; } } lutimensat_works_really = Number ; if ( ! @@int@@ ) goto LABEL_37 ; if ( @@int@@ != Number && ( unsigned int ) lstat ( @@char@@ , & @@structstat@@ ) ) { return Number ; } if ( @@structtimespec@@ && ( unsigned __int8 ) update_timespec ( ( __int64 ) & @@structstat@@ , ( __int64 * * ) & @@structtimespec@@ ) ) { return Number ; } LABEL_37 : if ( ! @@int@@ && ( unsigned int ) lstat ( @@char@@ , & @@structstat@@ ) ) return Number ; if ( ( @@structstat@@ . st_mode & Number ) != Number ) return fdutimens ( @@char@@ , Number , & @@structtimespec@@ -> tv_sec ) ; * __errno_location ( ) = Number ; return Number ; }
__int64 __fastcall get_stat_atime ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
void __fastcall hash_free ( __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) && * ( _QWORD * ) ( @@int64@@ + Number ) ) { for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { for ( @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@int64@@ + Number ) ) ( * @@QWORD@@ ) ; } } } } for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { for ( @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; @@QWORD@@ ; @@QWORD@@ = @@QWORD@@ ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; free ( @@QWORD@@ ) ; } } for ( @@QWORD@@ = * ( _QWORD * * ) ( @@int64@@ + Number ) ; @@QWORD@@ ; @@QWORD@@ = @@QWORD@@ ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; free ( @@QWORD@@ ) ; } free ( * ( void * * ) @@int64@@ ) ; free ( ( void * ) @@int64@@ ) ; }
__int64 __fastcall argmatch_to_argument ( const void * @@constvoid@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; ++ @@int64@@ ) { if ( ! memcmp ( @@constvoid@@ , ( const void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) , @@sizet@@ ) ) return * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; } return Number L ; }
int __fastcall clone_file ( int @@int@@ , unsigned int @@unsignedint@@ ) { return ioctl ( @@int@@ , Number , @@unsignedint@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall i_ring_empty ( __int64 @@int64@@ ) { return * ( unsigned __int8 * ) ( @@int64@@ + Number ) ; }
__int64 __fastcall select_plural ( __int64 @@int64@@ ) { return @@int64@@ ; }
__int64 __fastcall set_cloexec_flag ( int @@int@@ , char @@char@@ , __int64 a3 , int @@int@@ , int @@int@@ , int @@int@@ ) { int @@int@@ ; int @@int@@ ; int @@int@@ ; unsigned int @@unsignedint@@ ; __int64 @@int64@@ ; int @@int@@ ; @@int@@ = rpl_fcntl ( @@int@@ , Number , Number , @@int@@ , @@int@@ , @@int@@ ) ; if ( @@int@@ < Number || ( ! @@char@@ ? ( @@unsignedint@@ = @@int@@ & Number ) : ( @@unsignedint@@ = @@int@@ | Number ) , @@int@@ != @@unsignedint@@ && ( unsigned int ) rpl_fcntl ( @@int@@ , Number , @@unsignedint@@ , @@int@@ , @@int@@ , @@int@@ ) == Number ) ) { @@int64@@ = Number ; } else { @@int64@@ = Number L ; } return @@int64@@ ; }
__ino_t * __fastcall get_root_dev_ino ( __ino_t * @@inot@@ ) { struct stat @@structstat@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( ( unsigned int ) lstat ( String , & @@structstat@@ ) ) return Number L ; * @@inot@@ = @@structstat@@ . st_ino ; @@inot@@ [ Number ] = @@structstat@@ . st_dev ; return @@inot@@ ; }
__int64 __fastcall bad_cast ( __int64 @@int64@@ ) { return @@int64@@ ; }
_BOOL8 __fastcall copy_dir ( __int64 @@int64@@ , __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ , _QWORD * @@QWORD@@ , int @@int@@ , __int64 @@int64@@ , __int64 @@int64@@ , bool * @@bool@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; _BOOL8 @@BOOL8@@ ; unsigned __int8 @@unsignedint8@@ ; size_t @@sizet@@ ; char @@char@@ ; bool @@bool@@ ; char * @@char@@ ; void * @@void@@ ; void * @@void@@ ; void * @@void@@ ; __int64 @@int6412@@ [ Number ] ; @@int6412@@ [ Number ] = __readfsqword ( Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int6412@@ [ Number ] = * ( _QWORD * ) @@int64@@ ; @@int6412@@ [ Number ] = @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int6412@@ [ Number ] = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int6412@@ [ Number ] = @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int6412@@ [ Number ] = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int6412@@ [ Number ] = @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int6412@@ [ Number ] = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int6412@@ [ Number ] = @@int64@@ ; @@int6412@@ [ Number ] = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@bool@@ = Number ; @@void@@ = ( void * ) savedir ( @@int64@@ ) ; if ( @@void@@ ) { if ( * ( _DWORD * ) ( @@int64@@ + Number ) == Number ) HIDWORD ( @@int6412@@ [ Number ] ) = Number ; for ( @@char@@ = ( char * ) @@void@@ ; * @@char@@ ; @@char@@ += @@sizet@@ + Number ) { @@void@@ = ( void * ) file_name_concat ( @@int64@@ , @@char@@ , Number L ) ; @@void@@ = ( void * ) file_name_concat ( @@int64@@ , @@char@@ , Number L ) ; @@unsignedint8@@ = copy_internal ( ( _DWORD ) @@void@@ , ( _DWORD ) @@void@@ , @@unsignedint8@@ , * @@QWORD@@ , @@int@@ , ( unsigned int ) @@int6412@@ , Number , @@int64@@ , ( __int64 ) & @@char@@ , Number L ) ; @@bool@@ = ( @@bool@@ & @@unsignedint8@@ ) != Number ; * @@bool@@ = ( unsigned __int8 ) ( * @@bool@@ | @@char@@ ) != Number ; free ( @@void@@ ) ; free ( @@void@@ ) ; if ( @@char@@ ) break ; @@sizet@@ = strlen ( @@char@@ ) ; } free ( @@void@@ ) ; @@BOOL8@@ = @@bool@@ ; } else { @@int64@@ = quote ( @@int64@@ ) ; @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ , @@int64@@ ) ; @@BOOL8@@ = Number L ; } return @@BOOL8@@ ; }
_BOOL8 __fastcall strip_trailing_slashes ( char * @@char@@ ) { char @@char@@ ; const char * @@constchar@@ ; const char * @@constchar@@ ; @@constchar@@ = last_component ( @@char@@ ) ; if ( ! * @@constchar@@ ) @@constchar@@ = @@char@@ ; @@constchar@@ = & @@constchar@@ [ base_len ( @@constchar@@ ) ] ; @@char@@ = * @@constchar@@ ; * @@constchar@@ = Number ; return @@char@@ != Number ; }
bool __fastcall hex_digits ( _BYTE * @@BYTE@@ ) { unsigned int @@unsignedint@@ ; for ( @@unsignedint@@ = Number ; @@unsignedint@@ < ( unsigned __int64 ) digest_hex_bytes ; ++ @@unsignedint@@ ) { if ( ( ( * __ctype_b_loc ( ) ) [ ( unsigned __int8 ) * @@BYTE@@ ] & Number ) == Number ) return Number ; ++ @@BYTE@@ ; } return * @@BYTE@@ == Number ; }
bool __fastcall dev_info_compare ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ ) { return * @@QWORD@@ == * @@QWORD@@ ; }
__int64 __fastcall bsd_split_3 ( __int64 @@int64@@ , __int64 @@int64@@ , _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; if ( ! @@int64@@ ) return Number L ; * @@QWORD@@ = @@int64@@ ; for ( @@int64@@ = @@int64@@ - Number ; @@int64@@ && * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) != Number ; -- @@int64@@ ) { ; } if ( * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) != Number ) return Number L ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ + Number ; * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) = Number ; while ( * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) == Number || * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) == Number ) ++ @@int64@@ ; if ( * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) != Number ) return Number L ; for ( @@int64@@ = @@int64@@ + Number ; * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) == Number || * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) == Number ; ++ @@int64@@ ) { ; } * @@QWORD@@ = @@int64@@ + @@int64@@ ; return Number L ; }
__int64 __fastcall i_ring_pop ( __int64 @@int64@@ ) { unsigned int @@unsignedint@@ ; if ( ( unsigned __int8 ) i_ring_empty ( @@int64@@ ) ) abort ( ) ; @@unsignedint@@ = * ( _DWORD * ) ( @@int64@@ + Number L * * ( unsigned int * ) ( @@int64@@ + Number ) ) ; * ( _DWORD * ) ( @@int64@@ + Number L * * ( unsigned int * ) ( @@int64@@ + Number ) ) = * ( _DWORD * ) ( @@int64@@ + Number ) ; if ( * ( _DWORD * ) ( @@int64@@ + Number ) == * ( _DWORD * ) ( @@int64@@ + Number ) ) * ( _BYTE * ) ( @@int64@@ + Number ) = Number ; else * ( _DWORD * ) ( @@int64@@ + Number ) = ( ( unsigned __int8 ) * ( _DWORD * ) ( @@int64@@ + Number ) + Number ) & Number ; return @@unsignedint@@ ; }
__int64 __fastcall get_stat_mtime_0 ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
_DWORD * __fastcall md5_read_ctx ( int * @@int@@ , _DWORD * @@DWORD@@ ) { set_uint32 ( @@DWORD@@ , * @@int@@ ) ; set_uint32 ( @@DWORD@@ + Number , @@int@@ [ Number ] ) ; set_uint32 ( @@DWORD@@ + Number , @@int@@ [ Number ] ) ; set_uint32 ( @@DWORD@@ + Number , @@int@@ [ Number ] ) ; return @@DWORD@@ ; }
char * __fastcall areadlink_with_size ( const char * @@constchar@@ , unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; char * @@char@@ ; int @@int@@ ; size_t @@sizet@@ ; char * @@char@@ ; ssize_t @@ssizet@@ ; if ( @@unsignedint64@@ >= Number ) @@int64@@ = Number L ; else @@int64@@ = @@unsignedint64@@ + Number ; @@sizet@@ = @@int64@@ ; LABEL_5 : for ( @@char@@ = ( char * ) malloc ( @@sizet@@ ) ; ; @@char@@ = ( char * ) malloc ( Number ) ) { @@char@@ = @@char@@ ; if ( ! @@char@@ ) return Number L ; @@ssizet@@ = readlink ( @@constchar@@ , @@char@@ , @@sizet@@ ) ; if ( @@ssizet@@ < Number && * __errno_location ( ) != Number ) { @@int@@ = * __errno_location ( ) ; free ( @@char@@ ) ; * __errno_location ( ) = @@int@@ ; return Number L ; } if ( @@ssizet@@ < @@sizet@@ ) { @@char@@ [ @@ssizet@@ ] = Number ; return @@char@@ ; } free ( @@char@@ ) ; if ( @@sizet@@ <= Number ) { @@sizet@@ *= Number L ; goto LABEL_5 ; } if ( @@sizet@@ > Number ) break ; @@sizet@@ = Number ; } * __errno_location ( ) = Number ; return Number L ; }
int __fastcall utimens ( char * @@char@@ , __int64 * @@int64@@ ) { return fdutimens ( @@char@@ , Number , @@int64@@ ) ; }
int __fastcall rpl_linkat ( unsigned int @@unsignedint@@ , char * @@char@@ , int @@int@@ , const char * @@constchar@@ , int @@int@@ ) { int @@int@@ ; int @@int@@ ; if ( ! @@int@@ ) return linkat ( @@unsignedint@@ , @@char@@ , @@int@@ , @@constchar@@ , Number ) ; @@int@@ = @@int@@ ; BYTE1 ( @@int@@ ) = BYTE1 ( @@int@@ ) & Number ; if ( @@int@@ ) { * __errno_location ( ) = Number ; return Number ; } if ( have_follow_really_4385 >= Number ) { @@int@@ = linkat ( @@unsignedint@@ , @@char@@ , @@int@@ , @@constchar@@ , @@int@@ ) ; if ( @@int@@ != Number || * __errno_location ( ) != Number ) { have_follow_really_4385 = Number ; return @@int@@ ; } have_follow_really_4385 = Number ; } return linkat_follow ( @@unsignedint@@ , @@char@@ , @@int@@ , @@constchar@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall md5_stream ( FILE * @@FILE@@ , _DWORD * @@DWORD@@ ) { __int64 @@int64@@ ; char * @@char@@ ; size_t @@sizet@@ ; int @@int@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@char@@ = ( char * ) malloc ( Number ) ; if ( ! @@char@@ ) return Number L ; md5_init_ctx ( @@int@@ ) ; LABEL_4 : @@int64@@ = Number L ; while ( Number ) { @@sizet@@ = fread_unlocked ( & @@char@@ [ @@int64@@ ] , Number , Number - @@int64@@ , @@FILE@@ ) ; @@int64@@ += @@sizet@@ ; if ( @@int64@@ == Number ) { md5_process_block ( @@char@@ , Number , @@int@@ ) ; goto LABEL_4 ; } if ( ! @@sizet@@ ) break ; if ( feof_unlocked ( @@FILE@@ ) ) goto LABEL_12 ; } if ( ferror_unlocked ( @@FILE@@ ) ) { free ( @@char@@ ) ; return Number L ; } LABEL_12 : if ( @@int64@@ ) md5_process_bytes ( @@char@@ , @@int64@@ , @@int@@ ) ; md5_finish_ctx ( @@int@@ , @@DWORD@@ ) ; free ( @@char@@ ) ; return Number L ; }
__int64 __fastcall get_version ( __int64 @@int64@@ , _BYTE * @@BYTE@@ ) { __int64 @@int64@@ ; if ( @@BYTE@@ && * @@BYTE@@ ) @@int64@@ = backup_types [ _xargmatch_internal ( @@int64@@ , @@BYTE@@ , backup_args , backup_types , Number L , argmatch_die ) ] ; else @@int64@@ = Number L ; return @@int64@@ ; }
__int64 __fastcall xnrealloc ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { if ( ! is_mul_ok ( @@unsignedint64@@ , @@unsignedint64@@ ) ) xalloc_die ( ) ; return xrealloc ( @@int64@@ , @@unsignedint64@@ * @@unsignedint64@@ ) ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
__int64 __fastcall xget_version ( __int64 @@int64@@ , _BYTE * @@BYTE@@ ) { char * @@char@@ ; if ( @@BYTE@@ && * @@BYTE@@ ) return get_version ( @@int64@@ , @@BYTE@@ ) ; @@char@@ = getenv ( String ) ; return get_version ( ( __int64 ) String , @@char@@ ) ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
__int64 __fastcall x2nrealloc ( __int64 @@int64@@ , unsigned __int64 * @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = * @@unsignedint64@@ ; if ( @@int64@@ ) { if ( @@unsignedint64@@ >= Number / @@unsignedint64@@ ) xalloc_die ( ) ; @@unsignedint64@@ += ( @@unsignedint64@@ + Number ) >> Number ; } else if ( ! @@unsignedint64@@ ) { @@unsignedint64@@ = ( Number / @@unsignedint64@@ == Number ) + Number / @@unsignedint64@@ ; } * @@unsignedint64@@ = @@unsignedint64@@ ; return xrealloc ( @@int64@@ , @@unsignedint64@@ * @@unsignedint64@@ ) ; }
void * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_20A028 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
__int64 close_stdin ( ) { const char * @@constchar@@ ; int * @@int@@ ; int * @@int@@ ; __int64 @@int64@@ ; char @@char@@ ; char * @@char@@ ; @@char@@ = Number ; if ( freadahead ( stdin ) && ! ( unsigned int ) rpl_fseeko ( stdin , Number L , Number L ) && ( unsigned int ) rpl_fflush ( stdin ) ) @@char@@ = Number ; if ( ( unsigned int ) close_stream ( stdin ) ) @@char@@ = Number ; if ( @@char@@ ) { @@char@@ = gettext ( String ) ; if ( file_name ) { @@constchar@@ = ( const char * ) quotearg_colon ( file_name ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , String , @@constchar@@ , @@char@@ ) ; } else { @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , String , @@char@@ ) ; } } @@int64@@ = close_stdout ( ) ; if ( @@char@@ ) _exit ( exit_failure ) ; return @@int64@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
void * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
_BOOL8 __fastcall cycle_warning_required ( __int64 @@int64@@ , __int64 @@int64@@ ) { return ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number && ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) == Number || ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number && ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number && * ( _QWORD * ) ( @@int64@@ + Number ) ; }
void * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
char * __fastcall file_type ( __int64 @@int64@@ ) { char * @@char@@ ; switch ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) { case Number : if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) @@char@@ = gettext ( String ) ; else @@char@@ = gettext ( String ) ; break ; case Number : @@char@@ = gettext ( String ) ; break ; case Number : @@char@@ = gettext ( String ) ; break ; case Number : @@char@@ = gettext ( String ) ; break ; case Number : @@char@@ = gettext ( String ) ; break ; case Number : @@char@@ = gettext ( String ) ; break ; case Number : @@char@@ = gettext ( String ) ; break ; default : @@char@@ = gettext ( String ) ; break ; } return @@char@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
void * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
unsigned __int64 __fastcall hash_pjw ( _BYTE * @@BYTE@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = Number L ; while ( * @@BYTE@@ ) @@unsignedint64@@ = __ROL8__ ( @@unsignedint64@@ , Number ) + ( char ) * @@BYTE@@ ++ ; return @@unsignedint64@@ % @@unsignedint64@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return xmalloc ( @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall setup_dir ( __int64 @@int64@@ ) { if ( ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number ) { * ( _QWORD * ) ( @@int64@@ + Number ) = hash_initialize ( Number L , Number L , AD_hash , AD_compare , & free ) ; if ( ! * ( _QWORD * ) ( @@int64@@ + Number ) ) return Number L ; } else { * ( _QWORD * ) ( @@int64@@ + Number ) = malloc ( Number ) ; if ( ! * ( _QWORD * ) ( @@int64@@ + Number ) ) return Number L ; cycle_check_init ( * ( _QWORD * ) ( @@int64@@ + Number ) ) ; } return Number L ; }
void __fastcall argmatch_invalid ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { char * @@char@@ ; __int64 @@int64@@ ; void * @@void@@ ; char * @@char@@ ; if ( @@int64@@ == Number ) @@char@@ = gettext ( String ) ; else @@char@@ = gettext ( String ) ; @@char@@ = @@char@@ ; @@int64@@ = quote_n ( Number , @@int64@@ ) ; @@void@@ = quotearg_n_style ( Number , Number , @@int64@@ ) ; error ( Number , Number , @@char@@ , @@void@@ , @@int64@@ ) ; }
_BYTE * __fastcall savedirstream ( DIR * @@DIR@@ ) { __int64 @@int64@@ ; int @@int@@ ; _BYTE * @@BYTE@@ ; unsigned __int64 @@unsignedint64@@ ; size_t @@sizet@@ ; struct dirent * @@structdirent@@ ; char * @@char@@ ; size_t @@sizet@@ ; @@unsignedint64@@ = Number L ; @@sizet@@ = Number L ; if ( ! @@DIR@@ ) return Number L ; @@BYTE@@ = ( _BYTE * ) xmalloc ( Number L ) ; while ( Number ) { * __errno_location ( ) = Number ; @@structdirent@@ = readdir ( @@DIR@@ ) ; if ( ! @@structdirent@@ ) break ; @@char@@ = @@structdirent@@ -> d_name ; if ( @@structdirent@@ -> d_name [ Number ] == Number ) { if ( @@structdirent@@ -> d_name [ Number ] == Number ) @@int64@@ = Number L ; else @@int64@@ = Number L ; } else { @@int64@@ = Number L ; } if ( @@char@@ [ @@int64@@ ] ) { @@sizet@@ = strlen ( @@structdirent@@ -> d_name ) + Number ; if ( @@sizet@@ > @@sizet@@ + @@sizet@@ ) xalloc_die ( ) ; if ( @@unsignedint64@@ <= @@sizet@@ + @@sizet@@ ) { do { if ( @@unsignedint64@@ > Number * @@unsignedint64@@ ) xalloc_die ( ) ; @@unsignedint64@@ *= Number L ; } while ( @@unsignedint64@@ <= @@sizet@@ + @@sizet@@ ) ; @@BYTE@@ = ( _BYTE * ) xrealloc ( @@BYTE@@ , @@unsignedint64@@ ) ; } memcpy ( & @@BYTE@@ [ @@sizet@@ ] , @@char@@ , @@sizet@@ ) ; @@sizet@@ += @@sizet@@ ; } } @@BYTE@@ [ @@sizet@@ ] = Number ; @@int@@ = * __errno_location ( ) ; if ( closedir ( @@DIR@@ ) ) @@int@@ = * __errno_location ( ) ; if ( ! @@int@@ ) return @@BYTE@@ ; free ( @@BYTE@@ ) ; * __errno_location ( ) = @@int@@ ; return Number L ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
void __fastcall free_dir ( __int64 @@int64@@ ) { if ( ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number ) { if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) hash_free ( * ( _QWORD * ) ( @@int64@@ + Number ) ) ; } else { free ( * ( void * * ) ( @@int64@@ + Number ) ) ; } }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
__int64 __fastcall _xargmatch_internal ( __int64 @@int64@@ , const char * @@constchar@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ , void ( * @ @ VAR_2063 @ @ void ( ) ( void ) @ @ argmatchexitfn ) ( void ) ) { __int64 @@int64@@ ; @@int64@@ = argmatch ( @@constchar@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; if ( @@int64@@ >= Number ) return @@int64@@ ; argmatch_invalid ( @@int64@@ , ( __int64 ) @@constchar@@ , @@int64@@ ) ; argmatch_valid ( @@int64@@ , @@int64@@ , @@sizet@@ ) ; @ @ VAR_2063 @ @ void ( ) ( void ) @ @ argmatchexitfn ( ) ; return Number ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
_BOOL8 __fastcall euidaccess_stat ( _DWORD * @@DWORD@@ , char @@char@@ ) { unsigned int @@unsignedint@@ ; __uid_t @@uidt@@ ; if ( ( @@char@@ & Number ) == Number ) return Number L ; @@uidt@@ = geteuid ( ) ; if ( ! @@uidt@@ && ( ( @@char@@ & Number ) == Number || ( @@DWORD@@ [ Number ] & Number ) != Number ) ) return Number L ; @@unsignedint@@ = @@DWORD@@ [ Number ] ; if ( @@uidt@@ == @@DWORD@@ [ Number ] ) { @@unsignedint@@ >>= Number ; } else if ( getegid ( ) == @@DWORD@@ [ Number ] || group_member ( @@DWORD@@ [ Number ] ) ) { @@unsignedint@@ >>= Number ; } return ( ~ @@unsignedint@@ & @@char@@ & Number ) == Number ; }
bool __fastcall is_zero_or_power_of_two ( __int64 @@int64@@ ) { return ( @@int64@@ & ( @@int64@@ - Number ) ) == Number ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall fts_set_stat_required ( __int64 @@int64@@ , char @@char@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; if ( * ( _WORD * ) ( @@int64@@ + Number ) != Number ) abort ( ) ; if ( @@char@@ ) @@int64@@ = Number L ; else @@int64@@ = Number L ; @@int64@@ = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; return @@int64@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
int __fastcall mknod ( char * @@char@@ , __mode_t @@modet@@ , __dev_t @@devt@@ ) { __dev_t @@devt2@@ [ Number ] ; @@devt2@@ [ Number ] = @@devt@@ ; return __xmknod ( Number , @@char@@ , @@modet@@ , @@devt2@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return xmalloc ( @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall cwd_advance_fd ( __int64 @@int64@@ , int @@int@@ , char @@char@@ ) { __int64 @@int64@@ ; int @@int@@ ; int @@int@@ ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) ; if ( @@int@@ == @@int@@ && @@int@@ != Number ) abort ( ) ; if ( @@char@@ ) { @@int@@ = i_ring_push ( @@int64@@ + Number , ( unsigned int ) @@int@@ ) ; if ( @@int@@ >= Number ) close ( @@int@@ ) ; } else if ( ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) == Number && @@int@@ >= Number ) { close ( @@int@@ ) ; } @@int64@@ = @@int64@@ ; * ( _DWORD * ) ( @@int64@@ + Number ) = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall argmatch ( const char * @@constchar@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { __int64 @@int64@@ ; char @@char@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; size_t @@sizet@@ ; @@int64@@ = Number ; @@char@@ = Number ; @@sizet@@ = strlen ( @@constchar@@ ) ; for ( @@int64@@ = Number L ; * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; ++ @@int64@@ ) { if ( ! strncmp ( * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) , @@constchar@@ , @@sizet@@ ) ) { if ( @@sizet@@ == strlen ( * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) ) ) return @@int64@@ ; if ( @@int64@@ == Number ) { @@int64@@ = @@int64@@ ; } else if ( ! @@int64@@ || memcmp ( ( const void * ) ( @@sizet@@ * @@int64@@ + @@int64@@ ) , ( const void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) , @@sizet@@ ) ) { @@char@@ = Number ; } } } if ( @@char@@ ) @@int64@@ = Number ; else @@int64@@ = @@int64@@ ; return @@int64@@ ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
__int64 __fastcall cycle_check ( __int64 @@int64@@ , _QWORD * @@QWORD@@ ) { if ( * ( _DWORD * ) ( @@int64@@ + Number ) != Number ) __assert_fail ( String , String , Number , String ) ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) && @@QWORD@@ [ Number ] == * ( _QWORD * ) @@int64@@ && * @@QWORD@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ) { return Number L ; } if ( is_zero_or_power_of_two ( ++ * ( _QWORD * ) ( @@int64@@ + Number ) ) ) { if ( ! * ( _QWORD * ) ( @@int64@@ + Number ) ) return Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = * @@QWORD@@ ; * ( _QWORD * ) @@int64@@ = @@QWORD@@ [ Number ] ; } return Number L ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_206028 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
_BOOL8 __fastcall leaf_optimization_applies ( int @@int@@ ) { _BOOL8 @@BOOL8@@ ; struct statfs @@structstatfs@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( fstatfs ( @@int@@ , & @@structstatfs@@ ) ) @@BOOL8@@ = Number L ; else @@BOOL8@@ = @@structstatfs@@ . f_type == Number ; return @@BOOL8@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
__int64 __fastcall digest_file ( const char * @@constchar@@ , __int64 a2 , __int64 @@int64@@ ) { int @@int@@ ; int @@int@@ ; int * @@int@@ ; int * @@int@@ ; bool @@bool@@ ; FILE * @@FILE@@ ; @@int@@ = strcmp ( @@constchar@@ , String ) ; @@bool@@ = @@int@@ == Number ; if ( @@int@@ ) { @@FILE@@ = ( FILE * ) fopen_safer ( @@constchar@@ , String ) ; if ( ! @@FILE@@ ) goto LABEL_4 ; @@int@@ = md5_stream ( @@FILE@@ , @@int64@@ ) ; } else { have_read_stdin = Number ; @@FILE@@ = stdin ; @@int@@ = md5_stream ( stdin , @@int64@@ ) ; } if ( ! @@int@@ ) { if ( @@bool@@ || ! fclose ( @@FILE@@ ) ) return Number L ; LABEL_4 : @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , String , @@constchar@@ ) ; return Number L ; } @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , String , @@constchar@@ ) ; if ( @@FILE@@ != stdin ) fclose ( @@FILE@@ ) ; return Number L ; }
void * __fastcall mfile_name_concat ( _BYTE * @@BYTE@@ , _BYTE * @@BYTE@@ , _QWORD * @@QWORD@@ ) { _BOOL4 @@BOOL4@@ ; const char * @@constchar@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; _BOOL8 @@BOOL8@@ ; char * @@char@@ ; size_t @@sizet@@ ; void * @@void@@ ; _BYTE * @@BYTE@@ ; char * @@char@@ ; @@constchar@@ = last_component ( @@BYTE@@ ) ; @@sizet@@ = base_len ( @@constchar@@ ) ; @@sizet@@ = @@constchar@@ - @@BYTE@@ + @@sizet@@ ; @@BOOL4@@ = @@sizet@@ && @@constchar@@ [ @@sizet@@ - Number ] != Number ; @@BOOL8@@ = @@BOOL4@@ ; @@char@@ = longest_relative_suffix ( @@BYTE@@ ) ; @@sizet@@ = strlen ( @@char@@ ) ; @@void@@ = malloc ( @@BOOL8@@ + @@sizet@@ + @@sizet@@ + Number ) ; if ( ! @@void@@ ) return Number L ; @@BYTE@@ = mempcpy ( @@void@@ , @@BYTE@@ , @@sizet@@ ) ; * @@BYTE@@ = Number ; @@char@@ = & @@BYTE@@ [ @@BOOL8@@ ] ; if ( @@QWORD@@ ) * @@QWORD@@ = & @@char@@ [ - ( * @@BYTE@@ == Number ) ] ; * ( _BYTE * ) mempcpy ( @@char@@ , @@char@@ , @@sizet@@ ) = Number ; return @@void@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall fts_set ( __int64 a1 , __int64 @@int64@@ , int @@int@@ ) { __int64 @@int64@@ ; if ( ! @@int@@ || @@int@@ == Number || @@int@@ == Number || @@int@@ == Number || @@int@@ == Number ) { * ( _WORD * ) ( @@int64@@ + Number ) = @@int@@ ; @@int64@@ = Number L ; } else { * __errno_location ( ) = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
_DWORD * __fastcall md5_finish_ctx ( int * @@int@@ , _DWORD * @@DWORD@@ ) { __int64 @@int64@@ ; unsigned int @@unsignedint@@ ; __int64 @@int64@@ ; @@unsignedint@@ = @@int@@ [ Number ] ; if ( @@unsignedint@@ > Number ) @@int64@@ = Number L ; else @@int64@@ = Number L ; @@int64@@ = @@int64@@ ; @@int@@ [ Number ] += @@unsignedint@@ ; if ( @@unsignedint@@ > @@int@@ [ Number ] ) ++ @@int@@ [ Number ] ; @@int@@ [ @@int64@@ + Number ] = Number * @@int@@ [ Number ] ; @@int@@ [ @@int64@@ + Number ] = * ( ( __int64 * ) @@int@@ + Number ) >> Number ; memcpy ( ( char * ) @@int@@ + @@unsignedint@@ + Number , & fillbuf , Number * @@int64@@ - @@unsignedint@@ - Number ) ; md5_process_block ( @@int@@ + Number , Number * @@int64@@ , @@int@@ ) ; return md5_read_ctx ( @@int@@ , @@DWORD@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 __fastcall fts_compare_ino ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; if ( * ( _QWORD * ) ( * ( _QWORD * ) @@int64@@ + Number L ) < * ( _QWORD * ) ( * ( _QWORD * ) @@int64@@ + Number L ) ) @@int64@@ = Number ; else @@int64@@ = * ( _QWORD * ) ( * ( _QWORD * ) @@int64@@ + Number L ) < * ( _QWORD * ) ( * ( _QWORD * ) @@int64@@ + Number L ) ; return @@int64@@ ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_207028 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
__int64 __fastcall set_stat_type ( __int64 @@int64@@ , int @@int@@ ) { __int64 @@int64@@ ; int @@int@@ ; switch ( @@int@@ ) { case Number : @@int@@ = Number ; break ; case Number : @@int@@ = Number ; break ; case Number : @@int@@ = Number ; break ; case Number : @@int@@ = Number ; break ; case Number : @@int@@ = Number ; break ; case Number : @@int@@ = Number ; break ; case Number : @@int@@ = Number ; break ; default : @@int@@ = Number ; break ; } @@int64@@ = @@int64@@ ; * ( _DWORD * ) ( @@int64@@ + Number ) = @@int@@ ; return @@int64@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
int __fastcall hash_print_statistics ( __int64 @@int64@@ , FILE * @@FILE@@ ) { double @@double@@ ; double @@double@@ ; double @@double@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int64@@ = hash_get_n_entries ( @@int64@@ ) ; @@int64@@ = hash_get_n_buckets ( @@int64@@ ) ; @@int64@@ = hash_get_n_buckets_used ( @@int64@@ ) ; @@unsignedint64@@ = hash_get_max_bucket_length ( @@int64@@ ) ; fprintf ( @@FILE@@ , String , @@int64@@ ) ; fprintf ( @@FILE@@ , String , @@int64@@ ) ; if ( @@int64@@ < Number ) @@double@@ = ( double ) ( int ) ( @@int64@@ & Number | ( ( unsigned __int64 ) @@int64@@ >> Number ) ) + ( double ) ( int ) ( @@int64@@ & Number | ( ( unsigned __int64 ) @@int64@@ >> Number ) ) ; else @@double@@ = ( double ) ( int ) @@int64@@ ; @@double@@ = Number * @@double@@ ; if ( @@int64@@ < Number ) @@double@@ = ( double ) ( int ) ( @@int64@@ & Number | ( ( unsigned __int64 ) @@int64@@ >> Number ) ) + ( double ) ( int ) ( @@int64@@ & Number | ( ( unsigned __int64 ) @@int64@@ >> Number ) ) ; else @@double@@ = ( double ) ( int ) @@int64@@ ; fprintf ( @@FILE@@ , String , @@int64@@ , @@double@@ / @@double@@ ) ; return fprintf ( @@FILE@@ , String , @@unsignedint64@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_20A0E8 ; @@int648@@ [ Number ] = qword_20A0F0 ; @@int648@@ [ Number ] = qword_20A0F8 ; @@int648@@ [ Number ] = qword_20A100 ; @@int648@@ [ Number ] = qword_20A108 ; @@int648@@ [ Number ] = qword_20A110 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
unsigned __int64 __fastcall compute_bucket_size ( __int64 @@int64@@ , __int64 @@int64@@ ) { float @@float@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; float @@float@@ ; @@unsignedint64@@ = @@int64@@ ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) != Number ) { if ( @@int64@@ < Number ) @@float@@ = ( float ) ( @@int64@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@int64@@ >> Number ) ) + ( float ) ( @@int64@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@int64@@ >> Number ) ) ; else @@float@@ = ( float ) ( int ) @@int64@@ ; @@float@@ = @@float@@ / * ( float * ) ( @@int64@@ + Number ) ; if ( @@float@@ >= Number ) return Number L ; if ( @@float@@ >= Number ) @@unsignedint64@@ = ( unsigned int ) ( int ) ( float ) ( @@float@@ - Number ) ^ Number ; else @@unsignedint64@@ = ( unsigned int ) ( int ) @@float@@ ; } @@unsignedint64@@ = next_prime ( @@unsignedint64@@ ) ; if ( @@unsignedint64@@ <= Number ) @@unsignedint64@@ = @@unsignedint64@@ ; else @@unsignedint64@@ = Number L ; return @@unsignedint64@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return xmalloc ( @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall hash_rehash ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; void * @@void@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@unsignedint64@@ = compute_bucket_size ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( ! @@unsignedint64@@ ) return Number L ; if ( @@unsignedint64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ) return Number L ; @@void@@ = calloc ( @@unsignedint64@@ , Number ) ; if ( ! @@void@@ ) return Number L ; @@unsignedint64@@ = @@unsignedint64@@ ; @@int64@@ = ( __int64 ) @@void@@ + Number * @@unsignedint64@@ ; @@int64@@ = Number L ; @@int64@@ = Number L ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( ( unsigned __int8 ) transfer_entries ( ( __int64 ) & @@void@@ , @@int64@@ , Number ) ) { free ( * ( void * * ) @@int64@@ ) ; * ( _QWORD * ) @@int64@@ = @@void@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@unsignedint64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; @@int64@@ = Number L ; } else { * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; if ( ( unsigned __int8 ) transfer_entries ( @@int64@@ , ( __int64 ) & @@void@@ , Number ) != Number || ( unsigned __int8 ) transfer_entries ( @@int64@@ , ( __int64 ) & @@void@@ , Number ) != Number ) { abort ( ) ; } free ( @@void@@ ) ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@unsignedint64@@ , int @@int@@ ) { __int64 @@int64@@ ; if ( is_mul_ok ( @@int@@ , * @@unsignedint64@@ ) ) { * @@unsignedint64@@ *= @@int@@ ; @@int64@@ = Number L ; } else { * @@unsignedint64@@ = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ ) { return xmalloc ( @@int64@@ ) ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
__int64 __fastcall rpl_fcntl ( int @@int@@ , int @@int@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ ) { int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; if ( @@int@@ != Number ) return ( unsigned int ) fcntl ( @@int@@ , @@int@@ , @@int64@@ ) ; @@int@@ = @@int64@@ ; if ( have_dupfd_cloexec_2895 < Number ) { @@int@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@int@@ , Number , @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ ) ; } else { @@int@@ = fcntl ( @@int@@ , Number , ( unsigned int ) @@int64@@ ) ; if ( @@int@@ < Number && * __errno_location ( ) == Number ) { @@int@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@int@@ , Number , @@int@@ , @@int@@ , @@int@@ , @@int@@ ) ; if ( @@int@@ < Number ) return ( unsigned int ) @@int@@ ; have_dupfd_cloexec_2895 = Number ; } else { have_dupfd_cloexec_2895 = Number ; } } if ( @@int@@ >= Number && have_dupfd_cloexec_2895 == Number ) { @@int@@ = fcntl ( @@int@@ , Number ) ; if ( @@int@@ < Number || fcntl ( @@int@@ , Number , @@int@@ | Number ) == Number ) { @@int@@ = * __errno_location ( ) ; close ( @@int@@ ) ; * __errno_location ( ) = @@int@@ ; @@int@@ = Number ; } } return ( unsigned int ) @@int@@ ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
__int64 __fastcall bkm_scale_by_power ( unsigned __int64 * @@unsignedint64@@ , int @@int@@ , int @@int@@ ) { unsigned int @@unsignedint@@ ; for ( @@unsignedint@@ = Number ; @@int@@ -- ; @@unsignedint@@ |= bkm_scale ( @@unsignedint64@@ , @@int@@ ) ) { ; } return @@unsignedint@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
_BOOL8 __fastcall dot_or_dotdot ( _BYTE * @@BYTE@@ ) { __int64 @@int64@@ ; char @@char@@ ; if ( * @@BYTE@@ != Number ) return Number L ; if ( @@BYTE@@ [ Number ] == Number ) @@int64@@ = Number L ; else @@int64@@ = Number L ; @@char@@ = @@BYTE@@ [ @@int64@@ ] ; return ! @@char@@ || @@char@@ == Number ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
unsigned __int64 __fastcall dev_ino_hash ( _QWORD * @@QWORD@@ , unsigned __int64 @@unsignedint64@@ ) { return * @@QWORD@@ % @@unsignedint64@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall make_node_op_equals ( int @@int@@ , int @@int@@ ) { __int64 @@int64@@ ; @@int64@@ = xmalloc ( Number L ) ; * ( _BYTE * ) @@int64@@ = Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = Number ; * ( _DWORD * ) ( @@int64@@ + Number ) = Number ; * ( _DWORD * ) ( @@int64@@ + Number ) = @@int@@ ; * ( _DWORD * ) ( @@int64@@ + Number ) = @@int@@ ; * ( _BYTE * ) ( @@int64@@ + Number ) = Number ; return @@int64@@ ; }
_BOOL8 __fastcall visit_dir ( __int64 @@int64@@ , __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; @@QWORD@@ = ( _QWORD * ) xmalloc ( Number L ) ; * @@QWORD@@ = @@int64@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = hash_insert ( active_dir_set , @@QWORD@@ ) ; if ( ! @@int64@@ ) xalloc_die ( ) ; if ( ( _QWORD * ) @@int64@@ != @@QWORD@@ ) free ( @@QWORD@@ ) ; return @@int64@@ != ( _QWORD ) @@QWORD@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_2060C8 ; @@int648@@ [ Number ] = qword_2060D0 ; @@int648@@ [ Number ] = qword_2060D8 ; @@int648@@ [ Number ] = qword_2060E0 ; @@int648@@ [ Number ] = qword_2060E8 ; @@int648@@ [ Number ] = qword_2060F0 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
unsigned __int64 process_signals ( ) { int @@int@@ ; sigset_t @@sigsett@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; while ( interrupt_signal || stop_signal_count ) { if ( used_color ) restore_default_color ( ) ; fflush_unlocked ( stdout ) ; sigprocmask ( Number , & caught_signals , & @@sigsett@@ ) ; @@int@@ = interrupt_signal ; if ( stop_signal_count ) { -- stop_signal_count ; raise ( Number ) ; } else { signal ( interrupt_signal , Number L ) ; raise ( @@int@@ ) ; } sigprocmask ( Number , & @@sigsett@@ , Number L ) ; } return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
_BOOL8 __fastcall same_name ( _BYTE * @@BYTE@@ , _BYTE * @@BYTE@@ ) { bool @@bool@@ ; int * @@int@@ ; int * @@int@@ ; bool @@bool@@ ; bool @@bool@@ ; const char * @@constchar@@ ; const char * @@constchar@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; char * @@char@@ ; char * @@char@@ ; struct stat @@structstat@@ ; struct stat @@structstat@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@constchar@@ = last_component ( @@BYTE@@ ) ; @@constchar@@ = last_component ( @@BYTE@@ ) ; @@sizet@@ = base_len ( @@constchar@@ ) ; @@sizet@@ = base_len ( @@constchar@@ ) ; @@bool@@ = @@sizet@@ == @@sizet@@ && ! memcmp ( @@constchar@@ , @@constchar@@ , @@sizet@@ ) ; @@bool@@ = Number ; if ( @@bool@@ ) { @@char@@ = ( char * ) dir_name ( ( __int64 ) @@BYTE@@ ) ; @@char@@ = ( char * ) dir_name ( ( __int64 ) @@BYTE@@ ) ; if ( ( unsigned int ) stat ( @@char@@ , & @@structstat@@ ) ) { @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , String , @@char@@ ) ; } if ( ( unsigned int ) stat ( @@char@@ , & @@structstat@@ ) ) { @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , String , @@char@@ ) ; } @@bool@@ = @@structstat@@ . st_ino == @@structstat@@ . st_ino && @@structstat@@ . st_dev == @@structstat@@ . st_dev ; @@bool@@ = @@bool@@ ; free ( @@char@@ ) ; free ( @@char@@ ) ; } return @@bool@@ ; }
__int64 __fastcall set_cloexec_flag ( int @@int@@ , char @@char@@ , __int64 a3 , int @@int@@ , int @@int@@ , int @@int@@ ) { int @@int@@ ; int @@int@@ ; int @@int@@ ; unsigned int @@unsignedint@@ ; __int64 @@int64@@ ; int @@int@@ ; @@int@@ = rpl_fcntl ( @@int@@ , Number , Number , @@int@@ , @@int@@ , @@int@@ ) ; if ( @@int@@ < Number || ( ! @@char@@ ? ( @@unsignedint@@ = @@int@@ & Number ) : ( @@unsignedint@@ = @@int@@ | Number ) , @@int@@ != @@unsignedint@@ && ( unsigned int ) rpl_fcntl ( @@int@@ , Number , @@unsignedint@@ , @@int@@ , @@int@@ , @@int@@ ) == Number ) ) { @@int64@@ = Number ; } else { @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall rpl_fcntl ( int @@int@@ , int @@int@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ ) { int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; if ( @@int@@ != Number ) return ( unsigned int ) fcntl ( @@int@@ , @@int@@ , @@int64@@ ) ; @@int@@ = @@int64@@ ; if ( have_dupfd_cloexec_2895 < Number ) { @@int@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@int@@ , Number , @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ ) ; } else { @@int@@ = fcntl ( @@int@@ , Number , ( unsigned int ) @@int64@@ ) ; if ( @@int@@ < Number && * __errno_location ( ) == Number ) { @@int@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@int@@ , Number , @@int@@ , @@int@@ , @@int@@ , @@int@@ ) ; if ( @@int@@ < Number ) return ( unsigned int ) @@int@@ ; have_dupfd_cloexec_2895 = Number ; } else { have_dupfd_cloexec_2895 = Number ; } } if ( @@int@@ >= Number && have_dupfd_cloexec_2895 == Number ) { @@int@@ = fcntl ( @@int@@ , Number ) ; if ( @@int@@ < Number || fcntl ( @@int@@ , Number , @@int@@ | Number ) == Number ) { @@int@@ = * __errno_location ( ) ; close ( @@int@@ ) ; * __errno_location ( ) = @@int@@ ; @@int@@ = Number ; } } return ( unsigned int ) @@int@@ ; }
__int64 __fastcall get_link_name ( __int64 @@int64@@ , __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int64@@ ; char * @@char@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = areadlink_with_size ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( ! @@int64@@ ) { @@char@@ = gettext ( String ) ; @@int64@@ = file_failure ( @@unsignedint8@@ , @@char@@ , @@int64@@ ) ; } return @@int64@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_208028 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall xfts_open ( const char * * @@constchar@@ , int @@int@@ , __int64 @@int64@@ ) { int @@int@@ ; __int64 @@int64@@ ; @@int@@ = @@int@@ ; BYTE1 ( @@int@@ ) = BYTE1 ( @@int@@ ) | Number ; @@int64@@ = fts_open ( @@constchar@@ , @@int@@ , @@int64@@ ) ; if ( ! @@int64@@ ) { if ( * __errno_location ( ) == Number ) __assert_fail ( String , String , Number , String ) ; xalloc_die ( ) ; } return @@int64@@ ; }
_BYTE * __fastcall longest_relative_suffix ( _BYTE * @@BYTE@@ ) { while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; return @@BYTE@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
__int64 __fastcall cmp_mtime ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ , __int64 ( __fastcall * @ @ VAR_500 @ @ int64 ( fastcall ) ( QWORD , QWORD ) @ @ int ( ) ( constchar , constchar ) ) ( _QWORD , _QWORD ) ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = get_stat_mtime ( ( __int64 ) ( @@QWORD@@ + Number ) ) ; @@int64@@ = @@int64@@ ; @@int64@@ = get_stat_mtime ( ( __int64 ) ( @@QWORD@@ + Number ) ) ; @@unsignedint@@ = timespec_cmp ( @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( @@unsignedint@@ ) @@int64@@ = @@unsignedint@@ ; else @@int64@@ = @ @ VAR_500 @ @ int64 ( fastcall ) ( QWORD , QWORD ) @ @ int ( ) ( constchar , constchar ) ( * @@QWORD@@ , * @@QWORD@@ ) ; return @@int64@@ ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
_QWORD * __fastcall add_ignore_pattern ( __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) xmalloc ( Number L ) ; * @@QWORD@@ = @@int64@@ ; @@QWORD@@ [ Number ] = ignore_patterns ; ignore_patterns = ( __int64 ) @@QWORD@@ ; return @@QWORD@@ ; }
__int64 __fastcall unsigned_file_size ( __int64 @@int64@@ ) { return @@int64@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall freadahead ( __int64 @@int64@@ ) { __int64 @@int64@@ ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) > * ( _QWORD * ) ( @@int64@@ + Number ) ) return Number L ; if ( ( * ( _DWORD * ) @@int64@@ & Number ) != Number ) @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) - * ( _QWORD * ) ( @@int64@@ + Number ) ; else @@int64@@ = Number L ; return * ( _QWORD * ) ( @@int64@@ + Number ) - * ( _QWORD * ) ( @@int64@@ + Number ) + @@int64@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_2070C8 ; @@int648@@ [ Number ] = qword_2070D0 ; @@int648@@ [ Number ] = qword_2070D8 ; @@int648@@ [ Number ] = qword_2070E0 ; @@int648@@ [ Number ] = qword_2070E8 ; @@int648@@ [ Number ] = qword_2070F0 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 __fastcall cmp_extension ( const char * * @@constchar@@ , const char * * @@constchar@@ , __int64 ( __fastcall * @ @ VAR_525 @ @ int64 ( fastcall ) ( constchar , constchar ) @ @ int ( ) ( constchar , constchar ) ) ( const char * , const char * ) ) { const char * @@constchar@@ ; const char * @@constchar@@ ; __int64 @@int64@@ ; unsigned int @@unsignedint@@ ; char * @@char@@ ; char * @@char@@ ; @@char@@ = strrchr ( * @@constchar@@ , Number ) ; @@char@@ = strrchr ( * @@constchar@@ , Number ) ; if ( @@char@@ ) @@constchar@@ = @@char@@ ; else @@constchar@@ = & off_16E97 [ Number ] ; if ( @@char@@ ) @@constchar@@ = @@char@@ ; else @@constchar@@ = & off_16E97 [ Number ] ; @@unsignedint@@ = @ @ VAR_525 @ @ int64 ( fastcall ) ( constchar , constchar ) @ @ int ( ) ( constchar , constchar ) ( @@constchar@@ , @@constchar@@ ) ; if ( @@unsignedint@@ ) @@int64@@ = @@unsignedint@@ ; else @@int64@@ = @ @ VAR_525 @ @ int64 ( fastcall ) ( constchar , constchar ) @ @ int ( ) ( constchar , constchar ) ( * @@constchar@@ , * @@constchar@@ ) ; return @@int64@@ ; }
__int64 clear_files ( ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; void * * @@void@@ ; for ( @@unsignedint64@@ = Number L ; ; ++ @@unsignedint64@@ ) { @@int64@@ = cwd_n_used ; if ( @@unsignedint64@@ >= cwd_n_used ) break ; @@void@@ = ( void * * ) * ( ( _QWORD * ) sorted_file + @@unsignedint64@@ ) ; free ( * @@void@@ ) ; free ( @@void@@ [ Number ] ) ; if ( @@void@@ [ Number ] != & UNKNOWN_SECURITY_CONTEXT ) freecon ( ) ; } cwd_n_used = Number L ; any_has_acl = Number ; inode_number_width = Number ; block_size_width = Number ; nlink_width = Number ; owner_width = Number ; group_width = Number ; author_width = Number ; scontext_width = Number ; major_device_number_width = Number ; minor_device_number_width = Number ; file_size_width = Number ; return @@int64@@ ; }
int __fastcall argmatch_valid ( __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { char * @@char@@ ; __int64 @@int64@@ ; void * @@void@@ ; @@void@@ = Number L ; @@char@@ = gettext ( String ) ; fprintf ( stderr , @@char@@ ) ; for ( @@int64@@ = Number L ; * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; ++ @@int64@@ ) { if ( @@int64@@ && ! memcmp ( @@void@@ , ( const void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) , @@sizet@@ ) ) { fprintf ( stderr , String , * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) ) ; } else { fprintf ( stderr , String , * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) ) ; @@void@@ = ( void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) ; } } return putc_unlocked ( Number , stderr ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
__int64 __fastcall format_user_or_group ( const char * @@constchar@@ , __int64 @@int64@@ , int @@int@@ ) { int @@int@@ ; __int64 @@int64@@ ; int @@int@@ ; int @@int@@ ; size_t @@sizet@@ ; if ( @@constchar@@ ) { @@int@@ = @@int@@ - gnu_mbswidth ( @@constchar@@ , Number L ) ; @@int@@ = Number ; if ( @@int@@ >= Number ) @@int@@ = @@int@@ ; @@int@@ = @@int@@ ; fputs_unlocked ( @@constchar@@ , stdout ) ; @@sizet@@ = strlen ( @@constchar@@ ) + @@int@@ ; do putchar_unlocked ( Number ) ; while ( @@int@@ -- ) ; } else { printf ( String , @@int@@ , @@int64@@ ) ; @@sizet@@ = @@int@@ ; } @@int64@@ = dired_pos + @@sizet@@ + Number ; dired_pos = @@int64@@ ; return @@int64@@ ; }
__int64 __fastcall cmp_atime ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ , __int64 ( __fastcall * @ @ VAR_510 @ @ int64 ( fastcall ) ( QWORD , QWORD ) @ @ int ( ) ( constchar , constchar ) ) ( _QWORD , _QWORD ) ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = get_stat_atime ( ( __int64 ) ( @@QWORD@@ + Number ) ) ; @@int64@@ = @@int64@@ ; @@int64@@ = get_stat_atime ( ( __int64 ) ( @@QWORD@@ + Number ) ) ; @@unsignedint@@ = timespec_cmp ( @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( @@unsignedint@@ ) @@int64@@ = @@unsignedint@@ ; else @@int64@@ = @ @ VAR_510 @ @ int64 ( fastcall ) ( QWORD , QWORD ) @ @ int ( ) ( constchar , constchar ) ( * @@QWORD@@ , * @@QWORD@@ ) ; return @@int64@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall rpl_fcntl ( int @@int@@ , int @@int@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ ) { int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; if ( @@int@@ != Number ) return ( unsigned int ) fcntl ( @@int@@ , @@int@@ , @@int64@@ ) ; @@int@@ = @@int64@@ ; if ( have_dupfd_cloexec_2895 < Number ) { @@int@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@int@@ , Number , @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ ) ; } else { @@int@@ = fcntl ( @@int@@ , Number , ( unsigned int ) @@int64@@ ) ; if ( @@int@@ < Number && * __errno_location ( ) == Number ) { @@int@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@int@@ , Number , @@int@@ , @@int@@ , @@int@@ , @@int@@ ) ; if ( @@int@@ < Number ) return ( unsigned int ) @@int@@ ; have_dupfd_cloexec_2895 = Number ; } else { have_dupfd_cloexec_2895 = Number ; } } if ( @@int@@ >= Number && have_dupfd_cloexec_2895 == Number ) { @@int@@ = fcntl ( @@int@@ , Number ) ; if ( @@int@@ < Number || fcntl ( @@int@@ , Number , @@int@@ | Number ) == Number ) { @@int@@ = * __errno_location ( ) ; close ( @@int@@ ) ; * __errno_location ( ) = @@int@@ ; @@int@@ = Number ; } } return ( unsigned int ) @@int@@ ; }
__int64 __fastcall mode_create_from_ref ( char * @@char@@ ) { __int64 @@int64@@ ; struct stat @@structstat@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( ( unsigned int ) stat ( @@char@@ , & @@structstat@@ ) ) @@int64@@ = Number L ; else @@int64@@ = make_node_op_equals ( @@structstat@@ . st_mode , Number ) ; return @@int64@@ ; }
size_t __fastcall put_indicator ( __int64 @@int64@@ ) { if ( used_color != Number ) { used_color = Number ; prep_non_filename_text ( ) ; } return fwrite_unlocked ( * ( const void * * ) ( @@int64@@ + Number ) , * ( _QWORD * ) @@int64@@ , Number , stdout ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 print_current_files ( ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int64@@ = ( unsigned int ) format ; switch ( format ) { case Number : for ( @@unsignedint64@@ = Number L ; ; ++ @@unsignedint64@@ ) { @@int64@@ = cwd_n_used ; if ( @@unsignedint64@@ >= cwd_n_used ) break ; print_long_format ( * ( ( _QWORD * ) sorted_file + @@unsignedint64@@ ) ) ; putchar_unlocked ( Number ) ; ++ dired_pos ; } break ; case Number : for ( @@unsignedint64@@ = Number L ; ; ++ @@unsignedint64@@ ) { @@int64@@ = cwd_n_used ; if ( @@unsignedint64@@ >= cwd_n_used ) break ; print_file_name_and_frills ( * ( ( _QWORD * ) sorted_file + @@unsignedint64@@ ) , Number L ) ; putchar_unlocked ( Number ) ; } break ; case Number : @@int64@@ = print_many_per_line ( ) ; break ; case Number : @@int64@@ = print_horizontal ( ) ; break ; case Number : @@int64@@ = print_with_commas ( ) ; break ; default : return @@int64@@ ; } return @@int64@@ ; }
_DWORD * __fastcall md5_buffer ( __int64 @@int64@@ , __int64 @@int64@@ , _DWORD * @@DWORD@@ ) { int @@int@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; md5_init_ctx ( @@int@@ ) ; md5_process_bytes ( @@int64@@ , @@int64@@ , @@int@@ ) ; return md5_finish_ctx ( @@int@@ , @@DWORD@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
size_t __fastcall print_name_with_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , struct obstack * @@structobstack@@ , unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; bool @@bool@@ ; bool @@bool@@ ; __int64 @@int64@@ ; size_t @@sizet@@ ; if ( @@unsignedint8@@ ) @@int64@@ = @@int64@@ [ Number ] ; else @@int64@@ = * @@int64@@ ; @@int64@@ = @@int64@@ ; @@bool@@ = print_with_color && ( unsigned __int8 ) print_color_indicator ( @@int64@@ , @@unsignedint8@@ ) ; @@bool@@ = @@bool@@ ; if ( @@structobstack@@ && dired ) { if ( @@structobstack@@ -> next_free + Number > @@structobstack@@ -> chunk_limit ) _obstack_newchunk ( @@structobstack@@ , Number ) ; memcpy ( @@structobstack@@ -> next_free , & dired_pos , Number ) ; @@structobstack@@ -> next_free += Number ; } @@sizet@@ = quote_name ( stdout , @@int64@@ , filename_quoting_options , Number L ) ; dired_pos += @@sizet@@ ; if ( @@structobstack@@ && dired ) { if ( @@structobstack@@ -> next_free + Number > @@structobstack@@ -> chunk_limit ) _obstack_newchunk ( @@structobstack@@ , Number ) ; memcpy ( @@structobstack@@ -> next_free , & dired_pos , Number ) ; @@structobstack@@ -> next_free += Number ; } if ( @@bool@@ ) { process_signals ( ) ; prep_non_filename_text ( ) ; if ( @@unsignedint64@@ / line_length != ( @@unsignedint64@@ + @@sizet@@ - Number ) / line_length ) put_indicator ( & unk_21F1F0 ) ; } return @@sizet@@ ; }
__int64 __fastcall length_of_file_name_and_frills ( __int64 @@int64@@ ) { const char * @@constchar@@ ; __int64 @@int64@@ ; const char * @@constchar@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; char @@char@@ ; size_t @@sizet@@ ; __int64 @@int64@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = Number L ; if ( print_inode ) { if ( format == Number ) { @@constchar@@ = ( const char * ) umaxtostr ( * ( _QWORD * ) ( @@int64@@ + Number ) , @@char@@ ) ; @@int64@@ = strlen ( @@constchar@@ ) + Number ; } else { @@int64@@ = inode_number_width + Number L ; } @@int64@@ += @@int64@@ ; } if ( print_block_size ) { if ( format == Number ) { if ( * ( _BYTE * ) ( @@int64@@ + Number ) != Number ) @@constchar@@ = String ; else @@constchar@@ = ( const char * ) human_readable ( * ( _QWORD * ) ( @@int64@@ + Number ) , @@char@@ , ( unsigned int ) human_output_opts , Number L , output_block_size ) ; @@int64@@ = strlen ( @@constchar@@ ) + Number ; } else { @@int64@@ = block_size_width + Number L ; } @@int64@@ += @@int64@@ ; } if ( print_scontext ) { if ( format == Number ) @@int64@@ = strlen ( * ( const char * * ) ( @@int64@@ + Number ) ) + Number ; else @@int64@@ = scontext_width + Number L ; @@int64@@ += @@int64@@ ; } quote_name ( Number L , * ( _QWORD * ) @@int64@@ , filename_quoting_options , & @@sizet@@ ) ; @@int64@@ += @@sizet@@ ; if ( indicator_style ) { @@char@@ = get_type_indicator ( * ( _BYTE * ) ( @@int64@@ + Number ) , * ( _DWORD * ) ( @@int64@@ + Number ) , * ( _DWORD * ) ( @@int64@@ + Number ) ) ; @@int64@@ += @@char@@ != Number ; } return @@int64@@ ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
unsigned __int64 __fastcall md5_process_bytes ( char * @@char@@ , unsigned __int64 @@unsignedint64@@ , unsigned int * @@unsignedint@@ ) { unsigned __int64 @@unsignedint64@@ ; size_t @@sizet@@ ; void * @@void@@ ; size_t @@sizet@@ ; char * @@char@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; __int64 @@int64@@ ; size_t @@sizet@@ ; @@char@@ = @@char@@ ; @@sizet@@ = @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint@@ [ Number ] ; if ( ( _DWORD ) @@unsignedint64@@ ) { @@int64@@ = @@unsignedint@@ [ Number ] ; @@sizet@@ = Number - @@int64@@ ; if ( @@unsignedint64@@ <= Number - @@int64@@ ) @@sizet@@ = @@unsignedint64@@ ; @@sizet@@ = @@sizet@@ ; memcpy ( ( char * ) @@unsignedint@@ + @@int64@@ + Number , @@char@@ , @@sizet@@ ) ; @@unsignedint@@ [ Number ] += @@sizet@@ ; if ( @@unsignedint@@ [ Number ] > Number ) { md5_process_block ( @@unsignedint@@ + Number , @@unsignedint@@ [ Number ] & Number , @@unsignedint@@ ) ; @@unsignedint@@ [ Number ] &= Number ; memcpy ( @@unsignedint@@ + Number , ( char * ) @@unsignedint@@ + ( ( @@int64@@ + @@sizet@@ ) & Number ) + Number , @@unsignedint@@ [ Number ] ) ; } @@char@@ = & @@char@@ [ @@sizet@@ ] ; @@unsignedint64@@ = @@sizet@@ ; @@sizet@@ = @@unsignedint64@@ - @@sizet@@ ; } if ( @@sizet@@ > Number ) { @@unsignedint64@@ = ( unsigned __int8 ) @@char@@ & Number ; if ( ( ( unsigned __int8 ) @@char@@ & Number ) != Number ) { while ( @@sizet@@ > Number ) { @@void@@ = memcpy ( @@unsignedint@@ + Number , @@char@@ , Number ) ; @@unsignedint64@@ = md5_process_block ( @@void@@ , Number L , @@unsignedint@@ ) ; @@char@@ += Number ; @@sizet@@ -= Number L ; } } else { md5_process_block ( @@char@@ , @@sizet@@ & Number , @@unsignedint@@ ) ; @@unsignedint64@@ = @@sizet@@ & Number ; @@char@@ += @@sizet@@ & Number ; @@sizet@@ &= Number ; } } if ( @@sizet@@ ) { @@sizet@@ = @@unsignedint@@ [ Number ] ; memcpy ( ( char * ) @@unsignedint@@ + @@sizet@@ + Number , @@char@@ , @@sizet@@ ) ; @@sizet@@ = @@sizet@@ + @@sizet@@ ; if ( @@sizet@@ > Number ) { md5_process_block ( @@unsignedint@@ + Number , Number L , @@unsignedint@@ ) ; @@sizet@@ -= Number L ; memcpy ( @@unsignedint@@ + Number , @@unsignedint@@ + Number , @@sizet@@ ) ; } @@unsignedint64@@ = ( unsigned __int64 ) @@unsignedint@@ ; @@unsignedint@@ [ Number ] = @@sizet@@ ; } return @@unsignedint64@@ ; }
__int64 __fastcall fd_reopen ( int @@int@@ , const char * @@constchar@@ , int @@int@@ , unsigned int @@unsignedint@@ ) { int @@int@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; @@int@@ = open ( @@constchar@@ , @@int@@ , @@unsignedint@@ ) ; if ( @@int@@ == @@int@@ || @@int@@ < Number ) return ( unsigned int ) @@int@@ ; @@unsignedint@@ = dup2 ( @@int@@ , @@int@@ ) ; @@int@@ = * __errno_location ( ) ; close ( @@int@@ ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
unsigned __int64 __fastcall calculate_columns ( char @@char@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = max_idx ; if ( cwd_n_used <= ( unsigned __int64 ) max_idx ) @@int64@@ = cwd_n_used ; @@unsignedint64@@ = @@int64@@ ; init_column_info ( ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < cwd_n_used ; ++ @@unsignedint64@@ ) { @@int64@@ = length_of_file_name_and_frills ( * ( ( _QWORD * ) sorted_file + @@unsignedint64@@ ) ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@unsignedint64@@ ; ++ @@unsignedint64@@ ) { if ( * ( _BYTE * ) ( column_info + Number * @@unsignedint64@@ ) ) { @@unsignedint64@@ = @@char@@ ? @@unsignedint64@@ / ( ( cwd_n_used + @@unsignedint64@@ ) / ( @@unsignedint64@@ + Number ) ) : @@unsignedint64@@ % ( @@unsignedint64@@ + Number ) ; @@int64@@ = @@unsignedint64@@ == @@unsignedint64@@ ? Number L : Number L ; @@int64@@ = @@int64@@ + @@int64@@ ; if ( ( unsigned __int64 ) ( @@int64@@ + @@int64@@ ) > * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( column_info + Number * @@unsignedint64@@ + Number ) ) ) { * ( _QWORD * ) ( column_info + Number * @@unsignedint64@@ + Number ) += @@int64@@ - * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( column_info + Number * @@unsignedint64@@ + Number ) ) ; * ( _QWORD * ) ( * ( _QWORD * ) ( column_info + Number * @@unsignedint64@@ + Number ) + Number * @@unsignedint64@@ ) = @@int64@@ ; * ( _BYTE * ) ( column_info + Number * @@unsignedint64@@ ) = * ( _QWORD * ) ( column_info + Number * @@unsignedint64@@ + Number ) < ( unsigned __int64 ) line_length ; } } } } for ( @@unsignedint64@@ = @@unsignedint64@@ ; @@unsignedint64@@ > Number && ! * ( _BYTE * ) ( column_info + Number * @@unsignedint64@@ - Number ) ; -- @@unsignedint64@@ ) { ; } return @@unsignedint64@@ ; }
int print_horizontal ( ) { unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; @@unsignedint64@@ = Number L ; @@unsignedint64@@ = calculate_columns ( Number L ) ; @@int64@@ = column_info + Number * @@unsignedint64@@ - Number ; @@int64@@ = * ( _QWORD * ) sorted_file ; @@int64@@ = length_of_file_name_and_frills ( * ( _QWORD * ) sorted_file ) ; @@int64@@ = * * ( _QWORD * * ) ( @@int64@@ + Number ) ; print_file_name_and_frills ( @@int64@@ , Number L ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < cwd_n_used ; ++ @@unsignedint64@@ ) { if ( @@unsignedint64@@ % @@unsignedint64@@ ) { indent ( @@unsignedint64@@ + @@int64@@ , @@int64@@ + @@unsignedint64@@ ) ; @@unsignedint64@@ += @@int64@@ ; } else { putchar_unlocked ( Number ) ; @@unsignedint64@@ = Number L ; } @@int64@@ = * ( ( _QWORD * ) sorted_file + @@unsignedint64@@ ) ; print_file_name_and_frills ( @@int64@@ , @@unsignedint64@@ ) ; @@int64@@ = length_of_file_name_and_frills ( @@int64@@ ) ; @@int64@@ = * ( _QWORD * ) ( Number * ( @@unsignedint64@@ % @@unsignedint64@@ ) + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; } return putchar_unlocked ( Number ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
_BYTE * __fastcall mbs_align_pad ( _BYTE * @@BYTE@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ ) { _BYTE * @@BYTE@@ ; __int64 @@int64@@ ; while ( Number ) { @@int64@@ = @@int64@@ -- ; if ( ! @@int64@@ || ( unsigned __int64 ) @@BYTE@@ >= @@unsignedint64@@ ) break ; @@BYTE@@ = @@BYTE@@ ++ ; * @@BYTE@@ = Number ; } * @@BYTE@@ = Number ; return @@BYTE@@ ; }
int __fastcall mknod ( char * @@char@@ , __mode_t @@modet@@ , __dev_t @@devt@@ ) { __dev_t @@devt2@@ [ Number ] ; @@devt2@@ [ Number ] = @@devt@@ ; return __xmknod ( Number , @@char@@ , @@modet@@ , @@devt2@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 __fastcall verrevcmp ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { int @@int@@ ; int @@int@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = Number L ; @@unsignedint64@@ = Number L ; while ( @@unsignedint64@@ < @@unsignedint64@@ || @@unsignedint64@@ < @@unsignedint64@@ ) { @@unsignedint@@ = Number ; while ( @@unsignedint64@@ < @@unsignedint64@@ && ( unsigned __int8 ) c_isdigit ( ( unsigned int ) * ( char * ) ( @@int64@@ + @@unsignedint64@@ ) ) != Number || @@unsignedint64@@ < @@unsignedint64@@ && ( unsigned __int8 ) c_isdigit ( ( unsigned int ) * ( char * ) ( @@int64@@ + @@unsignedint64@@ ) ) != Number ) { if ( @@unsignedint64@@ == @@unsignedint64@@ ) @@int@@ = Number ; else @@int@@ = order ( * ( _BYTE * ) ( @@int64@@ + @@unsignedint64@@ ) ) ; @@int@@ = @@int@@ ; if ( @@unsignedint64@@ == @@unsignedint64@@ ) @@int@@ = Number ; else @@int@@ = order ( * ( _BYTE * ) ( @@int64@@ + @@unsignedint64@@ ) ) ; if ( @@int@@ != @@int@@ ) return ( unsigned int ) ( @@int@@ - @@int@@ ) ; ++ @@unsignedint64@@ ; ++ @@unsignedint64@@ ; } while ( * ( _BYTE * ) ( @@int64@@ + @@unsignedint64@@ ) == Number ) ++ @@unsignedint64@@ ; while ( * ( _BYTE * ) ( @@int64@@ + @@unsignedint64@@ ) == Number ) ++ @@unsignedint64@@ ; while ( ( unsigned __int8 ) c_isdigit ( ( unsigned int ) * ( char * ) ( @@int64@@ + @@unsignedint64@@ ) ) && ( unsigned __int8 ) c_isdigit ( ( unsigned int ) * ( char * ) ( @@int64@@ + @@unsignedint64@@ ) ) ) { if ( ! @@unsignedint@@ ) @@unsignedint@@ = * ( char * ) ( @@int64@@ + @@unsignedint64@@ ) - * ( char * ) ( @@int64@@ + @@unsignedint64@@ ) ; ++ @@unsignedint64@@ ; ++ @@unsignedint64@@ ; } if ( ( unsigned __int8 ) c_isdigit ( ( unsigned int ) * ( char * ) ( @@int64@@ + @@unsignedint64@@ ) ) ) return Number L ; if ( ( unsigned __int8 ) c_isdigit ( ( unsigned int ) * ( char * ) ( @@int64@@ + @@unsignedint64@@ ) ) ) return Number ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; } return Number L ; }
__int64 __fastcall argmatch ( const char * @@constchar@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { __int64 @@int64@@ ; char @@char@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; size_t @@sizet@@ ; @@int64@@ = Number ; @@char@@ = Number ; @@sizet@@ = strlen ( @@constchar@@ ) ; for ( @@int64@@ = Number L ; * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; ++ @@int64@@ ) { if ( ! strncmp ( * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) , @@constchar@@ , @@sizet@@ ) ) { if ( @@sizet@@ == strlen ( * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) ) ) return @@int64@@ ; if ( @@int64@@ == Number ) { @@int64@@ = @@int64@@ ; } else if ( ! @@int64@@ || memcmp ( ( const void * ) ( @@sizet@@ * @@int64@@ + @@int64@@ ) , ( const void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) , @@sizet@@ ) ) { @@char@@ = Number ; } } } if ( @@char@@ ) @@int64@@ = Number ; else @@int64@@ = @@int64@@ ; return @@int64@@ ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
__int64 __fastcall mode_adjust ( __int16 @@int16@@ , unsigned __int8 @@unsignedint8@@ , int @@int@@ , char * @@char@@ , _DWORD * @@DWORD@@ ) { int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; @@unsignedint@@ = @@int16@@ & Number ; @@int@@ = Number ; while ( @@char@@ [ Number ] ) { @@int@@ = * ( ( _DWORD * ) @@char@@ + Number ) ; if ( @@unsignedint8@@ ) @@int@@ = Number ; else @@int@@ = Number ; @@int@@ = @@int@@ & ~ * ( ( _DWORD * ) @@char@@ + Number ) ; @@int@@ = * ( ( _DWORD * ) @@char@@ + Number ) ; @@int@@ = @@char@@ [ Number ] ; if ( @@int@@ == Number ) { if ( @@unsignedint@@ & Number | @@unsignedint8@@ ) @@int@@ |= Number ; } else if ( @@int@@ == Number ) { @@int@@ = @@unsignedint@@ & @@int@@ ; if ( ( @@int@@ & Number ) != Number ) @@int@@ = Number ; else @@int@@ = Number ; if ( ( @@int@@ & Number ) != Number ) @@int@@ = Number ; else @@int@@ = Number ; @@int@@ = @@int@@ | @@int@@ ; if ( ( @@int@@ & Number ) != Number ) @@int@@ = Number ; else @@int@@ = Number ; @@int@@ = @@int@@ | @@int@@ | @@int@@ ; } if ( @@int@@ ) @@int@@ = * ( ( _DWORD * ) @@char@@ + Number ) ; else @@int@@ = ~ @@int@@ ; @@int@@ = ~ @@int@@ & @@int@@ & @@int@@ ; @@int@@ = * @@char@@ ; switch ( @@int@@ ) { case String : @@int@@ |= @@int@@ ; @@unsignedint@@ &= ~ @@int@@ ; break ; case String : if ( @@int@@ ) @@int@@ = ~ @@int@@ ; else @@int@@ = Number ; @@int@@ |= ~ ( ( unsigned __int16 ) @@int@@ | ( unsigned __int16 ) @@int@@ ) & Number ; @@unsignedint@@ = @@int@@ | ( @@int@@ | @@int@@ ) & @@unsignedint@@ ; break ; case String : @@int@@ |= @@int@@ ; @@unsignedint@@ |= @@int@@ ; break ; } @@char@@ += Number ; } if ( @@DWORD@@ ) * @@DWORD@@ = @@int@@ ; return @@unsignedint@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall get_stat_mtime ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
__int64 __fastcall mbsnwidth ( char * @@char@@ , __int64 @@int64@@ , char @@char@@ ) { int @@int@@ ; char * @@char@@ ; unsigned __int8 @@unsignedint8@@ ; wchar_t @@wchart@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; char * @@char@@ ; size_t @@sizet@@ ; char * @@char@@ ; mbstate_t @@mbstatet2@@ [ Number ] ; @@mbstatet2@@ [ Number ] = ( mbstate_t ) __readfsqword ( Number ) ; @@char@@ = @@char@@ ; @@char@@ = & @@char@@ [ @@int64@@ ] ; @@unsignedint@@ = Number ; if ( __ctype_get_mb_cur_max ( ) > Number ) { while ( Number ) { LABEL_28 : if ( @@char@@ >= @@char@@ ) return @@unsignedint@@ ; @@int@@ = * @@char@@ ; if ( @@int@@ > Number ) { if ( @@int@@ < Number || @@int@@ > Number && ( unsigned int ) ( @@int@@ - Number ) > Number ) { LABEL_11 : memset ( @@mbstatet2@@ , Number , Number ) ; while ( Number ) { @@sizet@@ = mbrtowc ( & @@wchart@@ , @@char@@ , @@char@@ - @@char@@ , @@mbstatet2@@ ) ; if ( @@sizet@@ == Number ) { if ( ( @@char@@ & Number ) == Number ) { ++ @@char@@ ; ++ @@unsignedint@@ ; goto LABEL_28 ; } return Number ; } if ( @@sizet@@ == Number ) break ; if ( ! @@sizet@@ ) @@sizet@@ = Number L ; @@int@@ = wcwidth ( @@wchart@@ ) ; if ( @@int@@ < Number ) { if ( ( @@char@@ & Number ) != Number ) return Number ; @@unsignedint@@ += iswcntrl ( @@wchart@@ ) == Number ; } else { @@unsignedint@@ += @@int@@ ; } @@char@@ += @@sizet@@ ; if ( mbsinit ( @@mbstatet2@@ ) ) goto LABEL_28 ; } if ( ( @@char@@ & Number ) == Number ) { @@char@@ = @@char@@ ; ++ @@unsignedint@@ ; continue ; } return Number ; } } else if ( @@int@@ < Number && ( unsigned int ) ( @@int@@ - Number ) > Number ) { goto LABEL_11 ; } ++ @@char@@ ; ++ @@unsignedint@@ ; } } while ( @@char@@ < @@char@@ ) { @@char@@ = @@char@@ ++ ; @@unsignedint8@@ = * @@char@@ ; if ( ( ( * __ctype_b_loc ( ) ) [ @@unsignedint8@@ ] & Number ) != Number ) { ++ @@unsignedint@@ ; } else { if ( ( @@char@@ & Number ) != Number ) return Number ; @@unsignedint@@ += ( ( * __ctype_b_loc ( ) ) [ @@unsignedint8@@ ] & Number ) == Number ; } } return @@unsignedint@@ ; }
__int64 __fastcall file_failure ( unsigned __int8 @@unsignedint8@@ , const char * @@constchar@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; int * @@int@@ ; @@int64@@ = quotearg_colon ( @@int64@@ ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@constchar@@ , @@int64@@ ) ; return set_exit_status ( @@unsignedint8@@ ) ; }
__int64 __fastcall file_name_concat ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = mfile_name_concat ( @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( ! @@int64@@ ) xalloc_die ( ) ; return @@int64@@ ; }
_BOOL8 __fastcall dev_ino_compare ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ ) { return * @@QWORD@@ == * @@QWORD@@ && @@QWORD@@ [ Number ] == @@QWORD@@ [ Number ] ; }
_BYTE * __fastcall longest_relative_suffix ( _BYTE * @@BYTE@@ ) { while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; return @@BYTE@@ ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
__int64 __fastcall patterns_match ( __int64 @@int64@@ , const char * @@constchar@@ ) { while ( @@int64@@ ) { if ( ! fnmatch ( * ( const char * * ) @@int64@@ , @@constchar@@ , Number ) ) return Number L ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; } return Number L ; }
_BOOL8 __fastcall is_directory ( __int64 @@int64@@ ) { return * ( _DWORD * ) ( @@int64@@ + Number ) == Number || * ( _DWORD * ) ( @@int64@@ + Number ) == Number ; }
_BOOL8 __fastcall is_colored ( unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; char * @@char@@ ; @@int64@@ = * ( ( _QWORD * ) & color_indicator + Number * @@unsignedint@@ ) ; @@char@@ = ( char * ) * ( & off_21F088 + Number * @@unsignedint@@ ) ; return @@int64@@ && ( @@int64@@ != Number || * @@char@@ != Number ) && ( @@int64@@ != Number || strncmp ( @@char@@ , off_16E97 , Number ) ) ; }
__int64 __fastcall hard_locale ( int @@int@@ ) { unsigned __int8 @@unsignedint8@@ ; const char * @@constchar@@ ; @@unsignedint8@@ = Number ; @@constchar@@ = setlocale ( @@int@@ , Number L ) ; if ( @@constchar@@ && ( ! strcmp ( @@constchar@@ , String ) || ! strcmp ( @@constchar@@ , String ) ) ) { @@unsignedint8@@ = Number ; } return @@unsignedint8@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
__int64 __fastcall make_link_name ( const char * @@constchar@@ , const char * @@constchar@@ ) { size_t @@sizet@@ ; char * @@char@@ ; char * @@char@@ ; __int64 @@int64@@ ; if ( ! @@constchar@@ ) return Number L ; if ( * @@constchar@@ == Number ) return xstrdup ( @@constchar@@ ) ; @@char@@ = strrchr ( @@constchar@@ , Number ) ; if ( ! @@char@@ ) return xstrdup ( @@constchar@@ ) ; @@int64@@ = @@char@@ - @@constchar@@ + Number ; @@sizet@@ = strlen ( @@constchar@@ ) ; @@char@@ = ( char * ) xmalloc ( @@sizet@@ + @@int64@@ + Number ) ; strncpy ( @@char@@ , @@constchar@@ , @@int64@@ ) ; strcpy ( & @@char@@ [ @@int64@@ ] , @@constchar@@ ) ; return ( __int64 ) @@char@@ ; }
__int64 __fastcall queue_directory ( __int64 @@int64@@ , __int64 @@int64@@ , char @@char@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = xmalloc ( Number L ) ; if ( @@int64@@ ) @@int64@@ = xstrdup ( @@int64@@ ) ; else @@int64@@ = Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; if ( @@int64@@ ) @@int64@@ = xstrdup ( @@int64@@ ) ; else @@int64@@ = Number L ; * ( _QWORD * ) @@int64@@ = @@int64@@ ; * ( _BYTE * ) ( @@int64@@ + Number ) = @@char@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = pending_dirs ; @@int64@@ = @@int64@@ ; pending_dirs = @@int64@@ ; return @@int64@@ ; }
int __fastcall hash_print_statistics ( __int64 @@int64@@ , FILE * @@FILE@@ ) { double @@double@@ ; double @@double@@ ; double @@double@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int64@@ = hash_get_n_entries ( @@int64@@ ) ; @@int64@@ = hash_get_n_buckets ( @@int64@@ ) ; @@int64@@ = hash_get_n_buckets_used ( @@int64@@ ) ; @@unsignedint64@@ = hash_get_max_bucket_length ( @@int64@@ ) ; fprintf ( @@FILE@@ , String , @@int64@@ ) ; fprintf ( @@FILE@@ , String , @@int64@@ ) ; if ( @@int64@@ < Number ) @@double@@ = ( double ) ( int ) ( @@int64@@ & Number | ( ( unsigned __int64 ) @@int64@@ >> Number ) ) + ( double ) ( int ) ( @@int64@@ & Number | ( ( unsigned __int64 ) @@int64@@ >> Number ) ) ; else @@double@@ = ( double ) ( int ) @@int64@@ ; @@double@@ = Number * @@double@@ ; if ( @@int64@@ < Number ) @@double@@ = ( double ) ( int ) ( @@int64@@ & Number | ( ( unsigned __int64 ) @@int64@@ >> Number ) ) + ( double ) ( int ) ( @@int64@@ & Number | ( ( unsigned __int64 ) @@int64@@ >> Number ) ) ; else @@double@@ = ( double ) ( int ) @@int64@@ ; fprintf ( @@FILE@@ , String , @@int64@@ , @@double@@ / @@double@@ ) ; return fprintf ( @@FILE@@ , String , @@unsignedint64@@ ) ; }
_BOOL8 __fastcall hash_table_ok ( __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; @@int64@@ = Number L ; @@int64@@ = Number L ; for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { @@QWORD@@ = @@QWORD@@ ; ++ @@int64@@ ; ++ @@int64@@ ; while ( Number ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; if ( ! @@QWORD@@ ) break ; ++ @@int64@@ ; } } } return @@int64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) && @@int64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
__int64 __fastcall cmp_size ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ , __int64 ( __fastcall * @ @ VAR_514 @ @ int64 ( fastcall ) ( QWORD , QWORD ) @ @ int ( ) ( constchar , constchar ) ) ( _QWORD , _QWORD ) ) { __int64 @@int64@@ ; if ( @@QWORD@@ [ Number ] < @@QWORD@@ [ Number ] ) LODWORD ( @@int64@@ ) = Number ; else LODWORD ( @@int64@@ ) = @@QWORD@@ [ Number ] > @@QWORD@@ [ Number ] ; if ( ( _DWORD ) @@int64@@ ) @@int64@@ = ( unsigned int ) @@int64@@ ; else @@int64@@ = @ @ VAR_514 @ @ int64 ( fastcall ) ( QWORD , QWORD ) @ @ int ( ) ( constchar , constchar ) ( * @@QWORD@@ , * @@QWORD@@ ) ; return @@int64@@ ; }
__int64 __fastcall next_prime ( unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = @@unsignedint64@@ ; if ( @@unsignedint64@@ <= Number ) @@int64@@ = Number L ; for ( @@int64@@ = @@int64@@ | Number ; @@int64@@ != Number && ! is_prime ( @@int64@@ ) ; @@int64@@ += Number L ) { ; } return @@int64@@ ; }
__int64 __fastcall extract_dirs_from_files ( __int64 @@int64@@ , char @@char@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 * @@int64@@ ; void * @@void@@ ; if ( @@int64@@ && active_dir_set ) queue_directory ( Number L , @@int64@@ , Number ) ; @@int64@@ = cwd_n_used ; while ( @@int64@@ -- ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) sorted_file + @@int64@@ ) ; if ( is_directory ( ( __int64 ) @@int64@@ ) && ( ! @@int64@@ || ! basename_is_dot_or_dotdot ( * @@int64@@ ) ) ) { if ( @@int64@@ && * ( _BYTE * ) * @@int64@@ != Number ) { @@void@@ = ( void * ) file_name_concat ( @@int64@@ , * @@int64@@ , Number L ) ; queue_directory ( ( __int64 ) @@void@@ , @@int64@@ [ Number ] , @@char@@ ) ; free ( @@void@@ ) ; } else { queue_directory ( * @@int64@@ , @@int64@@ [ Number ] , @@char@@ ) ; } if ( * ( ( _DWORD * ) @@int64@@ + Number ) == Number ) free ( ( void * ) * @@int64@@ ) ; } } @@unsignedint64@@ = Number L ; @@int64@@ = Number L ; while ( @@unsignedint64@@ < cwd_n_used ) { @@int64@@ = * ( ( _QWORD * ) sorted_file + @@unsignedint64@@ ) ; * ( ( _QWORD * ) sorted_file + @@int64@@ ) = @@int64@@ ; @@int64@@ += * ( _DWORD * ) ( @@int64@@ + Number ) != Number ; ++ @@unsignedint64@@ ; } @@int64@@ = @@int64@@ ; cwd_n_used = @@int64@@ ; return @@int64@@ ; }
__int64 __fastcall hash_get_first ( unsigned __int64 * @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; if ( ! @@unsignedint64@@ [ Number ] ) return Number L ; for ( @@unsignedint64@@ = * @@unsignedint64@@ ; ; @@unsignedint64@@ += Number L ) { if ( @@unsignedint64@@ >= @@unsignedint64@@ [ Number ] ) abort ( ) ; if ( * ( _QWORD * ) @@unsignedint64@@ ) break ; } return * ( _QWORD * ) @@unsignedint64@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 sort_files ( ) { __int64 @@int64@@ ; int @@int@@ ; unsigned __int8 @@unsignedint8@@ ; if ( cwd_n_used + ( ( unsigned __int64 ) cwd_n_used >> Number ) > sorted_file_alloc ) { free ( sorted_file ) ; sorted_file = ( void * ) xnmalloc ( cwd_n_used , Number L ) ; sorted_file_alloc = Number * cwd_n_used ; } initialize_ordering_vector ( ) ; @@int64@@ = ( unsigned int ) sort_type ; if ( sort_type != Number ) { if ( _setjmp ( failed_strcoll ) ) { @@unsignedint8@@ = Number ; if ( sort_type == Number ) __assert_fail ( String , String , Number , String ) ; initialize_ordering_vector ( ) ; } else { @@unsignedint8@@ = Number ; } if ( sort_type == Number ) @@int@@ = time_type ; else @@int@@ = Number ; @@int64@@ = mpsort ( sorted_file , cwd_n_used , * ( & sort_functions [ Number * ( unsigned int ) ( @@int@@ + sort_type ) ] + Number * @@unsignedint8@@ + Number * ( unsigned __int8 ) sort_reverse + ( unsigned __int8 ) directories_first ) ) ; } return @@int64@@ ; }
void __fastcall hash_free ( __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) && * ( _QWORD * ) ( @@int64@@ + Number ) ) { for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { for ( @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@int64@@ + Number ) ) ( * @@QWORD@@ ) ; } } } } for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { for ( @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; @@QWORD@@ ; @@QWORD@@ = @@QWORD@@ ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; free ( @@QWORD@@ ) ; } } for ( @@QWORD@@ = * ( _QWORD * * ) ( @@int64@@ + Number ) ; @@QWORD@@ ; @@QWORD@@ = @@QWORD@@ ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; free ( @@QWORD@@ ) ; } free ( * ( void * * ) @@int64@@ ) ; free ( ( void * ) @@int64@@ ) ; }
__int64 long_time_expected_width ( ) { time_t @@timet@@ ; struct tm * @@structtm@@ ; __int64 @@int64@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( width_8232 < Number ) { @@timet@@ = Number L ; @@structtm@@ = localtime ( & @@timet@@ ) ; if ( @@structtm@@ ) { @@int64@@ = align_nstrftime ( ( __int64 ) @@char@@ , Number L , long_time_format , ( __int64 ) @@structtm@@ , Number , Number ) ; if ( @@int64@@ ) width_8232 = mbsnwidth ( @@char@@ , @@int64@@ , Number L ) ; } if ( width_8232 < Number ) width_8232 = Number ; } return ( unsigned int ) width_8232 ; }
__int64 __fastcall hash_do_for_each ( __int64 @@int64@@ , unsigned __int8 ( __fastcall * @ @ VAR_1333 @ @ unsignedint8 ( fastcall ) ( QWORD , int64 ) @ @ Hashprocessor ) ( _QWORD , __int64 ) , __int64 @@int64@@ ) { __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; @@int64@@ = Number L ; for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { for ( @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { if ( @ @ VAR_1333 @ @ unsignedint8 ( fastcall ) ( QWORD , int64 ) @ @ Hashprocessor ( * @@QWORD@@ , @@int64@@ ) != Number ) return @@int64@@ ; ++ @@int64@@ ; } } } return @@int64@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall get_type_indicator ( char @@char@@ , __int16 @@int16@@ , int @@int@@ ) { bool @@bool@@ ; bool @@bool@@ ; bool @@bool@@ ; bool @@bool@@ ; bool @@bool@@ ; bool @@bool@@ ; unsigned __int8 @@unsignedint8@@ ; if ( @@char@@ ) @@bool@@ = ( @@int16@@ & Number ) == Number ; else @@bool@@ = @@int@@ == Number ; if ( @@bool@@ ) { if ( @@char@@ && indicator_style == Number && ( @@int16@@ & Number ) != Number ) @@unsignedint8@@ = Number ; else @@unsignedint8@@ = Number ; } else { if ( @@char@@ ) { @@bool@@ = ( @@int16@@ & Number ) == Number ; } else { @@bool@@ = @@int@@ == Number || @@int@@ == Number ; @@bool@@ = @@bool@@ ; } if ( @@bool@@ ) { @@unsignedint8@@ = Number ; } else if ( indicator_style == Number ) { @@unsignedint8@@ = Number ; } else { if ( @@char@@ ) @@bool@@ = ( @@int16@@ & Number ) == Number ; else @@bool@@ = @@int@@ == Number ; if ( @@bool@@ ) { @@unsignedint8@@ = Number ; } else { if ( @@char@@ ) @@bool@@ = ( @@int16@@ & Number ) == Number ; else @@bool@@ = @@int@@ == Number ; if ( @@bool@@ ) { @@unsignedint8@@ = Number ; } else { if ( @@char@@ ) @@bool@@ = ( @@int16@@ & Number ) == Number ; else @@bool@@ = @@int@@ == Number ; if ( @@bool@@ ) @@unsignedint8@@ = Number ; else @@unsignedint8@@ = Number ; } } } } return @@unsignedint8@@ ; }
__int64 default_block_size ( ) { __int64 @@int64@@ ; if ( getenv ( String ) ) @@int64@@ = Number L ; else @@int64@@ = Number L ; return @@int64@@ ; }
__int64 __fastcall format_group ( unsigned int @@unsignedint@@ , int @@int@@ , char @@char@@ ) { const char * @@constchar@@ ; if ( @@char@@ != Number ) { @@constchar@@ = String ; } else if ( numeric_ids ) { @@constchar@@ = Number L ; } else { @@constchar@@ = ( const char * ) getgroup ( @@unsignedint@@ ) ; } return format_user_or_group ( @@constchar@@ , @@unsignedint@@ , @@int@@ ) ; }
__int64 __fastcall check_tuning ( __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( ( _UNKNOWN * ) @@int64@@ == & default_tuning ) return Number L ; if ( * ( float * ) ( @@int64@@ + Number ) > Number && ( float ) ( Number - Number ) > * ( float * ) ( @@int64@@ + Number ) && * ( float * ) ( @@int64@@ + Number ) > ( float ) ( Number + Number ) && * ( float * ) @@int64@@ >= Number && * ( float * ) ( @@int64@@ + Number ) > ( float ) ( * ( float * ) @@int64@@ + Number ) && * ( float * ) ( @@int64@@ + Number ) <= Number && * ( float * ) ( @@int64@@ + Number ) > ( float ) ( * ( float * ) @@int64@@ + Number ) ) { return Number L ; } * ( _QWORD * ) ( @@int64@@ + Number ) = & default_tuning ; return Number L ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
size_t __fastcall format_user_width ( unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; if ( numeric_ids ) @@int64@@ = Number L ; else @@int64@@ = getuser ( @@unsignedint@@ ) ; return format_user_or_group_width ( @@int64@@ , @@unsignedint@@ ) ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
__int64 __fastcall humblock ( char * @@char@@ , _QWORD * @@QWORD@@ , int * @@int@@ ) { char * @@char@@ ; int @@int@@ ; int @@int@@ ; unsigned int @@unsignedint@@ ; __int64 @@int642@@ [ Number ] ; @@char@@ = @@char@@ ; @@int642@@ [ Number ] = __readfsqword ( Number ) ; @@int@@ = Number ; if ( @@char@@ || ( @@char@@ = getenv ( String ) ) != Number L || ( @@char@@ = getenv ( String ) ) != Number L ) { if ( * @@char@@ == Number ) { @@int@@ = Number ; ++ @@char@@ ; } @@int@@ = argmatch ( @@char@@ , ( __int64 ) block_size_args , ( __int64 ) block_size_opts , Number ) ; if ( @@int@@ < Number ) { @@unsignedint@@ = xstrtoumax ( @@char@@ , @@int642@@ , Number L , @@QWORD@@ , String ) ; if ( @@unsignedint@@ ) { * @@int@@ = Number ; return @@unsignedint@@ ; } while ( * @@char@@ <= Number || * @@char@@ > Number ) { if ( @@char@@ == ( char * ) @@int642@@ [ Number ] ) { @@int@@ |= Number ; if ( * ( _BYTE * ) ( @@int642@@ [ Number ] - Number ) == Number ) @@int@@ |= Number ; if ( * ( _BYTE * ) ( @@int642@@ [ Number ] - Number ) != Number || * ( _BYTE * ) ( @@int642@@ [ Number ] - Number ) == Number ) @@int@@ |= Number ; break ; } ++ @@char@@ ; } } else { @@int@@ |= block_size_opts [ @@int@@ ] ; * @@QWORD@@ = Number L ; } } else { * @@QWORD@@ = default_block_size ( ) ; } * @@int@@ = @@int@@ ; return Number L ; }
_BYTE * __fastcall attach ( _BYTE * @@BYTE@@ , _BYTE * @@BYTE@@ , _BYTE * @@BYTE@@ ) { _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; @@BYTE@@ = @@BYTE@@ ; if ( * @@BYTE@@ != Number || @@BYTE@@ [ Number ] ) { while ( * @@BYTE@@ ) { @@BYTE@@ = @@BYTE@@ ++ ; @@BYTE@@ = @@BYTE@@ ++ ; * @@BYTE@@ = * @@BYTE@@ ; } if ( @@BYTE@@ > @@BYTE@@ && * ( @@BYTE@@ - Number ) != Number ) { @@BYTE@@ = @@BYTE@@ ++ ; * @@BYTE@@ = Number ; } } while ( * @@BYTE@@ ) { @@BYTE@@ = @@BYTE@@ ++ ; @@BYTE@@ = @@BYTE@@ ++ ; * @@BYTE@@ = * @@BYTE@@ ; } @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ = Number ; return @@BYTE@@ ; }
__int64 __fastcall free_entry ( __int64 @@int64@@ , _QWORD * @@QWORD@@ ) { __int64 @@int64@@ ; * @@QWORD@@ = Number L ; @@QWORD@@ [ Number ] = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@QWORD@@ ; return @@int64@@ ; }
size_t __fastcall format_group_width ( unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; if ( numeric_ids ) @@int64@@ = Number L ; else @@int64@@ = getgroup ( @@unsignedint@@ ) ; return format_user_or_group_width ( @@int64@@ , @@unsignedint@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 __fastcall getgidbyname ( const char * @@constchar@@ ) { __int64 @@int64@@ ; size_t @@sizet@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; struct group * @@structgroup@@ ; for ( @@int64@@ = group_alist ; @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ) { if ( * ( _BYTE * ) ( @@int64@@ + Number ) == * @@constchar@@ && ! strcmp ( ( const char * ) ( @@int64@@ + Number ) , @@constchar@@ ) ) { return @@int64@@ ; } } for ( @@int64@@ = nogroup_alist ; @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ) { if ( * ( _BYTE * ) ( @@int64@@ + Number ) == * @@constchar@@ && ! strcmp ( ( const char * ) ( @@int64@@ + Number ) , @@constchar@@ ) ) { return Number L ; } } @@structgroup@@ = getgrnam ( @@constchar@@ ) ; @@sizet@@ = strlen ( @@constchar@@ ) ; @@int64@@ = xmalloc ( @@sizet@@ + Number ) ; strcpy ( ( char * ) ( @@int64@@ + Number ) , @@constchar@@ ) ; if ( @@structgroup@@ ) { * ( _DWORD * ) @@int64@@ = @@structgroup@@ -> gr_gid ; * ( _QWORD * ) ( @@int64@@ + Number ) = group_alist ; group_alist = @@int64@@ ; @@int64@@ = @@int64@@ ; } else { * ( _QWORD * ) ( @@int64@@ + Number ) = nogroup_alist ; nogroup_alist = @@int64@@ ; @@int64@@ = Number L ; } return @@int64@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
_BYTE * __fastcall match_suffix ( _BYTE * * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@BYTE@@ = Number L ; @@char@@ = Number ; while ( * * @@BYTE@@ ) { if ( @@char@@ ) { @@char@@ = Number ; if ( ( unsigned __int8 ) c_isalpha ( ( unsigned int ) ( char ) * * @@BYTE@@ ) != Number && * * @@BYTE@@ != Number ) { @@BYTE@@ = Number L ; } } else if ( * * @@BYTE@@ == Number ) { @@char@@ = Number ; if ( ! @@BYTE@@ ) @@BYTE@@ = * @@BYTE@@ ; } else if ( ( unsigned __int8 ) c_isalnum ( ( unsigned int ) ( char ) * * @@BYTE@@ ) != Number && * * @@BYTE@@ != Number ) { @@BYTE@@ = Number L ; } ++ * @@BYTE@@ ; } return @@BYTE@@ ; }
size_t __fastcall print_file_name_and_frills ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { const char * @@constchar@@ ; int @@int@@ ; const char * @@constchar@@ ; int @@int@@ ; int @@int@@ ; size_t @@sizet@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( print_inode ) { @@constchar@@ = format_inode ( ( __int64 ) @@char@@ , Number , @@int64@@ ) ; if ( format == Number ) @@int@@ = Number ; else @@int@@ = inode_number_width ; printf ( String , @@int@@ , @@constchar@@ ) ; } if ( print_block_size ) { if ( * ( _BYTE * ) ( @@int64@@ + Number ) != Number ) @@constchar@@ = String ; else @@constchar@@ = ( const char * ) human_readable ( * ( _QWORD * ) ( @@int64@@ + Number ) , @@char@@ , ( unsigned int ) human_output_opts , Number L , output_block_size ) ; if ( format == Number ) @@int@@ = Number ; else @@int@@ = block_size_width ; printf ( String , @@int@@ , @@constchar@@ ) ; } if ( print_scontext ) { if ( format == Number ) @@int@@ = Number ; else @@int@@ = scontext_width ; printf ( String , @@int@@ , * ( const char * * ) ( @@int64@@ + Number ) ) ; } @@sizet@@ = print_name_with_quoting ( ( __int64 * ) @@int64@@ , Number , Number L , @@unsignedint64@@ ) ; if ( indicator_style ) @@sizet@@ += ( unsigned __int8 ) print_type_indicator ( * ( unsigned __int8 * ) ( @@int64@@ + Number ) , * ( unsigned int * ) ( @@int64@@ + Number ) , * ( unsigned int * ) ( @@int64@@ + Number ) ) ; return @@sizet@@ ; }
__int64 __fastcall filevercmp ( const char * @@constchar@@ , const char * @@constchar@@ ) { __int64 @@int64@@ ; _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned int @@unsignedint@@ ; unsigned int @@unsignedint@@ ; _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; size_t @@sizet@@ ; _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; unsigned __int64 @@unsignedint64@@ ; @@int64@@ = ( __int64 ) @@constchar@@ ; @@int64@@ = ( __int64 ) @@constchar@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@unsignedint@@ = strcmp ( @@constchar@@ , @@constchar@@ ) ; if ( ! @@unsignedint@@ ) return Number L ; if ( ! * @@constchar@@ ) return Number ; if ( ! * @@constchar@@ ) return Number L ; if ( ! strcmp ( String , @@constchar@@ ) ) return Number ; if ( ! strcmp ( String , @@constchar@@ ) ) return Number L ; if ( ! strcmp ( String , @@constchar@@ ) ) return Number ; if ( ! strcmp ( String , @@constchar@@ ) ) return Number L ; if ( * @@constchar@@ == Number && * @@constchar@@ != Number ) return Number ; if ( * @@constchar@@ != Number && * @@constchar@@ == Number ) return Number L ; if ( * @@constchar@@ == Number && * @@constchar@@ == Number ) { @@int64@@ = ( __int64 ) ( @@constchar@@ + Number ) ; @@int64@@ = ( __int64 ) ( @@constchar@@ + Number ) ; } @@BYTE@@ = ( _BYTE * ) @@int64@@ ; @@BYTE@@ = ( _BYTE * ) @@int64@@ ; @@BYTE@@ = match_suffix ( & @@BYTE@@ ) ; @@BYTE@@ = match_suffix ( & @@BYTE@@ ) ; if ( @@BYTE@@ ) @@BYTE@@ = @@BYTE@@ ; else @@BYTE@@ = @@BYTE@@ ; @@sizet@@ = ( size_t ) & @@BYTE@@ [ - @@int64@@ ] ; if ( @@BYTE@@ ) @@BYTE@@ = @@BYTE@@ ; else @@BYTE@@ = @@BYTE@@ ; @@BYTE@@ = & @@BYTE@@ [ - @@int64@@ ] ; if ( ( @@BYTE@@ || @@BYTE@@ ) && ( _BYTE * ) @@sizet@@ == @@BYTE@@ && ! strncmp ( ( const char * ) @@int64@@ , ( const char * ) @@int64@@ , @@sizet@@ ) ) { @@sizet@@ = ( size_t ) & @@BYTE@@ [ - @@int64@@ ] ; @@BYTE@@ = & @@BYTE@@ [ - @@int64@@ ] ; } @@unsignedint@@ = verrevcmp ( @@int64@@ , @@sizet@@ , @@int64@@ , ( unsigned __int64 ) @@BYTE@@ ) ; if ( @@unsignedint@@ ) @@int64@@ = @@unsignedint@@ ; else @@int64@@ = @@unsignedint@@ ; return @@int64@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall hash_rehash ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; void * @@void@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@unsignedint64@@ = compute_bucket_size ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( ! @@unsignedint64@@ ) return Number L ; if ( @@unsignedint64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ) return Number L ; @@void@@ = calloc ( @@unsignedint64@@ , Number ) ; if ( ! @@void@@ ) return Number L ; @@unsignedint64@@ = @@unsignedint64@@ ; @@int64@@ = ( __int64 ) @@void@@ + Number * @@unsignedint64@@ ; @@int64@@ = Number L ; @@int64@@ = Number L ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( ( unsigned __int8 ) transfer_entries ( ( __int64 ) & @@void@@ , @@int64@@ , Number ) ) { free ( * ( void * * ) @@int64@@ ) ; * ( _QWORD * ) @@int64@@ = @@void@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@unsignedint64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; @@int64@@ = Number L ; } else { * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; if ( ( unsigned __int8 ) transfer_entries ( @@int64@@ , ( __int64 ) & @@void@@ , Number ) != Number || ( unsigned __int8 ) transfer_entries ( @@int64@@ , ( __int64 ) & @@void@@ , Number ) != Number ) { abort ( ) ; } free ( @@void@@ ) ; @@int64@@ = Number L ; } return @@int64@@ ; }
int print_with_commas ( ) { char @@char@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; @@unsignedint64@@ = Number L ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < cwd_n_used ; ++ @@unsignedint64@@ ) { @@int64@@ = * ( ( _QWORD * ) sorted_file + @@unsignedint64@@ ) ; @@int64@@ = length_of_file_name_and_frills ( @@int64@@ ) ; if ( @@unsignedint64@@ ) { if ( @@unsignedint64@@ + @@int64@@ + Number >= line_length ) { @@unsignedint64@@ = Number L ; @@char@@ = Number ; } else { @@unsignedint64@@ += Number L ; @@char@@ = Number ; } putchar_unlocked ( Number ) ; putchar_unlocked ( @@char@@ ) ; } print_file_name_and_frills ( @@int64@@ , @@unsignedint64@@ ) ; @@unsignedint64@@ += @@int64@@ ; } return putchar_unlocked ( Number ) ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
__int64 __fastcall argmatch_to_argument ( const void * @@constvoid@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; ++ @@int64@@ ) { if ( ! memcmp ( @@constvoid@@ , ( const void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) , @@sizet@@ ) ) return * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; } return Number L ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_2080C8 ; @@int648@@ [ Number ] = qword_2080D0 ; @@int648@@ [ Number ] = qword_2080D8 ; @@int648@@ [ Number ] = qword_2080E0 ; @@int648@@ [ Number ] = qword_2080E8 ; @@int648@@ [ Number ] = qword_2080F0 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
__int64 __fastcall getgroup ( __gid_t @@gidt@@ ) { const char * @@constchar@@ ; size_t @@sizet@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; struct group * @@structgroup@@ ; char * @@char@@ ; @@int64@@ = Number L ; for ( @@int64@@ = group_alist ; @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ) { if ( @@gidt@@ == * ( _DWORD * ) @@int64@@ ) { @@int64@@ = @@int64@@ ; break ; } } if ( ! @@int64@@ ) { @@structgroup@@ = getgrgid ( @@gidt@@ ) ; if ( @@structgroup@@ ) @@constchar@@ = @@structgroup@@ -> gr_name ; else @@constchar@@ = ( const char * ) & unk_19CC0 ; @@char@@ = ( char * ) @@constchar@@ ; @@sizet@@ = strlen ( @@constchar@@ ) ; @@int64@@ = xmalloc ( @@sizet@@ + Number ) ; * ( _DWORD * ) @@int64@@ = @@gidt@@ ; strcpy ( ( char * ) ( @@int64@@ + Number ) , @@char@@ ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = group_alist ; group_alist = @@int64@@ ; } if ( * ( _BYTE * ) ( @@int64@@ + Number ) ) @@int64@@ = @@int64@@ + Number ; else @@int64@@ = Number L ; return @@int64@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_21FE88 ; @@int648@@ [ Number ] = qword_21FE90 ; @@int648@@ [ Number ] = qword_21FE98 ; @@int648@@ [ Number ] = qword_21FEA0 ; @@int648@@ [ Number ] = qword_21FEA8 ; @@int648@@ [ Number ] = qword_21FEB0 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
unsigned __int64 init_column_info ( ) { unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = max_idx ; if ( cwd_n_used <= ( unsigned __int64 ) max_idx ) @@unsignedint64@@ = cwd_n_used ; @@unsignedint64@@ = @@unsignedint64@@ ; if ( @@unsignedint64@@ > column_info_alloc_8572 ) { if ( @@unsignedint64@@ >= ( unsigned __int64 ) max_idx >> Number ) { column_info = xnrealloc ( column_info , max_idx , Number L ) ; @@unsignedint64@@ = max_idx ; } else { column_info = xnrealloc ( column_info , @@unsignedint64@@ , Number L ) ; @@unsignedint64@@ = Number * @@unsignedint64@@ ; } @@unsignedint64@@ = ( @@unsignedint64@@ - column_info_alloc_8572 ) * ( column_info_alloc_8572 + @@unsignedint64@@ + Number ) ; if ( column_info_alloc_8572 + @@unsignedint64@@ + Number < @@unsignedint64@@ || column_info_alloc_8572 + @@unsignedint64@@ + Number != @@unsignedint64@@ / ( @@unsignedint64@@ - column_info_alloc_8572 ) ) { xalloc_die ( ) ; } @@int64@@ = xnmalloc ( @@unsignedint64@@ >> Number , Number L ) ; for ( @@unsignedint64@@ = column_info_alloc_8572 ; @@unsignedint64@@ < @@unsignedint64@@ ; ++ @@unsignedint64@@ ) { * ( _QWORD * ) ( column_info + Number * @@unsignedint64@@ + Number ) = @@int64@@ ; @@int64@@ += Number * ( @@unsignedint64@@ + Number ) ; } column_info_alloc_8572 = @@unsignedint64@@ ; } for ( @@unsignedint64@@ = Number L ; ; ++ @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ ; if ( @@unsignedint64@@ >= @@unsignedint64@@ ) break ; * ( _BYTE * ) ( column_info + Number * @@unsignedint64@@ ) = Number ; * ( _QWORD * ) ( column_info + Number * @@unsignedint64@@ + Number ) = Number * ( @@unsignedint64@@ + Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= @@unsignedint64@@ ; ++ @@unsignedint64@@ ) { * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( column_info + Number * @@unsignedint64@@ + Number ) ) = Number L ; } } return @@unsignedint64@@ ; }
_BYTE * __fastcall strmode ( __int16 @@int16@@ , _BYTE * @@BYTE@@ ) { char @@char@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; _BYTE * @@BYTE@@ ; * @@BYTE@@ = ftypelet ( @@int16@@ ) ; if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) { if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; } else if ( ( @@int16@@ & Number ) != Number ) { @@char@@ = Number ; } else { @@char@@ = Number ; } @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) { if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; } else if ( ( @@int16@@ & Number ) != Number ) { @@char@@ = Number ; } else { @@char@@ = Number ; } @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) { if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; } else if ( ( @@int16@@ & Number ) != Number ) { @@char@@ = Number ; } else { @@char@@ = Number ; } @@BYTE@@ [ Number ] = @@char@@ ; @@BYTE@@ [ Number ] = Number ; @@BYTE@@ = @@BYTE@@ + Number ; @@BYTE@@ [ Number ] = Number ; return @@BYTE@@ ; }
__int64 __fastcall bad_cast ( __int64 @@int64@@ ) { return @@int64@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ ) { return xmalloc ( @@int64@@ ) ; }
void __fastcall mpsort_with_tmp ( __int64 * @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 * @@int64@@ , __int64 ( __fastcall * @ @ VAR_1614 @ @ int64 ( fastcall ) ( int64 , int64 ) @ @ int64 ( fastcall ) ( int64 , int64 ) ) ( __int64 , __int64 ) ) { int @@int@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; if ( @@unsignedint64@@ > Number ) { @@int64@@ = Number L ; @@unsignedint64@@ = @@unsignedint64@@ >> Number ; @@unsignedint64@@ = @@unsignedint64@@ >> Number ; mpsort_with_tmp ( & @@int64@@ [ @@unsignedint64@@ >> Number ] , @@unsignedint64@@ - ( @@unsignedint64@@ >> Number ) , @@int64@@ , @ @ VAR_1614 @ @ int64 ( fastcall ) ( int64 , int64 ) @ @ int64 ( fastcall ) ( int64 , int64 ) ) ; if ( @@unsignedint64@@ >> Number > Number ) mpsort_into_tmp ( @@int64@@ , @@unsignedint64@@ >> Number , @@int64@@ , @ @ VAR_1614 @ @ int64 ( fastcall ) ( int64 , int64 ) @ @ int64 ( fastcall ) ( int64 , int64 ) ) ; else * @@int64@@ = * @@int64@@ ; @@int64@@ = * @@int64@@ ; @@int64@@ = @@int64@@ [ @@unsignedint64@@ ] ; @@int64@@ = Number L ; for ( @@int@@ = @ @ VAR_1614 @ @ int64 ( fastcall ) ( int64 , int64 ) @ @ int64 ( fastcall ) ( int64 , int64 ) ( * @@int64@@ , @@int64@@ ) ; ; @@int@@ = @ @ VAR_1614 @ @ int64 ( fastcall ) ( int64 , int64 ) @ @ int64 ( fastcall ) ( int64 , int64 ) ( @@int64@@ , @@int64@@ ) ) { while ( @@int@@ <= Number ) { @@int64@@ = @@int64@@ ++ ; @@int64@@ [ @@int64@@ ] = @@int64@@ ; if ( ++ @@int64@@ == @@unsignedint64@@ ) return ; @@int64@@ = @@int64@@ [ @@int64@@ ] ; @@int@@ = @ @ VAR_1614 @ @ int64 ( fastcall ) ( int64 , int64 ) @ @ int64 ( fastcall ) ( int64 , int64 ) ( @@int64@@ , @@int64@@ ) ; } @@int64@@ = @@int64@@ ++ ; @@int64@@ [ @@int64@@ ] = @@int64@@ ; if ( ++ @@unsignedint64@@ == @@unsignedint64@@ ) break ; @@int64@@ = @@int64@@ [ @@unsignedint64@@ ] ; } memcpy ( & @@int64@@ [ @@int64@@ ] , & @@int64@@ [ @@int64@@ ] , Number * ( @@unsignedint64@@ - @@int64@@ ) ) ; } else if ( @@unsignedint64@@ == Number ) { @@int64@@ = * @@int64@@ ; @@int64@@ = @@int64@@ [ Number ] ; if ( ( int ) @ @ VAR_1614 @ @ int64 ( fastcall ) ( int64 , int64 ) @ @ int64 ( fastcall ) ( int64 , int64 ) ( * @@int64@@ , @@int64@@ ) > Number ) { * @@int64@@ = @@int64@@ ; @@int64@@ [ Number ] = @@int64@@ ; } } }
__int64 __fastcall rpl_wcswidth ( wchar_t * @@wchart@@ , __int64 @@int64@@ ) { wchar_t * @@wchart@@ ; __int64 @@int64@@ ; int @@int@@ ; int @@int@@ ; for ( @@int@@ = Number ; ; @@int@@ += @@int@@ ) { @@int64@@ = @@int64@@ -- ; if ( ! @@int64@@ || ! * @@wchart@@ ) break ; @@wchart@@ = @@wchart@@ ++ ; @@int@@ = wcwidth ( * @@wchart@@ ) ; if ( @@int@@ == Number ) return Number ; if ( @@int@@ > Number - @@int@@ ) return Number ; } return ( unsigned int ) @@int@@ ; }
__int64 __fastcall get_stat_atime ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
void * __fastcall allocate_entry ( __int64 @@int64@@ ) { __int64 @@int64@@ ; if ( ! * ( _QWORD * ) ( @@int64@@ + Number ) ) return malloc ( Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; return ( void * ) @@int64@@ ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@unsignedint64@@ , int @@int@@ ) { __int64 @@int64@@ ; if ( is_mul_ok ( @@int@@ , * @@unsignedint64@@ ) ) { * @@unsignedint64@@ *= @@int@@ ; @@int64@@ = Number L ; } else { * @@unsignedint64@@ = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall xnrealloc ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { if ( ! is_mul_ok ( @@unsignedint64@@ , @@unsignedint64@@ ) ) xalloc_die ( ) ; return xrealloc ( @@int64@@ , @@unsignedint64@@ * @@unsignedint64@@ ) ; }
__int64 __fastcall get_stat_ctime ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 __fastcall c_toupper ( int @@int@@ ) { __int64 @@int64@@ ; if ( @@int@@ <= Number || @@int@@ > Number ) @@int64@@ = ( unsigned int ) @@int@@ ; else @@int64@@ = ( unsigned int ) ( @@int@@ - Number ) ; return @@int64@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
unsigned __int64 __fastcall xstrtol_error ( unsigned int @@unsignedint@@ , int @@int@@ , char @@char@@ , __int64 @@int64@@ , __int64 @@int64@@ , int @@int@@ ) { char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; char @@char2@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@char@@ = ( char * ) & unk_1A278 ; if ( @@unsignedint@@ > Number ) { if ( @@unsignedint@@ != Number ) goto LABEL_6 ; @@char@@ = String ; } else if ( @@unsignedint@@ >= Number ) { @@char@@ = String ; } else { if ( @@unsignedint@@ != Number ) LABEL_6 : abort ( ) ; @@char@@ = String ; } if ( @@int@@ >= Number ) { @@char@@ = * ( char * * ) ( Number L * @@int@@ + @@int64@@ ) ; } else { @@char@@ = ( char * ) & unk_1A278 - @@int@@ ; @@char2@@ [ Number ] = @@char@@ ; @@char2@@ [ Number ] = Number ; @@char@@ = @@char2@@ ; } @@char@@ = gettext ( @@char@@ ) ; error ( @@int@@ , Number , @@char@@ , @@char@@ , @@char@@ , @@int64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
unsigned int __fastcall dired_dump_obstack ( const char * @@constchar@@ , __int64 @@int64@@ ) { unsigned int @@unsignedint@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; @@unsignedint@@ = ( unsigned int ) ( * ( _DWORD * ) ( @@int64@@ + Number ) - * ( _DWORD * ) ( @@int64@@ + Number ) ) >> Number ; @@unsignedint64@@ = @@unsignedint@@ ; if ( @@unsignedint@@ ) { @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( @@int64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ) * ( _BYTE * ) ( @@int64@@ + Number ) |= Number ; * ( _QWORD * ) ( @@int64@@ + Number ) = ( * ( int * ) ( @@int64@@ + Number ) + * ( _QWORD * ) ( @@int64@@ + Number ) ) & ~ * ( _DWORD * ) ( @@int64@@ + Number ) ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) - * ( _QWORD * ) ( @@int64@@ + Number ) > * ( _QWORD * ) ( @@int64@@ + Number ) - * ( _QWORD * ) ( @@int64@@ + Number ) ) * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; fputs_unlocked ( @@constchar@@ , stdout ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@unsignedint64@@ ; ++ @@unsignedint64@@ ) { printf ( String , * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@int64@@ ) ) ; } @@unsignedint@@ = putchar_unlocked ( Number ) ; } return @@unsignedint@@ ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
__int64 __fastcall hash_find_entry ( __int64 @@int64@@ , __int64 @@int64@@ , _QWORD * @@QWORD@@ , char @@char@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; @@int64@@ = * ( _QWORD * ) @@int64@@ ; @@QWORD@@ = ( _QWORD * ) ( @@int64@@ + Number * ( * ( __int64 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@int64@@ + Number ) ) ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@QWORD@@ >= * ( _QWORD * ) ( @@int64@@ + Number ) ) abort ( ) ; * @@QWORD@@ = @@QWORD@@ ; if ( ! * @@QWORD@@ ) return Number L ; if ( @@int64@@ == * @@QWORD@@ || ( * ( unsigned __int8 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@int64@@ + Number ) ) ( @@int64@@ , * @@QWORD@@ ) ) { @@int64@@ = * @@QWORD@@ ; if ( @@char@@ ) { if ( @@QWORD@@ [ Number ] ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; @@int64@@ = @@QWORD@@ [ Number ] ; * @@QWORD@@ = * @@QWORD@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; free_entry ( @@int64@@ , @@QWORD@@ ) ; } else { * @@QWORD@@ = Number L ; } } @@int64@@ = @@int64@@ ; } else { for ( @@QWORD@@ = @@QWORD@@ ; ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { if ( ! @@QWORD@@ [ Number ] ) return Number L ; if ( @@int64@@ == * ( _QWORD * ) @@QWORD@@ [ Number ] || ( * ( unsigned __int8 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@int64@@ + Number ) ) ( @@int64@@ , * ( _QWORD * ) @@QWORD@@ [ Number ] ) ) { break ; } } @@int64@@ = * ( _QWORD * ) @@QWORD@@ [ Number ] ; if ( @@char@@ ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = @@QWORD@@ [ Number ] ; free_entry ( @@int64@@ , @@QWORD@@ ) ; } @@int64@@ = @@int64@@ ; } return @@int64@@ ; }
__int64 __fastcall _xargmatch_internal ( __int64 @@int64@@ , const char * @@constchar@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ , void ( * @ @ VAR_1227 @ @ void ( ) ( void ) @ @ argmatchexitfn ) ( void ) ) { __int64 @@int64@@ ; @@int64@@ = argmatch ( @@constchar@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; if ( @@int64@@ >= Number ) return @@int64@@ ; argmatch_invalid ( @@int64@@ , ( __int64 ) @@constchar@@ , @@int64@@ ) ; argmatch_valid ( @@int64@@ , @@int64@@ , @@sizet@@ ) ; @ @ VAR_1227 @ @ void ( ) ( void ) @ @ argmatchexitfn ( ) ; return Number ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
_BOOL8 __fastcall basename_is_dot_or_dotdot ( __int64 @@int64@@ ) { _BYTE * @@BYTE@@ ; @@BYTE@@ = ( _BYTE * ) last_component ( @@int64@@ ) ; return dot_or_dotdot ( @@BYTE@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 __fastcall getuser ( __uid_t @@uidt@@ ) { const char * @@constchar@@ ; size_t @@sizet@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; struct passwd * @@structpasswd@@ ; char * @@char@@ ; @@int64@@ = Number L ; for ( @@int64@@ = user_alist ; @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ) { if ( @@uidt@@ == * ( _DWORD * ) @@int64@@ ) { @@int64@@ = @@int64@@ ; break ; } } if ( ! @@int64@@ ) { @@structpasswd@@ = getpwuid ( @@uidt@@ ) ; if ( @@structpasswd@@ ) @@constchar@@ = @@structpasswd@@ -> pw_name ; else @@constchar@@ = ( const char * ) & unk_19CC0 ; @@char@@ = ( char * ) @@constchar@@ ; @@sizet@@ = strlen ( @@constchar@@ ) ; @@int64@@ = xmalloc ( @@sizet@@ + Number ) ; * ( _DWORD * ) @@int64@@ = @@uidt@@ ; strcpy ( ( char * ) ( @@int64@@ + Number ) , @@char@@ ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = user_alist ; user_alist = @@int64@@ ; } if ( * ( _BYTE * ) ( @@int64@@ + Number ) ) @@int64@@ = @@int64@@ + Number ; else @@int64@@ = Number L ; return @@int64@@ ; }
__int64 __fastcall ftypelet ( __int16 @@int16@@ ) { switch ( @@int16@@ & Number ) { case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; } return Number L ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
__int64 __fastcall cmp_ctime ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ , __int64 ( __fastcall * @ @ VAR_490 @ @ int64 ( fastcall ) ( QWORD , QWORD ) @ @ int ( ) ( constchar , constchar ) ) ( _QWORD , _QWORD ) ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = get_stat_ctime ( ( __int64 ) ( @@QWORD@@ + Number ) ) ; @@int64@@ = @@int64@@ ; @@int64@@ = get_stat_ctime ( ( __int64 ) ( @@QWORD@@ + Number ) ) ; @@unsignedint@@ = timespec_cmp ( @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( @@unsignedint@@ ) @@int64@@ = @@unsignedint@@ ; else @@int64@@ = @ @ VAR_490 @ @ int64 ( fastcall ) ( QWORD , QWORD ) @ @ int ( ) ( constchar , constchar ) ( * @@QWORD@@ , * @@QWORD@@ ) ; return @@int64@@ ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
__int64 __fastcall file_name_concat ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = mfile_name_concat ( @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( ! @@int64@@ ) xalloc_die ( ) ; return @@int64@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall cmp_name ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ , __int64 ( __fastcall * @ @ VAR_515 @ @ int64 ( fastcall ) ( QWORD , QWORD ) @ @ int ( ) ( constchar , constchar ) ) ( _QWORD , _QWORD ) ) { return @ @ VAR_515 @ @ int64 ( fastcall ) ( QWORD , QWORD ) @ @ int ( ) ( constchar , constchar ) ( * @@QWORD@@ , * @@QWORD@@ ) ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
__int64 __fastcall imaxtostr ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ + Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = Number ; if ( @@int64@@ >= Number ) { do { * ( _BYTE * ) -- @@int64@@ = ( char ) @@int64@@ % Number + Number ; @@int64@@ /= Number L ; } while ( @@int64@@ ) ; } else { do { * ( _BYTE * ) -- @@int64@@ = Number - ( char ) @@int64@@ % Number ; @@int64@@ /= Number L ; } while ( @@int64@@ ) ; * ( _BYTE * ) -- @@int64@@ = Number ; } return @@int64@@ ; }
__int64 __fastcall hash_get_n_buckets ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall hash_get_n_buckets_used ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 __fastcall align_nstrftime ( __int64 @@int64@@ , __int64 @@int64@@ , const char * @@constchar@@ , __int64 @@int64@@ , unsigned int @@unsignedint@@ , unsigned int @@unsignedint@@ ) { char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@char@@ = ( char * ) @@constchar@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@char@@ = ( char * ) @@constchar@@ ; if ( required_mon_width ) { @@char@@ = strstr ( @@constchar@@ , needle ) ; if ( @@char@@ ) { if ( strlen ( @@char@@ ) <= Number ) { @@char@@ = @@char@@ ; @@char@@ = ( char * ) mempcpy ( @@char@@ , @@char@@ , @@char@@ - @@char@@ ) ; @@char@@ = stpcpy ( @@char@@ , & abmon [ Number * * ( int * ) ( @@int64@@ + Number ) ] ) ; strcpy ( @@char@@ , @@char@@ + Number ) ; } } } return nstrftime ( @@int64@@ , @@int64@@ , @@char@@ , @@int64@@ , @@unsignedint@@ , @@unsignedint@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall hash_get_n_entries ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 __fastcall format_user ( unsigned int @@unsignedint@@ , int @@int@@ , char @@char@@ ) { const char * @@constchar@@ ; if ( @@char@@ != Number ) { @@constchar@@ = String ; } else if ( numeric_ids ) { @@constchar@@ = Number L ; } else { @@constchar@@ = ( const char * ) getuser ( @@unsignedint@@ ) ; } return format_user_or_group ( @@constchar@@ , @@unsignedint@@ , @@int@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
size_t __fastcall format_user_or_group_width ( __int64 @@int64@@ , __int64 @@int64@@ ) { size_t @@sizet@@ ; int @@int@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( @@int64@@ ) { @@int@@ = gnu_mbswidth ( @@int64@@ , Number L ) ; @@sizet@@ = Number L ; if ( @@int@@ >= Number ) @@sizet@@ = ( unsigned int ) @@int@@ ; } else { sprintf ( @@char@@ , String , @@int64@@ ) ; @@sizet@@ = strlen ( @@char@@ ) ; } return @@sizet@@ ; }
unsigned __int64 __fastcall hash_get_max_bucket_length ( __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = Number L ; for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { @@QWORD@@ = @@QWORD@@ ; for ( @@unsignedint64@@ = Number L ; ; ++ @@unsignedint64@@ ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; if ( ! @@QWORD@@ ) break ; } if ( @@unsignedint64@@ > @@unsignedint64@@ ) @@unsignedint64@@ = @@unsignedint64@@ ; } } return @@unsignedint64@@ ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
int __cdecl __noreturn main ( int @@int@@ , const char * * @@constchar@@ , const char * * @@constchar@@ ) { const char * @@constchar@@ ; __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; int @@int@@ ; unsigned __int8 @@unsignedint8@@ ; int @@int@@ ; char * @@char@@ ; @@int@@ = @@int@@ ; @@char@@ = String ; set_program_name ( * @@constchar@@ , @@constchar@@ , @@constchar@@ ) ; setlocale ( Number , & locale ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; have_read_stdin = Number ; serial_merge = Number ; while ( Number ) { @@int@@ = getopt_long ( @@int@@ , ( char * const * ) @@constchar@@ , String , & longopts , Number L ) ; if ( @@int@@ == Number ) { if ( @@int@@ == optind ) { @@int@@ = @@int@@ + Number ; @@constchar@@ [ @@int@@ ] = ( const char * ) bad_cast ( ( __int64 ) String ) ; } if ( ( unsigned int ) collapse_escapes ( @@char@@ ) ) { set_quoting_style ( Number L , Number L ) ; @@int64@@ = quotearg_colon ( @@char@@ ) ; @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ , @@int64@@ ) ; } if ( serial_merge != Number ) @@unsignedint8@@ = paste_parallel ( @@int@@ - optind , ( __int64 ) & @@constchar@@ [ optind ] ) ; else @@unsignedint8@@ = paste_serial ( @@int@@ - optind , & @@constchar@@ [ optind ] ) ; free ( delims ) ; if ( have_read_stdin ) { if ( fclose ( stdin ) == Number ) { @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , String ) ; } } exit ( @@unsignedint8@@ ^ Number ) ; } if ( @@int@@ == Number ) usage ( Number ) ; if ( @@int@@ <= Number ) break ; if ( @@int@@ == Number ) { if ( * ( _BYTE * ) optarg ) @@constchar@@ = ( const char * ) optarg ; else @@constchar@@ = String ; @@char@@ = ( char * ) @@constchar@@ ; } else { if ( @@int@@ != Number ) goto LABEL_16 ; serial_merge = Number ; } } if ( @@int@@ == Number ) { version_etc ( ( _DWORD ) stdout , ( unsigned int ) String , ( unsigned int ) String , ( _DWORD ) Version , ( unsigned int ) String , ( unsigned int ) String , Number ) ; exit ( Number ) ; } LABEL_16 : usage ( Number ) ; }
const char * __fastcall format_inode ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ ) { const char * @@constchar@@ ; if ( @@unsignedint64@@ <= Number ) __assert_fail ( String , String , Number , String ) ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) && * ( _QWORD * ) ( @@int64@@ + Number ) ) @@constchar@@ = ( const char * ) umaxtostr ( * ( _QWORD * ) ( @@int64@@ + Number ) , @@int64@@ ) ; else @@constchar@@ = String ; return @@constchar@@ ; }
__int64 __fastcall base_name ( __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; _BYTE * @@BYTE@@ ; @@BYTE@@ = ( _BYTE * ) last_component ( @@int64@@ ) ; if ( * @@BYTE@@ ) { @@int64@@ = base_len ( @@BYTE@@ ) ; if ( @@BYTE@@ [ @@int64@@ ] == Number ) ++ @@int64@@ ; @@int64@@ = xstrndup ( @@BYTE@@ , @@int64@@ ) ; } else { @@int64@@ = base_len ( @@int64@@ ) ; @@int64@@ = xstrndup ( @@int64@@ , @@int64@@ ) ; } return @@int64@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
__int64 __fastcall hash_lookup ( __int64 * @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; @@int64@@ = * @@int64@@ ; @@QWORD@@ = ( _QWORD * ) ( @@int64@@ + Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@int64@@ [ Number ] ) ( @@int64@@ , @@int64@@ [ Number ] ) ) ; if ( ( unsigned __int64 ) @@QWORD@@ >= @@int64@@ [ Number ] ) abort ( ) ; if ( ! * @@QWORD@@ ) return Number L ; for ( @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { if ( @@int64@@ == * @@QWORD@@ || ( ( unsigned __int8 ( __fastcall * ) ( __int64 , _QWORD ) ) @@int64@@ [ Number ] ) ( @@int64@@ , * @@QWORD@@ ) ) { return * @@QWORD@@ ; } } return Number L ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
unsigned __int64 __fastcall hash_string ( _BYTE * @@BYTE@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = Number L ; while ( * @@BYTE@@ ) @@unsignedint64@@ = ( Number * @@unsignedint64@@ + ( unsigned __int8 ) * @@BYTE@@ ++ ) % @@unsignedint64@@ ; return @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_2070C8 ; @@int648@@ [ Number ] = qword_2070D0 ; @@int648@@ [ Number ] = qword_2070D8 ; @@int648@@ [ Number ] = qword_2070E0 ; @@int648@@ [ Number ] = qword_2070E8 ; @@int648@@ [ Number ] = qword_2070F0 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
unsigned __int64 print_many_per_line ( ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; @@unsignedint64@@ = calculate_columns ( Number L ) ; @@int64@@ = column_info + Number * @@unsignedint64@@ - Number ; @@unsignedint64@@ = cwd_n_used / @@unsignedint64@@ + ( cwd_n_used % @@unsignedint64@@ != Number ) ; for ( @@unsignedint64@@ = Number L ; ; ++ @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ ; if ( @@unsignedint64@@ >= @@unsignedint64@@ ) break ; @@int64@@ = Number L ; @@unsignedint64@@ = @@unsignedint64@@ ; for ( @@unsignedint64@@ = Number L ; ; @@unsignedint64@@ += @@int64@@ ) { @@int64@@ = * ( ( _QWORD * ) sorted_file + @@unsignedint64@@ ) ; @@int64@@ = length_of_file_name_and_frills ( @@int64@@ ) ; @@int64@@ = @@int64@@ ++ ; @@int64@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ ) ; print_file_name_and_frills ( @@int64@@ , @@unsignedint64@@ ) ; @@unsignedint64@@ += @@unsignedint64@@ ; if ( @@unsignedint64@@ >= cwd_n_used ) break ; indent ( @@unsignedint64@@ + @@int64@@ , @@int64@@ + @@unsignedint64@@ ) ; } putchar_unlocked ( Number ) ; } return @@unsignedint64@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
unsigned __int64 __fastcall raw_hasher ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { return rotr_sz ( @@int64@@ , Number ) % @@unsignedint64@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
void __fastcall freebuffer ( __int64 @@int64@@ ) { free ( * ( void * * ) ( @@int64@@ + Number ) ) ; }
char * __fastcall areadlink_with_size ( const char * @@constchar@@ , unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; char * @@char@@ ; int @@int@@ ; size_t @@sizet@@ ; char * @@char@@ ; ssize_t @@ssizet@@ ; if ( @@unsignedint64@@ >= Number ) @@int64@@ = Number L ; else @@int64@@ = @@unsignedint64@@ + Number ; @@sizet@@ = @@int64@@ ; LABEL_5 : for ( @@char@@ = ( char * ) malloc ( @@sizet@@ ) ; ; @@char@@ = ( char * ) malloc ( Number ) ) { @@char@@ = @@char@@ ; if ( ! @@char@@ ) return Number L ; @@ssizet@@ = readlink ( @@constchar@@ , @@char@@ , @@sizet@@ ) ; if ( @@ssizet@@ < Number && * __errno_location ( ) != Number ) { @@int@@ = * __errno_location ( ) ; free ( @@char@@ ) ; * __errno_location ( ) = @@int@@ ; return Number L ; } if ( @@ssizet@@ < @@sizet@@ ) { @@char@@ [ @@ssizet@@ ] = Number ; return @@char@@ ; } free ( @@char@@ ) ; if ( @@sizet@@ <= Number ) { @@sizet@@ *= Number L ; goto LABEL_5 ; } if ( @@sizet@@ > Number ) break ; @@sizet@@ = Number ; } * __errno_location ( ) = Number ; return Number L ; }
__int64 __fastcall memcpy_lowcase ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { while ( @@int64@@ -- ) * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) = tolower ( * ( unsigned __int8 * ) ( @@int64@@ + @@int64@@ ) ) ; return @@int64@@ ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall wc_ensure_printable ( wint_t * @@wintt@@ ) { unsigned __int8 @@unsignedint8@@ ; @@unsignedint8@@ = Number ; while ( * @@wintt@@ ) { if ( ! iswprint ( * @@wintt@@ ) ) { * @@wintt@@ = Number ; @@unsignedint8@@ = Number ; } ++ @@wintt@@ ; } return @@unsignedint8@@ ; }
unsigned __int64 __fastcall compute_bucket_size ( __int64 @@int64@@ , __int64 @@int64@@ ) { float @@float@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; float @@float@@ ; @@unsignedint64@@ = @@int64@@ ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) != Number ) { if ( @@int64@@ < Number ) @@float@@ = ( float ) ( @@int64@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@int64@@ >> Number ) ) + ( float ) ( @@int64@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@int64@@ >> Number ) ) ; else @@float@@ = ( float ) ( int ) @@int64@@ ; @@float@@ = @@float@@ / * ( float * ) ( @@int64@@ + Number ) ; if ( @@float@@ >= Number ) return Number L ; if ( @@float@@ >= Number ) @@unsignedint64@@ = ( unsigned int ) ( int ) ( float ) ( @@float@@ - Number ) ^ Number ; else @@unsignedint64@@ = ( unsigned int ) ( int ) @@float@@ ; } @@unsignedint64@@ = next_prime ( @@unsignedint64@@ ) ; if ( @@unsignedint64@@ <= Number ) @@unsignedint64@@ = @@unsignedint64@@ ; else @@unsignedint64@@ = Number L ; return @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_206028 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall nstrftime ( char * @@char@@ , __int64 @@int64@@ , char * @@char@@ , __int64 @@int64@@ , int @@int@@ , int @@int@@ ) { return strftime_case_ ( Number , @@char@@ , @@int64@@ , @@char@@ , @@int64@@ , @@int@@ , @@int@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall wc_truncate ( wchar_t * @@wchart@@ , unsigned __int64 @@unsignedint64@@ ) { int @@int@@ ; __int64 @@int64@@ ; @@int64@@ = Number L ; while ( * @@wchart@@ ) { @@int@@ = wcwidth ( * @@wchart@@ ) ; if ( @@int@@ == Number ) { * @@wchart@@ = Number ; @@int@@ = Number ; } if ( @@unsignedint64@@ < @@int@@ + @@int64@@ ) break ; @@int64@@ += @@int@@ ; ++ @@wchart@@ ; } * @@wchart@@ = Number ; return @@int64@@ ; }
__int64 __fastcall transfer_entries ( __int64 @@int64@@ , __int64 @@int64@@ , char @@char@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 * @@int64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; for ( @@int64@@ = * ( __int64 * * ) @@int64@@ ; ( unsigned __int64 ) @@int64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ += Number ) { if ( * @@int64@@ ) { for ( @@QWORD@@ = ( _QWORD * ) @@int64@@ [ Number ] ; @@QWORD@@ ; @@QWORD@@ = @@QWORD@@ ) { @@int64@@ = * @@QWORD@@ ; @@int64@@ = * ( _QWORD * ) @@int64@@ ; @@QWORD@@ = ( _QWORD * ) ( @@int64@@ + Number * ( * ( __int64 ( __fastcall * * ) ( _QWORD , _QWORD ) ) ( @@int64@@ + Number ) ) ( * @@QWORD@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@QWORD@@ >= * ( _QWORD * ) ( @@int64@@ + Number ) ) abort ( ) ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; if ( * @@QWORD@@ ) { @@QWORD@@ [ Number ] = @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = @@QWORD@@ ; } else { * @@QWORD@@ = @@int64@@ ; ++ * ( _QWORD * ) ( @@int64@@ + Number ) ; free_entry ( @@int64@@ , @@QWORD@@ ) ; } } @@int64@@ = * @@int64@@ ; @@int64@@ [ Number ] = Number L ; if ( ! @@char@@ ) { @@int64@@ = * ( _QWORD * ) @@int64@@ ; @@QWORD@@ = ( _QWORD * ) ( @@int64@@ + Number * ( * ( __int64 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@int64@@ + Number ) ) ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@QWORD@@ >= * ( _QWORD * ) ( @@int64@@ + Number ) ) abort ( ) ; if ( * @@QWORD@@ ) { @@QWORD@@ = allocate_entry ( @@int64@@ ) ; if ( ! @@QWORD@@ ) return Number L ; * @@QWORD@@ = @@int64@@ ; @@QWORD@@ [ Number ] = @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = @@QWORD@@ ; } else { * @@QWORD@@ = @@int64@@ ; ++ * ( _QWORD * ) ( @@int64@@ + Number ) ; } * @@int64@@ = Number L ; -- * ( _QWORD * ) ( @@int64@@ + Number ) ; } } } return Number L ; }
__int64 __fastcall gnu_mbswidth ( const char * @@constchar@@ , unsigned int @@unsignedint@@ ) { size_t @@sizet@@ ; @@sizet@@ = strlen ( @@constchar@@ ) ; return mbsnwidth ( @@constchar@@ , @@sizet@@ , @@unsignedint@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 __fastcall x2nrealloc ( __int64 @@int64@@ , unsigned __int64 * @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = * @@unsignedint64@@ ; if ( @@int64@@ ) { if ( @@unsignedint64@@ >= Number / @@unsignedint64@@ ) xalloc_die ( ) ; @@unsignedint64@@ += ( @@unsignedint64@@ + Number ) >> Number ; } else if ( ! @@unsignedint64@@ ) { @@unsignedint64@@ = ( Number / @@unsignedint64@@ == Number ) + Number / @@unsignedint64@@ ; } * @@unsignedint64@@ = @@unsignedint64@@ ; return xrealloc ( @@int64@@ , @@unsignedint64@@ * @@unsignedint64@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) { ; } return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall bkm_scale_by_power_0 ( unsigned __int64 * @@unsignedint64@@ , int @@int@@ , int @@int@@ ) { unsigned int @@unsignedint@@ ; for ( @@unsignedint@@ = Number ; @@int@@ -- ; @@unsignedint@@ |= bkm_scale_0 ( @@unsignedint64@@ , @@int@@ ) ) { ; } return @@unsignedint@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
void * __fastcall mpsort_into_tmp ( __int64 * @@int64@@ , unsigned __int64 @@unsignedint64@@ , _QWORD * @@QWORD@@ , __int64 ( __fastcall * @ @ VAR_1602 @ @ int64 ( fastcall ) ( int64 , int64 ) @ @ int64 ( fastcall ) ( int64 , int64 ) ) ( __int64 , __int64 ) ) { int @@int@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; @@QWORD@@ = @@QWORD@@ ; @@unsignedint64@@ = Number L ; @@unsignedint64@@ = @@unsignedint64@@ >> Number ; @@unsignedint64@@ = @@unsignedint64@@ >> Number ; mpsort_with_tmp ( & @@int64@@ [ @@unsignedint64@@ >> Number ] , @@unsignedint64@@ - ( @@unsignedint64@@ >> Number ) , @@QWORD@@ , @ @ VAR_1602 @ @ int64 ( fastcall ) ( int64 , int64 ) @ @ int64 ( fastcall ) ( int64 , int64 ) ) ; mpsort_with_tmp ( @@int64@@ , @@unsignedint64@@ >> Number , @@QWORD@@ , @ @ VAR_1602 @ @ int64 ( fastcall ) ( int64 , int64 ) @ @ int64 ( fastcall ) ( int64 , int64 ) ) ; @@int64@@ = * @@int64@@ ; @@int64@@ = @@int64@@ [ @@unsignedint64@@ >> Number ] ; for ( @@int@@ = @ @ VAR_1602 @ @ int64 ( fastcall ) ( int64 , int64 ) @ @ int64 ( fastcall ) ( int64 , int64 ) ( * @@int64@@ , @@int64@@ ) ; ; @@int@@ = @ @ VAR_1602 @ @ int64 ( fastcall ) ( int64 , int64 ) @ @ int64 ( fastcall ) ( int64 , int64 ) ( @@int64@@ , @@int64@@ ) ) { while ( @@int@@ > Number ) { @@QWORD@@ = @@QWORD@@ ++ ; * @@QWORD@@ = @@int64@@ ; if ( ++ @@unsignedint64@@ == @@unsignedint64@@ ) return memcpy ( @@QWORD@@ , & @@int64@@ [ @@unsignedint64@@ ] , Number * ( @@unsignedint64@@ - @@unsignedint64@@ ) ) ; @@int64@@ = @@int64@@ [ @@unsignedint64@@ ] ; @@int@@ = @ @ VAR_1602 @ @ int64 ( fastcall ) ( int64 , int64 ) @ @ int64 ( fastcall ) ( int64 , int64 ) ( @@int64@@ , @@int64@@ ) ; } @@QWORD@@ = @@QWORD@@ ++ ; * @@QWORD@@ = @@int64@@ ; if ( ++ @@unsignedint64@@ == @@unsignedint64@@ ) break ; @@int64@@ = @@int64@@ [ @@unsignedint64@@ ] ; } @@unsignedint64@@ = @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint64@@ ; return memcpy ( @@QWORD@@ , & @@int64@@ [ @@unsignedint64@@ ] , Number * ( @@unsignedint64@@ - @@unsignedint64@@ ) ) ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_221088 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall bad_cast ( __int64 @@int64@@ ) { return @@int64@@ ; }
void __fastcall argmatch_invalid ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { char * @@char@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; char * @@char@@ ; if ( @@int64@@ == Number ) @@char@@ = gettext ( String ) ; else @@char@@ = gettext ( String ) ; @@char@@ = @@char@@ ; @@int64@@ = quote_n ( Number L , @@int64@@ ) ; @@int64@@ = quotearg_n_style ( Number L , Number L , @@int64@@ ) ; error ( Number , Number , @@char@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
int __fastcall argmatch_valid ( __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { char * @@char@@ ; __int64 @@int64@@ ; void * @@void@@ ; @@void@@ = Number L ; @@char@@ = gettext ( String ) ; fprintf ( stderr , @@char@@ ) ; for ( @@int64@@ = Number L ; * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; ++ @@int64@@ ) { if ( @@int64@@ && ! memcmp ( @@void@@ , ( const void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) , @@sizet@@ ) ) { fprintf ( stderr , String , * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) ) ; } else { fprintf ( stderr , String , * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) ) ; @@void@@ = ( void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) ; } } return putc_unlocked ( Number , stderr ) ; }
__int64 __fastcall re_string_allocate ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ , __int64 @@int64@@ ) { unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned int @@unsignedint@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint64@@ ; if ( @@unsignedint64@@ < * ( int * ) ( @@int64@@ + Number ) ) @@unsignedint64@@ = * ( int * ) ( @@int64@@ + Number ) ; @@unsignedint64@@ = @@int64@@ + Number ; if ( @@unsignedint64@@ <= @@int64@@ + Number ) @@unsignedint64@@ = @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint64@@ ; re_string_construct_common ( @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@unsignedint8@@ , @@int64@@ ) ; @@unsignedint@@ = re_string_realloc_buffers ( @@int64@@ , @@unsignedint64@@ ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ + Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = ( * ( _BYTE * ) ( @@int64@@ + Number ) & Number ) != Number ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) ) @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; else @@int64@@ = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) || * ( int * ) ( @@int64@@ + Number ) > Number ) @@int64@@ = Number L ; else @@int64@@ = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; return Number L ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall memcpy_uppcase ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { while ( @@int64@@ -- ) * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) = toupper ( * ( unsigned __int8 * ) ( @@int64@@ + @@int64@@ ) ) ; return @@int64@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
_BYTE * __fastcall filemodestring ( __int64 @@int64@@ , _BYTE * @@BYTE@@ ) { return strmode ( * ( _DWORD * ) ( @@int64@@ + Number ) , @@BYTE@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
__int64 __fastcall umaxtostr ( unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = @@int64@@ + Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = Number ; do { * ( _BYTE * ) -- @@int64@@ = @@unsignedint64@@ % Number + Number ; @@unsignedint64@@ /= Number ; } while ( @@unsignedint64@@ ) ; return @@int64@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
void * __fastcall initbuffer ( void * @@void@@ ) { return memset ( @@void@@ , Number , Number ) ; }
__int64 __fastcall c_tolower ( int @@int@@ ) { __int64 @@int64@@ ; if ( @@int@@ <= Number || @@int@@ > Number ) @@int64@@ = ( unsigned int ) @@int@@ ; else @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; return @@int64@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall bkm_scale_0 ( unsigned __int64 * @@unsignedint64@@ , int @@int@@ ) { __int64 @@int64@@ ; if ( is_mul_ok ( @@int@@ , * @@unsignedint64@@ ) ) { * @@unsignedint64@@ *= @@int@@ ; @@int64@@ = Number L ; } else { * @@unsignedint64@@ = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall readlinebuffer ( __int64 @@int64@@ , __int64 @@int64@@ ) { return readlinebuffer_delim ( @@int64@@ , @@int64@@ , Number L ) ; }
__int64 __fastcall re_string_peek_byte_case ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; if ( ! * ( _BYTE * ) ( @@int64@@ + Number ) ) return * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + * ( _QWORD * ) ( @@int64@@ + Number ) + @@int64@@ ) ; if ( * ( int * ) ( @@int64@@ + Number ) > Number && ( * ( _DWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * ( * ( _QWORD * ) ( @@int64@@ + Number ) + @@int64@@ ) ) == Number || * ( _QWORD * ) ( @@int64@@ + Number ) != * ( _QWORD * ) ( @@int64@@ + Number ) + @@int64@@ + Number && * ( _DWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * ( * ( _QWORD * ) ( @@int64@@ + Number ) + @@int64@@ + Number ) ) == Number ) ) { return * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + * ( _QWORD * ) ( @@int64@@ + Number ) + @@int64@@ ) ; } @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) + @@int64@@ ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) ) @@int64@@ = * ( _QWORD * ) ( Number * @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) && ( * ( _BYTE * ) ( * ( _QWORD * ) @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) + @@int64@@ ) & Number ) != Number ) { @@int64@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + * ( _QWORD * ) ( @@int64@@ + Number ) + @@int64@@ ) ; } else { @@int64@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) + @@int64@@ ) ; } return @@int64@@ ; }
void * __fastcall mfile_name_concat ( _BYTE * @@BYTE@@ , _BYTE * @@BYTE@@ , _QWORD * @@QWORD@@ ) { _BOOL4 @@BOOL4@@ ; const char * @@constchar@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; _BOOL8 @@BOOL8@@ ; char * @@char@@ ; size_t @@sizet@@ ; void * @@void@@ ; _BYTE * @@BYTE@@ ; char * @@char@@ ; @@constchar@@ = last_component ( @@BYTE@@ ) ; @@sizet@@ = base_len ( @@constchar@@ ) ; @@sizet@@ = @@constchar@@ - @@BYTE@@ + @@sizet@@ ; @@BOOL4@@ = @@sizet@@ && @@constchar@@ [ @@sizet@@ - Number ] != Number ; @@BOOL8@@ = @@BOOL4@@ ; @@char@@ = longest_relative_suffix ( @@BYTE@@ ) ; @@sizet@@ = strlen ( @@char@@ ) ; @@void@@ = malloc ( @@BOOL8@@ + @@sizet@@ + @@sizet@@ + Number ) ; if ( ! @@void@@ ) return Number L ; @@BYTE@@ = mempcpy ( @@void@@ , @@BYTE@@ , @@sizet@@ ) ; * @@BYTE@@ = Number ; @@char@@ = & @@BYTE@@ [ @@BOOL8@@ ] ; if ( @@QWORD@@ ) * @@QWORD@@ = & @@char@@ [ - ( * @@BYTE@@ == Number ) ] ; * ( _BYTE * ) mempcpy ( @@char@@ , @@char@@ , @@sizet@@ ) = Number ; return @@void@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return xmalloc ( @@int64@@ , @@int64@@ , @@int64@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
__int64 * __fastcall readlinebuffer_delim ( __int64 * @@int64@@ , FILE * @@FILE@@ , char @@char@@ ) { _BYTE * @@BYTE@@ ; int @@int@@ ; __int64 @@int64@@ ; _BYTE * @@BYTE@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = @@int64@@ [ Number ] ; @@BYTE@@ = ( _BYTE * ) @@int64@@ ; @@int64@@ = * @@int64@@ + @@int64@@ ; if ( feof_unlocked ( @@FILE@@ ) ) return Number L ; while ( Number ) { @@int@@ = getc_unlocked ( @@FILE@@ ) ; if ( @@int@@ == Number ) break ; LABEL_9 : if ( @@BYTE@@ == ( _BYTE * ) @@int64@@ ) { @@int64@@ = * @@int64@@ ; @@int64@@ = x2realloc ( @@int64@@ , @@int64@@ ) ; @@BYTE@@ = ( _BYTE * ) ( @@int64@@ + @@int64@@ ) ; @@int64@@ [ Number ] = @@int64@@ ; @@int64@@ = * @@int64@@ + @@int64@@ ; } @@BYTE@@ = @@BYTE@@ ++ ; * @@BYTE@@ = @@int@@ ; if ( @@int@@ == @@char@@ ) goto LABEL_12 ; } if ( @@BYTE@@ == ( _BYTE * ) @@int64@@ || ferror_unlocked ( @@FILE@@ ) ) return Number L ; if ( @@char@@ != * ( @@BYTE@@ - Number ) ) { @@int@@ = @@char@@ ; goto LABEL_9 ; } LABEL_12 : @@int64@@ [ Number ] = ( __int64 ) & @@BYTE@@ [ - @@int64@@ ] ; return @@int64@@ ; }
__int64 __fastcall re_node_set_init_copy ( void * @@void@@ , __int64 @@int64@@ ) { * ( ( _QWORD * ) @@void@@ + Number ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) { * ( _QWORD * ) @@void@@ = * ( ( _QWORD * ) @@void@@ + Number ) ; * ( ( _QWORD * ) @@void@@ + Number ) = malloc ( Number L * * ( _QWORD * ) @@void@@ ) ; if ( ! * ( ( _QWORD * ) @@void@@ + Number ) ) { * ( ( _QWORD * ) @@void@@ + Number ) = Number L ; * ( _QWORD * ) @@void@@ = * ( ( _QWORD * ) @@void@@ + Number ) ; return Number L ; } memcpy ( * ( ( void * * ) @@void@@ + Number ) , * ( const void * * ) ( @@int64@@ + Number ) , Number L * * ( _QWORD * ) ( @@int64@@ + Number ) ) ; } else { memset ( @@void@@ , Number , Number ) ; } return Number L ; }
unsigned __int64 __fastcall hash_get_entries ( __int64 @@int64@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; @@unsignedint64@@ = Number L ; for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { for ( @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { if ( @@unsignedint64@@ >= @@unsignedint64@@ ) return @@unsignedint64@@ ; @@int64@@ = @@unsignedint64@@ ++ ; * ( _QWORD * ) ( @@int64@@ + Number * @@int64@@ ) = * @@QWORD@@ ; } } } return @@unsignedint64@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
bool __fastcall is_prime ( unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = Number L ; @@unsignedint64@@ = Number L ; while ( @@unsignedint64@@ < @@unsignedint64@@ && @@unsignedint64@@ % @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@unsignedint64@@ += Number * @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint64@@ + Number ; } return @@unsignedint64@@ % @@unsignedint64@@ != Number ; }
unsigned __int64 __fastcall re_node_set_remove_at ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint64@@ ; @@unsignedint64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( @@unsignedint64@@ < @@unsignedint64@@ ) { -- * ( _QWORD * ) ( @@int64@@ + Number ) ; while ( Number ) { @@unsignedint64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( @@unsignedint64@@ >= @@unsignedint64@@ ) break ; * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@unsignedint64@@ ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * ( @@unsignedint64@@ + Number ) ) ; ++ @@unsignedint64@@ ; } } return @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
size_t * __fastcall hash_initialize ( __int64 @@int64@@ , void * @@void@@ , unsigned __int64 ( __fastcall * @ @ VAR_1363 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ) ( __int64 a1 , unsigned __int64 a2 ) , bool ( __fastcall * @ @ VAR_1365 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ) ( __int64 a1 , __int64 a2 ) , size_t @@sizet@@ ) { size_t * @@sizet@@ ; bool ( __fastcall * @ @ VAR_1364 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ) ( __int64 , __int64 ) ; unsigned __int64 ( __fastcall * @ @ VAR_1362 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ) ( __int64 , unsigned __int64 ) ; void * @@void@@ ; size_t * @@sizet@@ ; @@void@@ = @@void@@ ; @ @ VAR_1362 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher = @ @ VAR_1363 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ; @ @ VAR_1364 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator = @ @ VAR_1365 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ; if ( ! @ @ VAR_1363 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ) @ @ VAR_1362 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher = raw_hasher ; if ( ! @ @ VAR_1365 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ) @ @ VAR_1364 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator = raw_comparator ; @@sizet@@ = ( size_t * ) malloc ( Number ) ; if ( ! @@sizet@@ ) return Number L ; if ( ! @@void@@ ) @@void@@ = & default_tuning ; @@sizet@@ [ Number ] = ( size_t ) @@void@@ ; if ( ( unsigned __int8 ) check_tuning ( ( __int64 ) @@sizet@@ ) == Number && ( @@sizet@@ [ Number ] = compute_bucket_size ( @@int64@@ , ( __int64 ) @@void@@ ) ) != Number && ( * @@sizet@@ = ( size_t ) calloc ( @@sizet@@ [ Number ] , Number ) ) != Number ) { @@sizet@@ [ Number ] = Number * @@sizet@@ [ Number ] + * @@sizet@@ ; @@sizet@@ [ Number ] = Number L ; @@sizet@@ [ Number ] = Number L ; @@sizet@@ [ Number ] = ( size_t ) @ @ VAR_1362 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ; @@sizet@@ [ Number ] = ( size_t ) @ @ VAR_1364 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ; @@sizet@@ [ Number ] = @@sizet@@ ; @@sizet@@ [ Number ] = Number L ; @@sizet@@ = @@sizet@@ ; } else { free ( @@sizet@@ ) ; @@sizet@@ = Number L ; } return @@sizet@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_2060C8 ; @@int648@@ [ Number ] = qword_2060D0 ; @@int648@@ [ Number ] = qword_2060D8 ; @@int648@@ [ Number ] = qword_2060E0 ; @@int648@@ [ Number ] = qword_2060E8 ; @@int648@@ [ Number ] = qword_2060F0 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
__int64 __fastcall register_state ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; void * @@void@@ ; __int64 @@int64@@ ; * @@QWORD@@ = @@int64@@ ; if ( ( unsigned int ) re_node_set_alloc ( @@QWORD@@ + Number , @@QWORD@@ [ Number ] ) ) return Number L ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@QWORD@@ [ Number ] ; ++ @@unsignedint64@@ ) { @@int64@@ = * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@QWORD@@ [ Number ] ) ; if ( ( * ( _BYTE * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) & Number ) == Number && ( unsigned __int8 ) re_node_set_insert_last ( ( __int64 ) ( @@QWORD@@ + Number ) , @@int64@@ ) != Number ) { return Number L ; } } @@int64@@ = @@QWORD@@ [ Number ] + Number * ( @@int64@@ & @@QWORD@@ [ Number ] ) ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) <= * ( _QWORD * ) @@int64@@ ) { @@int64@@ = * ( _QWORD * ) @@int64@@ + Number L ; @@int64@@ = Number * @@int64@@ ; @@void@@ = realloc ( * ( void * * ) ( @@int64@@ + Number ) , Number * @@int64@@ ) ; if ( ! @@void@@ ) return Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@void@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; } @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = ( * ( _QWORD * ) @@int64@@ ) ++ ; * ( _QWORD * ) ( @@int64@@ + Number * @@int64@@ ) = @@QWORD@@ ; return Number L ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
char * __fastcall group_number ( char * @@char@@ , size_t @@sizet@@ , unsigned __int8 * @@unsignedint8@@ , const char * @@constchar@@ ) { char * @@char@@ ; size_t @@sizet@@ ; char * @@char@@ ; unsigned __int8 @@unsignedint8@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@sizet@@ = Number ; @@sizet@@ = strlen ( @@constchar@@ ) ; @@sizet@@ = @@sizet@@ ; memcpy ( @@char@@ , @@char@@ , @@sizet@@ ) ; for ( @@char@@ = & @@char@@ [ @@sizet@@ ] ; ; memcpy ( @@char@@ , @@constchar@@ , @@sizet@@ ) ) { @@unsignedint8@@ = * @@unsignedint8@@ ; if ( * @@unsignedint8@@ ) { if ( @@unsignedint8@@ > Number ) @@sizet@@ = @@sizet@@ ; else @@sizet@@ = @@unsignedint8@@ ; @@sizet@@ = @@sizet@@ ; ++ @@unsignedint8@@ ; } if ( @@sizet@@ < @@sizet@@ ) @@sizet@@ = @@sizet@@ ; @@char@@ = & @@char@@ [ - @@sizet@@ ] ; @@sizet@@ -= @@sizet@@ ; memcpy ( @@char@@ , & @@char@@ [ @@sizet@@ ] , @@sizet@@ ) ; if ( ! @@sizet@@ ) break ; @@char@@ = & @@char@@ [ - @@sizet@@ ] ; } return @@char@@ ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall human_options ( char * @@char@@ , int * @@int@@ , _QWORD * @@QWORD@@ ) { unsigned int @@unsignedint@@ ; @@unsignedint@@ = humblock ( @@char@@ , @@QWORD@@ , @@int@@ ) ; if ( ! * @@QWORD@@ ) { * @@QWORD@@ = default_block_size ( ) ; @@unsignedint@@ = Number ; } return @@unsignedint@@ ; }
__int64 __fastcall init_dfa ( void * * @@void@@ , unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; wint_t @@wintt@@ ; size_t @@sizet@@ ; const char * @@constchar@@ ; memset ( @@void@@ , Number , Number ) ; * ( ( _DWORD * ) @@void@@ + Number ) = Number ; if ( @@unsignedint64@@ >= Number ) return Number L ; @@void@@ [ Number ] = ( void * ) ( @@unsignedint64@@ + Number ) ; * @@void@@ = malloc ( Number L * ( _QWORD ) @@void@@ [ Number ] ) ; for ( @@sizet@@ = Number L ; @@sizet@@ <= @@unsignedint64@@ ; @@sizet@@ *= Number L ) { ; } @@void@@ [ Number ] = calloc ( Number , @@sizet@@ ) ; @@void@@ [ Number ] = ( void * ) ( @@sizet@@ - Number ) ; * ( ( _DWORD * ) @@void@@ + Number ) = __ctype_get_mb_cur_max ( ) ; @@constchar@@ = nl_langinfo ( Number ) ; if ( ! strcasecmp ( @@constchar@@ , String ) || ! strcasecmp ( @@constchar@@ , String ) ) * ( ( _BYTE * ) @@void@@ + Number ) |= Number ; * ( ( _BYTE * ) @@void@@ + Number ) &= Number ; if ( * ( ( int * ) @@void@@ + Number ) > Number ) { if ( ( ( _BYTE ) @@void@@ [ Number ] & Number ) != Number ) { @@void@@ [ Number ] = & utf8_sb_map ; } else { @@void@@ [ Number ] = calloc ( Number , Number ) ; if ( ! @@void@@ [ Number ] ) return Number L ; @@int@@ = Number ; @@int@@ = Number ; while ( @@int@@ <= Number ) { for ( @@int@@ = Number ; @@int@@ <= Number ; ++ @@int@@ ) { @@wintt@@ = btowc ( @@int@@ ) ; if ( @@wintt@@ != Number ) * ( ( _QWORD * ) @@void@@ [ Number ] + @@int@@ ) |= Number L << @@int@@ ; if ( ( @@int@@ & Number ) == Number && @@wintt@@ != @@int@@ ) * ( ( _BYTE * ) @@void@@ + Number ) |= Number ; ++ @@int@@ ; } ++ @@int@@ ; } } } if ( * @@void@@ && @@void@@ [ Number ] ) @@int64@@ = Number L ; else @@int64@@ = Number L ; return @@int64@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return xmalloc ( @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall getuidbyname ( const char * @@constchar@@ ) { __int64 @@int64@@ ; size_t @@sizet@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; struct passwd * @@structpasswd@@ ; for ( @@int64@@ = user_alist ; @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ) { if ( * ( _BYTE * ) ( @@int64@@ + Number ) == * @@constchar@@ && ! strcmp ( ( const char * ) ( @@int64@@ + Number ) , @@constchar@@ ) ) { return @@int64@@ ; } } for ( @@int64@@ = nouser_alist ; @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ) { if ( * ( _BYTE * ) ( @@int64@@ + Number ) == * @@constchar@@ && ! strcmp ( ( const char * ) ( @@int64@@ + Number ) , @@constchar@@ ) ) { return Number L ; } } @@structpasswd@@ = getpwnam ( @@constchar@@ ) ; @@sizet@@ = strlen ( @@constchar@@ ) ; @@int64@@ = xmalloc ( @@sizet@@ + Number ) ; strcpy ( ( char * ) ( @@int64@@ + Number ) , @@constchar@@ ) ; if ( @@structpasswd@@ ) { * ( _DWORD * ) @@int64@@ = @@structpasswd@@ -> pw_uid ; * ( _QWORD * ) ( @@int64@@ + Number ) = user_alist ; user_alist = @@int64@@ ; @@int64@@ = @@int64@@ ; } else { * ( _QWORD * ) ( @@int64@@ + Number ) = nouser_alist ; nouser_alist = @@int64@@ ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
void __fastcall mpsort ( __int64 * @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 ( __fastcall * @ @ VAR_1625 @ @ int64 ( fastcall ) ( int64 , int64 ) @ @ comparisonfunction ) ( __int64 , __int64 ) ) { mpsort_with_tmp ( @@int64@@ , @@unsignedint64@@ , & @@int64@@ [ @@unsignedint64@@ ] , @ @ VAR_1625 @ @ int64 ( fastcall ) ( int64 , int64 ) @ @ comparisonfunction ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
__int64 __fastcall duplicate_node ( _QWORD * @@QWORD@@ , __int64 @@int64@@ , __int16 @@int16@@ ) { __int64 @@int64@@ ; @@int64@@ = re_dfa_add_node ( ( __int64 ) @@QWORD@@ , * ( _QWORD * ) ( Number * @@int64@@ + * @@QWORD@@ ) , * ( _QWORD * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) ) ; if ( @@int64@@ != Number ) { * ( _DWORD * ) ( * @@QWORD@@ + Number * @@int64@@ + Number ) = ( ( @@int16@@ & Number ) << Number ) | * ( _DWORD * ) ( * @@QWORD@@ + Number * @@int64@@ + Number ) & Number ; * ( _DWORD * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) = ( ( ( ( * ( _DWORD * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) >> Number ) & Number | ( * ( _DWORD * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) >> Number ) & Number ) & Number ) << Number ) | * ( _DWORD * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) & Number ; * ( _BYTE * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) |= Number ; * ( _QWORD * ) ( @@QWORD@@ [ Number ] + Number * @@int64@@ ) = @@int64@@ ; } return @@int64@@ ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
__int64 __fastcall collapse_escapes ( char * @@char@@ ) { char * @@char@@ ; char * @@char@@ ; int @@int@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; unsigned __int8 @@unsignedint8@@ ; char * @@char@@ ; @@char@@ = @@char@@ ; @@char@@ = ( char * ) xstrdup ( @@char@@ ) ; @@unsignedint8@@ = Number ; delims = @@char@@ ; while ( * @@char@@ ) { if ( * @@char@@ == Number ) { @@char@@ = @@char@@ + Number ; @@int@@ = * @@char@@ ; if ( @@int@@ == Number ) { @@char@@ = @@char@@ ++ ; * @@char@@ = Number ; goto LABEL_30 ; } if ( @@int@@ > Number ) { if ( @@int@@ == Number ) { @@char@@ = @@char@@ ++ ; * @@char@@ = Number ; goto LABEL_30 ; } if ( @@int@@ > Number ) { if ( @@int@@ == Number ) { @@char@@ = @@char@@ ++ ; * @@char@@ = Number ; goto LABEL_30 ; } if ( @@int@@ == Number ) { @@char@@ = @@char@@ ++ ; * @@char@@ = Number ; goto LABEL_30 ; } } else if ( @@int@@ == Number ) { @@char@@ = @@char@@ ++ ; * @@char@@ = Number ; goto LABEL_30 ; } } else { if ( @@int@@ == Number ) { @@char@@ = @@char@@ ++ ; * @@char@@ = Number ; goto LABEL_30 ; } if ( @@int@@ > Number ) { if ( @@int@@ == Number ) { @@char@@ = @@char@@ ++ ; * @@char@@ = Number ; goto LABEL_30 ; } if ( @@int@@ == Number ) { @@char@@ = @@char@@ ++ ; * @@char@@ = Number ; goto LABEL_30 ; } } else if ( ! * @@char@@ ) { @@unsignedint8@@ = Number ; break ; } } @@char@@ = @@char@@ ++ ; * @@char@@ = * @@char@@ ; LABEL_30 : @@char@@ = @@char@@ + Number ; } else { @@char@@ = @@char@@ ++ ; @@char@@ = @@char@@ ++ ; * @@char@@ = * @@char@@ ; } } delim_end = ( __int64 ) @@char@@ ; return @@unsignedint8@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_2060C8 ; @@int648@@ [ Number ] = qword_2060D0 ; @@int648@@ [ Number ] = qword_2060D8 ; @@int648@@ [ Number ] = qword_2060E0 ; @@int648@@ [ Number ] = qword_2060E8 ; @@int648@@ [ Number ] = qword_2060F0 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
__int64 __fastcall parse_branch ( __int64 @@int64@@ , __int64 * @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , _DWORD * @@DWORD@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = * @@int64@@ ; @@int64@@ = parse_expression ( @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@DWORD@@ ) ; if ( * @@DWORD@@ && ! @@int64@@ ) return Number L ; while ( * ( _BYTE * ) ( @@int64@@ + Number ) != Number && * ( _BYTE * ) ( @@int64@@ + Number ) != Number && ( ! @@int64@@ || * ( _BYTE * ) ( @@int64@@ + Number ) != Number ) ) { @@int64@@ = parse_expression ( @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@DWORD@@ ) ; if ( * @@DWORD@@ && ! @@int64@@ ) return Number L ; if ( @@int64@@ && @@int64@@ ) { @@int64@@ = create_tree ( @@int64@@ , @@int64@@ , @@int64@@ , Number L ) ; if ( ! @@int64@@ ) { * @@DWORD@@ = Number ; return Number L ; } } else if ( ! @@int64@@ ) { @@int64@@ = @@int64@@ ; } } return @@int64@@ ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
__int64 __fastcall bad_cast ( __int64 @@int64@@ ) { return @@int64@@ ; }
_QWORD * __fastcall bitset_set ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { _QWORD * @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) ( Number * ( @@unsignedint64@@ >> Number ) + @@int64@@ ) ; * @@QWORD@@ |= Number L << ( @@unsignedint64@@ & Number ) ; return @@QWORD@@ ; }
__int64 __fastcall build_equiv_class ( __int64 @@int64@@ , __int64 a2 , __int64 a3 , const char * @@constchar@@ ) { if ( strlen ( @@constchar@@ ) != Number ) return Number L ; bitset_set ( @@int64@@ , * ( unsigned __int8 * ) @@constchar@@ ) ; return Number L ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
void * __fastcall bitset_empty ( void * @@void@@ ) { return memset ( @@void@@ , Number , Number ) ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
__int64 __fastcall re_string_char_size_at ( __int64 @@int64@@ , __int64 @@int64@@ ) { int @@int@@ ; if ( * ( _DWORD * ) ( @@int64@@ + Number ) == Number ) return Number L ; for ( @@int@@ = Number ; ( unsigned __int64 ) ( @@int64@@ + @@int@@ ) < * ( _QWORD * ) ( @@int64@@ + Number ) && * ( _DWORD * ) ( Number * ( @@int@@ + @@int64@@ ) + * ( _QWORD * ) ( @@int64@@ + Number ) ) == Number ; ++ @@int@@ ) { ; } return ( unsigned int ) @@int@@ ; }
__int64 __fastcall fetch_number ( __int64 @@int64@@ , unsigned __int8 * @@unsignedint8@@ , __int64 @@int64@@ ) { unsigned __int64 @@unsignedint64@@ ; unsigned __int8 @@unsignedint8@@ ; __int64 @@int64@@ ; for ( @@int64@@ = Number ; ; @@int64@@ = @@unsignedint64@@ ) { fetch_token ( ( __int64 ) @@unsignedint8@@ , @@int64@@ , @@int64@@ ) ; @@unsignedint8@@ = * @@unsignedint8@@ ; if ( @@unsignedint8@@ [ Number ] == Number ) return Number ; if ( @@unsignedint8@@ [ Number ] == Number || @@unsignedint8@@ == Number ) break ; if ( @@unsignedint8@@ [ Number ] != Number || @@unsignedint8@@ <= Number || @@unsignedint8@@ > Number || @@int64@@ == Number ) { @@unsignedint64@@ = Number ; } else if ( @@int64@@ == Number ) { @@unsignedint64@@ = @@unsignedint8@@ - Number ; } else { @@unsignedint64@@ = Number * @@int64@@ + @@unsignedint8@@ - Number ; } if ( @@unsignedint64@@ > Number ) @@unsignedint64@@ = Number ; } return @@int64@@ ; }
__int64 __fastcall paste_serial ( __int64 @@int64@@ , const char * * @@constchar@@ ) { int @@int@@ ; const char * @@constchar@@ ; int * @@int@@ ; unsigned __int8 @@unsignedint8@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; char * @@char@@ ; FILE * @@FILE@@ ; @@unsignedint8@@ = Number ; while ( @@int64@@ ) { @@int@@ = strcmp ( * @@constchar@@ , String ) ; @@bool@@ = @@int@@ == Number ; if ( @@int@@ ) { @@FILE@@ = fopen ( * @@constchar@@ , String ) ; if ( ! @@FILE@@ ) goto LABEL_23 ; } else { have_read_stdin = Number ; @@FILE@@ = stdin ; } @@char@@ = ( char * ) delims ; @@int@@ = getc_unlocked ( @@FILE@@ ) ; @@int@@ = * __errno_location ( ) ; if ( @@int@@ != Number ) { while ( Number ) { @@int@@ = getc_unlocked ( @@FILE@@ ) ; if ( @@int@@ == Number ) break ; if ( @@int@@ == Number ) { if ( * @@char@@ ) xputchar ( * @@char@@ ) ; if ( ++ @@char@@ == ( char * ) delim_end ) @@char@@ = ( char * ) delims ; } else { xputchar ( @@int@@ ) ; } @@int@@ = @@int@@ ; } @@int@@ = * __errno_location ( ) ; xputchar ( @@int@@ ) ; } if ( @@int@@ != Number ) xputchar ( Number ) ; if ( ferror_unlocked ( @@FILE@@ ) ) { error ( Number , @@int@@ , String , * @@constchar@@ ) ; @@unsignedint8@@ = Number ; } if ( @@bool@@ ) { clearerr_unlocked ( @@FILE@@ ) ; goto LABEL_24 ; } if ( fclose ( @@FILE@@ ) == Number ) { LABEL_23 : @@constchar@@ = * @@constchar@@ ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , String , @@constchar@@ ) ; @@unsignedint8@@ = Number ; } LABEL_24 : -- @@int64@@ ; ++ @@constchar@@ ; } return @@unsignedint8@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_207028 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall rpl_re_match_2 ( int @@int@@ , int @@int@@ , int @@int@@ , int @@int@@ , int @@int@@ , int @@int@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return re_search_2_stub ( @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int@@ , Number L , @@int64@@ , @@int64@@ , Number ) ; }
unsigned __int64 __fastcall re_string_skip_chars ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , wchar_t * @@wchart@@ ) { _BOOL4 @@BOOL4@@ ; wchar_t @@wchart@@ ; wchar_t @@wchart@@ ; unsigned __int64 @@unsignedint64@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@wchart@@ = Number ; for ( @@unsignedint64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) + * ( _QWORD * ) ( @@int64@@ + Number ) ; @@unsignedint64@@ < @@unsignedint64@@ ; @@unsignedint64@@ += @@sizet@@ ) { @@sizet@@ = * ( _QWORD * ) ( @@int64@@ + Number ) - @@unsignedint64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@sizet@@ = mbrtowc ( & @@wchart@@ , ( const char * ) ( * ( _QWORD * ) @@int64@@ + @@unsignedint64@@ ) , @@sizet@@ , ( mbstate_t * ) ( @@int64@@ + Number ) ) ; @@BOOL4@@ = @@sizet@@ == Number || @@sizet@@ == Number ; if ( ! @@BOOL4@@ && @@sizet@@ ) { @@wchart@@ = @@wchart@@ ; } else { if ( @@sizet@@ && @@sizet@@ ) @@wchart@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) @@int64@@ + @@unsignedint64@@ ) ; else @@wchart@@ = Number ; @@sizet@@ = Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; } } * @@wchart@@ = @@wchart@@ ; return @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_21F238 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
__int64 __fastcall re_node_set_init_1 ( _QWORD * @@QWORD@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; * @@QWORD@@ = Number L ; @@QWORD@@ [ Number ] = Number L ; @@QWORD@@ [ Number ] = malloc ( Number ) ; if ( @@QWORD@@ [ Number ] ) { * ( _QWORD * ) @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = Number L ; } else { @@QWORD@@ [ Number ] = Number L ; * @@QWORD@@ = @@QWORD@@ [ Number ] ; @@int64@@ = Number L ; } return @@int64@@ ; }
_QWORD * __fastcall rpl_re_set_registers ( __int64 @@int64@@ , _QWORD * @@QWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; if ( @@int64@@ ) { * ( _BYTE * ) ( @@int64@@ + Number ) = * ( _BYTE * ) ( @@int64@@ + Number ) & Number | Number ; * @@QWORD@@ = @@int64@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; } else { * ( _BYTE * ) ( @@int64@@ + Number ) &= Number ; * @@QWORD@@ = Number L ; @@QWORD@@ [ Number ] = Number L ; @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ [ Number ] = @@QWORD@@ [ Number ] ; } return @@QWORD@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
__int64 __fastcall check_halt_state_context ( __int64 @@int64@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { char @@char@@ ; unsigned __int64 @@unsignedint64@@ ; @@char@@ = re_string_context_at ( @@int64@@ , @@unsignedint64@@ , * ( _DWORD * ) ( @@int64@@ + Number ) ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { if ( check_halt_node_context ( * ( _QWORD * * ) ( @@int64@@ + Number ) , * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) , @@char@@ ) ) { return * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; } } return Number L ; }
__int64 __fastcall re_node_set_insert_last ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; void * @@void@@ ; if ( * ( _QWORD * ) @@int64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ) { * ( _QWORD * ) @@int64@@ = Number * ( * ( _QWORD * ) @@int64@@ + Number L ) ; @@void@@ = realloc ( * ( void * * ) ( @@int64@@ + Number ) , Number L * * ( _QWORD * ) @@int64@@ ) ; if ( ! @@void@@ ) return Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@void@@ ; } @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ + Number ; * ( _QWORD * ) ( @@int64@@ + Number * @@int64@@ ) = @@int64@@ ; return Number L ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_206028 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
__int64 __fastcall free_fail_stack_return ( __int64 @@int64@@ ) { unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) { for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) @@int64@@ ; ++ @@unsignedint64@@ ) { free ( * ( void * * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@unsignedint64@@ + Number ) ) ; free ( * ( void * * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@unsignedint64@@ + Number ) ) ; } free ( * ( void * * ) ( @@int64@@ + Number ) ) ; } return Number L ; }
_QWORD * __fastcall re_acquire_state ( _DWORD * @@DWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; unsigned __int64 * @@unsignedint64@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) { @@int64@@ = calc_state_hash ( @@int64@@ , Number ) ; @@unsignedint64@@ = ( unsigned __int64 * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * ( @@int64@@ & * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * @@unsignedint64@@ ; ++ @@unsignedint64@@ ) { @@QWORD@@ = * ( _QWORD * * ) ( Number * @@unsignedint64@@ + @@unsignedint64@@ [ Number ] ) ; if ( @@int64@@ == * @@QWORD@@ && ( unsigned __int8 ) re_node_set_compare ( ( __int64 ) ( @@QWORD@@ + Number ) , @@int64@@ ) ) { return @@QWORD@@ ; } } @@int64@@ = create_ci_newstate ( @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( ! @@int64@@ ) * @@DWORD@@ = Number ; @@QWORD@@ = ( _QWORD * ) @@int64@@ ; } else { * @@DWORD@@ = Number ; @@QWORD@@ = Number L ; } return @@QWORD@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
_QWORD * __fastcall bitset_clear ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { _QWORD * @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) ( Number * ( @@unsignedint64@@ >> Number ) + @@int64@@ ) ; * @@QWORD@@ &= ~ ( Number L << ( @@unsignedint64@@ & Number ) ) ; return @@QWORD@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall rpl_re_set_syntax ( __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = rpl_re_syntax_options ; rpl_re_syntax_options = @@int64@@ ; return @@int64@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
_QWORD * __fastcall update_regs ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ , void * @@void@@ , __int64 @@int64@@ , _QWORD * @@QWORD@@ , unsigned __int64 @@unsignedint64@@ ) { _QWORD * @@QWORD@@ ; int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@QWORD@@ = ( _QWORD * ) * ( unsigned __int8 * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) ; @@int@@ = * ( unsigned __int8 * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) ; if ( @@int@@ == Number ) { @@unsignedint64@@ = * ( _QWORD * ) ( Number * @@int64@@ + * @@QWORD@@ ) + Number L ; @@QWORD@@ = ( _QWORD * ) @@unsignedint64@@ ; if ( @@unsignedint64@@ < @@unsignedint64@@ ) { @@QWORD@@ [ Number * @@unsignedint64@@ ] = @@QWORD@@ ; @@QWORD@@ = & @@QWORD@@ [ Number * @@unsignedint64@@ ] ; @@QWORD@@ [ Number ] = Number ; } } else if ( @@int@@ == Number ) { @@unsignedint64@@ = * ( _QWORD * ) ( Number * @@int64@@ + * @@QWORD@@ ) + Number L ; @@QWORD@@ = ( _QWORD * ) @@unsignedint64@@ ; if ( @@unsignedint64@@ < @@unsignedint64@@ ) { if ( ( unsigned __int64 ) @@QWORD@@ <= @@QWORD@@ [ Number * @@unsignedint64@@ ] ) { if ( ( * ( _BYTE * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) & Number ) == Number || * ( ( _QWORD * ) @@void@@ + Number * @@unsignedint64@@ ) == Number ) { @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ [ Number * @@unsignedint64@@ + Number ] = @@QWORD@@ ; } else { @@QWORD@@ = memcpy ( @@QWORD@@ , @@void@@ , Number * @@unsignedint64@@ ) ; } } else { @@QWORD@@ [ Number * @@unsignedint64@@ + Number ] = @@QWORD@@ ; @@QWORD@@ = memcpy ( @@void@@ , @@QWORD@@ , Number * @@unsignedint64@@ ) ; } } } return @@QWORD@@ ; }
void * __fastcall bitset_set_all ( void * @@void@@ ) { return memset ( @@void@@ , Number , Number ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall rpl_re_compile_fastmap ( __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; void * @@void@@ ; @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; @@void@@ = * ( void * * ) ( @@int64@@ + Number ) ; memset ( @@void@@ , Number , Number ) ; re_compile_fastmap_iter ( @@int64@@ , @@QWORD@@ [ Number ] , @@void@@ ) ; if ( @@QWORD@@ [ Number ] != @@QWORD@@ [ Number ] ) re_compile_fastmap_iter ( @@int64@@ , @@QWORD@@ [ Number ] , @@void@@ ) ; if ( @@QWORD@@ [ Number ] != @@QWORD@@ [ Number ] ) re_compile_fastmap_iter ( @@int64@@ , @@QWORD@@ [ Number ] , @@void@@ ) ; if ( @@QWORD@@ [ Number ] != @@QWORD@@ [ Number ] ) re_compile_fastmap_iter ( @@int64@@ , @@QWORD@@ [ Number ] , @@void@@ ) ; * ( _BYTE * ) ( @@int64@@ + Number ) |= Number ; return Number L ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ ) { return xmalloc ( @@int64@@ ) ; }
__int64 __fastcall re_string_wchar_at ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; if ( * ( _DWORD * ) ( @@int64@@ + Number ) == Number ) @@int64@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + @@int64@@ ) ; else @@int64@@ = * ( unsigned int * ) ( Number * @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; return @@int64@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall add_epsilon_src_nodes ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { unsigned int @@unsignedint@@ ; unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@unsignedint@@ = Number ; @@QWORD@@ = re_acquire_state ( & @@unsignedint@@ , @@int64@@ , @@int64@@ ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; if ( ! @@QWORD@@ [ Number ] ) { @@unsignedint@@ = re_node_set_alloc ( @@QWORD@@ + Number , * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint@@ ) return Number L ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { re_node_set_merge ( ( __int64 ) ( @@QWORD@@ + Number ) , * ( _QWORD * ) ( @@int64@@ + Number ) + Number L * * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; } } return re_node_set_add_intersect ( @@int64@@ , @@int64@@ , ( __int64 ) ( @@QWORD@@ + Number ) ) ; }
__int64 __fastcall postorder ( _QWORD * @@QWORD@@ , __int64 ( __fastcall * @ @ VAR_980 @ @ int64 ( fastcall ) ( int64 , QWORD ) @ @ regerrcodet ( ) ( void , bintreet0 ) ) ( __int64 , _QWORD * ) , __int64 @@int64@@ ) { unsigned int @@unsignedint@@ ; _QWORD * @@QWORD@@ ; LABEL_5 : while ( @@QWORD@@ [ Number ] || @@QWORD@@ [ Number ] ) { if ( @@QWORD@@ [ Number ] ) @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; else @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; } while ( Number ) { @@unsignedint@@ = @ @ VAR_980 @ @ int64 ( fastcall ) ( int64 , QWORD ) @ @ regerrcodet ( ) ( void , bintreet0 ) ( @@int64@@ , @@QWORD@@ ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; if ( ! * @@QWORD@@ ) return Number L ; @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) * @@QWORD@@ ; if ( @@QWORD@@ != ( _QWORD * ) @@QWORD@@ [ Number ] && @@QWORD@@ [ Number ] ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; goto LABEL_5 ; } } }
_BOOL8 __fastcall strip_trailing_slashes ( char * @@char@@ ) { char @@char@@ ; const char * @@constchar@@ ; const char * @@constchar@@ ; @@constchar@@ = last_component ( @@char@@ ) ; if ( ! * @@constchar@@ ) @@constchar@@ = @@char@@ ; @@constchar@@ = & @@constchar@@ [ base_len ( @@constchar@@ ) ] ; @@char@@ = * @@constchar@@ ; * @@constchar@@ = Number ; return @@char@@ != Number ; }
__int64 __fastcall build_type_arg ( char * * @@char@@ , _QWORD * @@QWORD@@ , __int64 @@int64@@ ) { int @@int@@ ; char * @@char@@ ; size_t @@sizet@@ ; unsigned __int8 @@unsignedint8@@ ; const char * @@constchar@@ ; @@unsignedint8@@ = Number ; @@int@@ = * optarg ; if ( @@int@@ == Number ) { LABEL_7 : * @@char@@ = optarg ; return @@unsignedint8@@ ; } if ( @@int@@ <= Number ) { if ( @@int@@ != Number ) return Number ; goto LABEL_7 ; } if ( @@int@@ != Number ) { if ( @@int@@ != Number ) return Number ; goto LABEL_7 ; } @@char@@ = optarg ++ ; * @@char@@ = @@char@@ ; * @@QWORD@@ = Number L ; @@QWORD@@ [ Number ] = Number L ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = Number L ; rpl_re_syntax_options = Number L ; @@sizet@@ = strlen ( optarg ) ; @@constchar@@ = ( const char * ) rpl_re_compile_pattern ( optarg , @@sizet@@ , @@QWORD@@ ) ; if ( @@constchar@@ ) error ( Number , Number , String , @@constchar@@ ) ; return @@unsignedint8@@ ; }
__int64 __fastcall re_string_construct_common ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , char @@char@@ , __int64 @@int64@@ ) { bool @@bool@@ ; __int64 @@int64@@ ; * ( _QWORD * ) @@int64@@ = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _BYTE * ) ( @@int64@@ + Number ) = @@char@@ ; @@bool@@ = @@int64@@ || @@char@@ ; * ( _BYTE * ) ( @@int64@@ + Number ) = @@bool@@ ; * ( _DWORD * ) ( @@int64@@ + Number ) = * ( _DWORD * ) ( @@int64@@ + Number ) ; * ( _BYTE * ) ( @@int64@@ + Number ) = ( * ( _BYTE * ) ( @@int64@@ + Number ) & Number ) != Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = ( * ( _BYTE * ) ( @@int64@@ + Number ) & Number ) != Number ; * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; return @@int64@@ ; }
__int64 __fastcall check_dst_limits_calc_pos ( __int64 @@int64@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ ; if ( @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ) return Number ; if ( @@unsignedint64@@ > * ( _QWORD * ) ( @@int64@@ + Number ) ) return Number L ; if ( @@unsignedint64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ) @@int@@ = Number ; else @@int@@ = Number ; @@int@@ = @@int@@ | ( @@unsignedint64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( @@int@@ ) @@int64@@ = check_dst_limits_calc_pos_1 ( @@int64@@ , @@int@@ , @@unsignedint64@@ , @@int64@@ , @@int64@@ ) ; else @@int64@@ = Number L ; return @@int64@@ ; }
__int64 __fastcall lower_subexp ( _DWORD * @@DWORD@@ , __int64 * @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; _BOOL4 @@BOOL4@@ ; _BOOL4 @@BOOL4@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = * @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( ( @@int64@@ [ Number ] & Number ) != Number && * ( _QWORD * ) ( @@int64@@ + Number ) && ( * ( _QWORD * ) ( @@int64@@ + Number ) > Number || ( ( * ( _QWORD * ) ( @@int64@@ + Number ) >> * ( _QWORD * ) ( @@int64@@ + Number ) ) & Number L ) == Number ) ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; } @@int64@@ = create_tree ( @@int64@@ , Number L , Number L , Number L ) ; @@int64@@ = create_tree ( @@int64@@ , Number L , Number L , Number L ) ; if ( @@int64@@ ) @@int64@@ = create_tree ( @@int64@@ , @@int64@@ , @@int64@@ , Number L ) ; else @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = create_tree ( @@int64@@ , @@int64@@ , @@int64@@ , Number L ) ; @@BOOL4@@ = ! @@int64@@ || ! @@int64@@ ; @@BOOL4@@ = @@BOOL4@@ || ! @@int64@@ ; if ( ! @@BOOL4@@ && @@int64@@ ) { * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _BYTE * ) ( @@int64@@ + Number ) = ( Number * ( ( * ( _BYTE * ) ( @@int64@@ + Number ) & Number ) != Number ) ) | * ( _BYTE * ) ( @@int64@@ + Number ) & Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = ( Number * ( ( * ( _BYTE * ) ( @@int64@@ + Number ) & Number ) != Number ) ) | * ( _BYTE * ) ( @@int64@@ + Number ) & Number ; @@int64@@ = @@int64@@ ; } else { * @@DWORD@@ = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
__int64 __fastcall bkm_scale_by_power ( __int64 * @@int64@@ , int @@int@@ , int @@int@@ ) { unsigned int @@unsignedint@@ ; for ( @@unsignedint@@ = Number ; @@int@@ -- ; @@unsignedint@@ |= bkm_scale ( @@int64@@ , @@int@@ ) ) { ; } return @@unsignedint@@ ; }
__int64 __fastcall re_string_fetch_byte_case ( __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned int @@unsignedint@@ ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) ) { if ( * ( _BYTE * ) ( @@int64@@ + Number ) ) { if ( * ( _QWORD * ) ( @@int64@@ + Number ) == * ( _QWORD * ) ( @@int64@@ + Number ) || * ( _DWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L * * ( _QWORD * ) ( @@int64@@ + Number ) ) != Number ) { @@unsignedint@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) + * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L * * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; if ( ( @@unsignedint@@ & Number ) != Number ) { @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ + Number ; @@int64@@ = * ( unsigned __int8 * ) ( @@int64@@ + @@int64@@ ) ; } else { @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ + ( int ) re_string_char_size_at ( @@int64@@ , @@int64@@ ) ; @@int64@@ = @@unsignedint@@ ; } } else { @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ + Number ; @@int64@@ = * ( unsigned __int8 * ) ( @@int64@@ + @@int64@@ ) ; } } else { @@int64@@ = * ( _QWORD * ) @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ + Number ; @@int64@@ = * ( unsigned __int8 * ) ( @@int64@@ + @@int64@@ + @@int64@@ ) ; } } else { @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ + Number ; @@int64@@ = * ( unsigned __int8 * ) ( @@int64@@ + @@int64@@ ) ; } return @@int64@@ ; }
__int64 __fastcall merge_state_with_log ( _DWORD * @@DWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned int @@unsignedint@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ [ Number ] ; void * @@void@@ ; unsigned __int64 @@unsignedint64@@ ; @@int64@@ = @@int64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@unsignedint64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( @@unsignedint64@@ <= * ( _QWORD * ) ( @@int64@@ + Number ) ) { if ( * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ) { @@int64@@ = Number L ; @@int64@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) + Number L ) ; if ( @@int64@@ ) { @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * @@DWORD@@ = re_node_set_init_union ( @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( * @@DWORD@@ ) return Number L ; } else { @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ [ Number ] = * ( _QWORD * ) @@int64@@ ; @@int64@@ [ Number ] = @@int64@@ ; @@void@@ = * ( void * * ) ( @@int64@@ + Number ) ; } @@unsignedint@@ = re_string_context_at ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) - Number L , * ( _DWORD * ) ( @@int64@@ + Number ) ) ; @@int64@@ = ( __int64 * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@unsignedint64@@ ) ; * @@int64@@ = re_acquire_state_context ( @@DWORD@@ , @@int64@@ , ( __int64 ) @@int64@@ , @@unsignedint@@ ) ; @@int64@@ = * @@int64@@ ; if ( @@int64@@ ) free ( @@void@@ ) ; } else { * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@unsignedint64@@ ) = @@int64@@ ; } } else { * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@unsignedint64@@ ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@unsignedint64@@ ; } if ( * ( _QWORD * ) ( @@int64@@ + Number ) && @@int64@@ ) { * @@DWORD@@ = check_subexp_matching_top ( @@int64@@ , @@int64@@ + Number , @@unsignedint64@@ ) ; if ( * @@DWORD@@ ) return Number L ; if ( ( * ( _BYTE * ) ( @@int64@@ + Number ) & Number ) != Number ) { * @@DWORD@@ = transit_state_bkref ( @@int64@@ , @@int64@@ + Number ) ; if ( * @@DWORD@@ ) return Number L ; @@int64@@ = * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; } } return @@int64@@ ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall peek_token_bracket ( _BYTE * @@BYTE@@ , __int64 @@int64@@ , char @@char@@ ) { char @@char@@ ; char @@char@@ ; unsigned int @@unsignedint@@ ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) <= * ( _QWORD * ) ( @@int64@@ + Number ) ) { @@BYTE@@ [ Number ] = Number ; return Number L ; } @@char@@ = * ( _BYTE * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; * @@BYTE@@ = @@char@@ ; if ( * ( int * ) ( @@int64@@ + Number ) > Number && * ( _QWORD * ) ( @@int64@@ + Number ) != * ( _QWORD * ) ( @@int64@@ + Number ) && * ( _DWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L * * ( _QWORD * ) ( @@int64@@ + Number ) ) == Number ) { @@BYTE@@ [ Number ] = Number ; return Number L ; } if ( @@char@@ == Number && ( @@char@@ & Number ) != Number && ( unsigned __int64 ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) < * ( _QWORD * ) ( @@int64@@ + Number ) ) { ++ * ( _QWORD * ) ( @@int64@@ + Number ) ; * @@BYTE@@ = * ( _BYTE * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; @@BYTE@@ [ Number ] = Number ; return Number L ; } switch ( @@char@@ ) { case String : if ( ( unsigned __int64 ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) >= * ( _QWORD * ) ( @@int64@@ + Number ) ) @@char@@ = Number ; else @@char@@ = * ( _BYTE * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) ; * @@BYTE@@ = @@char@@ ; @@unsignedint@@ = Number ; switch ( @@char@@ ) { case String : if ( ( @@char@@ & Number ) != Number ) { @@BYTE@@ [ Number ] = Number ; return @@unsignedint@@ ; } break ; case String : @@BYTE@@ [ Number ] = Number ; return @@unsignedint@@ ; case String : @@BYTE@@ [ Number ] = Number ; return @@unsignedint@@ ; } @@BYTE@@ [ Number ] = Number ; * @@BYTE@@ = Number ; return Number ; case String : @@BYTE@@ [ Number ] = Number ; break ; case String : @@BYTE@@ [ Number ] = Number ; break ; case String : @@BYTE@@ [ Number ] = Number ; break ; default : @@BYTE@@ [ Number ] = Number ; break ; } return Number L ; }
__int64 __fastcall re_node_set_compare ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; if ( ! @@int64@@ || ! @@int64@@ || * ( _QWORD * ) ( @@int64@@ + Number ) != * ( _QWORD * ) ( @@int64@@ + Number ) ) { return Number L ; } @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; while ( ( unsigned __int64 ) -- @@int64@@ <= Number ) { if ( * ( _QWORD * ) ( Number * @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) != * ( _QWORD * ) ( Number * @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ) return Number L ; } return Number L ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
__int64 __fastcall extend_buffers ( __int64 @@int64@@ ) { unsigned int @@unsignedint@@ ; unsigned int @@unsignedint@@ ; void * @@void@@ ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) > Number ) return Number L ; @@unsignedint@@ = re_string_realloc_buffers ( @@int64@@ , Number L * * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) { @@void@@ = realloc ( * ( void * * ) ( @@int64@@ + Number ) , Number * ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) ) ; if ( ! @@void@@ ) return Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@void@@ ; } if ( * ( _BYTE * ) ( @@int64@@ + Number ) ) { if ( * ( int * ) ( @@int64@@ + Number ) <= Number ) { build_upper_buffer ( ( _QWORD * ) @@int64@@ ) ; } else { @@unsignedint@@ = build_wcs_upper_buffer ( @@int64@@ ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; } } else if ( * ( int * ) ( @@int64@@ + Number ) <= Number ) { if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) re_string_translate_buffer ( ( _QWORD * ) @@int64@@ ) ; } else { build_wcs_buffer ( @@int64@@ ) ; } return Number L ; }
__int64 __fastcall calc_state_hash ( __int64 @@int64@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) + @@unsignedint@@ ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { @@int64@@ += * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; } return @@int64@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
_QWORD * __fastcall match_ctx_add_sublast ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; void * @@void@@ ; _QWORD * @@QWORD@@ ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) == * ( _QWORD * ) ( @@int64@@ + Number ) ) { @@int64@@ = Number L * * ( _QWORD * ) ( @@int64@@ + Number ) + Number ; @@void@@ = realloc ( * ( void * * ) ( @@int64@@ + Number ) , Number * @@int64@@ ) ; if ( ! @@void@@ ) return Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@void@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; } @@QWORD@@ = calloc ( Number , Number ) ; if ( @@QWORD@@ ) { * ( _QWORD * ) ( Number L * * ( _QWORD * ) ( @@int64@@ + Number ) + * ( _QWORD * ) ( @@int64@@ + Number ) ) = @@QWORD@@ ; * @@QWORD@@ = @@int64@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; ++ * ( _QWORD * ) ( @@int64@@ + Number ) ; } return @@QWORD@@ ; }
__int64 __fastcall build_charclass_op ( __int64 @@int64@@ , __int64 @@int64@@ , const char * @@constchar@@ , _BYTE * @@BYTE@@ , char @@char@@ , _DWORD * @@DWORD@@ ) { int @@int@@ ; __int64 @@int64@@ ; void * @@void@@ ; _BYTE * @@BYTE@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; void * @@void@@ ; char @@char@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = Number L ; @@void@@ = calloc ( Number , Number ) ; @@BYTE@@ = calloc ( Number , Number ) ; if ( ! @@void@@ || ! @@BYTE@@ ) { * @@DWORD@@ = Number ; return Number L ; } if ( @@char@@ ) @@BYTE@@ [ Number ] |= Number ; @@int@@ = build_charclass ( @@int64@@ , ( __int64 ) @@void@@ , ( __int64 ) @@BYTE@@ , & @@int64@@ , @@constchar@@ , Number ) ; if ( @@int@@ ) { free ( @@void@@ ) ; free_charset ( @@BYTE@@ ) ; * @@DWORD@@ = @@int@@ ; return Number L ; } while ( * @@BYTE@@ ) bitset_set ( ( __int64 ) @@void@@ , ( unsigned __int8 ) * @@BYTE@@ ++ ) ; if ( @@char@@ ) bitset_not ( ( __int64 ) @@void@@ ) ; if ( * ( int * ) ( @@int64@@ + Number ) > Number ) bitset_mask ( ( __int64 ) @@void@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ; @@char@@ = Number ; @@void@@ = @@void@@ ; @@int64@@ = create_token_tree ( @@int64@@ , Number L , Number L , & @@void@@ ) ; if ( @@int64@@ ) { if ( * ( int * ) ( @@int64@@ + Number ) <= Number ) { free_charset ( @@BYTE@@ ) ; return @@int64@@ ; } @@char@@ = Number ; @@void@@ = @@BYTE@@ ; * ( _BYTE * ) ( @@int64@@ + Number ) |= Number ; @@int64@@ = create_token_tree ( @@int64@@ , Number L , Number L , & @@void@@ ) ; if ( @@int64@@ ) { @@int64@@ = create_tree ( @@int64@@ , @@int64@@ , @@int64@@ , Number L ) ; if ( @@int64@@ ) return @@int64@@ ; } } free ( @@void@@ ) ; free_charset ( @@BYTE@@ ) ; * @@DWORD@@ = Number ; return Number L ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
unsigned __int64 __fastcall triple_hash_no_name ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) % @@unsignedint64@@ ; }
__int64 __fastcall re_acquire_state_context ( _DWORD * @@DWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; unsigned __int64 * @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) { @@int64@@ = calc_state_hash ( @@int64@@ , @@unsignedint@@ ) ; @@unsignedint64@@ = ( unsigned __int64 * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * ( @@int64@@ & * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * @@unsignedint64@@ ; ++ @@unsignedint64@@ ) { @@int64@@ = * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@unsignedint64@@ [ Number ] ) ; if ( @@int64@@ == * ( _QWORD * ) @@int64@@ && @@unsignedint@@ == ( * ( _BYTE * ) ( @@int64@@ + Number ) & Number ) && ( unsigned __int8 ) re_node_set_compare ( * ( _QWORD * ) ( @@int64@@ + Number ) , @@int64@@ ) ) { return @@int64@@ ; } } @@int64@@ = create_cd_newstate ( @@int64@@ , @@int64@@ , @@unsignedint@@ , @@int64@@ ) ; if ( ! @@int64@@ ) * @@DWORD@@ = Number ; @@int64@@ = @@int64@@ ; } else { * @@DWORD@@ = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall rpl_re_search_2 ( int @@int@@ , int @@int@@ , int @@int@@ , int @@int@@ , int @@int@@ , int @@int@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return re_search_2_stub ( @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int64@@ , @@int64@@ , @@int64@@ , Number ) ; }
_QWORD * __fastcall bitset_merge ( __int64 @@int64@@ , __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; int @@int@@ ; for ( @@int@@ = Number ; @@int@@ <= Number ; ++ @@int@@ ) { @@QWORD@@ = ( _QWORD * ) ( Number L * @@int@@ + @@int64@@ ) ; * @@QWORD@@ |= * ( _QWORD * ) ( Number L * @@int@@ + @@int64@@ ) ; } return @@QWORD@@ ; }
_BOOL8 __fastcall triple_compare ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ ) { return @@QWORD@@ [ Number ] == @@QWORD@@ [ Number ] && @@QWORD@@ [ Number ] == @@QWORD@@ [ Number ] && ( unsigned __int8 ) same_name ( * @@QWORD@@ , * @@QWORD@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
size_t __fastcall rpl_regerror ( int @@int@@ , __int64 a2 , _BYTE * @@BYTE@@ , size_t @@sizet@@ ) { size_t @@sizet@@ ; const char * @@constchar@@ ; size_t @@sizet@@ ; if ( @@int@@ < Number || @@int@@ > Number ) abort ( ) ; @@constchar@@ = gettext ( & _re_error_msgid [ _re_error_msgid_idx [ @@int@@ ] ] ) ; @@sizet@@ = strlen ( @@constchar@@ ) + Number ; if ( @@sizet@@ ) { @@sizet@@ = @@sizet@@ ; if ( @@sizet@@ > @@sizet@@ ) { @@sizet@@ = @@sizet@@ - Number ; @@BYTE@@ [ @@sizet@@ - Number ] = Number ; } memcpy ( @@BYTE@@ , @@constchar@@ , @@sizet@@ ) ; } return @@sizet@@ ; }
__int64 __fastcall prune_impossible_nodes ( __int64 @@int64@@ ) { unsigned int @@unsignedint@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; char @@char@@ [ Number ] ; void * @@void@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ = Number L ; @@unsignedint64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( @@unsignedint64@@ > Number ) return Number L ; @@QWORD@@ = malloc ( Number * ( @@unsignedint64@@ + Number ) ) ; if ( @@QWORD@@ ) { if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) { @@QWORD@@ = malloc ( Number * ( @@unsignedint64@@ + Number ) ) ; if ( @@QWORD@@ ) { while ( Number ) { memset ( @@QWORD@@ , Number , Number * ( @@unsignedint64@@ + Number ) ) ; sift_ctx_init ( @@char@@ , @@QWORD@@ , @@QWORD@@ , @@int64@@ , @@unsignedint64@@ ) ; @@unsignedint@@ = sift_states_backward ( @@int64@@ , @@char@@ ) ; free ( @@void@@ ) ; if ( @@unsignedint@@ ) break ; if ( * @@QWORD@@ || * @@QWORD@@ ) { @@unsignedint@@ = merge_state_array ( @@int64@@ , @@QWORD@@ , @@QWORD@@ , @@unsignedint64@@ + Number ) ; free ( @@QWORD@@ ) ; @@QWORD@@ = Number L ; if ( ! @@unsignedint@@ ) goto LABEL_21 ; break ; } do { if ( -- @@unsignedint64@@ > Number ) { @@unsignedint@@ = Number ; goto LABEL_22 ; } } while ( ! * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) || ( * ( _BYTE * ) ( * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) + Number L ) & Number ) == Number ) ; @@int64@@ = check_halt_state_context ( @@int64@@ , * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) , @@unsignedint64@@ ) ; } } else { @@unsignedint@@ = Number ; } } else { sift_ctx_init ( @@char@@ , @@QWORD@@ , Number L , @@int64@@ , @@unsignedint64@@ ) ; @@unsignedint@@ = sift_states_backward ( @@int64@@ , @@char@@ ) ; free ( @@void@@ ) ; if ( ! @@unsignedint@@ ) { if ( * @@QWORD@@ ) { LABEL_21 : free ( * ( void * * ) ( @@int64@@ + Number ) ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@QWORD@@ ; @@QWORD@@ = Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@unsignedint64@@ ; @@unsignedint@@ = Number ; } else { @@unsignedint@@ = Number ; } } } } else { @@unsignedint@@ = Number ; } LABEL_22 : free ( @@QWORD@@ ) ; free ( @@QWORD@@ ) ; return @@unsignedint@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
unsigned __int64 __fastcall check_extension ( const char * @@constchar@@ , __int64 @@int64@@ , char @@char@@ ) { unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; char * @@char@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int16 @@int16@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@char@@ = ( char * ) last_component ( @@constchar@@ ) ; @@unsignedint64@@ = base_len ( @@char@@ ) ; @@unsignedint64@@ = Number L ; if ( @@unsignedint64@@ > Number ) { @@int16@@ = * ( _WORD * ) @@char@@ ; * ( _WORD * ) @@char@@ = Number ; * __errno_location ( ) = Number ; @@int64@@ = pathconf ( @@constchar@@ , Number ) ; if ( @@int64@@ >= Number || ! * __errno_location ( ) ) @@unsignedint64@@ = @@int64@@ ; * ( _WORD * ) @@char@@ = @@int16@@ ; } if ( @@unsignedint64@@ < @@unsignedint64@@ ) { @@unsignedint64@@ = & @@constchar@@ [ @@int64@@ ] - @@char@@ ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) @@unsignedint64@@ = @@unsignedint64@@ - Number ; @@char@@ [ @@unsignedint64@@ ] = @@char@@ ; @@char@@ [ @@unsignedint64@@ + Number ] = Number ; } return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall re_string_construct ( __int64 @@int64@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; unsigned int @@unsignedint@@ ; unsigned int @@unsignedint@@ ; unsigned int @@unsignedint@@ ; memset ( ( void * ) @@int64@@ , Number , Number ) ; re_string_construct_common ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@int64@@ , @@unsignedint8@@ , @@int64@@ ) ; if ( @@unsignedint64@@ ) { @@unsignedint@@ = re_string_realloc_buffers ( @@int64@@ , @@unsignedint64@@ + Number ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; } if ( * ( _BYTE * ) ( @@int64@@ + Number ) ) @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; else @@int64@@ = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; if ( ! @@unsignedint8@@ ) { if ( * ( int * ) ( @@int64@@ + Number ) <= Number ) { if ( @@int64@@ ) { re_string_translate_buffer ( @@int64@@ ) ; } else { * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; } } else { build_wcs_buffer ( @@int64@@ ) ; } return Number L ; } if ( * ( int * ) ( @@int64@@ + Number ) <= Number ) { build_upper_buffer ( @@int64@@ ) ; return Number L ; } do { @@unsignedint@@ = build_wcs_upper_buffer ( @@int64@@ ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; if ( @@unsignedint64@@ <= * ( _QWORD * ) ( @@int64@@ + Number ) || * ( _QWORD * ) ( @@int64@@ + Number ) > ( unsigned __int64 ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + * ( int * ) ( @@int64@@ + Number ) ) ) { return Number L ; } @@unsignedint@@ = re_string_realloc_buffers ( @@int64@@ , Number L * * ( _QWORD * ) ( @@int64@@ + Number ) ) ; } while ( ! @@unsignedint@@ ) ; return @@unsignedint@@ ; }
__int64 __fastcall free_workarea_compile ( __int64 * @@int64@@ ) { __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; @@int64@@ = * @@int64@@ ; for ( @@QWORD@@ = * ( _QWORD * * ) ( * @@int64@@ + Number ) ; @@QWORD@@ ; @@QWORD@@ = @@QWORD@@ ) { @@QWORD@@ = ( _QWORD * ) * @@QWORD@@ ; free ( @@QWORD@@ ) ; } * ( _QWORD * ) ( @@int64@@ + Number ) = Number L ; * ( _DWORD * ) ( @@int64@@ + Number ) = Number ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number L ; free ( * ( void * * ) ( @@int64@@ + Number ) ) ; @@int64@@ = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number L ; return @@int64@@ ; }
__int64 __fastcall hash_get_first ( unsigned __int64 * @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; if ( ! @@unsignedint64@@ [ Number ] ) return Number L ; for ( @@unsignedint64@@ = * @@unsignedint64@@ ; ; @@unsignedint64@@ += Number L ) { if ( @@unsignedint64@@ >= @@unsignedint64@@ [ Number ] ) abort ( ) ; if ( * ( _QWORD * ) @@unsignedint64@@ ) break ; } return * ( _QWORD * ) @@unsignedint64@@ ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
__int64 __fastcall update_cur_sifted_state ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; unsigned int @@unsignedint@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = @@QWORD@@ [ Number ] ; @@unsignedint@@ = Number ; if ( * ( _QWORD * ) ( Number * @@int64@@ + @@QWORD@@ [ Number ] ) ) @@int64@@ = * ( _QWORD * ) ( Number * @@int64@@ + @@QWORD@@ [ Number ] ) + Number L ; else @@int64@@ = Number L ; @@int64@@ = @@int64@@ ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) { if ( @@int64@@ ) { @@unsignedint@@ = add_epsilon_src_nodes ( @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; if ( @@QWORD@@ [ Number ] ) { @@unsignedint@@ = check_subexp_limits ( @@int64@@ , @@int64@@ , @@int64@@ , @@QWORD@@ + Number , @@QWORD@@ [ Number ] , @@int64@@ ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; } } @@QWORD@@ = ( _QWORD * ) ( * @@QWORD@@ + Number * @@int64@@ ) ; * @@QWORD@@ = re_acquire_state ( & @@unsignedint@@ , @@int64@@ , @@int64@@ ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; } else { * ( _QWORD * ) ( Number * @@int64@@ + * @@QWORD@@ ) = Number L ; } if ( @@int64@@ && ( * ( _BYTE * ) ( * ( _QWORD * ) ( Number * @@int64@@ + @@QWORD@@ [ Number ] ) + Number L ) & Number ) != Number && ( @@unsignedint@@ = sift_states_bkref ( @@QWORD@@ , @@QWORD@@ , @@int64@@ , @@int64@@ ) ) != Number ) { @@int64@@ = @@unsignedint@@ ; } else { @@int64@@ = Number L ; } return @@int64@@ ; }
void __fastcall re_string_destruct ( __int64 @@int64@@ ) { free ( * ( void * * ) ( @@int64@@ + Number ) ) ; free ( * ( void * * ) ( @@int64@@ + Number ) ) ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) ) free ( * ( void * * ) ( @@int64@@ + Number ) ) ; }
__int64 __fastcall bkm_scale ( __int64 * @@int64@@ , int @@int@@ ) { __int64 @@int64@@ ; if ( * @@int64@@ >= ( __int64 ) Number / @@int@@ ) { if ( Number / @@int@@ >= * @@int64@@ ) { * @@int64@@ *= @@int@@ ; @@int64@@ = Number L ; } else { * @@int64@@ = Number ; @@int64@@ = Number L ; } } else { * @@int64@@ = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall hash_do_for_each ( __int64 @@int64@@ , unsigned __int8 ( __fastcall * @ @ VAR_521 @ @ unsignedint8 ( fastcall ) ( QWORD , int64 ) @ @ Hashprocessor ) ( _QWORD , __int64 ) , __int64 @@int64@@ ) { __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; @@int64@@ = Number L ; for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { for ( @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { if ( @ @ VAR_521 @ @ unsignedint8 ( fastcall ) ( QWORD , int64 ) @ @ Hashprocessor ( * @@QWORD@@ , @@int64@@ ) != Number ) return @@int64@@ ; ++ @@int64@@ ; } } } return @@int64@@ ; }
__int64 __fastcall lower_subexps ( __int64 @@int64@@ , __int64 @@int64@@ ) { unsigned int @@unsignedint@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = @@int64@@ ; @@unsignedint@@ = Number ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) { if ( * ( _BYTE * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) == Number ) { * ( _QWORD * ) ( @@int64@@ + Number ) = lower_subexp ( & @@unsignedint@@ , @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) * * ( _QWORD * * ) ( @@int64@@ + Number ) = @@int64@@ ; } } if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) { if ( * ( _BYTE * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) == Number ) { * ( _QWORD * ) ( @@int64@@ + Number ) = lower_subexp ( & @@unsignedint@@ , @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) * * ( _QWORD * * ) ( @@int64@@ + Number ) = @@int64@@ ; } } return @@unsignedint@@ ; }
__int64 __fastcall transit_state ( _DWORD * @@DWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int8 @@unsignedint8@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; if ( ( * ( _BYTE * ) ( @@int64@@ + Number ) & Number ) != Number ) { * @@DWORD@@ = transit_state_mb ( @@int64@@ , @@int64@@ ) ; if ( * @@DWORD@@ ) return Number L ; } @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ + Number ; @@unsignedint8@@ = * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) ; while ( Number ) { @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( @@int64@@ ) return * ( _QWORD * ) ( Number L * @@unsignedint8@@ + @@int64@@ ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( @@int64@@ ) break ; if ( ( unsigned __int8 ) build_trtable ( * ( _QWORD * ) ( @@int64@@ + Number ) , @@int64@@ ) != Number ) { * @@DWORD@@ = Number ; return Number L ; } } if ( ( re_string_context_at ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) - Number L , * ( _DWORD * ) ( @@int64@@ + Number ) ) & Number ) != Number ) @@int64@@ = Number * ( @@unsignedint8@@ + Number L ) ; else @@int64@@ = Number L * @@unsignedint8@@ ; return * ( _QWORD * ) ( @@int64@@ + @@int64@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
void * __fastcall allocate_entry ( __int64 @@int64@@ ) { __int64 @@int64@@ ; if ( ! * ( _QWORD * ) ( @@int64@@ + Number ) ) return malloc ( Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; return ( void * ) @@int64@@ ; }
__int64 __fastcall re_string_context_at ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , char @@char@@ ) { __int64 @@int64@@ ; int @@int@@ ; wint_t @@wintt@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@unsignedint64@@ > Number ) return * ( unsigned int * ) ( @@int64@@ + Number ) ; if ( @@unsignedint64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ) { if ( ( @@char@@ & Number ) != Number ) @@int64@@ = Number L ; else @@int64@@ = Number L ; } else if ( * ( int * ) ( @@int64@@ + Number ) <= Number ) { @@int@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + @@unsignedint64@@ ) ; if ( bitset_contain ( * ( _QWORD * ) ( @@int64@@ + Number ) , * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + @@unsignedint64@@ ) ) ) { @@int64@@ = Number L ; } else if ( @@int@@ == Number && * ( _BYTE * ) ( @@int64@@ + Number ) ) { @@int64@@ = Number L ; } else { @@int64@@ = Number L ; } } else { @@unsignedint64@@ = @@unsignedint64@@ ; while ( * ( _DWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) == Number ) { if ( -- @@unsignedint64@@ > Number ) return * ( unsigned int * ) ( @@int64@@ + Number ) ; } @@wintt@@ = * ( _DWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) && ( iswalnum ( @@wintt@@ ) || @@wintt@@ == Number ) ) { @@int64@@ = Number L ; } else if ( @@wintt@@ == Number && * ( _BYTE * ) ( @@int64@@ + Number ) ) { @@int64@@ = Number L ; } else { @@int64@@ = Number L ; } } return @@int64@@ ; }
__int64 __fastcall search_duplicated_node ( _QWORD * @@QWORD@@ , __int64 @@int64@@ , int @@int@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = @@QWORD@@ [ Number ] - Number L ; ( * ( _BYTE * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) & Number ) != Number && @@int64@@ ; -- @@int64@@ ) { if ( @@int64@@ == * ( _QWORD * ) ( Number * @@int64@@ + @@QWORD@@ [ Number ] ) && @@int@@ == ( ( * ( _DWORD * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) >> Number ) & Number ) ) { return @@int64@@ ; } } return Number ; }
__int64 __fastcall free_entry ( __int64 @@int64@@ , _QWORD * @@QWORD@@ ) { __int64 @@int64@@ ; * @@QWORD@@ = Number L ; @@QWORD@@ [ Number ] = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@QWORD@@ ; return @@int64@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
__int64 __fastcall check_arrival_add_next_nodes ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; char @@char@@ [ Number ] ; __int64 @@int64@@ ; void * @@void@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@QWORD@@ = * ( _QWORD * * ) ( @@int64@@ + Number ) ; @@unsignedint@@ = Number ; memset ( @@char@@ , Number , Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { @@int@@ = Number ; @@int64@@ = * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( ( * ( _BYTE * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) & Number ) != Number ) { @@int@@ = check_node_accept_bytes ( @@QWORD@@ , @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( @@int@@ > Number ) { @@unsignedint64@@ = * ( _QWORD * ) ( Number * @@int64@@ + @@QWORD@@ [ Number ] ) ; @@int64@@ = @@int@@ + @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( Number * @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; @@int64@@ = Number L ; if ( @@int64@@ ) { @@unsignedint@@ = re_node_set_merge ( ( __int64 ) @@char@@ , @@int64@@ + Number ) ; if ( @@unsignedint@@ ) goto LABEL_6 ; } if ( ! re_node_set_insert ( ( __int64 ) @@char@@ , @@unsignedint64@@ ) ) goto LABEL_8 ; @@QWORD@@ = ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ ) ; * @@QWORD@@ = re_acquire_state ( & @@unsignedint@@ , ( __int64 ) @@QWORD@@ , ( __int64 ) @@char@@ ) ; if ( ! * ( _QWORD * ) ( Number * @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ) { if ( @@unsignedint@@ ) { LABEL_6 : free ( @@void@@ ) ; return @@unsignedint@@ ; } } } } if ( ( @@int@@ || ( unsigned __int8 ) check_node_accept ( @@int64@@ , * @@QWORD@@ + Number * @@int64@@ , @@int64@@ ) ) && ! re_node_set_insert ( @@int64@@ , * ( _QWORD * ) ( Number * @@int64@@ + @@QWORD@@ [ Number ] ) ) ) { LABEL_8 : free ( @@void@@ ) ; return Number L ; } } free ( @@void@@ ) ; return Number L ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall calc_inveclosure ( _QWORD * @@QWORD@@ ) { unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@QWORD@@ [ Number ] ; ++ @@unsignedint64@@ ) { memset ( ( void * ) ( @@QWORD@@ [ Number ] + Number * @@unsignedint64@@ ) , Number , Number ) ; } for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@QWORD@@ [ Number ] ; ++ @@unsignedint64@@ ) { @@int64@@ = * ( _QWORD * ) ( @@QWORD@@ [ Number ] + Number * @@unsignedint64@@ + Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@QWORD@@ [ Number ] + Number * @@unsignedint64@@ + Number ) ; ++ @@unsignedint64@@ ) { if ( ( unsigned __int8 ) re_node_set_insert_last ( @@QWORD@@ [ Number ] + Number L * * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@int64@@ ) , @@unsignedint64@@ ) != Number ) return Number L ; } } return Number L ; }
bool __fastcall re_node_set_insert ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; void * @@void@@ ; if ( ! * ( _QWORD * ) @@int64@@ ) return ( unsigned int ) re_node_set_init_1 ( ( _QWORD * ) @@int64@@ , @@unsignedint64@@ ) == Number ; if ( ! * ( _QWORD * ) ( @@int64@@ + Number ) ) { * * ( _QWORD * * ) ( @@int64@@ + Number ) = @@unsignedint64@@ ; ++ * ( _QWORD * ) ( @@int64@@ + Number ) ; return Number ; } if ( * ( _QWORD * ) @@int64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ) { * ( _QWORD * ) @@int64@@ *= Number L ; @@void@@ = realloc ( * ( void * * ) ( @@int64@@ + Number ) , Number L * * ( _QWORD * ) @@int64@@ ) ; if ( ! @@void@@ ) return Number ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@void@@ ; } if ( @@unsignedint64@@ >= * * ( _QWORD * * ) ( @@int64@@ + Number ) ) { for ( @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@unsignedint64@@ < * ( _QWORD * ) ( Number * @@int64@@ - Number + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; -- @@int64@@ ) { * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ - Number ) ; } } else { for ( @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ ; -- @@int64@@ ) { * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ - Number ) ; } } * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ ) = @@unsignedint64@@ ; ++ * ( _QWORD * ) ( @@int64@@ + Number ) ; return Number ; }
__int64 __fastcall transfer_entries ( __int64 @@int64@@ , __int64 @@int64@@ , char @@char@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 * @@int64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; for ( @@int64@@ = * ( __int64 * * ) @@int64@@ ; ( unsigned __int64 ) @@int64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ += Number ) { if ( * @@int64@@ ) { for ( @@QWORD@@ = ( _QWORD * ) @@int64@@ [ Number ] ; @@QWORD@@ ; @@QWORD@@ = @@QWORD@@ ) { @@int64@@ = * @@QWORD@@ ; @@int64@@ = * ( _QWORD * ) @@int64@@ ; @@QWORD@@ = ( _QWORD * ) ( @@int64@@ + Number * ( * ( __int64 ( __fastcall * * ) ( _QWORD , _QWORD ) ) ( @@int64@@ + Number ) ) ( * @@QWORD@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@QWORD@@ >= * ( _QWORD * ) ( @@int64@@ + Number ) ) abort ( ) ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; if ( * @@QWORD@@ ) { @@QWORD@@ [ Number ] = @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = @@QWORD@@ ; } else { * @@QWORD@@ = @@int64@@ ; ++ * ( _QWORD * ) ( @@int64@@ + Number ) ; free_entry ( @@int64@@ , @@QWORD@@ ) ; } } @@int64@@ = * @@int64@@ ; @@int64@@ [ Number ] = Number L ; if ( ! @@char@@ ) { @@int64@@ = * ( _QWORD * ) @@int64@@ ; @@QWORD@@ = ( _QWORD * ) ( @@int64@@ + Number * ( * ( __int64 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@int64@@ + Number ) ) ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@QWORD@@ >= * ( _QWORD * ) ( @@int64@@ + Number ) ) abort ( ) ; if ( * @@QWORD@@ ) { @@QWORD@@ = allocate_entry ( @@int64@@ ) ; if ( ! @@QWORD@@ ) return Number L ; * @@QWORD@@ = @@int64@@ ; @@QWORD@@ [ Number ] = @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = @@QWORD@@ ; } else { * @@QWORD@@ = @@int64@@ ; ++ * ( _QWORD * ) ( @@int64@@ + Number ) ; } * @@int64@@ = Number L ; -- * ( _QWORD * ) ( @@int64@@ + Number ) ; } } } return Number L ; }
void __fastcall match_ctx_free ( __int64 @@int64@@ ) { match_ctx_clean ( ( _QWORD * ) @@int64@@ ) ; free ( * ( void * * ) ( @@int64@@ + Number ) ) ; free ( * ( void * * ) ( @@int64@@ + Number ) ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_221588 ; @@int648@@ [ Number ] = qword_221590 ; @@int648@@ [ Number ] = qword_221598 ; @@int648@@ [ Number ] = qword_2215A0 ; @@int648@@ [ Number ] = qword_2215A8 ; @@int648@@ [ Number ] = qword_2215B0 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
__int64 __fastcall parse ( __int64 @@int64@@ , __int64 * @@int64@@ , __int64 @@int64@@ , _DWORD * @@DWORD@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = * @@int64@@ ; * ( _QWORD * ) ( * @@int64@@ + Number ) = @@int64@@ ; fetch_token ( ( __int64 ) @@char@@ , @@int64@@ , @@int64@@ | Number ) ; @@int64@@ = parse_reg_exp ( @@int64@@ , @@int64@@ , @@char@@ , @@int64@@ , Number L , @@DWORD@@ ) ; if ( * @@DWORD@@ && ! @@int64@@ ) return Number L ; @@int64@@ = create_tree ( @@int64@@ , Number L , Number L , Number L ) ; if ( @@int64@@ ) @@int64@@ = create_tree ( @@int64@@ , @@int64@@ , @@int64@@ , Number L ) ; else @@int64@@ = @@int64@@ ; if ( @@int64@@ && @@int64@@ ) return @@int64@@ ; * @@DWORD@@ = Number ; return Number L ; }
char * __fastcall rpl_re_compile_pattern ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { char * @@char@@ ; int @@int@@ ; * ( _BYTE * ) ( @@int64@@ + Number ) = ( Number * ( ( rpl_re_syntax_options & Number ) != Number ) ) | * ( _BYTE * ) ( @@int64@@ + Number ) & Number ; * ( _BYTE * ) ( @@int64@@ + Number ) |= Number ; @@int@@ = re_compile_internal ( @@int64@@ , @@int64@@ , @@int64@@ , rpl_re_syntax_options ) ; if ( @@int@@ ) @@char@@ = gettext ( & _re_error_msgid [ _re_error_msgid_idx [ @@int@@ ] ] ) ; else @@char@@ = Number L ; return @@char@@ ; }
bool __fastcall bitset_contain ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { return ( ( * ( _QWORD * ) ( Number * ( @@unsignedint64@@ >> Number ) + @@int64@@ ) >> ( @@unsignedint64@@ & Number ) ) & Number L ) != Number ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
__int64 __fastcall search_cur_bkref_entry ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@unsignedint64@@ = Number L ; while ( @@unsignedint64@@ < @@unsignedint64@@ ) { if ( @@unsignedint64@@ <= * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * ( ( @@unsignedint64@@ + @@unsignedint64@@ ) >> Number ) + Number ) ) @@unsignedint64@@ = ( @@unsignedint64@@ + @@unsignedint64@@ ) >> Number ; else @@unsignedint64@@ = ( ( @@unsignedint64@@ + @@unsignedint64@@ ) >> Number ) + Number ; } if ( @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) && @@unsignedint64@@ == * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@unsignedint64@@ + Number ) ) { @@int64@@ = @@unsignedint64@@ ; } else { @@int64@@ = Number ; } return @@int64@@ ; }
__int64 __fastcall parse_sub_exp ( __int64 @@int64@@ , __int64 * @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , _DWORD * @@DWORD@@ ) { unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int64@@ = * @@int64@@ ; @@unsignedint64@@ = @@int64@@ [ Number ] ; @@int64@@ [ Number ] = @@unsignedint64@@ + Number ; @@unsignedint64@@ = @@unsignedint64@@ ; fetch_token ( @@int64@@ , @@int64@@ , @@int64@@ | Number ) ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) == Number ) { @@int64@@ = Number L ; } else { @@int64@@ = parse_reg_exp ( @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@DWORD@@ ) ; if ( ! * @@DWORD@@ && * ( _BYTE * ) ( @@int64@@ + Number ) != Number ) * @@DWORD@@ = Number ; if ( * @@DWORD@@ ) return Number L ; } if ( @@unsignedint64@@ <= Number ) * ( _QWORD * ) ( @@int64@@ + Number ) |= Number << @@unsignedint64@@ ; @@int64@@ = create_tree ( @@int64@@ , @@int64@@ , Number L , Number L ) ; if ( @@int64@@ ) { * ( _QWORD * ) ( @@int64@@ + Number ) = @@unsignedint64@@ ; @@int64@@ = @@int64@@ ; } else { * @@DWORD@@ = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
_QWORD * __fastcall bitset_mask ( __int64 @@int64@@ , __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; int @@int@@ ; for ( @@int@@ = Number ; @@int@@ <= Number ; ++ @@int@@ ) { @@QWORD@@ = ( _QWORD * ) ( Number L * @@int@@ + @@int64@@ ) ; * @@QWORD@@ &= * ( _QWORD * ) ( Number L * @@int@@ + @@int64@@ ) ; } return @@QWORD@@ ; }
void __fastcall free_dfa_content ( __int64 @@int64@@ ) { unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( * ( _QWORD * ) @@int64@@ ) { for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { free_token ( Number * @@unsignedint64@@ + * ( _QWORD * ) @@int64@@ ) ; } } free ( * ( void * * ) ( @@int64@@ + Number ) ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) free ( * ( void * * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@unsignedint64@@ + Number ) ) ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) free ( * ( void * * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@unsignedint64@@ + Number ) ) ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) free ( * ( void * * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@unsignedint64@@ + Number ) ) ; } free ( * ( void * * ) ( @@int64@@ + Number ) ) ; free ( * ( void * * ) ( @@int64@@ + Number ) ) ; free ( * ( void * * ) ( @@int64@@ + Number ) ) ; free ( * ( void * * ) @@int64@@ ) ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) { for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@unsignedint64@@ ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) @@int64@@ ; ++ @@unsignedint64@@ ) { free_state ( * ( void * * * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; } free ( * ( void * * ) ( @@int64@@ + Number ) ) ; } } free ( * ( void * * ) ( @@int64@@ + Number ) ) ; if ( * ( _UNKNOWN * * ) ( @@int64@@ + Number ) != & utf8_sb_map ) free ( * ( void * * ) ( @@int64@@ + Number ) ) ; free ( * ( void * * ) ( @@int64@@ + Number ) ) ; free ( ( void * ) @@int64@@ ) ; }
bool __fastcall seen_file ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 * @@int64@@ ) { __int64 @@int644@@ [ Number ] ; @@int644@@ [ Number ] = __readfsqword ( Number ) ; if ( ! @@int64@@ ) return Number ; @@int644@@ [ Number ] = @@int64@@ ; @@int644@@ [ Number ] = @@int64@@ [ Number ] ; @@int644@@ [ Number ] = * @@int64@@ ; return hash_lookup ( @@int64@@ , @@int644@@ ) != Number ; }
void * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * @@int64@@ ; void * @@void@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; void * @@void@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == ( __int64 * ) & slotvec0 ; if ( slotvec == ( __int64 * ) & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@void@@ = off_20D038 ; * @@int64@@ = ( __int64 ) slotvec0 ; @@int64@@ [ Number ] = ( __int64 ) @@void@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = @@int64@@ [ Number * @@int@@ ] ; @@void@@ = ( void * ) @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@void@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = @@unsignedint64@@ + Number ; if ( @@void@@ != & slot0 ) free ( @@void@@ ) ; @@void@@ = ( void * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = ( __int64 ) @@void@@ ; quotearg_buffer_restyled ( ( __int64 ) @@void@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@void@@ ; }
__int64 __fastcall create_tree ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , char @@char@@ ) { char @@char24@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@char24@@ [ Number ] = @@char@@ ; return create_token_tree ( @@int64@@ , @@int64@@ , @@int64@@ , @@char24@@ ) ; }
__int64 __fastcall re_string_realloc_buffers ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { void * @@void@@ ; void * @@void@@ ; void * @@void@@ ; if ( * ( int * ) ( @@int64@@ + Number ) > Number ) { if ( ! is_mul_ok ( Number , @@unsignedint64@@ ) ) return Number L ; @@void@@ = realloc ( * ( void * * ) ( @@int64@@ + Number ) , Number * @@unsignedint64@@ ) ; if ( ! @@void@@ ) return Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@void@@ ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) { @@void@@ = realloc ( * ( void * * ) ( @@int64@@ + Number ) , Number * @@unsignedint64@@ ) ; if ( ! @@void@@ ) return Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@void@@ ; } } if ( * ( _BYTE * ) ( @@int64@@ + Number ) ) { @@void@@ = realloc ( * ( void * * ) ( @@int64@@ + Number ) , @@unsignedint64@@ ) ; if ( ! @@void@@ ) return Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@void@@ ; } * ( _QWORD * ) ( @@int64@@ + Number ) = @@unsignedint64@@ ; return Number L ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall link_nfa_nodes ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; unsigned int @@unsignedint@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@unsignedint@@ = Number ; switch ( * ( _BYTE * ) ( @@int64@@ + Number ) ) { case Number : if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) __assert_fail ( String , String , Number , String ) ; return @@int64@@ ; case Number : * ( _QWORD * ) ( Number * @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) == Number ) re_node_set_init_1 ( ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ ) , * ( _QWORD * ) ( Number * @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; break ; case Number : case Number : case Number : @@unsignedint@@ = re_node_set_init_1 ( ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ ) , * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) ) ; break ; case Number : case Number : * ( _BYTE * ) ( @@int64@@ + Number ) |= Number ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) @@unsignedint64@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) + Number L ) ; else @@unsignedint64@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) @@unsignedint64@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) + Number L ) ; else @@unsignedint64@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) ; if ( @@unsignedint64@@ > Number ) __assert_fail ( String , String , Number , String ) ; if ( @@unsignedint64@@ > Number ) __assert_fail ( String , String , Number , String ) ; @@unsignedint@@ = re_node_set_init_2 ( ( _QWORD * ) ( Number * @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) , @@unsignedint64@@ , @@unsignedint64@@ ) ; break ; case Number : return @@unsignedint@@ ; default : if ( ( * ( _BYTE * ) ( @@int64@@ + Number ) & Number ) != Number ) __assert_fail ( String , String , Number , String ) ; * ( _QWORD * ) ( Number * @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) ; break ; } return @@unsignedint@@ ; }
__int64 __fastcall _xargmatch_internal ( __int64 @@int64@@ , const char * @@constchar@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ , void ( * @ @ VAR_947 @ @ void ( ) ( void ) @ @ argmatchexitfn ) ( void ) ) { __int64 @@int64@@ ; @@int64@@ = argmatch ( @@constchar@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; if ( @@int64@@ >= Number ) return @@int64@@ ; argmatch_invalid ( @@int64@@ , ( __int64 ) @@constchar@@ , @@int64@@ ) ; argmatch_valid ( @@int64@@ , @@int64@@ , @@sizet@@ ) ; @ @ VAR_947 @ @ void ( ) ( void ) @ @ argmatchexitfn ( ) ; return Number ; }
__int64 __fastcall re_node_set_alloc ( _QWORD * @@QWORD@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; * @@QWORD@@ = @@int64@@ ; @@QWORD@@ [ Number ] = Number L ; @@QWORD@@ [ Number ] = malloc ( Number * @@int64@@ ) ; if ( @@QWORD@@ [ Number ] ) @@int64@@ = Number L ; else @@int64@@ = Number L ; return @@int64@@ ; }
void * __fastcall find_backup_file_name ( const char * @@constchar@@ , int @@int@@ ) { int @@int@@ ; bool @@bool@@ ; void * @@void@@ ; size_t @@sizet@@ ; __int64 @@int64@@ ; size_t @@sizet@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = strlen ( @@constchar@@ ) ; @@bool@@ = Number ; @@sizet@@ = strlen ( simple_backup_suffix ) + Number ; @@sizet@@ = @@sizet@@ ; if ( @@sizet@@ <= Number ) @@sizet@@ = Number L ; @@unsignedint64@@ = @@int64@@ + @@sizet@@ + Number ; @@void@@ = ( void * ) xmalloc ( @@unsignedint64@@ ) ; memcpy ( @@void@@ , @@constchar@@ , @@int64@@ + Number ) ; if ( @@int@@ != Number ) { @@int@@ = numbered_backup ( ( __int64 * ) & @@void@@ , @@unsignedint64@@ , @@int64@@ ) ; switch ( @@int@@ ) { case Number : @@bool@@ = Number ; break ; case Number : return @@void@@ ; case Number : @@bool@@ = @@int@@ == Number ; break ; } } if ( @@bool@@ ) memcpy ( ( char * ) @@void@@ + @@int64@@ , simple_backup_suffix , @@sizet@@ ) ; check_extension ( ( const char * ) @@void@@ , @@int64@@ , Number ) ; return @@void@@ ; }
__int64 __fastcall build_collating_symbol ( __int64 @@int64@@ , __int64 a2 , __int64 a3 , const char * @@constchar@@ ) { if ( strlen ( @@constchar@@ ) != Number ) return Number L ; bitset_set ( @@int64@@ , * ( unsigned __int8 * ) @@constchar@@ ) ; return Number L ; }
__int64 __fastcall create_token_tree ( __int64 @@int64@@ , __int64 * @@int64@@ , __int64 * @@int64@@ , _QWORD * @@QWORD@@ ) { __int64 @@int64@@ ; int @@int@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; if ( * ( _DWORD * ) ( @@int64@@ + Number ) == Number ) { @@QWORD@@ = malloc ( Number ) ; if ( ! @@QWORD@@ ) return Number L ; * @@QWORD@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@QWORD@@ ; * ( _DWORD * ) ( @@int64@@ + Number ) = Number ; } @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) ; * ( _DWORD * ) ( @@int64@@ + Number ) = @@int@@ + Number ; @@int64@@ = @@int64@@ + ( ( __int64 ) @@int@@ << Number ) + Number ; * ( _QWORD * ) @@int64@@ = Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; @@int64@@ = @@QWORD@@ [ Number ] ; * ( _QWORD * ) ( @@int64@@ + Number ) = * @@QWORD@@ ; * ( _QWORD * ) ( @@int64@@ + ( ( __int64 ) @@int@@ << Number ) + Number ) = @@int64@@ ; * ( _BYTE * ) ( @@int64@@ + Number ) &= Number ; * ( _BYTE * ) ( @@int64@@ + Number ) &= Number ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number ; if ( @@int64@@ ) * @@int64@@ = @@int64@@ ; if ( @@int64@@ ) * @@int64@@ = @@int64@@ ; return @@int64@@ + ( ( __int64 ) @@int@@ << Number ) + Number ; }
__int64 __fastcall hash_get_n_buckets_used ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 __fastcall dir_name ( __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = mdir_name ( @@int64@@ ) ; if ( ! @@int64@@ ) xalloc_die ( ) ; return @@int64@@ ; }
__int64 __fastcall re_node_set_init_2 ( _QWORD * @@QWORD@@ , unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { * @@QWORD@@ = Number L ; @@QWORD@@ [ Number ] = malloc ( Number ) ; if ( ! @@QWORD@@ [ Number ] ) return Number L ; if ( @@unsignedint64@@ == @@unsignedint64@@ ) { @@QWORD@@ [ Number ] = Number L ; * ( _QWORD * ) @@QWORD@@ [ Number ] = @@unsignedint64@@ ; } else { @@QWORD@@ [ Number ] = Number L ; if ( @@unsignedint64@@ >= @@unsignedint64@@ ) { * ( _QWORD * ) @@QWORD@@ [ Number ] = @@unsignedint64@@ ; * ( _QWORD * ) ( @@QWORD@@ [ Number ] + Number L ) = @@unsignedint64@@ ; } else { * ( _QWORD * ) @@QWORD@@ [ Number ] = @@unsignedint64@@ ; * ( _QWORD * ) ( @@QWORD@@ [ Number ] + Number L ) = @@unsignedint64@@ ; } } return Number L ; }
__int64 __fastcall parse_bracket_element ( __int64 @@int64@@ , __int64 @@int64@@ , _BYTE * @@BYTE@@ , int @@int@@ , __int64 a5 , char @@char@@ , char @@char@@ ) { __int64 @@int64@@ ; int @@int@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int@@ = re_string_char_size_at ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( @@int@@ <= Number ) { * ( _QWORD * ) ( @@int64@@ + Number ) += @@int@@ ; if ( @@BYTE@@ [ Number ] == Number || @@BYTE@@ [ Number ] == Number || @@BYTE@@ [ Number ] == Number ) { @@int64@@ = parse_bracket_symbol ( @@int64@@ , @@int64@@ , @@BYTE@@ ) ; } else if ( @@BYTE@@ [ Number ] == Number && @@char@@ != Number && ( peek_token_bracket ( @@char@@ , @@int64@@ , @@char@@ ) , @@char@@ [ Number ] != Number ) ) { @@int64@@ = Number L ; } else { * ( _DWORD * ) @@int64@@ = Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = * @@BYTE@@ ; @@int64@@ = Number L ; } } else { * ( _DWORD * ) @@int64@@ = Number ; * ( _DWORD * ) ( @@int64@@ + Number ) = re_string_wchar_at ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ; * ( _QWORD * ) ( @@int64@@ + Number ) += @@int@@ ; @@int64@@ = Number L ; } return @@int64@@ ; }
unsigned __int64 __fastcall hash_get_max_bucket_length ( __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = Number L ; for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { @@QWORD@@ = @@QWORD@@ ; for ( @@unsignedint64@@ = Number L ; ; ++ @@unsignedint64@@ ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; if ( ! @@QWORD@@ ) break ; } if ( @@unsignedint64@@ > @@unsignedint64@@ ) @@unsignedint64@@ = @@unsignedint64@@ ; } } return @@unsignedint64@@ ; }
__int64 __fastcall push_fail_stack ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , const void * @@constvoid@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; void * @@void@@ ; @@int64@@ = ( * ( _QWORD * ) @@int64@@ ) ++ ; @@int64@@ = @@int64@@ ; if ( * ( _QWORD * ) @@int64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ) { @@void@@ = realloc ( * ( void * * ) ( @@int64@@ + Number ) , Number L * * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( ! @@void@@ ) return Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) *= Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@void@@ ; } * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ ) = @@int64@@ ; * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ + Number ) = @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = malloc ( Number * @@int64@@ ) ; if ( ! * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ + Number ) ) return Number L ; memcpy ( * ( void * * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ + Number ) , @@constvoid@@ , Number * @@int64@@ ) ; return ( unsigned int ) re_node_set_init_copy ( ( void * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ + Number ) , @@int64@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
unsigned __int64 __fastcall re_node_set_contains ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( ( unsigned __int64 ) ( * ( _QWORD * ) ( @@int64@@ + Number ) - Number L ) > Number ) return Number L ; @@unsignedint64@@ = Number L ; @@unsignedint64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) - Number L ; while ( @@unsignedint64@@ < @@unsignedint64@@ ) { if ( @@unsignedint64@@ <= * ( _QWORD * ) ( Number * ( ( @@unsignedint64@@ + @@unsignedint64@@ ) >> Number ) + * ( _QWORD * ) ( @@int64@@ + Number ) ) ) @@unsignedint64@@ = ( @@unsignedint64@@ + @@unsignedint64@@ ) >> Number ; else @@unsignedint64@@ = ( ( @@unsignedint64@@ + @@unsignedint64@@ ) >> Number ) + Number ; } if ( @@unsignedint64@@ == * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ) @@unsignedint64@@ = @@unsignedint64@@ + Number ; else @@unsignedint64@@ = Number L ; return @@unsignedint64@@ ; }
void __fastcall free_token ( __int64 @@int64@@ ) { if ( * ( _BYTE * ) ( @@int64@@ + Number ) != Number || ( * ( _BYTE * ) ( @@int64@@ + Number ) & Number ) != Number ) { if ( * ( _BYTE * ) ( @@int64@@ + Number ) == Number && ( * ( _BYTE * ) ( @@int64@@ + Number ) & Number ) == Number ) free ( * ( void * * ) @@int64@@ ) ; } else { free_charset ( * ( void * * * ) @@int64@@ ) ; } }
int __fastcall hash_print_statistics ( __int64 @@int64@@ , FILE * @@FILE@@ ) { double @@double@@ ; double @@double@@ ; double @@double@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int64@@ = hash_get_n_entries ( @@int64@@ ) ; @@int64@@ = hash_get_n_buckets ( @@int64@@ ) ; @@int64@@ = hash_get_n_buckets_used ( @@int64@@ ) ; @@unsignedint64@@ = hash_get_max_bucket_length ( @@int64@@ ) ; fprintf ( @@FILE@@ , String , @@int64@@ ) ; fprintf ( @@FILE@@ , String , @@int64@@ ) ; if ( @@int64@@ < Number ) @@double@@ = ( double ) ( int ) ( @@int64@@ & Number | ( ( unsigned __int64 ) @@int64@@ >> Number ) ) + ( double ) ( int ) ( @@int64@@ & Number | ( ( unsigned __int64 ) @@int64@@ >> Number ) ) ; else @@double@@ = ( double ) ( int ) @@int64@@ ; @@double@@ = Number * @@double@@ ; if ( @@int64@@ < Number ) @@double@@ = ( double ) ( int ) ( @@int64@@ & Number | ( ( unsigned __int64 ) @@int64@@ >> Number ) ) + ( double ) ( int ) ( @@int64@@ & Number | ( ( unsigned __int64 ) @@int64@@ >> Number ) ) ; else @@double@@ = ( double ) ( int ) @@int64@@ ; fprintf ( @@FILE@@ , String , @@int64@@ , @@double@@ / @@double@@ ) ; return fprintf ( @@FILE@@ , String , @@unsignedint64@@ ) ; }
__int64 __fastcall clean_state_log_if_needed ( _QWORD * @@QWORD@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned int @@unsignedint@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = @@QWORD@@ [ Number ] ; if ( @@unsignedint64@@ >= @@QWORD@@ [ Number ] || @@unsignedint64@@ >= @@QWORD@@ [ Number ] && @@QWORD@@ [ Number ] < @@QWORD@@ [ Number ] ) { @@unsignedint@@ = extend_buffers ( @@QWORD@@ ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; } if ( @@unsignedint64@@ < @@unsignedint64@@ ) { memset ( ( void * ) ( Number * ( @@unsignedint64@@ + Number ) + @@QWORD@@ [ Number ] ) , Number , Number * ( @@unsignedint64@@ - @@unsignedint64@@ ) ) ; @@QWORD@@ [ Number ] = @@unsignedint64@@ ; } return Number L ; }
__int64 __fastcall install_file_in_file ( char * @@char@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; __int64 @@int64@@ ; struct stat @@structstat@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) && ( unsigned int ) stat ( @@char@@ , & @@structstat@@ ) ) { @@int64@@ = quote ( @@char@@ ) ; @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ , @@int64@@ ) ; @@int64@@ = Number L ; } else if ( ( unsigned __int8 ) copy_file ( @@char@@ , @@int64@@ , @@int64@@ ) != Number ) { @@int64@@ = Number L ; } else { if ( strip_files ) strip ( @@int64@@ ) ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) && ( strip_files || ( @@structstat@@ . st_mode & Number ) != Number ) && ( unsigned __int8 ) change_timestamps ( & @@structstat@@ , @@int64@@ ) != Number ) { @@int64@@ = Number L ; } else { @@int64@@ = change_attributes ( @@int64@@ ) ; } } return @@int64@@ ; }
__int64 __fastcall rpl_re_match ( int @@int@@ , int @@int@@ , int @@int@@ , int @@int@@ , __int64 @@int64@@ ) { return re_search_stub ( @@int@@ , @@int@@ , @@int@@ , @@int@@ , Number , @@int@@ , @@int64@@ , Number ) ; }
char * __fastcall create_ci_newstate ( _QWORD * @@QWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { char * @@char@@ ; int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; char * @@char@@ ; __int64 @@int64@@ ; @@char@@ = ( char * ) calloc ( Number , Number ) ; if ( ! @@char@@ ) return Number L ; if ( ( unsigned int ) re_node_set_init_copy ( @@char@@ + Number , @@int64@@ ) ) { free ( @@char@@ ) ; @@char@@ = Number L ; } else { * ( ( _QWORD * ) @@char@@ + Number ) = @@char@@ + Number ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { @@int64@@ = * @@QWORD@@ + Number L * * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; @@int@@ = * ( unsigned __int8 * ) ( @@int64@@ + Number ) ; if ( @@int@@ != Number || ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number ) { @@char@@ [ Number ] = ( Number * ( ( * ( _BYTE * ) ( @@int64@@ + Number ) & Number ) != Number || ( @@char@@ [ Number ] & Number ) != Number ) ) | @@char@@ [ Number ] & Number ; if ( @@int@@ == Number ) { @@char@@ [ Number ] |= Number ; } else if ( @@int@@ == Number ) { @@char@@ [ Number ] |= Number ; } else if ( @@int@@ == Number || ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number ) { @@char@@ [ Number ] |= Number ; } } } if ( ( unsigned int ) register_state ( @@QWORD@@ , @@char@@ , @@int64@@ ) ) { free_state ( ( void * * ) @@char@@ ) ; @@char@@ = Number L ; } @@char@@ = @@char@@ ; } return @@char@@ ; }
unsigned __int64 __fastcall compute_bucket_size ( __int64 @@int64@@ , __int64 @@int64@@ ) { float @@float@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; float @@float@@ ; @@unsignedint64@@ = @@int64@@ ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) != Number ) { if ( @@int64@@ < Number ) @@float@@ = ( float ) ( @@int64@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@int64@@ >> Number ) ) + ( float ) ( @@int64@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@int64@@ >> Number ) ) ; else @@float@@ = ( float ) ( int ) @@int64@@ ; @@float@@ = @@float@@ / * ( float * ) ( @@int64@@ + Number ) ; if ( @@float@@ >= Number ) return Number L ; if ( @@float@@ >= Number ) @@unsignedint64@@ = ( unsigned int ) ( int ) ( float ) ( @@float@@ - Number ) ^ Number ; else @@unsignedint64@@ = ( unsigned int ) ( int ) @@float@@ ; } @@unsignedint64@@ = next_prime ( @@unsignedint64@@ ) ; if ( @@unsignedint64@@ <= Number ) @@unsignedint64@@ = @@unsignedint64@@ ; else @@unsignedint64@@ = Number L ; return @@unsignedint64@@ ; }
__int64 __fastcall optimize_subexps ( __int64 @@int64@@ , __int64 @@int64@@ ) { unsigned __int64 @@unsignedint64@@ ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) == Number && * ( _QWORD * ) ( @@int64@@ + Number ) ) { * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( Number L * ( int ) * ( _QWORD * ) ( @@int64@@ + Number ) + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; * ( _QWORD * ) ( @@int64@@ + Number ) |= Number << * ( _QWORD * ) ( @@int64@@ + Number ) ; } else if ( * ( _BYTE * ) ( @@int64@@ + Number ) == Number && * ( _QWORD * ) ( @@int64@@ + Number ) && * ( _BYTE * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) == Number ) { @@unsignedint64@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) * * ( _QWORD * * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@unsignedint64@@ ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L * * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= Number ) * ( _QWORD * ) ( @@int64@@ + Number ) &= ~ ( Number L << @@unsignedint64@@ ) ; } return Number L ; }
__int64 __fastcall copy_file ( char * @@char@@ , char * @@char@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; char @@char@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( copy_only_if_needed && ! need_copy ( @@char@@ , @@char@@ , @@int64@@ ) ) { @@int64@@ = Number L ; } else { @@int64@@ = copy ( @@char@@ , @@char@@ , Number L , @@int64@@ , & @@char@@ , Number L ) ; } return @@int64@@ ; }
__int64 __fastcall merge_state_array ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { _QWORD * @@QWORD@@ ; unsigned int @@unsignedint@@ ; unsigned __int64 @@unsignedint64@@ ; void * @@void6@@ [ Number ] ; @@void6@@ [ Number ] = ( void * ) __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@unsignedint64@@ ; ++ @@unsignedint64@@ ) { if ( * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@int64@@ ) ) { if ( * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@int64@@ ) ) { @@unsignedint@@ = re_node_set_init_union ( @@void6@@ , * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@int64@@ ) + Number L , * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@int64@@ ) + Number L ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; @@QWORD@@ = ( _QWORD * ) ( Number * @@unsignedint64@@ + @@int64@@ ) ; * @@QWORD@@ = re_acquire_state ( & @@unsignedint@@ , @@int64@@ , ( __int64 ) @@void6@@ ) ; free ( @@void6@@ [ Number ] ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; } } else { * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@int64@@ ) = * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@int64@@ ) ; } } return Number L ; }
__int64 __fastcall rpl_re_search ( int @@int@@ , int @@int@@ , int @@int@@ , int @@int@@ , int @@int@@ , __int64 @@int64@@ ) { return re_search_stub ( @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int64@@ , Number ) ; }
__int64 __fastcall hash_rehash ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; void * @@void@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@unsignedint64@@ = compute_bucket_size ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( ! @@unsignedint64@@ ) return Number L ; if ( @@unsignedint64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ) return Number L ; @@void@@ = calloc ( @@unsignedint64@@ , Number ) ; if ( ! @@void@@ ) return Number L ; @@unsignedint64@@ = @@unsignedint64@@ ; @@int64@@ = ( __int64 ) @@void@@ + Number * @@unsignedint64@@ ; @@int64@@ = Number L ; @@int64@@ = Number L ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( ( unsigned __int8 ) transfer_entries ( ( __int64 ) & @@void@@ , @@int64@@ , Number ) ) { free ( * ( void * * ) @@int64@@ ) ; * ( _QWORD * ) @@int64@@ = @@void@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@unsignedint64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; @@int64@@ = Number L ; } else { * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; if ( ( unsigned __int8 ) transfer_entries ( @@int64@@ , ( __int64 ) & @@void@@ , Number ) != Number || ( unsigned __int8 ) transfer_entries ( @@int64@@ , ( __int64 ) & @@void@@ , Number ) != Number ) { abort ( ) ; } free ( @@void@@ ) ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall make_ancestor ( __int64 @@int64@@ , const char * @@constchar@@ , __int64 @@int64@@ ) { unsigned int @@unsignedint@@ ; @@unsignedint@@ = mkdir ( @@constchar@@ , Number ) ; if ( ! @@unsignedint@@ ) announce_mkdir ( @@int64@@ , @@int64@@ ) ; return @@unsignedint@@ ; }
__int64 __fastcall calc_next ( __int64 a1 , __int64 @@int64@@ ) { int @@int@@ ; @@int@@ = * ( unsigned __int8 * ) ( @@int64@@ + Number ) ; if ( @@int@@ == Number ) { * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) = @@int64@@ ; } else if ( @@int@@ == Number ) { * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) ; * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; } else { if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; } return Number L ; }
__int64 __fastcall re_search_2_stub ( int @@int@@ , const void * @@constvoid@@ , size_t @@sizet@@ , const void * @@constvoid@@ , size_t @@sizet@@ , int @@int@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int64@@ ; char * @@char@@ ; size_t @@sizet@@ ; __int64 @@int64@@ ; @@sizet@@ = @@sizet@@ + @@sizet@@ ; @@char@@ = Number L ; if ( @@sizet@@ + @@sizet@@ < @@sizet@@ ) return Number ; if ( @@sizet@@ ) { if ( @@sizet@@ ) { @@char@@ = ( char * ) malloc ( @@sizet@@ ) ; if ( ! @@char@@ ) return Number ; memcpy ( @@char@@ , @@constvoid@@ , @@sizet@@ ) ; memcpy ( & @@char@@ [ @@sizet@@ ] , @@constvoid@@ , @@sizet@@ ) ; @@int64@@ = re_search_stub ( @@int@@ , ( _DWORD ) @@char@@ , @@sizet@@ , @@int@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@unsignedint8@@ ) ; } else { @@int64@@ = re_search_stub ( @@int@@ , ( _DWORD ) @@constvoid@@ , @@sizet@@ , @@int@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@unsignedint8@@ ) ; } } else { @@int64@@ = re_search_stub ( @@int@@ , ( _DWORD ) @@constvoid@@ , @@sizet@@ , @@int@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@unsignedint8@@ ) ; } @@int64@@ = @@int64@@ ; free ( @@char@@ ) ; return @@int64@@ ; }
void * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
__int64 __fastcall check_dst_limits_calc_pos_1 ( __int64 @@int64@@ , int @@int@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { int @@int@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; @@QWORD@@ = * ( _QWORD * * ) ( @@int64@@ + Number ) ; @@int64@@ = @@QWORD@@ [ Number ] + Number * @@int64@@ ; for ( @@unsignedint64@@ = Number L ; ; ++ @@unsignedint64@@ ) { if ( @@unsignedint64@@ >= * ( _QWORD * ) ( @@int64@@ + Number ) ) return ( @@int@@ >> Number ) & Number ; @@int64@@ = * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; @@int@@ = * ( unsigned __int8 * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) ; if ( @@int@@ == Number ) { if ( ( @@int@@ & Number ) != Number && @@unsignedint64@@ == * ( _QWORD * ) ( Number * @@int64@@ + * @@QWORD@@ ) ) { return Number ; } continue ; } if ( @@int@@ != Number ) break ; if ( ( @@int@@ & Number ) != Number && @@unsignedint64@@ == * ( _QWORD * ) ( Number * @@int64@@ + * @@QWORD@@ ) ) { return Number L ; } LABEL_29 : ; } if ( @@int@@ != Number || @@int64@@ == Number ) goto LABEL_29 ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ ; while ( Number ) { if ( @@int64@@ != * ( _QWORD * ) @@int64@@ || @@unsignedint64@@ <= Number && ( ( * ( unsigned __int16 * ) ( @@int64@@ + Number ) >> @@unsignedint64@@ ) & Number L ) == Number ) { goto LABEL_21 ; } @@int64@@ = * * ( _QWORD * * ) ( @@QWORD@@ [ Number ] + Number * @@int64@@ + Number ) ; if ( @@int64@@ == @@int64@@ ) break ; @@int@@ = check_dst_limits_calc_pos_1 ( @@int64@@ , @@int@@ , @@unsignedint64@@ , @@int64@@ , @@int64@@ ) ; if ( @@int@@ == Number ) return Number ; if ( ! @@int@@ && ( @@int@@ & Number ) != Number ) return Number L ; if ( @@unsignedint64@@ <= Number ) * ( _WORD * ) ( @@int64@@ + Number ) &= ~ ( unsigned __int16 ) ( Number L << @@unsignedint64@@ ) ; LABEL_21 : @@int64@@ = @@int64@@ ; @@int64@@ += Number L ; if ( ! * ( _BYTE * ) ( @@int64@@ + Number ) ) goto LABEL_29 ; } if ( ( @@int@@ & Number ) != Number ) @@int64@@ = Number ; else @@int64@@ = Number L ; return @@int64@@ ; }
_BOOL8 __fastcall dot_or_dotdot ( _BYTE * @@BYTE@@ ) { __int64 @@int64@@ ; char @@char@@ ; if ( * @@BYTE@@ != Number ) return Number L ; if ( @@BYTE@@ [ Number ] == Number ) @@int64@@ = Number L ; else @@int64@@ = Number L ; @@char@@ = @@BYTE@@ [ @@int64@@ ] ; return ! @@char@@ || @@char@@ == Number ; }
__int64 __fastcall calc_eclosure ( __int64 @@int64@@ ) { char @@char@@ ; unsigned int @@unsignedint@@ ; __int64 @@int64@@ ; char @@char@@ [ Number ] ; void * @@void@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@char@@ = Number ; for ( @@int64@@ = Number L ; ; ++ @@int64@@ ) { if ( @@int64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ) { if ( @@char@@ != Number ) return Number L ; @@char@@ = Number ; @@int64@@ = Number L ; } if ( ! * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ + Number ) ) break ; LABEL_11 : ; } @@unsignedint@@ = calc_eclosure_iter ( @@char@@ , @@int64@@ , @@int64@@ , Number L ) ; if ( ! @@unsignedint@@ ) { if ( ! * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ + Number ) ) { @@char@@ = Number ; free ( @@void@@ ) ; } goto LABEL_11 ; } return @@unsignedint@@ ; }
void * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall get_stat_atime_0 ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 __fastcall pop_fail_stack ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ , __int64 @@int64@@ , void * @@void@@ , __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = -- * @@QWORD@@ ; if ( * @@QWORD@@ > Number ) __assert_fail ( String , String , Number , String ) ; * @@QWORD@@ = * ( _QWORD * ) ( @@QWORD@@ [ Number ] + Number * @@int64@@ ) ; memcpy ( @@void@@ , * ( const void * * ) ( @@QWORD@@ [ Number ] + Number * @@int64@@ + Number ) , Number * @@int64@@ ) ; free ( * ( void * * ) ( @@int64@@ + Number ) ) ; free ( * ( void * * ) ( @@QWORD@@ [ Number ] + Number * @@int64@@ + Number ) ) ; @@QWORD@@ = ( _QWORD * ) ( @@QWORD@@ [ Number ] + Number * @@int64@@ ) ; @@int64@@ = @@QWORD@@ [ Number ] ; * ( _QWORD * ) @@int64@@ = @@QWORD@@ [ Number ] ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@QWORD@@ [ Number ] ; return * ( _QWORD * ) ( @@QWORD@@ [ Number ] + Number * @@int64@@ + Number ) ; }
__int64 __fastcall utimens_symlink ( __int64 @@int64@@ , __int64 @@int64@@ ) { unsigned int @@unsignedint@@ ; @@unsignedint@@ = lutimens ( @@int64@@ , @@int64@@ ) ; if ( @@unsignedint@@ && * __errno_location ( ) == Number ) @@unsignedint@@ = Number ; return @@unsignedint@@ ; }
void * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall find_subexp_node ( _QWORD * @@QWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ , int @@int@@ ) { unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { @@int64@@ = Number L * * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) + * @@QWORD@@ ; if ( @@int@@ == * ( unsigned __int8 * ) ( @@int64@@ + Number ) && @@int64@@ == * ( _QWORD * ) @@int64@@ ) { return * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; } } return Number ; }
__int64 __fastcall parse_reg_exp ( __int64 @@int64@@ , __int64 * @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , _DWORD * @@DWORD@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = * @@int64@@ ; @@int64@@ = parse_branch ( @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@DWORD@@ ) ; if ( * @@DWORD@@ && ! @@int64@@ ) return Number L ; while ( * ( _BYTE * ) ( @@int64@@ + Number ) == Number ) { fetch_token ( @@int64@@ , @@int64@@ , @@int64@@ | Number ) ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) == Number || * ( _BYTE * ) ( @@int64@@ + Number ) == Number || @@int64@@ && * ( _BYTE * ) ( @@int64@@ + Number ) == Number ) { @@int64@@ = Number L ; } else { @@int64@@ = parse_branch ( @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@DWORD@@ ) ; if ( * @@DWORD@@ && ! @@int64@@ ) return Number L ; } @@int64@@ = create_tree ( @@int64@@ , @@int64@@ , @@int64@@ , Number L ) ; if ( ! @@int64@@ ) { * @@DWORD@@ = Number ; return Number L ; } } return @@int64@@ ; }
void * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_20D108 ; @@int648@@ [ Number ] = qword_20D110 ; @@int648@@ [ Number ] = qword_20D118 ; @@int648@@ [ Number ] = qword_20D120 ; @@int648@@ [ Number ] = qword_20D128 ; @@int648@@ [ Number ] = qword_20D130 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
__int64 __fastcall sift_states_backward ( __int64 @@int64@@ , __int64 @@int64@@ ) { int @@int@@ ; unsigned int @@unsignedint@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; __int64 @@int64@@ ; void * @@void@@ [ Number ] ; void * @@void@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int@@ = Number ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@unsignedint@@ = re_node_set_init_1 ( @@void@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; @@unsignedint@@ = update_cur_sifted_state ( @@int64@@ , @@int64@@ , @@int64@@ , @@void@@ ) ; if ( ! @@unsignedint@@ ) { while ( @@int64@@ ) { if ( * ( _QWORD * ) ( Number * @@int64@@ + * ( _QWORD * ) @@int64@@ ) ) @@int@@ = Number ; else @@int@@ = @@int@@ + Number ; @@int@@ = @@int@@ ; if ( @@int@@ > * ( _DWORD * ) ( @@int64@@ + Number ) ) { memset ( * ( void * * ) @@int64@@ , Number , Number * @@int64@@ ) ; free ( @@void@@ ) ; return Number L ; } @@void@@ [ Number ] = Number L ; -- @@int64@@ ; if ( ! * ( _QWORD * ) ( Number * @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) || ( @@unsignedint@@ = build_sifted_states ( @@int64@@ , @@int64@@ , @@int64@@ , @@void@@ ) ) == Number ) { @@unsignedint@@ = update_cur_sifted_state ( @@int64@@ , @@int64@@ , @@int64@@ , @@void@@ ) ; if ( ! @@unsignedint@@ ) continue ; } goto LABEL_15 ; } @@unsignedint@@ = Number ; } LABEL_15 : free ( @@void@@ ) ; return @@unsignedint@@ ; }
__int64 __fastcall set_owner ( __int64 @@int64@@ , const char * @@constchar@@ , unsigned int @@unsignedint@@ , _DWORD * @@DWORD@@ , char @@char@@ , __int64 @@int64@@ ) { int @@int@@ ; unsigned __int16 @@unsignedint16@@ ; __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; __uid_t @@uidt@@ ; __gid_t @@gidt@@ ; int @@int@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; int @@int@@ ; @@uidt@@ = @@DWORD@@ [ Number ] ; @@gidt@@ = @@DWORD@@ [ Number ] ; if ( @@char@@ != Number && ( * ( _BYTE * ) ( @@int64@@ + Number ) || * ( _BYTE * ) ( @@int64@@ + Number ) || * ( _BYTE * ) ( @@int64@@ + Number ) ) && ( ( @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) , ! * ( _BYTE * ) ( @@int64@@ + Number ) ) && ! * ( _BYTE * ) ( @@int64@@ + Number ) ? ( @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) ) : ( @@int@@ = @@DWORD@@ [ Number ] ) , ( @@unsignedint@@ = ( unsigned __int16 ) @@int@@ & ( unsigned __int16 ) @@int@@ & Number , @@unsignedint16@@ = ~ ( _WORD ) @@int@@ , HIBYTE ( @@unsignedint16@@ ) |= Number , ( ( unsigned __int16 ) @@int@@ & @@unsignedint16@@ & Number ) != Number ) && ( unsigned int ) qset_acl ( @@constchar@@ , @@unsignedint@@ , @@unsignedint@@ ) ) ) { if ( ( unsigned __int8 ) owner_failure_ok ( @@int64@@ ) != Number ) { @@int64@@ = quote ( @@constchar@@ ) ; @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ , @@int64@@ ) ; } @@int64@@ = ( unsigned int ) - * ( unsigned __int8 * ) ( @@int64@@ + Number ) ; } else { if ( @@unsignedint@@ == Number ) { if ( ! lchown ( @@constchar@@ , @@uidt@@ , @@gidt@@ ) ) return Number L ; if ( * __errno_location ( ) == Number || * __errno_location ( ) == Number ) { @@int@@ = * __errno_location ( ) ; lchown ( @@constchar@@ , Number , @@gidt@@ ) ; ignore_value ( ) ; * __errno_location ( ) = @@int@@ ; } } else { if ( ! fchown ( @@unsignedint@@ , @@uidt@@ , @@gidt@@ ) ) return Number L ; if ( * __errno_location ( ) == Number || * __errno_location ( ) == Number ) { @@int@@ = * __errno_location ( ) ; fchown ( @@unsignedint@@ , Number , @@gidt@@ ) ; ignore_value ( ) ; * __errno_location ( ) = @@int@@ ; } } if ( ( unsigned __int8 ) chown_failure_ok ( @@int64@@ ) != Number && ( @@int64@@ = quote ( @@constchar@@ ) , @@char@@ = gettext ( String ) , @@int@@ = __errno_location ( ) , error ( Number , * @@int@@ , @@char@@ , @@int64@@ ) , * ( _BYTE * ) ( @@int64@@ + Number ) ) ) { @@int64@@ = Number ; } else { @@int64@@ = Number L ; } } return @@int64@@ ; }
_BOOL8 __fastcall check_node_accept ( __int64 @@int64@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { int @@int@@ ; _BOOL8 @@BOOL8@@ ; char @@char@@ ; char @@char@@ ; @@char@@ = * ( _BYTE * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + @@unsignedint64@@ ) ; @@int@@ = * ( unsigned __int8 * ) ( @@int64@@ + Number ) ; if ( @@int@@ == Number ) { if ( ! bitset_contain ( * ( _QWORD * ) @@int64@@ , ( unsigned __int8 ) @@char@@ ) ) return Number L ; } else if ( * ( unsigned __int8 * ) ( @@int64@@ + Number ) > Number ) { if ( @@int@@ != Number ) { if ( @@int@@ != Number ) return Number L ; if ( @@char@@ < Number ) return Number L ; } if ( @@char@@ == Number && ( * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) & Number ) == Number || ! @@char@@ && ( * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) & Number ) != Number ) { return Number L ; } } else { if ( @@int@@ != Number ) return Number L ; if ( @@char@@ != * ( _BYTE * ) @@int64@@ ) return Number L ; } @@BOOL8@@ = Number ; if ( ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number ) { if ( ( @@char@@ = re_string_context_at ( @@int64@@ , @@unsignedint64@@ , * ( _DWORD * ) ( @@int64@@ + Number ) ) , ( ( * ( _DWORD * ) ( @@int64@@ + Number ) >> Number ) & Number ) != Number ) && ( @@char@@ & Number ) == Number || ( ( * ( _DWORD * ) ( @@int64@@ + Number ) >> Number ) & Number ) != Number && ( @@char@@ & Number ) != Number || ( ( * ( _DWORD * ) ( @@int64@@ + Number ) >> Number ) & Number ) != Number && ( @@char@@ & Number ) == Number || ( ( * ( _DWORD * ) ( @@int64@@ + Number ) >> Number ) & Number ) != Number && ( @@char@@ & Number ) == Number ) { @@BOOL8@@ = Number ; } } return @@BOOL8@@ ; }
__int64 __fastcall parse_bracket_symbol ( __int64 @@int64@@ , _QWORD * @@QWORD@@ , char * @@char@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; int @@int@@ ; char @@char@@ ; char @@char@@ ; int @@int@@ ; @@char@@ = * @@char@@ ; @@int@@ = Number ; if ( @@QWORD@@ [ Number ] <= @@QWORD@@ [ Number ] ) return Number L ; while ( Number ) { if ( @@int@@ > Number ) return Number L ; if ( @@char@@ [ Number ] == Number ) { @@char@@ = re_string_fetch_byte_case ( ( __int64 ) @@QWORD@@ ) ; } else { @@int64@@ = @@QWORD@@ [ Number ] ; @@int64@@ = @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ + Number ; @@char@@ = * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) ; } if ( @@QWORD@@ [ Number ] <= @@QWORD@@ [ Number ] ) return Number L ; if ( @@char@@ == @@char@@ && * ( _BYTE * ) ( @@QWORD@@ [ Number ] + @@QWORD@@ [ Number ] ) == Number ) { break ; } * ( _BYTE * ) ( @@int@@ ++ + * ( _QWORD * ) ( @@int64@@ + Number ) ) = @@char@@ ; } ++ @@QWORD@@ [ Number ] ; * ( _BYTE * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + @@int@@ ) = Number ; @@int@@ = ( unsigned __int8 ) @@char@@ [ Number ] ; switch ( @@int@@ ) { case Number : * ( _DWORD * ) @@int64@@ = Number ; break ; case Number : * ( _DWORD * ) @@int64@@ = Number ; break ; case Number : * ( _DWORD * ) @@int64@@ = Number ; break ; } return Number L ; }
char * __fastcall areadlinkat ( int @@int@@ , const char * @@constchar@@ ) { signed __int64 @@signedint64@@ ; int @@int@@ ; char * @@char@@ ; __int64 @@int64@@ ; signed __int64 @@signedint64@@ ; size_t @@sizet@@ ; char * @@char@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@char@@ = @@char@@ ; @@int64@@ = Number L ; while ( Number ) { @@signedint64@@ = readlinkat ( @@int@@ , @@constchar@@ , @@char@@ , @@int64@@ ) ; if ( @@signedint64@@ < Number && * __errno_location ( ) != Number ) { if ( @@char@@ != @@char@@ ) { @@int@@ = * __errno_location ( ) ; free ( @@char@@ ) ; * __errno_location ( ) = @@int@@ ; } return Number L ; } if ( @@int64@@ > ( unsigned __int64 ) @@signedint64@@ ) break ; if ( @@char@@ != @@char@@ ) free ( @@char@@ ) ; @@int64@@ *= Number L ; if ( @@int64@@ < Number ) { * __errno_location ( ) = Number ; return Number L ; } @@char@@ = ( char * ) malloc ( @@int64@@ ) ; if ( ! @@char@@ ) return Number L ; } @@signedint64@@ = @@signedint64@@ ; @@sizet@@ = @@signedint64@@ + Number ; @@char@@ [ @@signedint64@@ ] = Number ; if ( @@char@@ == @@char@@ ) { @@char@@ = ( char * ) malloc ( @@sizet@@ ) ; if ( ! @@char@@ ) return Number L ; memcpy ( @@char@@ , @@char@@ , @@sizet@@ ) ; } else if ( @@int64@@ > @@sizet@@ ) { @@char@@ = ( char * ) realloc ( @@char@@ , @@sizet@@ ) ; if ( @@char@@ ) @@char@@ = @@char@@ ; } return @@char@@ ; }
__int64 __fastcall sub_epsilon_src_nodes ( _QWORD * @@QWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; unsigned int @@unsignedint@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; char @@char@@ [ Number ] ; void * @@void@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = @@QWORD@@ [ Number ] + Number * @@int64@@ ; memset ( @@char@@ , Number , Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { @@int64@@ = * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( @@int64@@ != @@int64@@ && ( * ( _BYTE * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) & Number ) != Number ) { @@unsignedint64@@ = * * ( _QWORD * * ) ( @@QWORD@@ [ Number ] + Number * @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@QWORD@@ [ Number ] + Number * @@int64@@ + Number ) <= Number ? Number : * ( _QWORD * ) ( * ( _QWORD * ) ( @@QWORD@@ [ Number ] + Number * @@int64@@ + Number ) + Number L ) ; if ( ( @@unsignedint64@@ = @@int64@@ , ! re_node_set_contains ( @@int64@@ , @@unsignedint64@@ ) ) && re_node_set_contains ( @@int64@@ , @@unsignedint64@@ ) || @@unsignedint64@@ - Number <= Number && ! re_node_set_contains ( @@int64@@ , @@unsignedint64@@ ) && re_node_set_contains ( @@int64@@ , @@unsignedint64@@ ) ) { @@unsignedint@@ = re_node_set_add_intersect ( ( __int64 ) @@char@@ , @@int64@@ , @@QWORD@@ [ Number ] + Number * @@int64@@ ) ; if ( @@unsignedint@@ ) { free ( @@void@@ ) ; return @@unsignedint@@ ; } } } } for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { @@unsignedint64@@ = * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( ! re_node_set_contains ( ( __int64 ) @@char@@ , @@unsignedint64@@ ) ) { @@unsignedint64@@ = re_node_set_contains ( @@int64@@ , @@unsignedint64@@ ) - Number ; re_node_set_remove_at ( @@int64@@ , @@unsignedint64@@ ) ; } } free ( @@void@@ ) ; return Number L ; }
unsigned __int64 __fastcall triple_hash_no_name ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) % @@unsignedint64@@ ; }
__int64 __fastcall match_ctx_add_subtop ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; void * * @@void@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; void * @@void@@ ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) == * ( _QWORD * ) ( @@int64@@ + Number ) ) { @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = Number * @@int64@@ ; @@void@@ = realloc ( * ( void * * ) ( @@int64@@ + Number ) , Number * @@int64@@ ) ; if ( ! @@void@@ ) return Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@void@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; } @@void@@ = ( void * * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L * * ( _QWORD * ) ( @@int64@@ + Number ) ) ; * @@void@@ = calloc ( Number , Number ) ; if ( ! * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L * * ( _QWORD * ) ( @@int64@@ + Number ) ) ) return Number L ; * ( _QWORD * ) ( * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L * * ( _QWORD * ) ( @@int64@@ + Number ) ) + Number L ) = @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ + Number ; * * ( _QWORD * * ) ( @@int64@@ + Number * @@int64@@ ) = @@int64@@ ; return Number L ; }
__int64 __fastcall mark_opt_subexp ( __int64 @@int64@@ , __int64 @@int64@@ ) { if ( * ( _BYTE * ) ( @@int64@@ + Number ) == Number && @@int64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ) { * ( _BYTE * ) ( @@int64@@ + Number ) |= Number ; } return Number L ; }
void * __fastcall mdir_name ( _BYTE * @@BYTE@@ ) { _BYTE * @@BYTE@@ ; void * @@void@@ ; @@BYTE@@ = dir_len ( @@BYTE@@ ) ; @@void@@ = malloc ( ( size_t ) & @@BYTE@@ [ ( @@BYTE@@ == Number L ) + Number ] ) ; if ( ! @@void@@ ) return Number L ; memcpy ( @@void@@ , @@BYTE@@ , ( size_t ) @@BYTE@@ ) ; if ( ! @@BYTE@@ ) { @@BYTE@@ = ( _BYTE * ) ( & dword_0 + Number ) ; * ( _BYTE * ) @@void@@ = Number ; } @@BYTE@@ [ ( _QWORD ) @@void@@ ] = Number ; return @@void@@ ; }
_BOOL8 __fastcall triple_compare_ino_str ( __int64 @@int64@@ , __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) == * ( _QWORD * ) ( @@int64@@ + Number ) && * ( _QWORD * ) ( @@int64@@ + Number ) == * ( _QWORD * ) ( @@int64@@ + Number ) && ! strcmp ( * ( const char * * ) @@int64@@ , * ( const char * * ) @@int64@@ ) ; }
__int64 __fastcall xget_version ( __int64 @@int64@@ , _BYTE * @@BYTE@@ ) { char * @@char@@ ; if ( @@BYTE@@ && * @@BYTE@@ ) return get_version ( @@int64@@ , @@BYTE@@ ) ; @@char@@ = getenv ( String ) ; return get_version ( ( __int64 ) String , @@char@@ ) ; }
__int64 __fastcall check_subexp_matching_top ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { unsigned int @@unsignedint@@ ; unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; @@QWORD@@ = * ( _QWORD * * ) ( @@int64@@ + Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { @@int64@@ = * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( * ( _BYTE * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) == Number && * ( _QWORD * ) ( Number * @@int64@@ + * @@QWORD@@ ) <= Number && ( ( @@QWORD@@ [ Number ] >> * ( _QWORD * ) ( Number * @@int64@@ + * @@QWORD@@ ) ) & Number L ) != Number ) { @@unsignedint@@ = match_ctx_add_subtop ( @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; } } return Number L ; }
__int64 __fastcall duplicate_tree ( __int64 * * @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 * @@int64@@ ; __int64 * @@int64@@ ; __int64 * @@int64@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = & @@int64@@ ; @@int64@@ = * @@int64@@ ; @@int64@@ = ( __int64 * ) @@int64@@ ; while ( Number ) { @@int64@@ = create_token_tree ( @@int64@@ , Number L , Number L , @@int64@@ + Number ) ; * @@int64@@ = @@int64@@ ; if ( ! * @@int64@@ ) break ; * ( _QWORD * ) * @@int64@@ = @@int64@@ ; * ( _BYTE * ) ( * @@int64@@ + Number ) |= Number ; @@int64@@ = ( __int64 * ) * @@int64@@ ; if ( @@int64@@ [ Number ] ) { @@int64@@ = ( __int64 * ) @@int64@@ [ Number ] ; @@int64@@ = @@int64@@ + Number ; } else { @@int64@@ = Number L ; while ( @@int64@@ == ( __int64 * ) @@int64@@ [ Number ] || ! @@int64@@ [ Number ] ) { @@int64@@ = @@int64@@ ; @@int64@@ = ( __int64 * ) * @@int64@@ ; @@int64@@ = ( __int64 * ) * @@int64@@ ; if ( ! @@int64@@ ) return @@int64@@ ; } @@int64@@ = ( __int64 * ) @@int64@@ [ Number ] ; @@int64@@ = @@int64@@ + Number ; } } return Number L ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) { ; } return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 close_stdin ( ) { const char * @@constchar@@ ; int * @@int@@ ; int * @@int@@ ; __int64 @@int64@@ ; char @@char@@ ; char * @@char@@ ; @@char@@ = Number ; if ( freadahead ( stdin ) && ! ( unsigned int ) rpl_fseeko ( stdin , Number L , Number L ) && ( unsigned int ) rpl_fflush ( stdin ) ) @@char@@ = Number ; if ( ( unsigned int ) close_stream ( stdin ) ) @@char@@ = Number ; if ( @@char@@ ) { @@char@@ = gettext ( String ) ; if ( file_name ) { @@constchar@@ = ( const char * ) quotearg_colon ( file_name ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , String , @@constchar@@ , @@char@@ ) ; } else { @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , String , @@char@@ ) ; } } @@int64@@ = close_stdout ( ) ; if ( @@char@@ ) _exit ( exit_failure ) ; return @@int64@@ ; }
unsigned __int64 __fastcall setdefaultfilecon ( char * @@char@@ ) { char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; char * @@char@@ ; _BYTE * @@BYTE@@ ; char * @@char@@ ; char * @@char@@ ; struct stat @@structstat@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@char@@ = Number L ; if ( selinux_enabled == Number && ! ( unsigned int ) lstat ( @@char@@ , & @@structstat@@ ) ) { if ( first_call_6195 ) { if ( * @@char@@ == Number ) { for ( @@BYTE@@ = @@char@@ + Number ; * @@BYTE@@ == Number ; ++ @@BYTE@@ ) { ; } @@char@@ = @@BYTE@@ - Number ; if ( * @@BYTE@@ ) { do ++ @@BYTE@@ ; while ( * @@BYTE@@ && * @@BYTE@@ != Number ) ; @@char@@ = ( char * ) malloc ( @@BYTE@@ - @@char@@ + Number ) ; if ( @@char@@ ) { * ( _WORD * ) stpncpy ( @@char@@ , @@char@@ , @@BYTE@@ - @@char@@ ) = Number ; free ( @@char@@ ) ; } } } } first_call_6195 = Number ; if ( ! ( unsigned int ) matchpathcon ( @@char@@ , @@structstat@@ . st_mode , & @@char@@ ) && strcmp ( @@char@@ , String ) ) { if ( ( int ) lsetfilecon ( @@char@@ , @@char@@ ) < Number && * __errno_location ( ) != Number ) { @@char@@ = @@char@@ ; @@int64@@ = quotearg_colon ( @@char@@ ) ; @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ , @@int64@@ , @@char@@ ) ; } goto LABEL_20 ; } if ( @@char@@ ) { LABEL_20 : freecon ( ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; } } return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall check_arrival_expand_ecl ( _QWORD * @@QWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; unsigned int @@unsignedint@@ ; unsigned int @@unsignedint@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ [ Number ] ; void * @@void@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@unsignedint@@ = re_node_set_alloc ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { @@int64@@ = * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; @@int64@@ = @@QWORD@@ [ Number ] + Number * @@int64@@ ; if ( find_subexp_node ( @@QWORD@@ , @@int64@@ , @@int64@@ , @@unsignedint@@ ) == Number ) { @@unsignedint@@ = re_node_set_merge ( ( __int64 ) @@int64@@ , @@int64@@ ) ; if ( @@unsignedint@@ ) goto LABEL_6 ; } else { @@unsignedint@@ = check_arrival_expand_ecl_sub ( @@QWORD@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@unsignedint@@ ) ; if ( @@unsignedint@@ ) { LABEL_6 : free ( @@void@@ ) ; return @@unsignedint@@ ; } } } free ( * ( void * * ) ( @@int64@@ + Number ) ) ; @@int64@@ = @@int64@@ [ Number ] ; * ( _QWORD * ) @@int64@@ = @@int64@@ [ Number ] ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@void@@ ; return Number L ; }
_BOOL8 __fastcall check_halt_node_context ( _QWORD * @@QWORD@@ , __int64 @@int64@@ , char @@char@@ ) { if ( * ( _BYTE * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) != Number ) return Number L ; if ( ( ( * ( _DWORD * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) >> Number ) & Number ) == Number ) return Number L ; return ( ( * ( _DWORD * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) & Number ) == Number || ( @@char@@ & Number ) != Number ) && ( ( * ( _DWORD * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) & Number ) == Number || ( @@char@@ & Number ) == Number ) && ( ( * ( _DWORD * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) & Number ) == Number || ( @@char@@ & Number ) != Number ) && ( ( * ( _DWORD * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) & Number ) == Number || ( @@char@@ & Number ) != Number ) ; }
unsigned __int64 __fastcall check_extension ( const char * @@constchar@@ , __int64 @@int64@@ , char @@char@@ ) { unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; char * @@char@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int16 @@int16@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@char@@ = ( char * ) last_component ( @@constchar@@ ) ; @@unsignedint64@@ = base_len ( @@char@@ ) ; @@unsignedint64@@ = Number L ; if ( @@unsignedint64@@ > Number ) { @@int16@@ = * ( _WORD * ) @@char@@ ; * ( _WORD * ) @@char@@ = Number ; * __errno_location ( ) = Number ; @@int64@@ = pathconf ( @@constchar@@ , Number ) ; if ( @@int64@@ >= Number || ! * __errno_location ( ) ) @@unsignedint64@@ = @@int64@@ ; * ( _WORD * ) @@char@@ = @@int16@@ ; } if ( @@unsignedint64@@ < @@unsignedint64@@ ) { @@unsignedint64@@ = & @@constchar@@ [ @@int64@@ ] - @@char@@ ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) @@unsignedint64@@ = @@unsignedint64@@ - Number ; @@char@@ [ @@unsignedint64@@ ] = @@char@@ ; @@char@@ [ @@unsignedint64@@ + Number ] = Number ; } return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall hash_lookup ( __int64 * @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; @@int64@@ = * @@int64@@ ; @@QWORD@@ = ( _QWORD * ) ( @@int64@@ + Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@int64@@ [ Number ] ) ( @@int64@@ , @@int64@@ [ Number ] ) ) ; if ( ( unsigned __int64 ) @@QWORD@@ >= @@int64@@ [ Number ] ) abort ( ) ; if ( ! * @@QWORD@@ ) return Number L ; for ( @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { if ( @@int64@@ == * @@QWORD@@ || ( ( unsigned __int8 ( __fastcall * ) ( __int64 , _QWORD ) ) @@int64@@ [ Number ] ) ( @@int64@@ , * @@QWORD@@ ) ) { return * @@QWORD@@ ; } } return Number L ; }
__int64 __fastcall change_attributes ( char * @@char@@ ) { __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; unsigned __int8 @@unsignedint8@@ ; @@unsignedint8@@ = Number ; if ( owner_id == Number && group_id == Number || ! lchown ( @@char@@ , owner_id , group_id ) ) { if ( chmod ( @@char@@ , mode ) ) { @@int64@@ = quote ( @@char@@ ) ; @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ , @@int64@@ ) ; } else { @@unsignedint8@@ = Number ; } } else { @@int64@@ = quote ( @@char@@ ) ; @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ , @@int64@@ ) ; } if ( use_default_selinux_context ) setdefaultfilecon ( @@char@@ ) ; return @@unsignedint8@@ ; }
__int64 __fastcall match_ctx_init ( __int64 @@int64@@ , int @@int@@ , unsigned __int64 @@unsignedint64@@ ) { * ( _DWORD * ) ( @@int64@@ + Number ) = @@int@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number ; if ( ! @@unsignedint64@@ ) goto LABEL_7 ; if ( ! is_mul_ok ( Number , @@unsignedint64@@ ) ) return Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = malloc ( Number * @@unsignedint64@@ ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = malloc ( Number * @@unsignedint64@@ ) ; if ( ! * ( _QWORD * ) ( @@int64@@ + Number ) || ! * ( _QWORD * ) ( @@int64@@ + Number ) ) return Number L ; LABEL_7 : * ( _QWORD * ) ( @@int64@@ + Number ) = @@unsignedint64@@ ; * ( _DWORD * ) ( @@int64@@ + Number ) = Number ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@unsignedint64@@ ; return Number L ; }
__int64 __fastcall build_sifted_states ( __int64 @@int64@@ , _QWORD * @@QWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@QWORD@@ = * ( _QWORD * * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( Number * @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) + Number L ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { @@unsignedint64@@ = * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; @@int@@ = Number ; if ( ( * ( _BYTE * ) ( Number * @@unsignedint64@@ + * @@QWORD@@ + Number ) & Number ) != Number ) @@int@@ = sift_states_iter_mb ( @@int64@@ , @@QWORD@@ , @@unsignedint64@@ , @@int64@@ , @@QWORD@@ [ Number ] ) ; if ( ! @@int@@ && ( unsigned __int8 ) check_node_accept ( @@int64@@ , * @@QWORD@@ + Number * @@unsignedint64@@ , @@int64@@ ) && * ( _QWORD * ) ( Number * ( @@int64@@ + Number ) + * @@QWORD@@ ) && re_node_set_contains ( * ( _QWORD * ) ( Number * ( @@int64@@ + Number ) + * @@QWORD@@ ) + Number L , * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@QWORD@@ [ Number ] ) ) ) { @@int@@ = Number ; } if ( @@int@@ && ( ! @@QWORD@@ [ Number ] || ! ( unsigned __int8 ) check_dst_limits ( @@int64@@ , @@QWORD@@ + Number , * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@QWORD@@ [ Number ] ) , @@int@@ + @@int64@@ , @@unsignedint64@@ , @@int64@@ ) ) && ! re_node_set_insert ( @@int64@@ , @@unsignedint64@@ ) ) { return Number L ; } } return Number L ; }
unsigned __int64 __fastcall hash_string ( _BYTE * @@BYTE@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = Number L ; while ( * @@BYTE@@ ) @@unsignedint64@@ = ( Number * @@unsignedint64@@ + ( unsigned __int8 ) * @@BYTE@@ ++ ) % @@unsignedint64@@ ; return @@unsignedint64@@ ; }
_BYTE * __fastcall dir_len ( _BYTE * @@BYTE@@ ) { _BYTE * @@BYTE@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = * @@BYTE@@ == Number ; for ( @@BYTE@@ = ( _BYTE * ) ( last_component ( @@BYTE@@ ) - @@BYTE@@ ) ; @@unsignedint64@@ < ( unsigned __int64 ) @@BYTE@@ && @@BYTE@@ [ ( _QWORD ) ( @@BYTE@@ - Number ) ] == Number ; -- @@BYTE@@ ) { ; } return @@BYTE@@ ; }
__int64 __fastcall get_stat_mtime_0 ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
void * __fastcall sift_ctx_init ( _QWORD * @@QWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { * @@QWORD@@ = @@int64@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; return memset ( @@QWORD@@ + Number , Number , Number ) ; }
__int64 __fastcall check_dst_limits ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; @@QWORD@@ = * ( _QWORD * * ) ( @@int64@@ + Number ) ; @@int64@@ = search_cur_bkref_entry ( @@int64@@ , @@int64@@ ) ; @@int64@@ = search_cur_bkref_entry ( @@int64@@ , @@int64@@ ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { @@int64@@ = * ( _QWORD * ) ( * @@QWORD@@ + Number L * * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L * * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ) ; @@int64@@ = ( int ) check_dst_limits_calc_pos ( @@int64@@ , * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) , @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( ( int ) check_dst_limits_calc_pos ( @@int64@@ , * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) , @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ ) != @@int64@@ ) return Number L ; } return Number L ; }
unsigned __int64 __fastcall raw_hasher ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { return rotr_sz ( @@int64@@ , Number ) % @@unsignedint64@@ ; }
int __fastcall clone_file ( int @@int@@ , unsigned int @@unsignedint@@ ) { return ioctl ( @@int@@ , Number , @@unsignedint@@ ) ; }
__int64 __fastcall ftypelet ( __int16 @@int16@@ ) { switch ( @@int16@@ & Number ) { case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; } return Number L ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
_BYTE * __fastcall longest_relative_suffix ( _BYTE * @@BYTE@@ ) { while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; return @@BYTE@@ ; }
__int64 __fastcall sift_states_iter_mb ( __int64 @@int64@@ , _QWORD * @@QWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { int @@int@@ ; __int64 @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int@@ = check_node_accept_bytes ( @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( @@int@@ > Number && @@unsignedint64@@ >= @@int@@ + @@int64@@ && ( ! * ( _QWORD * ) ( Number * ( @@int@@ + @@int64@@ ) + * @@QWORD@@ ) || ! re_node_set_contains ( * ( _QWORD * ) ( Number * ( @@int@@ + @@int64@@ ) + * @@QWORD@@ ) + Number L , * ( _QWORD * ) ( Number * @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ) ) { @@int@@ = Number ; } return ( unsigned int ) @@int@@ ; }
__int64 __fastcall check_tuning ( __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( ( _UNKNOWN * ) @@int64@@ == & default_tuning ) return Number L ; if ( * ( float * ) ( @@int64@@ + Number ) > Number && ( float ) ( Number - Number ) > * ( float * ) ( @@int64@@ + Number ) && * ( float * ) ( @@int64@@ + Number ) > ( float ) ( Number + Number ) && * ( float * ) @@int64@@ >= Number && * ( float * ) ( @@int64@@ + Number ) > ( float ) ( * ( float * ) @@int64@@ + Number ) && * ( float * ) ( @@int64@@ + Number ) <= Number && * ( float * ) ( @@int64@@ + Number ) > ( float ) ( * ( float * ) @@int64@@ + Number ) ) { return Number L ; } * ( _QWORD * ) ( @@int64@@ + Number ) = & default_tuning ; return Number L ; }
__int64 __fastcall hash_get_n_buckets ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
_BOOL8 __fastcall copy_dir ( __int64 @@int64@@ , __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ , _QWORD * @@QWORD@@ , int @@int@@ , __int64 @@int64@@ , __int64 @@int64@@ , bool * @@bool@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; _BOOL8 @@BOOL8@@ ; unsigned __int8 @@unsignedint8@@ ; size_t @@sizet@@ ; char @@char@@ ; bool @@bool@@ ; char * @@char@@ ; void * @@void@@ ; void * @@void@@ ; void * @@void@@ ; __int64 @@int6412@@ [ Number ] ; @@int6412@@ [ Number ] = __readfsqword ( Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int6412@@ [ Number ] = * ( _QWORD * ) @@int64@@ ; @@int6412@@ [ Number ] = @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int6412@@ [ Number ] = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int6412@@ [ Number ] = @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int6412@@ [ Number ] = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int6412@@ [ Number ] = @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int6412@@ [ Number ] = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int6412@@ [ Number ] = @@int64@@ ; @@int6412@@ [ Number ] = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@bool@@ = Number ; @@void@@ = ( void * ) savedir ( @@int64@@ ) ; if ( @@void@@ ) { if ( * ( _DWORD * ) ( @@int64@@ + Number ) == Number ) HIDWORD ( @@int6412@@ [ Number ] ) = Number ; for ( @@char@@ = ( char * ) @@void@@ ; * @@char@@ ; @@char@@ += @@sizet@@ + Number ) { @@void@@ = ( void * ) file_name_concat ( @@int64@@ , @@char@@ , Number L ) ; @@void@@ = ( void * ) file_name_concat ( @@int64@@ , @@char@@ , Number L ) ; @@unsignedint8@@ = copy_internal ( ( _DWORD ) @@void@@ , ( _DWORD ) @@void@@ , @@unsignedint8@@ , * @@QWORD@@ , @@int@@ , ( unsigned int ) @@int6412@@ , Number , @@int64@@ , ( __int64 ) & @@char@@ , Number L ) ; @@bool@@ = ( @@bool@@ & @@unsignedint8@@ ) != Number ; * @@bool@@ = ( unsigned __int8 ) ( * @@bool@@ | @@char@@ ) != Number ; free ( @@void@@ ) ; free ( @@void@@ ) ; if ( @@char@@ ) break ; @@sizet@@ = strlen ( @@char@@ ) ; } free ( @@void@@ ) ; @@BOOL8@@ = @@bool@@ ; } else { @@int64@@ = quote ( @@int64@@ ) ; @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ , @@int64@@ ) ; @@BOOL8@@ = Number L ; } return @@BOOL8@@ ; }
__int64 __fastcall find_recover_state ( _DWORD * @@DWORD@@ , _QWORD * @@QWORD@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; do { @@unsignedint64@@ = @@QWORD@@ [ Number ] ; @@int64@@ = @@QWORD@@ [ Number ] ; do { if ( ++ @@int64@@ > @@unsignedint64@@ ) return Number L ; ++ @@QWORD@@ [ Number ] ; } while ( ! * ( _QWORD * ) ( Number * @@int64@@ + @@QWORD@@ [ Number ] ) ) ; @@int64@@ = merge_state_with_log ( @@DWORD@@ , ( __int64 ) @@QWORD@@ , Number L ) ; } while ( ! * @@DWORD@@ && ! @@int64@@ ) ; return @@int64@@ ; }
__int64 __fastcall hash_get_n_entries ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 __fastcall clear_ungetc_buffer_preserving_position ( _DWORD * @@DWORD@@ ) { __int64 @@int64@@ ; @@int64@@ = * @@DWORD@@ & Number ; if ( ( _DWORD ) @@int64@@ ) @@int64@@ = rpl_fseeko ( @@DWORD@@ , Number L , Number L ) ; return @@int64@@ ; }
__int64 __fastcall hash_find_entry ( __int64 @@int64@@ , __int64 @@int64@@ , _QWORD * @@QWORD@@ , char @@char@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; @@int64@@ = * ( _QWORD * ) @@int64@@ ; @@QWORD@@ = ( _QWORD * ) ( @@int64@@ + Number * ( * ( __int64 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@int64@@ + Number ) ) ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@QWORD@@ >= * ( _QWORD * ) ( @@int64@@ + Number ) ) abort ( ) ; * @@QWORD@@ = @@QWORD@@ ; if ( ! * @@QWORD@@ ) return Number L ; if ( @@int64@@ == * @@QWORD@@ || ( * ( unsigned __int8 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@int64@@ + Number ) ) ( @@int64@@ , * @@QWORD@@ ) ) { @@int64@@ = * @@QWORD@@ ; if ( @@char@@ ) { if ( @@QWORD@@ [ Number ] ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; @@int64@@ = @@QWORD@@ [ Number ] ; * @@QWORD@@ = * @@QWORD@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; free_entry ( @@int64@@ , @@QWORD@@ ) ; } else { * @@QWORD@@ = Number L ; } } @@int64@@ = @@int64@@ ; } else { for ( @@QWORD@@ = @@QWORD@@ ; ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { if ( ! @@QWORD@@ [ Number ] ) return Number L ; if ( @@int64@@ == * ( _QWORD * ) @@QWORD@@ [ Number ] || ( * ( unsigned __int8 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@int64@@ + Number ) ) ( @@int64@@ , * ( _QWORD * ) @@QWORD@@ [ Number ] ) ) { break ; } } @@int64@@ = * ( _QWORD * ) @@QWORD@@ [ Number ] ; if ( @@char@@ ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = @@QWORD@@ [ Number ] ; free_entry ( @@int64@@ , @@QWORD@@ ) ; } @@int64@@ = @@int64@@ ; } return @@int64@@ ; }
_BYTE * __fastcall longest_relative_suffix ( _BYTE * @@BYTE@@ ) { while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; return @@BYTE@@ ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
__int64 __fastcall get_subexp_sub ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; unsigned int @@unsignedint@@ ; unsigned int @@unsignedint@@ ; @@unsignedint@@ = check_arrival ( ( _DWORD ) @@QWORD@@ , ( int ) @@QWORD@@ + Number , * @@QWORD@@ , @@QWORD@@ [ Number ] , @@int64@@ , @@int64@@ , Number ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; @@unsignedint@@ = match_ctx_add_entry ( @@QWORD@@ , @@int64@@ , @@int64@@ , * @@QWORD@@ , @@QWORD@@ [ Number ] ) ; if ( @@unsignedint@@ ) @@int64@@ = @@unsignedint@@ ; else @@int64@@ = clean_state_log_if_needed ( @@QWORD@@ , @@int64@@ + @@QWORD@@ [ Number ] - * @@QWORD@@ ) ; return @@int64@@ ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
int __fastcall hash_print_statistics ( __int64 @@int64@@ , FILE * @@FILE@@ ) { double @@double@@ ; double @@double@@ ; double @@double@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int64@@ = hash_get_n_entries ( @@int64@@ ) ; @@int64@@ = hash_get_n_buckets ( @@int64@@ ) ; @@int64@@ = hash_get_n_buckets_used ( @@int64@@ ) ; @@unsignedint64@@ = hash_get_max_bucket_length ( @@int64@@ ) ; fprintf ( @@FILE@@ , String , @@int64@@ ) ; fprintf ( @@FILE@@ , String , @@int64@@ ) ; if ( @@int64@@ < Number ) @@double@@ = ( double ) ( int ) ( @@int64@@ & Number | ( ( unsigned __int64 ) @@int64@@ >> Number ) ) + ( double ) ( int ) ( @@int64@@ & Number | ( ( unsigned __int64 ) @@int64@@ >> Number ) ) ; else @@double@@ = ( double ) ( int ) @@int64@@ ; @@double@@ = Number * @@double@@ ; if ( @@int64@@ < Number ) @@double@@ = ( double ) ( int ) ( @@int64@@ & Number | ( ( unsigned __int64 ) @@int64@@ >> Number ) ) + ( double ) ( int ) ( @@int64@@ & Number | ( ( unsigned __int64 ) @@int64@@ >> Number ) ) ; else @@double@@ = ( double ) ( int ) @@int64@@ ; fprintf ( @@FILE@@ , String , @@int64@@ , @@double@@ / @@double@@ ) ; return fprintf ( @@FILE@@ , String , @@unsignedint64@@ ) ; }
__int64 __fastcall hash_get_n_buckets ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
void __fastcall record_file ( __int64 @@int64@@ , __int64 @@int64@@ , _QWORD * @@QWORD@@ ) { _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) { @@QWORD@@ = ( _QWORD * ) xmalloc ( Number L ) ; * @@QWORD@@ = xstrdup ( @@int64@@ ) ; @@QWORD@@ [ Number ] = @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = * @@QWORD@@ ; @@int64@@ = hash_insert ( @@int64@@ , @@QWORD@@ ) ; if ( ! @@int64@@ ) xalloc_die ( ) ; if ( ( _QWORD * ) @@int64@@ != @@QWORD@@ ) triple_free ( @@QWORD@@ ) ; } }
__int64 __fastcall hash_get_n_entries ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 __fastcall check_arrival_expand_ecl_sub ( _QWORD * @@QWORD@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , unsigned int @@unsignedint@@ ) { unsigned __int64 @@unsignedint64@@ ; unsigned int @@unsignedint@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint64@@ ; for ( @@unsignedint64@@ = re_node_set_contains ( @@int64@@ , @@unsignedint64@@ ) ; ! @@unsignedint64@@ ; @@unsignedint64@@ = re_node_set_contains ( @@int64@@ , @@unsignedint64@@ ) ) { if ( @@unsignedint@@ == * ( unsigned __int8 * ) ( Number * @@unsignedint64@@ + * @@QWORD@@ + Number ) && @@int64@@ == * ( _QWORD * ) ( Number * @@unsignedint64@@ + * @@QWORD@@ ) ) { if ( @@unsignedint@@ == Number && ! re_node_set_insert ( @@int64@@ , @@unsignedint64@@ ) ) { return Number L ; } return Number L ; } if ( ! re_node_set_insert ( @@int64@@ , @@unsignedint64@@ ) ) return Number L ; if ( ! * ( _QWORD * ) ( @@QWORD@@ [ Number ] + Number * @@unsignedint64@@ + Number ) ) return Number L ; if ( * ( _QWORD * ) ( @@QWORD@@ [ Number ] + Number * @@unsignedint64@@ + Number ) == Number L ) { @@unsignedint@@ = check_arrival_expand_ecl_sub ( @@QWORD@@ , @@int64@@ , * ( _QWORD * ) ( * ( _QWORD * ) ( @@QWORD@@ [ Number ] + Number * @@unsignedint64@@ + Number ) + Number L ) , @@int64@@ , @@unsignedint@@ ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; } @@unsignedint64@@ = * * ( _QWORD * * ) ( @@QWORD@@ [ Number ] + Number * @@unsignedint64@@ + Number ) ; } return Number L ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
bool __fastcall is_prime ( unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = Number L ; @@unsignedint64@@ = Number L ; while ( @@unsignedint64@@ < @@unsignedint64@@ && @@unsignedint64@@ % @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@unsignedint64@@ += Number * @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint64@@ + Number ; } return @@unsignedint64@@ % @@unsignedint64@@ != Number ; }
__int64 __fastcall full_read ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = Number L ; while ( @@int64@@ ) { @@int64@@ = safe_read ( @@unsignedint@@ , @@int64@@ , @@int64@@ ) ; if ( @@int64@@ == Number ) break ; if ( ! @@int64@@ ) { * __errno_location ( ) = Number ; return @@int64@@ ; } @@int64@@ += @@int64@@ ; @@int64@@ += @@int64@@ ; @@int64@@ -= @@int64@@ ; } return @@int64@@ ; }
_BOOL8 __fastcall hash_table_ok ( __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; @@int64@@ = Number L ; @@int64@@ = Number L ; for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { @@QWORD@@ = @@QWORD@@ ; ++ @@int64@@ ; ++ @@int64@@ ; while ( Number ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; if ( ! @@QWORD@@ ) break ; ++ @@int64@@ ; } } } return @@int64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) && @@int64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
_QWORD * __fastcall match_ctx_clean ( _QWORD * @@QWORD@@ ) { _QWORD * @@QWORD@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; void * @@void@@ ; void * * @@void@@ ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@QWORD@@ [ Number ] ; ++ @@unsignedint64@@ ) { @@void@@ = * ( void * * ) ( Number * @@unsignedint64@@ + @@QWORD@@ [ Number ] ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( ( _QWORD * ) @@void@@ + Number ) ; ++ @@unsignedint64@@ ) { @@void@@ = * ( void * * * ) ( Number * @@unsignedint64@@ + * ( ( _QWORD * ) @@void@@ + Number ) ) ; free ( @@void@@ [ Number ] ) ; free ( @@void@@ ) ; } free ( * ( ( void * * ) @@void@@ + Number ) ) ; if ( * ( ( _QWORD * ) @@void@@ + Number ) ) { free ( * ( void * * ) ( * ( ( _QWORD * ) @@void@@ + Number ) + Number L ) ) ; free ( * ( ( void * * ) @@void@@ + Number ) ) ; } free ( @@void@@ ) ; } @@QWORD@@ [ Number ] = Number L ; @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ [ Number ] = Number L ; return @@QWORD@@ ; }
bool __fastcall is_prime ( unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = Number L ; @@unsignedint64@@ = Number L ; while ( @@unsignedint64@@ < @@unsignedint64@@ && @@unsignedint64@@ % @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@unsignedint64@@ += Number * @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint64@@ + Number ; } return @@unsignedint64@@ % @@unsignedint64@@ != Number ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ ) { return xmalloc ( @@int64@@ ) ; }
__int64 __fastcall savewd_restore ( _DWORD * @@DWORD@@ , int @@int@@ ) { __int64 @@int64@@ ; int @@int@@ ; __pid_t @@pidt@@ ; int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; switch ( * @@DWORD@@ ) { case Number : case Number : goto LABEL_17 ; case Number : if ( fchdir ( @@DWORD@@ [ Number ] ) ) { @@int@@ = * __errno_location ( ) ; close ( @@DWORD@@ [ Number ] ) ; * @@DWORD@@ = Number ; @@DWORD@@ [ Number ] = @@int@@ ; LABEL_5 : * __errno_location ( ) = @@DWORD@@ [ Number ] ; @@int64@@ = Number ; } else { * @@DWORD@@ = Number ; LABEL_17 : @@int64@@ = Number L ; } break ; case Number : @@pidt@@ = @@DWORD@@ [ Number ] ; if ( ! @@pidt@@ ) _exit ( @@int@@ ) ; if ( @@pidt@@ <= Number ) goto LABEL_17 ; while ( waitpid ( @@pidt@@ , & @@int@@ , Number ) < Number ) { if ( * __errno_location ( ) != Number ) __assert_fail ( String , String , Number , String ) ; } @@DWORD@@ [ Number ] = Number ; if ( ( @@int@@ & Number ) != Number ) raise ( @@int@@ & Number ) ; @@int64@@ = BYTE1 ( @@int@@ ) ; break ; case Number : goto LABEL_5 ; default : __assert_fail ( String , String , Number , String ) ; } return @@int64@@ ; }
void __fastcall hash_free ( __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) && * ( _QWORD * ) ( @@int64@@ + Number ) ) { for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { for ( @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@int64@@ + Number ) ) ( * @@QWORD@@ ) ; } } } } for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { for ( @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; @@QWORD@@ ; @@QWORD@@ = @@QWORD@@ ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; free ( @@QWORD@@ ) ; } } for ( @@QWORD@@ = * ( _QWORD * * ) ( @@int64@@ + Number ) ; @@QWORD@@ ; @@QWORD@@ = @@QWORD@@ ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; free ( @@QWORD@@ ) ; } free ( * ( void * * ) @@int64@@ ) ; free ( ( void * ) @@int64@@ ) ; }
void __fastcall hash_free ( __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) && * ( _QWORD * ) ( @@int64@@ + Number ) ) { for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { for ( @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@int64@@ + Number ) ) ( * @@QWORD@@ ) ; } } } } for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { for ( @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; @@QWORD@@ ; @@QWORD@@ = @@QWORD@@ ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; free ( @@QWORD@@ ) ; } } for ( @@QWORD@@ = * ( _QWORD * * ) ( @@int64@@ + Number ) ; @@QWORD@@ ; @@QWORD@@ = @@QWORD@@ ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; free ( @@QWORD@@ ) ; } free ( * ( void * * ) @@int64@@ ) ; free ( ( void * ) @@int64@@ ) ; }
void __fastcall record_file ( __int64 @@int64@@ , __int64 @@int64@@ , _QWORD * @@QWORD@@ ) { _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) { @@QWORD@@ = ( _QWORD * ) xmalloc ( Number L ) ; * @@QWORD@@ = xstrdup ( @@int64@@ ) ; @@QWORD@@ [ Number ] = @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = * @@QWORD@@ ; @@int64@@ = hash_insert ( @@int64@@ , @@QWORD@@ ) ; if ( ! @@int64@@ ) xalloc_die ( ) ; if ( ( _QWORD * ) @@int64@@ != @@QWORD@@ ) triple_free ( @@QWORD@@ ) ; } }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 __fastcall get_version ( __int64 @@int64@@ , _BYTE * @@BYTE@@ ) { __int64 @@int64@@ ; if ( @@BYTE@@ && * @@BYTE@@ ) @@int64@@ = backup_types [ _xargmatch_internal ( @@int64@@ , @@BYTE@@ , backup_args , backup_types , Number L , argmatch_die ) ] ; else @@int64@@ = Number L ; return @@int64@@ ; }
__int64 __fastcall linkat_follow ( unsigned int @@unsignedint@@ , void * @@void@@ , int @@int@@ , const char * @@constchar@@ ) { __int64 @@int64@@ ; int @@int@@ ; int @@int@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; void * @@void@@ ; _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; @@void@@ = @@void@@ ; @@int@@ = Number ; while ( @@int@@ -- ) { @@BYTE@@ = ( _BYTE * ) areadlinkat ( @@unsignedint@@ , @@void@@ ) ; if ( ! @@BYTE@@ ) break ; if ( * @@BYTE@@ == Number ) { if ( @@void@@ != @@void@@ ) free ( @@void@@ ) ; @@void@@ = @@BYTE@@ ; } else { @@BYTE@@ = ( _BYTE * ) mdir_name ( @@void@@ ) ; if ( @@void@@ != @@void@@ ) free ( @@void@@ ) ; if ( ! @@BYTE@@ ) { free ( @@BYTE@@ ) ; * __errno_location ( ) = Number ; return Number ; } @@void@@ = mfile_name_concat ( @@BYTE@@ , @@BYTE@@ , Number L ) ; free ( @@BYTE@@ ) ; free ( @@BYTE@@ ) ; if ( ! @@void@@ ) { * __errno_location ( ) = Number ; return Number ; } } } if ( @@int@@ < Number ) { @@BYTE@@ = Number L ; * __errno_location ( ) = Number ; } if ( @@BYTE@@ || * __errno_location ( ) == Number ) { @@unsignedint@@ = linkat ( @@unsignedint@@ , ( const char * ) @@void@@ , @@int@@ , @@constchar@@ , Number ) ; if ( @@void@@ != @@void@@ ) { @@int@@ = * __errno_location ( ) ; free ( @@void@@ ) ; * __errno_location ( ) = @@int@@ ; } @@int64@@ = @@unsignedint@@ ; } else { if ( @@void@@ != @@void@@ ) { @@int@@ = * __errno_location ( ) ; free ( @@void@@ ) ; * __errno_location ( ) = @@int@@ ; } @@int64@@ = Number ; } return @@int64@@ ; }
unsigned __int64 __fastcall triple_hash ( _QWORD * @@QWORD@@ , unsigned __int64 @@unsignedint64@@ ) { return ( ( unsigned __int64 ) hash_pjw ( * @@QWORD@@ , @@unsignedint64@@ ) ^ @@QWORD@@ [ Number ] ) % @@unsignedint64@@ ; }
int __fastcall rpl_linkat ( unsigned int @@unsignedint@@ , char * @@char@@ , int @@int@@ , const char * @@constchar@@ , int @@int@@ ) { int @@int@@ ; int @@int@@ ; if ( ! @@int@@ ) return linkat ( @@unsignedint@@ , @@char@@ , @@int@@ , @@constchar@@ , Number ) ; @@int@@ = @@int@@ ; BYTE1 ( @@int@@ ) = BYTE1 ( @@int@@ ) & Number ; if ( @@int@@ ) { * __errno_location ( ) = Number ; return Number ; } if ( have_follow_really_4385 >= Number ) { @@int@@ = linkat ( @@unsignedint@@ , @@char@@ , @@int@@ , @@constchar@@ , @@int@@ ) ; if ( @@int@@ != Number || * __errno_location ( ) != Number ) { have_follow_really_4385 = Number ; return @@int@@ ; } have_follow_really_4385 = Number ; } return linkat_follow ( @@unsignedint@@ , @@char@@ , @@int@@ , @@constchar@@ ) ; }
__int64 __fastcall xnrealloc ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { if ( ! is_mul_ok ( @@unsignedint64@@ , @@unsignedint64@@ ) ) xalloc_die ( ) ; return xrealloc ( @@int64@@ , @@unsignedint64@@ * @@unsignedint64@@ ) ; }
_BOOL8 __fastcall triple_compare_ino_str ( __int64 @@int64@@ , __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) == * ( _QWORD * ) ( @@int64@@ + Number ) && * ( _QWORD * ) ( @@int64@@ + Number ) == * ( _QWORD * ) ( @@int64@@ + Number ) && ! strcmp ( * ( const char * * ) @@int64@@ , * ( const char * * ) @@int64@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
__int64 __fastcall savewd_errno ( _DWORD * @@DWORD@@ ) { __int64 @@int64@@ ; if ( * @@DWORD@@ == Number ) @@int64@@ = ( unsigned int ) @@DWORD@@ [ Number ] ; else @@int64@@ = Number L ; return @@int64@@ ; }
__int64 __fastcall get_version ( __int64 @@int64@@ , _BYTE * @@BYTE@@ ) { __int64 @@int64@@ ; if ( @@BYTE@@ && * @@BYTE@@ ) @@int64@@ = backup_types [ _xargmatch_internal ( @@int64@@ , @@BYTE@@ , backup_args , backup_types , Number L , argmatch_die ) ] ; else @@int64@@ = Number L ; return @@int64@@ ; }
__int64 __fastcall x2nrealloc ( __int64 @@int64@@ , unsigned __int64 * @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = * @@unsignedint64@@ ; if ( @@int64@@ ) { if ( @@unsignedint64@@ >= Number / @@unsignedint64@@ ) xalloc_die ( ) ; @@unsignedint64@@ += ( @@unsignedint64@@ + Number ) >> Number ; } else if ( ! @@unsignedint64@@ ) { @@unsignedint64@@ = ( Number / @@unsignedint64@@ == Number ) + Number / @@unsignedint64@@ ; } * @@unsignedint64@@ = @@unsignedint64@@ ; return xrealloc ( @@int64@@ , @@unsignedint64@@ * @@unsignedint64@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
_BYTE * __fastcall strmode ( __int16 @@int16@@ , _BYTE * @@BYTE@@ ) { char @@char@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; _BYTE * @@BYTE@@ ; * @@BYTE@@ = ftypelet ( @@int16@@ ) ; if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) { if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; } else if ( ( @@int16@@ & Number ) != Number ) { @@char@@ = Number ; } else { @@char@@ = Number ; } @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) { if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; } else if ( ( @@int16@@ & Number ) != Number ) { @@char@@ = Number ; } else { @@char@@ = Number ; } @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) { if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; } else if ( ( @@int16@@ & Number ) != Number ) { @@char@@ = Number ; } else { @@char@@ = Number ; } @@BYTE@@ [ Number ] = @@char@@ ; @@BYTE@@ [ Number ] = Number ; @@BYTE@@ = @@BYTE@@ + Number ; @@BYTE@@ [ Number ] = Number ; return @@BYTE@@ ; }
__int64 __fastcall make_node_op_equals ( int @@int@@ , int @@int@@ ) { __int64 @@int64@@ ; @@int64@@ = xmalloc ( Number L ) ; * ( _BYTE * ) @@int64@@ = Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = Number ; * ( _DWORD * ) ( @@int64@@ + Number ) = Number ; * ( _DWORD * ) ( @@int64@@ + Number ) = @@int@@ ; * ( _DWORD * ) ( @@int64@@ + Number ) = @@int@@ ; * ( _BYTE * ) ( @@int64@@ + Number ) = Number ; return @@int64@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
unsigned __int64 __fastcall hash_pjw ( _BYTE * @@BYTE@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = Number L ; while ( * @@BYTE@@ ) @@unsignedint64@@ = __ROL8__ ( @@unsignedint64@@ , Number ) + ( char ) * @@BYTE@@ ++ ; return @@unsignedint64@@ % @@unsignedint64@@ ; }
void * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
void * __fastcall allocate_entry ( __int64 @@int64@@ ) { __int64 @@int64@@ ; if ( ! * ( _QWORD * ) ( @@int64@@ + Number ) ) return malloc ( Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; return ( void * ) @@int64@@ ; }
__int64 __fastcall file_name_concat ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = mfile_name_concat ( @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( ! @@int64@@ ) xalloc_die ( ) ; return @@int64@@ ; }
__int64 __fastcall mode_create_from_ref ( char * @@char@@ ) { __int64 @@int64@@ ; struct stat @@structstat@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( ( unsigned int ) stat ( @@char@@ , & @@structstat@@ ) ) @@int64@@ = Number L ; else @@int64@@ = make_node_op_equals ( @@structstat@@ . st_mode , Number ) ; return @@int64@@ ; }
void * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
void __fastcall argmatch_invalid ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { char * @@char@@ ; __int64 @@int64@@ ; void * @@void@@ ; char * @@char@@ ; if ( @@int64@@ == Number ) @@char@@ = gettext ( String ) ; else @@char@@ = gettext ( String ) ; @@char@@ = @@char@@ ; @@int64@@ = quote_n ( Number , @@int64@@ ) ; @@void@@ = quotearg_n_style ( Number , Number , @@int64@@ ) ; error ( Number , Number , @@char@@ , @@void@@ , @@int64@@ ) ; }
__int64 __fastcall free_entry ( __int64 @@int64@@ , _QWORD * @@QWORD@@ ) { __int64 @@int64@@ ; * @@QWORD@@ = Number L ; @@QWORD@@ [ Number ] = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@QWORD@@ ; return @@int64@@ ; }
void * __fastcall mfile_name_concat ( _BYTE * @@BYTE@@ , _BYTE * @@BYTE@@ , _QWORD * @@QWORD@@ ) { _BOOL4 @@BOOL4@@ ; const char * @@constchar@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; _BOOL8 @@BOOL8@@ ; char * @@char@@ ; size_t @@sizet@@ ; void * @@void@@ ; _BYTE * @@BYTE@@ ; char * @@char@@ ; @@constchar@@ = last_component ( @@BYTE@@ ) ; @@sizet@@ = base_len ( @@constchar@@ ) ; @@sizet@@ = @@constchar@@ - @@BYTE@@ + @@sizet@@ ; @@BOOL4@@ = @@sizet@@ && @@constchar@@ [ @@sizet@@ - Number ] != Number ; @@BOOL8@@ = @@BOOL4@@ ; @@char@@ = longest_relative_suffix ( @@BYTE@@ ) ; @@sizet@@ = strlen ( @@char@@ ) ; @@void@@ = malloc ( @@BOOL8@@ + @@sizet@@ + @@sizet@@ + Number ) ; if ( ! @@void@@ ) return Number L ; @@BYTE@@ = mempcpy ( @@void@@ , @@BYTE@@ , @@sizet@@ ) ; * @@BYTE@@ = Number ; @@char@@ = & @@BYTE@@ [ @@BOOL8@@ ] ; if ( @@QWORD@@ ) * @@QWORD@@ = & @@char@@ [ - ( * @@BYTE@@ == Number ) ] ; * ( _BYTE * ) mempcpy ( @@char@@ , @@char@@ , @@sizet@@ ) = Number ; return @@void@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall open_safer ( const char * @@constchar@@ , char @@char@@ , unsigned int @@unsignedint@@ ) { unsigned int @@unsignedint@@ ; unsigned int @@unsignedint@@ ; @@unsignedint@@ = Number ; if ( ( @@char@@ & Number ) != Number ) @@unsignedint@@ = @@unsignedint@@ ; @@unsignedint@@ = open ( @@constchar@@ , @@char@@ , @@unsignedint@@ ) ; return fd_safer ( @@unsignedint@@ ) ; }
__int64 __fastcall argmatch_to_argument ( const void * @@constvoid@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; ++ @@int64@@ ) { if ( ! memcmp ( @@constvoid@@ , ( const void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) , @@sizet@@ ) ) return * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; } return Number L ; }
__int64 __fastcall transfer_entries ( __int64 @@int64@@ , __int64 @@int64@@ , char @@char@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 * @@int64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; for ( @@int64@@ = * ( __int64 * * ) @@int64@@ ; ( unsigned __int64 ) @@int64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ += Number ) { if ( * @@int64@@ ) { for ( @@QWORD@@ = ( _QWORD * ) @@int64@@ [ Number ] ; @@QWORD@@ ; @@QWORD@@ = @@QWORD@@ ) { @@int64@@ = * @@QWORD@@ ; @@int64@@ = * ( _QWORD * ) @@int64@@ ; @@QWORD@@ = ( _QWORD * ) ( @@int64@@ + Number * ( * ( __int64 ( __fastcall * * ) ( _QWORD , _QWORD ) ) ( @@int64@@ + Number ) ) ( * @@QWORD@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@QWORD@@ >= * ( _QWORD * ) ( @@int64@@ + Number ) ) abort ( ) ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; if ( * @@QWORD@@ ) { @@QWORD@@ [ Number ] = @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = @@QWORD@@ ; } else { * @@QWORD@@ = @@int64@@ ; ++ * ( _QWORD * ) ( @@int64@@ + Number ) ; free_entry ( @@int64@@ , @@QWORD@@ ) ; } } @@int64@@ = * @@int64@@ ; @@int64@@ [ Number ] = Number L ; if ( ! @@char@@ ) { @@int64@@ = * ( _QWORD * ) @@int64@@ ; @@QWORD@@ = ( _QWORD * ) ( @@int64@@ + Number * ( * ( __int64 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@int64@@ + Number ) ) ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@QWORD@@ >= * ( _QWORD * ) ( @@int64@@ + Number ) ) abort ( ) ; if ( * @@QWORD@@ ) { @@QWORD@@ = allocate_entry ( @@int64@@ ) ; if ( ! @@QWORD@@ ) return Number L ; * @@QWORD@@ = @@int64@@ ; @@QWORD@@ [ Number ] = @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = @@QWORD@@ ; } else { * @@QWORD@@ = @@int64@@ ; ++ * ( _QWORD * ) ( @@int64@@ + Number ) ; } * @@int64@@ = Number L ; -- * ( _QWORD * ) ( @@int64@@ + Number ) ; } } } return Number L ; }
unsigned __int64 __fastcall hash_get_entries ( __int64 @@int64@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; @@unsignedint64@@ = Number L ; for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { for ( @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { if ( @@unsignedint64@@ >= @@unsignedint64@@ ) return @@unsignedint64@@ ; @@int64@@ = @@unsignedint64@@ ++ ; * ( _QWORD * ) ( @@int64@@ + Number * @@int64@@ ) = * @@QWORD@@ ; } } } return @@unsignedint64@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
_BYTE * __fastcall dir_len ( _BYTE * @@BYTE@@ ) { _BYTE * @@BYTE@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = * @@BYTE@@ == Number ; for ( @@BYTE@@ = ( _BYTE * ) ( last_component ( @@BYTE@@ ) - @@BYTE@@ ) ; @@unsignedint64@@ < ( unsigned __int64 ) @@BYTE@@ && @@BYTE@@ [ ( _QWORD ) ( @@BYTE@@ - Number ) ] == Number ; -- @@BYTE@@ ) { ; } return @@BYTE@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
_BOOL8 __fastcall same_name ( _BYTE * @@BYTE@@ , _BYTE * @@BYTE@@ ) { bool @@bool@@ ; int * @@int@@ ; int * @@int@@ ; bool @@bool@@ ; bool @@bool@@ ; const char * @@constchar@@ ; const char * @@constchar@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; char * @@char@@ ; char * @@char@@ ; struct stat @@structstat@@ ; struct stat @@structstat@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@constchar@@ = last_component ( @@BYTE@@ ) ; @@constchar@@ = last_component ( @@BYTE@@ ) ; @@sizet@@ = base_len ( @@constchar@@ ) ; @@sizet@@ = base_len ( @@constchar@@ ) ; @@bool@@ = @@sizet@@ == @@sizet@@ && ! memcmp ( @@constchar@@ , @@constchar@@ , @@sizet@@ ) ; @@bool@@ = Number ; if ( @@bool@@ ) { @@char@@ = ( char * ) dir_name ( @@BYTE@@ ) ; @@char@@ = ( char * ) dir_name ( @@BYTE@@ ) ; if ( ( unsigned int ) stat ( @@char@@ , & @@structstat@@ ) ) { @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , String , @@char@@ ) ; } if ( ( unsigned int ) stat ( @@char@@ , & @@structstat@@ ) ) { @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , String , @@char@@ ) ; } @@bool@@ = @@structstat@@ . st_ino == @@structstat@@ . st_ino && @@structstat@@ . st_dev == @@structstat@@ . st_dev ; @@bool@@ = @@bool@@ ; free ( @@char@@ ) ; free ( @@char@@ ) ; } return @@bool@@ ; }
bool __fastcall extra_mode ( int @@int@@ ) { return ( @@int@@ & Number ) != Number ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
__int64 __fastcall next_prime ( unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = @@unsignedint64@@ ; if ( @@unsignedint64@@ <= Number ) @@int64@@ = Number L ; for ( @@int64@@ = @@int64@@ | Number ; @@int64@@ != Number && ! is_prime ( @@int64@@ ) ; @@int64@@ += Number L ) { ; } return @@int64@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
int __fastcall argmatch_valid ( __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { char * @@char@@ ; __int64 @@int64@@ ; void * @@void@@ ; @@void@@ = Number L ; @@char@@ = gettext ( String ) ; fprintf ( stderr , @@char@@ ) ; for ( @@int64@@ = Number L ; * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; ++ @@int64@@ ) { if ( @@int64@@ && ! memcmp ( @@void@@ , ( const void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) , @@sizet@@ ) ) { fprintf ( stderr , String , * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) ) ; } else { fprintf ( stderr , String , * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) ) ; @@void@@ = ( void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) ; } } return putc_unlocked ( Number , stderr ) ; }
void * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
_BOOL8 __fastcall need_copy ( char * @@char@@ , char * @@char@@ , __int64 @@int64@@ ) { _BOOL8 @@BOOL8@@ ; __uid_t @@uidt@@ ; __uid_t @@uidt@@ ; __gid_t @@gidt@@ ; __gid_t @@gidt@@ ; bool @@bool@@ ; char @@char@@ ; int @@int@@ ; int @@int@@ ; char * @@char@@ ; char * @@char@@ ; struct stat @@structstat@@ ; struct stat @@structstat@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( extra_mode ( mode ) ) return Number L ; if ( ( unsigned int ) lstat ( @@char@@ , & @@structstat@@ ) ) return Number L ; if ( ( unsigned int ) lstat ( @@char@@ , & @@structstat@@ ) ) return Number L ; if ( ( @@structstat@@ . st_mode & Number ) != Number || ( @@structstat@@ . st_mode & Number ) != Number || extra_mode ( @@structstat@@ . st_mode ) || extra_mode ( @@structstat@@ . st_mode ) ) { return Number L ; } if ( @@structstat@@ . st_size != @@structstat@@ . st_size || ( @@structstat@@ . st_mode & Number ) != mode ) { return Number L ; } @@uidt@@ = @@structstat@@ . st_uid ; @@uidt@@ = owner_id == Number ? getuid ( ) : owner_id ; if ( @@uidt@@ != @@uidt@@ ) return Number L ; @@gidt@@ = @@structstat@@ . st_gid ; @@gidt@@ = group_id == Number ? getgid ( ) : group_id ; if ( @@gidt@@ != @@gidt@@ ) return Number L ; if ( ! selinux_enabled || ! * ( _BYTE * ) ( @@int64@@ + Number ) ) goto LABEL_31 ; @@char@@ = Number L ; @@char@@ = Number L ; if ( ( unsigned int ) getfilecon ( @@char@@ , & @@char@@ ) == Number ) return Number L ; if ( ( unsigned int ) getfilecon ( @@char@@ , & @@char@@ ) == Number ) { freecon ( ) ; return Number L ; } @@bool@@ = strcmp ( @@char@@ , @@char@@ ) == Number ; freecon ( ) ; freecon ( ) ; if ( ! @@bool@@ ) return Number L ; LABEL_31 : @@int@@ = open ( @@char@@ , Number ) ; if ( @@int@@ < Number ) return Number L ; @@int@@ = open ( @@char@@ , Number ) ; if ( @@int@@ >= Number ) { @@char@@ = have_same_content ( @@int@@ , @@int@@ ) ; close ( @@int@@ ) ; close ( @@int@@ ) ; @@BOOL8@@ = @@char@@ == Number ; } else { close ( @@int@@ ) ; @@BOOL8@@ = Number L ; } return @@BOOL8@@ ; }
size_t * __fastcall hash_initialize ( __int64 @@int64@@ , void * @@void@@ , unsigned __int64 ( __fastcall * @ @ VAR_551 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ) ( __int64 a1 , unsigned __int64 a2 ) , bool ( __fastcall * @ @ VAR_553 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ) ( __int64 a1 , __int64 a2 ) , size_t @@sizet@@ ) { size_t * @@sizet@@ ; bool ( __fastcall * @ @ VAR_552 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ) ( __int64 , __int64 ) ; unsigned __int64 ( __fastcall * @ @ VAR_550 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ) ( __int64 , unsigned __int64 ) ; void * @@void@@ ; size_t * @@sizet@@ ; @@void@@ = @@void@@ ; @ @ VAR_550 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher = @ @ VAR_551 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ; @ @ VAR_552 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator = @ @ VAR_553 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ; if ( ! @ @ VAR_551 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ) @ @ VAR_550 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher = raw_hasher ; if ( ! @ @ VAR_553 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ) @ @ VAR_552 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator = raw_comparator ; @@sizet@@ = ( size_t * ) malloc ( Number ) ; if ( ! @@sizet@@ ) return Number L ; if ( ! @@void@@ ) @@void@@ = & default_tuning ; @@sizet@@ [ Number ] = ( size_t ) @@void@@ ; if ( ( unsigned __int8 ) check_tuning ( ( __int64 ) @@sizet@@ ) == Number && ( @@sizet@@ [ Number ] = compute_bucket_size ( @@int64@@ , ( __int64 ) @@void@@ ) ) != Number && ( * @@sizet@@ = ( size_t ) calloc ( @@sizet@@ [ Number ] , Number ) ) != Number ) { @@sizet@@ [ Number ] = Number * @@sizet@@ [ Number ] + * @@sizet@@ ; @@sizet@@ [ Number ] = Number L ; @@sizet@@ [ Number ] = Number L ; @@sizet@@ [ Number ] = ( size_t ) @ @ VAR_550 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ; @@sizet@@ [ Number ] = ( size_t ) @ @ VAR_552 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ; @@sizet@@ [ Number ] = @@sizet@@ ; @@sizet@@ [ Number ] = Number L ; @@sizet@@ = @@sizet@@ ; } else { free ( @@sizet@@ ) ; @@sizet@@ = Number L ; } return @@sizet@@ ; }
void * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * @@int64@@ ; void * @@void@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; void * @@void@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == ( __int64 * ) & slotvec0 ; if ( slotvec == ( __int64 * ) & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@void@@ = off_220058 ; * @@int64@@ = ( __int64 ) slotvec0 ; @@int64@@ [ Number ] = ( __int64 ) @@void@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = @@int64@@ [ Number * @@int@@ ] ; @@void@@ = ( void * ) @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@void@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = @@unsignedint64@@ + Number ; if ( @@void@@ != & slot0 ) free ( @@void@@ ) ; @@void@@ = ( void * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = ( __int64 ) @@void@@ ; quotearg_buffer_restyled ( ( __int64 ) @@void@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@void@@ ; }
__int64 __fastcall get_stat_atime ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
void * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
unsigned __int64 __fastcall gcd ( unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; do { @@unsignedint64@@ = @@unsignedint64@@ % @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint64@@ ; } while ( @@unsignedint64@@ ) ; return @@unsignedint64@@ ; }
int __fastcall rpl_linkat ( unsigned int @@unsignedint@@ , char * @@char@@ , int @@int@@ , const char * @@constchar@@ , int @@int@@ ) { int @@int@@ ; int @@int@@ ; if ( ! @@int@@ ) return linkat ( @@unsignedint@@ , @@char@@ , @@int@@ , @@constchar@@ , Number ) ; @@int@@ = @@int@@ ; BYTE1 ( @@int@@ ) = BYTE1 ( @@int@@ ) & Number ; if ( @@int@@ ) { * __errno_location ( ) = Number ; return Number ; } if ( have_follow_really_4385 >= Number ) { @@int@@ = linkat ( @@unsignedint@@ , @@char@@ , @@int@@ , @@constchar@@ , @@int@@ ) ; if ( @@int@@ != Number || * __errno_location ( ) != Number ) { have_follow_really_4385 = Number ; return @@int@@ ; } have_follow_really_4385 = Number ; } return linkat_follow ( @@unsignedint@@ , @@char@@ , @@int@@ , @@constchar@@ ) ; }
__int64 __fastcall get_stat_mtime ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
unsigned __int64 __fastcall lcm ( unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { return @@unsignedint64@@ * ( @@unsignedint64@@ / gcd ( @@unsignedint64@@ , @@unsignedint64@@ ) ) ; }
__int64 __fastcall xnrealloc ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { if ( ! is_mul_ok ( @@unsignedint64@@ , @@unsignedint64@@ ) ) xalloc_die ( ) ; return xrealloc ( @@int64@@ , @@unsignedint64@@ * @@unsignedint64@@ ) ; }
void * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ ) { return xmalloc ( @@int64@@ ) ; }
void * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall io_blksize ( __int64 a1 , __int64 a2 , __int64 a3 , __int64 a4 , __int64 a5 , __int64 a6 , int a7 , int a8 , int a9 , int a10 , int a11 , int a12 , int a13 , __int64 @@int64@@ ) { __int64 @@int64@@ ; if ( @@int64@@ <= Number || ( unsigned __int64 ) @@int64@@ > Number || @@int64@@ <= Number ) { @@int64@@ = Number ; } else { @@int64@@ = @@int64@@ ; } return @@int64@@ ; }
__int64 __fastcall have_same_content ( unsigned int @@unsignedint@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; while ( Number ) { @@int64@@ = full_read ( @@unsignedint@@ , & a_buff_6164 , Number L ) ; if ( ! @@int64@@ ) break ; if ( @@int64@@ != full_read ( @@unsignedint@@ , & b_buff_6165 , Number L ) ) return Number L ; if ( memcmp ( & a_buff_6164 , & b_buff_6165 , @@int64@@ ) ) return Number L ; } return Number L ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
void * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
void * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
void * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
__int64 __fastcall is_ancestor ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ ) { while ( @@QWORD@@ ) { if ( @@QWORD@@ [ Number ] == @@QWORD@@ [ Number ] && @@QWORD@@ [ Number ] == * @@QWORD@@ ) { return Number L ; } @@QWORD@@ = ( _QWORD * ) * @@QWORD@@ ; } return Number L ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@unsignedint64@@ , int @@int@@ ) { __int64 @@int64@@ ; if ( is_mul_ok ( @@int@@ , * @@unsignedint64@@ ) ) { * @@unsignedint64@@ *= @@int@@ ; @@int64@@ = Number L ; } else { * @@unsignedint64@@ = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall process_dir ( int @@int@@ , int @@int@@ , int @@int@@ ) { return ( unsigned __int8 ) make_dir_parents ( @@int@@ , @@int@@ , ( unsigned int ) make_ancestor , @@int@@ , dir_mode , ( unsigned int ) announce_mkdir , dir_mode_bits , owner_id , group_id , Number ) ^ Number ; }
void * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
void * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
unsigned __int64 __fastcall hash_pjw ( _BYTE * @@BYTE@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = Number L ; while ( * @@BYTE@@ ) @@unsignedint64@@ = __ROL8__ ( @@unsignedint64@@ , Number ) + ( char ) * @@BYTE@@ ++ ; return @@unsignedint64@@ % @@unsignedint64@@ ; }
void * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
unsigned __int64 __fastcall overwrite_prompt ( const char * @@constchar@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; char @@char@@ ; _BYTE @@BYTE11@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( ! writable_destination ( @@constchar@@ , * ( _DWORD * ) ( @@int64@@ + Number ) ) ) { strmode ( * ( unsigned int * ) ( @@int64@@ + Number ) , & @@char@@ ) ; @@BYTE11@@ [ Number ] = Number ; @@int64@@ = * ( _DWORD * ) ( @@int64@@ + Number ) & Number ; @@int64@@ = quote ( @@constchar@@ ) ; @@char@@ = program_name ; @@char@@ = gettext ( String ) ; fprintf ( stderr , @@char@@ , @@char@@ , @@int64@@ , @@int64@@ , @@BYTE11@@ ) ; } else { @@int64@@ = quote ( @@constchar@@ ) ; @@char@@ = program_name ; @@char@@ = gettext ( String ) ; fprintf ( stderr , @@char@@ , @@char@@ , @@int64@@ ) ; } return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
void * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
void __fastcall argmatch_invalid ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { char * @@char@@ ; __int64 @@int64@@ ; void * @@void@@ ; char * @@char@@ ; if ( @@int64@@ == Number ) @@char@@ = gettext ( String ) ; else @@char@@ = gettext ( String ) ; @@char@@ = @@char@@ ; @@int64@@ = quote_n ( Number , @@int64@@ ) ; @@void@@ = quotearg_n_style ( Number , Number , @@int64@@ ) ; error ( Number , Number , @@char@@ , @@void@@ , @@int64@@ ) ; }
_BOOL8 __fastcall install_file_in_file_parents ( _BYTE * @@BYTE@@ , _BYTE * @@BYTE@@ , __int64 @@int64@@ ) { bool @@bool@@ ; char * @@char@@ ; int * @@int@@ ; _BOOL8 @@BOOL8@@ ; char * @@char@@ ; bool @@bool@@ ; bool @@bool@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@bool@@ = * @@BYTE@@ != Number || * @@BYTE@@ != Number ; @@bool@@ = @@bool@@ ; @@unsignedint@@ = Number ; savewd_init ( & @@int@@ ) ; if ( ! @@bool@@ ) savewd_finish ( & @@int@@ ) ; if ( mkancesdirs ( @@BYTE@@ , & @@int@@ , make_ancestor , @@int64@@ ) == Number ) { @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ , @@BYTE@@ ) ; @@unsignedint@@ = Number ; } if ( ! @@bool@@ ) goto LABEL_22 ; @@int@@ = savewd_restore ( & @@int@@ , @@unsignedint@@ ) ; @@int@@ = * __errno_location ( ) ; savewd_finish ( & @@int@@ ) ; if ( @@int@@ > Number ) return Number L ; if ( @@int@@ >= Number || @@unsignedint@@ ) { LABEL_22 : @@bool@@ = ! @@unsignedint@@ && ( unsigned __int8 ) install_file_in_file ( @@BYTE@@ , @@BYTE@@ , @@int64@@ ) ; @@BOOL8@@ = @@bool@@ ; } else { @@char@@ = gettext ( String ) ; error ( Number , @@int@@ , @@char@@ , @@BYTE@@ ) ; @@BOOL8@@ = Number L ; } return @@BOOL8@@ ; }
_BOOL8 __fastcall chown_failure_ok ( __int64 @@int64@@ ) { return ( * __errno_location ( ) == Number || * __errno_location ( ) == Number ) && * ( _BYTE * ) ( @@int64@@ + Number ) != Number ; }
_BYTE * __fastcall savedirstream ( DIR * @@DIR@@ ) { __int64 @@int64@@ ; int @@int@@ ; _BYTE * @@BYTE@@ ; unsigned __int64 @@unsignedint64@@ ; size_t @@sizet@@ ; struct dirent * @@structdirent@@ ; char * @@char@@ ; size_t @@sizet@@ ; @@unsignedint64@@ = Number L ; @@sizet@@ = Number L ; if ( ! @@DIR@@ ) return Number L ; @@BYTE@@ = ( _BYTE * ) xmalloc ( Number L ) ; while ( Number ) { * __errno_location ( ) = Number ; @@structdirent@@ = readdir ( @@DIR@@ ) ; if ( ! @@structdirent@@ ) break ; @@char@@ = @@structdirent@@ -> d_name ; if ( @@structdirent@@ -> d_name [ Number ] == Number ) { if ( @@structdirent@@ -> d_name [ Number ] == Number ) @@int64@@ = Number L ; else @@int64@@ = Number L ; } else { @@int64@@ = Number L ; } if ( @@char@@ [ @@int64@@ ] ) { @@sizet@@ = strlen ( @@structdirent@@ -> d_name ) + Number ; if ( @@sizet@@ > @@sizet@@ + @@sizet@@ ) xalloc_die ( ) ; if ( @@unsignedint64@@ <= @@sizet@@ + @@sizet@@ ) { do { if ( @@unsignedint64@@ > Number * @@unsignedint64@@ ) xalloc_die ( ) ; @@unsignedint64@@ *= Number L ; } while ( @@unsignedint64@@ <= @@sizet@@ + @@sizet@@ ) ; @@BYTE@@ = ( _BYTE * ) xrealloc ( @@BYTE@@ , @@unsignedint64@@ ) ; } memcpy ( & @@BYTE@@ [ @@sizet@@ ] , @@char@@ , @@sizet@@ ) ; @@sizet@@ += @@sizet@@ ; } } @@BYTE@@ [ @@sizet@@ ] = Number ; @@int@@ = * __errno_location ( ) ; if ( closedir ( @@DIR@@ ) ) @@int@@ = * __errno_location ( ) ; if ( ! @@int@@ ) return @@BYTE@@ ; free ( @@BYTE@@ ) ; * __errno_location ( ) = @@int@@ ; return Number L ; }
_BOOL8 __fastcall strip_trailing_slashes ( char * @@char@@ ) { char @@char@@ ; const char * @@constchar@@ ; const char * @@constchar@@ ; @@constchar@@ = last_component ( @@char@@ ) ; if ( ! * @@constchar@@ ) @@constchar@@ = @@char@@ ; @@constchar@@ = & @@constchar@@ [ base_len ( @@constchar@@ ) ] ; @@char@@ = * @@constchar@@ ; * @@constchar@@ = Number ; return @@char@@ != Number ; }
__int64 __fastcall _xargmatch_internal ( __int64 @@int64@@ , const char * @@constchar@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ , void ( * @ @ VAR_2012 @ @ void ( ) ( void ) @ @ argmatchexitfn ) ( void ) ) { __int64 @@int64@@ ; @@int64@@ = argmatch ( @@constchar@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; if ( @@int64@@ >= Number ) return @@int64@@ ; argmatch_invalid ( @@int64@@ , ( __int64 ) @@constchar@@ , @@int64@@ ) ; argmatch_valid ( @@int64@@ , @@int64@@ , @@sizet@@ ) ; @ @ VAR_2012 @ @ void ( ) ( void ) @ @ argmatchexitfn ( ) ; return Number ; }
unsigned __int64 get_ids ( ) { __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; unsigned __int64 @@unsignedint64@@ ; struct passwd * @@structpasswd@@ ; struct group * @@structgroup@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( owner_name ) { @@structpasswd@@ = getpwnam ( owner_name ) ; if ( @@structpasswd@@ ) { owner_id = @@structpasswd@@ -> pw_uid ; } else { if ( ( unsigned int ) xstrtoul ( owner_name , Number L , Number L , & @@unsignedint64@@ , Number L ) || @@unsignedint64@@ > Number ) { @@int64@@ = quote ( owner_name ) ; @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ , @@int64@@ ) ; } owner_id = @@unsignedint64@@ ; } endpwent ( ) ; } else { owner_id = Number ; } if ( group_name ) { @@structgroup@@ = getgrnam ( group_name ) ; if ( @@structgroup@@ ) { group_id = @@structgroup@@ -> gr_gid ; } else { if ( ( unsigned int ) xstrtoul ( group_name , Number L , Number L , & @@unsignedint64@@ , Number L ) || @@unsignedint64@@ > Number ) { @@int64@@ = quote ( group_name ) ; @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ , @@int64@@ ) ; } group_id = @@unsignedint64@@ ; } endgrent ( ) ; } else { group_id = Number ; } return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
_BOOL8 __fastcall owner_failure_ok ( __int64 @@int64@@ ) { return ( * __errno_location ( ) == Number || * __errno_location ( ) == Number ) && * ( _BYTE * ) ( @@int64@@ + Number ) != Number ; }
char * __fastcall areadlinkat ( int @@int@@ , const char * @@constchar@@ ) { signed __int64 @@signedint64@@ ; int @@int@@ ; char * @@char@@ ; __int64 @@int64@@ ; signed __int64 @@signedint64@@ ; size_t @@sizet@@ ; char * @@char@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@char@@ = @@char@@ ; @@int64@@ = Number L ; while ( Number ) { @@signedint64@@ = readlinkat ( @@int@@ , @@constchar@@ , @@char@@ , @@int64@@ ) ; if ( @@signedint64@@ < Number && * __errno_location ( ) != Number ) { if ( @@char@@ != @@char@@ ) { @@int@@ = * __errno_location ( ) ; free ( @@char@@ ) ; * __errno_location ( ) = @@int@@ ; } return Number L ; } if ( @@int64@@ > ( unsigned __int64 ) @@signedint64@@ ) break ; if ( @@char@@ != @@char@@ ) free ( @@char@@ ) ; @@int64@@ *= Number L ; if ( @@int64@@ < Number ) { * __errno_location ( ) = Number ; return Number L ; } @@char@@ = ( char * ) malloc ( @@int64@@ ) ; if ( ! @@char@@ ) return Number L ; } @@signedint64@@ = @@signedint64@@ ; @@sizet@@ = @@signedint64@@ + Number ; @@char@@ [ @@signedint64@@ ] = Number ; if ( @@char@@ == @@char@@ ) { @@char@@ = ( char * ) malloc ( @@sizet@@ ) ; if ( ! @@char@@ ) return Number L ; memcpy ( @@char@@ , @@char@@ , @@sizet@@ ) ; } else if ( @@int64@@ > @@sizet@@ ) { @@char@@ = ( char * ) realloc ( @@char@@ , @@sizet@@ ) ; if ( @@char@@ ) @@char@@ = @@char@@ ; } return @@char@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ ) { return xmalloc ( @@int64@@ ) ; }
__int64 __fastcall xsum ( unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; if ( @@unsignedint64@@ + @@int64@@ < @@unsignedint64@@ ) @@int64@@ = Number ; else @@int64@@ = @@unsignedint64@@ + @@int64@@ ; return @@int64@@ ; }
_BOOL8 __fastcall abandon_move ( __int64 @@int64@@ , const char * @@constchar@@ , __int64 @@int64@@ ) { bool @@bool@@ ; if ( ! * ( _BYTE * ) ( @@int64@@ + Number ) ) __assert_fail ( String , String , Number , String ) ; @@bool@@ = Number ; if ( * ( _DWORD * ) ( @@int64@@ + Number ) != Number ) { if ( * ( _DWORD * ) ( @@int64@@ + Number ) != Number && ( * ( _DWORD * ) ( @@int64@@ + Number ) != Number || ! * ( _BYTE * ) ( @@int64@@ + Number ) || writable_destination ( @@constchar@@ , * ( _DWORD * ) ( @@int64@@ + Number ) ) ) || ( overwrite_prompt ( @@constchar@@ , @@int64@@ ) , ( unsigned __int8 ) yesno ( ) == Number ) ) { @@bool@@ = Number ; } } return @@bool@@ ; }
__int64 decimal_point_char ( ) { __int64 @@int64@@ ; char * @@char@@ ; @@char@@ = nl_langinfo ( Number ) ; if ( * @@char@@ ) @@int64@@ = ( unsigned __int8 ) * @@char@@ ; else @@int64@@ = Number L ; return @@int64@@ ; }
unsigned __int64 __fastcall forget_created ( __int64 @@int64@@ , __int64 @@int64@@ ) { void * * @@void@@ ; __int64 @@int643@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int643@@ [ Number ] = @@int64@@ ; @@int643@@ [ Number ] = @@int64@@ ; @@int643@@ [ Number ] = Number L ; @@void@@ = ( void * * ) hash_delete ( src_to_dest , @@int643@@ ) ; if ( @@void@@ ) src_to_dest_free ( @@void@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall freadahead ( __int64 @@int64@@ ) { __int64 @@int64@@ ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) > * ( _QWORD * ) ( @@int64@@ + Number ) ) return Number L ; if ( ( * ( _DWORD * ) @@int64@@ & Number ) != Number ) @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) - * ( _QWORD * ) ( @@int64@@ + Number ) ; else @@int64@@ = Number L ; return * ( _QWORD * ) ( @@int64@@ + Number ) - * ( _QWORD * ) ( @@int64@@ + Number ) + @@int64@@ ; }
__int64 __fastcall rpl_fcntl ( int @@int@@ , int @@int@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ ) { int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; if ( @@int@@ != Number ) return ( unsigned int ) fcntl ( @@int@@ , @@int@@ , @@int64@@ ) ; @@int@@ = @@int64@@ ; if ( have_dupfd_cloexec_2895 < Number ) { @@int@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@int@@ , Number , @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ ) ; } else { @@int@@ = fcntl ( @@int@@ , Number , ( unsigned int ) @@int64@@ ) ; if ( @@int@@ < Number && * __errno_location ( ) == Number ) { @@int@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@int@@ , Number , @@int@@ , @@int@@ , @@int@@ , @@int@@ ) ; if ( @@int@@ < Number ) return ( unsigned int ) @@int@@ ; have_dupfd_cloexec_2895 = Number ; } else { have_dupfd_cloexec_2895 = Number ; } } if ( @@int@@ >= Number && have_dupfd_cloexec_2895 == Number ) { @@int@@ = fcntl ( @@int@@ , Number ) ; if ( @@int@@ < Number || fcntl ( @@int@@ , Number , @@int@@ | Number ) == Number ) { @@int@@ = * __errno_location ( ) ; close ( @@int@@ ) ; * __errno_location ( ) = @@int@@ ; @@int@@ = Number ; } } return ( unsigned int ) @@int@@ ; }
__int64 __fastcall copy ( char * @@char@@ , char * @@char@@ , char @@char@@ , unsigned int * @@unsignedint@@ , bool * @@bool@@ , _BYTE * @@BYTE@@ ) { char @@char@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( ! ( unsigned __int8 ) valid_options ( ( __int64 ) @@unsignedint@@ ) ) __assert_fail ( String , String , Number , String ) ; top_level_src_name = ( __int64 ) @@char@@ ; top_level_dst_name = ( __int64 ) @@char@@ ; @@char@@ = Number ; return copy_internal ( @@char@@ , @@char@@ , @@char@@ , Number L , Number L , @@unsignedint@@ , Number , & @@char@@ , @@bool@@ , @@BYTE@@ ) ; }
__int64 __fastcall remember_copied ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = xmalloc ( Number L ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = xstrdup ( @@int64@@ ) ; * ( _QWORD * ) @@int64@@ = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; @@int64@@ = hash_insert ( src_to_dest , @@int64@@ ) ; if ( ! @@int64@@ ) xalloc_die ( ) ; if ( @@int64@@ == @@int64@@ ) return Number L ; src_to_dest_free ( ( void * * ) @@int64@@ ) ; return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
unsigned __int64 __fastcall src_to_dest_hash ( _QWORD * @@QWORD@@ , unsigned __int64 @@unsignedint64@@ ) { return * @@QWORD@@ % @@unsignedint64@@ ; }
__int64 __fastcall argmatch ( const char * @@constchar@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { __int64 @@int64@@ ; char @@char@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; size_t @@sizet@@ ; @@int64@@ = Number ; @@char@@ = Number ; @@sizet@@ = strlen ( @@constchar@@ ) ; for ( @@int64@@ = Number L ; * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; ++ @@int64@@ ) { if ( ! strncmp ( * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) , @@constchar@@ , @@sizet@@ ) ) { if ( @@sizet@@ == strlen ( * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) ) ) return @@int64@@ ; if ( @@int64@@ == Number ) { @@int64@@ = @@int64@@ ; } else if ( ! @@int64@@ || memcmp ( ( const void * ) ( @@sizet@@ * @@int64@@ + @@int64@@ ) , ( const void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) , @@sizet@@ ) ) { @@char@@ = Number ; } } } if ( @@char@@ ) @@int64@@ = Number ; else @@int64@@ = @@int64@@ ; return @@int64@@ ; }
int __fastcall mknod ( char * @@char@@ , __mode_t @@modet@@ , __dev_t @@devt@@ ) { __dev_t @@devt2@@ [ Number ] ; @@devt2@@ [ Number ] = @@devt@@ ; return __xmknod ( Number , @@char@@ , @@modet@@ , @@devt2@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
unsigned __int64 __fastcall triple_hash ( _QWORD * @@QWORD@@ , unsigned __int64 @@unsignedint64@@ ) { return ( ( unsigned __int64 ) hash_pjw ( * @@QWORD@@ , @@unsignedint64@@ ) ^ @@QWORD@@ [ Number ] ) % @@unsignedint64@@ ; }
_BOOL8 __fastcall src_to_dest_compare ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ ) { return * @@QWORD@@ == * @@QWORD@@ && @@QWORD@@ [ Number ] == @@QWORD@@ [ Number ] ; }
__int64 * __fastcall mpz_tdiv_q ( __int64 * @@int64@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = * @@int64@@ ; if ( * @@QWORD@@ == Number && @@int64@@ == Number ) integer_overflow ( Number L ) ; @@int64@@ = @@int64@@ ; * @@int64@@ = * @@QWORD@@ / @@int64@@ ; return @@int64@@ ; }
__int64 __fastcall rpl_fcntl ( int @@int@@ , int @@int@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ ) { int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; if ( @@int@@ != Number ) return ( unsigned int ) fcntl ( @@int@@ , @@int@@ , @@int64@@ ) ; @@int@@ = @@int64@@ ; if ( have_dupfd_cloexec_2895 < Number ) { @@int@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@int@@ , Number , @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ ) ; } else { @@int@@ = fcntl ( @@int@@ , Number , ( unsigned int ) @@int64@@ ) ; if ( @@int@@ < Number && * __errno_location ( ) == Number ) { @@int@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@int@@ , Number , @@int@@ , @@int@@ , @@int@@ , @@int@@ ) ; if ( @@int@@ < Number ) return ( unsigned int ) @@int@@ ; have_dupfd_cloexec_2895 = Number ; } else { have_dupfd_cloexec_2895 = Number ; } } if ( @@int@@ >= Number && have_dupfd_cloexec_2895 == Number ) { @@int@@ = fcntl ( @@int@@ , Number ) ; if ( @@int@@ < Number || fcntl ( @@int@@ , Number , @@int@@ | Number ) == Number ) { @@int@@ = * __errno_location ( ) ; close ( @@int@@ ) ; * __errno_location ( ) = @@int@@ ; @@int@@ = Number ; } } return ( unsigned int ) @@int@@ ; }
_BOOL8 __fastcall mpz_fits_ulong_p ( _QWORD * @@QWORD@@ ) { return * @@QWORD@@ >= Number L ; }
_BOOL8 __fastcall triple_compare ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ ) { return @@QWORD@@ [ Number ] == @@QWORD@@ [ Number ] && @@QWORD@@ [ Number ] == @@QWORD@@ [ Number ] && ( unsigned __int8 ) same_name ( * @@QWORD@@ , * @@QWORD@@ ) ; }
bool __fastcall null ( __int64 @@int64@@ ) { _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; if ( ! * ( _DWORD * ) @@int64@@ ) return ( unsigned int ) mpz_sgn ( ( __int64 * ) ( @@int64@@ + Number ) ) == Number ; if ( * ( _DWORD * ) @@int64@@ != Number ) abort ( ) ; @@BYTE@@ = * ( _BYTE * * ) ( @@int64@@ + Number ) ; if ( ! * @@BYTE@@ ) return Number ; @@BYTE@@ = & @@BYTE@@ [ * @@BYTE@@ == Number ] ; do { if ( * @@BYTE@@ != Number ) return Number ; ++ @@BYTE@@ ; } while ( * @@BYTE@@ ) ; return Number ; }
__int64 __fastcall src_to_dest_lookup ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int644@@ [ Number ] ; @@int644@@ [ Number ] = __readfsqword ( Number ) ; @@int644@@ [ Number ] = @@int64@@ ; @@int644@@ [ Number ] = @@int64@@ ; @@int64@@ = hash_lookup ( src_to_dest , @@int644@@ ) ; if ( @@int64@@ ) @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; else @@int64@@ = Number L ; return @@int64@@ ; }
__int64 __fastcall install_file_in_dir ( char * @@char@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { unsigned __int8 @@unsignedint8@@ ; __int64 @@int64@@ ; void * @@void@@ ; @@int64@@ = last_component ( @@char@@ ) ; @@void@@ = ( void * ) file_name_concat ( @@int64@@ , @@int64@@ , Number L ) ; @@unsignedint8@@ = install_file_in_file ( @@char@@ , ( __int64 ) @@void@@ , @@int64@@ ) ; free ( @@void@@ ) ; return @@unsignedint8@@ ; }
int __cdecl __noreturn main ( int @@int@@ , const char * * @@constchar@@ , const char * * @@constchar@@ ) { char * @@char@@ ; unsigned __int8 @@unsignedint8@@ ; const char * * @@constchar@@ ; int @@int@@ ; __int64 @@int64@@ ; @@int@@ = @@int@@ ; @@constchar@@ = @@constchar@@ ; set_program_name ( * @@constchar@@ , @@constchar@@ , @@constchar@@ ) ; setlocale ( Number , & off_1D2EC [ Number ] ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; initialize_exit_failure ( Number ) ; atexit ( close_stdout ) ; parse_long_options ( @@int@@ , ( _DWORD ) @@constchar@@ , ( unsigned int ) String , ( unsigned int ) String , ( unsigned int ) String , ( unsigned int ) usage , String , String , String , Number L ) ; if ( @@int@@ > Number && ! strcmp ( @@constchar@@ [ Number ] , String ) ) { @@int@@ = @@int@@ - Number ; @@constchar@@ = @@constchar@@ + Number ; } if ( @@int@@ <= Number ) { @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ ) ; usage ( Number ) ; } args = ( __int64 ) ( @@constchar@@ + Number ) ; @@int64@@ = eval ( Number L ) ; if ( ( unsigned __int8 ) nomoreargs ( ) != Number ) syntax_error ( ) ; printv ( @@int64@@ ) ; @@unsignedint8@@ = null ( @@int64@@ ) ; exit ( @@unsignedint8@@ ) ; }
char * __fastcall areadlink_with_size ( const char * @@constchar@@ , unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; char * @@char@@ ; int @@int@@ ; size_t @@sizet@@ ; char * @@char@@ ; ssize_t @@ssizet@@ ; if ( @@unsignedint64@@ >= Number ) @@int64@@ = Number L ; else @@int64@@ = @@unsignedint64@@ + Number ; @@sizet@@ = @@int64@@ ; LABEL_5 : for ( @@char@@ = ( char * ) malloc ( @@sizet@@ ) ; ; @@char@@ = ( char * ) malloc ( Number ) ) { @@char@@ = @@char@@ ; if ( ! @@char@@ ) return Number L ; @@ssizet@@ = readlink ( @@constchar@@ , @@char@@ , @@sizet@@ ) ; if ( @@ssizet@@ < Number && * __errno_location ( ) != Number ) { @@int@@ = * __errno_location ( ) ; free ( @@char@@ ) ; * __errno_location ( ) = @@int@@ ; return Number L ; } if ( @@ssizet@@ < @@sizet@@ ) { @@char@@ [ @@ssizet@@ ] = Number ; return @@char@@ ; } free ( @@char@@ ) ; if ( @@sizet@@ <= Number ) { @@sizet@@ *= Number L ; goto LABEL_5 ; } if ( @@sizet@@ > Number ) break ; @@sizet@@ = Number ; } * __errno_location ( ) = Number ; return Number L ; }
__int64 __fastcall savewd_process_files ( int @@int@@ , __int64 @@int64@@ , __int64 ( __fastcall * @ @ VAR_1057 @ @ int64 ( fastcall ) ( QWORD , int , int64 ) @ @ int ( ) ( char , savewd , void ) ) ( _QWORD , int * , __int64 ) , __int64 @@int64@@ ) { int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int@@ = Number ; @@int@@ = Number ; savewd_init_0 ( & @@int@@ ) ; for ( @@int@@ = @@int@@ - Number ; @@int@@ >= Number && * * ( _BYTE * * ) ( Number L * @@int@@ + @@int64@@ ) == Number ; -- @@int@@ ) { ; } while ( @@int@@ < @@int@@ ) { if ( ! savewd_delegating ( & @@int@@ ) ) { @@int@@ = @ @ VAR_1057 @ @ int64 ( fastcall ) ( QWORD , int , int64 ) @ @ int ( ) ( char , savewd , void ) ( * ( _QWORD * ) ( Number L * @@int@@ + @@int64@@ ) , & @@int@@ , @@int64@@ ) ; if ( @@int@@ < @@int@@ ) @@int@@ = @@int@@ ; } if ( * * ( _BYTE * * ) ( Number * ( @@int@@ + Number L ) + @@int64@@ ) != Number ) { @@int@@ = savewd_restore ( & @@int@@ , @@int@@ ) ; if ( @@int@@ < @@int@@ ) @@int@@ = @@int@@ ; } ++ @@int@@ ; } savewd_finish ( & @@int@@ ) ; while ( @@int@@ < @@int@@ ) { @@int@@ = @ @ VAR_1057 @ @ int64 ( fastcall ) ( QWORD , int , int64 ) @ @ int ( ) ( char , savewd , void ) ( * ( _QWORD * ) ( Number L * @@int@@ + @@int64@@ ) , & @@int@@ , @@int64@@ ) ; if ( @@int@@ < @@int@@ ) @@int@@ = @@int@@ ; ++ @@int@@ ; } return ( unsigned int ) @@int@@ ; }
unsigned __int64 __fastcall strip ( __int64 @@int64@@ ) { __pid_t @@pidt@@ ; char * @@char@@ ; int * @@int@@ ; char * @@char@@ ; char * @@char@@ ; int * @@int@@ ; char * @@char@@ ; int * @@int@@ ; char * @@char@@ ; int @@int@@ ; __pid_t @@pidt@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@pidt@@ = fork ( ) ; @@pidt@@ = @@pidt@@ ; if ( @@pidt@@ == Number ) { @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ ) ; } else if ( @@pidt@@ ) { if ( waitpid ( @@pidt@@ , & @@int@@ , Number ) >= Number ) { if ( ( @@int@@ & Number ) != Number || BYTE1 ( @@int@@ ) ) { @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ ) ; } } else { @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ ) ; } } else { execlp ( strip_program , strip_program , @@int64@@ , Number L ) ; @@char@@ = strip_program ; @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ , @@char@@ ) ; } return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall docolon ( __int64 @@int64@@ , __int64 @@int64@@ ) { size_t @@sizet@@ ; size_t @@sizet@@ ; char * @@char@@ ; int @@int@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; void * @@void@@ ; void * @@void@@ ; __int64 @@int644@@ [ Number ] ; char * @@char@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; char @@char@@ ; char @@char@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; tostring ( ( unsigned int * ) @@int64@@ ) ; tostring ( ( unsigned int * ) @@int64@@ ) ; @@int64@@ = Number L ; @@void@@ = Number L ; @@void@@ = Number L ; @@int644@@ [ Number ] = Number L ; @@int644@@ [ Number ] = Number L ; @@char@@ = & @@char@@ ; @@int64@@ = Number L ; rpl_re_syntax_options = Number L ; @@sizet@@ = strlen ( * ( const char * * ) ( @@int64@@ + Number ) ) ; @@int64@@ = rpl_re_compile_pattern ( * ( _QWORD * ) ( @@int64@@ + Number ) , @@sizet@@ , @@int644@@ ) ; if ( @@int64@@ ) error ( Number , Number , off_1D2EC , @@int64@@ ) ; @@char@@ &= Number ; @@sizet@@ = strlen ( * ( const char * * ) ( @@int64@@ + Number ) ) ; @@int64@@ = rpl_re_match ( @@int644@@ , * ( _QWORD * ) ( @@int64@@ + Number ) , @@sizet@@ , Number L , & @@int64@@ ) ; if ( @@int64@@ < Number ) { if ( @@int64@@ == Number ) { if ( @@int64@@ ) @@int64@@ = str_value ( ( __int64 ) & off_1D2EC [ Number ] ) ; else @@int64@@ = int_value ( Number L ) ; } else { @@char@@ = gettext ( String ) ; if ( @@int64@@ == Number ) @@int@@ = * __errno_location ( ) ; else @@int@@ = Number ; error ( Number , @@int@@ , @@char@@ ) ; } } else if ( @@int64@@ ) { * ( _BYTE * ) ( * ( ( _QWORD * ) @@void@@ + Number ) + * ( _QWORD * ) ( @@int64@@ + Number ) ) = Number ; @@int64@@ = str_value ( * ( ( _QWORD * ) @@void@@ + Number ) + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; } else { @@int64@@ = int_value ( @@int64@@ ) ; } if ( @@int64@@ ) { free ( @@void@@ ) ; free ( @@void@@ ) ; } @@char@@ = Number L ; rpl_regfree ( @@int644@@ ) ; return @@int64@@ ; }
void * * __fastcall eval1 ( unsigned __int8 @@unsignedint8@@ ) { bool @@bool@@ ; void * * @@void@@ ; void * * @@void@@ ; @@void@@ = ( void * * ) eval2 ( @@unsignedint8@@ ) ; while ( nextarg ( String ) ) { @@bool@@ = @@unsignedint8@@ && ! null ( ( __int64 ) @@void@@ ) ; @@void@@ = ( void * * ) eval2 ( @@bool@@ ) ; if ( null ( ( __int64 ) @@void@@ ) || null ( ( __int64 ) @@void@@ ) ) { freev ( @@void@@ ) ; freev ( @@void@@ ) ; @@void@@ = ( void * * ) int_value ( Number L ) ; } else { freev ( @@void@@ ) ; } } return @@void@@ ; }
unsigned __int64 __fastcall buffer_lcm ( unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@unsignedint64@@ ) { if ( @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ ; for ( @@unsignedint64@@ = @@unsignedint64@@ ; ; @@unsignedint64@@ = @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ % @@unsignedint64@@ ; if ( ! ( @@unsignedint64@@ % @@unsignedint64@@ ) ) break ; @@unsignedint64@@ = @@unsignedint64@@ ; } if ( @@unsignedint64@@ * ( @@unsignedint64@@ / @@unsignedint64@@ ) <= @@unsignedint64@@ && @@unsignedint64@@ / @@unsignedint64@@ == @@unsignedint64@@ * ( @@unsignedint64@@ / @@unsignedint64@@ ) / @@unsignedint64@@ ) { return @@unsignedint64@@ * ( @@unsignedint64@@ / @@unsignedint64@@ ) ; } } @@unsignedint64@@ = @@unsignedint64@@ ; } else { if ( @@unsignedint64@@ ) @@int64@@ = @@unsignedint64@@ ; else @@int64@@ = Number ; @@unsignedint64@@ = @@int64@@ ; } @@unsignedint64@@ = @@unsignedint64@@ ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) @@unsignedint64@@ = @@unsignedint64@@ ; return @@unsignedint64@@ ; }
__int64 __fastcall bkm_scale_by_power ( __int64 * @@int64@@ , int @@int@@ , int @@int@@ ) { unsigned int @@unsignedint@@ ; for ( @@unsignedint@@ = Number ; @@int@@ -- ; @@unsignedint@@ |= bkm_scale ( @@int64@@ , @@int@@ ) ) { ; } return @@unsignedint@@ ; }
_BOOL8 __fastcall writable_destination ( const char * @@constchar@@ , __int16 @@int16@@ ) { return ( @@int16@@ & Number ) == Number || ( unsigned __int8 ) can_write_any_file ( ) || ! euidaccess ( @@constchar@@ , Number ) ; }
__int64 close_stdin ( ) { const char * @@constchar@@ ; int * @@int@@ ; int * @@int@@ ; __int64 @@int64@@ ; char @@char@@ ; char * @@char@@ ; @@char@@ = Number ; if ( freadahead ( stdin ) && ! ( unsigned int ) rpl_fseeko ( stdin , Number L , Number L ) && ( unsigned int ) rpl_fflush ( stdin ) ) @@char@@ = Number ; if ( ( unsigned int ) close_stream ( stdin ) ) @@char@@ = Number ; if ( @@char@@ ) { @@char@@ = gettext ( String ) ; if ( file_name ) { @@constchar@@ = ( const char * ) quotearg_colon ( file_name ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , String , @@constchar@@ , @@char@@ ) ; } else { @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , String , @@char@@ ) ; } } @@int64@@ = close_stdout ( ) ; if ( @@char@@ ) _exit ( exit_failure ) ; return @@int64@@ ; }
__int64 __fastcall xget_version ( __int64 @@int64@@ , _BYTE * @@BYTE@@ ) { char * @@char@@ ; if ( @@BYTE@@ && * @@BYTE@@ ) return get_version ( @@int64@@ , @@BYTE@@ ) ; @@char@@ = getenv ( String ) ; return get_version ( ( __int64 ) String , @@char@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
_BYTE * __fastcall filemodestring ( __int64 @@int64@@ , _BYTE * @@BYTE@@ ) { return strmode ( * ( _DWORD * ) ( @@int64@@ + Number ) , @@BYTE@@ ) ; }
__int64 __fastcall bkm_scale ( __int64 * @@int64@@ , int @@int@@ ) { __int64 @@int64@@ ; if ( * @@int64@@ >= ( __int64 ) Number / @@int@@ ) { if ( Number / @@int@@ >= * @@int64@@ ) { * @@int64@@ *= @@int@@ ; @@int64@@ = Number L ; } else { * @@int64@@ = Number ; @@int64@@ = Number L ; } } else { * @@int64@@ = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
int __fastcall emit_verbose ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { const char * @@constchar@@ ; const char * @@constchar@@ ; __int64 @@int64@@ ; char * @@char@@ ; @@constchar@@ = ( const char * ) quote_n ( Number L , @@int64@@ ) ; @@constchar@@ = ( const char * ) quote_n ( Number L , @@int64@@ ) ; printf ( String , @@constchar@@ , @@constchar@@ ) ; if ( @@int64@@ ) { @@int64@@ = quote ( @@int64@@ ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } return putchar_unlocked ( Number ) ; }
__int64 __fastcall dir_name ( __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = mdir_name ( @@int64@@ ) ; if ( ! @@int64@@ ) xalloc_die ( ) ; return @@int64@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
void * __fastcall mfile_name_concat ( _BYTE * @@BYTE@@ , _BYTE * @@BYTE@@ , _QWORD * @@QWORD@@ ) { _BOOL4 @@BOOL4@@ ; const char * @@constchar@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; _BOOL8 @@BOOL8@@ ; char * @@char@@ ; size_t @@sizet@@ ; void * @@void@@ ; _BYTE * @@BYTE@@ ; char * @@char@@ ; @@constchar@@ = last_component ( @@BYTE@@ ) ; @@sizet@@ = base_len ( @@constchar@@ ) ; @@sizet@@ = @@constchar@@ - @@BYTE@@ + @@sizet@@ ; @@BOOL4@@ = @@sizet@@ && @@constchar@@ [ @@sizet@@ - Number ] != Number ; @@BOOL8@@ = @@BOOL4@@ ; @@char@@ = longest_relative_suffix ( @@BYTE@@ ) ; @@sizet@@ = strlen ( @@char@@ ) ; @@void@@ = malloc ( @@BOOL8@@ + @@sizet@@ + @@sizet@@ + Number ) ; if ( ! @@void@@ ) return Number L ; @@BYTE@@ = mempcpy ( @@void@@ , @@BYTE@@ , @@sizet@@ ) ; * @@BYTE@@ = Number ; @@char@@ = & @@BYTE@@ [ @@BOOL8@@ ] ; if ( @@QWORD@@ ) * @@QWORD@@ = & @@char@@ [ - ( * @@BYTE@@ == Number ) ] ; * ( _BYTE * ) mempcpy ( @@char@@ , @@char@@ , @@sizet@@ ) = Number ; return @@void@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
__int64 __fastcall clear_ungetc_buffer_preserving_position ( _DWORD * @@DWORD@@ ) { __int64 @@int64@@ ; @@int64@@ = * @@DWORD@@ & Number ; if ( ( _DWORD ) @@int64@@ ) @@int64@@ = rpl_fseeko ( @@DWORD@@ , Number L , Number L ) ; return @@int64@@ ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
__int64 __fastcall valid_options ( __int64 @@int64@@ ) { if ( ! @@int64@@ ) __assert_fail ( String , String , Number , String ) ; if ( * ( _DWORD * ) @@int64@@ > Number ) __assert_fail ( String , String , Number , String ) ; if ( * ( _DWORD * ) ( @@int64@@ + Number ) != Number && * ( _DWORD * ) ( @@int64@@ + Number ) != Number && * ( _DWORD * ) ( @@int64@@ + Number ) != Number ) { __assert_fail ( String , String , Number , String ) ; } if ( * ( _DWORD * ) ( @@int64@@ + Number ) && * ( _DWORD * ) ( @@int64@@ + Number ) != Number && * ( _DWORD * ) ( @@int64@@ + Number ) != Number ) { __assert_fail ( String , String , Number , String ) ; } if ( * ( _BYTE * ) ( @@int64@@ + Number ) == Number && * ( _BYTE * ) ( @@int64@@ + Number ) == Number ) __assert_fail ( String , String , Number , String ) ; if ( * ( _DWORD * ) ( @@int64@@ + Number ) == Number && * ( _DWORD * ) ( @@int64@@ + Number ) != Number ) { __assert_fail ( String , String , Number , String ) ; } return Number L ; }
__int64 __fastcall hash_get_first ( unsigned __int64 * @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; if ( ! @@unsignedint64@@ [ Number ] ) return Number L ; for ( @@unsignedint64@@ = * @@unsignedint64@@ ; ; @@unsignedint64@@ += Number L ) { if ( @@unsignedint64@@ >= @@unsignedint64@@ [ Number ] ) abort ( ) ; if ( * ( _QWORD * ) @@unsignedint64@@ ) break ; } return * ( _QWORD * ) @@unsignedint64@@ ; }
__int64 __fastcall file_name_concat ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = mfile_name_concat ( @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( ! @@int64@@ ) xalloc_die ( ) ; return @@int64@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 __fastcall hash_do_for_each ( __int64 @@int64@@ , unsigned __int8 ( __fastcall * @ @ VAR_1337 @ @ unsignedint8 ( fastcall ) ( QWORD , int64 ) @ @ Hashprocessor ) ( _QWORD , __int64 ) , __int64 @@int64@@ ) { __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; @@int64@@ = Number L ; for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { for ( @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { if ( @ @ VAR_1337 @ @ unsignedint8 ( fastcall ) ( QWORD , int64 ) @ @ Hashprocessor ( * @@QWORD@@ , @@int64@@ ) != Number ) return @@int64@@ ; ++ @@int64@@ ; } } } return @@int64@@ ; }
__int64 __fastcall hash_get_n_buckets_used ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 __fastcall copy_acl ( __int64 @@int64@@ , unsigned int @@unsignedint@@ , const char * @@constchar@@ , int @@int@@ , __mode_t @@modet@@ ) { int @@int@@ ; const char * @@constchar@@ ; int * @@int@@ ; __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; __int64 @@int64@@ ; @@int@@ = qcopy_acl ( @@int64@@ , @@unsignedint@@ , @@constchar@@ , @@int@@ , @@modet@@ ) ; if ( @@int@@ == Number ) { @@constchar@@ = ( const char * ) quote ( @@int64@@ ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , String , @@constchar@@ ) ; @@int64@@ = Number ; } else if ( @@int@@ == Number ) { @@int64@@ = quote ( @@constchar@@ ) ; @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ , @@int64@@ ) ; @@int64@@ = Number ; } else { @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_222028 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
_QWORD * __fastcall bitset_set ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { _QWORD * @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) ( Number * ( @@unsignedint64@@ >> Number ) + @@int64@@ ) ; * @@QWORD@@ |= Number L << ( @@unsignedint64@@ & Number ) ; return @@QWORD@@ ; }
unsigned __int64 __fastcall hash_get_max_bucket_length ( __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = Number L ; for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { @@QWORD@@ = @@QWORD@@ ; for ( @@unsignedint64@@ = Number L ; ; ++ @@unsignedint64@@ ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; if ( ! @@QWORD@@ ) break ; } if ( @@unsignedint64@@ > @@unsignedint64@@ ) @@unsignedint64@@ = @@unsignedint64@@ ; } } return @@unsignedint64@@ ; }
void * __fastcall bitset_set_all ( void * @@void@@ ) { return memset ( @@void@@ , Number , Number ) ; }
bool __fastcall seen_file ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 * @@int64@@ ) { __int64 @@int644@@ [ Number ] ; @@int644@@ [ Number ] = __readfsqword ( Number ) ; if ( ! @@int64@@ ) return Number ; @@int644@@ [ Number ] = @@int64@@ ; @@int644@@ [ Number ] = @@int64@@ [ Number ] ; @@int644@@ [ Number ] = * @@int64@@ ; return hash_lookup ( @@int64@@ , @@int644@@ ) != Number ; }
unsigned __int64 __fastcall compute_bucket_size ( __int64 @@int64@@ , __int64 @@int64@@ ) { float @@float@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; float @@float@@ ; @@unsignedint64@@ = @@int64@@ ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) != Number ) { if ( @@int64@@ < Number ) @@float@@ = ( float ) ( @@int64@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@int64@@ >> Number ) ) + ( float ) ( @@int64@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@int64@@ >> Number ) ) ; else @@float@@ = ( float ) ( int ) @@int64@@ ; @@float@@ = @@float@@ / * ( float * ) ( @@int64@@ + Number ) ; if ( @@float@@ >= Number ) return Number L ; if ( @@float@@ >= Number ) @@unsignedint64@@ = ( unsigned int ) ( int ) ( float ) ( @@float@@ - Number ) ^ Number ; else @@unsignedint64@@ = ( unsigned int ) ( int ) @@float@@ ; } @@unsignedint64@@ = next_prime ( @@unsignedint64@@ ) ; if ( @@unsignedint64@@ <= Number ) @@unsignedint64@@ = @@unsignedint64@@ ; else @@unsignedint64@@ = Number L ; return @@unsignedint64@@ ; }
_QWORD * __fastcall bitset_mask ( __int64 @@int64@@ , __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; int @@int@@ ; for ( @@int@@ = Number ; @@int@@ <= Number ; ++ @@int@@ ) { @@QWORD@@ = ( _QWORD * ) ( Number L * @@int@@ + @@int64@@ ) ; * @@QWORD@@ &= * ( _QWORD * ) ( Number L * @@int@@ + @@int64@@ ) ; } return @@QWORD@@ ; }
__int64 __fastcall full_write ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = Number L ; while ( @@int64@@ ) { @@int64@@ = safe_write ( @@unsignedint@@ , @@int64@@ , @@int64@@ ) ; if ( @@int64@@ == Number ) break ; if ( ! @@int64@@ ) { * __errno_location ( ) = Number ; return @@int64@@ ; } @@int64@@ += @@int64@@ ; @@int64@@ += @@int64@@ ; @@int64@@ -= @@int64@@ ; } return @@int64@@ ; }
__int64 __fastcall hash_lookup ( __int64 * @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; @@int64@@ = * @@int64@@ ; @@QWORD@@ = ( _QWORD * ) ( @@int64@@ + Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@int64@@ [ Number ] ) ( @@int64@@ , @@int64@@ [ Number ] ) ) ; if ( ( unsigned __int64 ) @@QWORD@@ >= @@int64@@ [ Number ] ) abort ( ) ; if ( ! * @@QWORD@@ ) return Number L ; for ( @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { if ( @@int64@@ == * @@QWORD@@ || ( ( unsigned __int8 ( __fastcall * ) ( __int64 , _QWORD ) ) @@int64@@ [ Number ] ) ( @@int64@@ , * @@QWORD@@ ) ) { return * @@QWORD@@ ; } } return Number L ; }
unsigned __int64 __fastcall re_string_skip_chars ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , wchar_t * @@wchart@@ ) { _BOOL4 @@BOOL4@@ ; wchar_t @@wchart@@ ; wchar_t @@wchart@@ ; unsigned __int64 @@unsignedint64@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@wchart@@ = Number ; for ( @@unsignedint64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) + * ( _QWORD * ) ( @@int64@@ + Number ) ; @@unsignedint64@@ < @@unsignedint64@@ ; @@unsignedint64@@ += @@sizet@@ ) { @@sizet@@ = * ( _QWORD * ) ( @@int64@@ + Number ) - @@unsignedint64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@sizet@@ = mbrtowc ( & @@wchart@@ , ( const char * ) ( * ( _QWORD * ) @@int64@@ + @@unsignedint64@@ ) , @@sizet@@ , ( mbstate_t * ) ( @@int64@@ + Number ) ) ; @@BOOL4@@ = @@sizet@@ == Number || @@sizet@@ == Number ; if ( ! @@BOOL4@@ && @@sizet@@ ) { @@wchart@@ = @@wchart@@ ; } else { if ( @@sizet@@ && @@sizet@@ ) @@wchart@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) @@int64@@ + @@unsignedint64@@ ) ; else @@wchart@@ = Number ; @@sizet@@ = Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; } } * @@wchart@@ = @@wchart@@ ; return @@unsignedint64@@ ; }
_BOOL8 __fastcall savewd_delegating ( _DWORD * @@DWORD@@ ) { return * @@DWORD@@ == Number && ( int ) @@DWORD@@ [ Number ] > Number ; }
__int64 __fastcall re_node_set_init_1 ( _QWORD * @@QWORD@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; * @@QWORD@@ = Number L ; @@QWORD@@ [ Number ] = Number L ; @@QWORD@@ [ Number ] = malloc ( Number ) ; if ( @@QWORD@@ [ Number ] ) { * ( _QWORD * ) @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = Number L ; } else { @@QWORD@@ [ Number ] = Number L ; * @@QWORD@@ = @@QWORD@@ [ Number ] ; @@int64@@ = Number L ; } return @@int64@@ ; }
unsigned __int64 __fastcall hash_string ( _BYTE * @@BYTE@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = Number L ; while ( * @@BYTE@@ ) @@unsignedint64@@ = ( Number * @@unsignedint64@@ + ( unsigned __int8 ) * @@BYTE@@ ++ ) % @@unsignedint64@@ ; return @@unsignedint64@@ ; }
__int64 __fastcall hash_rehash ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; void * @@void@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@unsignedint64@@ = compute_bucket_size ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( ! @@unsignedint64@@ ) return Number L ; if ( @@unsignedint64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ) return Number L ; @@void@@ = calloc ( @@unsignedint64@@ , Number ) ; if ( ! @@void@@ ) return Number L ; @@unsignedint64@@ = @@unsignedint64@@ ; @@int64@@ = ( __int64 ) @@void@@ + Number * @@unsignedint64@@ ; @@int64@@ = Number L ; @@int64@@ = Number L ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( ( unsigned __int8 ) transfer_entries ( ( __int64 ) & @@void@@ , @@int64@@ , Number ) ) { free ( * ( void * * ) @@int64@@ ) ; * ( _QWORD * ) @@int64@@ = @@void@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@unsignedint64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; @@int64@@ = Number L ; } else { * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; if ( ( unsigned __int8 ) transfer_entries ( @@int64@@ , ( __int64 ) & @@void@@ , Number ) != Number || ( unsigned __int8 ) transfer_entries ( @@int64@@ , ( __int64 ) & @@void@@ , Number ) != Number ) { abort ( ) ; } free ( @@void@@ ) ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall re_string_construct ( __int64 @@int64@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; unsigned int @@unsignedint@@ ; unsigned int @@unsignedint@@ ; unsigned int @@unsignedint@@ ; memset ( ( void * ) @@int64@@ , Number , Number ) ; re_string_construct_common ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@int64@@ , @@unsignedint8@@ , @@int64@@ ) ; if ( @@unsignedint64@@ ) { @@unsignedint@@ = re_string_realloc_buffers ( @@int64@@ , @@unsignedint64@@ + Number ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; } if ( * ( _BYTE * ) ( @@int64@@ + Number ) ) @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; else @@int64@@ = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; if ( ! @@unsignedint8@@ ) { if ( * ( int * ) ( @@int64@@ + Number ) <= Number ) { if ( @@int64@@ ) { re_string_translate_buffer ( @@int64@@ ) ; } else { * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; } } else { build_wcs_buffer ( @@int64@@ ) ; } return Number L ; } if ( * ( int * ) ( @@int64@@ + Number ) <= Number ) { build_upper_buffer ( @@int64@@ ) ; return Number L ; } do { @@unsignedint@@ = build_wcs_upper_buffer ( @@int64@@ ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; if ( @@unsignedint64@@ <= * ( _QWORD * ) ( @@int64@@ + Number ) || * ( _QWORD * ) ( @@int64@@ + Number ) > ( unsigned __int64 ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + * ( int * ) ( @@int64@@ + Number ) ) ) { return Number L ; } @@unsignedint@@ = re_string_realloc_buffers ( @@int64@@ , Number L * * ( _QWORD * ) ( @@int64@@ + Number ) ) ; } while ( ! @@unsignedint@@ ) ; return @@unsignedint@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall re_node_set_init_copy ( void * @@void@@ , __int64 @@int64@@ ) { * ( ( _QWORD * ) @@void@@ + Number ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) { * ( _QWORD * ) @@void@@ = * ( ( _QWORD * ) @@void@@ + Number ) ; * ( ( _QWORD * ) @@void@@ + Number ) = malloc ( Number L * * ( _QWORD * ) @@void@@ ) ; if ( ! * ( ( _QWORD * ) @@void@@ + Number ) ) { * ( ( _QWORD * ) @@void@@ + Number ) = Number L ; * ( _QWORD * ) @@void@@ = * ( ( _QWORD * ) @@void@@ + Number ) ; return Number L ; } memcpy ( * ( ( void * * ) @@void@@ + Number ) , * ( const void * * ) ( @@int64@@ + Number ) , Number L * * ( _QWORD * ) ( @@int64@@ + Number ) ) ; } else { memset ( @@void@@ , Number , Number ) ; } return Number L ; }
unsigned __int64 __fastcall raw_hasher ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { return rotr_sz ( @@int64@@ , Number ) % @@unsignedint64@@ ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
__int64 __fastcall re_string_context_at ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , char @@char@@ ) { __int64 @@int64@@ ; int @@int@@ ; wint_t @@wintt@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@unsignedint64@@ > Number ) return * ( unsigned int * ) ( @@int64@@ + Number ) ; if ( @@unsignedint64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ) { if ( ( @@char@@ & Number ) != Number ) @@int64@@ = Number L ; else @@int64@@ = Number L ; } else if ( * ( int * ) ( @@int64@@ + Number ) <= Number ) { @@int@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + @@unsignedint64@@ ) ; if ( bitset_contain ( * ( _QWORD * ) ( @@int64@@ + Number ) , * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + @@unsignedint64@@ ) ) ) { @@int64@@ = Number L ; } else if ( @@int@@ == Number && * ( _BYTE * ) ( @@int64@@ + Number ) ) { @@int64@@ = Number L ; } else { @@int64@@ = Number L ; } } else { @@unsignedint64@@ = @@unsignedint64@@ ; while ( * ( _DWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) == Number ) { if ( -- @@unsignedint64@@ > Number ) return * ( unsigned int * ) ( @@int64@@ + Number ) ; } @@wintt@@ = * ( _DWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) && ( iswalnum ( @@wintt@@ ) || @@wintt@@ == Number ) ) { @@int64@@ = Number L ; } else if ( @@wintt@@ == Number && * ( _BYTE * ) ( @@int64@@ + Number ) ) { @@int64@@ = Number L ; } else { @@int64@@ = Number L ; } } return @@int64@@ ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
__int64 __fastcall re_node_set_compare ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; if ( ! @@int64@@ || ! @@int64@@ || * ( _QWORD * ) ( @@int64@@ + Number ) != * ( _QWORD * ) ( @@int64@@ + Number ) ) { return Number L ; } @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; while ( ( unsigned __int64 ) -- @@int64@@ <= Number ) { if ( * ( _QWORD * ) ( Number * @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) != * ( _QWORD * ) ( Number * @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ) return Number L ; } return Number L ; }
void * __fastcall find_backup_file_name ( const char * @@constchar@@ , int @@int@@ ) { int @@int@@ ; bool @@bool@@ ; void * @@void@@ ; size_t @@sizet@@ ; __int64 @@int64@@ ; size_t @@sizet@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = strlen ( @@constchar@@ ) ; @@bool@@ = Number ; @@sizet@@ = strlen ( simple_backup_suffix ) + Number ; @@sizet@@ = @@sizet@@ ; if ( @@sizet@@ <= Number ) @@sizet@@ = Number L ; @@unsignedint64@@ = @@int64@@ + @@sizet@@ + Number ; @@void@@ = ( void * ) xmalloc ( @@unsignedint64@@ ) ; memcpy ( @@void@@ , @@constchar@@ , @@int64@@ + Number ) ; if ( @@int@@ != Number ) { @@int@@ = numbered_backup ( ( __int64 * ) & @@void@@ , @@unsignedint64@@ , @@int64@@ ) ; switch ( @@int@@ ) { case Number : @@bool@@ = Number ; break ; case Number : return @@void@@ ; case Number : @@bool@@ = @@int@@ == Number ; break ; } } if ( @@bool@@ ) memcpy ( ( char * ) @@void@@ + @@int64@@ , simple_backup_suffix , @@sizet@@ ) ; check_extension ( ( const char * ) @@void@@ , @@int64@@ , Number ) ; return @@void@@ ; }
__int64 __fastcall check_tuning ( __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( ( _UNKNOWN * ) @@int64@@ == & default_tuning ) return Number L ; if ( * ( float * ) ( @@int64@@ + Number ) > Number && ( float ) ( Number - Number ) > * ( float * ) ( @@int64@@ + Number ) && * ( float * ) ( @@int64@@ + Number ) > ( float ) ( Number + Number ) && * ( float * ) @@int64@@ >= Number && * ( float * ) ( @@int64@@ + Number ) > ( float ) ( * ( float * ) @@int64@@ + Number ) && * ( float * ) ( @@int64@@ + Number ) <= Number && * ( float * ) ( @@int64@@ + Number ) > ( float ) ( * ( float * ) @@int64@@ + Number ) ) { return Number L ; } * ( _QWORD * ) ( @@int64@@ + Number ) = & default_tuning ; return Number L ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
unsigned __int64 __fastcall re_node_set_contains ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( ( unsigned __int64 ) ( * ( _QWORD * ) ( @@int64@@ + Number ) - Number L ) > Number ) return Number L ; @@unsignedint64@@ = Number L ; @@unsignedint64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) - Number L ; while ( @@unsignedint64@@ < @@unsignedint64@@ ) { if ( @@unsignedint64@@ <= * ( _QWORD * ) ( Number * ( ( @@unsignedint64@@ + @@unsignedint64@@ ) >> Number ) + * ( _QWORD * ) ( @@int64@@ + Number ) ) ) @@unsignedint64@@ = ( @@unsignedint64@@ + @@unsignedint64@@ ) >> Number ; else @@unsignedint64@@ = ( ( @@unsignedint64@@ + @@unsignedint64@@ ) >> Number ) + Number ; } if ( @@unsignedint64@@ == * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ) @@unsignedint64@@ = @@unsignedint64@@ + Number ; else @@unsignedint64@@ = Number L ; return @@unsignedint64@@ ; }
void * __fastcall mdir_name ( _BYTE * @@BYTE@@ ) { _BYTE * @@BYTE@@ ; void * @@void@@ ; @@BYTE@@ = dir_len ( @@BYTE@@ ) ; @@void@@ = malloc ( ( size_t ) & @@BYTE@@ [ ( @@BYTE@@ == Number L ) + Number ] ) ; if ( ! @@void@@ ) return Number L ; memcpy ( @@void@@ , @@BYTE@@ , ( size_t ) @@BYTE@@ ) ; if ( ! @@BYTE@@ ) { @@BYTE@@ = ( _BYTE * ) ( & dword_0 + Number ) ; * ( _BYTE * ) @@void@@ = Number ; } @@BYTE@@ [ ( _QWORD ) @@void@@ ] = Number ; return @@void@@ ; }
_QWORD * __fastcall re_acquire_state ( _DWORD * @@DWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; unsigned __int64 * @@unsignedint64@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) { @@int64@@ = calc_state_hash ( @@int64@@ , Number ) ; @@unsignedint64@@ = ( unsigned __int64 * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * ( @@int64@@ & * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * @@unsignedint64@@ ; ++ @@unsignedint64@@ ) { @@QWORD@@ = * ( _QWORD * * ) ( Number * @@unsignedint64@@ + @@unsignedint64@@ [ Number ] ) ; if ( @@int64@@ == * @@QWORD@@ && ( unsigned __int8 ) re_node_set_compare ( ( __int64 ) ( @@QWORD@@ + Number ) , @@int64@@ ) ) { return @@QWORD@@ ; } } @@int64@@ = create_ci_newstate ( @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( ! @@int64@@ ) * @@DWORD@@ = Number ; @@QWORD@@ = ( _QWORD * ) @@int64@@ ; } else { * @@DWORD@@ = Number ; @@QWORD@@ = Number L ; } return @@QWORD@@ ; }
char * __fastcall create_ci_newstate ( _QWORD * @@QWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { char * @@char@@ ; int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; char * @@char@@ ; __int64 @@int64@@ ; @@char@@ = ( char * ) calloc ( Number , Number ) ; if ( ! @@char@@ ) return Number L ; if ( ( unsigned int ) re_node_set_init_copy ( @@char@@ + Number , @@int64@@ ) ) { free ( @@char@@ ) ; @@char@@ = Number L ; } else { * ( ( _QWORD * ) @@char@@ + Number ) = @@char@@ + Number ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { @@int64@@ = * @@QWORD@@ + Number L * * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; @@int@@ = * ( unsigned __int8 * ) ( @@int64@@ + Number ) ; if ( @@int@@ != Number || ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number ) { @@char@@ [ Number ] = ( Number * ( ( * ( _BYTE * ) ( @@int64@@ + Number ) & Number ) != Number || ( @@char@@ [ Number ] & Number ) != Number ) ) | @@char@@ [ Number ] & Number ; if ( @@int@@ == Number ) { @@char@@ [ Number ] |= Number ; } else if ( @@int@@ == Number ) { @@char@@ [ Number ] |= Number ; } else if ( @@int@@ == Number || ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number ) { @@char@@ [ Number ] |= Number ; } } } if ( ( unsigned int ) register_state ( @@QWORD@@ , @@char@@ , @@int64@@ ) ) { free_state ( ( void * * ) @@char@@ ) ; @@char@@ = Number L ; } @@char@@ = @@char@@ ; } return @@char@@ ; }
__int64 __fastcall hash_find_entry ( __int64 @@int64@@ , __int64 @@int64@@ , _QWORD * @@QWORD@@ , char @@char@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; @@int64@@ = * ( _QWORD * ) @@int64@@ ; @@QWORD@@ = ( _QWORD * ) ( @@int64@@ + Number * ( * ( __int64 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@int64@@ + Number ) ) ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@QWORD@@ >= * ( _QWORD * ) ( @@int64@@ + Number ) ) abort ( ) ; * @@QWORD@@ = @@QWORD@@ ; if ( ! * @@QWORD@@ ) return Number L ; if ( @@int64@@ == * @@QWORD@@ || ( * ( unsigned __int8 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@int64@@ + Number ) ) ( @@int64@@ , * @@QWORD@@ ) ) { @@int64@@ = * @@QWORD@@ ; if ( @@char@@ ) { if ( @@QWORD@@ [ Number ] ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; @@int64@@ = @@QWORD@@ [ Number ] ; * @@QWORD@@ = * @@QWORD@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; free_entry ( @@int64@@ , @@QWORD@@ ) ; } else { * @@QWORD@@ = Number L ; } } @@int64@@ = @@int64@@ ; } else { for ( @@QWORD@@ = @@QWORD@@ ; ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { if ( ! @@QWORD@@ [ Number ] ) return Number L ; if ( @@int64@@ == * ( _QWORD * ) @@QWORD@@ [ Number ] || ( * ( unsigned __int8 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@int64@@ + Number ) ) ( @@int64@@ , * ( _QWORD * ) @@QWORD@@ [ Number ] ) ) { break ; } } @@int64@@ = * ( _QWORD * ) @@QWORD@@ [ Number ] ; if ( @@char@@ ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = @@QWORD@@ [ Number ] ; free_entry ( @@int64@@ , @@QWORD@@ ) ; } @@int64@@ = @@int64@@ ; } return @@int64@@ ; }
_BOOL8 __fastcall hash_table_ok ( __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; @@int64@@ = Number L ; @@int64@@ = Number L ; for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { @@QWORD@@ = @@QWORD@@ ; ++ @@int64@@ ; ++ @@int64@@ ; while ( Number ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; if ( ! @@QWORD@@ ) break ; ++ @@int64@@ ; } } } return @@int64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) && @@int64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
__int64 __fastcall rpl_re_set_syntax ( __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = rpl_re_syntax_options ; rpl_re_syntax_options = @@int64@@ ; return @@int64@@ ; }
__int64 __fastcall optimize_subexps ( __int64 @@int64@@ , __int64 @@int64@@ ) { unsigned __int64 @@unsignedint64@@ ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) == Number && * ( _QWORD * ) ( @@int64@@ + Number ) ) { * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( Number L * ( int ) * ( _QWORD * ) ( @@int64@@ + Number ) + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; * ( _QWORD * ) ( @@int64@@ + Number ) |= Number << * ( _QWORD * ) ( @@int64@@ + Number ) ; } else if ( * ( _BYTE * ) ( @@int64@@ + Number ) == Number && * ( _QWORD * ) ( @@int64@@ + Number ) && * ( _BYTE * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) == Number ) { @@unsignedint64@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) * * ( _QWORD * * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@unsignedint64@@ ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L * * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= Number ) * ( _QWORD * ) ( @@int64@@ + Number ) &= ~ ( Number L << @@unsignedint64@@ ) ; } return Number L ; }
_BYTE * __fastcall mkancesdirs ( char * @@char@@ , _DWORD * @@DWORD@@ , __int64 ( __fastcall * @ @ VAR_1520 @ @ int64 ( fastcall ) ( char , char , int64 ) @ @ int ( ) ( constchar , constchar , void ) ) ( char * , char * , __int64 ) , __int64 @@int64@@ , int @@int@@ , int @@int@@ ) { int @@int@@ ; char * @@char@@ ; char @@char@@ ; char @@char@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; @@char@@ = Number L ; @@char@@ = @@char@@ ; @@char@@ = @@char@@ ; @@char@@ = Number ; while ( Number ) { do { while ( Number ) { @@char@@ = @@char@@ ++ ; @@char@@ = * @@char@@ ; if ( ! * @@char@@ ) return ( _BYTE * ) ( @@char@@ - @@char@@ ) ; if ( * @@char@@ != Number ) break ; if ( @@char@@ != Number ) @@char@@ = @@char@@ ; } } while ( @@char@@ != Number || ! * @@char@@ || ! @@char@@ ) ; if ( @@char@@ - @@char@@ != Number || * @@char@@ != Number ) break ; LABEL_29 : @@char@@ = @@char@@ ; } @@int@@ = Number ; @@int@@ = Number ; * @@char@@ = Number ; if ( @@char@@ - @@char@@ == Number && * @@char@@ == Number && @@char@@ [ Number ] == Number ) { @@char@@ = Number ; goto LABEL_20 ; } @@int@@ = @ @ VAR_1520 @ @ int64 ( fastcall ) ( char , char , int64 ) @ @ int ( ) ( constchar , constchar , void ) ( @@char@@ , @@char@@ , @@int64@@ ) ; switch ( @@int@@ ) { case Number : @@int@@ = Number ; goto LABEL_19 ; case Number : LABEL_19 : @@char@@ = Number ; break ; case Number : @@int@@ = * __errno_location ( ) ; break ; } LABEL_20 : if ( @@char@@ ) @@int@@ |= Number ; @@int@@ = savewd_chdir ( @@DWORD@@ , ( __int64 ) @@char@@ , @@int@@ , Number L , @@int@@ , @@int@@ ) ; if ( @@int@@ != Number ) * @@char@@ = Number ; if ( ! @@int@@ ) goto LABEL_29 ; if ( @@int@@ && * __errno_location ( ) == Number ) * __errno_location ( ) = @@int@@ ; return ( _BYTE * ) @@int@@ ; }
void * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
unsigned __int64 __fastcall hash_get_entries ( __int64 @@int64@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; @@unsignedint64@@ = Number L ; for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { for ( @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { if ( @@unsignedint64@@ >= @@unsignedint64@@ ) return @@unsignedint64@@ ; @@int64@@ = @@unsignedint64@@ ++ ; * ( _QWORD * ) ( @@int64@@ + Number * @@int64@@ ) = * @@QWORD@@ ; } } } return @@unsignedint64@@ ; }
void * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
__int64 __fastcall calc_next ( __int64 a1 , __int64 @@int64@@ ) { int @@int@@ ; @@int@@ = * ( unsigned __int8 * ) ( @@int64@@ + Number ) ; if ( @@int@@ == Number ) { * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) = @@int64@@ ; } else if ( @@int@@ == Number ) { * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) ; * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; } else { if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; } return Number L ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 __fastcall rpl_re_compile_fastmap ( __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; void * @@void@@ ; @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; @@void@@ = * ( void * * ) ( @@int64@@ + Number ) ; memset ( @@void@@ , Number , Number ) ; re_compile_fastmap_iter ( @@int64@@ , @@QWORD@@ [ Number ] , @@void@@ ) ; if ( @@QWORD@@ [ Number ] != @@QWORD@@ [ Number ] ) re_compile_fastmap_iter ( @@int64@@ , @@QWORD@@ [ Number ] , @@void@@ ) ; if ( @@QWORD@@ [ Number ] != @@QWORD@@ [ Number ] ) re_compile_fastmap_iter ( @@int64@@ , @@QWORD@@ [ Number ] , @@void@@ ) ; if ( @@QWORD@@ [ Number ] != @@QWORD@@ [ Number ] ) re_compile_fastmap_iter ( @@int64@@ , @@QWORD@@ [ Number ] , @@void@@ ) ; * ( _BYTE * ) ( @@int64@@ + Number ) |= Number ; return Number L ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
void * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_222168 ; @@int648@@ [ Number ] = qword_222170 ; @@int648@@ [ Number ] = qword_222178 ; @@int648@@ [ Number ] = qword_222180 ; @@int648@@ [ Number ] = qword_222188 ; @@int648@@ [ Number ] = qword_222190 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
__int64 __fastcall peek_token_bracket ( _BYTE * @@BYTE@@ , __int64 @@int64@@ , char @@char@@ ) { char @@char@@ ; char @@char@@ ; unsigned int @@unsignedint@@ ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) <= * ( _QWORD * ) ( @@int64@@ + Number ) ) { @@BYTE@@ [ Number ] = Number ; return Number L ; } @@char@@ = * ( _BYTE * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; * @@BYTE@@ = @@char@@ ; if ( * ( int * ) ( @@int64@@ + Number ) > Number && * ( _QWORD * ) ( @@int64@@ + Number ) != * ( _QWORD * ) ( @@int64@@ + Number ) && * ( _DWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L * * ( _QWORD * ) ( @@int64@@ + Number ) ) == Number ) { @@BYTE@@ [ Number ] = Number ; return Number L ; } if ( @@char@@ == Number && ( @@char@@ & Number ) != Number && ( unsigned __int64 ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) < * ( _QWORD * ) ( @@int64@@ + Number ) ) { ++ * ( _QWORD * ) ( @@int64@@ + Number ) ; * @@BYTE@@ = * ( _BYTE * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; @@BYTE@@ [ Number ] = Number ; return Number L ; } switch ( @@char@@ ) { case String : if ( ( unsigned __int64 ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) >= * ( _QWORD * ) ( @@int64@@ + Number ) ) @@char@@ = Number ; else @@char@@ = * ( _BYTE * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) ; * @@BYTE@@ = @@char@@ ; @@unsignedint@@ = Number ; switch ( @@char@@ ) { case String : if ( ( @@char@@ & Number ) != Number ) { @@BYTE@@ [ Number ] = Number ; return @@unsignedint@@ ; } break ; case String : @@BYTE@@ [ Number ] = Number ; return @@unsignedint@@ ; case String : @@BYTE@@ [ Number ] = Number ; return @@unsignedint@@ ; } @@BYTE@@ [ Number ] = Number ; * @@BYTE@@ = Number ; return Number ; case String : @@BYTE@@ [ Number ] = Number ; break ; case String : @@BYTE@@ [ Number ] = Number ; break ; case String : @@BYTE@@ [ Number ] = Number ; break ; default : @@BYTE@@ [ Number ] = Number ; break ; } return Number L ; }
__int64 __fastcall next_prime ( unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = @@unsignedint64@@ ; if ( @@unsignedint64@@ <= Number ) @@int64@@ = Number L ; for ( @@int64@@ = @@int64@@ | Number ; @@int64@@ != Number && ! is_prime ( @@int64@@ ) ; @@int64@@ += Number L ) { ; } return @@int64@@ ; }
__int64 __fastcall postorder ( _QWORD * @@QWORD@@ , __int64 ( __fastcall * @ @ VAR_978 @ @ int64 ( fastcall ) ( int64 , QWORD ) @ @ regerrcodet ( ) ( void , bintreet0 ) ) ( __int64 , _QWORD * ) , __int64 @@int64@@ ) { unsigned int @@unsignedint@@ ; _QWORD * @@QWORD@@ ; LABEL_5 : while ( @@QWORD@@ [ Number ] || @@QWORD@@ [ Number ] ) { if ( @@QWORD@@ [ Number ] ) @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; else @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; } while ( Number ) { @@unsignedint@@ = @ @ VAR_978 @ @ int64 ( fastcall ) ( int64 , QWORD ) @ @ regerrcodet ( ) ( void , bintreet0 ) ( @@int64@@ , @@QWORD@@ ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; if ( ! * @@QWORD@@ ) return Number L ; @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) * @@QWORD@@ ; if ( @@QWORD@@ != ( _QWORD * ) @@QWORD@@ [ Number ] && @@QWORD@@ [ Number ] ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; goto LABEL_5 ; } } }
__int64 __fastcall get_stat_mtime_ns ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
_BOOL8 __fastcall same_name ( _BYTE * @@BYTE@@ , _BYTE * @@BYTE@@ ) { bool @@bool@@ ; int * @@int@@ ; int * @@int@@ ; bool @@bool@@ ; bool @@bool@@ ; const char * @@constchar@@ ; const char * @@constchar@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; char * @@char@@ ; char * @@char@@ ; struct stat @@structstat@@ ; struct stat @@structstat@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@constchar@@ = last_component ( @@BYTE@@ ) ; @@constchar@@ = last_component ( @@BYTE@@ ) ; @@sizet@@ = base_len ( @@constchar@@ ) ; @@sizet@@ = base_len ( @@constchar@@ ) ; @@bool@@ = @@sizet@@ == @@sizet@@ && ! memcmp ( @@constchar@@ , @@constchar@@ , @@sizet@@ ) ; @@bool@@ = Number ; if ( @@bool@@ ) { @@char@@ = ( char * ) dir_name ( ( __int64 ) @@BYTE@@ ) ; @@char@@ = ( char * ) dir_name ( ( __int64 ) @@BYTE@@ ) ; if ( ( unsigned int ) stat ( @@char@@ , & @@structstat@@ ) ) { @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , String , @@char@@ ) ; } if ( ( unsigned int ) stat ( @@char@@ , & @@structstat@@ ) ) { @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , String , @@char@@ ) ; } @@bool@@ = @@structstat@@ . st_ino == @@structstat@@ . st_ino && @@structstat@@ . st_dev == @@structstat@@ . st_dev ; @@bool@@ = @@bool@@ ; free ( @@char@@ ) ; free ( @@char@@ ) ; } return @@bool@@ ; }
bool __fastcall dev_info_compare ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ ) { return * @@QWORD@@ == * @@QWORD@@ ; }
__int64 __fastcall lower_subexps ( __int64 @@int64@@ , __int64 @@int64@@ ) { unsigned int @@unsignedint@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = @@int64@@ ; @@unsignedint@@ = Number ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) { if ( * ( _BYTE * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) == Number ) { * ( _QWORD * ) ( @@int64@@ + Number ) = lower_subexp ( & @@unsignedint@@ , @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) * * ( _QWORD * * ) ( @@int64@@ + Number ) = @@int64@@ ; } } if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) { if ( * ( _BYTE * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) == Number ) { * ( _QWORD * ) ( @@int64@@ + Number ) = lower_subexp ( & @@unsignedint@@ , @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) * * ( _QWORD * * ) ( @@int64@@ + Number ) = @@int64@@ ; } } return @@unsignedint@@ ; }
size_t * __fastcall hash_initialize ( __int64 @@int64@@ , void * @@void@@ , unsigned __int64 ( __fastcall * @ @ VAR_1367 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ) ( __int64 a1 , unsigned __int64 a2 ) , bool ( __fastcall * @ @ VAR_1369 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ) ( __int64 a1 , __int64 a2 ) , size_t @@sizet@@ ) { size_t * @@sizet@@ ; bool ( __fastcall * @ @ VAR_1368 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ) ( __int64 , __int64 ) ; unsigned __int64 ( __fastcall * @ @ VAR_1366 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ) ( __int64 , unsigned __int64 ) ; void * @@void@@ ; size_t * @@sizet@@ ; @@void@@ = @@void@@ ; @ @ VAR_1366 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher = @ @ VAR_1367 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ; @ @ VAR_1368 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator = @ @ VAR_1369 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ; if ( ! @ @ VAR_1367 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ) @ @ VAR_1366 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher = raw_hasher ; if ( ! @ @ VAR_1369 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ) @ @ VAR_1368 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator = raw_comparator ; @@sizet@@ = ( size_t * ) malloc ( Number ) ; if ( ! @@sizet@@ ) return Number L ; if ( ! @@void@@ ) @@void@@ = & default_tuning ; @@sizet@@ [ Number ] = ( size_t ) @@void@@ ; if ( ( unsigned __int8 ) check_tuning ( ( __int64 ) @@sizet@@ ) == Number && ( @@sizet@@ [ Number ] = compute_bucket_size ( @@int64@@ , ( __int64 ) @@void@@ ) ) != Number && ( * @@sizet@@ = ( size_t ) calloc ( @@sizet@@ [ Number ] , Number ) ) != Number ) { @@sizet@@ [ Number ] = Number * @@sizet@@ [ Number ] + * @@sizet@@ ; @@sizet@@ [ Number ] = Number L ; @@sizet@@ [ Number ] = Number L ; @@sizet@@ [ Number ] = ( size_t ) @ @ VAR_1366 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ; @@sizet@@ [ Number ] = ( size_t ) @ @ VAR_1368 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ; @@sizet@@ [ Number ] = @@sizet@@ ; @@sizet@@ [ Number ] = Number L ; @@sizet@@ = @@sizet@@ ; } else { free ( @@sizet@@ ) ; @@sizet@@ = Number L ; } return @@sizet@@ ; }
__int64 __fastcall build_charclass_op ( __int64 @@int64@@ , __int64 @@int64@@ , const char * @@constchar@@ , _BYTE * @@BYTE@@ , char @@char@@ , _DWORD * @@DWORD@@ ) { int @@int@@ ; __int64 @@int64@@ ; void * @@void@@ ; _BYTE * @@BYTE@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; void * @@void@@ ; char @@char@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = Number L ; @@void@@ = calloc ( Number , Number ) ; @@BYTE@@ = calloc ( Number , Number ) ; if ( ! @@void@@ || ! @@BYTE@@ ) { * @@DWORD@@ = Number ; return Number L ; } if ( @@char@@ ) @@BYTE@@ [ Number ] |= Number ; @@int@@ = build_charclass ( @@int64@@ , ( __int64 ) @@void@@ , ( __int64 ) @@BYTE@@ , & @@int64@@ , @@constchar@@ , Number ) ; if ( @@int@@ ) { free ( @@void@@ ) ; free_charset ( @@BYTE@@ ) ; * @@DWORD@@ = @@int@@ ; return Number L ; } while ( * @@BYTE@@ ) bitset_set ( ( __int64 ) @@void@@ , ( unsigned __int8 ) * @@BYTE@@ ++ ) ; if ( @@char@@ ) bitset_not ( ( __int64 ) @@void@@ ) ; if ( * ( int * ) ( @@int64@@ + Number ) > Number ) bitset_mask ( ( __int64 ) @@void@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ; @@char@@ = Number ; @@void@@ = @@void@@ ; @@int64@@ = create_token_tree ( @@int64@@ , Number L , Number L , & @@void@@ ) ; if ( @@int64@@ ) { if ( * ( int * ) ( @@int64@@ + Number ) <= Number ) { free_charset ( @@BYTE@@ ) ; return @@int64@@ ; } @@char@@ = Number ; @@void@@ = @@BYTE@@ ; * ( _BYTE * ) ( @@int64@@ + Number ) |= Number ; @@int64@@ = create_token_tree ( @@int64@@ , Number L , Number L , & @@void@@ ) ; if ( @@int64@@ ) { @@int64@@ = create_tree ( @@int64@@ , @@int64@@ , @@int64@@ , Number L ) ; if ( @@int64@@ ) return @@int64@@ ; } } free ( @@void@@ ) ; free_charset ( @@BYTE@@ ) ; * @@DWORD@@ = Number ; return Number L ; }
__int64 __fastcall get_stat_mtime_1 ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 __fastcall x2nrealloc ( __int64 @@int64@@ , unsigned __int64 * @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = * @@unsignedint64@@ ; if ( @@int64@@ ) { if ( @@unsignedint64@@ >= Number / @@unsignedint64@@ ) xalloc_die ( ) ; @@unsignedint64@@ += ( @@unsignedint64@@ + Number ) >> Number ; } else if ( ! @@unsignedint64@@ ) { @@unsignedint64@@ = ( Number / @@unsignedint64@@ == Number ) + Number / @@unsignedint64@@ ; } * @@unsignedint64@@ = @@unsignedint64@@ ; return xrealloc ( @@int64@@ , @@unsignedint64@@ * @@unsignedint64@@ ) ; }
int __fastcall utimens ( char * @@char@@ , __int64 * @@int64@@ ) { return fdutimens ( @@char@@ , Number , @@int64@@ ) ; }
__int64 __fastcall rpl_re_match_2 ( int @@int@@ , int @@int@@ , int @@int@@ , int @@int@@ , int @@int@@ , int @@int@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return re_search_2_stub ( @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int@@ , Number L , @@int64@@ , @@int64@@ , Number ) ; }
__int64 __fastcall linkat_follow ( unsigned int @@unsignedint@@ , _BYTE * @@BYTE@@ , int @@int@@ , const char * @@constchar@@ ) { __int64 @@int64@@ ; int @@int@@ ; int @@int@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; @@BYTE@@ = @@BYTE@@ ; @@int@@ = Number ; while ( @@int@@ -- ) { @@BYTE@@ = ( _BYTE * ) areadlinkat ( @@unsignedint@@ , @@BYTE@@ ) ; if ( ! @@BYTE@@ ) break ; if ( * @@BYTE@@ == Number ) { if ( @@BYTE@@ != @@BYTE@@ ) free ( @@BYTE@@ ) ; @@BYTE@@ = @@BYTE@@ ; } else { @@BYTE@@ = mdir_name ( @@BYTE@@ ) ; if ( @@BYTE@@ != @@BYTE@@ ) free ( @@BYTE@@ ) ; if ( ! @@BYTE@@ ) { free ( @@BYTE@@ ) ; * __errno_location ( ) = Number ; return Number ; } @@BYTE@@ = mfile_name_concat ( @@BYTE@@ , @@BYTE@@ , Number L ) ; free ( @@BYTE@@ ) ; free ( @@BYTE@@ ) ; if ( ! @@BYTE@@ ) { * __errno_location ( ) = Number ; return Number ; } } } if ( @@int@@ < Number ) { @@BYTE@@ = Number L ; * __errno_location ( ) = Number ; } if ( @@BYTE@@ || * __errno_location ( ) == Number ) { @@unsignedint@@ = linkat ( @@unsignedint@@ , @@BYTE@@ , @@int@@ , @@constchar@@ , Number ) ; if ( @@BYTE@@ != @@BYTE@@ ) { @@int@@ = * __errno_location ( ) ; free ( @@BYTE@@ ) ; * __errno_location ( ) = @@int@@ ; } @@int64@@ = @@unsignedint@@ ; } else { if ( @@BYTE@@ != @@BYTE@@ ) { @@int@@ = * __errno_location ( ) ; free ( @@BYTE@@ ) ; * __errno_location ( ) = @@int@@ ; } @@int64@@ = Number ; } return @@int64@@ ; }
__int64 __fastcall duplicate_node ( _QWORD * @@QWORD@@ , __int64 @@int64@@ , __int16 @@int16@@ ) { __int64 @@int64@@ ; @@int64@@ = re_dfa_add_node ( ( __int64 ) @@QWORD@@ , * ( _QWORD * ) ( Number * @@int64@@ + * @@QWORD@@ ) , * ( _QWORD * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) ) ; if ( @@int64@@ != Number ) { * ( _DWORD * ) ( * @@QWORD@@ + Number * @@int64@@ + Number ) = ( ( @@int16@@ & Number ) << Number ) | * ( _DWORD * ) ( * @@QWORD@@ + Number * @@int64@@ + Number ) & Number ; * ( _DWORD * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) = ( ( ( ( * ( _DWORD * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) >> Number ) & Number | ( * ( _DWORD * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) >> Number ) & Number ) & Number ) << Number ) | * ( _DWORD * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) & Number ; * ( _BYTE * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) |= Number ; * ( _QWORD * ) ( @@QWORD@@ [ Number ] + Number * @@int64@@ ) = @@int64@@ ; } return @@int64@@ ; }
_QWORD * __fastcall rpl_re_set_registers ( __int64 @@int64@@ , _QWORD * @@QWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; if ( @@int64@@ ) { * ( _BYTE * ) ( @@int64@@ + Number ) = * ( _BYTE * ) ( @@int64@@ + Number ) & Number | Number ; * @@QWORD@@ = @@int64@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; } else { * ( _BYTE * ) ( @@int64@@ + Number ) &= Number ; * @@QWORD@@ = Number L ; @@QWORD@@ [ Number ] = Number L ; @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ [ Number ] = @@QWORD@@ [ Number ] ; } return @@QWORD@@ ; }
__int64 __fastcall argmatch ( const char * @@constchar@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { __int64 @@int64@@ ; char @@char@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; size_t @@sizet@@ ; @@int64@@ = Number ; @@char@@ = Number ; @@sizet@@ = strlen ( @@constchar@@ ) ; for ( @@int64@@ = Number L ; * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; ++ @@int64@@ ) { if ( ! strncmp ( * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) , @@constchar@@ , @@sizet@@ ) ) { if ( @@sizet@@ == strlen ( * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) ) ) return @@int64@@ ; if ( @@int64@@ == Number ) { @@int64@@ = @@int64@@ ; } else if ( ! @@int64@@ || memcmp ( ( const void * ) ( @@sizet@@ * @@int64@@ + @@int64@@ ) , ( const void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) , @@sizet@@ ) ) { @@char@@ = Number ; } } } if ( @@char@@ ) @@int64@@ = Number ; else @@int64@@ = @@int64@@ ; return @@int64@@ ; }
size_t __fastcall rpl_vfprintf ( FILE * @@FILE@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { size_t @@sizet@@ ; size_t @@sizet@@ ; int @@int@@ ; size_t @@sizet@@ ; void * @@void@@ ; size_t @@sizet@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@sizet@@ = Number L ; @@void@@ = ( void * ) vasnprintf ( @@char@@ , & @@sizet@@ , @@int64@@ , @@int64@@ ) ; @@sizet@@ = @@sizet@@ ; if ( @@void@@ ) { @@sizet@@ = fwrite ( @@void@@ , Number , @@sizet@@ , @@FILE@@ ) ; if ( @@sizet@@ <= @@sizet@@ ) { if ( @@void@@ != @@char@@ ) free ( @@void@@ ) ; if ( @@sizet@@ <= Number ) { @@sizet@@ = @@sizet@@ ; } else { * __errno_location ( ) = Number ; fseterr ( @@FILE@@ ) ; @@sizet@@ = Number ; } } else { if ( @@void@@ != @@char@@ ) { @@int@@ = * __errno_location ( ) ; free ( @@void@@ ) ; * __errno_location ( ) = @@int@@ ; } @@sizet@@ = Number ; } } else { fseterr ( @@FILE@@ ) ; @@sizet@@ = Number ; } return @@sizet@@ ; }
__int64 __fastcall parse_reg_exp ( __int64 @@int64@@ , __int64 * @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , _DWORD * @@DWORD@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = * @@int64@@ ; @@int64@@ = parse_branch ( @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@DWORD@@ ) ; if ( * @@DWORD@@ && ! @@int64@@ ) return Number L ; while ( * ( _BYTE * ) ( @@int64@@ + Number ) == Number ) { fetch_token ( @@int64@@ , @@int64@@ , @@int64@@ | Number ) ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) == Number || * ( _BYTE * ) ( @@int64@@ + Number ) == Number || @@int64@@ && * ( _BYTE * ) ( @@int64@@ + Number ) == Number ) { @@int64@@ = Number L ; } else { @@int64@@ = parse_branch ( @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@DWORD@@ ) ; if ( * @@DWORD@@ && ! @@int64@@ ) return Number L ; } @@int64@@ = create_tree ( @@int64@@ , @@int64@@ , @@int64@@ , Number L ) ; if ( ! @@int64@@ ) { * @@DWORD@@ = Number ; return Number L ; } } return @@int64@@ ; }
__int64 __fastcall mode_adjust ( __int16 @@int16@@ , unsigned __int8 @@unsignedint8@@ , int @@int@@ , char * @@char@@ , _DWORD * @@DWORD@@ ) { int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; @@unsignedint@@ = @@int16@@ & Number ; @@int@@ = Number ; while ( @@char@@ [ Number ] ) { @@int@@ = * ( ( _DWORD * ) @@char@@ + Number ) ; if ( @@unsignedint8@@ ) @@int@@ = Number ; else @@int@@ = Number ; @@int@@ = @@int@@ & ~ * ( ( _DWORD * ) @@char@@ + Number ) ; @@int@@ = * ( ( _DWORD * ) @@char@@ + Number ) ; @@int@@ = @@char@@ [ Number ] ; if ( @@int@@ == Number ) { if ( @@unsignedint@@ & Number | @@unsignedint8@@ ) @@int@@ |= Number ; } else if ( @@int@@ == Number ) { @@int@@ = @@unsignedint@@ & @@int@@ ; if ( ( @@int@@ & Number ) != Number ) @@int@@ = Number ; else @@int@@ = Number ; if ( ( @@int@@ & Number ) != Number ) @@int@@ = Number ; else @@int@@ = Number ; @@int@@ = @@int@@ | @@int@@ ; if ( ( @@int@@ & Number ) != Number ) @@int@@ = Number ; else @@int@@ = Number ; @@int@@ = @@int@@ | @@int@@ | @@int@@ ; } if ( @@int@@ ) @@int@@ = * ( ( _DWORD * ) @@char@@ + Number ) ; else @@int@@ = ~ @@int@@ ; @@int@@ = ~ @@int@@ & @@int@@ & @@int@@ ; @@int@@ = * @@char@@ ; switch ( @@int@@ ) { case String : @@int@@ |= @@int@@ ; @@unsignedint@@ &= ~ @@int@@ ; break ; case String : if ( @@int@@ ) @@int@@ = ~ @@int@@ ; else @@int@@ = Number ; @@int@@ |= ~ ( ( unsigned __int16 ) @@int@@ | ( unsigned __int16 ) @@int@@ ) & Number ; @@unsignedint@@ = @@int@@ | ( @@int@@ | @@int@@ ) & @@unsignedint@@ ; break ; case String : @@int@@ |= @@int@@ ; @@unsignedint@@ |= @@int@@ ; break ; } @@char@@ += Number ; } if ( @@DWORD@@ ) * @@DWORD@@ = @@int@@ ; return @@unsignedint@@ ; }
__int64 __fastcall push_fail_stack ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , const void * @@constvoid@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; void * @@void@@ ; @@int64@@ = ( * ( _QWORD * ) @@int64@@ ) ++ ; @@int64@@ = @@int64@@ ; if ( * ( _QWORD * ) @@int64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ) { @@void@@ = realloc ( * ( void * * ) ( @@int64@@ + Number ) , Number L * * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( ! @@void@@ ) return Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) *= Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@void@@ ; } * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ ) = @@int64@@ ; * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ + Number ) = @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = malloc ( Number * @@int64@@ ) ; if ( ! * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ + Number ) ) return Number L ; memcpy ( * ( void * * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ + Number ) , @@constvoid@@ , Number * @@int64@@ ) ; return ( unsigned int ) re_node_set_init_copy ( ( void * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ + Number ) , @@int64@@ ) ; }
__int64 __fastcall get_stat_atime_ns ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 __fastcall argmatch_to_argument ( const void * @@constvoid@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; ++ @@int64@@ ) { if ( ! memcmp ( @@constvoid@@ , ( const void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) , @@sizet@@ ) ) return * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; } return Number L ; }
__int64 __fastcall freadahead ( __int64 @@int64@@ ) { __int64 @@int64@@ ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) > * ( _QWORD * ) ( @@int64@@ + Number ) ) return Number L ; if ( ( * ( _DWORD * ) @@int64@@ & Number ) != Number ) @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) - * ( _QWORD * ) ( @@int64@@ + Number ) ; else @@int64@@ = Number L ; return * ( _QWORD * ) ( @@int64@@ + Number ) - * ( _QWORD * ) ( @@int64@@ + Number ) + @@int64@@ ; }
__int64 __fastcall parse_bracket_symbol ( __int64 @@int64@@ , _QWORD * @@QWORD@@ , char * @@char@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; int @@int@@ ; char @@char@@ ; char @@char@@ ; int @@int@@ ; @@char@@ = * @@char@@ ; @@int@@ = Number ; if ( @@QWORD@@ [ Number ] <= @@QWORD@@ [ Number ] ) return Number L ; while ( Number ) { if ( @@int@@ > Number ) return Number L ; if ( @@char@@ [ Number ] == Number ) { @@char@@ = re_string_fetch_byte_case ( ( __int64 ) @@QWORD@@ ) ; } else { @@int64@@ = @@QWORD@@ [ Number ] ; @@int64@@ = @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ + Number ; @@char@@ = * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) ; } if ( @@QWORD@@ [ Number ] <= @@QWORD@@ [ Number ] ) return Number L ; if ( @@char@@ == @@char@@ && * ( _BYTE * ) ( @@QWORD@@ [ Number ] + @@QWORD@@ [ Number ] ) == Number ) { break ; } * ( _BYTE * ) ( @@int@@ ++ + * ( _QWORD * ) ( @@int64@@ + Number ) ) = @@char@@ ; } ++ @@QWORD@@ [ Number ] ; * ( _BYTE * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + @@int@@ ) = Number ; @@int@@ = ( unsigned __int8 ) @@char@@ [ Number ] ; switch ( @@int@@ ) { case Number : * ( _DWORD * ) @@int64@@ = Number ; break ; case Number : * ( _DWORD * ) @@int64@@ = Number ; break ; case Number : * ( _DWORD * ) @@int64@@ = Number ; break ; } return Number L ; }
__int64 __fastcall get_stat_ctime_ns ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
_BOOL8 __fastcall rpl_isnanl ( __int64 a1 , __int64 a2 , __int64 a3 , __int64 a4 , __int64 a5 , __int64 a6 , __int128 @@int128@@ ) { if ( ( WORD4 ( @@int128@@ ) & Number ) == Number ) return DWORD1 ( @@int128@@ ) >> Number ; if ( ( WORD4 ( @@int128@@ ) & Number ) == Number ) return ( DWORD1 ( @@int128@@ ) ^ Number | ( unsigned int ) @@int128@@ ) != Number ; return ( DWORD1 ( @@int128@@ ) & Number ) == Number ; }
__int64 __fastcall build_sifted_states ( __int64 @@int64@@ , _QWORD * @@QWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@QWORD@@ = * ( _QWORD * * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( Number * @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) + Number L ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { @@unsignedint64@@ = * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; @@int@@ = Number ; if ( ( * ( _BYTE * ) ( Number * @@unsignedint64@@ + * @@QWORD@@ + Number ) & Number ) != Number ) @@int@@ = sift_states_iter_mb ( @@int64@@ , @@QWORD@@ , @@unsignedint64@@ , @@int64@@ , @@QWORD@@ [ Number ] ) ; if ( ! @@int@@ && ( unsigned __int8 ) check_node_accept ( @@int64@@ , * @@QWORD@@ + Number * @@unsignedint64@@ , @@int64@@ ) && * ( _QWORD * ) ( Number * ( @@int64@@ + Number ) + * @@QWORD@@ ) && re_node_set_contains ( * ( _QWORD * ) ( Number * ( @@int64@@ + Number ) + * @@QWORD@@ ) + Number L , * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@QWORD@@ [ Number ] ) ) ) { @@int@@ = Number ; } if ( @@int@@ && ( ! @@QWORD@@ [ Number ] || ! ( unsigned __int8 ) check_dst_limits ( @@int64@@ , @@QWORD@@ + Number , * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@QWORD@@ [ Number ] ) , @@int@@ + @@int64@@ , @@unsignedint64@@ , @@int64@@ ) ) && ! re_node_set_insert ( @@int64@@ , @@unsignedint64@@ ) ) { return Number L ; } } return Number L ; }
int __fastcall argmatch_valid ( __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { char * @@char@@ ; __int64 @@int64@@ ; void * @@void@@ ; @@void@@ = Number L ; @@char@@ = gettext ( String ) ; fprintf ( stderr , @@char@@ ) ; for ( @@int64@@ = Number L ; * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; ++ @@int64@@ ) { if ( @@int64@@ && ! memcmp ( @@void@@ , ( const void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) , @@sizet@@ ) ) { fprintf ( stderr , String , * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) ) ; } else { fprintf ( stderr , String , * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) ) ; @@void@@ = ( void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) ; } } return putc_unlocked ( Number , stderr ) ; }
unsigned __int64 __fastcall dev_info_hash ( _QWORD * @@QWORD@@ , unsigned __int64 @@unsignedint64@@ ) { return * @@QWORD@@ % @@unsignedint64@@ ; }
_QWORD * __fastcall mpz_sub ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { _QWORD * @@QWORD@@ ; if ( * @@QWORD@@ < * @@QWORD@@ - * @@int64@@ != * @@int64@@ < Number ) integer_overflow ( Number L ) ; @@QWORD@@ = @@QWORD@@ ; * @@QWORD@@ = * @@QWORD@@ - * @@int64@@ ; return @@QWORD@@ ; }
__int64 __fastcall create_token_tree ( __int64 @@int64@@ , __int64 * @@int64@@ , __int64 * @@int64@@ , _QWORD * @@QWORD@@ ) { __int64 @@int64@@ ; int @@int@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; if ( * ( _DWORD * ) ( @@int64@@ + Number ) == Number ) { @@QWORD@@ = malloc ( Number ) ; if ( ! @@QWORD@@ ) return Number L ; * @@QWORD@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@QWORD@@ ; * ( _DWORD * ) ( @@int64@@ + Number ) = Number ; } @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) ; * ( _DWORD * ) ( @@int64@@ + Number ) = @@int@@ + Number ; @@int64@@ = @@int64@@ + ( ( __int64 ) @@int@@ << Number ) + Number ; * ( _QWORD * ) @@int64@@ = Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; @@int64@@ = @@QWORD@@ [ Number ] ; * ( _QWORD * ) ( @@int64@@ + Number ) = * @@QWORD@@ ; * ( _QWORD * ) ( @@int64@@ + ( ( __int64 ) @@int@@ << Number ) + Number ) = @@int64@@ ; * ( _BYTE * ) ( @@int64@@ + Number ) &= Number ; * ( _BYTE * ) ( @@int64@@ + Number ) &= Number ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number ; if ( @@int64@@ ) * @@int64@@ = @@int64@@ ; if ( @@int64@@ ) * @@int64@@ = @@int64@@ ; return @@int64@@ + ( ( __int64 ) @@int@@ << Number ) + Number ; }
__int64 __fastcall get_stat_atime_1 ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
unsigned __int64 __fastcall xmax ( unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint64@@ ; if ( @@unsignedint64@@ >= @@unsignedint64@@ ) @@unsignedint64@@ = @@unsignedint64@@ ; return @@unsignedint64@@ ; }
__int64 __fastcall mpz_sgn ( __int64 * @@int64@@ ) { __int64 @@int64@@ ; if ( * @@int64@@ < Number ) @@int64@@ = Number ; else @@int64@@ = * @@int64@@ > Number ; return @@int64@@ ; }
__int64 __fastcall check_halt_state_context ( __int64 @@int64@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { char @@char@@ ; unsigned __int64 @@unsignedint64@@ ; @@char@@ = re_string_context_at ( @@int64@@ , @@unsignedint64@@ , * ( _DWORD * ) ( @@int64@@ + Number ) ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { if ( check_halt_node_context ( * ( _QWORD * * ) ( @@int64@@ + Number ) , * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) , @@char@@ ) ) { return * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; } } return Number L ; }
int __fastcall gl_futimens ( int @@int@@ , char * @@char@@ , __int64 * @@int64@@ ) { return fdutimens ( @@char@@ , @@int@@ , @@int64@@ ) ; }
__int64 __fastcall xsum_0 ( unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; if ( @@unsignedint64@@ + @@int64@@ < @@unsignedint64@@ ) @@int64@@ = Number ; else @@int64@@ = @@unsignedint64@@ + @@int64@@ ; return @@int64@@ ; }
__int64 __fastcall check_dst_limits ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; @@QWORD@@ = * ( _QWORD * * ) ( @@int64@@ + Number ) ; @@int64@@ = search_cur_bkref_entry ( @@int64@@ , @@int64@@ ) ; @@int64@@ = search_cur_bkref_entry ( @@int64@@ , @@int64@@ ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { @@int64@@ = * ( _QWORD * ) ( * @@QWORD@@ + Number L * * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L * * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ) ; @@int64@@ = ( int ) check_dst_limits_calc_pos ( @@int64@@ , * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) , @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( ( int ) check_dst_limits_calc_pos ( @@int64@@ , * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) , @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ ) != @@int64@@ ) return Number L ; } return Number L ; }
__int64 __fastcall str_value ( __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = xmalloc ( Number L ) ; * ( _DWORD * ) @@int64@@ = Number ; * ( _QWORD * ) ( @@int64@@ + Number ) = xstrdup ( @@int64@@ ) ; return @@int64@@ ; }
__int64 __fastcall mpz_init_set_str ( __int64 @@int64@@ , __int64 @@int64@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; if ( ( unsigned int ) xstrtoimax ( @@int64@@ , Number L , @@unsignedint@@ , @@int64@@ , Number L ) ) @@int64@@ = Number ; else @@int64@@ = Number L ; return @@int64@@ ; }
__int64 __fastcall pop_fail_stack ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ , __int64 @@int64@@ , void * @@void@@ , __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = -- * @@QWORD@@ ; if ( * @@QWORD@@ > Number ) __assert_fail ( String , String , Number , String ) ; * @@QWORD@@ = * ( _QWORD * ) ( @@QWORD@@ [ Number ] + Number * @@int64@@ ) ; memcpy ( @@void@@ , * ( const void * * ) ( @@QWORD@@ [ Number ] + Number * @@int64@@ + Number ) , Number * @@int64@@ ) ; free ( * ( void * * ) ( @@int64@@ + Number ) ) ; free ( * ( void * * ) ( @@QWORD@@ [ Number ] + Number * @@int64@@ + Number ) ) ; @@QWORD@@ = ( _QWORD * ) ( @@QWORD@@ [ Number ] + Number * @@int64@@ ) ; @@int64@@ = @@QWORD@@ [ Number ] ; * ( _QWORD * ) @@int64@@ = @@QWORD@@ [ Number ] ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@QWORD@@ [ Number ] ; return * ( _QWORD * ) ( @@QWORD@@ [ Number ] + Number * @@int64@@ + Number ) ; }
int __fastcall lutimens ( char * @@char@@ , __int64 * @@int64@@ ) { struct timespec * @@structtimespec@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; struct timespec * @@structtimespec@@ ; __syscall_slong_t @@syscallslongt@@ ; struct timespec * @@structtimespec@@ ; __syscall_slong_t @@syscallslongt@@ ; int @@int@@ ; int @@int@@ ; struct timespec * @@structtimespec@@ ; __int64 @@int64@@ [ Number ] ; struct stat @@structstat@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( @@int64@@ ) @@structtimespec@@ = ( struct timespec * ) @@int64@@ ; else @@structtimespec@@ = Number L ; @@structtimespec@@ = @@structtimespec@@ ; @@int@@ = Number ; if ( @@structtimespec@@ ) { @@int64@@ = @@int64@@ [ Number ] ; @@int64@@ [ Number ] = * @@int64@@ ; @@int64@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int64@@ [ Number ] ; @@int64@@ [ Number ] = @@int64@@ [ Number ] ; @@int64@@ [ Number ] = @@int64@@ ; @@int@@ = validate_timespec ( @@structtimespec@@ ) ; } if ( @@int@@ < Number ) return Number ; if ( lutimensat_works_really >= Number ) { if ( @@int@@ == Number ) { if ( ( unsigned int ) lstat ( @@char@@ , & @@structstat@@ ) ) return Number ; if ( @@structtimespec@@ -> tv_nsec == Number ) { @@structtimespec@@ = @@structtimespec@@ ; @@structtimespec@@ -> tv_sec = get_stat_atime_1 ( ( __int64 ) & @@structstat@@ ) ; @@structtimespec@@ -> tv_nsec = @@syscallslongt@@ ; } else if ( @@structtimespec@@ [ Number ] . tv_nsec == Number ) { @@structtimespec@@ = @@structtimespec@@ + Number ; @@structtimespec@@ [ Number ] . tv_sec = get_stat_mtime_1 ( ( __int64 ) & @@structstat@@ ) ; @@structtimespec@@ -> tv_nsec = @@syscallslongt@@ ; } @@int@@ = Number ; } @@int@@ = utimensat ( Number , @@char@@ , @@structtimespec@@ , Number ) ; if ( @@int@@ > Number ) * __errno_location ( ) = Number ; if ( ! @@int@@ || * __errno_location ( ) != Number ) { utimensat_works_really = Number ; lutimensat_works_really = Number ; return @@int@@ ; } } lutimensat_works_really = Number ; if ( ! @@int@@ ) goto LABEL_37 ; if ( @@int@@ != Number && ( unsigned int ) lstat ( @@char@@ , & @@structstat@@ ) ) { return Number ; } if ( @@structtimespec@@ && ( unsigned __int8 ) update_timespec ( ( __int64 ) & @@structstat@@ , ( __int64 * * ) & @@structtimespec@@ ) ) { return Number ; } LABEL_37 : if ( ! @@int@@ && ( unsigned int ) lstat ( @@char@@ , & @@structstat@@ ) ) return Number ; if ( ( @@structstat@@ . st_mode & Number ) != Number ) return fdutimens ( @@char@@ , Number , & @@structtimespec@@ -> tv_sec ) ; * __errno_location ( ) = Number ; return Number ; }
__int64 * __fastcall mpz_tdiv_r ( __int64 * @@int64@@ , __int64 * @@int64@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = * @@int64@@ ; if ( * @@int64@@ == Number && @@int64@@ == Number ) @@int64@@ = Number L ; else @@int64@@ = * @@int64@@ % @@int64@@ ; @@int64@@ = @@int64@@ ; * @@int64@@ = @@int64@@ ; return @@int64@@ ; }
unsigned int * __fastcall tostring ( unsigned int * @@unsignedint@@ ) { unsigned int * @@unsignedint@@ ; __int64 @@int64@@ ; @@unsignedint@@ = ( unsigned int * ) * @@unsignedint@@ ; if ( ( _DWORD ) @@unsignedint@@ ) { if ( ( _DWORD ) @@unsignedint@@ != Number ) abort ( ) ; } else { @@int64@@ = mpz_get_str ( Number L , Number L , ( _QWORD * ) @@unsignedint@@ + Number ) ; mpz_clear ( ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ ; @@unsignedint@@ = @@unsignedint@@ ; * @@unsignedint@@ = Number ; } return @@unsignedint@@ ; }
__int64 __fastcall mpz_get_ui ( __int64 @@int64@@ ) { return * ( _QWORD * ) @@int64@@ ; }
__int64 __fastcall clean_state_log_if_needed ( _QWORD * @@QWORD@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned int @@unsignedint@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = @@QWORD@@ [ Number ] ; if ( @@unsignedint64@@ >= @@QWORD@@ [ Number ] || @@unsignedint64@@ >= @@QWORD@@ [ Number ] && @@QWORD@@ [ Number ] < @@QWORD@@ [ Number ] ) { @@unsignedint@@ = extend_buffers ( @@QWORD@@ ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; } if ( @@unsignedint64@@ < @@unsignedint64@@ ) { memset ( ( void * ) ( Number * ( @@unsignedint64@@ + Number ) + @@QWORD@@ [ Number ] ) , Number , Number * ( @@unsignedint64@@ - @@unsignedint64@@ ) ) ; @@QWORD@@ [ Number ] = @@unsignedint64@@ ; } return Number L ; }
__int64 __fastcall merge_state_with_log ( _DWORD * @@DWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned int @@unsignedint@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ [ Number ] ; void * @@void@@ ; unsigned __int64 @@unsignedint64@@ ; @@int64@@ = @@int64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@unsignedint64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( @@unsignedint64@@ <= * ( _QWORD * ) ( @@int64@@ + Number ) ) { if ( * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ) { @@int64@@ = Number L ; @@int64@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) + Number L ) ; if ( @@int64@@ ) { @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * @@DWORD@@ = re_node_set_init_union ( @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( * @@DWORD@@ ) return Number L ; } else { @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ [ Number ] = * ( _QWORD * ) @@int64@@ ; @@int64@@ [ Number ] = @@int64@@ ; @@void@@ = * ( void * * ) ( @@int64@@ + Number ) ; } @@unsignedint@@ = re_string_context_at ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) - Number L , * ( _DWORD * ) ( @@int64@@ + Number ) ) ; @@int64@@ = ( __int64 * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@unsignedint64@@ ) ; * @@int64@@ = re_acquire_state_context ( @@DWORD@@ , @@int64@@ , ( __int64 ) @@int64@@ , @@unsignedint@@ ) ; @@int64@@ = * @@int64@@ ; if ( @@int64@@ ) free ( @@void@@ ) ; } else { * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@unsignedint64@@ ) = @@int64@@ ; } } else { * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@unsignedint64@@ ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@unsignedint64@@ ; } if ( * ( _QWORD * ) ( @@int64@@ + Number ) && @@int64@@ ) { * @@DWORD@@ = check_subexp_matching_top ( @@int64@@ , @@int64@@ + Number , @@unsignedint64@@ ) ; if ( * @@DWORD@@ ) return Number L ; if ( ( * ( _BYTE * ) ( @@int64@@ + Number ) & Number ) != Number ) { * @@DWORD@@ = transit_state_bkref ( @@int64@@ , @@int64@@ + Number ) ; if ( * @@DWORD@@ ) return Number L ; @@int64@@ = * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; } } return @@int64@@ ; }
int __fastcall printv ( __int64 @@int64@@ ) { int @@int@@ ; if ( * ( _DWORD * ) @@int64@@ ) { if ( * ( _DWORD * ) @@int64@@ != Number ) abort ( ) ; @@int@@ = puts ( * ( const char * * ) ( @@int64@@ + Number ) ) ; } else { mpz_out_str ( stdout , Number L , ( _QWORD * ) ( @@int64@@ + Number ) ) ; @@int@@ = putchar_unlocked ( Number ) ; } return @@int@@ ; }
__int64 __fastcall eval7 ( unsigned __int8 @@unsignedint8@@ ) { __int64 @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; if ( nomoreargs ( ) ) syntax_error ( ) ; if ( nextarg ( ( const char * ) asc_1D374 ) ) { @@int64@@ = eval ( @@unsignedint8@@ ) ; if ( ! nextarg ( ( const char * ) & asc_1D374 [ Number ] ) ) syntax_error ( ) ; @@int64@@ = @@int64@@ ; } else { if ( nextarg ( ( const char * ) & asc_1D374 [ Number ] ) ) syntax_error ( ) ; @@int64@@ = ( __int64 * ) args ; args += Number L ; @@int64@@ = str_value ( * @@int64@@ ) ; } return @@int64@@ ; }
__int64 __fastcall dirchownmod ( int @@int@@ , char * @@char@@ , int @@int@@ , __uid_t @@uidt@@ , __gid_t @@gidt@@ , int @@int@@ , int @@int@@ ) { unsigned int @@unsignedint@@ ; int @@int@@ ; int @@int@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; __mode_t @@modet@@ ; int @@int@@ ; int @@int@@ ; struct stat @@structstat@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( @@int@@ >= Number ) @@unsignedint@@ = fstat ( @@int@@ , & @@structstat@@ ) ; else @@unsignedint@@ = stat ( @@char@@ , & @@structstat@@ ) ; @@unsignedint@@ = @@unsignedint@@ ; if ( ! @@unsignedint@@ ) { @@modet@@ = @@structstat@@ . st_mode ; if ( ( @@structstat@@ . st_mode & Number ) == Number ) { @@int@@ = Number ; if ( @@uidt@@ != Number && @@uidt@@ != @@structstat@@ . st_uid || @@gidt@@ != Number && @@gidt@@ != @@structstat@@ . st_gid ) { if ( @@int@@ < Number ) @@int@@ = @@int@@ == Number ? chown ( @@char@@ , @@uidt@@ , @@gidt@@ ) : lchown ( @@char@@ , @@uidt@@ , @@gidt@@ ) ; else @@int@@ = fchown ( @@int@@ , @@uidt@@ , @@gidt@@ ) ; @@unsignedint@@ = @@int@@ ; if ( ! @@int@@ && ( @@modet@@ & Number ) != Number ) @@int@@ = @@modet@@ & Number ; } if ( ! @@unsignedint@@ && ( @@int@@ & ( @@int@@ | @@int@@ ^ @@modet@@ ) ) != Number ) { @@int@@ = @@int@@ | ( unsigned __int16 ) @@modet@@ & ( unsigned __int16 ) ~ ( _WORD ) @@int@@ & Number ; if ( @@int@@ < Number ) @@int@@ = chmod ( @@char@@ , @@int@@ ) ; else @@int@@ = fchmod ( @@int@@ , @@int@@ ) ; @@unsignedint@@ = @@int@@ ; } } else { * __errno_location ( ) = Number ; @@unsignedint@@ = Number ; } } if ( @@int@@ >= Number ) { if ( @@unsignedint@@ ) { @@int@@ = * __errno_location ( ) ; close ( @@int@@ ) ; * __errno_location ( ) = @@int@@ ; } else { @@unsignedint@@ = close ( @@int@@ ) ; } } return @@unsignedint@@ ; }
__int64 __fastcall sub_epsilon_src_nodes ( _QWORD * @@QWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; unsigned int @@unsignedint@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; char @@char@@ [ Number ] ; void * @@void@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = @@QWORD@@ [ Number ] + Number * @@int64@@ ; memset ( @@char@@ , Number , Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { @@int64@@ = * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( @@int64@@ != @@int64@@ && ( * ( _BYTE * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) & Number ) != Number ) { @@unsignedint64@@ = * * ( _QWORD * * ) ( @@QWORD@@ [ Number ] + Number * @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@QWORD@@ [ Number ] + Number * @@int64@@ + Number ) <= Number ? Number : * ( _QWORD * ) ( * ( _QWORD * ) ( @@QWORD@@ [ Number ] + Number * @@int64@@ + Number ) + Number L ) ; if ( ( @@unsignedint64@@ = @@int64@@ , ! re_node_set_contains ( @@int64@@ , @@unsignedint64@@ ) ) && re_node_set_contains ( @@int64@@ , @@unsignedint64@@ ) || @@unsignedint64@@ - Number <= Number && ! re_node_set_contains ( @@int64@@ , @@unsignedint64@@ ) && re_node_set_contains ( @@int64@@ , @@unsignedint64@@ ) ) { @@unsignedint@@ = re_node_set_add_intersect ( ( __int64 ) @@char@@ , @@int64@@ , @@QWORD@@ [ Number ] + Number * @@int64@@ ) ; if ( @@unsignedint@@ ) { free ( @@void@@ ) ; return @@unsignedint@@ ; } } } } for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { @@unsignedint64@@ = * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( ! re_node_set_contains ( ( __int64 ) @@char@@ , @@unsignedint64@@ ) ) { @@unsignedint64@@ = re_node_set_contains ( @@int64@@ , @@unsignedint64@@ ) - Number ; re_node_set_remove_at ( @@int64@@ , @@unsignedint64@@ ) ; } } free ( @@void@@ ) ; return Number L ; }
__int64 __fastcall getsize ( __int64 * @@int64@@ ) { __int64 @@int64@@ ; if ( ( int ) mpz_sgn ( @@int64@@ ) < Number ) return Number ; if ( ! mpz_fits_ulong_p ( @@int64@@ ) ) return Number ; @@int64@@ = mpz_get_ui ( ( __int64 ) @@int64@@ ) ; if ( @@int64@@ == Number ) return Number ; return @@int64@@ ; }
_QWORD * __fastcall match_ctx_clean ( _QWORD * @@QWORD@@ ) { _QWORD * @@QWORD@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; void * @@void@@ ; void * * @@void@@ ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@QWORD@@ [ Number ] ; ++ @@unsignedint64@@ ) { @@void@@ = * ( void * * ) ( Number * @@unsignedint64@@ + @@QWORD@@ [ Number ] ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( ( _QWORD * ) @@void@@ + Number ) ; ++ @@unsignedint64@@ ) { @@void@@ = * ( void * * * ) ( Number * @@unsignedint64@@ + * ( ( _QWORD * ) @@void@@ + Number ) ) ; free ( @@void@@ [ Number ] ) ; free ( @@void@@ ) ; } free ( * ( ( void * * ) @@void@@ + Number ) ) ; if ( * ( ( _QWORD * ) @@void@@ + Number ) ) { free ( * ( void * * ) ( * ( ( _QWORD * ) @@void@@ + Number ) + Number L ) ) ; free ( * ( ( void * * ) @@void@@ + Number ) ) ; } free ( @@void@@ ) ; } @@QWORD@@ [ Number ] = Number L ; @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ [ Number ] = Number L ; return @@QWORD@@ ; }
void * * __fastcall eval3 ( unsigned __int8 @@unsignedint8@@ ) { char * @@char@@ ; int @@int@@ $15114BBF10992532484F7C0F379D99C4 ; void * * @@void@@ ; void * * @@void@@ ; @@void@@ = eval4 ( @@unsignedint8@@ ) ; while ( Number ) { if ( nextarg ( ( const char * ) & asc_1D374 [ Number ] ) ) { @@int@@ $15114BBF10992532484F7C0F379D99C4 = Number ; goto LABEL_7 ; } if ( ! nextarg ( String ) ) return @@void@@ ; @@int@@ $15114BBF10992532484F7C0F379D99C4 = Number ; LABEL_7 : @@void@@ = eval4 ( @@unsignedint8@@ ) ; if ( @@unsignedint8@@ ) { if ( ( unsigned __int8 ) toarith ( ( __int64 ) @@void@@ ) != Number || ( unsigned __int8 ) toarith ( ( __int64 ) @@void@@ ) != Number ) { @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ ) ; } if ( @@int@@ $15114BBF10992532484F7C0F379D99C4 ) mpz_sub ( @@void@@ + Number , @@void@@ + Number , ( __int64 * ) @@void@@ + Number ) ; else mpz_add ( @@void@@ + Number , @@void@@ + Number , ( __int64 * ) @@void@@ + Number ) ; } freev ( @@void@@ ) ; } }
_QWORD * __fastcall mpz_add ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { _QWORD * @@QWORD@@ ; if ( * @@QWORD@@ + * @@int64@@ < * @@QWORD@@ != * @@int64@@ < Number ) integer_overflow ( Number L ) ; @@QWORD@@ = @@QWORD@@ ; * @@QWORD@@ = * @@QWORD@@ + * @@int64@@ ; return @@QWORD@@ ; }
__int64 __fastcall find_recover_state ( _DWORD * @@DWORD@@ , _QWORD * @@QWORD@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; do { @@unsignedint64@@ = @@QWORD@@ [ Number ] ; @@int64@@ = @@QWORD@@ [ Number ] ; do { if ( ++ @@int64@@ > @@unsignedint64@@ ) return Number L ; ++ @@QWORD@@ [ Number ] ; } while ( ! * ( _QWORD * ) ( Number * @@int64@@ + @@QWORD@@ [ Number ] ) ) ; @@int64@@ = merge_state_with_log ( @@DWORD@@ , ( __int64 ) @@QWORD@@ , Number L ) ; } while ( ! * @@DWORD@@ && ! @@int64@@ ) ; return @@int64@@ ; }
void * * __fastcall eval5 ( unsigned __int8 @@unsignedint8@@ ) { void * * @@void@@ ; void * * @@void@@ ; __int64 @@int64@@ ; @@void@@ = ( void * * ) eval6 ( @@unsignedint8@@ ) ; while ( nextarg ( ( const char * ) asc_1D394 ) ) { @@void@@ = ( void * * ) eval6 ( @@unsignedint8@@ ) ; if ( @@unsignedint8@@ ) { @@int64@@ = docolon ( ( __int64 ) @@void@@ , ( __int64 ) @@void@@ ) ; freev ( @@void@@ ) ; @@void@@ = ( void * * ) @@int64@@ ; } freev ( @@void@@ ) ; } return @@void@@ ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
__int64 __fastcall mpz_get_str ( __int64 a1 , __int64 a2 , _QWORD * @@QWORD@@ ) { __int64 @@int64@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = imaxtostr ( * @@QWORD@@ , @@char@@ ) ; return xstrdup ( @@int64@@ ) ; }
__int64 __fastcall incname ( __int64 @@int64@@ , __int64 @@int64@@ ) { char * @@char@@ ; while ( @@int64@@ -- ) { @@char@@ = strchr ( String , * ( char * ) ( @@int64@@ + @@int64@@ ) ) ; if ( @@char@@ [ Number ] ) { * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) = @@char@@ [ Number ] ; return Number L ; } * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) = Number ; } return Number L ; }
void * * __fastcall eval ( unsigned __int8 @@unsignedint8@@ ) { bool @@bool@@ ; void * * @@void@@ ; void * * @@void@@ ; @@void@@ = eval1 ( @@unsignedint8@@ ) ; while ( nextarg ( String ) ) { @@bool@@ = @@unsignedint8@@ && null ( ( __int64 ) @@void@@ ) ; @@void@@ = eval1 ( @@bool@@ ) ; if ( null ( ( __int64 ) @@void@@ ) ) { freev ( @@void@@ ) ; @@void@@ = @@void@@ ; if ( null ( ( __int64 ) @@void@@ ) ) { freev ( @@void@@ ) ; @@void@@ = ( void * * ) int_value ( Number L ) ; } } else { freev ( @@void@@ ) ; } } return @@void@@ ; }
void * * __fastcall eval4 ( unsigned __int8 @@unsignedint8@@ ) { char * @@char@@ ; char * @@char@@ ; int @@int@@ $B16BB1FB0E13686A99D5A99C8504F879 ; void * * @@void@@ ; void * * @@void@@ ; @@void@@ = eval5 ( @@unsignedint8@@ ) ; while ( Number ) { if ( nextarg ( ( const char * ) & asc_1D394 [ Number ] ) ) { @@int@@ $B16BB1FB0E13686A99D5A99C8504F879 = Number ; goto LABEL_9 ; } if ( nextarg ( ( const char * ) & asc_1D394 [ Number ] ) ) { @@int@@ $B16BB1FB0E13686A99D5A99C8504F879 = Number ; goto LABEL_9 ; } if ( ! nextarg ( ( const char * ) & asc_1D394 [ Number ] ) ) return @@void@@ ; @@int@@ $B16BB1FB0E13686A99D5A99C8504F879 = Number ; LABEL_9 : @@void@@ = eval5 ( @@unsignedint8@@ ) ; if ( @@unsignedint8@@ ) { if ( ( unsigned __int8 ) toarith ( ( __int64 ) @@void@@ ) != Number || ( unsigned __int8 ) toarith ( ( __int64 ) @@void@@ ) != Number ) { @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ ) ; } if ( @@int@@ $B16BB1FB0E13686A99D5A99C8504F879 && ! ( unsigned int ) mpz_sgn ( ( __int64 * ) @@void@@ + Number ) ) { @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ ) ; } if ( @@int@@ $B16BB1FB0E13686A99D5A99C8504F879 ) { if ( @@int@@ $B16BB1FB0E13686A99D5A99C8504F879 == Number ) mpz_tdiv_q ( ( __int64 * ) @@void@@ + Number , @@void@@ + Number , ( __int64 * ) @@void@@ + Number ) ; else mpz_tdiv_r ( ( __int64 * ) @@void@@ + Number , ( __int64 * ) @@void@@ + Number , ( __int64 * ) @@void@@ + Number ) ; } else { mpz_mul ( ( __int64 * ) @@void@@ + Number , ( __int64 * ) @@void@@ + Number , ( __int64 * ) @@void@@ + Number ) ; } } freev ( @@void@@ ) ; } }
__int64 __fastcall find_subexp_node ( _QWORD * @@QWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ , int @@int@@ ) { unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { @@int64@@ = Number L * * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) + * @@QWORD@@ ; if ( @@int@@ == * ( unsigned __int8 * ) ( @@int64@@ + Number ) && @@int64@@ == * ( _QWORD * ) @@int64@@ ) { return * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; } } return Number ; }
__int64 __fastcall randint_get_source ( __int64 @@int64@@ ) { return * ( _QWORD * ) @@int64@@ ; }
_BOOL8 __fastcall mpz_out_str ( FILE * @@FILE@@ , __int64 a2 , _QWORD * @@QWORD@@ ) { const char * @@constchar@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@constchar@@ = ( const char * ) imaxtostr ( * @@QWORD@@ , @@char@@ ) ; return fputs_unlocked ( @@constchar@@ , @@FILE@@ ) != Number ; }
__int64 __fastcall shift_left ( __int64 @@int64@@ ) { return @@int64@@ << Number ; }
__int64 __fastcall imaxtostr ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ + Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = Number ; if ( @@int64@@ >= Number ) { do { * ( _BYTE * ) -- @@int64@@ = ( char ) @@int64@@ % Number + Number ; @@int64@@ /= Number L ; } while ( @@int64@@ ) ; } else { do { * ( _BYTE * ) -- @@int64@@ = Number - ( char ) @@int64@@ % Number ; @@int64@@ /= Number L ; } while ( @@int64@@ ) ; * ( _BYTE * ) -- @@int64@@ = Number ; } return @@int64@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
__int64 __fastcall looks_like_integer ( _BYTE * @@BYTE@@ ) { _BYTE * @@BYTE@@ ; @@BYTE@@ = & @@BYTE@@ [ * @@BYTE@@ == Number ] ; do { if ( ( unsigned int ) ( ( char ) * @@BYTE@@ - Number ) > Number ) return Number L ; ++ @@BYTE@@ ; } while ( * @@BYTE@@ ) ; return Number L ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
unsigned __int64 __fastcall randint_genmax ( __int64 * @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = * @@int64@@ ; @@unsignedint64@@ = @@int64@@ [ Number ] ; @@unsignedint64@@ = @@int64@@ [ Number ] ; @@unsignedint64@@ = @@unsignedint64@@ + Number ; while ( Number ) { if ( @@unsignedint64@@ < @@unsignedint64@@ ) { @@int64@@ = Number L ; @@unsignedint64@@ = @@unsignedint64@@ ; do { @@unsignedint64@@ = shift_left ( @@unsignedint64@@ ) + Number ; ++ @@int64@@ ; } while ( @@unsignedint64@@ < @@unsignedint64@@ ) ; randread ( @@int64@@ , @@char@@ , @@int64@@ ) ; @@int64@@ = Number L ; do { @@unsignedint64@@ = shift_left ( @@unsignedint64@@ ) + ( unsigned __int8 ) @@char@@ [ @@int64@@ ] ; @@unsignedint64@@ = shift_left ( @@unsignedint64@@ ) + Number ; ++ @@int64@@ ; } while ( @@unsignedint64@@ < @@unsignedint64@@ ) ; } if ( @@unsignedint64@@ == @@unsignedint64@@ ) { @@int64@@ [ Number ] = Number L ; @@int64@@ [ Number ] = @@int64@@ [ Number ] ; return @@unsignedint64@@ ; } @@unsignedint64@@ = ( @@unsignedint64@@ - @@unsignedint64@@ ) % @@unsignedint64@@ ; if ( @@unsignedint64@@ <= @@unsignedint64@@ - @@unsignedint64@@ ) break ; @@unsignedint64@@ %= @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint64@@ - Number ; } @@int64@@ [ Number ] = @@unsignedint64@@ / @@unsignedint64@@ ; @@int64@@ [ Number ] = ( @@unsignedint64@@ - @@unsignedint64@@ ) / @@unsignedint64@@ ; return @@unsignedint64@@ % @@unsignedint64@@ ; }
__int64 __fastcall toarith ( __int64 @@int64@@ ) { _BYTE * @@BYTE@@ ; if ( ! * ( _DWORD * ) @@int64@@ ) return Number L ; if ( * ( _DWORD * ) @@int64@@ != Number ) abort ( ) ; @@BYTE@@ = * ( _BYTE * * ) ( @@int64@@ + Number ) ; if ( ( unsigned __int8 ) looks_like_integer ( @@BYTE@@ ) != Number ) return Number L ; if ( ( unsigned int ) mpz_init_set_str ( @@int64@@ + Number , ( __int64 ) @@BYTE@@ , Number ) ) error ( Number , Number , off_1D2EC , @@BYTE@@ ) ; free ( @@BYTE@@ ) ; * ( _DWORD * ) @@int64@@ = Number ; return Number L ; }
__int64 __fastcall check_arrival_expand_ecl ( _QWORD * @@QWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; unsigned int @@unsignedint@@ ; unsigned int @@unsignedint@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ [ Number ] ; void * @@void@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@unsignedint@@ = re_node_set_alloc ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { @@int64@@ = * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; @@int64@@ = @@QWORD@@ [ Number ] + Number * @@int64@@ ; if ( find_subexp_node ( @@QWORD@@ , @@int64@@ , @@int64@@ , @@unsignedint@@ ) == Number ) { @@unsignedint@@ = re_node_set_merge ( ( __int64 ) @@int64@@ , @@int64@@ ) ; if ( @@unsignedint@@ ) goto LABEL_6 ; } else { @@unsignedint@@ = check_arrival_expand_ecl_sub ( @@QWORD@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@unsignedint@@ ) ; if ( @@unsignedint@@ ) { LABEL_6 : free ( @@void@@ ) ; return @@unsignedint@@ ; } } } free ( * ( void * * ) ( @@int64@@ + Number ) ) ; @@int64@@ = @@int64@@ [ Number ] ; * ( _QWORD * ) @@int64@@ = @@int64@@ [ Number ] ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@void@@ ; return Number L ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
__int64 __fastcall extend_buffers ( __int64 @@int64@@ ) { unsigned int @@unsignedint@@ ; unsigned int @@unsignedint@@ ; void * @@void@@ ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) > Number ) return Number L ; @@unsignedint@@ = re_string_realloc_buffers ( @@int64@@ , Number L * * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) { @@void@@ = realloc ( * ( void * * ) ( @@int64@@ + Number ) , Number * ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) ) ; if ( ! @@void@@ ) return Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@void@@ ; } if ( * ( _BYTE * ) ( @@int64@@ + Number ) ) { if ( * ( int * ) ( @@int64@@ + Number ) <= Number ) { build_upper_buffer ( ( _QWORD * ) @@int64@@ ) ; } else { @@unsignedint@@ = build_wcs_upper_buffer ( @@int64@@ ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; } } else if ( * ( int * ) ( @@int64@@ + Number ) <= Number ) { if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) re_string_translate_buffer ( ( _QWORD * ) @@int64@@ ) ; } else { build_wcs_buffer ( @@int64@@ ) ; } return Number L ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@unsignedint64@@ , int @@int@@ ) { __int64 @@int64@@ ; if ( is_mul_ok ( @@int@@ , * @@unsignedint64@@ ) ) { * @@unsignedint64@@ *= @@int@@ ; @@int64@@ = Number L ; } else { * @@unsignedint64@@ = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall eval2 ( unsigned __int8 @@unsignedint8@@ ) { char * @@char@@ ; int * @@int@@ ; char * @@char@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; char * @@char@@ ; bool @@bool@@ ; int @@int@@ $8B6283BB588625B42BF25B000F30A210 ; int @@int@@ ; __int64 @@int64@@ ; void * * @@void@@ ; for ( @@int64@@ = ( __int64 ) eval3 ( @@unsignedint8@@ ) ; ; @@int64@@ = int_value ( @@bool@@ ) ) { @@bool@@ = Number ; if ( nextarg ( String ) ) { @@int@@ $8B6283BB588625B42BF25B000F30A210 = Number ; goto LABEL_16 ; } if ( nextarg ( String ) ) { @@int@@ $8B6283BB588625B42BF25B000F30A210 = Number ; goto LABEL_16 ; } if ( nextarg ( String ) || nextarg ( String ) ) { @@int@@ $8B6283BB588625B42BF25B000F30A210 = Number ; goto LABEL_16 ; } if ( nextarg ( String ) ) { @@int@@ $8B6283BB588625B42BF25B000F30A210 = Number ; goto LABEL_16 ; } if ( nextarg ( String ) ) { @@int@@ $8B6283BB588625B42BF25B000F30A210 = Number ; goto LABEL_16 ; } if ( ! nextarg ( String ) ) break ; @@int@@ $8B6283BB588625B42BF25B000F30A210 = Number ; LABEL_16 : @@void@@ = eval3 ( @@unsignedint8@@ ) ; if ( @@unsignedint8@@ ) { tostring ( ( unsigned int * ) @@int64@@ ) ; tostring ( ( unsigned int * ) @@void@@ ) ; if ( ( unsigned __int8 ) looks_like_integer ( * ( _BYTE * * ) ( @@int64@@ + Number ) ) && ( unsigned __int8 ) looks_like_integer ( @@void@@ [ Number ] ) ) { @@int@@ = strintcmp ( * ( _QWORD * ) ( @@int64@@ + Number ) , @@void@@ [ Number ] ) ; } else { * __errno_location ( ) = Number ; @@int@@ = strcoll ( * ( const char * * ) ( @@int64@@ + Number ) , ( const char * ) @@void@@ [ Number ] ) ; if ( * __errno_location ( ) ) { @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ ) ; @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ ) ; @@int64@@ = quotearg_n_style ( Number L , Number L , @@void@@ [ Number ] ) ; @@int64@@ = quotearg_n_style ( Number L , Number L , * ( _QWORD * ) ( @@int64@@ + Number ) ) ; @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ , @@int64@@ , @@int64@@ ) ; } } switch ( @@int@@ $8B6283BB588625B42BF25B000F30A210 ) { case Number : @@bool@@ = @@int@@ < Number ; break ; case Number : @@bool@@ = @@int@@ <= Number ; break ; case Number : @@bool@@ = @@int@@ == Number ; break ; case Number : @@bool@@ = @@int@@ != Number ; break ; case Number : @@bool@@ = @@int@@ >= Number ; break ; case Number : @@bool@@ = @@int@@ > Number ; break ; default : abort ( ) ; } } freev ( ( void * * ) @@int64@@ ) ; freev ( @@void@@ ) ; } return @@int64@@ ; }
void * __fastcall sift_ctx_init ( _QWORD * @@QWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { * @@QWORD@@ = @@int64@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; return memset ( @@QWORD@@ + Number , Number , Number ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_2220C8 ; @@int648@@ [ Number ] = qword_2220D0 ; @@int648@@ [ Number ] = qword_2220D8 ; @@int648@@ [ Number ] = qword_2220E0 ; @@int648@@ [ Number ] = qword_2220E8 ; @@int648@@ [ Number ] = qword_2220F0 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
void * __fastcall mdir_name ( _BYTE * @@BYTE@@ ) { _BYTE * @@BYTE@@ ; void * @@void@@ ; @@BYTE@@ = dir_len ( @@BYTE@@ ) ; @@void@@ = malloc ( ( size_t ) & @@BYTE@@ [ ( @@BYTE@@ == Number L ) + Number ] ) ; if ( ! @@void@@ ) return Number L ; memcpy ( @@void@@ , @@BYTE@@ , ( size_t ) @@BYTE@@ ) ; if ( ! @@BYTE@@ ) { @@BYTE@@ = ( _BYTE * ) ( & dword_0 + Number ) ; * ( _BYTE * ) @@void@@ = Number ; } @@BYTE@@ [ ( _QWORD ) @@void@@ ] = Number ; return @@void@@ ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) { ; } return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall re_string_wchar_at ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; if ( * ( _DWORD * ) ( @@int64@@ + Number ) == Number ) @@int64@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + @@int64@@ ) ; else @@int64@@ = * ( unsigned int * ) ( Number * @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; return @@int64@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall humblock ( char * @@char@@ , uintmax_t * @@uintmaxt@@ , int * @@int@@ ) { char * @@char@@ ; int @@int@@ ; int @@int@@ ; unsigned int @@unsignedint@@ ; char * @@char2@@ [ Number ] ; @@char@@ = @@char@@ ; @@char2@@ [ Number ] = ( char * ) __readfsqword ( Number ) ; @@int@@ = Number ; if ( @@char@@ || ( @@char@@ = getenv ( String ) ) != Number L || ( @@char@@ = getenv ( String ) ) != Number L ) { if ( * @@char@@ == Number ) { @@int@@ = Number ; ++ @@char@@ ; } @@int@@ = argmatch ( @@char@@ , & block_size_args , block_size_opts , Number L ) ; if ( @@int@@ < Number ) { @@unsignedint@@ = xstrtoumax ( @@char@@ , @@char2@@ , Number , @@uintmaxt@@ , String ) ; if ( @@unsignedint@@ ) { * @@int@@ = Number ; return @@unsignedint@@ ; } while ( * @@char@@ <= Number || * @@char@@ > Number ) { if ( @@char@@ == @@char2@@ [ Number ] ) { @@int@@ |= Number ; if ( * ( @@char2@@ [ Number ] - Number ) == Number ) @@int@@ |= Number ; if ( * ( @@char2@@ [ Number ] - Number ) != Number || * ( @@char2@@ [ Number ] - Number ) == Number ) @@int@@ |= Number ; break ; } ++ @@char@@ ; } } else { @@int@@ |= block_size_opts [ @@int@@ ] ; * @@uintmaxt@@ = Number L ; } } else { * @@uintmaxt@@ = default_block_size ( ) ; } * @@int@@ = @@int@@ ; return Number L ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
__int64 __fastcall re_string_realloc_buffers ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { void * @@void@@ ; void * @@void@@ ; void * @@void@@ ; if ( * ( int * ) ( @@int64@@ + Number ) > Number ) { if ( ! is_mul_ok ( Number , @@unsignedint64@@ ) ) return Number L ; @@void@@ = realloc ( * ( void * * ) ( @@int64@@ + Number ) , Number * @@unsignedint64@@ ) ; if ( ! @@void@@ ) return Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@void@@ ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) { @@void@@ = realloc ( * ( void * * ) ( @@int64@@ + Number ) , Number * @@unsignedint64@@ ) ; if ( ! @@void@@ ) return Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@void@@ ; } } if ( * ( _BYTE * ) ( @@int64@@ + Number ) ) { @@void@@ = realloc ( * ( void * * ) ( @@int64@@ + Number ) , @@unsignedint64@@ ) ; if ( ! @@void@@ ) return Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@void@@ ; } * ( _QWORD * ) ( @@int64@@ + Number ) = @@unsignedint64@@ ; return Number L ; }
__int64 __fastcall dosync ( int @@int@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; int @@int@@ ; int @@int@@ ; if ( ! fdatasync ( @@int@@ ) ) return Number L ; @@int@@ = * __errno_location ( ) ; if ( ! ignorable_sync_errno ( @@int@@ ) ) { @@char@@ = gettext ( String ) ; error ( Number , @@int@@ , @@char@@ , @@int64@@ ) ; * __errno_location ( ) = @@int@@ ; @@int64@@ = Number ; } else if ( fsync ( @@int@@ ) ) { @@int@@ = * __errno_location ( ) ; if ( ! ignorable_sync_errno ( @@int@@ ) ) { @@char@@ = gettext ( String ) ; error ( Number , @@int@@ , @@char@@ , @@int64@@ ) ; * __errno_location ( ) = @@int@@ ; @@int64@@ = Number ; } else { sync ( ) ; @@int64@@ = Number L ; } } else { @@int64@@ = Number L ; } return @@int64@@ ; }
void * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
_QWORD * __fastcall randint_all_new ( __int64 @@int64@@ , __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; @@int64@@ = randread_new ( @@int64@@ , @@int64@@ ) ; if ( @@int64@@ ) @@QWORD@@ = randint_new ( @@int64@@ ) ; else @@QWORD@@ = Number L ; return @@QWORD@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
bool __fastcall bitset_contain ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { return ( ( * ( _QWORD * ) ( Number * ( @@unsignedint64@@ >> Number ) + @@int64@@ ) >> ( @@unsignedint64@@ & Number ) ) & Number L ) != Number ; }
__int64 __fastcall re_string_peek_byte_case ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; if ( ! * ( _BYTE * ) ( @@int64@@ + Number ) ) return * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + * ( _QWORD * ) ( @@int64@@ + Number ) + @@int64@@ ) ; if ( * ( int * ) ( @@int64@@ + Number ) > Number && ( * ( _DWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * ( * ( _QWORD * ) ( @@int64@@ + Number ) + @@int64@@ ) ) == Number || * ( _QWORD * ) ( @@int64@@ + Number ) != * ( _QWORD * ) ( @@int64@@ + Number ) + @@int64@@ + Number && * ( _DWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * ( * ( _QWORD * ) ( @@int64@@ + Number ) + @@int64@@ + Number ) ) == Number ) ) { return * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + * ( _QWORD * ) ( @@int64@@ + Number ) + @@int64@@ ) ; } @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) + @@int64@@ ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) ) @@int64@@ = * ( _QWORD * ) ( Number * @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) && ( * ( _BYTE * ) ( * ( _QWORD * ) @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) + @@int64@@ ) & Number ) != Number ) { @@int64@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + * ( _QWORD * ) ( @@int64@@ + Number ) + @@int64@@ ) ; } else { @@int64@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) + @@int64@@ ) ; } return @@int64@@ ; }
void __fastcall randint_free ( void * @@void@@ ) { memset ( @@void@@ , Number , Number ) ; free ( @@void@@ ) ; }
void * __fastcall bitset_empty ( void * @@void@@ ) { return memset ( @@void@@ , Number , Number ) ; }
_QWORD * __fastcall bitset_clear ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { _QWORD * @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) ( Number * ( @@unsignedint64@@ >> Number ) + @@int64@@ ) ; * @@QWORD@@ &= ~ ( Number L << ( @@unsignedint64@@ & Number ) ) ; return @@QWORD@@ ; }
void * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_20D0C8 ; @@int648@@ [ Number ] = qword_20D0D0 ; @@int648@@ [ Number ] = qword_20D0D8 ; @@int648@@ [ Number ] = qword_20D0E0 ; @@int648@@ [ Number ] = qword_20D0E8 ; @@int648@@ [ Number ] = qword_20D0F0 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
_QWORD * __fastcall simple_new ( __int64 @@int64@@ , __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) xmalloc ( Number L ) ; * @@QWORD@@ = @@int64@@ ; @@QWORD@@ [ Number ] = randread_error ; @@QWORD@@ [ Number ] = @@int64@@ ; return @@QWORD@@ ; }
__int64 __fastcall re_string_char_size_at ( __int64 @@int64@@ , __int64 @@int64@@ ) { int @@int@@ ; if ( * ( _DWORD * ) ( @@int64@@ + Number ) == Number ) return Number L ; for ( @@int@@ = Number ; ( unsigned __int64 ) ( @@int64@@ + @@int@@ ) < * ( _QWORD * ) ( @@int64@@ + Number ) && * ( _DWORD * ) ( Number * ( @@int@@ + @@int64@@ ) + * ( _QWORD * ) ( @@int64@@ + Number ) ) == Number ; ++ @@int@@ ) { ; } return ( unsigned int ) @@int@@ ; }
_QWORD * __fastcall bitset_merge ( __int64 @@int64@@ , __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; int @@int@@ ; for ( @@int@@ = Number ; @@int@@ <= Number ; ++ @@int@@ ) { @@QWORD@@ = ( _QWORD * ) ( Number L * @@int@@ + @@int64@@ ) ; * @@QWORD@@ |= * ( _QWORD * ) ( Number L * @@int@@ + @@int64@@ ) ; } return @@QWORD@@ ; }
size_t __fastcall readsource ( __int64 @@int64@@ , char * @@char@@ , size_t @@sizet@@ ) { size_t @@sizet@@ ; int @@int@@ ; int @@int@@ ; size_t @@sizet@@ ; while ( Number ) { @@sizet@@ = fread_unlocked ( @@char@@ , Number , @@sizet@@ , * ( FILE * * ) @@int64@@ ) ; @@int@@ = * __errno_location ( ) ; @@char@@ += @@sizet@@ ; @@sizet@@ = @@sizet@@ ; @@sizet@@ -= @@sizet@@ ; if ( ! @@sizet@@ ) break ; if ( ferror_unlocked ( * ( FILE * * ) @@int64@@ ) ) @@int@@ = @@int@@ ; else @@int@@ = Number ; * __errno_location ( ) = @@int@@ ; ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@int64@@ + Number ) ) ( * ( _QWORD * ) ( @@int64@@ + Number ) ) ; } return @@sizet@@ ; }
int __fastcall argmatch_valid ( __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { char * @@char@@ ; __int64 @@int64@@ ; void * @@void@@ ; @@void@@ = Number L ; @@char@@ = gettext ( String ) ; fprintf ( stderr , @@char@@ ) ; for ( @@int64@@ = Number L ; * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; ++ @@int64@@ ) { if ( @@int64@@ && ! memcmp ( @@void@@ , ( const void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) , @@sizet@@ ) ) { fprintf ( stderr , String , * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) ) ; } else { fprintf ( stderr , String , * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) ) ; @@void@@ = ( void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) ; } } return putc_unlocked ( Number , stderr ) ; }
_DWORD * __fastcall isaac_seed_data ( _DWORD * @@DWORD@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { _DWORD * @@DWORD@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; char * @@char@@ ; char * @@char@@ ; for ( @@unsignedint64@@ = Number L - ( unsigned int ) @@DWORD@@ [ Number ] ; @@unsignedint64@@ > @@unsignedint64@@ ; @@unsignedint64@@ = Number L ) { @@char@@ = ( char * ) @@DWORD@@ + ( unsigned int ) @@DWORD@@ [ Number ] ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@unsignedint64@@ ; ++ @@unsignedint64@@ ) { @@char@@ [ @@unsignedint64@@ ] ^= * ( _BYTE * ) ( @@int64@@ + @@unsignedint64@@ ) ; } @@int64@@ += @@unsignedint64@@ ; @@unsignedint64@@ -= @@unsignedint64@@ ; isaac_mix ( @@DWORD@@ , ( __int64 ) @@DWORD@@ ) ; @@DWORD@@ [ Number ] = Number ; } @@char@@ = ( char * ) @@DWORD@@ + ( unsigned int ) @@DWORD@@ [ Number ] ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@unsignedint64@@ ; ++ @@unsignedint64@@ ) { @@char@@ [ @@unsignedint64@@ ] ^= * ( _BYTE * ) ( @@int64@@ + @@unsignedint64@@ ) ; } @@DWORD@@ = @@DWORD@@ ; @@DWORD@@ [ Number ] = @@unsignedint64@@ ; return @@DWORD@@ ; }
__int64 __fastcall re_string_construct_common ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , char @@char@@ , __int64 @@int64@@ ) { bool @@bool@@ ; __int64 @@int64@@ ; * ( _QWORD * ) @@int64@@ = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _BYTE * ) ( @@int64@@ + Number ) = @@char@@ ; @@bool@@ = @@int64@@ || @@char@@ ; * ( _BYTE * ) ( @@int64@@ + Number ) = @@bool@@ ; * ( _DWORD * ) ( @@int64@@ + Number ) = * ( _DWORD * ) ( @@int64@@ + Number ) ; * ( _BYTE * ) ( @@int64@@ + Number ) = ( * ( _BYTE * ) ( @@int64@@ + Number ) & Number ) != Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = ( * ( _BYTE * ) ( @@int64@@ + Number ) & Number ) != Number ; * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; return @@int64@@ ; }
__int64 __fastcall re_string_allocate ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ , __int64 @@int64@@ ) { unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned int @@unsignedint@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint64@@ ; if ( @@unsignedint64@@ < * ( int * ) ( @@int64@@ + Number ) ) @@unsignedint64@@ = * ( int * ) ( @@int64@@ + Number ) ; @@unsignedint64@@ = @@int64@@ + Number ; if ( @@unsignedint64@@ <= @@int64@@ + Number ) @@unsignedint64@@ = @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint64@@ ; re_string_construct_common ( @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@unsignedint8@@ , @@int64@@ ) ; @@unsignedint@@ = re_string_realloc_buffers ( @@int64@@ , @@unsignedint64@@ ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ + Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = ( * ( _BYTE * ) ( @@int64@@ + Number ) & Number ) != Number ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) ) @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; else @@int64@@ = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) || * ( int * ) ( @@int64@@ + Number ) > Number ) @@int64@@ = Number L ; else @@int64@@ = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; return Number L ; }
bool __fastcall re_node_set_insert ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; void * @@void@@ ; if ( ! * ( _QWORD * ) @@int64@@ ) return ( unsigned int ) re_node_set_init_1 ( ( _QWORD * ) @@int64@@ , @@unsignedint64@@ ) == Number ; if ( ! * ( _QWORD * ) ( @@int64@@ + Number ) ) { * * ( _QWORD * * ) ( @@int64@@ + Number ) = @@unsignedint64@@ ; ++ * ( _QWORD * ) ( @@int64@@ + Number ) ; return Number ; } if ( * ( _QWORD * ) @@int64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ) { * ( _QWORD * ) @@int64@@ *= Number L ; @@void@@ = realloc ( * ( void * * ) ( @@int64@@ + Number ) , Number L * * ( _QWORD * ) @@int64@@ ) ; if ( ! @@void@@ ) return Number ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@void@@ ; } if ( @@unsignedint64@@ >= * * ( _QWORD * * ) ( @@int64@@ + Number ) ) { for ( @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@unsignedint64@@ < * ( _QWORD * ) ( Number * @@int64@@ - Number + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; -- @@int64@@ ) { * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ - Number ) ; } } else { for ( @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ ; -- @@int64@@ ) { * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ - Number ) ; } } * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ ) = @@unsignedint64@@ ; ++ * ( _QWORD * ) ( @@int64@@ + Number ) ; return Number ; }
__int64 __fastcall make_node_op_equals ( int @@int@@ , int @@int@@ ) { __int64 @@int64@@ ; @@int64@@ = xmalloc ( Number L ) ; * ( _BYTE * ) @@int64@@ = Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = Number ; * ( _DWORD * ) ( @@int64@@ + Number ) = Number ; * ( _DWORD * ) ( @@int64@@ + Number ) = @@int@@ ; * ( _DWORD * ) ( @@int64@@ + Number ) = @@int@@ ; * ( _BYTE * ) ( @@int64@@ + Number ) = Number ; return @@int64@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
__int64 __fastcall re_string_fetch_byte_case ( __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned int @@unsignedint@@ ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) ) { if ( * ( _BYTE * ) ( @@int64@@ + Number ) ) { if ( * ( _QWORD * ) ( @@int64@@ + Number ) == * ( _QWORD * ) ( @@int64@@ + Number ) || * ( _DWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L * * ( _QWORD * ) ( @@int64@@ + Number ) ) != Number ) { @@unsignedint@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) + * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L * * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; if ( ( @@unsignedint@@ & Number ) != Number ) { @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ + Number ; @@int64@@ = * ( unsigned __int8 * ) ( @@int64@@ + @@int64@@ ) ; } else { @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ + ( int ) re_string_char_size_at ( @@int64@@ , @@int64@@ ) ; @@int64@@ = @@unsignedint@@ ; } } else { @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ + Number ; @@int64@@ = * ( unsigned __int8 * ) ( @@int64@@ + @@int64@@ ) ; } } else { @@int64@@ = * ( _QWORD * ) @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ + Number ; @@int64@@ = * ( unsigned __int8 * ) ( @@int64@@ + @@int64@@ + @@int64@@ ) ; } } else { @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ + Number ; @@int64@@ = * ( unsigned __int8 * ) ( @@int64@@ + @@int64@@ ) ; } return @@int64@@ ; }
char * __fastcall rpl_re_compile_pattern ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { char * @@char@@ ; int @@int@@ ; * ( _BYTE * ) ( @@int64@@ + Number ) = ( Number * ( ( rpl_re_syntax_options & Number ) != Number ) ) | * ( _BYTE * ) ( @@int64@@ + Number ) & Number ; * ( _BYTE * ) ( @@int64@@ + Number ) |= Number ; @@int@@ = re_compile_internal ( @@int64@@ , @@int64@@ , @@int64@@ , rpl_re_syntax_options ) ; if ( @@int@@ ) @@char@@ = gettext ( & _re_error_msgid [ _re_error_msgid_idx [ @@int@@ ] ] ) ; else @@char@@ = Number L ; return @@char@@ ; }
void __fastcall re_string_destruct ( __int64 @@int64@@ ) { free ( * ( void * * ) ( @@int64@@ + Number ) ) ; free ( * ( void * * ) ( @@int64@@ + Number ) ) ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) ) free ( * ( void * * ) ( @@int64@@ + Number ) ) ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
char * __fastcall group_number ( char * @@char@@ , size_t @@sizet@@ , unsigned __int8 * @@unsignedint8@@ , const char * @@constchar@@ ) { char * @@char@@ ; size_t @@sizet@@ ; char * @@char@@ ; unsigned __int8 @@unsignedint8@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@sizet@@ = Number ; @@sizet@@ = strlen ( @@constchar@@ ) ; @@sizet@@ = @@sizet@@ ; memcpy ( @@char@@ , @@char@@ , @@sizet@@ ) ; for ( @@char@@ = & @@char@@ [ @@sizet@@ ] ; ; memcpy ( @@char@@ , @@constchar@@ , @@sizet@@ ) ) { @@unsignedint8@@ = * @@unsignedint8@@ ; if ( * @@unsignedint8@@ ) { if ( @@unsignedint8@@ > Number ) @@sizet@@ = @@sizet@@ ; else @@sizet@@ = @@unsignedint8@@ ; @@sizet@@ = @@sizet@@ ; ++ @@unsignedint8@@ ; } if ( @@sizet@@ < @@sizet@@ ) @@sizet@@ = @@sizet@@ ; @@char@@ = & @@char@@ [ - @@sizet@@ ] ; @@sizet@@ -= @@sizet@@ ; memcpy ( @@char@@ , & @@char@@ [ @@sizet@@ ] , @@sizet@@ ) ; if ( ! @@sizet@@ ) break ; @@char@@ = & @@char@@ [ - @@sizet@@ ] ; } return @@char@@ ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
__int64 __fastcall re_node_set_alloc ( _QWORD * @@QWORD@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; * @@QWORD@@ = @@int64@@ ; @@QWORD@@ [ Number ] = Number L ; @@QWORD@@ [ Number ] = malloc ( Number * @@int64@@ ) ; if ( @@QWORD@@ [ Number ] ) @@int64@@ = Number L ; else @@int64@@ = Number L ; return @@int64@@ ; }
unsigned __int64 __fastcall re_node_set_remove_at ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint64@@ ; @@unsignedint64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( @@unsignedint64@@ < @@unsignedint64@@ ) { -- * ( _QWORD * ) ( @@int64@@ + Number ) ; while ( Number ) { @@unsignedint64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( @@unsignedint64@@ >= @@unsignedint64@@ ) break ; * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@unsignedint64@@ ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * ( @@unsignedint64@@ + Number ) ) ; ++ @@unsignedint64@@ ; } } return @@unsignedint64@@ ; }
size_t __fastcall rpl_regerror ( int @@int@@ , __int64 a2 , _BYTE * @@BYTE@@ , size_t @@sizet@@ ) { size_t @@sizet@@ ; const char * @@constchar@@ ; size_t @@sizet@@ ; if ( @@int@@ < Number || @@int@@ > Number ) abort ( ) ; @@constchar@@ = gettext ( & _re_error_msgid [ _re_error_msgid_idx [ @@int@@ ] ] ) ; @@sizet@@ = strlen ( @@constchar@@ ) + Number ; if ( @@sizet@@ ) { @@sizet@@ = @@sizet@@ ; if ( @@sizet@@ > @@sizet@@ ) { @@sizet@@ = @@sizet@@ - Number ; @@BYTE@@ [ @@sizet@@ - Number ] = Number ; } memcpy ( @@BYTE@@ , @@constchar@@ , @@sizet@@ ) ; } return @@sizet@@ ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 __fastcall re_node_set_init_2 ( _QWORD * @@QWORD@@ , unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { * @@QWORD@@ = Number L ; @@QWORD@@ [ Number ] = malloc ( Number ) ; if ( ! @@QWORD@@ [ Number ] ) return Number L ; if ( @@unsignedint64@@ == @@unsignedint64@@ ) { @@QWORD@@ [ Number ] = Number L ; * ( _QWORD * ) @@QWORD@@ [ Number ] = @@unsignedint64@@ ; } else { @@QWORD@@ [ Number ] = Number L ; if ( @@unsignedint64@@ >= @@unsignedint64@@ ) { * ( _QWORD * ) @@QWORD@@ [ Number ] = @@unsignedint64@@ ; * ( _QWORD * ) ( @@QWORD@@ [ Number ] + Number L ) = @@unsignedint64@@ ; } else { * ( _QWORD * ) @@QWORD@@ [ Number ] = @@unsignedint64@@ ; * ( _QWORD * ) ( @@QWORD@@ [ Number ] + Number L ) = @@unsignedint64@@ ; } } return Number L ; }
__int64 __fastcall free_workarea_compile ( __int64 * @@int64@@ ) { __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; @@int64@@ = * @@int64@@ ; for ( @@QWORD@@ = * ( _QWORD * * ) ( * @@int64@@ + Number ) ; @@QWORD@@ ; @@QWORD@@ = @@QWORD@@ ) { @@QWORD@@ = ( _QWORD * ) * @@QWORD@@ ; free ( @@QWORD@@ ) ; } * ( _QWORD * ) ( @@int64@@ + Number ) = Number L ; * ( _DWORD * ) ( @@int64@@ + Number ) = Number ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number L ; free ( * ( void * * ) ( @@int64@@ + Number ) ) ; @@int64@@ = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number L ; return @@int64@@ ; }
void * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
__int64 __fastcall register_state ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; void * @@void@@ ; __int64 @@int64@@ ; * @@QWORD@@ = @@int64@@ ; if ( ( unsigned int ) re_node_set_alloc ( @@QWORD@@ + Number , @@QWORD@@ [ Number ] ) ) return Number L ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@QWORD@@ [ Number ] ; ++ @@unsignedint64@@ ) { @@int64@@ = * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@QWORD@@ [ Number ] ) ; if ( ( * ( _BYTE * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) & Number ) == Number && ( unsigned __int8 ) re_node_set_insert_last ( ( __int64 ) ( @@QWORD@@ + Number ) , @@int64@@ ) != Number ) { return Number L ; } } @@int64@@ = @@QWORD@@ [ Number ] + Number * ( @@int64@@ & @@QWORD@@ [ Number ] ) ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) <= * ( _QWORD * ) @@int64@@ ) { @@int64@@ = * ( _QWORD * ) @@int64@@ + Number L ; @@int64@@ = Number * @@int64@@ ; @@void@@ = realloc ( * ( void * * ) ( @@int64@@ + Number ) , Number * @@int64@@ ) ; if ( ! @@void@@ ) return Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@void@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; } @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = ( * ( _QWORD * ) @@int64@@ ) ++ ; * ( _QWORD * ) ( @@int64@@ + Number * @@int64@@ ) = @@QWORD@@ ; return Number L ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
void * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall re_node_set_insert_last ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; void * @@void@@ ; if ( * ( _QWORD * ) @@int64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ) { * ( _QWORD * ) @@int64@@ = Number * ( * ( _QWORD * ) @@int64@@ + Number L ) ; @@void@@ = realloc ( * ( void * * ) ( @@int64@@ + Number ) , Number L * * ( _QWORD * ) @@int64@@ ) ; if ( ! @@void@@ ) return Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@void@@ ; } @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ + Number ; * ( _QWORD * ) ( @@int64@@ + Number * @@int64@@ ) = @@int64@@ ; return Number L ; }
__int64 __fastcall lower_subexp ( _DWORD * @@DWORD@@ , __int64 * @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; _BOOL4 @@BOOL4@@ ; _BOOL4 @@BOOL4@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = * @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( ( @@int64@@ [ Number ] & Number ) != Number && * ( _QWORD * ) ( @@int64@@ + Number ) && ( * ( _QWORD * ) ( @@int64@@ + Number ) > Number || ( ( * ( _QWORD * ) ( @@int64@@ + Number ) >> * ( _QWORD * ) ( @@int64@@ + Number ) ) & Number L ) == Number ) ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; } @@int64@@ = create_tree ( @@int64@@ , Number L , Number L , Number L ) ; @@int64@@ = create_tree ( @@int64@@ , Number L , Number L , Number L ) ; if ( @@int64@@ ) @@int64@@ = create_tree ( @@int64@@ , @@int64@@ , @@int64@@ , Number L ) ; else @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = create_tree ( @@int64@@ , @@int64@@ , @@int64@@ , Number L ) ; @@BOOL4@@ = ! @@int64@@ || ! @@int64@@ ; @@BOOL4@@ = @@BOOL4@@ || ! @@int64@@ ; if ( ! @@BOOL4@@ && @@int64@@ ) { * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _BYTE * ) ( @@int64@@ + Number ) = ( Number * ( ( * ( _BYTE * ) ( @@int64@@ + Number ) & Number ) != Number ) ) | * ( _BYTE * ) ( @@int64@@ + Number ) & Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = ( Number * ( ( * ( _BYTE * ) ( @@int64@@ + Number ) & Number ) != Number ) ) | * ( _BYTE * ) ( @@int64@@ + Number ) & Number ; @@int64@@ = @@int64@@ ; } else { * @@DWORD@@ = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
void * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
__int64 __fastcall calc_state_hash ( __int64 @@int64@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) + @@unsignedint@@ ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { @@int64@@ += * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; } return @@int64@@ ; }
__int64 __fastcall init_dfa ( void * * @@void@@ , unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; wint_t @@wintt@@ ; size_t @@sizet@@ ; const char * @@constchar@@ ; memset ( @@void@@ , Number , Number ) ; * ( ( _DWORD * ) @@void@@ + Number ) = Number ; if ( @@unsignedint64@@ >= Number ) return Number L ; @@void@@ [ Number ] = ( void * ) ( @@unsignedint64@@ + Number ) ; * @@void@@ = malloc ( Number L * ( _QWORD ) @@void@@ [ Number ] ) ; for ( @@sizet@@ = Number L ; @@sizet@@ <= @@unsignedint64@@ ; @@sizet@@ *= Number L ) { ; } @@void@@ [ Number ] = calloc ( Number , @@sizet@@ ) ; @@void@@ [ Number ] = ( void * ) ( @@sizet@@ - Number ) ; * ( ( _DWORD * ) @@void@@ + Number ) = __ctype_get_mb_cur_max ( ) ; @@constchar@@ = nl_langinfo ( Number ) ; if ( ! strcasecmp ( @@constchar@@ , String ) || ! strcasecmp ( @@constchar@@ , String ) ) * ( ( _BYTE * ) @@void@@ + Number ) |= Number ; * ( ( _BYTE * ) @@void@@ + Number ) &= Number ; if ( * ( ( int * ) @@void@@ + Number ) > Number ) { if ( ( ( _BYTE ) @@void@@ [ Number ] & Number ) != Number ) { @@void@@ [ Number ] = & utf8_sb_map ; } else { @@void@@ [ Number ] = calloc ( Number , Number ) ; if ( ! @@void@@ [ Number ] ) return Number L ; @@int@@ = Number ; @@int@@ = Number ; while ( @@int@@ <= Number ) { for ( @@int@@ = Number ; @@int@@ <= Number ; ++ @@int@@ ) { @@wintt@@ = btowc ( @@int@@ ) ; if ( @@wintt@@ != Number ) * ( ( _QWORD * ) @@void@@ [ Number ] + @@int@@ ) |= Number L << @@int@@ ; if ( ( @@int@@ & Number ) == Number && @@wintt@@ != @@int@@ ) * ( ( _BYTE * ) @@void@@ + Number ) |= Number ; ++ @@int@@ ; } ++ @@int@@ ; } } } if ( * @@void@@ && @@void@@ [ Number ] ) @@int64@@ = Number L ; else @@int64@@ = Number L ; return @@int64@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
__int64 __fastcall calc_eclosure ( __int64 @@int64@@ ) { char @@char@@ ; unsigned int @@unsignedint@@ ; __int64 @@int64@@ ; char @@char@@ [ Number ] ; void * @@void@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@char@@ = Number ; for ( @@int64@@ = Number L ; ; ++ @@int64@@ ) { if ( @@int64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ) { if ( @@char@@ != Number ) return Number L ; @@char@@ = Number ; @@int64@@ = Number L ; } if ( ! * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ + Number ) ) break ; LABEL_11 : ; } @@unsignedint@@ = calc_eclosure_iter ( @@char@@ , @@int64@@ , @@int64@@ , Number L ) ; if ( ! @@unsignedint@@ ) { if ( ! * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ + Number ) ) { @@char@@ = Number ; free ( @@void@@ ) ; } goto LABEL_11 ; } return @@unsignedint@@ ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
void * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall re_acquire_state_context ( _DWORD * @@DWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; unsigned __int64 * @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) { @@int64@@ = calc_state_hash ( @@int64@@ , @@unsignedint@@ ) ; @@unsignedint64@@ = ( unsigned __int64 * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * ( @@int64@@ & * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * @@unsignedint64@@ ; ++ @@unsignedint64@@ ) { @@int64@@ = * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@unsignedint64@@ [ Number ] ) ; if ( @@int64@@ == * ( _QWORD * ) @@int64@@ && @@unsignedint@@ == ( * ( _BYTE * ) ( @@int64@@ + Number ) & Number ) && ( unsigned __int8 ) re_node_set_compare ( * ( _QWORD * ) ( @@int64@@ + Number ) , @@int64@@ ) ) { return @@int64@@ ; } } @@int64@@ = create_cd_newstate ( @@int64@@ , @@int64@@ , @@unsignedint@@ , @@int64@@ ) ; if ( ! @@int64@@ ) * @@DWORD@@ = Number ; @@int64@@ = @@int64@@ ; } else { * @@DWORD@@ = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall parse_branch ( __int64 @@int64@@ , __int64 * @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , _DWORD * @@DWORD@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = * @@int64@@ ; @@int64@@ = parse_expression ( @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@DWORD@@ ) ; if ( * @@DWORD@@ && ! @@int64@@ ) return Number L ; while ( * ( _BYTE * ) ( @@int64@@ + Number ) != Number && * ( _BYTE * ) ( @@int64@@ + Number ) != Number && ( ! @@int64@@ || * ( _BYTE * ) ( @@int64@@ + Number ) != Number ) ) { @@int64@@ = parse_expression ( @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@DWORD@@ ) ; if ( * @@DWORD@@ && ! @@int64@@ ) return Number L ; if ( @@int64@@ && @@int64@@ ) { @@int64@@ = create_tree ( @@int64@@ , @@int64@@ , @@int64@@ , Number L ) ; if ( ! @@int64@@ ) { * @@DWORD@@ = Number ; return Number L ; } } else if ( ! @@int64@@ ) { @@int64@@ = @@int64@@ ; } } return @@int64@@ ; }
__int64 __fastcall argmatch ( const char * @@constchar@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { __int64 @@int64@@ ; char @@char@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; size_t @@sizet@@ ; @@int64@@ = Number ; @@char@@ = Number ; @@sizet@@ = strlen ( @@constchar@@ ) ; for ( @@int64@@ = Number L ; * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; ++ @@int64@@ ) { if ( ! strncmp ( * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) , @@constchar@@ , @@sizet@@ ) ) { if ( @@sizet@@ == strlen ( * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) ) ) return @@int64@@ ; if ( @@int64@@ == Number ) { @@int64@@ = @@int64@@ ; } else if ( ! @@int64@@ || memcmp ( ( const void * ) ( @@sizet@@ * @@int64@@ + @@int64@@ ) , ( const void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) , @@sizet@@ ) ) { @@char@@ = Number ; } } } if ( @@char@@ ) @@int64@@ = Number ; else @@int64@@ = @@int64@@ ; return @@int64@@ ; }
__int64 __fastcall link_nfa_nodes ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; unsigned int @@unsignedint@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@unsignedint@@ = Number ; switch ( * ( _BYTE * ) ( @@int64@@ + Number ) ) { case Number : if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) __assert_fail ( String , String , Number , String ) ; return @@int64@@ ; case Number : * ( _QWORD * ) ( Number * @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) == Number ) re_node_set_init_1 ( ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ ) , * ( _QWORD * ) ( Number * @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; break ; case Number : case Number : case Number : @@unsignedint@@ = re_node_set_init_1 ( ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ ) , * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) ) ; break ; case Number : case Number : * ( _BYTE * ) ( @@int64@@ + Number ) |= Number ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) @@unsignedint64@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) + Number L ) ; else @@unsignedint64@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) @@unsignedint64@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) + Number L ) ; else @@unsignedint64@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) ; if ( @@unsignedint64@@ > Number ) __assert_fail ( String , String , Number , String ) ; if ( @@unsignedint64@@ > Number ) __assert_fail ( String , String , Number , String ) ; @@unsignedint@@ = re_node_set_init_2 ( ( _QWORD * ) ( Number * @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) , @@unsignedint64@@ , @@unsignedint64@@ ) ; break ; case Number : return @@unsignedint@@ ; default : if ( ( * ( _BYTE * ) ( @@int64@@ + Number ) & Number ) != Number ) __assert_fail ( String , String , Number , String ) ; * ( _QWORD * ) ( Number * @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) ; break ; } return @@unsignedint@@ ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
void __fastcall free_dfa_content ( __int64 @@int64@@ ) { unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( * ( _QWORD * ) @@int64@@ ) { for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { free_token ( Number * @@unsignedint64@@ + * ( _QWORD * ) @@int64@@ ) ; } } free ( * ( void * * ) ( @@int64@@ + Number ) ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) free ( * ( void * * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@unsignedint64@@ + Number ) ) ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) free ( * ( void * * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@unsignedint64@@ + Number ) ) ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) free ( * ( void * * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@unsignedint64@@ + Number ) ) ; } free ( * ( void * * ) ( @@int64@@ + Number ) ) ; free ( * ( void * * ) ( @@int64@@ + Number ) ) ; free ( * ( void * * ) ( @@int64@@ + Number ) ) ; free ( * ( void * * ) @@int64@@ ) ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) { for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@unsignedint64@@ ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) @@int64@@ ; ++ @@unsignedint64@@ ) { free_state ( * ( void * * * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; } free ( * ( void * * ) ( @@int64@@ + Number ) ) ; } } free ( * ( void * * ) ( @@int64@@ + Number ) ) ; if ( * ( _UNKNOWN * * ) ( @@int64@@ + Number ) != & utf8_sb_map ) free ( * ( void * * ) ( @@int64@@ + Number ) ) ; free ( * ( void * * ) ( @@int64@@ + Number ) ) ; free ( ( void * ) @@int64@@ ) ; }
__int64 __fastcall parse_bracket_element ( __int64 @@int64@@ , __int64 @@int64@@ , _BYTE * @@BYTE@@ , int @@int@@ , __int64 a5 , char @@char@@ , char @@char@@ ) { __int64 @@int64@@ ; int @@int@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int@@ = re_string_char_size_at ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( @@int@@ <= Number ) { * ( _QWORD * ) ( @@int64@@ + Number ) += @@int@@ ; if ( @@BYTE@@ [ Number ] == Number || @@BYTE@@ [ Number ] == Number || @@BYTE@@ [ Number ] == Number ) { @@int64@@ = parse_bracket_symbol ( @@int64@@ , @@int64@@ , @@BYTE@@ ) ; } else if ( @@BYTE@@ [ Number ] == Number && @@char@@ != Number && ( peek_token_bracket ( @@char@@ , @@int64@@ , @@char@@ ) , @@char@@ [ Number ] != Number ) ) { @@int64@@ = Number L ; } else { * ( _DWORD * ) @@int64@@ = Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = * @@BYTE@@ ; @@int64@@ = Number L ; } } else { * ( _DWORD * ) @@int64@@ = Number ; * ( _DWORD * ) ( @@int64@@ + Number ) = re_string_wchar_at ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ; * ( _QWORD * ) ( @@int64@@ + Number ) += @@int@@ ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall argmatch_to_argument ( const void * @@constvoid@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; ++ @@int64@@ ) { if ( ! memcmp ( @@constvoid@@ , ( const void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) , @@sizet@@ ) ) return * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; } return Number L ; }
__int64 __fastcall build_collating_symbol ( __int64 @@int64@@ , __int64 a2 , __int64 a3 , const char * @@constchar@@ ) { if ( strlen ( @@constchar@@ ) != Number ) return Number L ; bitset_set ( @@int64@@ , * ( unsigned __int8 * ) @@constchar@@ ) ; return Number L ; }
__int64 __fastcall hash_ins ( __int64 @@int64@@ , __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; @@QWORD@@ = ( _QWORD * ) xmalloc ( Number L ) ; * @@QWORD@@ = @@int64@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = hash_insert ( htab , @@QWORD@@ ) ; if ( ! @@int64@@ ) xalloc_die ( ) ; if ( ( _QWORD * ) @@int64@@ == @@QWORD@@ ) return Number L ; free ( @@QWORD@@ ) ; return Number L ; }
__int64 __fastcall mark_opt_subexp ( __int64 @@int64@@ , __int64 @@int64@@ ) { if ( * ( _BYTE * ) ( @@int64@@ + Number ) == Number && @@int64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ) { * ( _BYTE * ) ( @@int64@@ + Number ) |= Number ; } return Number L ; }
__int64 __fastcall build_equiv_class ( __int64 @@int64@@ , __int64 a2 , __int64 a3 , const char * @@constchar@@ ) { if ( strlen ( @@constchar@@ ) != Number ) return Number L ; bitset_set ( @@int64@@ , * ( unsigned __int8 * ) @@constchar@@ ) ; return Number L ; }
__int64 __fastcall search_duplicated_node ( _QWORD * @@QWORD@@ , __int64 @@int64@@ , int @@int@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = @@QWORD@@ [ Number ] - Number L ; ( * ( _BYTE * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) & Number ) != Number && @@int64@@ ; -- @@int64@@ ) { if ( @@int64@@ == * ( _QWORD * ) ( Number * @@int64@@ + @@QWORD@@ [ Number ] ) && @@int@@ == ( ( * ( _DWORD * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) >> Number ) & Number ) ) { return @@int64@@ ; } } return Number ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
_QWORD * __fastcall argv_iter_init_argv ( __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; @@QWORD@@ = malloc ( Number ) ; if ( ! @@QWORD@@ ) return Number L ; * @@QWORD@@ = Number L ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; return @@QWORD@@ ; }
__int64 __fastcall fetch_number ( __int64 @@int64@@ , unsigned __int8 * @@unsignedint8@@ , __int64 @@int64@@ ) { unsigned __int64 @@unsignedint64@@ ; unsigned __int8 @@unsignedint8@@ ; __int64 @@int64@@ ; for ( @@int64@@ = Number ; ; @@int64@@ = @@unsignedint64@@ ) { fetch_token ( ( __int64 ) @@unsignedint8@@ , @@int64@@ , @@int64@@ ) ; @@unsignedint8@@ = * @@unsignedint8@@ ; if ( @@unsignedint8@@ [ Number ] == Number ) return Number ; if ( @@unsignedint8@@ [ Number ] == Number || @@unsignedint8@@ == Number ) break ; if ( @@unsignedint8@@ [ Number ] != Number || @@unsignedint8@@ <= Number || @@unsignedint8@@ > Number || @@int64@@ == Number ) { @@unsignedint64@@ = Number ; } else if ( @@int64@@ == Number ) { @@unsignedint64@@ = @@unsignedint8@@ - Number ; } else { @@unsignedint64@@ = Number * @@int64@@ + @@unsignedint8@@ - Number ; } if ( @@unsignedint64@@ > Number ) @@unsignedint64@@ = Number ; } return @@int64@@ ; }
__int64 __fastcall calc_inveclosure ( _QWORD * @@QWORD@@ ) { unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@QWORD@@ [ Number ] ; ++ @@unsignedint64@@ ) { memset ( ( void * ) ( @@QWORD@@ [ Number ] + Number * @@unsignedint64@@ ) , Number , Number ) ; } for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@QWORD@@ [ Number ] ; ++ @@unsignedint64@@ ) { @@int64@@ = * ( _QWORD * ) ( @@QWORD@@ [ Number ] + Number * @@unsignedint64@@ + Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@QWORD@@ [ Number ] + Number * @@unsignedint64@@ + Number ) ; ++ @@unsignedint64@@ ) { if ( ( unsigned __int8 ) re_node_set_insert_last ( @@QWORD@@ [ Number ] + Number L * * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@int64@@ ) , @@unsignedint64@@ ) != Number ) return Number L ; } } return Number L ; }
__int64 __fastcall duplicate_tree ( __int64 * * @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 * @@int64@@ ; __int64 * @@int64@@ ; __int64 * @@int64@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = & @@int64@@ ; @@int64@@ = * @@int64@@ ; @@int64@@ = ( __int64 * ) @@int64@@ ; while ( Number ) { @@int64@@ = create_token_tree ( @@int64@@ , Number L , Number L , @@int64@@ + Number ) ; * @@int64@@ = @@int64@@ ; if ( ! * @@int64@@ ) break ; * ( _QWORD * ) * @@int64@@ = @@int64@@ ; * ( _BYTE * ) ( * @@int64@@ + Number ) |= Number ; @@int64@@ = ( __int64 * ) * @@int64@@ ; if ( @@int64@@ [ Number ] ) { @@int64@@ = ( __int64 * ) @@int64@@ [ Number ] ; @@int64@@ = @@int64@@ + Number ; } else { @@int64@@ = Number L ; while ( @@int64@@ == ( __int64 * ) @@int64@@ [ Number ] || ! @@int64@@ [ Number ] ) { @@int64@@ = @@int64@@ ; @@int64@@ = ( __int64 * ) * @@int64@@ ; @@int64@@ = ( __int64 * ) * @@int64@@ ; if ( ! @@int64@@ ) return @@int64@@ ; } @@int64@@ = ( __int64 * ) @@int64@@ [ Number ] ; @@int64@@ = @@int64@@ + Number ; } } return Number L ; }
__int64 __fastcall argv_iter ( __int64 @@int64@@ , int * @@int@@ ) { int @@int@@ ; __int64 @@int64@@ ; __int64 * @@int64@@ ; if ( * ( _QWORD * ) @@int64@@ ) { if ( getdelim ( ( char * * ) ( @@int64@@ + Number ) , ( size_t * ) ( @@int64@@ + Number ) , Number , * ( FILE * * ) @@int64@@ ) >= Number ) { * @@int@@ = Number ; ++ * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; } else { if ( feof ( * ( FILE * * ) @@int64@@ ) ) @@int@@ = Number ; else @@int@@ = Number ; * @@int@@ = @@int@@ ; @@int64@@ = Number L ; } } else if ( * * ( _QWORD * * ) ( @@int64@@ + Number ) ) { * @@int@@ = Number ; @@int64@@ = * ( __int64 * * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ + Number ; @@int64@@ = * @@int64@@ ; } else { * @@int@@ = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
void __fastcall free_token ( __int64 @@int64@@ ) { if ( * ( _BYTE * ) ( @@int64@@ + Number ) != Number || ( * ( _BYTE * ) ( @@int64@@ + Number ) & Number ) != Number ) { if ( * ( _BYTE * ) ( @@int64@@ + Number ) == Number && ( * ( _BYTE * ) ( @@int64@@ + Number ) & Number ) == Number ) free ( * ( void * * ) @@int64@@ ) ; } else { free_charset ( * ( void * * * ) @@int64@@ ) ; } }
__int64 __fastcall mode_adjust ( __int16 @@int16@@ , unsigned __int8 @@unsignedint8@@ , int @@int@@ , char * @@char@@ , _DWORD * @@DWORD@@ ) { int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; @@unsignedint@@ = @@int16@@ & Number ; @@int@@ = Number ; while ( @@char@@ [ Number ] ) { @@int@@ = * ( ( _DWORD * ) @@char@@ + Number ) ; if ( @@unsignedint8@@ ) @@int@@ = Number ; else @@int@@ = Number ; @@int@@ = @@int@@ & ~ * ( ( _DWORD * ) @@char@@ + Number ) ; @@int@@ = * ( ( _DWORD * ) @@char@@ + Number ) ; @@int@@ = @@char@@ [ Number ] ; if ( @@int@@ == Number ) { if ( @@unsignedint@@ & Number | @@unsignedint8@@ ) @@int@@ |= Number ; } else if ( @@int@@ == Number ) { @@int@@ = @@unsignedint@@ & @@int@@ ; if ( ( @@int@@ & Number ) != Number ) @@int@@ = Number ; else @@int@@ = Number ; if ( ( @@int@@ & Number ) != Number ) @@int@@ = Number ; else @@int@@ = Number ; @@int@@ = @@int@@ | @@int@@ ; if ( ( @@int@@ & Number ) != Number ) @@int@@ = Number ; else @@int@@ = Number ; @@int@@ = @@int@@ | @@int@@ | @@int@@ ; } if ( @@int@@ ) @@int@@ = * ( ( _DWORD * ) @@char@@ + Number ) ; else @@int@@ = ~ @@int@@ ; @@int@@ = ~ @@int@@ & @@int@@ & @@int@@ ; @@int@@ = * @@char@@ ; switch ( @@int@@ ) { case String : @@int@@ |= @@int@@ ; @@unsignedint@@ &= ~ @@int@@ ; break ; case String : if ( @@int@@ ) @@int@@ = ~ @@int@@ ; else @@int@@ = Number ; @@int@@ |= ~ ( ( unsigned __int16 ) @@int@@ | ( unsigned __int16 ) @@int@@ ) & Number ; @@unsignedint@@ = @@int@@ | ( @@int@@ | @@int@@ ) & @@unsignedint@@ ; break ; case String : @@int@@ |= @@int@@ ; @@unsignedint@@ |= @@int@@ ; break ; } @@char@@ += Number ; } if ( @@DWORD@@ ) * @@DWORD@@ = @@int@@ ; return @@unsignedint@@ ; }
__int64 __fastcall parse ( __int64 @@int64@@ , __int64 * @@int64@@ , __int64 @@int64@@ , _DWORD * @@DWORD@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = * @@int64@@ ; * ( _QWORD * ) ( * @@int64@@ + Number ) = @@int64@@ ; fetch_token ( ( __int64 ) @@char@@ , @@int64@@ , @@int64@@ | Number ) ; @@int64@@ = parse_reg_exp ( @@int64@@ , @@int64@@ , @@char@@ , @@int64@@ , Number L , @@DWORD@@ ) ; if ( * @@DWORD@@ && ! @@int64@@ ) return Number L ; @@int64@@ = create_tree ( @@int64@@ , Number L , Number L , Number L ) ; if ( @@int64@@ ) @@int64@@ = create_tree ( @@int64@@ , @@int64@@ , @@int64@@ , Number L ) ; else @@int64@@ = @@int64@@ ; if ( @@int64@@ && @@int64@@ ) return @@int64@@ ; * @@DWORD@@ = Number ; return Number L ; }
_BOOL8 __fastcall check_halt_node_context ( _QWORD * @@QWORD@@ , __int64 @@int64@@ , char @@char@@ ) { if ( * ( _BYTE * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) != Number ) return Number L ; if ( ( ( * ( _DWORD * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) >> Number ) & Number ) == Number ) return Number L ; return ( ( * ( _DWORD * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) & Number ) == Number || ( @@char@@ & Number ) != Number ) && ( ( * ( _DWORD * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) & Number ) == Number || ( @@char@@ & Number ) == Number ) && ( ( * ( _DWORD * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) & Number ) == Number || ( @@char@@ & Number ) != Number ) && ( ( * ( _DWORD * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) & Number ) == Number || ( @@char@@ & Number ) != Number ) ; }
__int64 __fastcall strnlen1 ( const void * @@constvoid@@ , size_t @@sizet@@ ) { __int64 @@int64@@ ; _BYTE * @@BYTE@@ ; @@BYTE@@ = memchr ( @@constvoid@@ , Number , @@sizet@@ ) ; if ( @@BYTE@@ ) @@int64@@ = @@BYTE@@ - ( _BYTE * ) @@constvoid@@ + Number ; else @@int64@@ = @@sizet@@ ; return @@int64@@ ; }
__int64 __fastcall re_search_2_stub ( int @@int@@ , const void * @@constvoid@@ , size_t @@sizet@@ , const void * @@constvoid@@ , size_t @@sizet@@ , int @@int@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int64@@ ; char * @@char@@ ; size_t @@sizet@@ ; __int64 @@int64@@ ; @@sizet@@ = @@sizet@@ + @@sizet@@ ; @@char@@ = Number L ; if ( @@sizet@@ + @@sizet@@ < @@sizet@@ ) return Number ; if ( @@sizet@@ ) { if ( @@sizet@@ ) { @@char@@ = ( char * ) malloc ( @@sizet@@ ) ; if ( ! @@char@@ ) return Number ; memcpy ( @@char@@ , @@constvoid@@ , @@sizet@@ ) ; memcpy ( & @@char@@ [ @@sizet@@ ] , @@constvoid@@ , @@sizet@@ ) ; @@int64@@ = re_search_stub ( @@int@@ , ( _DWORD ) @@char@@ , @@sizet@@ , @@int@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@unsignedint8@@ ) ; } else { @@int64@@ = re_search_stub ( @@int@@ , ( _DWORD ) @@constvoid@@ , @@sizet@@ , @@int@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@unsignedint8@@ ) ; } } else { @@int64@@ = re_search_stub ( @@int@@ , ( _DWORD ) @@constvoid@@ , @@sizet@@ , @@int@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@unsignedint8@@ ) ; } @@int64@@ = @@int64@@ ; free ( @@char@@ ) ; return @@int64@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall parse_sub_exp ( __int64 @@int64@@ , __int64 * @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , _DWORD * @@DWORD@@ ) { unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int64@@ = * @@int64@@ ; @@unsignedint64@@ = @@int64@@ [ Number ] ; @@int64@@ [ Number ] = @@unsignedint64@@ + Number ; @@unsignedint64@@ = @@unsignedint64@@ ; fetch_token ( @@int64@@ , @@int64@@ , @@int64@@ | Number ) ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) == Number ) { @@int64@@ = Number L ; } else { @@int64@@ = parse_reg_exp ( @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@DWORD@@ ) ; if ( ! * @@DWORD@@ && * ( _BYTE * ) ( @@int64@@ + Number ) != Number ) * @@DWORD@@ = Number ; if ( * @@DWORD@@ ) return Number L ; } if ( @@unsignedint64@@ <= Number ) * ( _QWORD * ) ( @@int64@@ + Number ) |= Number << @@unsignedint64@@ ; @@int64@@ = create_tree ( @@int64@@ , @@int64@@ , Number L , Number L ) ; if ( @@int64@@ ) { * ( _QWORD * ) ( @@int64@@ + Number ) = @@unsignedint64@@ ; @@int64@@ = @@int64@@ ; } else { * @@DWORD@@ = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
_QWORD * __fastcall update_regs ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ , void * @@void@@ , __int64 @@int64@@ , _QWORD * @@QWORD@@ , unsigned __int64 @@unsignedint64@@ ) { _QWORD * @@QWORD@@ ; int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@QWORD@@ = ( _QWORD * ) * ( unsigned __int8 * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) ; @@int@@ = * ( unsigned __int8 * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) ; if ( @@int@@ == Number ) { @@unsignedint64@@ = * ( _QWORD * ) ( Number * @@int64@@ + * @@QWORD@@ ) + Number L ; @@QWORD@@ = ( _QWORD * ) @@unsignedint64@@ ; if ( @@unsignedint64@@ < @@unsignedint64@@ ) { @@QWORD@@ [ Number * @@unsignedint64@@ ] = @@QWORD@@ ; @@QWORD@@ = & @@QWORD@@ [ Number * @@unsignedint64@@ ] ; @@QWORD@@ [ Number ] = Number ; } } else if ( @@int@@ == Number ) { @@unsignedint64@@ = * ( _QWORD * ) ( Number * @@int64@@ + * @@QWORD@@ ) + Number L ; @@QWORD@@ = ( _QWORD * ) @@unsignedint64@@ ; if ( @@unsignedint64@@ < @@unsignedint64@@ ) { if ( ( unsigned __int64 ) @@QWORD@@ <= @@QWORD@@ [ Number * @@unsignedint64@@ ] ) { if ( ( * ( _BYTE * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) & Number ) == Number || * ( ( _QWORD * ) @@void@@ + Number * @@unsignedint64@@ ) == Number ) { @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ [ Number * @@unsignedint64@@ + Number ] = @@QWORD@@ ; } else { @@QWORD@@ = memcpy ( @@QWORD@@ , @@void@@ , Number * @@unsignedint64@@ ) ; } } else { @@QWORD@@ [ Number * @@unsignedint64@@ + Number ] = @@QWORD@@ ; @@QWORD@@ = memcpy ( @@void@@ , @@QWORD@@ , Number * @@unsignedint64@@ ) ; } } } return @@QWORD@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ ) { return xmalloc ( @@int64@@ ) ; }
__int64 __fastcall free_fail_stack_return ( __int64 @@int64@@ ) { unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) { for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) @@int64@@ ; ++ @@unsignedint64@@ ) { free ( * ( void * * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@unsignedint64@@ + Number ) ) ; free ( * ( void * * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@unsignedint64@@ + Number ) ) ; } free ( * ( void * * ) ( @@int64@@ + Number ) ) ; } return Number L ; }
__int64 __fastcall create_tree ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , char @@char@@ ) { char @@char24@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@char24@@ [ Number ] = @@char@@ ; return create_token_tree ( @@int64@@ , @@int64@@ , @@int64@@ , @@char24@@ ) ; }
__int64 __fastcall update_cur_sifted_state ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; unsigned int @@unsignedint@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = @@QWORD@@ [ Number ] ; @@unsignedint@@ = Number ; if ( * ( _QWORD * ) ( Number * @@int64@@ + @@QWORD@@ [ Number ] ) ) @@int64@@ = * ( _QWORD * ) ( Number * @@int64@@ + @@QWORD@@ [ Number ] ) + Number L ; else @@int64@@ = Number L ; @@int64@@ = @@int64@@ ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) { if ( @@int64@@ ) { @@unsignedint@@ = add_epsilon_src_nodes ( @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; if ( @@QWORD@@ [ Number ] ) { @@unsignedint@@ = check_subexp_limits ( @@int64@@ , @@int64@@ , @@int64@@ , @@QWORD@@ + Number , @@QWORD@@ [ Number ] , @@int64@@ ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; } } @@QWORD@@ = ( _QWORD * ) ( * @@QWORD@@ + Number * @@int64@@ ) ; * @@QWORD@@ = re_acquire_state ( & @@unsignedint@@ , @@int64@@ , @@int64@@ ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; } else { * ( _QWORD * ) ( Number * @@int64@@ + * @@QWORD@@ ) = Number L ; } if ( @@int64@@ && ( * ( _BYTE * ) ( * ( _QWORD * ) ( Number * @@int64@@ + @@QWORD@@ [ Number ] ) + Number L ) & Number ) != Number && ( @@unsignedint@@ = sift_states_bkref ( @@QWORD@@ , @@QWORD@@ , @@int64@@ , @@int64@@ ) ) != Number ) { @@int64@@ = @@unsignedint@@ ; } else { @@int64@@ = Number L ; } return @@int64@@ ; }
int __fastcall emit_blocksize_note ( __int64 @@int64@@ ) { char * @@char@@ ; @@char@@ = gettext ( String String String String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
__int64 __fastcall rpl_re_match ( int @@int@@ , int @@int@@ , int @@int@@ , int @@int@@ , __int64 @@int64@@ ) { return re_search_stub ( @@int@@ , @@int@@ , @@int@@ , @@int@@ , Number , @@int@@ , @@int64@@ , Number ) ; }
void __fastcall argmatch_invalid ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { char * @@char@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; char * @@char@@ ; if ( @@int64@@ == Number ) @@char@@ = gettext ( String ) ; else @@char@@ = gettext ( String ) ; @@char@@ = @@char@@ ; @@int64@@ = quote_n ( Number L , @@int64@@ ) ; @@int64@@ = quotearg_n_style ( Number L , Number L , @@int64@@ ) ; error ( Number , Number , @@char@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall sift_states_backward ( __int64 @@int64@@ , __int64 @@int64@@ ) { int @@int@@ ; unsigned int @@unsignedint@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; __int64 @@int64@@ ; void * @@void@@ [ Number ] ; void * @@void@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int@@ = Number ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@unsignedint@@ = re_node_set_init_1 ( @@void@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; @@unsignedint@@ = update_cur_sifted_state ( @@int64@@ , @@int64@@ , @@int64@@ , @@void@@ ) ; if ( ! @@unsignedint@@ ) { while ( @@int64@@ ) { if ( * ( _QWORD * ) ( Number * @@int64@@ + * ( _QWORD * ) @@int64@@ ) ) @@int@@ = Number ; else @@int@@ = @@int@@ + Number ; @@int@@ = @@int@@ ; if ( @@int@@ > * ( _DWORD * ) ( @@int64@@ + Number ) ) { memset ( * ( void * * ) @@int64@@ , Number , Number * @@int64@@ ) ; free ( @@void@@ ) ; return Number L ; } @@void@@ [ Number ] = Number L ; -- @@int64@@ ; if ( ! * ( _QWORD * ) ( Number * @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) || ( @@unsignedint@@ = build_sifted_states ( @@int64@@ , @@int64@@ , @@int64@@ , @@void@@ ) ) == Number ) { @@unsignedint@@ = update_cur_sifted_state ( @@int64@@ , @@int64@@ , @@int64@@ , @@void@@ ) ; if ( ! @@unsignedint@@ ) continue ; } goto LABEL_15 ; } @@unsignedint@@ = Number ; } LABEL_15 : free ( @@void@@ ) ; return @@unsignedint@@ ; }
__int64 __fastcall bad_cast ( __int64 @@int64@@ ) { return @@int64@@ ; }
__int64 __fastcall sift_states_iter_mb ( __int64 @@int64@@ , _QWORD * @@QWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { int @@int@@ ; __int64 @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int@@ = check_node_accept_bytes ( @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( @@int@@ > Number && @@unsignedint64@@ >= @@int@@ + @@int64@@ && ( ! * ( _QWORD * ) ( Number * ( @@int@@ + @@int64@@ ) + * @@QWORD@@ ) || ! re_node_set_contains ( * ( _QWORD * ) ( Number * ( @@int@@ + @@int64@@ ) + * @@QWORD@@ ) + Number L , * ( _QWORD * ) ( Number * @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ) ) { @@int@@ = Number ; } return ( unsigned int ) @@int@@ ; }
__int64 __fastcall rpl_re_search ( int @@int@@ , int @@int@@ , int @@int@@ , int @@int@@ , int @@int@@ , __int64 @@int64@@ ) { return re_search_stub ( @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int64@@ , Number ) ; }
__int64 __fastcall fprintftime ( FILE * @@FILE@@ , char * @@char@@ , __int64 @@int64@@ , unsigned int @@unsignedint@@ , unsigned int @@unsignedint@@ ) { return strftime_case_ ( Number , @@FILE@@ , @@char@@ , @@int64@@ , @@unsignedint@@ , @@unsignedint@@ ) ; }
__int64 __fastcall add_epsilon_src_nodes ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { unsigned int @@unsignedint@@ ; unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@unsignedint@@ = Number ; @@QWORD@@ = re_acquire_state ( & @@unsignedint@@ , @@int64@@ , @@int64@@ ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; if ( ! @@QWORD@@ [ Number ] ) { @@unsignedint@@ = re_node_set_alloc ( @@QWORD@@ + Number , * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint@@ ) return Number L ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { re_node_set_merge ( ( __int64 ) ( @@QWORD@@ + Number ) , * ( _QWORD * ) ( @@int64@@ + Number ) + Number L * * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; } } return re_node_set_add_intersect ( @@int64@@ , @@int64@@ , ( __int64 ) ( @@QWORD@@ + Number ) ) ; }
__int64 __fastcall get_stat_atime ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 __fastcall rpl_re_search_2 ( int @@int@@ , int @@int@@ , int @@int@@ , int @@int@@ , int @@int@@ , int @@int@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return re_search_2_stub ( @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int64@@ , @@int64@@ , @@int64@@ , Number ) ; }
__int64 __fastcall get_stat_ctime ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 __fastcall check_subexp_matching_top ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { unsigned int @@unsignedint@@ ; unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; @@QWORD@@ = * ( _QWORD * * ) ( @@int64@@ + Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { @@int64@@ = * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( * ( _BYTE * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) == Number && * ( _QWORD * ) ( Number * @@int64@@ + * @@QWORD@@ ) <= Number && ( ( @@QWORD@@ [ Number ] >> * ( _QWORD * ) ( Number * @@int64@@ + * @@QWORD@@ ) ) & Number L ) != Number ) { @@unsignedint@@ = match_ctx_add_subtop ( @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; } } return Number L ; }
_BOOL8 __fastcall AD_compare ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ ) { return @@QWORD@@ [ Number ] == @@QWORD@@ [ Number ] && * @@QWORD@@ == * @@QWORD@@ ; }
__int64 __fastcall get_stat_mtime ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 __fastcall check_dst_limits_calc_pos ( __int64 @@int64@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ ; if ( @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ) return Number ; if ( @@unsignedint64@@ > * ( _QWORD * ) ( @@int64@@ + Number ) ) return Number L ; if ( @@unsignedint64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ) @@int@@ = Number ; else @@int@@ = Number ; @@int@@ = @@int@@ | ( @@unsignedint64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( @@int@@ ) @@int64@@ = check_dst_limits_calc_pos_1 ( @@int64@@ , @@int@@ , @@unsignedint64@@ , @@int64@@ , @@int64@@ ) ; else @@int64@@ = Number L ; return @@int64@@ ; }
unsigned __int64 __fastcall AD_hash ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) % @@unsignedint64@@ ; }
__int64 __fastcall duinfo_set ( _QWORD * @@QWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; * @@QWORD@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; return @@int64@@ ; }
__int64 __fastcall prune_impossible_nodes ( __int64 @@int64@@ ) { unsigned int @@unsignedint@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; char @@char@@ [ Number ] ; void * @@void@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ = Number L ; @@unsignedint64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( @@unsignedint64@@ > Number ) return Number L ; @@QWORD@@ = malloc ( Number * ( @@unsignedint64@@ + Number ) ) ; if ( @@QWORD@@ ) { if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) { @@QWORD@@ = malloc ( Number * ( @@unsignedint64@@ + Number ) ) ; if ( @@QWORD@@ ) { while ( Number ) { memset ( @@QWORD@@ , Number , Number * ( @@unsignedint64@@ + Number ) ) ; sift_ctx_init ( @@char@@ , @@QWORD@@ , @@QWORD@@ , @@int64@@ , @@unsignedint64@@ ) ; @@unsignedint@@ = sift_states_backward ( @@int64@@ , @@char@@ ) ; free ( @@void@@ ) ; if ( @@unsignedint@@ ) break ; if ( * @@QWORD@@ || * @@QWORD@@ ) { @@unsignedint@@ = merge_state_array ( @@int64@@ , @@QWORD@@ , @@QWORD@@ , @@unsignedint64@@ + Number ) ; free ( @@QWORD@@ ) ; @@QWORD@@ = Number L ; if ( ! @@unsignedint@@ ) goto LABEL_21 ; break ; } do { if ( -- @@unsignedint64@@ > Number ) { @@unsignedint@@ = Number ; goto LABEL_22 ; } } while ( ! * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) || ( * ( _BYTE * ) ( * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) + Number L ) & Number ) == Number ) ; @@int64@@ = check_halt_state_context ( @@int64@@ , * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) , @@unsignedint64@@ ) ; } } else { @@unsignedint@@ = Number ; } } else { sift_ctx_init ( @@char@@ , @@QWORD@@ , Number L , @@int64@@ , @@unsignedint64@@ ) ; @@unsignedint@@ = sift_states_backward ( @@int64@@ , @@char@@ ) ; free ( @@void@@ ) ; if ( ! @@unsignedint@@ ) { if ( * @@QWORD@@ ) { LABEL_21 : free ( * ( void * * ) ( @@int64@@ + Number ) ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@QWORD@@ ; @@QWORD@@ = Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@unsignedint64@@ ; @@unsignedint@@ = Number ; } else { @@unsignedint@@ = Number ; } } } } else { @@unsignedint@@ = Number ; } LABEL_22 : free ( @@QWORD@@ ) ; free ( @@QWORD@@ ) ; return @@unsignedint@@ ; }
unsigned __int64 __fastcall entry_hash ( _QWORD * @@QWORD@@ , unsigned __int64 @@unsignedint64@@ ) { return * @@QWORD@@ % @@unsignedint64@@ ; }
_BOOL8 __fastcall check_node_accept ( __int64 @@int64@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { int @@int@@ ; _BOOL8 @@BOOL8@@ ; char @@char@@ ; char @@char@@ ; @@char@@ = * ( _BYTE * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + @@unsignedint64@@ ) ; @@int@@ = * ( unsigned __int8 * ) ( @@int64@@ + Number ) ; if ( @@int@@ == Number ) { if ( ! bitset_contain ( * ( _QWORD * ) @@int64@@ , ( unsigned __int8 ) @@char@@ ) ) return Number L ; } else if ( * ( unsigned __int8 * ) ( @@int64@@ + Number ) > Number ) { if ( @@int@@ != Number ) { if ( @@int@@ != Number ) return Number L ; if ( @@char@@ < Number ) return Number L ; } if ( @@char@@ == Number && ( * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) & Number ) == Number || ! @@char@@ && ( * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) & Number ) != Number ) { return Number L ; } } else { if ( @@int@@ != Number ) return Number L ; if ( @@char@@ != * ( _BYTE * ) @@int64@@ ) return Number L ; } @@BOOL8@@ = Number ; if ( ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number ) { if ( ( @@char@@ = re_string_context_at ( @@int64@@ , @@unsignedint64@@ , * ( _DWORD * ) ( @@int64@@ + Number ) ) , ( ( * ( _DWORD * ) ( @@int64@@ + Number ) >> Number ) & Number ) != Number ) && ( @@char@@ & Number ) == Number || ( ( * ( _DWORD * ) ( @@int64@@ + Number ) >> Number ) & Number ) != Number && ( @@char@@ & Number ) != Number || ( ( * ( _DWORD * ) ( @@int64@@ + Number ) >> Number ) & Number ) != Number && ( @@char@@ & Number ) == Number || ( ( * ( _DWORD * ) ( @@int64@@ + Number ) >> Number ) & Number ) != Number && ( @@char@@ & Number ) == Number ) { @@BOOL8@@ = Number ; } } return @@BOOL8@@ ; }
__int64 __fastcall setup_dir ( __int64 @@int64@@ ) { if ( ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number ) { * ( _QWORD * ) ( @@int64@@ + Number ) = hash_initialize ( Number L , Number L , AD_hash , AD_compare , & free ) ; if ( ! * ( _QWORD * ) ( @@int64@@ + Number ) ) return Number L ; } else { * ( _QWORD * ) ( @@int64@@ + Number ) = malloc ( Number ) ; if ( ! * ( _QWORD * ) ( @@int64@@ + Number ) ) return Number L ; cycle_check_init ( * ( _QWORD * ) ( @@int64@@ + Number ) ) ; } return Number L ; }
__int64 __fastcall transit_state ( _DWORD * @@DWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int8 @@unsignedint8@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; if ( ( * ( _BYTE * ) ( @@int64@@ + Number ) & Number ) != Number ) { * @@DWORD@@ = transit_state_mb ( @@int64@@ , @@int64@@ ) ; if ( * @@DWORD@@ ) return Number L ; } @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ + Number ; @@unsignedint8@@ = * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) ; while ( Number ) { @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( @@int64@@ ) return * ( _QWORD * ) ( Number L * @@unsignedint8@@ + @@int64@@ ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( @@int64@@ ) break ; if ( ( unsigned __int8 ) build_trtable ( * ( _QWORD * ) ( @@int64@@ + Number ) , @@int64@@ ) != Number ) { * @@DWORD@@ = Number ; return Number L ; } } if ( ( re_string_context_at ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) - Number L , * ( _DWORD * ) ( @@int64@@ + Number ) ) & Number ) != Number ) @@int64@@ = Number * ( @@unsignedint8@@ + Number L ) ; else @@int64@@ = Number L * @@unsignedint8@@ ; return * ( _QWORD * ) ( @@int64@@ + @@int64@@ ) ; }
_BOOL8 __fastcall entry_compare ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ ) { return * @@QWORD@@ == * @@QWORD@@ && @@QWORD@@ [ Number ] == @@QWORD@@ [ Number ] ; }
__int64 __fastcall search_cur_bkref_entry ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@unsignedint64@@ = Number L ; while ( @@unsignedint64@@ < @@unsignedint64@@ ) { if ( @@unsignedint64@@ <= * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * ( ( @@unsignedint64@@ + @@unsignedint64@@ ) >> Number ) + Number ) ) @@unsignedint64@@ = ( @@unsignedint64@@ + @@unsignedint64@@ ) >> Number ; else @@unsignedint64@@ = ( ( @@unsignedint64@@ + @@unsignedint64@@ ) >> Number ) + Number ; } if ( @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) && @@unsignedint64@@ == * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@unsignedint64@@ + Number ) ) { @@int64@@ = @@unsignedint64@@ ; } else { @@int64@@ = Number ; } return @@int64@@ ; }
unsigned __int64 __fastcall show_date ( __int64 @@int64@@ , time_t @@timet@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; char * @@char@@ ; time_t @@timet@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; struct tm * @@structtm@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@int64@@ = @@int64@@ ; @@timet@@ = @@timet@@ ; @@int64@@ = @@int64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@structtm@@ = localtime ( & @@timet@@ ) ; if ( @@structtm@@ ) { fprintftime ( stdout , @@int64@@ , @@structtm@@ , Number L , ( unsigned int ) @@int64@@ ) ; } else { @@int64@@ = timetostr ( @@timet@@ , ( __int64 ) @@char@@ ) ; @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ , @@int64@@ ) ; fputs_unlocked ( @@char@@ , stdout ) ; } return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall get_subexp_sub ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; unsigned int @@unsignedint@@ ; unsigned int @@unsignedint@@ ; @@unsignedint@@ = check_arrival ( ( _DWORD ) @@QWORD@@ , ( int ) @@QWORD@@ + Number , * @@QWORD@@ , @@QWORD@@ [ Number ] , @@int64@@ , @@int64@@ , Number ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; @@unsignedint@@ = match_ctx_add_entry ( @@QWORD@@ , @@int64@@ , @@int64@@ , * @@QWORD@@ , @@QWORD@@ [ Number ] ) ; if ( @@unsignedint@@ ) @@int64@@ = @@unsignedint@@ ; else @@int64@@ = clean_state_log_if_needed ( @@QWORD@@ , @@int64@@ + @@QWORD@@ [ Number ] - * @@QWORD@@ ) ; return @@int64@@ ; }
unsigned __int64 __fastcall leave_dir ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 * @@int64@@ ; __int64 * @@int64@@ ; void * @@void@@ ; __int64 @@int643@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = ( __int64 * ) ( @@int64@@ + Number ) ; if ( ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number ) { @@int643@@ [ Number ] = * @@int64@@ ; @@int643@@ [ Number ] = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@void@@ = ( void * ) hash_delete ( * ( _QWORD * ) ( @@int64@@ + Number ) , @@int643@@ ) ; if ( ! @@void@@ ) abort ( ) ; free ( @@void@@ ) ; } else { @@int64@@ = * ( __int64 * * ) ( @@int64@@ + Number ) ; if ( @@int64@@ && @@int64@@ [ Number ] >= Number ) { if ( ! * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) ) abort ( ) ; if ( * * ( _QWORD * * ) ( @@int64@@ + Number ) == * ( _QWORD * ) ( @@int64@@ + Number ) && * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) == * @@int64@@ ) { * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) = @@int64@@ [ Number ] ; * * ( _QWORD * * ) ( @@int64@@ + Number ) = @@int64@@ [ Number ] ; } } } return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall merge_state_array ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { _QWORD * @@QWORD@@ ; unsigned int @@unsignedint@@ ; unsigned __int64 @@unsignedint64@@ ; void * @@void6@@ [ Number ] ; @@void6@@ [ Number ] = ( void * ) __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@unsignedint64@@ ; ++ @@unsignedint64@@ ) { if ( * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@int64@@ ) ) { if ( * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@int64@@ ) ) { @@unsignedint@@ = re_node_set_init_union ( @@void6@@ , * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@int64@@ ) + Number L , * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@int64@@ ) + Number L ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; @@QWORD@@ = ( _QWORD * ) ( Number * @@unsignedint64@@ + @@int64@@ ) ; * @@QWORD@@ = re_acquire_state ( & @@unsignedint@@ , @@int64@@ , ( __int64 ) @@void6@@ ) ; free ( @@void6@@ [ Number ] ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; } } else { * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@int64@@ ) = * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@int64@@ ) ; } } return Number L ; }
bool __fastcall is_basic_0 ( unsigned __int8 @@unsignedint8@@ ) { return ( ( is_basic_table [ @@unsignedint8@@ >> Number ] >> ( @@unsignedint8@@ & Number ) ) & Number ) != Number ; }
_QWORD * __fastcall match_ctx_add_sublast ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; void * @@void@@ ; _QWORD * @@QWORD@@ ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) == * ( _QWORD * ) ( @@int64@@ + Number ) ) { @@int64@@ = Number L * * ( _QWORD * ) ( @@int64@@ + Number ) + Number ; @@void@@ = realloc ( * ( void * * ) ( @@int64@@ + Number ) , Number * @@int64@@ ) ; if ( ! @@void@@ ) return Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@void@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; } @@QWORD@@ = calloc ( Number , Number ) ; if ( @@QWORD@@ ) { * ( _QWORD * ) ( Number L * * ( _QWORD * ) ( @@int64@@ + Number ) + * ( _QWORD * ) ( @@int64@@ + Number ) ) = @@QWORD@@ ; * @@QWORD@@ = @@int64@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; ++ * ( _QWORD * ) ( @@int64@@ + Number ) ; } return @@QWORD@@ ; }
__int64 __fastcall check_arrival_expand_ecl_sub ( _QWORD * @@QWORD@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , unsigned int @@unsignedint@@ ) { unsigned __int64 @@unsignedint64@@ ; unsigned int @@unsignedint@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint64@@ ; for ( @@unsignedint64@@ = re_node_set_contains ( @@int64@@ , @@unsignedint64@@ ) ; ! @@unsignedint64@@ ; @@unsignedint64@@ = re_node_set_contains ( @@int64@@ , @@unsignedint64@@ ) ) { if ( @@unsignedint@@ == * ( unsigned __int8 * ) ( Number * @@unsignedint64@@ + * @@QWORD@@ + Number ) && @@int64@@ == * ( _QWORD * ) ( Number * @@unsignedint64@@ + * @@QWORD@@ ) ) { if ( @@unsignedint@@ == Number && ! re_node_set_insert ( @@int64@@ , @@unsignedint64@@ ) ) { return Number L ; } return Number L ; } if ( ! re_node_set_insert ( @@int64@@ , @@unsignedint64@@ ) ) return Number L ; if ( ! * ( _QWORD * ) ( @@QWORD@@ [ Number ] + Number * @@unsignedint64@@ + Number ) ) return Number L ; if ( * ( _QWORD * ) ( @@QWORD@@ [ Number ] + Number * @@unsignedint64@@ + Number ) == Number L ) { @@unsignedint@@ = check_arrival_expand_ecl_sub ( @@QWORD@@ , @@int64@@ , * ( _QWORD * ) ( * ( _QWORD * ) ( @@QWORD@@ [ Number ] + Number * @@unsignedint64@@ + Number ) + Number L ) , @@int64@@ , @@unsignedint@@ ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; } @@unsignedint64@@ = * * ( _QWORD * * ) ( @@QWORD@@ [ Number ] + Number * @@unsignedint64@@ + Number ) ; } return Number L ; }
__int64 __fastcall set_stat_type ( __int64 @@int64@@ , int @@int@@ ) { __int64 @@int64@@ ; int @@int@@ ; switch ( @@int@@ ) { case Number : @@int@@ = Number ; break ; case Number : @@int@@ = Number ; break ; case Number : @@int@@ = Number ; break ; case Number : @@int@@ = Number ; break ; case Number : @@int@@ = Number ; break ; case Number : @@int@@ = Number ; break ; case Number : @@int@@ = Number ; break ; default : @@int@@ = Number ; break ; } @@int64@@ = @@int64@@ ; * ( _DWORD * ) ( @@int64@@ + Number ) = @@int@@ ; return @@int64@@ ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall check_dst_limits_calc_pos_1 ( __int64 @@int64@@ , int @@int@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { int @@int@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; @@QWORD@@ = * ( _QWORD * * ) ( @@int64@@ + Number ) ; @@int64@@ = @@QWORD@@ [ Number ] + Number * @@int64@@ ; for ( @@unsignedint64@@ = Number L ; ; ++ @@unsignedint64@@ ) { if ( @@unsignedint64@@ >= * ( _QWORD * ) ( @@int64@@ + Number ) ) return ( @@int@@ >> Number ) & Number ; @@int64@@ = * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; @@int@@ = * ( unsigned __int8 * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) ; if ( @@int@@ == Number ) { if ( ( @@int@@ & Number ) != Number && @@unsignedint64@@ == * ( _QWORD * ) ( Number * @@int64@@ + * @@QWORD@@ ) ) { return Number ; } continue ; } if ( @@int@@ != Number ) break ; if ( ( @@int@@ & Number ) != Number && @@unsignedint64@@ == * ( _QWORD * ) ( Number * @@int64@@ + * @@QWORD@@ ) ) { return Number L ; } LABEL_29 : ; } if ( @@int@@ != Number || @@int64@@ == Number ) goto LABEL_29 ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ ; while ( Number ) { if ( @@int64@@ != * ( _QWORD * ) @@int64@@ || @@unsignedint64@@ <= Number && ( ( * ( unsigned __int16 * ) ( @@int64@@ + Number ) >> @@unsignedint64@@ ) & Number L ) == Number ) { goto LABEL_21 ; } @@int64@@ = * * ( _QWORD * * ) ( @@QWORD@@ [ Number ] + Number * @@int64@@ + Number ) ; if ( @@int64@@ == @@int64@@ ) break ; @@int@@ = check_dst_limits_calc_pos_1 ( @@int64@@ , @@int@@ , @@unsignedint64@@ , @@int64@@ , @@int64@@ ) ; if ( @@int@@ == Number ) return Number ; if ( ! @@int@@ && ( @@int@@ & Number ) != Number ) return Number L ; if ( @@unsignedint64@@ <= Number ) * ( _WORD * ) ( @@int64@@ + Number ) &= ~ ( unsigned __int16 ) ( Number L << @@unsignedint64@@ ) ; LABEL_21 : @@int64@@ = @@int64@@ ; @@int64@@ += Number L ; if ( ! * ( _BYTE * ) ( @@int64@@ + Number ) ) goto LABEL_29 ; } if ( ( @@int@@ & Number ) != Number ) @@int64@@ = Number ; else @@int64@@ = Number L ; return @@int64@@ ; }
size_t __fastcall fillpattern ( __int16 @@int16@@ , _BYTE * @@BYTE@@ , size_t @@sizet@@ ) { size_t @@sizet@@ ; unsigned int @@unsignedint@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; @@unsignedint@@ = ( ( @@int16@@ & Number ) << Number ) | @@int16@@ & Number ; * @@BYTE@@ = @@unsignedint@@ >> Number ; @@BYTE@@ [ Number ] = BYTE1 ( @@unsignedint@@ ) ; @@BYTE@@ [ Number ] = @@int16@@ ; for ( @@sizet@@ = Number L ; @@sizet@@ < @@sizet@@ >> Number ; @@sizet@@ *= Number L ) { memcpy ( & @@BYTE@@ [ @@sizet@@ ] , @@BYTE@@ , @@sizet@@ ) ; } if ( @@sizet@@ < @@sizet@@ ) memcpy ( & @@BYTE@@ [ @@sizet@@ ] , @@BYTE@@ , @@sizet@@ - @@sizet@@ ) ; @@sizet@@ = @@int16@@ & Number ; if ( ( @@int16@@ & Number ) != Number ) { for ( @@sizet@@ = Number L ; ; @@sizet@@ += Number L ) { @@sizet@@ = @@sizet@@ ; if ( @@sizet@@ >= @@sizet@@ ) break ; @@BYTE@@ [ @@sizet@@ ] ^= Number ; } } return @@sizet@@ ; }
__int64 __fastcall hash_get_n_buckets ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 __fastcall match_ctx_init ( __int64 @@int64@@ , int @@int@@ , unsigned __int64 @@unsignedint64@@ ) { * ( _DWORD * ) ( @@int64@@ + Number ) = @@int@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number ; if ( ! @@unsignedint64@@ ) goto LABEL_7 ; if ( ! is_mul_ok ( Number , @@unsignedint64@@ ) ) return Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = malloc ( Number * @@unsignedint64@@ ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = malloc ( Number * @@unsignedint64@@ ) ; if ( ! * ( _QWORD * ) ( @@int64@@ + Number ) || ! * ( _QWORD * ) ( @@int64@@ + Number ) ) return Number L ; LABEL_7 : * ( _QWORD * ) ( @@int64@@ + Number ) = @@unsignedint64@@ ; * ( _DWORD * ) ( @@int64@@ + Number ) = Number ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@unsignedint64@@ ; return Number L ; }
__int64 __fastcall xstr_cd_iconv ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = str_cd_iconv ( @@int64@@ , @@int64@@ ) ; if ( ! @@int64@@ && * __errno_location ( ) == Number ) xalloc_die ( ) ; return @@int64@@ ; }
__int64 __fastcall hash_get_n_entries ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
void __fastcall match_ctx_free ( __int64 @@int64@@ ) { match_ctx_clean ( ( _QWORD * ) @@int64@@ ) ; free ( * ( void * * ) ( @@int64@@ + Number ) ) ; free ( * ( void * * ) ( @@int64@@ + Number ) ) ; }
__int64 __fastcall wipefile ( const char * @@constchar@@ , const char * @@constchar@@ , __int64 @@int64@@ , _BYTE * @@BYTE@@ , int @@int@@ , int @@int@@ ) { int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; char * @@char@@ ; int * @@int@@ ; __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; unsigned __int8 @@unsignedint8@@ ; int @@int@@ ; @@int@@ = open_safer ( ( _DWORD ) @@constchar@@ , Number , @@int64@@ , ( _DWORD ) @@BYTE@@ , @@int@@ , @@int@@ ) ; if ( @@int@@ < Number && * __errno_location ( ) == Number && * @@BYTE@@ && ! chmod ( @@constchar@@ , Number ) ) { @@int@@ = open_safer ( ( _DWORD ) @@constchar@@ , Number , @@int@@ , @@int@@ , @@int@@ , @@int@@ ) ; } if ( @@int@@ >= Number ) { @@unsignedint8@@ = do_wipefd ( @@int@@ , ( __int64 ) @@constchar@@ , @@int64@@ , ( __int64 ) @@BYTE@@ ) ; if ( close ( @@int@@ ) ) { @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ , @@constchar@@ ) ; @@unsignedint8@@ = Number ; } if ( @@unsignedint8@@ ) { if ( @@BYTE@@ [ Number ] ) @@unsignedint8@@ = wipename ( @@constchar@@ , @@constchar@@ , ( __int64 ) @@BYTE@@ ) ; } @@int64@@ = @@unsignedint8@@ ; } else { @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ , @@constchar@@ ) ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall check_arrival_add_next_nodes ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; char @@char@@ [ Number ] ; __int64 @@int64@@ ; void * @@void@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@QWORD@@ = * ( _QWORD * * ) ( @@int64@@ + Number ) ; @@unsignedint@@ = Number ; memset ( @@char@@ , Number , Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { @@int@@ = Number ; @@int64@@ = * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( ( * ( _BYTE * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) & Number ) != Number ) { @@int@@ = check_node_accept_bytes ( @@QWORD@@ , @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( @@int@@ > Number ) { @@unsignedint64@@ = * ( _QWORD * ) ( Number * @@int64@@ + @@QWORD@@ [ Number ] ) ; @@int64@@ = @@int@@ + @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( Number * @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; @@int64@@ = Number L ; if ( @@int64@@ ) { @@unsignedint@@ = re_node_set_merge ( ( __int64 ) @@char@@ , @@int64@@ + Number ) ; if ( @@unsignedint@@ ) goto LABEL_6 ; } if ( ! re_node_set_insert ( ( __int64 ) @@char@@ , @@unsignedint64@@ ) ) goto LABEL_8 ; @@QWORD@@ = ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ ) ; * @@QWORD@@ = re_acquire_state ( & @@unsignedint@@ , ( __int64 ) @@QWORD@@ , ( __int64 ) @@char@@ ) ; if ( ! * ( _QWORD * ) ( Number * @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ) { if ( @@unsignedint@@ ) { LABEL_6 : free ( @@void@@ ) ; return @@unsignedint@@ ; } } } } if ( ( @@int@@ || ( unsigned __int8 ) check_node_accept ( @@int64@@ , * @@QWORD@@ + Number * @@int64@@ , @@int64@@ ) ) && ! re_node_set_insert ( @@int64@@ , * ( _QWORD * ) ( Number * @@int64@@ + @@QWORD@@ [ Number ] ) ) ) { LABEL_8 : free ( @@void@@ ) ; return Number L ; } } free ( @@void@@ ) ; return Number L ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ ) { return xmalloc ( @@int64@@ ) ; }
__int64 __fastcall xstr_iconv ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = str_iconv ( @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( ! @@int64@@ && * __errno_location ( ) == Number ) xalloc_die ( ) ; return @@int64@@ ; }
_BOOL8 __fastcall hash_table_ok ( __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; @@int64@@ = Number L ; @@int64@@ = Number L ; for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { @@QWORD@@ = @@QWORD@@ ; ++ @@int64@@ ; ++ @@int64@@ ; while ( Number ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; if ( ! @@QWORD@@ ) break ; ++ @@int64@@ ; } } } return @@int64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) && @@int64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ; }
size_t * __fastcall readisaac ( size_t * @@sizet@@ , char * @@char@@ , size_t @@sizet@@ ) { size_t * @@sizet@@ ; size_t @@sizet@@ ; char * @@char@@ ; for ( @@sizet@@ = * @@sizet@@ ; @@sizet@@ > @@sizet@@ ; @@sizet@@ = Number L ) { memcpy ( @@char@@ , ( char * ) @@sizet@@ + Number - @@sizet@@ + Number , @@sizet@@ ) ; @@char@@ += @@sizet@@ ; @@sizet@@ -= @@sizet@@ ; if ( ( ( unsigned __int8 ) @@char@@ & Number ) == Number ) { @@char@@ = @@char@@ ; while ( @@sizet@@ > Number ) { isaac_refill ( @@sizet@@ + Number , @@char@@ ) ; @@char@@ += Number ; @@sizet@@ -= Number L ; if ( ! @@sizet@@ ) { @@sizet@@ = @@sizet@@ ; * @@sizet@@ = Number L ; return @@sizet@@ ; } } @@char@@ = @@char@@ ; } isaac_refill ( @@sizet@@ + Number , ( char * ) @@sizet@@ + Number ) ; } memcpy ( @@char@@ , ( char * ) @@sizet@@ + Number - @@sizet@@ + Number , @@sizet@@ ) ; @@sizet@@ = @@sizet@@ ; * @@sizet@@ = @@sizet@@ - @@sizet@@ ; return @@sizet@@ ; }
__int64 __fastcall hash_do_for_each ( __int64 @@int64@@ , unsigned __int8 ( __fastcall * @ @ VAR_1161 @ @ unsignedint8 ( fastcall ) ( QWORD , int64 ) @ @ Hashprocessor ) ( _QWORD , __int64 ) , __int64 @@int64@@ ) { __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; @@int64@@ = Number L ; for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { for ( @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { if ( @ @ VAR_1161 @ @ unsignedint8 ( fastcall ) ( QWORD , int64 ) @ @ Hashprocessor ( * @@QWORD@@ , @@int64@@ ) != Number ) return @@int64@@ ; ++ @@int64@@ ; } } } return @@int64@@ ; }
__int64 __fastcall argmatch ( const char * @@constchar@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { __int64 @@int64@@ ; char @@char@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; size_t @@sizet@@ ; @@int64@@ = Number ; @@char@@ = Number ; @@sizet@@ = strlen ( @@constchar@@ ) ; for ( @@int64@@ = Number L ; * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; ++ @@int64@@ ) { if ( ! strncmp ( * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) , @@constchar@@ , @@sizet@@ ) ) { if ( @@sizet@@ == strlen ( * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) ) ) return @@int64@@ ; if ( @@int64@@ == Number ) { @@int64@@ = @@int64@@ ; } else if ( ! @@int64@@ || memcmp ( ( const void * ) ( @@sizet@@ * @@int64@@ + @@int64@@ ) , ( const void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) , @@sizet@@ ) ) { @@char@@ = Number ; } } } if ( @@char@@ ) @@int64@@ = Number ; else @@int64@@ = @@int64@@ ; return @@int64@@ ; }
__int64 __fastcall check_tuning ( __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( ( _UNKNOWN * ) @@int64@@ == & default_tuning ) return Number L ; if ( * ( float * ) ( @@int64@@ + Number ) > Number && ( float ) ( Number - Number ) > * ( float * ) ( @@int64@@ + Number ) && * ( float * ) ( @@int64@@ + Number ) > ( float ) ( Number + Number ) && * ( float * ) @@int64@@ >= Number && * ( float * ) ( @@int64@@ + Number ) > ( float ) ( * ( float * ) @@int64@@ + Number ) && * ( float * ) ( @@int64@@ + Number ) <= Number && * ( float * ) ( @@int64@@ + Number ) > ( float ) ( * ( float * ) @@int64@@ + Number ) ) { return Number L ; } * ( _QWORD * ) ( @@int64@@ + Number ) = & default_tuning ; return Number L ; }
__int64 __fastcall match_ctx_add_subtop ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; void * * @@void@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; void * @@void@@ ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) == * ( _QWORD * ) ( @@int64@@ + Number ) ) { @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = Number * @@int64@@ ; @@void@@ = realloc ( * ( void * * ) ( @@int64@@ + Number ) , Number * @@int64@@ ) ; if ( ! @@void@@ ) return Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@void@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; } @@void@@ = ( void * * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L * * ( _QWORD * ) ( @@int64@@ + Number ) ) ; * @@void@@ = calloc ( Number , Number ) ; if ( ! * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L * * ( _QWORD * ) ( @@int64@@ + Number ) ) ) return Number L ; * ( _QWORD * ) ( * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L * * ( _QWORD * ) ( @@int64@@ + Number ) ) + Number L ) = @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ + Number ; * * ( _QWORD * * ) ( @@int64@@ + Number * @@int64@@ ) = @@int64@@ ; return Number L ; }
__int64 __fastcall bkm_scale_by_power ( unsigned __int64 * @@unsignedint64@@ , int @@int@@ , int @@int@@ ) { unsigned int @@unsignedint@@ ; for ( @@unsignedint@@ = Number ; @@int@@ -- ; @@unsignedint@@ |= bkm_scale ( @@unsignedint64@@ , @@int@@ ) ) { ; } return @@unsignedint@@ ; }
__int64 __fastcall fraccompare ( _BYTE * @@BYTE@@ , _BYTE * @@BYTE@@ , char @@char@@ ) { _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; @@BYTE@@ = @@BYTE@@ ; @@BYTE@@ = @@BYTE@@ ; if ( @@char@@ == * @@BYTE@@ && @@char@@ == * @@BYTE@@ ) { while ( * ++ @@BYTE@@ == * ++ @@BYTE@@ ) { if ( ( unsigned int ) ( ( char ) * @@BYTE@@ - Number ) > Number ) return Number L ; } if ( ( unsigned int ) ( ( char ) * @@BYTE@@ - Number ) <= Number && ( unsigned int ) ( ( char ) * @@BYTE@@ - Number ) <= Number ) { return ( unsigned int ) ( ( char ) * @@BYTE@@ - ( char ) * @@BYTE@@ ) ; } if ( ( unsigned int ) ( ( char ) * @@BYTE@@ - Number ) > Number ) { if ( ( unsigned int ) ( ( char ) * @@BYTE@@ - Number ) > Number ) return Number L ; LABEL_23 : while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; return ( unsigned int ) - ( ( unsigned int ) ( ( char ) * @@BYTE@@ - Number ) <= Number ) ; } } else { @@BYTE@@ = @@BYTE@@ + Number ; if ( @@char@@ != * @@BYTE@@ ) { @@BYTE@@ = @@BYTE@@ + Number ; if ( @@char@@ != * @@BYTE@@ ) return Number L ; goto LABEL_23 ; } } while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; return ( unsigned int ) ( ( char ) * @@BYTE@@ - Number ) <= Number ; }
void __fastcall add_exclude ( __int64 @@int64@@ , const char * @@constchar@@ , int @@int@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; __int64 * @@int64@@ ; void * @@void@@ ; if ( ( @@int@@ & Number ) != Number && ( unsigned __int8 ) fnmatch_pattern_has_wildcards ( @@constchar@@ , @@int@@ ) ) { if ( * ( _QWORD * ) ( @@int64@@ + Number ) && * ( _DWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) == Number && ( ( @@int@@ ^ * ( _DWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) ) & Number ) == Number ) { @@QWORD@@ = * ( _QWORD * * ) ( @@int64@@ + Number ) ; } else { @@QWORD@@ = ( _QWORD * ) new_exclude_segment ( @@int64@@ , Number , @@int@@ ) ; } @@int64@@ = @@QWORD@@ + Number ; if ( @@QWORD@@ [ Number ] == @@QWORD@@ [ Number ] ) * @@int64@@ = x2nrealloc ( @@QWORD@@ [ Number ] , @@QWORD@@ + Number , Number L ) ; @@int64@@ = * @@int64@@ ; @@int64@@ = @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ + Number ; @@int64@@ *= Number L ; * ( _QWORD * ) ( @@int64@@ + @@int64@@ ) = @@constchar@@ ; * ( _DWORD * ) ( @@int64@@ + @@int64@@ + Number ) = @@int@@ ; } else { if ( ! * ( _QWORD * ) ( @@int64@@ + Number ) || * ( _DWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) || ( ( @@int@@ ^ * ( _DWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) ) & Number ) != Number ) { @@int64@@ = new_exclude_segment ( @@int64@@ , Number , @@int@@ ) ; } else { @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; } @@void@@ = ( void * ) xstrdup ( @@constchar@@ ) ; if ( ( void * ) hash_insert ( * ( _QWORD * ) ( @@int64@@ + Number ) , @@void@@ ) != @@void@@ ) free ( @@void@@ ) ; } }
__int64 __fastcall hash_find_entry ( __int64 @@int64@@ , __int64 @@int64@@ , _QWORD * @@QWORD@@ , char @@char@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; @@int64@@ = * ( _QWORD * ) @@int64@@ ; @@QWORD@@ = ( _QWORD * ) ( @@int64@@ + Number * ( * ( __int64 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@int64@@ + Number ) ) ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@QWORD@@ >= * ( _QWORD * ) ( @@int64@@ + Number ) ) abort ( ) ; * @@QWORD@@ = @@QWORD@@ ; if ( ! * @@QWORD@@ ) return Number L ; if ( @@int64@@ == * @@QWORD@@ || ( * ( unsigned __int8 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@int64@@ + Number ) ) ( @@int64@@ , * @@QWORD@@ ) ) { @@int64@@ = * @@QWORD@@ ; if ( @@char@@ ) { if ( @@QWORD@@ [ Number ] ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; @@int64@@ = @@QWORD@@ [ Number ] ; * @@QWORD@@ = * @@QWORD@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; free_entry ( @@int64@@ , @@QWORD@@ ) ; } else { * @@QWORD@@ = Number L ; } } @@int64@@ = @@int64@@ ; } else { for ( @@QWORD@@ = @@QWORD@@ ; ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { if ( ! @@QWORD@@ [ Number ] ) return Number L ; if ( @@int64@@ == * ( _QWORD * ) @@QWORD@@ [ Number ] || ( * ( unsigned __int8 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@int64@@ + Number ) ) ( @@int64@@ , * ( _QWORD * ) @@QWORD@@ [ Number ] ) ) { break ; } } @@int64@@ = * ( _QWORD * ) @@QWORD@@ [ Number ] ; if ( @@char@@ ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = @@QWORD@@ [ Number ] ; free_entry ( @@int64@@ , @@QWORD@@ ) ; } @@int64@@ = @@int64@@ ; } return @@int64@@ ; }
__int64 __fastcall randint_choose ( __int64 @@int64@@ , __int64 @@int64@@ ) { return randint_genmax ( @@int64@@ , @@int64@@ - Number ) ; }
_BYTE * __fastcall dir_len ( _BYTE * @@BYTE@@ ) { _BYTE * @@BYTE@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = * @@BYTE@@ == Number ; for ( @@BYTE@@ = ( _BYTE * ) ( last_component ( @@BYTE@@ ) - @@BYTE@@ ) ; @@unsignedint64@@ < ( unsigned __int64 ) @@BYTE@@ && @@BYTE@@ [ ( _QWORD ) ( @@BYTE@@ - Number ) ] == Number ; -- @@BYTE@@ ) { ; } return @@BYTE@@ ; }
void __fastcall genpattern ( char * @@char@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ ) { int * @@int@@ ; int * @@int@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; int * @@int@@ ; char * @@char@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@unsignedint64@@ ) { @@int@@ = ( int * ) & patterns ; @@int64@@ = Number L ; @@char@@ = @@char@@ ; for ( @@unsignedint64@@ = @@unsignedint64@@ ; ; @@unsignedint64@@ -= @@int@@ ) { while ( Number ) { while ( Number ) { @@int@@ = @@int@@ ++ ; @@int@@ = * @@int@@ ; if ( * @@int@@ ) break ; @@int@@ = ( int * ) & patterns ; } if ( @@int@@ >= Number ) break ; @@int@@ = - @@int@@ ; if ( @@unsignedint64@@ <= @@int@@ ) { @@int64@@ += @@unsignedint64@@ ; goto LABEL_18 ; } @@int64@@ += @@int@@ ; @@unsignedint64@@ -= @@int@@ ; } if ( @@unsignedint64@@ < @@int@@ ) break ; memcpy ( @@char@@ , @@int@@ , Number L * @@int@@ ) ; @@int@@ += @@int@@ ; @@char@@ += Number * @@int@@ ; } if ( @@unsignedint64@@ > Number && Number * @@unsignedint64@@ >= @@int@@ ) { do { if ( @@unsignedint64@@ == @@int@@ || @@unsignedint64@@ > randint_choose ( @@int64@@ , @@int@@ ) ) { @@int@@ = ( int * ) @@char@@ ; @@char@@ += Number ; * @@int@@ = * @@int@@ ; -- @@unsignedint64@@ ; } ++ @@int@@ ; } while ( @@unsignedint64@@ ) ; } else { @@int64@@ += @@unsignedint64@@ ; } LABEL_18 : @@int64@@ = @@unsignedint64@@ - @@int64@@ ; @@unsignedint64@@ = @@int64@@ - Number ; @@unsignedint64@@ = @@unsignedint64@@ ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@unsignedint64@@ ; ++ @@unsignedint64@@ ) { if ( @@unsignedint64@@ > @@unsignedint64@@ ) { @@int64@@ = randint_choose ( @@int64@@ , @@int64@@ - @@unsignedint64@@ ) ; @@int@@ = * ( _DWORD * ) & @@char@@ [ Number * @@unsignedint64@@ ] ; * ( _DWORD * ) & @@char@@ [ Number * @@unsignedint64@@ ] = * ( _DWORD * ) & @@char@@ [ Number * @@int64@@ + Number * @@unsignedint64@@ ] ; * ( _DWORD * ) & @@char@@ [ Number * @@int64@@ + Number * @@unsignedint64@@ ] = @@int@@ ; } else { @@unsignedint64@@ = @@unsignedint64@@ + @@unsignedint64@@ - Number ; @@int64@@ = @@int64@@ ++ ; * ( _DWORD * ) & @@char@@ [ Number * @@int64@@ ] = * ( _DWORD * ) & @@char@@ [ Number * @@unsignedint64@@ ] ; * ( _DWORD * ) & @@char@@ [ Number * @@unsignedint64@@ ] = Number ; } @@unsignedint64@@ -= @@unsignedint64@@ ; } } }
__int64 __fastcall enter_dir ( __int64 @@int64@@ , __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; if ( ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number ) { @@QWORD@@ = malloc ( Number ) ; if ( ! @@QWORD@@ ) return Number L ; * @@QWORD@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ [ Number ] = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = hash_insert ( * ( _QWORD * ) ( @@int64@@ + Number ) , @@QWORD@@ ) ; if ( ( _QWORD * ) @@int64@@ != @@QWORD@@ ) { free ( @@QWORD@@ ) ; if ( ! @@int64@@ ) return Number L ; * ( _QWORD * ) @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _WORD * ) ( @@int64@@ + Number ) = Number ; } } else if ( ( unsigned __int8 ) cycle_check ( * ( _QWORD * ) ( @@int64@@ + Number ) , @@int64@@ + Number ) ) { * ( _QWORD * ) @@int64@@ = @@int64@@ ; * ( _WORD * ) ( @@int64@@ + Number ) = Number ; } return Number L ; }
int __fastcall passname ( unsigned __int8 * @@unsignedint8@@ , char * @@char@@ ) { int @@int@@ ; if ( @@unsignedint8@@ ) @@int@@ = sprintf ( @@char@@ , String , * @@unsignedint8@@ , @@unsignedint8@@ [ Number ] , @@unsignedint8@@ [ Number ] ) ; else @@int@@ = ( unsigned int ) memcpy ( @@char@@ , String , Number ) ; return @@int@@ ; }
__int64 __fastcall humblock ( char * @@char@@ , _QWORD * @@QWORD@@ , int * @@int@@ ) { char * @@char@@ ; int @@int@@ ; int @@int@@ ; unsigned int @@unsignedint@@ ; __int64 @@int642@@ [ Number ] ; @@char@@ = @@char@@ ; @@int642@@ [ Number ] = __readfsqword ( Number ) ; @@int@@ = Number ; if ( @@char@@ || ( @@char@@ = getenv ( String ) ) != Number L || ( @@char@@ = getenv ( String ) ) != Number L ) { if ( * @@char@@ == Number ) { @@int@@ = Number ; ++ @@char@@ ; } @@int@@ = argmatch ( @@char@@ , ( __int64 ) & block_size_args , ( __int64 ) block_size_opts , Number ) ; if ( @@int@@ < Number ) { @@unsignedint@@ = xstrtoumax ( @@char@@ , @@int642@@ , Number L , @@QWORD@@ , String ) ; if ( @@unsignedint@@ ) { * @@int@@ = Number ; return @@unsignedint@@ ; } while ( * @@char@@ <= Number || * @@char@@ > Number ) { if ( @@char@@ == ( char * ) @@int642@@ [ Number ] ) { @@int@@ |= Number ; if ( * ( _BYTE * ) ( @@int642@@ [ Number ] - Number ) == Number ) @@int@@ |= Number ; if ( * ( _BYTE * ) ( @@int642@@ [ Number ] - Number ) != Number || * ( _BYTE * ) ( @@int642@@ [ Number ] - Number ) == Number ) @@int@@ |= Number ; break ; } ++ @@char@@ ; } } else { @@int@@ |= block_size_opts [ @@int@@ ] ; * @@QWORD@@ = Number L ; } } else { * @@QWORD@@ = default_block_size ( ) ; } * @@int@@ = @@int@@ ; return Number L ; }
__int64 default_block_size ( ) { __int64 @@int64@@ ; if ( getenv ( String ) ) @@int64@@ = Number L ; else @@int64@@ = Number L ; return @@int64@@ ; }
__int64 __fastcall direct_mode ( int @@int@@ , char @@char@@ , int @@int@@ , int @@int@@ , int @@int@@ , int @@int@@ ) { __int64 @@int64@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; @@int64@@ = rpl_fcntl ( @@int@@ , Number , @@int@@ , @@int@@ , @@int@@ , @@int@@ ) ; @@int@@ = @@int64@@ ; if ( ( int ) @@int64@@ > Number ) { if ( @@char@@ ) BYTE1 ( @@int64@@ ) |= Number ; else BYTE1 ( @@int64@@ ) &= Number ; @@int64@@ = ( unsigned int ) @@int64@@ ; if ( ( _DWORD ) @@int64@@ != @@int@@ ) @@int64@@ = rpl_fcntl ( @@int@@ , Number , @@int64@@ , @@int@@ , @@int@@ , @@int@@ ) ; } return @@int64@@ ; }
__int64 __fastcall diropen ( __int64 @@int64@@ , int @@int@@ , __int64 a3 , int @@int@@ , int @@int@@ , int @@int@@ ) { int @@int@@ ; int @@int@@ ; unsigned int @@unsignedint@@ ; @@int@@ = ( * ( _DWORD * ) ( @@int64@@ + Number ) << Number ) & Number | Number ; if ( ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number ) @@int@@ = openat_safer ( * ( _DWORD * ) ( @@int64@@ + Number ) , @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int@@ ) ; else @@int@@ = open_safer ( @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int@@ ) ; @@unsignedint@@ = @@int@@ ; if ( @@int@@ >= Number ) set_cloexec_flag ( ( unsigned int ) @@int@@ , Number L ) ; return @@unsignedint@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
_QWORD * __fastcall randint_new ( __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) xmalloc ( Number L ) ; * @@QWORD@@ = @@int64@@ ; @@QWORD@@ [ Number ] = Number L ; @@QWORD@@ [ Number ] = @@QWORD@@ [ Number ] ; return @@QWORD@@ ; }
__int64 __fastcall fts_palloc ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; void * @@void@@ ; @@unsignedint64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) + @@int64@@ + Number ; if ( @@unsignedint64@@ >= * ( _QWORD * ) ( @@int64@@ + Number ) ) { * ( _QWORD * ) ( @@int64@@ + Number ) = @@unsignedint64@@ ; @@void@@ = realloc ( * ( void * * ) ( @@int64@@ + Number ) , * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( @@void@@ ) { * ( _QWORD * ) ( @@int64@@ + Number ) = @@void@@ ; @@int64@@ = Number L ; } else { free ( * ( void * * ) ( @@int64@@ + Number ) ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number L ; @@int64@@ = Number L ; } } else { free ( * ( void * * ) ( @@int64@@ + Number ) ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number L ; * __errno_location ( ) = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall xtime_make ( __int64 @@int64@@ , __int64 @@int64@@ ) { return Number * @@int64@@ + @@int64@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
int __fastcall hash_print_statistics ( __int64 @@int64@@ , FILE * @@FILE@@ ) { double @@double@@ ; double @@double@@ ; double @@double@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int64@@ = hash_get_n_entries ( @@int64@@ ) ; @@int64@@ = hash_get_n_buckets ( @@int64@@ ) ; @@int64@@ = hash_get_n_buckets_used ( @@int64@@ ) ; @@unsignedint64@@ = hash_get_max_bucket_length ( @@int64@@ ) ; fprintf ( @@FILE@@ , String , @@int64@@ ) ; fprintf ( @@FILE@@ , String , @@int64@@ ) ; if ( @@int64@@ < Number ) @@double@@ = ( double ) ( int ) ( @@int64@@ & Number | ( ( unsigned __int64 ) @@int64@@ >> Number ) ) + ( double ) ( int ) ( @@int64@@ & Number | ( ( unsigned __int64 ) @@int64@@ >> Number ) ) ; else @@double@@ = ( double ) ( int ) @@int64@@ ; @@double@@ = Number * @@double@@ ; if ( @@int64@@ < Number ) @@double@@ = ( double ) ( int ) ( @@int64@@ & Number | ( ( unsigned __int64 ) @@int64@@ >> Number ) ) + ( double ) ( int ) ( @@int64@@ & Number | ( ( unsigned __int64 ) @@int64@@ >> Number ) ) ; else @@double@@ = ( double ) ( int ) @@int64@@ ; fprintf ( @@FILE@@ , String , @@int64@@ , @@double@@ / @@double@@ ) ; return fprintf ( @@FILE@@ , String , @@unsignedint64@@ ) ; }
__int64 gethrxtime ( ) { struct timespec @@structtimespec@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( clock_gettime ( Number , & @@structtimespec@@ ) ) gettime ( & @@structtimespec@@ ) ; return xtime_make ( @@structtimespec@@ . tv_sec , @@structtimespec@@ . tv_nsec ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
__int64 __fastcall randint_all_free ( _QWORD * @@QWORD@@ ) { unsigned int @@unsignedint@@ ; int @@int@@ ; @@unsignedint@@ = randread_free ( * @@QWORD@@ ) ; @@int@@ = * __errno_location ( ) ; randint_free ( @@QWORD@@ ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 __fastcall open_safer ( const char * @@constchar@@ , char @@char@@ , unsigned int @@unsignedint@@ ) { unsigned int @@unsignedint@@ ; unsigned int @@unsignedint@@ ; @@unsignedint@@ = Number ; if ( ( @@char@@ & Number ) != Number ) @@unsignedint@@ = @@unsignedint@@ ; @@unsignedint@@ = open ( @@constchar@@ , @@char@@ , @@unsignedint@@ ) ; return fd_safer ( @@unsignedint@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
void __fastcall hash_free ( __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) && * ( _QWORD * ) ( @@int64@@ + Number ) ) { for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { for ( @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@int64@@ + Number ) ) ( * @@QWORD@@ ) ; } } } } for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { for ( @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; @@QWORD@@ ; @@QWORD@@ = @@QWORD@@ ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; free ( @@QWORD@@ ) ; } } for ( @@QWORD@@ = * ( _QWORD * * ) ( @@int64@@ + Number ) ; @@QWORD@@ ; @@QWORD@@ = @@QWORD@@ ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; free ( @@QWORD@@ ) ; } free ( * ( void * * ) @@int64@@ ) ; free ( ( void * ) @@int64@@ ) ; }
char * __fastcall randread_new ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { size_t @@sizet@@ ; FILE * @@FILE@@ ; char * @@char@@ ; if ( ! @@unsignedint64@@ ) return ( char * ) simple_new ( Number L , Number L ) ; @@FILE@@ = Number L ; if ( @@int64@@ ) { @@FILE@@ = ( FILE * ) fopen_safer ( @@int64@@ , & off_AA73 ) ; if ( ! @@FILE@@ ) return Number L ; } @@char@@ = ( char * ) simple_new ( ( __int64 ) @@FILE@@ , @@int64@@ ) ; if ( @@FILE@@ ) { @@sizet@@ = Number L ; if ( @@unsignedint64@@ <= Number ) @@sizet@@ = @@unsignedint64@@ ; setvbuf ( @@FILE@@ , @@char@@ + Number , Number , @@sizet@@ ) ; } else { * ( ( _QWORD * ) @@char@@ + Number ) = Number L ; isaac_seed ( @@char@@ + Number ) ; } return @@char@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall umaxtostr ( unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = @@int64@@ + Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = Number ; do { * ( _BYTE * ) -- @@int64@@ = @@unsignedint64@@ % Number + Number ; @@unsignedint64@@ /= Number ; } while ( @@unsignedint64@@ ) ; return @@int64@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
char * __fastcall group_number ( char * @@char@@ , size_t @@sizet@@ , unsigned __int8 * @@unsignedint8@@ , const char * @@constchar@@ ) { char * @@char@@ ; size_t @@sizet@@ ; char * @@char@@ ; unsigned __int8 @@unsignedint8@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@sizet@@ = Number ; @@sizet@@ = strlen ( @@constchar@@ ) ; @@sizet@@ = @@sizet@@ ; memcpy ( @@char@@ , @@char@@ , @@sizet@@ ) ; for ( @@char@@ = & @@char@@ [ @@sizet@@ ] ; ; memcpy ( @@char@@ , @@constchar@@ , @@sizet@@ ) ) { @@unsignedint8@@ = * @@unsignedint8@@ ; if ( * @@unsignedint8@@ ) { if ( @@unsignedint8@@ > Number ) @@sizet@@ = @@sizet@@ ; else @@sizet@@ = @@unsignedint8@@ ; @@sizet@@ = @@sizet@@ ; ++ @@unsignedint8@@ ; } if ( @@sizet@@ < @@sizet@@ ) @@sizet@@ = @@sizet@@ ; @@char@@ = & @@char@@ [ - @@sizet@@ ] ; @@sizet@@ -= @@sizet@@ ; memcpy ( @@char@@ , & @@char@@ [ @@sizet@@ ] , @@sizet@@ ) ; if ( ! @@sizet@@ ) break ; @@char@@ = & @@char@@ [ - @@sizet@@ ] ; } return @@char@@ ; }
size_t __fastcall randread ( _QWORD * @@QWORD@@ , char * @@char@@ , size_t @@sizet@@ ) { size_t @@sizet@@ ; if ( * @@QWORD@@ ) @@sizet@@ = readsource ( ( __int64 ) @@QWORD@@ , @@char@@ , @@sizet@@ ) ; else @@sizet@@ = ( size_t ) readisaac ( @@QWORD@@ + Number , @@char@@ , @@sizet@@ ) ; return @@sizet@@ ; }
__int64 __fastcall _xargmatch_internal ( __int64 @@int64@@ , const char * @@constchar@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ , void ( * @ @ VAR_1005 @ @ void ( ) ( void ) @ @ argmatchexitfn ) ( void ) ) { __int64 @@int64@@ ; @@int64@@ = argmatch ( @@constchar@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; if ( @@int64@@ >= Number ) return @@int64@@ ; argmatch_invalid ( @@int64@@ , ( __int64 ) @@constchar@@ , @@int64@@ ) ; argmatch_valid ( @@int64@@ , @@int64@@ , @@sizet@@ ) ; @ @ VAR_1005 @ @ void ( ) ( void ) @ @ argmatchexitfn ( ) ; return Number ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_21B168 ; @@int648@@ [ Number ] = qword_21B170 ; @@int648@@ [ Number ] = qword_21B178 ; @@int648@@ [ Number ] = qword_21B180 ; @@int648@@ [ Number ] = qword_21B188 ; @@int648@@ [ Number ] = qword_21B190 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
void * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
void * __fastcall quote_n ( int @@int@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@int@@ , Number , @@int64@@ ) ; }
__int64 __fastcall i_ring_pop ( __int64 @@int64@@ ) { unsigned int @@unsignedint@@ ; if ( ( unsigned __int8 ) i_ring_empty ( @@int64@@ ) ) abort ( ) ; @@unsignedint@@ = * ( _DWORD * ) ( @@int64@@ + Number L * * ( unsigned int * ) ( @@int64@@ + Number ) ) ; * ( _DWORD * ) ( @@int64@@ + Number L * * ( unsigned int * ) ( @@int64@@ + Number ) ) = * ( _DWORD * ) ( @@int64@@ + Number ) ; if ( * ( _DWORD * ) ( @@int64@@ + Number ) == * ( _DWORD * ) ( @@int64@@ + Number ) ) * ( _BYTE * ) ( @@int64@@ + Number ) = Number ; else * ( _DWORD * ) ( @@int64@@ + Number ) = ( ( unsigned __int8 ) * ( _DWORD * ) ( @@int64@@ + Number ) + Number ) & Number ; return @@unsignedint@@ ; }
unsigned __int64 __fastcall isaac_seed ( _DWORD * @@DWORD@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; isaac_seed_start ( @@DWORD@@ ) ; LODWORD ( @@int64@@ ) = getpid ( ) ; isaac_seed_data ( @@DWORD@@ , ( __int64 ) & @@int64@@ , Number ) ; LODWORD ( @@int64@@ ) = getppid ( ) ; isaac_seed_data ( @@DWORD@@ , ( __int64 ) & @@int64@@ , Number ) ; LODWORD ( @@int64@@ ) = getuid ( ) ; isaac_seed_data ( @@DWORD@@ , ( __int64 ) & @@int64@@ , Number ) ; LODWORD ( @@int64@@ ) = getgid ( ) ; isaac_seed_data ( @@DWORD@@ , ( __int64 ) & @@int64@@ , Number ) ; @@int64@@ = gethrxtime ( ) ; isaac_seed_data ( @@DWORD@@ , ( __int64 ) & @@int64@@ , Number ) ; isaac_seed_finish ( @@DWORD@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
void * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
void * __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
__int64 __fastcall xfts_open ( const char * * @@constchar@@ , int @@int@@ , __int64 @@int64@@ ) { int @@int@@ ; __int64 @@int64@@ ; @@int@@ = @@int@@ ; BYTE1 ( @@int@@ ) = BYTE1 ( @@int@@ ) | Number ; @@int64@@ = fts_open ( @@constchar@@ , @@int@@ , @@int64@@ ) ; if ( ! @@int64@@ ) { if ( * __errno_location ( ) == Number ) __assert_fail ( String , String , Number , String ) ; xalloc_die ( ) ; } return @@int64@@ ; }
__int64 __fastcall open_safer ( const char * @@constchar@@ , char @@char@@ , unsigned int @@unsignedint@@ ) { unsigned int @@unsignedint@@ ; unsigned int @@unsignedint@@ ; @@unsignedint@@ = Number ; if ( ( @@char@@ & Number ) != Number ) @@unsignedint@@ = @@unsignedint@@ ; @@unsignedint@@ = open ( @@constchar@@ , @@char@@ , @@unsignedint@@ ) ; return fd_safer ( @@unsignedint@@ ) ; }
__int64 __fastcall dir_name ( __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = mdir_name ( @@int64@@ ) ; if ( ! @@int64@@ ) xalloc_die ( ) ; return @@int64@@ ; }
void * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
bool __fastcall is_basic_2 ( unsigned __int8 @@unsignedint8@@ ) { return ( ( is_basic_table [ @@unsignedint8@@ >> Number ] >> ( @@unsignedint8@@ & Number ) ) & Number ) != Number ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
void * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
bool __fastcall is_basic_3 ( unsigned __int8 @@unsignedint8@@ ) { return ( ( is_basic_table [ @@unsignedint8@@ >> Number ] >> ( @@unsignedint8@@ & Number ) ) & Number ) != Number ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
int __cdecl __noreturn main ( int @@int@@ , const char * * @@constchar@@ , const char * * @@constchar@@ ) { char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; char * @@char@@ ; __mode_t @@modet@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; __mode_t @@modet@@ ; int @@int@@ ; int @@int@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; void * @@void@@ ; @@int64@@ = Number L ; @@int@@ = Number ; @@int64@@ = Number L ; set_program_name ( * @@constchar@@ , @@constchar@@ , @@constchar@@ ) ; setlocale ( Number , & locale ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; while ( Number ) { @@int@@ = getopt_long ( @@int@@ , ( char * const * ) @@constchar@@ , String , & longopts , Number L ) ; if ( @@int@@ == Number ) { if ( @@int@@ == optind ) { @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ ) ; usage ( Number ) ; } if ( @@int64@@ && ( int ) setfscreatecon ( @@int64@@ ) < Number ) { @@int64@@ = quote ( @@int64@@ ) ; @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ , @@int64@@ ) ; } @@modet@@ = Number ; if ( @@int64@@ ) { @@void@@ = ( void * ) mode_compile ( @@int64@@ ) ; if ( ! @@void@@ ) { @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ ) ; } @@modet@@ = umask ( Number ) ; @@modet@@ = mode_adjust ( Number L , Number L , @@modet@@ , @@void@@ , Number L ) ; free ( @@void@@ ) ; if ( ( @@modet@@ & Number ) != Number ) { @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ ) ; } } while ( @@int@@ > optind ) { if ( mkfifo ( @@constchar@@ [ optind ] , @@modet@@ ) ) { @@int64@@ = quote ( @@constchar@@ [ optind ] ) ; @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ , @@int64@@ ) ; @@int@@ = Number ; } ++ optind ; } exit ( @@int@@ ) ; } if ( @@int@@ == Number ) usage ( Number ) ; if ( @@int@@ <= Number ) break ; if ( @@int@@ == Number ) { @@int64@@ = optarg ; } else { if ( @@int@@ != Number ) goto LABEL_12 ; @@int64@@ = optarg ; } } if ( @@int@@ == Number ) { version_etc ( ( _DWORD ) stdout , ( unsigned int ) String , ( unsigned int ) String , ( _DWORD ) Version , ( unsigned int ) String , Number , ( char ) @@constchar@@ ) ; exit ( Number ) ; } LABEL_12 : usage ( Number ) ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ ) { return xmalloc ( @@int64@@ ) ; }
__int64 __fastcall rpl_fcntl ( int @@int@@ , int @@int@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ ) { int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; if ( @@int@@ != Number ) return ( unsigned int ) fcntl ( @@int@@ , @@int@@ , @@int64@@ ) ; @@int@@ = @@int64@@ ; if ( have_dupfd_cloexec_2895 < Number ) { @@int@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@int@@ , Number , @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ ) ; } else { @@int@@ = fcntl ( @@int@@ , Number , ( unsigned int ) @@int64@@ ) ; if ( @@int@@ < Number && * __errno_location ( ) == Number ) { @@int@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@int@@ , Number , @@int@@ , @@int@@ , @@int@@ , @@int@@ ) ; if ( @@int@@ < Number ) return ( unsigned int ) @@int@@ ; have_dupfd_cloexec_2895 = Number ; } else { have_dupfd_cloexec_2895 = Number ; } } if ( @@int@@ >= Number && have_dupfd_cloexec_2895 == Number ) { @@int@@ = fcntl ( @@int@@ , Number ) ; if ( @@int@@ < Number || fcntl ( @@int@@ , Number , @@int@@ | Number ) == Number ) { @@int@@ = * __errno_location ( ) ; close ( @@int@@ ) ; * __errno_location ( ) = @@int@@ ; @@int@@ = Number ; } } return ( unsigned int ) @@int@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_21B038 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall mem_cd_iconv ( char * @@char@@ , size_t @@sizet@@ , void * @@void@@ , void * * @@void@@ , size_t * @@sizet@@ ) { int @@int@@ ; char * @@char@@ ; size_t @@sizet@@ ; char * @@char@@ ; size_t @@sizet@@ ; void * @@void@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; char @@char@@ $D1F1B2789FC85C59BE59CF61C76BFA1E [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; iconv ( @@void@@ , Number L , Number L , Number L , Number L ) ; @@sizet@@ = Number L ; @@char@@ = @@char@@ ; @@sizet@@ = @@sizet@@ ; while ( @@sizet@@ ) { @@char@@ = @@char@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; @@sizet@@ = Number L ; @@sizet@@ = iconv ( @@void@@ , & @@char@@ , & @@sizet@@ , & @@char@@ , & @@sizet@@ ) ; if ( @@sizet@@ == Number && * __errno_location ( ) != Number ) { if ( * __errno_location ( ) != Number ) return Number ; break ; } @@sizet@@ += @@char@@ - @@char@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; } @@char@@ = @@char@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; @@sizet@@ = Number L ; @@sizet@@ = iconv ( @@void@@ , Number L , Number L , & @@char@@ , & @@sizet@@ ) ; if ( @@sizet@@ == Number ) return Number ; @@sizet@@ += @@char@@ - @@char@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; @@sizet@@ = @@sizet@@ ; if ( ! @@sizet@@ ) { * @@sizet@@ = Number L ; return Number L ; } if ( * @@void@@ && @@sizet@@ <= * @@sizet@@ ) { @@void@@ = * @@void@@ ; } else { @@void@@ = malloc ( @@sizet@@ ) ; if ( ! @@void@@ ) { * __errno_location ( ) = Number ; return Number ; } } iconv ( @@void@@ , Number L , Number L , Number L , Number L ) ; @@char@@ = @@char@@ ; @@sizet@@ = @@sizet@@ ; @@char@@ = ( char * ) @@void@@ ; @@sizet@@ = @@sizet@@ ; while ( @@sizet@@ ) { @@sizet@@ = iconv ( @@void@@ , & @@char@@ , & @@sizet@@ , & @@char@@ , & @@sizet@@ ) ; if ( @@sizet@@ == Number ) { if ( * __errno_location ( ) != Number ) goto LABEL_26 ; break ; } } @@sizet@@ = iconv ( @@void@@ , Number L , Number L , & @@char@@ , & @@sizet@@ ) ; if ( @@sizet@@ != Number ) { if ( @@sizet@@ ) abort ( ) ; * @@void@@ = @@void@@ ; * @@sizet@@ = @@sizet@@ ; return Number L ; } LABEL_26 : if ( @@void@@ != * @@void@@ ) { @@int@@ = * __errno_location ( ) ; free ( @@void@@ ) ; * __errno_location ( ) = @@int@@ ; } return Number ; }
__int64 __fastcall human_options ( char * @@char@@ , int * @@int@@ , uintmax_t * @@uintmaxt@@ ) { unsigned int @@unsignedint@@ ; @@unsignedint@@ = humblock ( @@char@@ , @@uintmaxt@@ , @@int@@ ) ; if ( ! * @@uintmaxt@@ ) { * @@uintmaxt@@ = default_block_size ( ) ; @@unsignedint@@ = Number ; } return @@unsignedint@@ ; }
void __fastcall argmatch_invalid ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { char * @@char@@ ; __int64 @@int64@@ ; void * @@void@@ ; char * @@char@@ ; if ( @@int64@@ == Number ) @@char@@ = gettext ( String ) ; else @@char@@ = gettext ( String ) ; @@char@@ = @@char@@ ; @@int64@@ = quote_n ( Number L , @@int64@@ ) ; @@void@@ = quotearg_n_style ( Number , Number , @@int64@@ ) ; error ( Number , Number , @@char@@ , @@void@@ , @@int64@@ ) ; }
int __fastcall argmatch_valid ( __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { char * @@char@@ ; __int64 @@int64@@ ; void * @@void@@ ; @@void@@ = Number L ; @@char@@ = gettext ( String ) ; fprintf ( stderr , @@char@@ ) ; for ( @@int64@@ = Number L ; * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; ++ @@int64@@ ) { if ( @@int64@@ && ! memcmp ( @@void@@ , ( const void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) , @@sizet@@ ) ) { fprintf ( stderr , String , * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) ) ; } else { fprintf ( stderr , String , * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) ) ; @@void@@ = ( void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) ; } } return putc_unlocked ( Number , stderr ) ; }
bool __fastcall is_zero_or_power_of_two ( __int64 @@int64@@ ) { return ( @@int64@@ & ( @@int64@@ - Number ) ) == Number ; }
__int64 __fastcall test_unop ( _BYTE * @@BYTE@@ ) { __int64 @@int64@@ ; if ( * @@BYTE@@ != Number ) return Number L ; switch ( @@BYTE@@ [ Number ] ) { case String : case String : case String : case String : case String : case String : case String : case String : case String : case String : case String : case String : case String : case String : case String : case String : case String : case String : case String : case String : case String : case String : case String : case String : @@int64@@ = Number L ; break ; default : @@int64@@ = Number L ; break ; } return @@int64@@ ; }
__int64 __fastcall dup_safer ( int @@int@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __int64 a10 , __int64 a11 , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return rpl_fcntl ( @@int@@ , Number , Number L , @@int64@@ , @@int64@@ , @@int64@@ , @@m128@@ , @@m128@@ , @@m128@@ , @@m128@@ , @@m128@@ , @@m128@@ , @@m128@@ , @@m128@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 __fastcall _xargmatch_internal ( __int64 @@int64@@ , const char * @@constchar@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ , void ( * @ @ VAR_587 @ @ void ( ) ( void ) @ @ argmatchexitfn ) ( void ) ) { __int64 @@int64@@ ; @@int64@@ = argmatch ( @@constchar@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; if ( @@int64@@ >= Number ) return @@int64@@ ; argmatch_invalid ( @@int64@@ , ( __int64 ) @@constchar@@ , @@int64@@ ) ; argmatch_valid ( @@int64@@ , @@int64@@ , @@sizet@@ ) ; @ @ VAR_587 @ @ void ( ) ( void ) @ @ argmatchexitfn ( ) ; return Number ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
__int64 __fastcall cycle_check ( __int64 @@int64@@ , _QWORD * @@QWORD@@ ) { if ( * ( _DWORD * ) ( @@int64@@ + Number ) != Number ) __assert_fail ( String , String , Number , String ) ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) && @@QWORD@@ [ Number ] == * ( _QWORD * ) @@int64@@ && * @@QWORD@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ) { return Number L ; } if ( is_zero_or_power_of_two ( ++ * ( _QWORD * ) ( @@int64@@ + Number ) ) ) { if ( ! * ( _QWORD * ) ( @@int64@@ + Number ) ) return Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = * @@QWORD@@ ; * ( _QWORD * ) @@int64@@ = @@QWORD@@ [ Number ] ; } return Number L ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall c_toupper ( int @@int@@ ) { __int64 @@int64@@ ; if ( @@int@@ <= Number || @@int@@ > Number ) @@int64@@ = ( unsigned int ) @@int@@ ; else @@int64@@ = ( unsigned int ) ( @@int@@ - Number ) ; return @@int64@@ ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
void * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * @@int64@@ ; void * @@void@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; void * @@void@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == ( __int64 * ) & slotvec0 ; if ( slotvec == ( __int64 * ) & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@void@@ = off_20D028 ; * @@int64@@ = ( __int64 ) slotvec0 ; @@int64@@ [ Number ] = ( __int64 ) @@void@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = @@int64@@ [ Number * @@int@@ ] ; @@void@@ = ( void * ) @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@void@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = @@unsignedint64@@ + Number ; if ( @@void@@ != & slot0 ) free ( @@void@@ ) ; @@void@@ = ( void * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = ( __int64 ) @@void@@ ; quotearg_buffer_restyled ( ( __int64 ) @@void@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@void@@ ; }
__int64 __fastcall argmatch_to_argument ( const void * @@constvoid@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; ++ @@int64@@ ) { if ( ! memcmp ( @@constvoid@@ , ( const void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) , @@sizet@@ ) ) return * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; } return Number L ; }
__int64 __fastcall mode_create_from_ref ( char * @@char@@ ) { __int64 @@int64@@ ; struct stat @@structstat@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( ( unsigned int ) stat ( @@char@@ , & @@structstat@@ ) ) @@int64@@ = Number L ; else @@int64@@ = make_node_op_equals ( @@structstat@@ . st_mode , Number ) ; return @@int64@@ ; }
void __fastcall freea ( unsigned __int64 @@unsignedint64@@ ) { _QWORD * @@QWORD@@ ; if ( @@unsignedint64@@ && * ( _DWORD * ) ( @@unsignedint64@@ - Number ) == Number ) { for ( @@QWORD@@ = & mmalloca_results [ @@unsignedint64@@ % Number ] ; * @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) ( * @@QWORD@@ - Number L ) ) { if ( @@unsignedint64@@ == * @@QWORD@@ ) { * @@QWORD@@ = * ( _QWORD * ) ( @@unsignedint64@@ - Number ) ; free ( ( void * ) ( @@unsignedint64@@ - Number ) ) ; return ; } } } }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
__int64 __fastcall get_stat_mtime ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
void __fastcall __noreturn test_syntax_error ( const char * @@constchar@@ , __int64 @@int64@@ ) { fprintf ( stderr , String , * ( const char * * ) argv ) ; fprintf ( stderr , @@constchar@@ , @@int64@@ ) ; fputc_unlocked ( Number , stderr ) ; fflush_unlocked ( stderr ) ; exit ( Number ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
__int64 __fastcall advance ( char @@char@@ ) { __int64 @@int64@@ ; @@int64@@ = ( unsigned int ) ++ pos ; if ( @@char@@ ) { @@int64@@ = ( unsigned int ) argc ; if ( pos >= argc ) beyond ( ) ; } return @@int64@@ ; }
unsigned __int64 __fastcall string_hasher_ci ( char * @@char@@ , unsigned __int64 @@unsignedint64@@ ) { signed int @@signedint@@ ; unsigned __int64 @@unsignedint64@@ ; char @@char4@@ [ Number ] ; int @@int@@ ; char @@char@@ ; char * @@char@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@unsignedint64@@ = Number L ; @@char@@ = @@char@@ ; @@char4@@ [ Number ] = Number ; memset ( & @@int@@ , Number , Number ) ; for ( @@char@@ = Number ; ; @@char@@ = Number ) { mbuiter_multi_next_0 ( ( __int64 ) @@char4@@ ) ; if ( ( unsigned __int8 ) @@int64@@ == Number && ! HIDWORD ( @@int64@@ ) ) break ; if ( ( _BYTE ) @@int64@@ ) @@signedint@@ = towlower ( HIDWORD ( @@int64@@ ) ) ; else @@signedint@@ = * @@char@@ ; @@unsignedint64@@ = ( Number * @@unsignedint64@@ + @@signedint@@ ) % @@unsignedint64@@ ; @@char@@ += @@int64@@ ; } return @@unsignedint64@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
unsigned __int64 __fastcall print_login ( __int64 @@int64@@ ) { char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@char@@ = make_id_equals_comment ( @@int64@@ ) ; sprintf ( @@char@@ , String , * ( int * ) ( @@int64@@ + Number ) ) ; @@char@@ = time_string ( @@int64@@ ) ; @@char@@ = gettext ( String ) ; print_line ( Number , ( __int64 ) @@char@@ , Number , Number , @@int64@@ + Number , ( __int64 ) @@char@@ , & locale , @@char@@ , ( __int64 ) @@char@@ , & locale ) ; free ( @@char@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
_BOOL8 __fastcall get_mtime ( char * @@char@@ , __int64 * @@int64@@ ) { int @@int@@ ; __int64 @@int64@@ ; bool @@bool@@ ; struct stat @@structstat@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int@@ = stat ( @@char@@ , & @@structstat@@ ) ; @@bool@@ = @@int@@ == Number ; if ( ! @@int@@ ) { * @@int64@@ = get_stat_mtime ( ( __int64 ) & @@structstat@@ ) ; @@int64@@ [ Number ] = @@int64@@ ; } return @@bool@@ ; }
void __fastcall free_exclude_segment ( __int64 @@int64@@ ) { int @@int@@ ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) ; if ( @@int@@ ) { if ( @@int@@ == Number ) free ( * ( void * * ) ( @@int64@@ + Number ) ) ; } else { hash_free ( * ( _QWORD * ) ( @@int64@@ + Number ) ) ; } free ( ( void * ) @@int64@@ ) ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_207028 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
unsigned __int64 __fastcall who ( __int64 @@int64@@ , unsigned int @@unsignedint@@ ) { int * @@int@@ ; char * @@char@@ ; void * @@void@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( ( unsigned int ) read_utmp ( @@int64@@ , & @@char@@ , & @@void@@ , @@unsignedint@@ ) ) { @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , off_BC43 , @@int64@@ ) ; } if ( short_list ) list_entries_who ( ( __int64 ) @@char@@ , ( __int64 ) @@void@@ ) ; else scan_entries ( @@char@@ , ( __int64 ) @@void@@ ) ; free ( @@void@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
_BOOL8 __fastcall exclude_fnmatch ( __int64 @@int64@@ , _BYTE * @@BYTE@@ , unsigned int @@unsignedint@@ ) { void * @@void@@ ; bool @@bool@@ ; _BYTE * @@BYTE@@ ; unsigned int ( __fastcall * @ @ VAR_658 @ @ unsignedint ( fastcall ) ( int64 , BYTE , QWORD ) @ @ int ( ) ( constchar , constchar , int ) ) ( __int64 , _BYTE * , _QWORD ) ; if ( ( @@unsignedint@@ & Number ) != Number ) @@void@@ = & fnmatch ; else @@void@@ = fnmatch_no_wildcards ; @ @ VAR_658 @ @ unsignedint ( fastcall ) ( int64 , BYTE , QWORD ) @ @ int ( ) ( constchar , constchar , int ) = ( unsigned int ( __fastcall * ) ( __int64 , _BYTE * , _QWORD ) ) @@void@@ ; @@bool@@ = ( ( unsigned int ( __fastcall * ) ( __int64 , _BYTE * , _QWORD ) ) @@void@@ ) ( @@int64@@ , @@BYTE@@ , @@unsignedint@@ ) == Number ; if ( ( @@unsignedint@@ & Number ) == Number ) { for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ && ! @@bool@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number && @@BYTE@@ [ Number ] != Number ) @@bool@@ = @ @ VAR_658 @ @ unsignedint ( fastcall ) ( int64 , BYTE , QWORD ) @ @ int ( ) ( constchar , constchar , int ) ( @@int64@@ , @@BYTE@@ + Number , @@unsignedint@@ ) == Number ; } } return @@bool@@ ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
_BOOL8 __fastcall du_files ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { char * @@char@@ ; int * @@int@@ ; char * @@char@@ ; int * @@int@@ ; bool @@bool@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; @@bool@@ = Number ; if ( * @@QWORD@@ ) { for ( @@int64@@ = xfts_open ( @@QWORD@@ , @@unsignedint@@ , Number L ) ; ; @@bool@@ = ( @@bool@@ & ( unsigned __int8 ) process_file ( @@int64@@ , @@int64@@ ) ) != Number ) { @@int64@@ = fts_read ( @@int64@@ ) ; if ( ! @@int64@@ ) break ; } if ( * __errno_location ( ) ) { @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ ) ; @@bool@@ = Number ; } if ( ( unsigned int ) fts_close ( @@int64@@ ) ) { @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ ) ; @@bool@@ = Number ; } } return @@bool@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_20A028 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall canon_host ( __int64 @@int64@@ ) { return canon_host_r ( @@int64@@ , & last_cherror ) ; }
_BOOL8 __fastcall excluded_file_name_p ( __int64 @@int64@@ , char * @@char@@ , char * @@char@@ ) { int @@int@@ ; __int64 @@int64@@ ; char * @@char@@ ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; do { strcpy ( @@char@@ , @@char@@ ) ; while ( Number ) { if ( hash_lookup ( @@int64@@ , @@char@@ ) ) return ( @@int@@ & Number ) == Number ; if ( ( @@int@@ & Number ) == Number ) break ; @@char@@ = strrchr ( @@char@@ , Number ) ; if ( ! @@char@@ ) break ; * @@char@@ = Number ; } if ( ( @@int@@ & Number ) != Number ) break ; @@char@@ = strchr ( @@char@@ , Number ) ; if ( @@char@@ ) ++ @@char@@ ; } while ( @@char@@ ) ; return ( @@int@@ & Number ) != Number ; }
__int64 __fastcall argv_iter_n_args ( _QWORD * @@QWORD@@ ) { __int64 @@int64@@ ; if ( * @@QWORD@@ ) @@int64@@ = @@QWORD@@ [ Number ] ; else @@int64@@ = ( __int64 ) ( @@QWORD@@ [ Number ] - @@QWORD@@ [ Number ] ) >> Number ; return @@int64@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
bool __fastcall is_basic ( unsigned __int8 @@unsignedint8@@ ) { return ( ( is_basic_table [ @@unsignedint8@@ >> Number ] >> ( @@unsignedint8@@ & Number ) ) & Number ) != Number ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall imaxtostr ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ + Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = Number ; if ( @@int64@@ >= Number ) { do { * ( _BYTE * ) -- @@int64@@ = ( char ) @@int64@@ % Number + Number ; @@int64@@ /= Number L ; } while ( @@int64@@ ) ; } else { do { * ( _BYTE * ) -- @@int64@@ = Number - ( char ) @@int64@@ % Number ; @@int64@@ /= Number L ; } while ( @@int64@@ ) ; * ( _BYTE * ) -- @@int64@@ = Number ; } return @@int64@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_2070C8 ; @@int648@@ [ Number ] = qword_2070D0 ; @@int648@@ [ Number ] = qword_2070D8 ; @@int648@@ [ Number ] = qword_2070E0 ; @@int648@@ [ Number ] = qword_2070E8 ; @@int648@@ [ Number ] = qword_2070F0 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
unsigned __int64 __fastcall print_runlevel ( __int64 @@int64@@ ) { int @@int@@ ; char * @@char@@ ; size_t @@sizet@@ ; char * @@char@@ ; char * @@char@@ ; size_t @@sizet@@ ; unsigned int @@unsignedint@@ ; char * @@char@@ ; const char * @@constchar@@ ; char * @@char@@ ; unsigned __int8 @@unsignedint8@@ ; unsigned __int8 @@unsignedint8@@ ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) ; if ( @@int@@ < Number ) BYTE1 ( @@int@@ ) = ( unsigned __int16 ) ( @@int@@ + Number ) >> Number ; @@unsignedint8@@ = BYTE1 ( @@int@@ ) ; @@unsignedint8@@ = * ( _DWORD * ) ( @@int64@@ + Number ) ; if ( ! runlevline_5719 ) { @@char@@ = gettext ( String ) ; @@sizet@@ = strlen ( @@char@@ ) ; runlevline_5719 = ( char * ) xmalloc ( @@sizet@@ + Number ) ; } @@char@@ = gettext ( String ) ; sprintf ( runlevline_5719 , String , @@char@@ , @@unsignedint8@@ ) ; if ( ! comment_5720 ) { @@char@@ = gettext ( String ) ; @@sizet@@ = strlen ( @@char@@ ) ; comment_5720 = ( char * ) xmalloc ( @@sizet@@ + Number ) ; } if ( @@unsignedint8@@ == Number ) @@unsignedint@@ = Number ; else @@unsignedint@@ = @@unsignedint8@@ ; @@char@@ = gettext ( String ) ; sprintf ( comment_5720 , String , @@char@@ , @@unsignedint@@ ) ; if ( ( unsigned __int8 ) c_isprint ( @@unsignedint8@@ ) ) @@constchar@@ = comment_5720 ; else @@constchar@@ = & locale ; @@char@@ = time_string ( @@int64@@ ) ; return print_line ( Number , ( __int64 ) & locale , Number , Number , ( __int64 ) runlevline_5719 , ( __int64 ) @@char@@ , & locale , & locale , ( __int64 ) @@constchar@@ , & locale ) ; }
__int64 __fastcall add_exclude_file ( void ( __fastcall * @ @ VAR_709 @ @ void ( fastcall ) ( int64 , BYTE , QWORD ) @ @ void ( ) ( exclude , constchar , int ) ) ( __int64 , _BYTE * , _QWORD ) , __int64 @@int64@@ , __int64 @@int64@@ , unsigned int @@unsignedint@@ , unsigned __int8 @@unsignedint8@@ ) { bool @@bool@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; _BOOL4 @@BOOL4@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 @@int64@@ ; FILE * @@FILE@@ ; _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; __int64 @@int64@@ ; _BYTE * @@BYTE@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@bool@@ = * ( _BYTE * ) @@int64@@ == Number && ! * ( _BYTE * ) ( @@int64@@ + Number ) ; @@bool@@ = @@bool@@ ; @@BYTE@@ = Number L ; @@int64@@ = Number L ; @@int64@@ = Number L ; @@int@@ = Number ; if ( @@bool@@ ) { @@FILE@@ = stdin ; } else { @@FILE@@ = fopen ( ( const char * ) @@int64@@ , String ) ; if ( ! @@FILE@@ ) return Number ; } while ( Number ) { @@int@@ = getc_unlocked ( @@FILE@@ ) ; if ( @@int@@ == Number ) break ; if ( @@int64@@ == @@int64@@ ) @@BYTE@@ = ( _BYTE * ) x2realloc ( @@BYTE@@ , & @@int64@@ ) ; @@int64@@ = @@int64@@ ++ ; @@BYTE@@ [ @@int64@@ ] = @@int@@ ; } if ( ferror_unlocked ( @@FILE@@ ) ) @@int@@ = * __errno_location ( ) ; if ( ! @@bool@@ && fclose ( @@FILE@@ ) ) @@int@@ = * __errno_location ( ) ; @@BYTE@@ = ( _BYTE * ) xrealloc ( @@BYTE@@ , @@int64@@ + Number ) ; @@BYTE@@ [ @@int64@@ ] = @@unsignedint8@@ ; @@BOOL4@@ = @@int64@@ && @@unsignedint8@@ != @@BYTE@@ [ @@int64@@ - Number ] ; @@unsignedint64@@ = ( unsigned __int64 ) & @@BYTE@@ [ @@int64@@ + @@BOOL4@@ ] ; @@BYTE@@ = @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; ( unsigned __int64 ) @@BYTE@@ < @@unsignedint64@@ ; ++ @@BYTE@@ ) { if ( @@unsignedint8@@ == * @@BYTE@@ ) { @@BYTE@@ = @@BYTE@@ ; if ( ( ( * __ctype_b_loc ( ) ) [ @@unsignedint8@@ ] & Number ) != Number ) { while ( @@BYTE@@ != @@BYTE@@ ) { if ( ( ( * __ctype_b_loc ( ) ) [ ( unsigned __int8 ) * ( @@BYTE@@ - Number ) ] & Number ) == Number ) goto LABEL_28 ; -- @@BYTE@@ ; } } else { LABEL_28 : * @@BYTE@@ = Number ; @ @ VAR_709 @ @ void ( fastcall ) ( int64 , BYTE , QWORD ) @ @ void ( ) ( exclude , constchar , int ) ( @@int64@@ , @@BYTE@@ , @@unsignedint@@ ) ; } @@BYTE@@ = @@BYTE@@ + Number ; } } * __errno_location ( ) = @@int@@ ; if ( @@int@@ ) @@int64@@ = Number ; else @@int64@@ = Number L ; return @@int64@@ ; }
char * __fastcall proper_name_utf8 ( const char * @@constchar@@ , __int64 @@int64@@ ) { char * @@char@@ ; char * @@char@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; char * @@char@@ ; char * @@char@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; size_t @@sizet@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; @@char@@ = ( char * ) locale_charset ( ) ; @@char@@ = Number L ; @@char@@ = Number L ; @@int64@@ = Number L ; if ( ( unsigned int ) c_strcasecmp ( @@char@@ , String ) ) { @@char@@ = ( char * ) xstr_iconv ( @@int64@@ , String , @@char@@ ) ; @@int64@@ = ( __int64 ) @@char@@ ; @@sizet@@ = strlen ( @@char@@ ) ; @@char@@ = ( char * ) xmalloc ( @@sizet@@ + Number ) ; memcpy ( @@char@@ , @@char@@ , @@sizet@@ ) ; memcpy ( & @@char@@ [ @@sizet@@ ] , String , Number ) ; @@char@@ = ( char * ) xstr_iconv ( @@int64@@ , String , @@char@@ ) ; free ( @@char@@ ) ; if ( @@char@@ ) { if ( strchr ( @@char@@ , Number ) ) { free ( @@char@@ ) ; } else { @@char@@ = @@char@@ ; @@int64@@ = ( __int64 ) @@char@@ ; } } } else { @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; } if ( @@int64@@ ) { @@char@@ = ( char * ) @@int64@@ ; } else if ( @@int64@@ ) { @@char@@ = ( char * ) @@int64@@ ; } else { @@char@@ = ( char * ) @@constchar@@ ; } @@char@@ = @@char@@ ; if ( ! strcmp ( @@char@@ , @@constchar@@ ) ) { if ( @@char@@ && @@char@@ != @@char@@ ) free ( @@char@@ ) ; if ( @@char@@ && @@char@@ != @@char@@ ) free ( @@char@@ ) ; @@char@@ = @@char@@ ; } else if ( ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@char@@ , ( __int64 ) @@constchar@@ ) || @@int64@@ && ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@char@@ , @@int64@@ ) || @@int64@@ && ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@char@@ , @@int64@@ ) ) { if ( @@char@@ ) free ( @@char@@ ) ; if ( @@char@@ ) free ( @@char@@ ) ; @@char@@ = @@char@@ ; } else { @@sizet@@ = strlen ( @@char@@ ) ; @@sizet@@ = strlen ( @@char@@ ) ; @@char@@ = ( char * ) xmalloc ( @@sizet@@ + @@sizet@@ + Number ) ; sprintf ( @@char@@ , String , @@char@@ , @@char@@ ) ; if ( @@char@@ ) free ( @@char@@ ) ; if ( @@char@@ ) free ( @@char@@ ) ; @@char@@ = @@char@@ ; } return @@char@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
unsigned __int64 __fastcall print_only_size ( __int64 @@int64@@ ) { FILE * @@FILE@@ ; const char * @@constchar@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@FILE@@ = stdout ; @@constchar@@ = ( const char * ) human_readable ( @@int64@@ , @@char@@ , ( unsigned int ) human_output_opts , Number L , output_block_size ) ; fputs_unlocked ( @@constchar@@ , @@FILE@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
_BOOL8 __fastcall leaf_optimization_applies ( int @@int@@ ) { _BOOL8 @@BOOL8@@ ; struct statfs @@structstatfs@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( fstatfs ( @@int@@ , & @@structstatfs@@ ) ) @@BOOL8@@ = Number L ; else @@BOOL8@@ = @@structstatfs@@ . f_type == Number ; return @@BOOL8@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
void __fastcall free_dir ( __int64 @@int64@@ ) { if ( ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number ) { if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) hash_free ( * ( _QWORD * ) ( @@int64@@ + Number ) ) ; } else { free ( * ( void * * ) ( @@int64@@ + Number ) ) ; } }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
_QWORD * __fastcall argv_iter_init_stream ( __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; @@QWORD@@ = malloc ( Number ) ; if ( ! @@QWORD@@ ) return Number L ; * @@QWORD@@ = @@int64@@ ; @@QWORD@@ [ Number ] = Number L ; @@QWORD@@ [ Number ] = Number L ; @@QWORD@@ [ Number ] = Number L ; @@QWORD@@ [ Number ] = Number L ; return @@QWORD@@ ; }
__int64 __fastcall link_count_optimize_ok ( __int64 @@int64@@ ) { __int64 @@int64@@ ; bool @@bool@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; _BYTE * @@BYTE@@ ; __int64 @@int644@@ [ Number ] ; @@int644@@ [ Number ] = __readfsqword ( Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) == Number ) return Number L ; if ( ! @@int64@@ ) { * ( _QWORD * ) ( @@int64@@ + Number ) = hash_initialize ( Number L , Number L , LCO_hash , LCO_compare , & free ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( ! @@int64@@ ) return Number L ; } @@int644@@ [ Number ] = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = hash_lookup ( @@int64@@ , @@int644@@ ) ; if ( @@int64@@ ) return * ( unsigned __int8 * ) ( @@int64@@ + Number ) ; @@BYTE@@ = malloc ( Number ) ; if ( ! @@BYTE@@ ) return Number L ; @@bool@@ = leaf_optimization_applies ( * ( _DWORD * ) ( @@int64@@ + Number ) ) ; @@BYTE@@ [ Number ] = @@bool@@ ; * ( _QWORD * ) @@BYTE@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = hash_insert ( @@int64@@ , @@BYTE@@ ) ; if ( @@int64@@ ) { if ( ( _BYTE * ) @@int64@@ != @@BYTE@@ ) abort ( ) ; @@int64@@ = @@bool@@ ; } else { free ( @@BYTE@@ ) ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_20F038 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
bool __fastcall is_basic_1 ( unsigned __int8 @@unsignedint8@@ ) { return ( ( is_basic_table [ @@unsignedint8@@ >> Number ] >> ( @@unsignedint8@@ & Number ) ) & Number ) != Number ; }
__int64 __fastcall cwd_advance_fd ( __int64 @@int64@@ , int @@int@@ , char @@char@@ ) { __int64 @@int64@@ ; int @@int@@ ; int @@int@@ ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) ; if ( @@int@@ == @@int@@ && @@int@@ != Number ) abort ( ) ; if ( @@char@@ ) { @@int@@ = i_ring_push ( @@int64@@ + Number , ( unsigned int ) @@int@@ ) ; if ( @@int@@ >= Number ) close ( @@int@@ ) ; } else if ( ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) == Number && @@int@@ >= Number ) { close ( @@int@@ ) ; } @@int64@@ = @@int64@@ ; * ( _DWORD * ) ( @@int64@@ + Number ) = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall hash_lookup ( __int64 * @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; @@int64@@ = * @@int64@@ ; @@QWORD@@ = ( _QWORD * ) ( @@int64@@ + Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@int64@@ [ Number ] ) ( @@int64@@ , @@int64@@ [ Number ] ) ) ; if ( ( unsigned __int64 ) @@QWORD@@ >= @@int64@@ [ Number ] ) abort ( ) ; if ( ! * @@QWORD@@ ) return Number L ; for ( @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { if ( @@int64@@ == * @@QWORD@@ || ( ( unsigned __int8 ( __fastcall * ) ( __int64 , _QWORD ) ) @@int64@@ [ Number ] ) ( @@int64@@ , * @@QWORD@@ ) ) { return * @@QWORD@@ ; } } return Number L ; }
__int64 __fastcall fts_compare_ino ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; if ( * ( _QWORD * ) ( * ( _QWORD * ) @@int64@@ + Number L ) < * ( _QWORD * ) ( * ( _QWORD * ) @@int64@@ + Number L ) ) @@int64@@ = Number ; else @@int64@@ = * ( _QWORD * ) ( * ( _QWORD * ) @@int64@@ + Number L ) < * ( _QWORD * ) ( * ( _QWORD * ) @@int64@@ + Number L ) ; return @@int64@@ ; }
bool __fastcall is_prime ( unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = Number L ; @@unsignedint64@@ = Number L ; while ( @@unsignedint64@@ < @@unsignedint64@@ && @@unsignedint64@@ % @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@unsignedint64@@ += Number * @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint64@@ + Number ; } return @@unsignedint64@@ % @@unsignedint64@@ != Number ; }
__int64 __fastcall portable_chars_only ( const char * @@constchar@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; char * @@char@@ ; size_t @@sizet@@ ; char * @@char@@ ; size_t @@sizet@@ ; mbstate_t @@mbstatet@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@sizet@@ = strspn ( @@constchar@@ , String ) ; @@char@@ = ( char * ) & @@constchar@@ [ @@sizet@@ ] ; if ( ! @@constchar@@ [ @@sizet@@ ] ) return Number L ; @@mbstatet@@ = Number L ; @@sizet@@ = mbrlen ( @@char@@ , @@int64@@ - @@sizet@@ , & @@mbstatet@@ ) ; @@int64@@ = quote_n ( Number L , @@constchar@@ ) ; if ( @@sizet@@ > Number ) @@int64@@ = Number L ; else @@int64@@ = @@sizet@@ ; @@int64@@ = quotearg_n_style_mem ( Number L , Number L , @@char@@ , @@int64@@ ) ; @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ , @@int64@@ , @@int64@@ ) ; return Number L ; }
__int64 __fastcall new_exclude_segment ( __int64 @@int64@@ , int @@int@@ , int @@int@@ ) { void * @@void@@ ; void * @@void@@ ; __int64 @@int64@@ ; @@int64@@ = xzalloc ( Number L ) ; * ( _DWORD * ) ( @@int64@@ + Number ) = @@int@@ ; * ( _DWORD * ) ( @@int64@@ + Number ) = @@int@@ ; if ( ! @@int@@ ) { if ( ( @@int@@ & Number ) != Number ) @@void@@ = string_compare_ci ; else @@void@@ = string_compare ; if ( ( @@int@@ & Number ) != Number ) @@void@@ = string_hasher_ci ; else @@void@@ = string_hasher ; * ( _QWORD * ) ( @@int64@@ + Number ) = hash_initialize ( Number L , Number L , @@void@@ , @@void@@ , string_free ) ; } if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) * * ( _QWORD * * ) ( @@int64@@ + Number ) = @@int64@@ ; else * ( _QWORD * ) @@int64@@ = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; return @@int64@@ ; }
__int64 __fastcall read_utmp ( const char * @@constchar@@ , _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ , char @@char@@ ) { __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; struct utmpx * @@structutmpx@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; struct utmpx * @@structutmpx@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = Number L ; @@int64@@ = Number L ; @@int64@@ = Number L ; utmpxname ( @@constchar@@ ) ; setutxent ( ) ; while ( Number ) { @@structutmpx@@ = getutxent ( ) ; if ( ! @@structutmpx@@ ) break ; if ( desirable_utmp_entry ( ( __int64 ) @@structutmpx@@ , @@char@@ ) ) { if ( @@int64@@ == @@int64@@ ) @@int64@@ = x2nrealloc ( @@int64@@ , & @@int64@@ , Number L ) ; @@int64@@ = @@int64@@ ++ ; @@QWORD@@ = ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; @@structutmpx@@ = @@structutmpx@@ ; * @@QWORD@@ = * ( _QWORD * ) & @@structutmpx@@ -> ut_type ; @@QWORD@@ [ Number ] = * ( _QWORD * ) & @@structutmpx@@ -> __unused [ Number ] ; qmemcpy ( ( void * ) ( ( unsigned __int64 ) ( @@QWORD@@ + Number ) & Number ) , ( const void * ) ( ( char * ) @@structutmpx@@ - ( ( char * ) @@QWORD@@ - ( ( unsigned __int64 ) ( @@QWORD@@ + Number ) & Number ) ) ) , Number L * ( ( ( ( _DWORD ) @@QWORD@@ - ( ( ( _DWORD ) @@QWORD@@ + Number ) & Number ) + Number ) & Number ) >> Number ) ) ; } } endutxent ( ) ; * @@QWORD@@ = @@int64@@ ; * @@QWORD@@ = @@int64@@ ; return Number L ; }
size_t __fastcall fts_maxarglen ( const char * * @@constchar@@ ) { size_t @@sizet@@ ; size_t @@sizet@@ ; @@sizet@@ = Number L ; while ( * @@constchar@@ ) { @@sizet@@ = strlen ( * @@constchar@@ ) ; if ( @@sizet@@ > @@sizet@@ ) @@sizet@@ = @@sizet@@ ; ++ @@constchar@@ ; } return @@sizet@@ + Number ; }
void * __fastcall allocate_entry ( __int64 @@int64@@ ) { __int64 @@int64@@ ; if ( ! * ( _QWORD * ) ( @@int64@@ + Number ) ) return malloc ( Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; return ( void * ) @@int64@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
void __fastcall free_exclude ( _QWORD * * @@QWORD@@ ) { _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; for ( @@QWORD@@ = * @@QWORD@@ ; @@QWORD@@ ; @@QWORD@@ = @@QWORD@@ ) { @@QWORD@@ = ( _QWORD * ) * @@QWORD@@ ; free_exclude_segment ( ( __int64 ) @@QWORD@@ ) ; } free ( @@QWORD@@ ) ; }
__int64 __fastcall hash_get_n_buckets_used ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
_BYTE * __fastcall component_start ( _BYTE * @@BYTE@@ ) { while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; return @@BYTE@@ ; }
__int64 __fastcall free_entry ( __int64 @@int64@@ , _QWORD * @@QWORD@@ ) { __int64 @@int64@@ ; * @@QWORD@@ = Number L ; @@QWORD@@ [ Number ] = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@QWORD@@ ; return @@int64@@ ; }
__int64 __fastcall component_len ( __int64 @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) != Number && * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) ; ++ @@int64@@ ) { ; } return @@int64@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
__int64 __fastcall transfer_entries ( __int64 @@int64@@ , __int64 @@int64@@ , char @@char@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 * @@int64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; for ( @@int64@@ = * ( __int64 * * ) @@int64@@ ; ( unsigned __int64 ) @@int64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ += Number ) { if ( * @@int64@@ ) { for ( @@QWORD@@ = ( _QWORD * ) @@int64@@ [ Number ] ; @@QWORD@@ ; @@QWORD@@ = @@QWORD@@ ) { @@int64@@ = * @@QWORD@@ ; @@int64@@ = * ( _QWORD * ) @@int64@@ ; @@QWORD@@ = ( _QWORD * ) ( @@int64@@ + Number * ( * ( __int64 ( __fastcall * * ) ( _QWORD , _QWORD ) ) ( @@int64@@ + Number ) ) ( * @@QWORD@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@QWORD@@ >= * ( _QWORD * ) ( @@int64@@ + Number ) ) abort ( ) ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; if ( * @@QWORD@@ ) { @@QWORD@@ [ Number ] = @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = @@QWORD@@ ; } else { * @@QWORD@@ = @@int64@@ ; ++ * ( _QWORD * ) ( @@int64@@ + Number ) ; free_entry ( @@int64@@ , @@QWORD@@ ) ; } } @@int64@@ = * @@int64@@ ; @@int64@@ [ Number ] = Number L ; if ( ! @@char@@ ) { @@int64@@ = * ( _QWORD * ) @@int64@@ ; @@QWORD@@ = ( _QWORD * ) ( @@int64@@ + Number * ( * ( __int64 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@int64@@ + Number ) ) ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@QWORD@@ >= * ( _QWORD * ) ( @@int64@@ + Number ) ) abort ( ) ; if ( * @@QWORD@@ ) { @@QWORD@@ = allocate_entry ( @@int64@@ ) ; if ( ! @@QWORD@@ ) return Number L ; * @@QWORD@@ = @@int64@@ ; @@QWORD@@ [ Number ] = @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = @@QWORD@@ ; } else { * @@QWORD@@ = @@int64@@ ; ++ * ( _QWORD * ) ( @@int64@@ + Number ) ; } * @@int64@@ = Number L ; -- * ( _QWORD * ) ( @@int64@@ + Number ) ; } } } return Number L ; }
_BOOL8 __fastcall excluded_file_pattern_p ( __int64 @@int64@@ , _BYTE * @@BYTE@@ ) { bool @@bool@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; @@unsignedint64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@bool@@ = ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@unsignedint64@@ ; ++ @@unsignedint64@@ ) { if ( @@bool@@ != exclude_fnmatch ( * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@int64@@ ) , @@BYTE@@ , * ( _DWORD * ) ( Number * @@unsignedint64@@ + @@int64@@ + Number ) ) ) return ! @@bool@@ ; } return @@bool@@ ; }
unsigned __int64 __fastcall hash_get_max_bucket_length ( __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = Number L ; for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { @@QWORD@@ = @@QWORD@@ ; for ( @@unsignedint64@@ = Number L ; ; ++ @@unsignedint64@@ ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; if ( ! @@QWORD@@ ) break ; } if ( @@unsignedint64@@ > @@unsignedint64@@ ) @@unsignedint64@@ = @@unsignedint64@@ ; } } return @@unsignedint64@@ ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
unsigned __int64 __fastcall hash_get_entries ( __int64 @@int64@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; @@unsignedint64@@ = Number L ; for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { for ( @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { if ( @@unsignedint64@@ >= @@unsignedint64@@ ) return @@unsignedint64@@ ; @@int64@@ = @@unsignedint64@@ ++ ; * ( _QWORD * ) ( @@int64@@ + Number * @@int64@@ ) = * @@QWORD@@ ; } } } return @@unsignedint64@@ ; }
__int64 __fastcall excluded_file_name ( __int64 * @@int64@@ , char * @@char@@ ) { int @@int@@ ; size_t @@sizet@@ ; unsigned __int8 @@unsignedint8@@ ; unsigned __int8 @@unsignedint8@@ ; __int64 @@int64@@ ; char * @@char@@ ; @@char@@ = Number L ; if ( ! * @@int64@@ ) return Number L ; @@unsignedint8@@ = ( * ( _DWORD * ) ( * @@int64@@ + Number ) & Number ) != Number ; for ( @@int64@@ = * @@int64@@ ; @@int64@@ ; @@int64@@ = * ( _QWORD * ) @@int64@@ ) { @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) ; if ( @@int@@ ) { if ( @@int@@ != Number ) abort ( ) ; @@unsignedint8@@ = excluded_file_pattern_p ( @@int64@@ , @@char@@ ) ; } else { if ( ! @@char@@ ) { @@sizet@@ = strlen ( @@char@@ ) ; @@char@@ = ( char * ) xmalloc ( @@sizet@@ + Number ) ; } @@unsignedint8@@ = excluded_file_name_p ( @@int64@@ , @@char@@ , @@char@@ ) ; } if ( @@unsignedint8@@ != @@unsignedint8@@ ) { @@unsignedint8@@ = @@unsignedint8@@ ; break ; } } free ( @@char@@ ) ; return @@unsignedint8@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_2070A8 ; @@int648@@ [ Number ] = qword_2070B0 ; @@int648@@ [ Number ] = qword_2070B8 ; @@int648@@ [ Number ] = qword_2070C0 ; @@int648@@ [ Number ] = qword_2070C8 ; @@int648@@ [ Number ] = qword_2070D0 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
unsigned __int64 __fastcall raw_hasher ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { return rotr_sz ( @@int64@@ , Number ) % @@unsignedint64@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 __fastcall fwrite_lowcase ( FILE * @@FILE@@ , unsigned __int8 * @@unsignedint8@@ , __int64 @@int64@@ ) { int @@int@@ ; __int64 @@int64@@ ; while ( Number ) { @@int64@@ = @@int64@@ -- ; if ( ! @@int64@@ ) break ; @@int@@ = tolower ( * @@unsignedint8@@ ) ; fputc ( @@int@@ , @@FILE@@ ) ; ++ @@unsignedint8@@ ; } return @@int64@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
unsigned __int64 __fastcall compute_bucket_size ( __int64 @@int64@@ , __int64 @@int64@@ ) { float @@float@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; float @@float@@ ; @@unsignedint64@@ = @@int64@@ ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) != Number ) { if ( @@int64@@ < Number ) @@float@@ = ( float ) ( @@int64@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@int64@@ >> Number ) ) + ( float ) ( @@int64@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@int64@@ >> Number ) ) ; else @@float@@ = ( float ) ( int ) @@int64@@ ; @@float@@ = @@float@@ / * ( float * ) ( @@int64@@ + Number ) ; if ( @@float@@ >= Number ) return Number L ; if ( @@float@@ >= Number ) @@unsignedint64@@ = ( unsigned int ) ( int ) ( float ) ( @@float@@ - Number ) ^ Number ; else @@unsignedint64@@ = ( unsigned int ) ( int ) @@float@@ ; } @@unsignedint64@@ = next_prime ( @@unsignedint64@@ ) ; if ( @@unsignedint64@@ <= Number ) @@unsignedint64@@ = @@unsignedint64@@ ; else @@unsignedint64@@ = Number L ; return @@unsignedint64@@ ; }
unsigned __int64 __fastcall getoptarg ( _BYTE * @@BYTE@@ , char @@char@@ , _BYTE * @@BYTE@@ , _DWORD * @@DWORD@@ ) { __int64 @@int64@@ ; char * @@char@@ ; _BYTE * @@BYTE@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@BYTE@@ = @@BYTE@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( ( unsigned int ) ( ( char ) * @@BYTE@@ - Number ) > Number ) { @@BYTE@@ = @@BYTE@@ + Number ; * @@BYTE@@ = * @@BYTE@@ ; } if ( * @@BYTE@@ ) { if ( ( unsigned int ) xstrtol ( @@BYTE@@ , Number L , Number L , & @@int64@@ , & locale ) || @@int64@@ <= Number || @@int64@@ > Number ) { @@int64@@ = quote ( @@BYTE@@ ) ; @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ , ( unsigned int ) @@char@@ , @@int64@@ ) ; usage ( Number L ) ; } * @@DWORD@@ = @@int64@@ ; } return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
__int64 __fastcall fwrite_uppcase ( FILE * @@FILE@@ , unsigned __int8 * @@unsignedint8@@ , __int64 @@int64@@ ) { int @@int@@ ; __int64 @@int64@@ ; while ( Number ) { @@int64@@ = @@int64@@ -- ; if ( ! @@int64@@ ) break ; @@int@@ = toupper ( * @@unsignedint8@@ ) ; fputc ( @@int@@ , @@FILE@@ ) ; ++ @@unsignedint8@@ ; } return @@int64@@ ; }
__int64 __fastcall x2nrealloc ( __int64 @@int64@@ , unsigned __int64 * @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = * @@unsignedint64@@ ; if ( @@int64@@ ) { if ( @@unsignedint64@@ >= Number / @@unsignedint64@@ ) xalloc_die ( ) ; @@unsignedint64@@ += ( @@unsignedint64@@ + Number ) >> Number ; } else if ( ! @@unsignedint64@@ ) { @@unsignedint64@@ = ( Number / @@unsignedint64@@ == Number ) + Number / @@unsignedint64@@ ; } * @@unsignedint64@@ = @@unsignedint64@@ ; return xrealloc ( @@int64@@ , @@unsignedint64@@ * @@unsignedint64@@ ) ; }
__int64 __fastcall hash_rehash ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; void * @@void@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@unsignedint64@@ = compute_bucket_size ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( ! @@unsignedint64@@ ) return Number L ; if ( @@unsignedint64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ) return Number L ; @@void@@ = calloc ( @@unsignedint64@@ , Number ) ; if ( ! @@void@@ ) return Number L ; @@unsignedint64@@ = @@unsignedint64@@ ; @@int64@@ = ( __int64 ) @@void@@ + Number * @@unsignedint64@@ ; @@int64@@ = Number L ; @@int64@@ = Number L ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( ( unsigned __int8 ) transfer_entries ( ( __int64 ) & @@void@@ , @@int64@@ , Number ) ) { free ( * ( void * * ) @@int64@@ ) ; * ( _QWORD * ) @@int64@@ = @@void@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@unsignedint64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; @@int64@@ = Number L ; } else { * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; if ( ( unsigned __int8 ) transfer_entries ( @@int64@@ , ( __int64 ) & @@void@@ , Number ) != Number || ( unsigned __int8 ) transfer_entries ( @@int64@@ , ( __int64 ) & @@void@@ , Number ) != Number ) { abort ( ) ; } free ( @@void@@ ) ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall hold_file ( __int64 @@int64@@ ) { int @@int@@ ; _DWORD * @@DWORD@@ ; if ( parallel_files != Number ) { @@DWORD@@ = column_vector ; for ( @@int@@ = columns ; @@int@@ ; -- @@int@@ ) { if ( storing_columns ) @@DWORD@@ [ Number ] = Number ; else @@DWORD@@ [ Number ] = Number ; @@DWORD@@ += Number ; } } else { * ( _DWORD * ) ( @@int64@@ + Number ) = Number ; } * ( _DWORD * ) ( @@int64@@ + Number ) = Number ; return ( unsigned int ) -- files_ready_to_read ; }
const char * locale_charset ( ) { const char * @@constchar@@ ; char * @@char@@ ; char * @@char@@ ; @@constchar@@ = nl_langinfo ( Number ) ; if ( ! @@constchar@@ ) @@constchar@@ = ( const char * ) & unk_1785F ; for ( @@char@@ = ( char * ) get_charset_aliases ( ) ; * @@char@@ ; @@char@@ = & @@char@@ [ strlen ( @@char@@ ) + Number ] ) { if ( ! strcmp ( @@constchar@@ , @@char@@ ) || * @@char@@ == Number && ! @@char@@ [ Number ] ) { @@constchar@@ = & @@char@@ [ strlen ( @@char@@ ) + Number ] ; break ; } @@char@@ = & @@char@@ [ strlen ( @@char@@ ) + Number ] ; } if ( ! * @@constchar@@ ) @@constchar@@ = String ; return @@constchar@@ ; }
FILE * __fastcall freopen_safer ( const char * @@constchar@@ , const char * @@constchar@@ , FILE * @@FILE@@ ) { int @@int@@ ; FILE * @@FILE@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; int @@int@@ ; @@char@@ = Number ; @@char@@ = Number ; @@char@@ = Number ; @@int@@ = fileno ( @@FILE@@ ) ; if ( @@int@@ != Number ) { if ( @@int@@ != Number ) { if ( ! @@int@@ ) goto LABEL_10 ; if ( dup2 ( Number , Number ) != Number ) @@char@@ = Number ; } if ( dup2 ( Number , Number ) != Number ) @@char@@ = Number ; } if ( dup2 ( Number , Number ) ) @@char@@ = Number ; LABEL_10 : if ( @@char@@ && ( unsigned __int8 ) protect_fd ( Number ) != Number ) { @@FILE@@ = Number L ; } else if ( @@char@@ && ( unsigned __int8 ) protect_fd ( Number ) != Number ) { @@FILE@@ = Number L ; } else if ( @@char@@ && ( unsigned __int8 ) protect_fd ( Number ) != Number ) { @@FILE@@ = Number L ; } else { @@FILE@@ = freopen ( @@constchar@@ , @@constchar@@ , @@FILE@@ ) ; } @@int@@ = * __errno_location ( ) ; if ( @@char@@ ) close ( Number ) ; if ( @@char@@ ) close ( Number ) ; if ( @@char@@ ) close ( Number ) ; if ( ! @@FILE@@ ) * __errno_location ( ) = @@int@@ ; return @@FILE@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
__int64 __fastcall imaxtostr ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ + Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = Number ; if ( @@int64@@ >= Number ) { do { * ( _BYTE * ) -- @@int64@@ = ( char ) @@int64@@ % Number + Number ; @@int64@@ /= Number L ; } while ( @@int64@@ ) ; } else { do { * ( _BYTE * ) -- @@int64@@ = Number - ( char ) @@int64@@ % Number ; @@int64@@ /= Number L ; } while ( @@int64@@ ) ; * ( _BYTE * ) -- @@int64@@ = Number ; } return @@int64@@ ; }
__int64 __fastcall bkm_scale_0 ( unsigned __int64 * @@unsignedint64@@ , int @@int@@ ) { __int64 @@int64@@ ; if ( is_mul_ok ( @@int@@ , * @@unsignedint64@@ ) ) { * @@unsignedint64@@ *= @@int@@ ; @@int64@@ = Number L ; } else { * @@unsignedint64@@ = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall skip_read ( __int64 @@int64@@ , int @@int@@ ) { __int64 @@int64@@ ; unsigned __int8 @@unsignedint8@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; char * @@char@@ ; FILE * @@FILE@@ ; @@FILE@@ = * ( FILE * * ) @@int64@@ ; @@unsignedint8@@ = Number ; @@int@@ = getc_unlocked ( * ( FILE * * ) @@int64@@ ) ; if ( @@int@@ == Number ) { if ( * ( _BYTE * ) ( @@int64@@ + Number ) ) { @@int@@ = getc_unlocked ( @@FILE@@ ) ; if ( @@int@@ == Number ) @@int@@ = getc_unlocked ( @@FILE@@ ) ; } } * ( _BYTE * ) ( @@int64@@ + Number ) = Number ; if ( @@int@@ == Number ) @@unsignedint8@@ = Number ; if ( last_line ) * ( _BYTE * ) ( @@int64@@ + Number ) = Number ; while ( @@int@@ != Number ) { if ( @@int@@ == Number ) { if ( last_line ) { if ( parallel_files != Number ) { @@char@@ = ( char * ) column_vector ; for ( @@int@@ = columns ; @@int@@ ; -- @@int@@ ) { @@char@@ [ Number ] = Number ; @@char@@ += Number ; } } else { * ( _BYTE * ) ( @@int64@@ + Number ) = Number ; } } @@int@@ = getc_unlocked ( @@FILE@@ ) ; if ( @@int@@ != Number ) ungetc ( @@int@@ , @@FILE@@ ) ; hold_file ( @@int64@@ ) ; break ; } if ( @@int@@ == Number ) { close_file ( @@int64@@ ) ; break ; } @@int@@ = getc_unlocked ( @@FILE@@ ) ; } @@int64@@ = ( unsigned __int8 ) skip_count ; if ( skip_count ) { @@int64@@ = ( unsigned __int8 ) parallel_files ^ Number ; if ( parallel_files != Number || @@int@@ == Number ) { @@int64@@ = @@unsignedint8@@ ^ Number ; if ( @@unsignedint8@@ != Number ) @@int64@@ = ( unsigned int ) ++ line_count ; } } return @@int64@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
__int64 __fastcall fts_set_stat_required ( __int64 @@int64@@ , char @@char@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; if ( * ( _WORD * ) ( @@int64@@ + Number ) != Number ) abort ( ) ; if ( @@char@@ ) @@int64@@ = Number L ; else @@int64@@ = Number L ; @@int64@@ = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; return @@int64@@ ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
__int64 __fastcall bkm_scale_by_power_0 ( unsigned __int64 * @@unsignedint64@@ , int @@int@@ , int @@int@@ ) { unsigned int @@unsignedint@@ ; for ( @@unsignedint@@ = Number ; @@int@@ -- ; @@unsignedint@@ |= bkm_scale_0 ( @@unsignedint64@@ , @@int@@ ) ) { ; } return @@unsignedint@@ ; }
__int64 __fastcall bkm_scale_by_power ( unsigned __int64 * @@unsignedint64@@ , int @@int@@ , int @@int@@ ) { unsigned int @@unsignedint@@ ; for ( @@unsignedint@@ = Number ; @@int@@ -- ; @@unsignedint@@ |= bkm_scale ( @@unsignedint64@@ , @@int@@ ) ) { ; } return @@unsignedint@@ ; }
unsigned __int64 __fastcall LCO_hash ( _QWORD * @@QWORD@@ , unsigned __int64 @@unsignedint64@@ ) { return * @@QWORD@@ % @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
bool __fastcall LCO_compare ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ ) { return * @@QWORD@@ == * @@QWORD@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
__int64 __fastcall set_cloexec_flag ( int @@int@@ , char @@char@@ , __int64 a3 , int @@int@@ , int @@int@@ , int @@int@@ ) { int @@int@@ ; int @@int@@ ; int @@int@@ ; unsigned int @@unsignedint@@ ; __int64 @@int64@@ ; int @@int@@ ; @@int@@ = rpl_fcntl ( @@int@@ , Number , Number , @@int@@ , @@int@@ , @@int@@ ) ; if ( @@int@@ < Number || ( ! @@char@@ ? ( @@unsignedint@@ = @@int@@ & Number ) : ( @@unsignedint@@ = @@int@@ | Number ) , @@int@@ != @@unsignedint@@ && ( unsigned int ) rpl_fcntl ( @@int@@ , Number , @@unsignedint@@ , @@int@@ , @@int@@ , @@int@@ ) == Number ) ) { @@int64@@ = Number ; } else { @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall fts_set ( __int64 a1 , __int64 @@int64@@ , int @@int@@ ) { __int64 @@int64@@ ; if ( ! @@int@@ || @@int@@ == Number || @@int@@ == Number || @@int@@ == Number || @@int@@ == Number ) { * ( _WORD * ) ( @@int64@@ + Number ) = @@int@@ ; @@int64@@ = Number L ; } else { * __errno_location ( ) = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 __fastcall open_file ( const char * @@constchar@@ , __int64 @@int64@@ ) { int * @@int@@ ; __int64 @@int64@@ ; if ( ! strcmp ( @@constchar@@ , String ) ) { * ( _QWORD * ) ( @@int64@@ + Number ) = gettext ( String ) ; * ( _QWORD * ) @@int64@@ = stdin ; have_read_stdin = Number ; } else { * ( _QWORD * ) ( @@int64@@ + Number ) = @@constchar@@ ; * ( _QWORD * ) @@int64@@ = fopen_safer ( @@constchar@@ , String ) ; } if ( * ( _QWORD * ) @@int64@@ ) { * ( _DWORD * ) ( @@int64@@ + Number ) = Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = Number ; ++ total_files ; @@int64@@ = Number L ; } else { failed_opens = Number ; if ( ignore_failed_opens != Number ) { @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , String , @@constchar@@ ) ; } @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
__int64 __fastcall c_tolower ( int @@int@@ ) { __int64 @@int64@@ ; if ( @@int@@ <= Number || @@int@@ > Number ) @@int64@@ = ( unsigned int ) @@int@@ ; else @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; return @@int64@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
__int64 __fastcall fts_padjust ( __int64 @@int64@@ , _QWORD * @@QWORD@@ ) { _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; for ( @@QWORD@@ = * ( _QWORD * * ) ( @@int64@@ + Number ) ; @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { if ( ( _QWORD * ) @@QWORD@@ [ Number ] != @@QWORD@@ + Number ) @@QWORD@@ [ Number ] = @@int64@@ + @@QWORD@@ [ Number ] - @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; } while ( Number ) { @@int64@@ = @@QWORD@@ [ Number ] ; if ( @@int64@@ < Number ) break ; if ( ( _QWORD * ) @@QWORD@@ [ Number ] != @@QWORD@@ + Number ) @@QWORD@@ [ Number ] = @@int64@@ + @@QWORD@@ [ Number ] - @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; if ( @@QWORD@@ [ Number ] ) @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; else @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; @@QWORD@@ = @@QWORD@@ ; } return @@int64@@ ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
__int64 reset_status ( ) { __int64 @@int64@@ ; int @@int@@ ; _DWORD * @@DWORD@@ ; @@int@@ = columns ; @@DWORD@@ = column_vector ; while ( @@int@@ ) { if ( @@DWORD@@ [ Number ] == Number ) { @@DWORD@@ [ Number ] = Number ; ++ files_ready_to_read ; } -- @@int@@ ; @@DWORD@@ += Number ; } @@int64@@ = ( unsigned __int8 ) storing_columns ; if ( storing_columns ) { @@int64@@ = * ( ( unsigned int * ) column_vector + Number ) ; files_ready_to_read = @@int64@@ != Number ; } return @@int64@@ ; }
unsigned __int64 __fastcall mmalloca ( unsigned __int64 @@unsignedint64@@ ) { char * @@char@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@unsignedint64@@ + Number < @@unsignedint64@@ ) return Number L ; @@char@@ = ( char * ) malloc ( @@unsignedint64@@ + Number ) ; if ( ! @@char@@ ) return Number L ; @@unsignedint64@@ = ( unsigned __int64 ) ( @@char@@ + Number ) ; * ( _DWORD * ) ( @@unsignedint64@@ - Number ) = Number ; * ( _QWORD * ) ( @@unsignedint64@@ - Number ) = mmalloca_results [ @@unsignedint64@@ % Number ] ; mmalloca_results [ @@unsignedint64@@ % Number ] = @@unsignedint64@@ ; return @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall hash_get_first ( unsigned __int64 * @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; if ( ! @@unsignedint64@@ [ Number ] ) return Number L ; for ( @@unsignedint64@@ = * @@unsignedint64@@ ; ; @@unsignedint64@@ += Number L ) { if ( @@unsignedint64@@ >= @@unsignedint64@@ [ Number ] ) abort ( ) ; if ( * ( _QWORD * ) @@unsignedint64@@ ) break ; } return * ( _QWORD * ) @@unsignedint64@@ ; }
__int64 __fastcall print_clump ( __int64 @@int64@@ , unsigned int @@unsignedint@@ , char * @@char@@ ) { char * @@char@@ ; __int64 @@int64@@ ; while ( Number ) { @@int64@@ = @@unsignedint@@ -- ; if ( ! ( _DWORD ) @@int64@@ ) break ; @@char@@ = @@char@@ ++ ; ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@int64@@ + Number ) ) ( ( unsigned int ) * @@char@@ ) ; } return @@int64@@ ; }
__int64 __fastcall xnrealloc ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { if ( ! is_mul_ok ( @@unsignedint64@@ , @@unsignedint64@@ ) ) xalloc_die ( ) ; return xrealloc ( @@int64@@ , @@unsignedint64@@ * @@unsignedint64@@ ) ; }
unsigned __int64 __fastcall hash_string ( _BYTE * @@BYTE@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = Number L ; while ( * @@BYTE@@ ) @@unsignedint64@@ = ( Number * @@unsignedint64@@ + ( unsigned __int8 ) * @@BYTE@@ ++ ) % @@unsignedint64@@ ; return @@unsignedint64@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ ) { return xmalloc ( @@int64@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_210228 ; @@int648@@ [ Number ] = qword_210230 ; @@int648@@ [ Number ] = qword_210238 ; @@int648@@ [ Number ] = qword_210240 ; @@int648@@ [ Number ] = qword_210248 ; @@int648@@ [ Number ] = qword_210250 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
size_t __fastcall mbslen ( const char * @@constchar@@ ) { __int64 @@int64@@ ; char @@char4@@ [ Number ] ; int @@int@@ ; char @@char@@ ; const char * @@constchar@@ ; __int64 @@int64@@ ; char @@char@@ ; int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( __ctype_get_mb_cur_max ( ) <= Number ) return strlen ( @@constchar@@ ) ; @@int64@@ = Number L ; @@constchar@@ = @@constchar@@ ; @@char4@@ [ Number ] = Number ; memset ( & @@int@@ , Number , Number ) ; for ( @@char@@ = Number ; ; @@char@@ = Number ) { mbuiter_multi_next_3 ( ( __int64 ) @@char4@@ ) ; if ( @@char@@ == Number && ! @@int@@ ) break ; ++ @@int64@@ ; @@constchar@@ += @@int64@@ ; } return @@int64@@ ; }
bool __fastcall skip_to_page ( unsigned __int64 @@unsignedint64@@ ) { char * @@char@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; _DWORD * @@DWORD@@ ; _DWORD * @@DWORD@@ ; _DWORD * @@DWORD@@ ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@unsignedint64@@ ; ++ @@unsignedint64@@ ) { for ( @@int@@ = Number ; @@int@@ < lines_per_body ; ++ @@int@@ ) { @@int@@ = Number ; @@DWORD@@ = column_vector ; while ( @@int@@ <= columns ) { if ( ! @@DWORD@@ [ Number ] ) skip_read ( ( __int64 ) @@DWORD@@ , @@int@@ ) ; ++ @@int@@ ; @@DWORD@@ += Number ; } } last_line = Number ; @@int@@ = Number ; @@DWORD@@ = column_vector ; while ( @@int@@ <= columns ) { if ( ! @@DWORD@@ [ Number ] ) skip_read ( ( __int64 ) @@DWORD@@ , @@int@@ ) ; ++ @@int@@ ; @@DWORD@@ += Number ; } if ( storing_columns ) { @@int@@ = Number ; @@DWORD@@ = column_vector ; while ( @@int@@ <= columns ) { if ( @@DWORD@@ [ Number ] != Number ) @@DWORD@@ [ Number ] = Number ; ++ @@int@@ ; @@DWORD@@ += Number ; } } reset_status ( ) ; last_line = Number ; if ( files_ready_to_read <= Number ) { @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ , @@unsignedint64@@ , @@unsignedint64@@ ) ; return files_ready_to_read > Number ; } } return files_ready_to_read > Number ; }
__int64 __fastcall next_prime ( unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = @@unsignedint64@@ ; if ( @@unsignedint64@@ <= Number ) @@int64@@ = Number L ; for ( @@int64@@ = @@int64@@ | Number ; @@int64@@ != Number && ! is_prime ( @@int64@@ ) ; @@int64@@ += Number L ) { ; } return @@int64@@ ; }
__int64 __fastcall nstrftime ( char * @@char@@ , __int64 @@int64@@ , char * @@char@@ , __int64 @@int64@@ , int @@int@@ , int @@int@@ ) { return strftime_case_ ( Number , @@char@@ , @@int64@@ , @@char@@ , @@int64@@ , @@int@@ , @@int@@ ) ; }
unsigned __int64 __fastcall xstrtol_error ( unsigned int @@unsignedint@@ , int @@int@@ , char @@char@@ , __int64 @@int64@@ , __int64 @@int64@@ , int @@int@@ ) { char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; char @@char2@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@char@@ = ( char * ) & unk_17688 ; if ( @@unsignedint@@ > Number ) { if ( @@unsignedint@@ != Number ) goto LABEL_6 ; @@char@@ = String ; } else if ( @@unsignedint@@ >= Number ) { @@char@@ = String ; } else { if ( @@unsignedint@@ != Number ) LABEL_6 : abort ( ) ; @@char@@ = String ; } if ( @@int@@ >= Number ) { @@char@@ = * ( char * * ) ( Number L * @@int@@ + @@int64@@ ) ; } else { @@char@@ = ( char * ) & unk_17688 - @@int@@ ; @@char2@@ [ Number ] = @@char@@ ; @@char2@@ [ Number ] = Number ; @@char@@ = @@char2@@ ; } @@char@@ = gettext ( @@char@@ ) ; error ( @@int@@ , Number , @@char@@ , @@char@@ , @@char@@ , @@int64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
unsigned __int8 * __fastcall find_int ( unsigned __int8 * @@unsignedint8@@ ) { const unsigned __int16 * @@constunsignedint16@@ ; unsigned __int8 * @@unsignedint8@@ ; const unsigned __int16 * @@constunsignedint16@@ ; __int64 @@int64@@ ; char * @@char@@ ; unsigned __int8 * @@unsignedint8@@ ; unsigned __int8 * @@unsignedint8@@ ; unsigned __int8 * @@unsignedint8@@ ; unsigned __int8 * @@unsignedint8@@ ; for ( @@unsignedint8@@ = @@unsignedint8@@ ; ; ++ @@unsignedint8@@ ) { @@constunsignedint16@@ = * __ctype_b_loc ( ) ; if ( ( @@constunsignedint16@@ [ ( unsigned __int8 ) to_uchar ( * @@unsignedint8@@ ) ] & Number ) == Number ) break ; } if ( * @@unsignedint8@@ == Number ) { @@unsignedint8@@ = @@unsignedint8@@ + Number ; @@unsignedint8@@ = @@unsignedint8@@ ; } else { @@unsignedint8@@ = @@unsignedint8@@ ; @@unsignedint8@@ = & @@unsignedint8@@ [ * @@unsignedint8@@ == Number ] ; } @@unsignedint8@@ = @@unsignedint8@@ ; @@unsignedint8@@ = @@unsignedint8@@ + Number ; if ( ( unsigned int ) ( ( char ) * @@unsignedint8@@ - Number ) > Number ) goto LABEL_16 ; while ( ( unsigned int ) ( ( char ) * @@unsignedint8@@ - Number ) <= Number ) ++ @@unsignedint8@@ ; while ( Number ) { @@constunsignedint16@@ = * __ctype_b_loc ( ) ; if ( ( @@constunsignedint16@@ [ ( unsigned __int8 ) to_uchar ( * @@unsignedint8@@ ) ] & Number ) == Number ) break ; ++ @@unsignedint8@@ ; } if ( * @@unsignedint8@@ ) { LABEL_16 : @@int64@@ = quote ( @@unsignedint8@@ ) ; @@char@@ = gettext ( String ) ; test_syntax_error ( @@char@@ , @@int64@@ ) ; } return @@unsignedint8@@ ; }
__int64 __fastcall get_stat_mtime ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@unsignedint64@@ , int @@int@@ ) { __int64 @@int64@@ ; if ( is_mul_ok ( @@int@@ , * @@unsignedint64@@ ) ) { * @@unsignedint64@@ *= @@int@@ ; @@int64@@ = Number L ; } else { * @@unsignedint64@@ = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
size_t * __fastcall hash_initialize ( __int64 @@int64@@ , void * @@void@@ , unsigned __int64 ( __fastcall * @ @ VAR_1191 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ) ( __int64 a1 , unsigned __int64 a2 ) , bool ( __fastcall * @ @ VAR_1193 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ) ( __int64 a1 , __int64 a2 ) , size_t @@sizet@@ ) { size_t * @@sizet@@ ; bool ( __fastcall * @ @ VAR_1192 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ) ( __int64 , __int64 ) ; unsigned __int64 ( __fastcall * @ @ VAR_1190 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ) ( __int64 , unsigned __int64 ) ; void * @@void@@ ; size_t * @@sizet@@ ; @@void@@ = @@void@@ ; @ @ VAR_1190 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher = @ @ VAR_1191 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ; @ @ VAR_1192 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator = @ @ VAR_1193 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ; if ( ! @ @ VAR_1191 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ) @ @ VAR_1190 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher = raw_hasher ; if ( ! @ @ VAR_1193 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ) @ @ VAR_1192 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator = raw_comparator ; @@sizet@@ = ( size_t * ) malloc ( Number ) ; if ( ! @@sizet@@ ) return Number L ; if ( ! @@void@@ ) @@void@@ = & default_tuning ; @@sizet@@ [ Number ] = ( size_t ) @@void@@ ; if ( ( unsigned __int8 ) check_tuning ( ( __int64 ) @@sizet@@ ) == Number && ( @@sizet@@ [ Number ] = compute_bucket_size ( @@int64@@ , ( __int64 ) @@void@@ ) ) != Number && ( * @@sizet@@ = ( size_t ) calloc ( @@sizet@@ [ Number ] , Number ) ) != Number ) { @@sizet@@ [ Number ] = Number * @@sizet@@ [ Number ] + * @@sizet@@ ; @@sizet@@ [ Number ] = Number L ; @@sizet@@ [ Number ] = Number L ; @@sizet@@ [ Number ] = ( size_t ) @ @ VAR_1190 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ; @@sizet@@ [ Number ] = ( size_t ) @ @ VAR_1192 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ; @@sizet@@ [ Number ] = @@sizet@@ ; @@sizet@@ [ Number ] = Number L ; @@sizet@@ = @@sizet@@ ; } else { free ( @@sizet@@ ) ; @@sizet@@ = Number L ; } return @@sizet@@ ; }
char * __fastcall str_iconv ( char * @@char@@ , char * @@char@@ , char * @@char@@ ) { char * @@char@@ ; int @@int@@ ; int @@int@@ ; iconv_t @@iconvt@@ ; void * @@void@@ ; char * @@char@@ ; if ( * @@char@@ && ( unsigned int ) c_strcasecmp ( ( unsigned __int8 * ) @@char@@ , ( unsigned __int8 * ) @@char@@ ) ) { @@iconvt@@ = iconv_open ( @@char@@ , @@char@@ ) ; if ( @@iconvt@@ == ( iconv_t ) Number ) return Number L ; @@void@@ = str_cd_iconv ( @@char@@ , @@iconvt@@ ) ; if ( @@void@@ ) { if ( iconv_close ( @@iconvt@@ ) < Number ) { @@int@@ = * __errno_location ( ) ; free ( @@void@@ ) ; * __errno_location ( ) = @@int@@ ; return Number L ; } } else { @@int@@ = * __errno_location ( ) ; iconv_close ( @@iconvt@@ ) ; * __errno_location ( ) = @@int@@ ; } @@char@@ = ( char * ) @@void@@ ; } else { @@char@@ = strdup ( @@char@@ ) ; if ( ! @@char@@ ) * __errno_location ( ) = Number ; @@char@@ = @@char@@ ; } return @@char@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 __fastcall hard_locale ( int @@int@@ ) { unsigned __int8 @@unsignedint8@@ ; const char * @@constchar@@ ; @@unsignedint8@@ = Number ; @@constchar@@ = setlocale ( @@int@@ , Number L ) ; if ( @@constchar@@ && ( ! strcmp ( @@constchar@@ , String ) || ! strcmp ( @@constchar@@ , String ) ) ) { @@unsignedint8@@ = Number ; } return @@unsignedint8@@ ; }
bool __fastcall mktime_ok ( _DWORD * @@DWORD@@ , struct tm * @@structtm@@ , time_t @@timet@@ ) { bool @@bool@@ ; time_t @@timet@@ ; struct tm * @@structtm@@ ; _DWORD * @@DWORD@@ ; @@DWORD@@ = @@DWORD@@ ; @@structtm@@ = @@structtm@@ ; @@timet@@ = @@timet@@ ; if ( @@timet@@ != Number || ( @@structtm@@ = localtime ( & @@timet@@ ) ) != Number L ) @@bool@@ = ( @@DWORD@@ [ Number ] ^ @@structtm@@ -> tm_mon | @@DWORD@@ [ Number ] ^ @@structtm@@ -> tm_mday | @@DWORD@@ [ Number ] ^ @@structtm@@ -> tm_hour | @@DWORD@@ [ Number ] ^ @@structtm@@ -> tm_min | @@structtm@@ -> tm_sec ^ * @@DWORD@@ | @@DWORD@@ [ Number ] ^ @@structtm@@ -> tm_year ) == Number ; else @@bool@@ = Number ; return @@bool@@ ; }
__int64 default_block_size ( ) { __int64 @@int64@@ ; if ( getenv ( String ) ) @@int64@@ = Number L ; else @@int64@@ = Number L ; return @@int64@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
__int64 __fastcall rpl_fcntl ( int @@int@@ , int @@int@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ ) { int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; if ( @@int@@ != Number ) return ( unsigned int ) fcntl ( @@int@@ , @@int@@ , @@int64@@ ) ; @@int@@ = @@int64@@ ; if ( have_dupfd_cloexec_2895 < Number ) { @@int@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@int@@ , Number , @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ ) ; } else { @@int@@ = fcntl ( @@int@@ , Number , ( unsigned int ) @@int64@@ ) ; if ( @@int@@ < Number && * __errno_location ( ) == Number ) { @@int@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@int@@ , Number , @@int@@ , @@int@@ , @@int@@ , @@int@@ ) ; if ( @@int@@ < Number ) return ( unsigned int ) @@int@@ ; have_dupfd_cloexec_2895 = Number ; } else { have_dupfd_cloexec_2895 = Number ; } } if ( @@int@@ >= Number && have_dupfd_cloexec_2895 == Number ) { @@int@@ = fcntl ( @@int@@ , Number ) ; if ( @@int@@ < Number || fcntl ( @@int@@ , Number , @@int@@ | Number ) == Number ) { @@int@@ = * __errno_location ( ) ; close ( @@int@@ ) ; * __errno_location ( ) = @@int@@ ; @@int@@ = Number ; } } return ( unsigned int ) @@int@@ ; }
__int64 __fastcall human_options ( char * @@char@@ , int * @@int@@ , _QWORD * @@QWORD@@ ) { unsigned int @@unsignedint@@ ; @@unsignedint@@ = humblock ( @@char@@ , @@QWORD@@ , @@int@@ ) ; if ( ! * @@QWORD@@ ) { * @@QWORD@@ = default_block_size ( ) ; @@unsignedint@@ = Number ; } return @@unsignedint@@ ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
void __fastcall argmatch_invalid ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { char * @@char@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; char * @@char@@ ; if ( @@int64@@ == Number ) @@char@@ = gettext ( String ) ; else @@char@@ = gettext ( String ) ; @@char@@ = @@char@@ ; @@int64@@ = quote_n ( Number L , @@int64@@ ) ; @@int64@@ = quotearg_n_style ( Number L , Number L , @@int64@@ ) ; error ( Number , Number , @@char@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall i_ring_empty ( __int64 @@int64@@ ) { return * ( unsigned __int8 * ) ( @@int64@@ + Number ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
__int64 __fastcall _xargmatch_internal ( __int64 @@int64@@ , const char * @@constchar@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ , void ( * @ @ VAR_607 @ @ void ( ) ( void ) @ @ argmatchexitfn ) ( void ) ) { __int64 @@int64@@ ; @@int64@@ = argmatch ( @@constchar@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; if ( @@int64@@ >= Number ) return @@int64@@ ; argmatch_invalid ( @@int64@@ , ( __int64 ) @@constchar@@ , @@int64@@ ) ; argmatch_valid ( @@int64@@ , @@int64@@ , @@sizet@@ ) ; @ @ VAR_607 @ @ void ( ) ( void ) @ @ argmatchexitfn ( ) ; return Number ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 __fastcall i_ring_push ( __int64 @@int64@@ , int @@int@@ ) { int @@int@@ ; unsigned int @@unsignedint@@ ; @@int@@ = ( ( unsigned __int8 ) * ( _DWORD * ) ( @@int64@@ + Number ) + ( * ( _BYTE * ) ( @@int64@@ + Number ) ^ Number ) ) & Number ; @@unsignedint@@ = * ( _DWORD * ) ( @@int64@@ + Number L * ( ( ( unsigned __int8 ) * ( _DWORD * ) ( @@int64@@ + Number ) + ( * ( _BYTE * ) ( @@int64@@ + Number ) ^ Number ) ) & Number ) ) ; * ( _DWORD * ) ( @@int64@@ + Number L * ( ( ( unsigned __int8 ) * ( _DWORD * ) ( @@int64@@ + Number ) + ( * ( _BYTE * ) ( @@int64@@ + Number ) ^ Number ) ) & Number ) ) = @@int@@ ; * ( _DWORD * ) ( @@int64@@ + Number ) = @@int@@ ; if ( @@int@@ == * ( _DWORD * ) ( @@int64@@ + Number ) ) * ( _DWORD * ) ( @@int64@@ + Number ) = ( ( unsigned __int8 ) * ( _DWORD * ) ( @@int64@@ + Number ) + ( * ( _BYTE * ) ( @@int64@@ + Number ) ^ Number ) ) & Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = Number ; return @@unsignedint@@ ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall year ( __int64 @@int64@@ , _DWORD * @@DWORD@@ , __int64 @@int64@@ , char @@char@@ ) { time_t @@timet@@ ; struct tm * @@structtm@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( @@int64@@ == Number ) { * ( _DWORD * ) ( @@int64@@ + Number ) = * @@DWORD@@ ; if ( ( int ) * @@DWORD@@ <= Number ) { if ( ( @@char@@ & Number ) != Number ) return Number L ; * ( _DWORD * ) ( @@int64@@ + Number ) += Number ; } } else if ( @@int64@@ ) { if ( @@int64@@ != Number ) abort ( ) ; if ( ( @@char@@ & Number ) == Number ) return Number L ; * ( _DWORD * ) ( @@int64@@ + Number ) = Number * * @@DWORD@@ + @@DWORD@@ [ Number ] - Number ; } else { time ( & @@timet@@ ) ; @@structtm@@ = localtime ( & @@timet@@ ) ; if ( ! @@structtm@@ ) return Number L ; * ( _DWORD * ) ( @@int64@@ + Number ) = @@structtm@@ -> tm_year ; } return Number L ; }
__int64 __fastcall memcpy_uppcase ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { while ( @@int64@@ -- ) * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) = toupper ( * ( unsigned __int8 * ) ( @@int64@@ + @@int64@@ ) ) ; return @@int64@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall openat_safer ( int @@int@@ , const char * @@constchar@@ , char @@char@@ , unsigned int @@unsignedint@@ ) { unsigned int @@unsignedint@@ ; unsigned int @@unsignedint@@ ; @@unsignedint@@ = Number ; if ( ( @@char@@ & Number ) != Number ) @@unsignedint@@ = @@unsignedint@@ ; @@unsignedint@@ = openat ( @@int@@ , @@constchar@@ , @@char@@ , @@unsignedint@@ ) ; return fd_safer ( @@unsignedint@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall umaxtostr ( unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = @@int64@@ + Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = Number ; do { * ( _BYTE * ) -- @@int64@@ = @@unsignedint64@@ % Number + Number ; @@unsignedint64@@ /= Number ; } while ( @@unsignedint64@@ ) ; return @@int64@@ ; }
__int64 __fastcall get_stat_atime ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
const char * * __fastcall lookup_zone ( __int64 @@int64@@ , const char * @@constchar@@ ) { const char * * @@constchar@@ ; const char * * @@constchar@@ ; const char * * @@constchar@@ ; for ( @@constchar@@ = ( const char * * ) & universal_time_zone_table ; * @@constchar@@ ; @@constchar@@ += Number ) { if ( ! strcmp ( @@constchar@@ , * @@constchar@@ ) ) return @@constchar@@ ; } for ( @@constchar@@ = ( const char * * ) ( @@int64@@ + Number ) ; * @@constchar@@ ; @@constchar@@ += Number ) { if ( ! strcmp ( @@constchar@@ , * @@constchar@@ ) ) return @@constchar@@ ; } for ( @@constchar@@ = ( const char * * ) & time_zone_table ; * @@constchar@@ ; @@constchar@@ += Number ) { if ( ! strcmp ( @@constchar@@ , * @@constchar@@ ) ) return @@constchar@@ ; } return Number L ; }
__int64 __fastcall get_stat_mtime_0 ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
unsigned __int64 __fastcall print_line ( int @@int@@ , __int64 @@int64@@ , char @@char@@ , int @@int@@ , __int64 @@int64@@ , __int64 @@int64@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 @@int64@@ , const char * @@constchar@@ ) { size_t @@sizet@@ ; const char * @@constchar@@ ; const char * @@constchar@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; char @@char@@ [ Number ] ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; byte_20F019 = @@char@@ ; if ( include_idle && short_output != Number && strlen ( @@constchar@@ ) <= Number ) sprintf ( @@char@@ , String , @@constchar@@ ) ; else @@char@@ [ Number ] = Number ; if ( short_output != Number && strlen ( @@constchar@@ ) <= Number ) sprintf ( @@char@@ , String , @@constchar@@ ) ; else @@char@@ [ Number ] = Number ; if ( include_exit ) { if ( strlen ( @@constchar@@ ) <= Number ) @@sizet@@ = Number L ; else @@sizet@@ = strlen ( @@constchar@@ ) + Number ; } else { @@sizet@@ = Number L ; } @@char@@ = ( char * ) xmalloc ( @@sizet@@ ) ; if ( include_exit ) sprintf ( @@char@@ , String , @@constchar@@ ) ; else * @@char@@ = Number ; if ( include_mesg ) @@constchar@@ = ( const char * ) & mesg_5665 ; else @@constchar@@ = & locale ; if ( @@int64@@ ) LODWORD ( @@constchar@@ ) = @@int64@@ ; else @@constchar@@ = String ; if ( ( unsigned int ) rpl_asprintf ( ( unsigned int ) & @@char@@ , ( unsigned int ) String , @@int@@ , ( _DWORD ) @@constchar@@ , ( _DWORD ) @@constchar@@ , @@int@@ , @@int64@@ , ( unsigned int ) time_format_width , @@int64@@ , @@char@@ , @@char@@ , @@int64@@ , @@char@@ ) == Number ) xalloc_die ( ) ; @@char@@ = @@char@@ ; @@char@@ = & @@char@@ [ strlen ( @@char@@ ) ] ; do -- @@char@@ ; while ( * @@char@@ == Number ) ; @@char@@ [ Number ] = Number ; puts ( @@char@@ ) ; free ( @@char@@ ) ; free ( @@char@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@unsignedint64@@ , int @@int@@ ) { __int64 @@int64@@ ; if ( is_mul_ok ( @@int@@ , * @@unsignedint64@@ ) ) { * @@unsignedint64@@ *= @@int@@ ; @@int64@@ = Number L ; } else { * @@unsignedint64@@ = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall hard_locale ( int @@int@@ ) { unsigned __int8 @@unsignedint8@@ ; const char * @@constchar@@ ; @@unsignedint8@@ = Number ; @@constchar@@ = setlocale ( @@int@@ , Number L ) ; if ( @@constchar@@ && ( ! strcmp ( @@constchar@@ , String ) || ! strcmp ( @@constchar@@ , String ) ) ) { @@unsignedint8@@ = Number ; } return @@unsignedint8@@ ; }
int __fastcall lutimens ( char * @@char@@ , __int64 * @@int64@@ ) { struct timespec * @@structtimespec@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; struct timespec * @@structtimespec@@ ; __syscall_slong_t @@syscallslongt@@ ; struct timespec * @@structtimespec@@ ; __syscall_slong_t @@syscallslongt@@ ; int @@int@@ ; int @@int@@ ; struct timespec * @@structtimespec@@ ; __int64 @@int64@@ [ Number ] ; struct stat @@structstat@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( @@int64@@ ) @@structtimespec@@ = ( struct timespec * ) @@int64@@ ; else @@structtimespec@@ = Number L ; @@structtimespec@@ = @@structtimespec@@ ; @@int@@ = Number ; if ( @@structtimespec@@ ) { @@int64@@ = @@int64@@ [ Number ] ; @@int64@@ [ Number ] = * @@int64@@ ; @@int64@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int64@@ [ Number ] ; @@int64@@ [ Number ] = @@int64@@ [ Number ] ; @@int64@@ [ Number ] = @@int64@@ ; @@int@@ = validate_timespec ( @@structtimespec@@ ) ; } if ( @@int@@ < Number ) return Number ; if ( lutimensat_works_really >= Number ) { if ( @@int@@ == Number ) { if ( ( unsigned int ) lstat ( @@char@@ , & @@structstat@@ ) ) return Number ; if ( @@structtimespec@@ -> tv_nsec == Number ) { @@structtimespec@@ = @@structtimespec@@ ; @@structtimespec@@ -> tv_sec = get_stat_atime_0 ( ( __int64 ) & @@structstat@@ ) ; @@structtimespec@@ -> tv_nsec = @@syscallslongt@@ ; } else if ( @@structtimespec@@ [ Number ] . tv_nsec == Number ) { @@structtimespec@@ = @@structtimespec@@ + Number ; @@structtimespec@@ [ Number ] . tv_sec = get_stat_mtime_0 ( ( __int64 ) & @@structstat@@ ) ; @@structtimespec@@ -> tv_nsec = @@syscallslongt@@ ; } @@int@@ = Number ; } @@int@@ = utimensat ( Number , @@char@@ , @@structtimespec@@ , Number ) ; if ( @@int@@ > Number ) * __errno_location ( ) = Number ; if ( ! @@int@@ || * __errno_location ( ) != Number ) { utimensat_works_really = Number ; lutimensat_works_really = Number ; return @@int@@ ; } } lutimensat_works_really = Number ; if ( ! @@int@@ ) goto LABEL_37 ; if ( @@int@@ != Number && ( unsigned int ) lstat ( @@char@@ , & @@structstat@@ ) ) return Number ; if ( @@structtimespec@@ && ( unsigned __int8 ) update_timespec ( ( __int64 ) & @@structstat@@ , & @@structtimespec@@ ) ) { return Number ; } LABEL_37 : if ( ! @@int@@ && ( unsigned int ) lstat ( @@char@@ , & @@structstat@@ ) ) return Number ; if ( ( @@structstat@@ . st_mode & Number ) != Number ) return fdutimens ( @@char@@ , Number , & @@structtimespec@@ -> tv_sec ) ; * __errno_location ( ) = Number ; return Number ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
_BOOL8 __fastcall cycle_warning_required ( __int64 @@int64@@ , __int64 @@int64@@ ) { return ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number && ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) == Number || ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number && ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number && * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return xmalloc ( @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall argmatch_to_argument ( const void * @@constvoid@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; ++ @@int64@@ ) { if ( ! memcmp ( @@constvoid@@ , ( const void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) , @@sizet@@ ) ) return * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; } return Number L ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_20C0A8 ; @@int648@@ [ Number ] = qword_20C0B0 ; @@int648@@ [ Number ] = qword_20C0B8 ; @@int648@@ [ Number ] = qword_20C0C0 ; @@int648@@ [ Number ] = qword_20C0C8 ; @@int648@@ [ Number ] = qword_20C0D0 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
__int64 __fastcall fraccompare ( _BYTE * @@BYTE@@ , _BYTE * @@BYTE@@ , char @@char@@ ) { _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; @@BYTE@@ = @@BYTE@@ ; @@BYTE@@ = @@BYTE@@ ; if ( @@char@@ == * @@BYTE@@ && @@char@@ == * @@BYTE@@ ) { while ( * ++ @@BYTE@@ == * ++ @@BYTE@@ ) { if ( ( unsigned int ) ( ( char ) * @@BYTE@@ - Number ) > Number ) return Number L ; } if ( ( unsigned int ) ( ( char ) * @@BYTE@@ - Number ) <= Number && ( unsigned int ) ( ( char ) * @@BYTE@@ - Number ) <= Number ) { return ( unsigned int ) ( ( char ) * @@BYTE@@ - ( char ) * @@BYTE@@ ) ; } if ( ( unsigned int ) ( ( char ) * @@BYTE@@ - Number ) > Number ) { if ( ( unsigned int ) ( ( char ) * @@BYTE@@ - Number ) > Number ) return Number L ; LABEL_23 : while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; return ( unsigned int ) - ( ( unsigned int ) ( ( char ) * @@BYTE@@ - Number ) <= Number ) ; } } else { @@BYTE@@ = @@BYTE@@ + Number ; if ( @@char@@ != * @@BYTE@@ ) { @@BYTE@@ = @@BYTE@@ + Number ; if ( @@char@@ != * @@BYTE@@ ) return Number L ; goto LABEL_23 ; } } while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; return ( unsigned int ) ( ( char ) * @@BYTE@@ - Number ) <= Number ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 __fastcall knuth_morris_pratt_unibyte ( _BYTE * @@BYTE@@ , char * @@char@@ , _QWORD * @@QWORD@@ ) { void * @@void@@ ; unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; char * @@char@@ ; _BYTE * @@BYTE@@ ; char @@char@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; size_t @@sizet@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@BYTE@@ = @@BYTE@@ ; @@char@@ = @@char@@ ; @@QWORD@@ = @@QWORD@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@sizet@@ = strlen ( @@char@@ ) ; if ( @@sizet@@ > Number ) { @@unsignedint64@@ = Number L ; } else if ( Number * @@sizet@@ > Number ) { @@unsignedint64@@ = mmalloca ( Number * @@sizet@@ ) ; } else { @@void@@ = alloca ( Number * ( ( Number * ( @@sizet@@ + Number ) + Number ) / Number ) ) ; @@unsignedint64@@ = Number * ( ( ( unsigned __int64 ) & @@QWORD@@ + Number ) >> Number ) + Number ; } @@unsignedint64@@ = @@unsignedint64@@ ; if ( ! @@unsignedint64@@ ) return Number L ; * ( _QWORD * ) ( @@unsignedint64@@ + Number ) = Number L ; @@int64@@ = Number L ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@sizet@@ ; ++ @@unsignedint64@@ ) { @@char@@ = @@char@@ [ @@unsignedint64@@ - Number ] ; while ( Number ) { if ( @@char@@ == @@char@@ [ @@int64@@ ] ) { ++ @@int64@@ ; * ( _QWORD * ) ( @@unsignedint64@@ + Number * @@unsignedint64@@ ) = @@unsignedint64@@ - @@int64@@ ; goto LABEL_15 ; } if ( ! @@int64@@ ) break ; @@int64@@ -= * ( _QWORD * ) ( Number * @@int64@@ + @@unsignedint64@@ ) ; } * ( _QWORD * ) ( @@unsignedint64@@ + Number * @@unsignedint64@@ ) = @@unsignedint64@@ ; LABEL_15 : ; } * @@QWORD@@ = Number L ; @@int64@@ = Number L ; @@BYTE@@ = @@BYTE@@ ; @@BYTE@@ = @@BYTE@@ ; while ( * @@BYTE@@ ) { if ( @@char@@ [ @@int64@@ ] == * @@BYTE@@ ) { ++ @@int64@@ ; ++ @@BYTE@@ ; if ( @@int64@@ == @@sizet@@ ) { * @@QWORD@@ = @@BYTE@@ ; break ; } } else if ( @@int64@@ ) { @@BYTE@@ += * ( _QWORD * ) ( Number * @@int64@@ + @@unsignedint64@@ ) ; @@int64@@ -= * ( _QWORD * ) ( Number * @@int64@@ + @@unsignedint64@@ ) ; } else { ++ @@BYTE@@ ; ++ @@BYTE@@ ; } } freea ( @@unsignedint64@@ ) ; return Number L ; }
unsigned __int64 __fastcall xmax ( unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint64@@ ; if ( @@unsignedint64@@ >= @@unsignedint64@@ ) @@unsignedint64@@ = @@unsignedint64@@ ; return @@unsignedint64@@ ; }
unsigned __int64 __fastcall print_clockchange ( __int64 @@int64@@ ) { char * @@char@@ ; char * @@char@@ ; @@char@@ = time_string ( @@int64@@ ) ; @@char@@ = gettext ( String ) ; return print_line ( Number , ( __int64 ) & locale , Number , Number , ( __int64 ) @@char@@ , ( __int64 ) @@char@@ , & locale , & locale , ( __int64 ) & locale , & locale ) ; }
bool __fastcall is_basic_4 ( unsigned __int8 @@unsignedint8@@ ) { return ( ( is_basic_table [ @@unsignedint8@@ >> Number ] >> ( @@unsignedint8@@ & Number ) ) & Number ) != Number ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_210038 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
unsigned __int64 __fastcall rpl_vasprintf ( void * * @@void@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; void * @@void@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@void@@ = ( void * ) vasnprintf ( Number L , & @@unsignedint64@@ , @@int64@@ , @@int64@@ ) ; if ( ! @@void@@ ) return Number ; if ( @@unsignedint64@@ <= Number ) { * @@void@@ = @@void@@ ; @@unsignedint64@@ = @@unsignedint64@@ ; } else { free ( @@void@@ ) ; * __errno_location ( ) = Number ; @@unsignedint64@@ = Number ; } return @@unsignedint64@@ ; }
__int64 __fastcall xsum_0 ( unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; if ( @@unsignedint64@@ + @@int64@@ < @@unsignedint64@@ ) @@int64@@ = Number ; else @@int64@@ = @@unsignedint64@@ + @@int64@@ ; return @@int64@@ ; }
__int64 __fastcall c_tolower ( int @@int@@ ) { __int64 @@int64@@ ; if ( @@int@@ <= Number || @@int@@ > Number ) @@int64@@ = ( unsigned int ) @@int@@ ; else @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; return @@int64@@ ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
unsigned __int64 __fastcall xmax ( unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint64@@ ; if ( @@unsignedint64@@ >= @@unsignedint64@@ ) @@unsignedint64@@ = @@unsignedint64@@ ; return @@unsignedint64@@ ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall c_toupper ( int @@int@@ ) { __int64 @@int64@@ ; if ( @@int@@ <= Number || @@int@@ > Number ) @@int64@@ = ( unsigned int ) @@int@@ ; else @@int64@@ = ( unsigned int ) ( @@int@@ - Number ) ; return @@int64@@ ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
_BOOL8 __fastcall rpl_isnanl ( __int64 a1 , __int64 a2 , __int64 a3 , __int64 a4 , __int64 a5 , __int64 a6 , __int128 @@int128@@ ) { if ( ( WORD4 ( @@int128@@ ) & Number ) == Number ) return DWORD1 ( @@int128@@ ) >> Number ; if ( ( WORD4 ( @@int128@@ ) & Number ) == Number ) return ( DWORD1 ( @@int128@@ ) ^ Number | ( unsigned int ) @@int128@@ ) != Number ; return ( DWORD1 ( @@int128@@ ) & Number ) == Number ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
__int64 __fastcall no_leading_hyphen ( char * @@char@@ ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; for ( @@char@@ = @@char@@ ; ; @@char@@ = @@char@@ + Number ) { @@char@@ = strchr ( @@char@@ , Number ) ; if ( ! @@char@@ ) break ; if ( @@char@@ == @@char@@ || * ( @@char@@ - Number ) == Number ) { @@int64@@ = quote ( @@char@@ ) ; @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ , @@int64@@ ) ; return Number L ; } } return Number L ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_207028 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_20C028 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_20A0A8 ; @@int648@@ [ Number ] = qword_20A0B0 ; @@int648@@ [ Number ] = qword_20A0B8 ; @@int648@@ [ Number ] = qword_20A0C0 ; @@int648@@ [ Number ] = qword_20A0C8 ; @@int648@@ [ Number ] = qword_20A0D0 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
char * __fastcall time_string ( __int64 @@int64@@ ) { time_t @@timet@@ ; struct tm * @@structtm@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@timet@@ = * ( int * ) ( @@int64@@ + Number ) ; @@structtm@@ = localtime ( & @@timet@@ ) ; if ( ! @@structtm@@ ) return ( char * ) timetostr ( @@timet@@ , ( __int64 ) buf_5650 ) ; strftime ( buf_5650 , Number , time_format , @@structtm@@ ) ; return buf_5650 ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
unsigned __int64 __fastcall print_boottime ( __int64 @@int64@@ ) { char * @@char@@ ; char * @@char@@ ; @@char@@ = time_string ( @@int64@@ ) ; @@char@@ = gettext ( String ) ; return print_line ( Number , ( __int64 ) & locale , Number , Number , ( __int64 ) @@char@@ , ( __int64 ) @@char@@ , & locale , & locale , ( __int64 ) & locale , & locale ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return xmalloc ( @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return xmalloc ( @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall bad_cast ( __int64 @@int64@@ ) { return @@int64@@ ; }
int __fastcall list_entries_who ( __int64 @@int64@@ , __int64 @@int64@@ ) { char * @@char@@ ; __int64 @@int64@@ ; const char * @@constchar@@ ; char * @@char@@ ; @@int64@@ = Number L ; @@constchar@@ = & locale ; while ( @@int64@@ -- ) { if ( * ( _BYTE * ) ( @@int64@@ + Number ) && * ( _WORD * ) @@int64@@ == Number ) { @@char@@ = ( char * ) extract_trimmed_name ( @@int64@@ ) ; printf ( String , @@constchar@@ , @@char@@ ) ; free ( @@char@@ ) ; @@constchar@@ = String ; ++ @@int64@@ ; } @@int64@@ += Number L ; } @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_20F1A8 ; @@int648@@ [ Number ] = qword_20F1B0 ; @@int648@@ [ Number ] = qword_20F1B8 ; @@int648@@ [ Number ] = qword_20F1C0 ; @@int648@@ [ Number ] = qword_20F1C8 ; @@int648@@ [ Number ] = qword_20F1D0 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
__int64 __fastcall xstrtod ( _BYTE * @@BYTE@@ , _QWORD * @@QWORD@@ , double * @@double@@ , double ( __fastcall * @ @ VAR_346 @ @ double ( fastcall ) ( BYTE , BYTE ) @ @ double ( ) ( constchar , char ) ) ( _BYTE * , _BYTE * * ) ) { unsigned __int8 @@unsignedint8@@ ; _BYTE * @@BYTE@@ ; double @@double@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@unsignedint8@@ = Number ; * __errno_location ( ) = Number ; @@double@@ = @ @ VAR_346 @ @ double ( fastcall ) ( BYTE , BYTE ) @ @ double ( ) ( constchar , char ) ( @@BYTE@@ , & @@BYTE@@ ) ; if ( @@BYTE@@ == @@BYTE@@ || ! @@QWORD@@ && * @@BYTE@@ ) { @@unsignedint8@@ = Number ; } else if ( @@double@@ != Number && * __errno_location ( ) == Number ) { @@unsignedint8@@ = Number ; } if ( @@QWORD@@ ) * @@QWORD@@ = @@BYTE@@ ; * @@double@@ = @@double@@ ; return @@unsignedint8@@ ; }
__int64 __fastcall randint_get_source ( __int64 @@int64@@ ) { return * ( _QWORD * ) @@int64@@ ; }
__int64 __fastcall mkdtemp_len ( __int64 @@int64@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , char @@char@@ ) { __int64 @@int64@@ ; if ( @@char@@ ) @@int64@@ = Number L ; else @@int64@@ = Number L ; return gen_tempname_len ( @@int64@@ , @@unsignedint@@ , Number L , @@int64@@ , @@int64@@ ) ; }
__int64 cols_ready_to_print ( ) { int @@int@@ ; unsigned int @@unsignedint@@ ; _DWORD * @@DWORD@@ ; @@unsignedint@@ = Number ; @@DWORD@@ = column_vector ; for ( @@int@@ = Number ; @@int@@ < columns ; ++ @@int@@ ) { if ( ! @@DWORD@@ [ Number ] || @@DWORD@@ [ Number ] == Number || storing_columns && ( int ) @@DWORD@@ [ Number ] > Number && ( int ) @@DWORD@@ [ Number ] > Number ) { ++ @@unsignedint@@ ; } @@DWORD@@ += Number ; } return @@unsignedint@@ ; }
__int64 __fastcall xnrealloc ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { if ( ! is_mul_ok ( @@unsignedint64@@ , @@unsignedint64@@ ) ) xalloc_die ( ) ; return xrealloc ( @@int64@@ , @@unsignedint64@@ * @@unsignedint64@@ ) ; }
__int64 __fastcall shift_left ( __int64 @@int64@@ ) { return @@int64@@ << Number ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ ) { return xmalloc ( @@int64@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
unsigned __int64 __fastcall randint_genmax ( __int64 * @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = * @@int64@@ ; @@unsignedint64@@ = @@int64@@ [ Number ] ; @@unsignedint64@@ = @@int64@@ [ Number ] ; @@unsignedint64@@ = @@unsignedint64@@ + Number ; while ( Number ) { if ( @@unsignedint64@@ < @@unsignedint64@@ ) { @@int64@@ = Number L ; @@unsignedint64@@ = @@unsignedint64@@ ; do { @@unsignedint64@@ = shift_left ( @@unsignedint64@@ ) + Number ; ++ @@int64@@ ; } while ( @@unsignedint64@@ < @@unsignedint64@@ ) ; randread ( @@int64@@ , @@char@@ , @@int64@@ ) ; @@int64@@ = Number L ; do { @@unsignedint64@@ = shift_left ( @@unsignedint64@@ ) + ( unsigned __int8 ) @@char@@ [ @@int64@@ ] ; @@unsignedint64@@ = shift_left ( @@unsignedint64@@ ) + Number ; ++ @@int64@@ ; } while ( @@unsignedint64@@ < @@unsignedint64@@ ) ; } if ( @@unsignedint64@@ == @@unsignedint64@@ ) { @@int64@@ [ Number ] = Number L ; @@int64@@ [ Number ] = @@int64@@ [ Number ] ; return @@unsignedint64@@ ; } @@unsignedint64@@ = ( @@unsignedint64@@ - @@unsignedint64@@ ) % @@unsignedint64@@ ; if ( @@unsignedint64@@ <= @@unsignedint64@@ - @@unsignedint64@@ ) break ; @@unsignedint64@@ %= @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint64@@ - Number ; } @@int64@@ [ Number ] = @@unsignedint64@@ / @@unsignedint64@@ ; @@int64@@ [ Number ] = ( @@unsignedint64@@ - @@unsignedint64@@ ) / @@unsignedint64@@ ; return @@unsignedint64@@ % @@unsignedint64@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
__int64 __fastcall xsum ( unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; if ( @@unsignedint64@@ + @@int64@@ < @@unsignedint64@@ ) @@int64@@ = Number ; else @@int64@@ = @@unsignedint64@@ + @@int64@@ ; return @@int64@@ ; }
__int64 __fastcall init_fps ( int @@int@@ , _QWORD * @@QWORD@@ ) { unsigned int @@unsignedint@@ ; _QWORD * @@QWORD@@ ; int @@int@@ ; int @@int@@ ; char * @@char@@ ; _QWORD * @@QWORD@@ ; char * @@char@@ ; __int64 @@int64@@ ; FILE * @@FILE@@ ; @@QWORD@@ = @@QWORD@@ ; total_files = Number ; free ( column_vector ) ; column_vector = ( void * ) xnmalloc ( columns , Number L ) ; if ( parallel_files ) { @@int@@ = @@int@@ ; for ( @@char@@ = ( char * ) column_vector ; @@int@@ -- ; @@char@@ += Number ) { if ( ( unsigned __int8 ) open_file ( * @@QWORD@@ , @@char@@ ) != Number ) { @@char@@ -= Number ; -- columns ; } ++ @@QWORD@@ ; } if ( ! columns ) return Number L ; init_header ( & locale , Number ) ; } else { @@QWORD@@ = column_vector ; if ( @@int@@ <= Number ) { @@QWORD@@ [ Number ] = gettext ( String ) ; * @@QWORD@@ = stdin ; have_read_stdin = Number ; * ( ( _DWORD * ) @@QWORD@@ + Number ) = Number ; * ( ( _BYTE * ) @@QWORD@@ + Number ) = Number ; ++ total_files ; init_header ( & locale , Number ) ; * ( ( _DWORD * ) @@QWORD@@ + Number ) = Number ; } else { if ( ( unsigned __int8 ) open_file ( * @@QWORD@@ , column_vector ) != Number ) return Number L ; @@unsignedint@@ = fileno ( ( FILE * ) * @@QWORD@@ ) ; init_header ( * @@QWORD@@ , @@unsignedint@@ ) ; * ( ( _DWORD * ) @@QWORD@@ + Number ) = Number ; } @@int64@@ = @@QWORD@@ [ Number ] ; @@FILE@@ = ( FILE * ) * @@QWORD@@ ; @@int@@ = columns - Number ; @@char@@ = ( char * ) ( @@QWORD@@ + Number ) ; while ( @@int@@ ) { * ( ( _QWORD * ) @@char@@ + Number ) = @@int64@@ ; * ( _QWORD * ) @@char@@ = @@FILE@@ ; * ( ( _DWORD * ) @@char@@ + Number ) = Number ; @@char@@ [ Number ] = Number ; * ( ( _DWORD * ) @@char@@ + Number ) = Number ; -- @@int@@ ; @@char@@ += Number ; } } files_ready_to_read = total_files ; return Number L ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
__int64 __fastcall xtime_make ( __int64 @@int64@@ , __int64 @@int64@@ ) { return Number * @@int64@@ + @@int64@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 decimal_point_char ( ) { __int64 @@int64@@ ; char * @@char@@ ; @@char@@ = nl_langinfo ( Number ) ; if ( * @@char@@ ) @@int64@@ = ( unsigned __int8 ) * @@char@@ ; else @@int64@@ = Number L ; return @@int64@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 gethrxtime ( ) { struct timespec @@structtimespec@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( clock_gettime ( Number , & @@structtimespec@@ ) ) gettime ( & @@structtimespec@@ ) ; return xtime_make ( @@structtimespec@@ . tv_sec , @@structtimespec@@ . tv_nsec ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
_BOOL8 __fastcall desirable_utmp_entry ( __int64 @@int64@@ , char @@char@@ ) { bool @@bool@@ ; @@bool@@ = * ( _BYTE * ) ( @@int64@@ + Number ) && * ( _WORD * ) @@int64@@ == Number ; if ( ( @@char@@ & Number ) != Number && ! @@bool@@ ) return Number L ; return ( @@char@@ & Number ) == Number || ! @@bool@@ || * ( int * ) ( @@int64@@ + Number ) > Number && ( kill ( * ( _DWORD * ) ( @@int64@@ + Number ) , Number ) >= Number || * __errno_location ( ) != Number ) ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
__int64 __fastcall add_line_number ( __int64 @@int64@@ ) { char * @@char@@ ; int @@int@@ ; __int64 @@int64@@ ; int @@int@@ ; int @@int@@ ; char * @@char@@ ; if ( line_number >= power_10 ) sprintf ( number_buff , String , chars_per_number , ( unsigned int ) ( line_number % power_10 ) ) ; else sprintf ( number_buff , String , chars_per_number , ( unsigned int ) line_number ) ; ++ line_number ; @@char@@ = number_buff ; for ( @@int@@ = chars_per_number ; @@int@@ > Number ; -- @@int@@ ) { @@char@@ = @@char@@ ++ ; ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@int64@@ + Number ) ) ( ( unsigned int ) * @@char@@ ) ; } if ( columns <= Number ) { ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@int64@@ + Number ) ) ( ( unsigned int ) number_separator ) ; if ( number_separator == Number ) output_position += chars_per_output_tab - output_position % chars_per_output_tab ; } else if ( number_separator == Number ) { @@int@@ = number_width - chars_per_number ; while ( Number ) { @@int@@ = @@int@@ -- ; if ( @@int@@ <= Number ) break ; ( * ( void ( __fastcall * * ) ( __int64 ) ) ( @@int64@@ + Number ) ) ( Number L ) ; } } else { ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@int64@@ + Number ) ) ( ( unsigned int ) number_separator ) ; } @@int64@@ = ( unsigned __int8 ) truncate_lines ; if ( truncate_lines ) { @@int64@@ = ( unsigned __int8 ) parallel_files ^ Number ; if ( parallel_files != Number ) { @@int64@@ = ( unsigned int ) ( input_position + number_width ) ; input_position += number_width ; } } return @@int64@@ ; }
__int64 __fastcall x2nrealloc ( __int64 @@int64@@ , unsigned __int64 * @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = * @@unsignedint64@@ ; if ( @@int64@@ ) { if ( @@unsignedint64@@ >= Number / @@unsignedint64@@ ) xalloc_die ( ) ; @@unsignedint64@@ += ( @@unsignedint64@@ + Number ) >> Number ; } else if ( ! @@unsignedint64@@ ) { @@unsignedint64@@ = ( Number / @@unsignedint64@@ == Number ) + Number / @@unsignedint64@@ ; } * @@unsignedint64@@ = @@unsignedint64@@ ; return xrealloc ( @@int64@@ , @@unsignedint64@@ * @@unsignedint64@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
__int64 __fastcall gnu_mbswidth ( const char * @@constchar@@ , unsigned int @@unsignedint@@ ) { size_t @@sizet@@ ; @@sizet@@ = strlen ( @@constchar@@ ) ; return mbsnwidth ( @@constchar@@ , @@sizet@@ , @@unsignedint@@ ) ; }
__int64 __fastcall xsum_0 ( unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; if ( @@unsignedint64@@ + @@int64@@ < @@unsignedint64@@ ) @@int64@@ = Number ; else @@int64@@ = @@unsignedint64@@ + @@int64@@ ; return @@int64@@ ; }
_BYTE * __fastcall filemodestring ( __int64 @@int64@@ , _BYTE * @@BYTE@@ ) { return strmode ( * ( _DWORD * ) ( @@int64@@ + Number ) , @@BYTE@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
unsigned __int64 __fastcall AD_hash ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) % @@unsignedint64@@ ; }
int __cdecl __noreturn main ( int @@int@@ , const char * * @@constchar@@ , const char * * @@constchar@@ ) { char * @@char@@ ; bool @@bool@@ ; unsigned __int8 @@unsignedint8@@ ; unsigned __int8 @@unsignedint8@@ ; int @@int@@ ; @@bool@@ = Number ; @@unsignedint8@@ = Number ; @@unsignedint8@@ = Number ; set_program_name ( * @@constchar@@ , @@constchar@@ , @@constchar@@ ) ; setlocale ( Number , & locale ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; while ( Number ) { while ( Number ) { @@int@@ = getopt_long ( @@int@@ , ( char * const * ) @@constchar@@ , String , & longopts , Number L ) ; if ( @@int@@ == Number ) { if ( @@int@@ == optind ) { @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ ) ; usage ( Number ) ; } while ( @@int@@ > optind ) { @@bool@@ = ( @@bool@@ & ( unsigned __int8 ) validate_file_name ( @@constchar@@ [ optind ] , @@unsignedint8@@ , @@unsignedint8@@ ) ) != Number ; ++ optind ; } exit ( ! @@bool@@ ) ; } if ( @@int@@ != Number ) break ; @@unsignedint8@@ = Number ; } if ( @@int@@ <= Number ) break ; if ( @@int@@ == Number ) { @@unsignedint8@@ = Number ; } else { if ( @@int@@ != Number ) goto LABEL_14 ; @@unsignedint8@@ = Number ; @@unsignedint8@@ = Number ; } } if ( @@int@@ == Number ) { version_etc ( ( _DWORD ) stdout , ( unsigned int ) String , ( unsigned int ) String , ( _DWORD ) Version , ( unsigned int ) String , ( unsigned int ) String , String , Number L ) ; exit ( Number ) ; } if ( @@int@@ == Number ) usage ( Number ) ; LABEL_14 : usage ( Number ) ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
__int64 __fastcall mbsnwidth ( char * @@char@@ , __int64 @@int64@@ , char @@char@@ ) { int @@int@@ ; char * @@char@@ ; unsigned __int8 @@unsignedint8@@ ; wchar_t @@wchart@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; char * @@char@@ ; size_t @@sizet@@ ; char * @@char@@ ; mbstate_t @@mbstatet2@@ [ Number ] ; @@mbstatet2@@ [ Number ] = ( mbstate_t ) __readfsqword ( Number ) ; @@char@@ = @@char@@ ; @@char@@ = & @@char@@ [ @@int64@@ ] ; @@unsignedint@@ = Number ; if ( __ctype_get_mb_cur_max ( ) > Number ) { while ( Number ) { LABEL_28 : if ( @@char@@ >= @@char@@ ) return @@unsignedint@@ ; @@int@@ = * @@char@@ ; if ( @@int@@ > Number ) { if ( @@int@@ < Number || @@int@@ > Number && ( unsigned int ) ( @@int@@ - Number ) > Number ) { LABEL_11 : memset ( @@mbstatet2@@ , Number , Number ) ; while ( Number ) { @@sizet@@ = mbrtowc ( & @@wchart@@ , @@char@@ , @@char@@ - @@char@@ , @@mbstatet2@@ ) ; if ( @@sizet@@ == Number ) { if ( ( @@char@@ & Number ) == Number ) { ++ @@char@@ ; ++ @@unsignedint@@ ; goto LABEL_28 ; } return Number ; } if ( @@sizet@@ == Number ) break ; if ( ! @@sizet@@ ) @@sizet@@ = Number L ; @@int@@ = wcwidth ( @@wchart@@ ) ; if ( @@int@@ < Number ) { if ( ( @@char@@ & Number ) != Number ) return Number ; @@unsignedint@@ += iswcntrl ( @@wchart@@ ) == Number ; } else { @@unsignedint@@ += @@int@@ ; } @@char@@ += @@sizet@@ ; if ( mbsinit ( @@mbstatet2@@ ) ) goto LABEL_28 ; } if ( ( @@char@@ & Number ) == Number ) { @@char@@ = @@char@@ ; ++ @@unsignedint@@ ; continue ; } return Number ; } } else if ( @@int@@ < Number && ( unsigned int ) ( @@int@@ - Number ) > Number ) { goto LABEL_11 ; } ++ @@char@@ ; ++ @@unsignedint@@ ; } } while ( @@char@@ < @@char@@ ) { @@char@@ = @@char@@ ++ ; @@unsignedint8@@ = * @@char@@ ; if ( ( ( * __ctype_b_loc ( ) ) [ @@unsignedint8@@ ] & Number ) != Number ) { ++ @@unsignedint@@ ; } else { if ( ( @@char@@ & Number ) != Number ) return Number ; @@unsignedint@@ += ( ( * __ctype_b_loc ( ) ) [ @@unsignedint8@@ ] & Number ) == Number ; } } return @@unsignedint@@ ; }
unsigned __int64 __fastcall leave_dir ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 * @@int64@@ ; __int64 * @@int64@@ ; void * @@void@@ ; __int64 @@int643@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = ( __int64 * ) ( @@int64@@ + Number ) ; if ( ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number ) { @@int643@@ [ Number ] = * @@int64@@ ; @@int643@@ [ Number ] = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@void@@ = ( void * ) hash_delete ( * ( _QWORD * ) ( @@int64@@ + Number ) , @@int643@@ ) ; if ( ! @@void@@ ) abort ( ) ; free ( @@void@@ ) ; } else { @@int64@@ = * ( __int64 * * ) ( @@int64@@ + Number ) ; if ( @@int64@@ && @@int64@@ [ Number ] >= Number ) { if ( ! * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) ) abort ( ) ; if ( * * ( _QWORD * * ) ( @@int64@@ + Number ) == * ( _QWORD * ) ( @@int64@@ + Number ) && * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) == * @@int64@@ ) { * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) = @@int64@@ [ Number ] ; * * ( _QWORD * * ) ( @@int64@@ + Number ) = @@int64@@ [ Number ] ; } } } return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_207028 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall gen_tempname_len ( char * @@char@@ , int @@int@@ , int @@int@@ , int @@int@@ , size_t @@sizet@@ ) { int @@int@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; __int64 @@int64@@ ; struct stat @@structstat@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int@@ = * __errno_location ( ) ; @@sizet@@ = strlen ( @@char@@ ) ; if ( @@sizet@@ < @@int@@ + @@sizet@@ || ! check_x_suffix ( & @@char@@ [ @@sizet@@ - @@sizet@@ - @@int@@ ] , @@sizet@@ ) ) { * __errno_location ( ) = Number ; return Number ; } @@int64@@ = randint_all_new ( Number L , Number L ) ; if ( ! @@int64@@ ) return Number ; for ( @@unsignedint@@ = Number ; ; ++ @@unsignedint@@ ) { if ( @@unsignedint@@ >= Number ) { randint_all_free ( @@int64@@ ) ; * __errno_location ( ) = Number ; return Number ; } for ( @@sizet@@ = Number L ; @@sizet@@ < @@sizet@@ ; ++ @@sizet@@ ) @@char@@ [ @@sizet@@ - @@sizet@@ - @@int@@ + @@sizet@@ ] = letters [ randint_genmax ( @@int64@@ , Number L ) ] ; if ( @@int@@ == Number ) { @@int@@ = mkdir ( @@char@@ , Number ) ; goto LABEL_20 ; } if ( @@int@@ == Number ) break ; if ( @@int@@ ) __assert_fail ( String , String , Number , String ) ; @@int@@ = @@int@@ ; LOBYTE ( @@int@@ ) = @@int@@ & Number | Number ; @@int@@ = open ( @@char@@ , @@int@@ , Number L ) ; LABEL_20 : if ( @@int@@ >= Number ) { * __errno_location ( ) = @@int@@ ; goto LABEL_27 ; } if ( * __errno_location ( ) != Number ) { @@int@@ = Number ; goto LABEL_27 ; } LABEL_24 : ; } if ( ( int ) lstat ( @@char@@ , & @@structstat@@ ) >= Number ) goto LABEL_24 ; if ( * __errno_location ( ) == Number ) { * __errno_location ( ) = @@int@@ ; @@int@@ = Number ; } else { @@int@@ = Number ; } LABEL_27 : @@int@@ = * __errno_location ( ) ; randint_all_free ( @@int64@@ ) ; * __errno_location ( ) = @@int@@ ; return ( unsigned int ) @@int@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall fts_set ( __int64 a1 , __int64 @@int64@@ , int @@int@@ ) { __int64 @@int64@@ ; if ( ! @@int@@ || @@int@@ == Number || @@int@@ == Number || @@int@@ == Number || @@int@@ == Number ) { * ( _WORD * ) ( @@int64@@ + Number ) = @@int@@ ; @@int64@@ = Number L ; } else { * __errno_location ( ) = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 __fastcall close_file ( __int64 @@int64@@ ) { __int64 @@int64@@ ; const char * @@constchar@@ ; int * @@int@@ ; const char * @@constchar@@ ; int * @@int@@ ; int @@int@@ ; _DWORD * @@DWORD@@ ; @@int64@@ = * ( unsigned int * ) ( @@int64@@ + Number ) ; if ( ( _DWORD ) @@int64@@ != Number ) { if ( ferror_unlocked ( * ( FILE * * ) @@int64@@ ) ) { @@constchar@@ = * ( const char * * ) ( @@int64@@ + Number ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , String , @@constchar@@ ) ; } if ( fileno ( * ( FILE * * ) @@int64@@ ) && fclose ( * ( FILE * * ) @@int64@@ ) ) { @@constchar@@ = * ( const char * * ) ( @@int64@@ + Number ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , String , @@constchar@@ ) ; } if ( parallel_files != Number ) { @@DWORD@@ = column_vector ; for ( @@int@@ = columns ; @@int@@ ; -- @@int@@ ) { @@DWORD@@ [ Number ] = Number ; if ( ! @@DWORD@@ [ Number ] ) @@DWORD@@ [ Number ] = Number ; @@DWORD@@ += Number ; } } else { * ( _DWORD * ) ( @@int64@@ + Number ) = Number ; * ( _DWORD * ) ( @@int64@@ + Number ) = Number ; } @@int64@@ = ( unsigned int ) -- files_ready_to_read ; } return @@int64@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall fts_compar ( __int64 @@int64@@ , __int64 @@int64@@ ) { return ( * ( __int64 ( __fastcall * * ) ( __int64 , __int64 ) ) ( * ( _QWORD * ) ( * ( _QWORD * ) @@int64@@ + Number L ) + Number L ) ) ( @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 __fastcall rpl_fcntl ( int @@int@@ , int @@int@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ ) { int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; if ( @@int@@ != Number ) return ( unsigned int ) fcntl ( @@int@@ , @@int@@ , @@int64@@ ) ; @@int@@ = @@int64@@ ; if ( have_dupfd_cloexec_2895 < Number ) { @@int@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@int@@ , Number , @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ ) ; } else { @@int@@ = fcntl ( @@int@@ , Number , ( unsigned int ) @@int64@@ ) ; if ( @@int@@ < Number && * __errno_location ( ) == Number ) { @@int@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@int@@ , Number , @@int@@ , @@int@@ , @@int@@ , @@int@@ ) ; if ( @@int@@ < Number ) return ( unsigned int ) @@int@@ ; have_dupfd_cloexec_2895 = Number ; } else { have_dupfd_cloexec_2895 = Number ; } } if ( @@int@@ >= Number && have_dupfd_cloexec_2895 == Number ) { @@int@@ = fcntl ( @@int@@ , Number ) ; if ( @@int@@ < Number || fcntl ( @@int@@ , Number , @@int@@ | Number ) == Number ) { @@int@@ = * __errno_location ( ) ; close ( @@int@@ ) ; * __errno_location ( ) = @@int@@ ; @@int@@ = Number ; } } return ( unsigned int ) @@int@@ ; }
__int64 store_columns ( ) { unsigned int @@unsignedint@@ ; __int64 @@int64@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; int @@int@@ ; _DWORD * @@DWORD@@ ; _DWORD * @@DWORD@@ ; @@unsignedint@@ = Number ; buff_current = Number ; @@int@@ = Number ; if ( balance_columns ) @@int@@ = columns ; else @@int@@ = columns - Number ; @@int@@ = Number ; @@DWORD@@ = column_vector ; while ( @@int@@ <= @@int@@ ) { @@DWORD@@ [ Number ] = Number ; ++ @@int@@ ; @@DWORD@@ += Number ; } @@int@@ = Number ; @@DWORD@@ = column_vector ; while ( @@int@@ <= @@int@@ && files_ready_to_read ) { @@DWORD@@ [ Number ] = @@unsignedint@@ ; for ( @@int@@ = lines_per_body ; @@int@@ && files_ready_to_read ; -- @@int@@ ) { if ( ! @@DWORD@@ [ Number ] ) { input_position = Number ; if ( ( unsigned __int8 ) read_line ( @@DWORD@@ ) != Number ) read_rest_of_line ( @@DWORD@@ ) ; if ( ! @@DWORD@@ [ Number ] || @@int@@ != buff_current ) { ++ @@DWORD@@ [ Number ] ; * ( ( _DWORD * ) line_vector + @@unsignedint@@ ) = @@int@@ ; @@unsignedint@@ = @@unsignedint@@ ++ ; * ( ( _DWORD * ) end_vector + @@unsignedint@@ ) = input_position ; @@int@@ = buff_current ; } } } ++ @@int@@ ; @@DWORD@@ += Number ; } * ( ( _DWORD * ) line_vector + @@unsignedint@@ ) = @@int@@ ; @@int64@@ = ( unsigned __int8 ) balance_columns ; if ( balance_columns ) @@int64@@ = balance ( @@unsignedint@@ ) ; return @@int64@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall get_stat_mtime ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 __fastcall fts_sort ( __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { size_t @@sizet@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; int ( * @ @ VAR_577 @ @ int ( ) ( constvoid , constvoid ) @ @ int ( ) ( constvoid , constvoid ) ) ( const void * , const void * ) ; void * @@void@@ ; @@sizet@@ = @@sizet@@ ; @ @ VAR_577 @ @ int ( ) ( constvoid , constvoid ) @ @ int ( ) ( constvoid , constvoid ) = * ( int ( * * ) ( const void * , const void * ) ) ( @@int64@@ + Number ) ; if ( @@sizet@@ > * ( _QWORD * ) ( @@int64@@ + Number ) ) { * ( _QWORD * ) ( @@int64@@ + Number ) = @@sizet@@ + Number ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) > Number || ( @@void@@ = realloc ( * ( void * * ) ( @@int64@@ + Number ) , Number L * * ( _QWORD * ) ( @@int64@@ + Number ) ) ) == Number L ) { free ( * ( void * * ) ( @@int64@@ + Number ) ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number L ; return @@int64@@ ; } * ( _QWORD * ) ( @@int64@@ + Number ) = @@void@@ ; } @@QWORD@@ = * ( _QWORD * * ) ( @@int64@@ + Number ) ; for ( @@int64@@ = @@int64@@ ; @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ) { @@QWORD@@ = @@QWORD@@ ++ ; * @@QWORD@@ = @@int64@@ ; } qsort ( * ( void * * ) ( @@int64@@ + Number ) , @@sizet@@ , Number , @ @ VAR_577 @ @ int ( ) ( constvoid , constvoid ) @ @ int ( ) ( constvoid , constvoid ) ) ; @@QWORD@@ = * ( _QWORD * * ) ( @@int64@@ + Number ) ; @@int64@@ = * @@QWORD@@ ; while ( -- @@sizet@@ ) { * ( _QWORD * ) ( * @@QWORD@@ + Number L ) = @@QWORD@@ [ Number ] ; ++ @@QWORD@@ ; } * ( _QWORD * ) ( * @@QWORD@@ + Number L ) = Number L ; return @@int64@@ ; }
__int64 __fastcall enter_dir ( __int64 @@int64@@ , __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; if ( ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number ) { @@QWORD@@ = malloc ( Number ) ; if ( ! @@QWORD@@ ) return Number L ; * @@QWORD@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ [ Number ] = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = hash_insert ( * ( _QWORD * ) ( @@int64@@ + Number ) , @@QWORD@@ ) ; if ( ( _QWORD * ) @@int64@@ != @@QWORD@@ ) { free ( @@QWORD@@ ) ; if ( ! @@int64@@ ) return Number L ; * ( _QWORD * ) @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _WORD * ) ( @@int64@@ + Number ) = Number ; } } else if ( ( unsigned __int8 ) cycle_check ( * ( _QWORD * ) ( @@int64@@ + Number ) , @@int64@@ + Number ) ) { * ( _QWORD * ) @@int64@@ = @@int64@@ ; * ( _WORD * ) ( @@int64@@ + Number ) = Number ; } return Number L ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall first_last_page ( unsigned int @@unsignedint@@ , char @@char@@ , _BYTE * @@BYTE@@ ) { unsigned int @@unsignedint@@ ; unsigned int @@unsignedint@@ ; _BYTE * @@BYTE@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; _BYTE * @@BYTE@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@unsignedint64@@ = Number ; @@unsignedint@@ = xstrtoumax ( @@BYTE@@ , & @@BYTE@@ , Number L , & @@unsignedint64@@ , & locale ) ; if ( @@unsignedint@@ && @@unsignedint@@ != Number ) xstrtol_fatal ( @@unsignedint@@ , @@unsignedint@@ , ( unsigned int ) @@char@@ , & long_options , @@BYTE@@ ) ; if ( @@BYTE@@ == @@BYTE@@ || ! @@unsignedint64@@ ) return Number L ; if ( * @@BYTE@@ == Number ) { @@BYTE@@ = @@BYTE@@ + Number ; @@unsignedint@@ = xstrtoumax ( @@BYTE@@ + Number , & @@BYTE@@ , Number L , & @@unsignedint64@@ , & locale ) ; if ( @@unsignedint@@ ) xstrtol_fatal ( @@unsignedint@@ , @@unsignedint@@ , ( unsigned int ) @@char@@ , & long_options , @@BYTE@@ ) ; if ( @@BYTE@@ == @@BYTE@@ || @@unsignedint64@@ < @@unsignedint64@@ ) { return Number L ; } } if ( * @@BYTE@@ ) return Number L ; first_page_number = @@unsignedint64@@ ; last_page_number = @@unsignedint64@@ ; return Number L ; }
__int64 __fastcall hash_get_first ( unsigned __int64 * @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; if ( ! @@unsignedint64@@ [ Number ] ) return Number L ; for ( @@unsignedint64@@ = * @@unsignedint64@@ ; ; @@unsignedint64@@ += Number L ) { if ( @@unsignedint64@@ >= @@unsignedint64@@ [ Number ] ) abort ( ) ; if ( * ( _QWORD * ) @@unsignedint64@@ ) break ; } return * ( _QWORD * ) @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
_BOOL8 __fastcall leaf_optimization_applies ( int @@int@@ ) { _BOOL8 @@BOOL8@@ ; struct statfs @@structstatfs@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( fstatfs ( @@int@@ , & @@structstatfs@@ ) ) @@BOOL8@@ = Number L ; else @@BOOL8@@ = @@structstatfs@@ . f_type == Number ; return @@BOOL8@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ ) { return xmalloc ( @@int64@@ ) ; }
bool __fastcall is_prime ( unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = Number L ; @@unsignedint64@@ = Number L ; while ( @@unsignedint64@@ < @@unsignedint64@@ && @@unsignedint64@@ % @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@unsignedint64@@ += Number * @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint64@@ + Number ; } return @@unsignedint64@@ % @@unsignedint64@@ != Number ; }
__int64 __fastcall print_files ( int @@int@@ , _QWORD * @@QWORD@@ ) { __int64 @@int64@@ ; init_parameters ( @@int@@ ) ; @@int64@@ = ( unsigned int ) init_fps ( @@int@@ , @@QWORD@@ ) ^ Number ; if ( ! ( _BYTE ) @@int64@@ ) { if ( storing_columns ) init_store_cols ( ) ; if ( ( unsigned __int64 ) first_page_number <= Number ) { page_number = Number L ; } else { @@int64@@ = ( unsigned int ) skip_to_page ( first_page_number ) ^ Number ; if ( ( _BYTE ) @@int64@@ ) return @@int64@@ ; page_number = first_page_number ; } init_funcs ( ) ; line_number = line_count ; do @@int64@@ = print_page ( ) ; while ( ( _BYTE ) @@int64@@ ) ; } return @@int64@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
__int64 __fastcall check_tuning ( __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( ( _UNKNOWN * ) @@int64@@ == & default_tuning ) return Number L ; if ( * ( float * ) ( @@int64@@ + Number ) > Number && ( float ) ( Number - Number ) > * ( float * ) ( @@int64@@ + Number ) && * ( float * ) ( @@int64@@ + Number ) > ( float ) ( Number + Number ) && * ( float * ) @@int64@@ >= Number && * ( float * ) ( @@int64@@ + Number ) > ( float ) ( * ( float * ) @@int64@@ + Number ) && * ( float * ) ( @@int64@@ + Number ) <= Number && * ( float * ) ( @@int64@@ + Number ) > ( float ) ( * ( float * ) @@int64@@ + Number ) ) { return Number L ; } * ( _QWORD * ) ( @@int64@@ + Number ) = & default_tuning ; return Number L ; }
__int64 __fastcall link_count_optimize_ok ( __int64 @@int64@@ ) { __int64 @@int64@@ ; bool @@bool@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; _BYTE * @@BYTE@@ ; __int64 @@int644@@ [ Number ] ; @@int644@@ [ Number ] = __readfsqword ( Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) == Number ) return Number L ; if ( ! @@int64@@ ) { * ( _QWORD * ) ( @@int64@@ + Number ) = hash_initialize ( Number L , Number L , LCO_hash , LCO_compare , & free ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( ! @@int64@@ ) return Number L ; } @@int644@@ [ Number ] = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = hash_lookup ( @@int64@@ , @@int644@@ ) ; if ( @@int64@@ ) return * ( unsigned __int8 * ) ( @@int64@@ + Number ) ; @@BYTE@@ = malloc ( Number ) ; if ( ! @@BYTE@@ ) return Number L ; @@bool@@ = leaf_optimization_applies ( * ( _DWORD * ) ( @@int64@@ + Number ) ) ; @@BYTE@@ [ Number ] = @@bool@@ ; * ( _QWORD * ) @@BYTE@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = hash_insert ( @@int64@@ , @@BYTE@@ ) ; if ( @@int64@@ ) { if ( ( _BYTE * ) @@int64@@ != @@BYTE@@ ) abort ( ) ; @@int64@@ = @@bool@@ ; } else { free ( @@BYTE@@ ) ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall hash_find_entry ( __int64 @@int64@@ , __int64 @@int64@@ , _QWORD * @@QWORD@@ , char @@char@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; @@int64@@ = * ( _QWORD * ) @@int64@@ ; @@QWORD@@ = ( _QWORD * ) ( @@int64@@ + Number * ( * ( __int64 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@int64@@ + Number ) ) ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@QWORD@@ >= * ( _QWORD * ) ( @@int64@@ + Number ) ) abort ( ) ; * @@QWORD@@ = @@QWORD@@ ; if ( ! * @@QWORD@@ ) return Number L ; if ( @@int64@@ == * @@QWORD@@ || ( * ( unsigned __int8 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@int64@@ + Number ) ) ( @@int64@@ , * @@QWORD@@ ) ) { @@int64@@ = * @@QWORD@@ ; if ( @@char@@ ) { if ( @@QWORD@@ [ Number ] ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; @@int64@@ = @@QWORD@@ [ Number ] ; * @@QWORD@@ = * @@QWORD@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; free_entry ( @@int64@@ , @@QWORD@@ ) ; } else { * @@QWORD@@ = Number L ; } } @@int64@@ = @@int64@@ ; } else { for ( @@QWORD@@ = @@QWORD@@ ; ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { if ( ! @@QWORD@@ [ Number ] ) return Number L ; if ( @@int64@@ == * ( _QWORD * ) @@QWORD@@ [ Number ] || ( * ( unsigned __int8 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@int64@@ + Number ) ) ( @@int64@@ , * ( _QWORD * ) @@QWORD@@ [ Number ] ) ) { break ; } } @@int64@@ = * ( _QWORD * ) @@QWORD@@ [ Number ] ; if ( @@char@@ ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = @@QWORD@@ [ Number ] ; free_entry ( @@int64@@ , @@QWORD@@ ) ; } @@int64@@ = @@int64@@ ; } return @@int64@@ ; }
__int64 __fastcall align_column ( __int64 @@int64@@ ) { __int64 @@int64@@ ; padding_not_printed = * ( _DWORD * ) ( @@int64@@ + Number ) ; if ( padding_not_printed - col_sep_length > Number ) { pad_across_to ( ( unsigned int ) ( padding_not_printed - col_sep_length ) ) ; padding_not_printed = Number ; } if ( use_col_separator ) print_sep_string ( ) ; @@int64@@ = * ( unsigned __int8 * ) ( @@int64@@ + Number ) ; if ( ( _BYTE ) @@int64@@ ) @@int64@@ = add_line_number ( @@int64@@ ) ; return @@int64@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
unsigned __int64 __fastcall xstrtol_error ( unsigned int @@unsignedint@@ , int @@int@@ , char @@char@@ , __int64 @@int64@@ , __int64 @@int64@@ , int @@int@@ ) { char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; char @@char2@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@char@@ = String ; if ( @@unsignedint@@ > Number ) { if ( @@unsignedint@@ != Number ) goto LABEL_6 ; @@char@@ = String ; } else if ( @@unsignedint@@ >= Number ) { @@char@@ = String ; } else { if ( @@unsignedint@@ != Number ) LABEL_6 : abort ( ) ; @@char@@ = String ; } if ( @@int@@ >= Number ) { @@char@@ = * ( char * * ) ( Number L * @@int@@ + @@int64@@ ) ; } else { @@char@@ = & asc_DD10 [ - @@int@@ ] ; @@char2@@ [ Number ] = @@char@@ ; @@char2@@ [ Number ] = Number ; @@char@@ = @@char2@@ ; } @@char@@ = gettext ( @@char@@ ) ; error ( @@int@@ , Number , @@char@@ , @@char@@ , @@char@@ , @@int64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
size_t __fastcall fts_maxarglen ( const char * * @@constchar@@ ) { size_t @@sizet@@ ; size_t @@sizet@@ ; @@sizet@@ = Number L ; while ( * @@constchar@@ ) { @@sizet@@ = strlen ( * @@constchar@@ ) ; if ( @@sizet@@ > @@sizet@@ ) @@sizet@@ = @@sizet@@ ; ++ @@constchar@@ ; } return @@sizet@@ + Number ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
__int64 __fastcall balance ( int @@int@@ ) { __int64 @@int64@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; _DWORD * @@DWORD@@ ; @@int@@ = Number ; @@int@@ = Number ; for ( @@DWORD@@ = column_vector ; ; @@DWORD@@ += Number ) { @@int64@@ = ( unsigned int ) columns ; if ( @@int@@ > columns ) break ; @@int@@ = @@int@@ / columns ; if ( @@int@@ <= @@int@@ % columns ) ++ @@int@@ ; @@DWORD@@ [ Number ] = @@int@@ ; @@DWORD@@ [ Number ] = @@int@@ ; @@int@@ += @@int@@ ; ++ @@int@@ ; } return @@int64@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall touch ( const char * @@constchar@@ ) { bool @@bool@@ ; const char * @@constchar@@ ; __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; bool @@bool@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; time_t * @@timet@@ ; @@unsignedint@@ = Number ; @@int@@ = Number ; @@timet@@ = & newtime ; if ( ! strcmp ( @@constchar@@ , String ) ) { @@unsignedint@@ = Number ; } else if ( no_create != Number && no_dereference != Number ) { @@unsignedint@@ = fd_reopen ( Number L , @@constchar@@ , Number L , Number L ) ; if ( @@unsignedint@@ == Number && * __errno_location ( ) != Number && * __errno_location ( ) != Number && * __errno_location ( ) != Number ) { @@int@@ = * __errno_location ( ) ; } } if ( change_times != Number ) { if ( change_times == Number ) { qword_2100E8 = Number L ; } else { if ( change_times != Number ) __assert_fail ( String , String , Number , String ) ; qword_2100F8 = Number L ; } } if ( amtime_now ) @@timet@@ = Number L ; if ( no_dereference && @@unsignedint@@ == Number ) { @@bool@@ = ( unsigned int ) lutimens ( @@constchar@@ , @@timet@@ ) == Number ; } else { if ( @@unsignedint@@ == Number ) @@constchar@@ = Number L ; else @@constchar@@ = @@constchar@@ ; @@bool@@ = ( unsigned int ) gl_futimens ( @@unsignedint@@ , @@constchar@@ , @@timet@@ ) == Number ; } @@bool@@ = @@bool@@ ; if ( @@unsignedint@@ ) { if ( @@unsignedint@@ == Number && ! @@bool@@ && * __errno_location ( ) == Number && no_create ) return Number L ; } else if ( close ( Number ) ) { @@int64@@ = quote ( @@constchar@@ ) ; @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ , @@int64@@ ) ; return Number L ; } if ( @@bool@@ ) return Number L ; if ( @@int@@ ) { @@int64@@ = quote ( @@constchar@@ ) ; @@char@@ = gettext ( String ) ; error ( Number , @@int@@ , @@char@@ , @@int64@@ ) ; } else { if ( no_create && * __errno_location ( ) == Number ) return Number L ; @@int64@@ = quote ( @@constchar@@ ) ; @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ , @@int64@@ ) ; } return Number L ; }
__int64 __fastcall memcpy_lowcase ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { while ( @@int64@@ -- ) * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) = tolower ( * ( unsigned __int8 * ) ( @@int64@@ + @@int64@@ ) ) ; return @@int64@@ ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
int __fastcall print_char ( signed __int8 @@signedint8@@ ) { const unsigned __int16 * @@constunsignedint16@@ ; if ( tabify_output ) { if ( @@signedint8@@ == Number ) return ++ spaces_not_printed ; if ( spaces_not_printed > Number ) print_white_space ( ) ; @@constunsignedint16@@ = * __ctype_b_loc ( ) ; if ( ( @@constunsignedint16@@ [ ( unsigned __int8 ) to_uchar ( @@signedint8@@ ) ] & Number ) != Number ) { ++ output_position ; } else if ( @@signedint8@@ == Number ) { -- output_position ; } } return putchar_unlocked ( @@signedint8@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
int __fastcall hash_print_statistics ( __int64 @@int64@@ , FILE * @@FILE@@ ) { double @@double@@ ; double @@double@@ ; double @@double@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int64@@ = hash_get_n_entries ( @@int64@@ ) ; @@int64@@ = hash_get_n_buckets ( @@int64@@ ) ; @@int64@@ = hash_get_n_buckets_used ( @@int64@@ ) ; @@unsignedint64@@ = hash_get_max_bucket_length ( @@int64@@ ) ; fprintf ( @@FILE@@ , String , @@int64@@ ) ; fprintf ( @@FILE@@ , String , @@int64@@ ) ; if ( @@int64@@ < Number ) @@double@@ = ( double ) ( int ) ( @@int64@@ & Number | ( ( unsigned __int64 ) @@int64@@ >> Number ) ) + ( double ) ( int ) ( @@int64@@ & Number | ( ( unsigned __int64 ) @@int64@@ >> Number ) ) ; else @@double@@ = ( double ) ( int ) @@int64@@ ; @@double@@ = Number * @@double@@ ; if ( @@int64@@ < Number ) @@double@@ = ( double ) ( int ) ( @@int64@@ & Number | ( ( unsigned __int64 ) @@int64@@ >> Number ) ) + ( double ) ( int ) ( @@int64@@ & Number | ( ( unsigned __int64 ) @@int64@@ >> Number ) ) ; else @@double@@ = ( double ) ( int ) @@int64@@ ; fprintf ( @@FILE@@ , String , @@int64@@ , @@double@@ / @@double@@ ) ; return fprintf ( @@FILE@@ , String , @@unsignedint64@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
__int64 __fastcall print_stored ( _DWORD * @@DWORD@@ ) { int @@int@@ ; __int64 @@int64@@ ; signed __int8 * @@signedint8@@ ; int @@int@@ ; int @@int@@ ; _DWORD * @@DWORD@@ ; signed __int8 * @@signedint8@@ ; signed __int8 * @@signedint8@@ ; @@int@@ = @@DWORD@@ [ Number ] ; @@DWORD@@ [ Number ] = @@int@@ + Number ; @@int@@ = @@int@@ ; @@signedint8@@ = ( char * ) buff + * ( ( int * ) line_vector + @@int@@ ) ; @@signedint8@@ = ( char * ) buff + * ( ( int * ) line_vector + @@int@@ + Number ) ; pad_vertically = Number ; if ( print_a_header ) print_header ( ) ; if ( @@DWORD@@ [ Number ] != Number ) goto LABEL_11 ; @@int@@ = Number ; @@DWORD@@ = column_vector ; while ( @@int@@ <= columns ) { @@DWORD@@ [ Number ] = Number ; ++ @@int@@ ; @@DWORD@@ += Number ; } if ( * ( ( int * ) column_vector + Number ) <= Number ) { if ( extremities != Number ) pad_vertically = Number ; @@int64@@ = Number L ; } else { LABEL_11 : if ( padding_not_printed - col_sep_length > Number ) { pad_across_to ( padding_not_printed - col_sep_length ) ; padding_not_printed = Number ; } if ( use_col_separator ) print_sep_string ( ) ; while ( @@signedint8@@ != @@signedint8@@ ) { @@signedint8@@ = @@signedint8@@ ++ ; print_char ( * @@signedint8@@ ) ; } if ( ! spaces_not_printed ) { output_position = @@DWORD@@ [ Number ] + * ( ( _DWORD * ) end_vector + @@int@@ ) ; if ( @@DWORD@@ [ Number ] - col_sep_length == chars_per_margin ) output_position -= col_sep_length ; } @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_20E038 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
unsigned __int64 __fastcall hash_string ( _BYTE * @@BYTE@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = Number L ; while ( * @@BYTE@@ ) @@unsignedint64@@ = ( Number * @@unsignedint64@@ + ( unsigned __int8 ) * @@BYTE@@ ++ ) % @@unsignedint64@@ ; return @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
const char * __fastcall get_tz ( void * @@void@@ ) { const char * @@constchar@@ ; const char * @@constchar@@ ; size_t @@sizet@@ ; @@constchar@@ = getenv ( String ) ; if ( @@constchar@@ ) { @@sizet@@ = strlen ( @@constchar@@ ) + Number ; if ( @@sizet@@ > Number ) @@constchar@@ = ( const char * ) xmemdup ( @@constchar@@ , @@sizet@@ ) ; else @@constchar@@ = ( const char * ) memcpy ( @@void@@ , @@constchar@@ , @@sizet@@ ) ; @@constchar@@ = @@constchar@@ ; } return @@constchar@@ ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
unsigned __int64 __fastcall raw_hasher ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { return rotr_sz ( @@int64@@ , Number ) % @@unsignedint64@@ ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
void * __fastcall allocate_entry ( __int64 @@int64@@ ) { __int64 @@int64@@ ; if ( ! * ( _QWORD * ) ( @@int64@@ + Number ) ) return malloc ( Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; return ( void * ) @@int64@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_210128 ; @@int648@@ [ Number ] = qword_210130 ; @@int648@@ [ Number ] = qword_210138 ; @@int648@@ [ Number ] = qword_210140 ; @@int648@@ [ Number ] = qword_210148 ; @@int648@@ [ Number ] = qword_210150 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
__int64 __fastcall argmatch ( const char * @@constchar@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { __int64 @@int64@@ ; char @@char@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; size_t @@sizet@@ ; @@int64@@ = Number ; @@char@@ = Number ; @@sizet@@ = strlen ( @@constchar@@ ) ; for ( @@int64@@ = Number L ; * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; ++ @@int64@@ ) { if ( ! strncmp ( * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) , @@constchar@@ , @@sizet@@ ) ) { if ( @@sizet@@ == strlen ( * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) ) ) return @@int64@@ ; if ( @@int64@@ == Number ) { @@int64@@ = @@int64@@ ; } else if ( ! @@int64@@ || memcmp ( ( const void * ) ( @@sizet@@ * @@int64@@ + @@int64@@ ) , ( const void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) , @@sizet@@ ) ) { @@char@@ = Number ; } } } if ( @@char@@ ) @@int64@@ = Number ; else @@int64@@ = @@int64@@ ; return @@int64@@ ; }
__int64 __fastcall free_entry ( __int64 @@int64@@ , _QWORD * @@QWORD@@ ) { __int64 @@int64@@ ; * @@QWORD@@ = Number L ; @@QWORD@@ [ Number ] = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@QWORD@@ ; return @@int64@@ ; }
__int64 __fastcall errno_may_be_empty ( int @@int@@ ) { __int64 @@int64@@ ; switch ( @@int@@ ) { case Number : case Number : case Number : case Number : case Number : @@int64@@ = Number L ; break ; default : @@int64@@ = Number L ; break ; } return @@int64@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_210088 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
_BOOL8 __fastcall remove_parents ( const char * @@constchar@@ ) { int @@int@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int * @@int@@ ; __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; char @@char@@ ; bool @@bool@@ ; char * @@char@@ ; @@bool@@ = Number ; strip_trailing_slashes ( @@constchar@@ ) ; while ( Number ) { @@char@@ = strrchr ( @@constchar@@ , Number ) ; if ( ! @@char@@ ) break ; while ( @@char@@ > @@constchar@@ && * @@char@@ == Number ) -- @@char@@ ; @@char@@ [ Number ] = Number ; if ( verbose ) { @@int@@ = quote ( @@constchar@@ ) ; @@unsignedint@@ = ( unsigned int ) gettext ( String ) ; prog_fprintf ( ( _DWORD ) stdout , @@unsignedint@@ , @@int@@ , @@unsignedint@@ , @@int@@ , @@int@@ , @@char@@ ) ; } @@int@@ = rmdir ( @@constchar@@ ) ; @@bool@@ = @@int@@ == Number ; if ( @@int@@ ) { @@int@@ = __errno_location ( ) ; if ( ignorable_failure ( * @@int@@ , @@constchar@@ ) ) return Number ; @@int64@@ = quote ( @@constchar@@ ) ; @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ , @@int64@@ ) ; return @@bool@@ ; } } return @@bool@@ ; }
__int64 __fastcall transfer_entries ( __int64 @@int64@@ , __int64 @@int64@@ , char @@char@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 * @@int64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; for ( @@int64@@ = * ( __int64 * * ) @@int64@@ ; ( unsigned __int64 ) @@int64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ += Number ) { if ( * @@int64@@ ) { for ( @@QWORD@@ = ( _QWORD * ) @@int64@@ [ Number ] ; @@QWORD@@ ; @@QWORD@@ = @@QWORD@@ ) { @@int64@@ = * @@QWORD@@ ; @@int64@@ = * ( _QWORD * ) @@int64@@ ; @@QWORD@@ = ( _QWORD * ) ( @@int64@@ + Number * ( * ( __int64 ( __fastcall * * ) ( _QWORD , _QWORD ) ) ( @@int64@@ + Number ) ) ( * @@QWORD@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@QWORD@@ >= * ( _QWORD * ) ( @@int64@@ + Number ) ) abort ( ) ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; if ( * @@QWORD@@ ) { @@QWORD@@ [ Number ] = @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = @@QWORD@@ ; } else { * @@QWORD@@ = @@int64@@ ; ++ * ( _QWORD * ) ( @@int64@@ + Number ) ; free_entry ( @@int64@@ , @@QWORD@@ ) ; } } @@int64@@ = * @@int64@@ ; @@int64@@ [ Number ] = Number L ; if ( ! @@char@@ ) { @@int64@@ = * ( _QWORD * ) @@int64@@ ; @@QWORD@@ = ( _QWORD * ) ( @@int64@@ + Number * ( * ( __int64 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@int64@@ + Number ) ) ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@QWORD@@ >= * ( _QWORD * ) ( @@int64@@ + Number ) ) abort ( ) ; if ( * @@QWORD@@ ) { @@QWORD@@ = allocate_entry ( @@int64@@ ) ; if ( ! @@QWORD@@ ) return Number L ; * @@QWORD@@ = @@int64@@ ; @@QWORD@@ [ Number ] = @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = @@QWORD@@ ; } else { * @@QWORD@@ = @@int64@@ ; ++ * ( _QWORD * ) ( @@int64@@ + Number ) ; } * @@int64@@ = Number L ; -- * ( _QWORD * ) ( @@int64@@ + Number ) ; } } } return Number L ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_2070E8 ; @@int648@@ [ Number ] = qword_2070F0 ; @@int648@@ [ Number ] = qword_2070F8 ; @@int648@@ [ Number ] = qword_207100 ; @@int648@@ [ Number ] = qword_207108 ; @@int648@@ [ Number ] = qword_207110 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
__int64 __fastcall rpl_fcntl ( int @@int@@ , int @@int@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ ) { int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; if ( @@int@@ != Number ) return ( unsigned int ) fcntl ( @@int@@ , @@int@@ , @@int64@@ ) ; @@int@@ = @@int64@@ ; if ( have_dupfd_cloexec_2895 < Number ) { @@int@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@int@@ , Number , @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ ) ; } else { @@int@@ = fcntl ( @@int@@ , Number , ( unsigned int ) @@int64@@ ) ; if ( @@int@@ < Number && * __errno_location ( ) == Number ) { @@int@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@int@@ , Number , @@int@@ , @@int@@ , @@int@@ , @@int@@ ) ; if ( @@int@@ < Number ) return ( unsigned int ) @@int@@ ; have_dupfd_cloexec_2895 = Number ; } else { have_dupfd_cloexec_2895 = Number ; } } if ( @@int@@ >= Number && have_dupfd_cloexec_2895 == Number ) { @@int@@ = fcntl ( @@int@@ , Number ) ; if ( @@int@@ < Number || fcntl ( @@int@@ , Number , @@int@@ | Number ) == Number ) { @@int@@ = * __errno_location ( ) ; close ( @@int@@ ) ; * __errno_location ( ) = @@int@@ ; @@int@@ = Number ; } } return ( unsigned int ) @@int@@ ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
int __fastcall gl_futimens ( int @@int@@ , char * @@char@@ , __int64 * @@int64@@ ) { return fdutimens ( @@char@@ , @@int@@ , @@int64@@ ) ; }
__int64 __fastcall fwrite_lowcase ( FILE * @@FILE@@ , unsigned __int8 * @@unsignedint8@@ , __int64 @@int64@@ ) { int @@int@@ ; __int64 @@int64@@ ; while ( Number ) { @@int64@@ = @@int64@@ -- ; if ( ! @@int64@@ ) break ; @@int@@ = tolower ( * @@unsignedint8@@ ) ; fputc ( @@int@@ , @@FILE@@ ) ; ++ @@unsignedint8@@ ; } return @@int64@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ ) { return xmalloc ( @@int64@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall fd_reopen ( int @@int@@ , const char * @@constchar@@ , int @@int@@ , unsigned int @@unsignedint@@ ) { int @@int@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; @@int@@ = open ( @@constchar@@ , @@int@@ , @@unsignedint@@ ) ; if ( @@int@@ == @@int@@ || @@int@@ < Number ) return ( unsigned int ) @@int@@ ; @@unsignedint@@ = dup2 ( @@int@@ , @@int@@ ) ; @@int@@ = * __errno_location ( ) ; close ( @@int@@ ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint@@ ; }
int __fastcall argmatch_valid ( __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { char * @@char@@ ; __int64 @@int64@@ ; void * @@void@@ ; @@void@@ = Number L ; @@char@@ = gettext ( String ) ; fprintf ( stderr , @@char@@ ) ; for ( @@int64@@ = Number L ; * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; ++ @@int64@@ ) { if ( @@int64@@ && ! memcmp ( @@void@@ , ( const void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) , @@sizet@@ ) ) { fprintf ( stderr , String , * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) ) ; } else { fprintf ( stderr , String , * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) ) ; @@void@@ = ( void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) ; } } return putc_unlocked ( Number , stderr ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_20E108 ; @@int648@@ [ Number ] = qword_20E110 ; @@int648@@ [ Number ] = qword_20E118 ; @@int648@@ [ Number ] = qword_20E120 ; @@int648@@ [ Number ] = qword_20E128 ; @@int648@@ [ Number ] = qword_20E130 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
__int64 __fastcall rpl_fcntl ( int @@int@@ , int @@int@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ ) { int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; if ( @@int@@ != Number ) return ( unsigned int ) fcntl ( @@int@@ , @@int@@ , @@int64@@ ) ; @@int@@ = @@int64@@ ; if ( have_dupfd_cloexec_2895 < Number ) { @@int@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@int@@ , Number , @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ ) ; } else { @@int@@ = fcntl ( @@int@@ , Number , ( unsigned int ) @@int64@@ ) ; if ( @@int@@ < Number && * __errno_location ( ) == Number ) { @@int@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@int@@ , Number , @@int@@ , @@int@@ , @@int@@ , @@int@@ ) ; if ( @@int@@ < Number ) return ( unsigned int ) @@int@@ ; have_dupfd_cloexec_2895 = Number ; } else { have_dupfd_cloexec_2895 = Number ; } } if ( @@int@@ >= Number && have_dupfd_cloexec_2895 == Number ) { @@int@@ = fcntl ( @@int@@ , Number ) ; if ( @@int@@ < Number || fcntl ( @@int@@ , Number , @@int@@ | Number ) == Number ) { @@int@@ = * __errno_location ( ) ; close ( @@int@@ ) ; * __errno_location ( ) = @@int@@ ; @@int@@ = Number ; } } return ( unsigned int ) @@int@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_20A0C8 ; @@int648@@ [ Number ] = qword_20A0D0 ; @@int648@@ [ Number ] = qword_20A0D8 ; @@int648@@ [ Number ] = qword_20A0E0 ; @@int648@@ [ Number ] = qword_20A0E8 ; @@int648@@ [ Number ] = qword_20A0F0 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
size_t __fastcall rpl_vfprintf ( FILE * @@FILE@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { size_t @@sizet@@ ; size_t @@sizet@@ ; int @@int@@ ; size_t @@sizet@@ ; void * @@void@@ ; size_t @@sizet@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@sizet@@ = Number L ; @@void@@ = ( void * ) vasnprintf ( @@char@@ , & @@sizet@@ , @@int64@@ , @@int64@@ ) ; @@sizet@@ = @@sizet@@ ; if ( @@void@@ ) { @@sizet@@ = fwrite ( @@void@@ , Number , @@sizet@@ , @@FILE@@ ) ; if ( @@sizet@@ <= @@sizet@@ ) { if ( @@void@@ != @@char@@ ) free ( @@void@@ ) ; if ( @@sizet@@ <= Number ) { @@sizet@@ = @@sizet@@ ; } else { * __errno_location ( ) = Number ; fseterr ( @@FILE@@ ) ; @@sizet@@ = Number ; } } else { if ( @@void@@ != @@char@@ ) { @@int@@ = * __errno_location ( ) ; free ( @@void@@ ) ; * __errno_location ( ) = @@int@@ ; } @@sizet@@ = Number ; } } else { fseterr ( @@FILE@@ ) ; @@sizet@@ = Number ; } return @@sizet@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_207028 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return xmalloc ( @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall fwrite_uppcase ( FILE * @@FILE@@ , unsigned __int8 * @@unsignedint8@@ , __int64 @@int64@@ ) { int @@int@@ ; __int64 @@int64@@ ; while ( Number ) { @@int64@@ = @@int64@@ -- ; if ( ! @@int64@@ ) break ; @@int@@ = toupper ( * @@unsignedint8@@ ) ; fputc ( @@int@@ , @@FILE@@ ) ; ++ @@unsignedint8@@ ; } return @@int64@@ ; }
__int64 __fastcall selected_fstype ( const char * @@constchar@@ ) { __int64 @@int64@@ ; if ( ! fs_select_list || ! @@constchar@@ ) return Number L ; for ( @@int64@@ = fs_select_list ; @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ) { if ( ! strcmp ( @@constchar@@ , * ( const char * * ) @@int64@@ ) ) return Number L ; } return Number L ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall xsum ( unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; if ( @@unsignedint64@@ + @@int64@@ < @@unsignedint64@@ ) @@int64@@ = Number ; else @@int64@@ = @@unsignedint64@@ + @@int64@@ ; return @@int64@@ ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 decimal_point_char ( ) { __int64 @@int64@@ ; char * @@char@@ ; @@char@@ = nl_langinfo ( Number ) ; if ( * @@char@@ ) @@int64@@ = ( unsigned __int8 ) * @@char@@ ; else @@int64@@ = Number L ; return @@int64@@ ; }
__int64 __fastcall get_stat_atime_0 ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
unsigned __int64 __fastcall add_uint_with_neg_flag ( _QWORD * @@QWORD@@ , unsigned __int8 * @@unsignedint8@@ , unsigned __int64 @@unsignedint64@@ , unsigned __int8 @@unsignedint8@@ ) { unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint64@@ ; if ( @@unsignedint8@@ ^ * @@unsignedint8@@ ^ Number ) { @@unsignedint64@@ = ( unsigned __int64 ) @@QWORD@@ ; * @@QWORD@@ += @@unsignedint64@@ ; } else { if ( * @@unsignedint8@@ ) * @@QWORD@@ = - * @@QWORD@@ ; if ( @@unsignedint8@@ ) @@unsignedint64@@ = - ( __int64 ) @@unsignedint64@@ ; if ( @@unsignedint64@@ >= * @@QWORD@@ ) { * @@QWORD@@ = @@unsignedint64@@ - * @@QWORD@@ ; * @@unsignedint8@@ = @@unsignedint8@@ ; } else { * @@QWORD@@ -= @@unsignedint64@@ ; } @@unsignedint64@@ = * @@unsignedint8@@ ; if ( ( _BYTE ) @@unsignedint64@@ ) { @@unsignedint64@@ = ( unsigned __int64 ) @@QWORD@@ ; * @@QWORD@@ = - * @@QWORD@@ ; } } return @@unsignedint64@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
int __fastcall utimens ( char * @@char@@ , __int64 * @@int64@@ ) { return fdutimens ( @@char@@ , Number , @@int64@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
void * __fastcall xzalloc ( size_t @@sizet@@ , __int64 @@int64@@ ) { void * @@void@@ ; @@void@@ = xmalloc ( @@sizet@@ , @@int64@@ ) ; return memset ( @@void@@ , Number , @@sizet@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ ) { return xmalloc ( @@int64@@ ) ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
__int64 __fastcall xstr_iconv ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = str_iconv ( @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( ! @@int64@@ && * __errno_location ( ) == Number ) xalloc_die ( ) ; return @@int64@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
_BOOL8 __fastcall dot_or_dotdot ( _BYTE * @@BYTE@@ ) { __int64 @@int64@@ ; char @@char@@ ; if ( * @@BYTE@@ != Number ) return Number L ; if ( @@BYTE@@ [ Number ] == Number ) @@int64@@ = Number L ; else @@int64@@ = Number L ; @@char@@ = @@BYTE@@ [ @@int64@@ ] ; return ! @@char@@ || @@char@@ == Number ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
int __fastcall emit_blocksize_note ( __int64 @@int64@@ ) { char * @@char@@ ; @@char@@ = gettext ( String String String String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
_BYTE * __fastcall dir_len ( _BYTE * @@BYTE@@ ) { _BYTE * @@BYTE@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = * @@BYTE@@ == Number ; for ( @@BYTE@@ = ( _BYTE * ) ( last_component ( @@BYTE@@ ) - @@BYTE@@ ) ; @@unsignedint64@@ < ( unsigned __int64 ) @@BYTE@@ && @@BYTE@@ [ ( _QWORD ) ( @@BYTE@@ - Number ) ] == Number ; -- @@BYTE@@ ) { ; } return @@BYTE@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
bool __fastcall is_empty_dir ( int @@int@@ , const char * @@constchar@@ ) { bool @@bool@@ ; int @@int@@ ; int @@int@@ ; DIR * @@DIR@@ ; struct dirent * @@structdirent@@ ; @@int@@ = openat ( @@int@@ , @@constchar@@ , Number ) ; if ( @@int@@ < Number ) return Number ; @@DIR@@ = fdopendir ( @@int@@ ) ; if ( @@DIR@@ ) { * __errno_location ( ) = Number ; @@structdirent@@ = readdir_ignoring_dot_and_dotdot ( @@DIR@@ ) ; @@int@@ = * __errno_location ( ) ; closedir ( @@DIR@@ ) ; if ( @@structdirent@@ ) @@bool@@ = Number ; else @@bool@@ = @@int@@ == Number ; } else { close ( @@int@@ ) ; @@bool@@ = Number ; } return @@bool@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
__int64 __fastcall get_fs_usage ( const char * @@constchar@@ , __int64 a2 , __int64 @@int64@@ ) { struct statfs @@structstatfs@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( statfs ( @@constchar@@ , & @@structstatfs@@ ) < Number ) return Number ; * ( _QWORD * ) @@int64@@ = @@structstatfs@@ . f_bsize ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@structstatfs@@ . f_blocks ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@structstatfs@@ . f_bfree ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@structstatfs@@ . f_bavail | - ( __int64 ) ( @@structstatfs@@ . f_bavail & Number ) ; * ( _BYTE * ) ( @@int64@@ + Number ) = ( @@structstatfs@@ . f_bavail & Number ) != Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@structstatfs@@ . f_files ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@structstatfs@@ . f_ffree ; return Number L ; }
unsigned __int64 print_header ( ) { FILE * @@FILE@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; int @@int@@ ; __int64 @@int64@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; bool @@bool@@ ; bool @@bool@@ ; unsigned int @@unsignedint@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@FILE@@ = stdout ; if ( print_type ) @@char@@ = gettext ( String ) ; else @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; if ( inode_format ) { @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; } else if ( ( human_output_opts & Number ) != Number ) { @@FILE@@ = stdout ; if ( ( human_output_opts & Number ) != Number ) @@char@@ = gettext ( String ) ; else @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; } else if ( posix_format ) { @@int64@@ = umaxtostr ( output_block_size , @@char@@ ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } else { @@int@@ = human_output_opts & Number ; LOBYTE ( @@int@@ ) = human_output_opts & Number | Number ; @@unsignedint@@ = @@int@@ ; @@unsignedint64@@ = output_block_size ; @@unsignedint64@@ = output_block_size ; do { @@bool@@ = @@unsignedint64@@ % Number == Number ; @@unsignedint64@@ /= Number ; @@bool@@ = ( @@unsignedint64@@ & Number ) == Number ; @@unsignedint64@@ >>= Number ; } while ( @@bool@@ && @@bool@@ ) ; if ( ( unsigned __int8 ) @@bool@@ < ( unsigned __int8 ) @@bool@@ ) @@unsignedint@@ = @@int@@ | Number ; if ( ( unsigned __int8 ) @@bool@@ < ( unsigned __int8 ) @@bool@@ ) @@unsignedint@@ &= Number ; if ( ( @@unsignedint@@ & Number ) == Number ) @@unsignedint@@ |= Number ; @@int64@@ = human_readable ( output_block_size , @@char@@ , @@unsignedint@@ , Number L , Number L ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_2070C8 ; @@int648@@ [ Number ] = qword_2070D0 ; @@int648@@ [ Number ] = qword_2070D8 ; @@int648@@ [ Number ] = qword_2070E0 ; @@int648@@ [ Number ] = qword_2070E8 ; @@int648@@ [ Number ] = qword_2070F0 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
__int64 __fastcall count_consecutive_X_s ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = Number L ; while ( @@int64@@ && * ( _BYTE * ) ( @@int64@@ - Number + @@int64@@ ) == Number ) { ++ @@int64@@ ; -- @@int64@@ ; } return @@int64@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall mkstemp_len ( __int64 @@int64@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , char @@char@@ ) { __int64 @@int64@@ ; if ( @@char@@ ) @@int64@@ = Number L ; else @@int64@@ = Number L ; return gen_tempname_len ( @@int64@@ , @@unsignedint@@ , Number L , @@int64@@ , @@int64@@ ) ; }
char * __fastcall group_number ( char * @@char@@ , size_t @@sizet@@ , unsigned __int8 * @@unsignedint8@@ , const char * @@constchar@@ ) { char * @@char@@ ; size_t @@sizet@@ ; char * @@char@@ ; unsigned __int8 @@unsignedint8@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@sizet@@ = Number ; @@sizet@@ = strlen ( @@constchar@@ ) ; @@sizet@@ = @@sizet@@ ; memcpy ( @@char@@ , @@char@@ , @@sizet@@ ) ; for ( @@char@@ = & @@char@@ [ @@sizet@@ ] ; ; memcpy ( @@char@@ , @@constchar@@ , @@sizet@@ ) ) { @@unsignedint8@@ = * @@unsignedint8@@ ; if ( * @@unsignedint8@@ ) { if ( @@unsignedint8@@ > Number ) @@sizet@@ = @@sizet@@ ; else @@sizet@@ = @@unsignedint8@@ ; @@sizet@@ = @@sizet@@ ; ++ @@unsignedint8@@ ; } if ( @@sizet@@ < @@sizet@@ ) @@sizet@@ = @@sizet@@ ; @@char@@ = & @@char@@ [ - @@sizet@@ ] ; @@sizet@@ -= @@sizet@@ ; memcpy ( @@char@@ , & @@char@@ [ @@sizet@@ ] , @@sizet@@ ) ; if ( ! @@sizet@@ ) break ; @@char@@ = & @@char@@ [ - @@sizet@@ ] ; } return @@char@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
void * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
void * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
void * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
void * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
int __fastcall restore_cwd ( __int64 @@int64@@ ) { int @@int@@ ; if ( * ( int * ) @@int64@@ < Number ) @@int@@ = chdir_long ( * ( _QWORD * ) ( @@int64@@ + Number ) ) ; else @@int@@ = fchdir ( * ( _DWORD * ) @@int64@@ ) ; return @@int@@ ; }
_BOOL8 __fastcall strip_trailing_slashes ( char * @@char@@ ) { char @@char@@ ; const char * @@constchar@@ ; const char * @@constchar@@ ; @@constchar@@ = last_component ( @@char@@ ) ; if ( ! * @@constchar@@ ) @@constchar@@ = @@char@@ ; @@constchar@@ = & @@constchar@@ [ base_len ( @@constchar@@ ) ] ; @@char@@ = * @@constchar@@ ; * @@constchar@@ = Number ; return @@char@@ != Number ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
__int64 __fastcall save_cwd ( __int64 @@int64@@ , __int64 a2 , int @@int@@ , int @@int@@ , int @@int@@ , int @@int@@ ) { __int64 @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number L ; * ( _DWORD * ) @@int64@@ = open_safer ( ( unsigned int ) & unk_EA28 , Number , @@int@@ , @@int@@ , @@int@@ , @@int@@ ) ; if ( * ( int * ) @@int64@@ >= Number ) return Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = xgetcwd ( ) ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) @@int64@@ = Number L ; else @@int64@@ = Number ; return @@int64@@ ; }
__int64 __fastcall xnrealloc ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { if ( ! is_mul_ok ( @@unsignedint64@@ , @@unsignedint64@@ ) ) xalloc_die ( ) ; return xrealloc ( @@int64@@ , @@unsignedint64@@ * @@unsignedint64@@ ) ; }
void * __fastcall mfile_name_concat ( _BYTE * @@BYTE@@ , _BYTE * @@BYTE@@ , _QWORD * @@QWORD@@ ) { _BOOL4 @@BOOL4@@ ; const char * @@constchar@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; _BOOL8 @@BOOL8@@ ; char * @@char@@ ; size_t @@sizet@@ ; void * @@void@@ ; _BYTE * @@BYTE@@ ; char * @@char@@ ; @@constchar@@ = last_component ( @@BYTE@@ ) ; @@sizet@@ = base_len ( @@constchar@@ ) ; @@sizet@@ = @@constchar@@ - @@BYTE@@ + @@sizet@@ ; @@BOOL4@@ = @@sizet@@ && @@constchar@@ [ @@sizet@@ - Number ] != Number ; @@BOOL8@@ = @@BOOL4@@ ; @@char@@ = longest_relative_suffix ( @@BYTE@@ ) ; @@sizet@@ = strlen ( @@char@@ ) ; @@void@@ = malloc ( @@BOOL8@@ + @@sizet@@ + @@sizet@@ + Number ) ; if ( ! @@void@@ ) return Number L ; @@BYTE@@ = mempcpy ( @@void@@ , @@BYTE@@ , @@sizet@@ ) ; * @@BYTE@@ = Number ; @@char@@ = & @@BYTE@@ [ @@BOOL8@@ ] ; if ( @@QWORD@@ ) * @@QWORD@@ = & @@char@@ [ - ( * @@BYTE@@ == Number ) ] ; * ( _BYTE * ) mempcpy ( @@char@@ , @@char@@ , @@sizet@@ ) = Number ; return @@void@@ ; }
_BOOL8 __fastcall rpl_isnanl ( __int64 a1 , __int64 a2 , __int64 a3 , __int64 a4 , __int64 a5 , __int64 a6 , __int128 @@int128@@ ) { if ( ( WORD4 ( @@int128@@ ) & Number ) == Number ) return DWORD1 ( @@int128@@ ) >> Number ; if ( ( WORD4 ( @@int128@@ ) & Number ) == Number ) return ( DWORD1 ( @@int128@@ ) ^ Number | ( unsigned int ) @@int128@@ ) != Number ; return ( DWORD1 ( @@int128@@ ) & Number ) == Number ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
bool __fastcall is_basic_1 ( unsigned __int8 @@unsignedint8@@ ) { return ( ( is_basic_table [ @@unsignedint8@@ >> Number ] >> ( @@unsignedint8@@ & Number ) ) & Number ) != Number ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ ) { return xmalloc ( @@int64@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
const char * locale_charset ( ) { const char * @@constchar@@ ; char * @@char@@ ; char * @@char@@ ; @@constchar@@ = nl_langinfo ( Number ) ; if ( ! @@constchar@@ ) @@constchar@@ = ( const char * ) & unk_EABF ; for ( @@char@@ = ( char * ) get_charset_aliases ( ) ; * @@char@@ ; @@char@@ = & @@char@@ [ strlen ( @@char@@ ) + Number ] ) { if ( ! strcmp ( @@constchar@@ , @@char@@ ) || * @@char@@ == Number && ! @@char@@ [ Number ] ) { @@constchar@@ = & @@char@@ [ strlen ( @@char@@ ) + Number ] ; break ; } @@char@@ = & @@char@@ [ strlen ( @@char@@ ) + Number ] ; } if ( ! * @@constchar@@ ) @@constchar@@ = String ; return @@constchar@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_20A0E8 ; @@int648@@ [ Number ] = qword_20A0F0 ; @@int648@@ [ Number ] = qword_20A0F8 ; @@int648@@ [ Number ] = qword_20A100 ; @@int648@@ [ Number ] = qword_20A108 ; @@int648@@ [ Number ] = qword_20A110 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
int __cdecl __noreturn main ( int @@int@@ , const char * * @@constchar@@ , const char * * @@constchar@@ ) { char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; int * @@int@@ ; char @@char@@ ; int @@int@@ ; double @@double@@ ; char * @@char@@ ; double @@double@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@double@@ = Number ; @@char@@ = Number ; set_program_name ( * @@constchar@@ , @@constchar@@ , @@constchar@@ ) ; setlocale ( Number , & shortopts ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; parse_long_options ( @@int@@ , ( _DWORD ) @@constchar@@ , ( unsigned int ) String , ( unsigned int ) String , ( _DWORD ) Version , ( unsigned int ) usage , String , String , Number L ) ; if ( getopt_long ( @@int@@ , ( char * const * ) @@constchar@@ , & shortopts , Number L , Number L ) != Number ) usage ( Number ) ; if ( @@int@@ == Number ) { @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ ) ; usage ( Number ) ; } for ( @@int@@ = optind ; @@int@@ < @@int@@ ; ++ @@int@@ ) { if ( ( unsigned __int8 ) xstrtod ( @@constchar@@ [ @@int@@ ] , & @@char@@ , & @@double@@ , c_strtod ) != Number || @@double@@ < Number || * @@char@@ && @@char@@ [ Number ] || ( unsigned __int8 ) apply_suffix ( & @@double@@ , * @@char@@ ) != Number ) { @@int64@@ = quote ( @@constchar@@ [ @@int@@ ] ) ; @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ , @@int64@@ ) ; @@char@@ = Number ; } @@double@@ = @@double@@ + @@double@@ ; } if ( @@char@@ != Number ) usage ( Number ) ; if ( ( unsigned int ) xnanosleep ( @@double@@ ) ) { @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ ) ; } exit ( Number ) ; }
char * __fastcall str_iconv ( char * @@char@@ , char * @@char@@ , char * @@char@@ ) { char * @@char@@ ; int @@int@@ ; int @@int@@ ; iconv_t @@iconvt@@ ; void * @@void@@ ; char * @@char@@ ; if ( * @@char@@ && ( unsigned int ) c_strcasecmp ( ( unsigned __int8 * ) @@char@@ , ( unsigned __int8 * ) @@char@@ ) ) { @@iconvt@@ = iconv_open ( @@char@@ , @@char@@ ) ; if ( @@iconvt@@ == ( iconv_t ) Number ) return Number L ; @@void@@ = str_cd_iconv ( @@char@@ , @@iconvt@@ ) ; if ( @@void@@ ) { if ( iconv_close ( @@iconvt@@ ) < Number ) { @@int@@ = * __errno_location ( ) ; free ( @@void@@ ) ; * __errno_location ( ) = @@int@@ ; return Number L ; } } else { @@int@@ = * __errno_location ( ) ; iconv_close ( @@iconvt@@ ) ; * __errno_location ( ) = @@int@@ ; } @@char@@ = ( char * ) @@void@@ ; } else { @@char@@ = strdup ( @@char@@ ) ; if ( ! @@char@@ ) * __errno_location ( ) = Number ; @@char@@ = @@char@@ ; } return @@char@@ ; }
__int64 __fastcall knuth_morris_pratt_unibyte ( _BYTE * @@BYTE@@ , char * @@char@@ , _QWORD * @@QWORD@@ ) { void * @@void@@ ; unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; char * @@char@@ ; _BYTE * @@BYTE@@ ; char @@char@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; size_t @@sizet@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@BYTE@@ = @@BYTE@@ ; @@char@@ = @@char@@ ; @@QWORD@@ = @@QWORD@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@sizet@@ = strlen ( @@char@@ ) ; if ( @@sizet@@ > Number ) { @@unsignedint64@@ = Number L ; } else if ( Number * @@sizet@@ > Number ) { @@unsignedint64@@ = mmalloca ( Number * @@sizet@@ ) ; } else { @@void@@ = alloca ( Number * ( ( Number * ( @@sizet@@ + Number ) + Number ) / Number ) ) ; @@unsignedint64@@ = Number * ( ( ( unsigned __int64 ) & @@QWORD@@ + Number ) >> Number ) + Number ; } @@unsignedint64@@ = @@unsignedint64@@ ; if ( ! @@unsignedint64@@ ) return Number L ; * ( _QWORD * ) ( @@unsignedint64@@ + Number ) = Number L ; @@int64@@ = Number L ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@sizet@@ ; ++ @@unsignedint64@@ ) { @@char@@ = @@char@@ [ @@unsignedint64@@ - Number ] ; while ( Number ) { if ( @@char@@ == @@char@@ [ @@int64@@ ] ) { ++ @@int64@@ ; * ( _QWORD * ) ( @@unsignedint64@@ + Number * @@unsignedint64@@ ) = @@unsignedint64@@ - @@int64@@ ; goto LABEL_15 ; } if ( ! @@int64@@ ) break ; @@int64@@ -= * ( _QWORD * ) ( Number * @@int64@@ + @@unsignedint64@@ ) ; } * ( _QWORD * ) ( @@unsignedint64@@ + Number * @@unsignedint64@@ ) = @@unsignedint64@@ ; LABEL_15 : ; } * @@QWORD@@ = Number L ; @@int64@@ = Number L ; @@BYTE@@ = @@BYTE@@ ; @@BYTE@@ = @@BYTE@@ ; while ( * @@BYTE@@ ) { if ( @@char@@ [ @@int64@@ ] == * @@BYTE@@ ) { ++ @@int64@@ ; ++ @@BYTE@@ ; if ( @@int64@@ == @@sizet@@ ) { * @@QWORD@@ = @@BYTE@@ ; break ; } } else if ( @@int64@@ ) { @@BYTE@@ += * ( _QWORD * ) ( Number * @@int64@@ + @@unsignedint64@@ ) ; @@int64@@ -= * ( _QWORD * ) ( Number * @@int64@@ + @@unsignedint64@@ ) ; } else { ++ @@BYTE@@ ; ++ @@BYTE@@ ; } } freea ( @@unsignedint64@@ ) ; return Number L ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_20A038 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
_QWORD * __fastcall randint_all_new ( __int64 @@int64@@ , __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; @@int64@@ = randread_new ( @@int64@@ , @@int64@@ ) ; if ( @@int64@@ ) @@QWORD@@ = randint_new ( @@int64@@ , @@int64@@ ) ; else @@QWORD@@ = Number L ; return @@QWORD@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall _xargmatch_internal ( __int64 @@int64@@ , const char * @@constchar@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ , void ( * @ @ VAR_1146 @ @ void ( ) ( void ) @ @ argmatchexitfn ) ( void ) ) { __int64 @@int64@@ ; @@int64@@ = argmatch ( @@constchar@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; if ( @@int64@@ >= Number ) return @@int64@@ ; argmatch_invalid ( @@int64@@ , ( __int64 ) @@constchar@@ , @@int64@@ ) ; argmatch_valid ( @@int64@@ , @@int64@@ , @@sizet@@ ) ; @ @ VAR_1146 @ @ void ( ) ( void ) @ @ argmatchexitfn ( ) ; return Number ; }
__int64 __fastcall open_safer ( const char * @@constchar@@ , char @@char@@ , unsigned int @@unsignedint@@ ) { unsigned int @@unsignedint@@ ; unsigned int @@unsignedint@@ ; @@unsignedint@@ = Number ; if ( ( @@char@@ & Number ) != Number ) @@unsignedint@@ = @@unsignedint@@ ; @@unsignedint@@ = open ( @@constchar@@ , @@char@@ , @@unsignedint@@ ) ; return fd_safer ( @@unsignedint@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
__int64 __fastcall randint_all_free ( _QWORD * @@QWORD@@ ) { unsigned int @@unsignedint@@ ; int @@int@@ ; @@unsignedint@@ = randread_free ( * @@QWORD@@ ) ; @@int@@ = * __errno_location ( ) ; randint_free ( @@QWORD@@ ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return xmalloc ( @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall argmatch_to_argument ( const void * @@constvoid@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; ++ @@int64@@ ) { if ( ! memcmp ( @@constvoid@@ , ( const void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) , @@sizet@@ ) ) return * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; } return Number L ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
void __fastcall freea ( unsigned __int64 @@unsignedint64@@ ) { _QWORD * @@QWORD@@ ; if ( @@unsignedint64@@ && * ( _DWORD * ) ( @@unsignedint64@@ - Number ) == Number ) { for ( @@QWORD@@ = & mmalloca_results [ @@unsignedint64@@ % Number ] ; * @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) ( * @@QWORD@@ - Number L ) ) { if ( @@unsignedint64@@ == * @@QWORD@@ ) { * @@QWORD@@ = * ( _QWORD * ) ( @@unsignedint64@@ - Number ) ; free ( ( void * ) ( @@unsignedint64@@ - Number ) ) ; return ; } } } }
__int64 __fastcall c_tolower ( int @@int@@ ) { __int64 @@int64@@ ; if ( @@int@@ <= Number || @@int@@ > Number ) @@int64@@ = ( unsigned int ) @@int@@ ; else @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; return @@int64@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
char * __fastcall randread_new ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { size_t @@sizet@@ ; FILE * @@FILE@@ ; char * @@char@@ ; if ( ! @@unsignedint64@@ ) return ( char * ) simple_new ( Number L , Number L ) ; @@FILE@@ = Number L ; if ( @@int64@@ ) { @@FILE@@ = ( FILE * ) fopen_safer ( @@int64@@ , & off_7CD0 ) ; if ( ! @@FILE@@ ) return Number L ; } @@char@@ = ( char * ) simple_new ( ( __int64 ) @@FILE@@ , @@int64@@ ) ; if ( @@FILE@@ ) { @@sizet@@ = Number L ; if ( @@unsignedint64@@ <= Number ) @@sizet@@ = @@unsignedint64@@ ; setvbuf ( @@FILE@@ , @@char@@ + Number , Number , @@sizet@@ ) ; } else { * ( ( _QWORD * ) @@char@@ + Number ) = Number L ; isaac_seed ( @@char@@ + Number ) ; } return @@char@@ ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
size_t * __fastcall readisaac ( size_t * @@sizet@@ , char * @@char@@ , size_t @@sizet@@ ) { size_t * @@sizet@@ ; size_t @@sizet@@ ; char * @@char@@ ; for ( @@sizet@@ = * @@sizet@@ ; @@sizet@@ > @@sizet@@ ; @@sizet@@ = Number L ) { memcpy ( @@char@@ , ( char * ) @@sizet@@ + Number - @@sizet@@ + Number , @@sizet@@ ) ; @@char@@ += @@sizet@@ ; @@sizet@@ -= @@sizet@@ ; if ( ( ( unsigned __int8 ) @@char@@ & Number ) == Number ) { @@char@@ = @@char@@ ; while ( @@sizet@@ > Number ) { isaac_refill ( @@sizet@@ + Number , @@char@@ ) ; @@char@@ += Number ; @@sizet@@ -= Number L ; if ( ! @@sizet@@ ) { @@sizet@@ = @@sizet@@ ; * @@sizet@@ = Number L ; return @@sizet@@ ; } } @@char@@ = @@char@@ ; } isaac_refill ( @@sizet@@ + Number , ( char * ) @@sizet@@ + Number ) ; } memcpy ( @@char@@ , ( char * ) @@sizet@@ + Number - @@sizet@@ + Number , @@sizet@@ ) ; @@sizet@@ = @@sizet@@ ; * @@sizet@@ = @@sizet@@ - @@sizet@@ ; return @@sizet@@ ; }
bool __fastcall is_basic_2 ( unsigned __int8 @@unsignedint8@@ ) { return ( ( is_basic_table [ @@unsignedint8@@ >> Number ] >> ( @@unsignedint8@@ & Number ) ) & Number ) != Number ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
size_t __fastcall randread ( _QWORD * @@QWORD@@ , char * @@char@@ , size_t @@sizet@@ ) { size_t @@sizet@@ ; if ( * @@QWORD@@ ) @@sizet@@ = readsource ( ( __int64 ) @@QWORD@@ , @@char@@ , @@sizet@@ ) ; else @@sizet@@ = ( size_t ) readisaac ( @@QWORD@@ + Number , @@char@@ , @@sizet@@ ) ; return @@sizet@@ ; }
__int64 __fastcall file_name_concat ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = mfile_name_concat ( @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( ! @@int64@@ ) xalloc_die ( ) ; return @@int64@@ ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
bool __fastcall mode_changed ( char * @@char@@ , unsigned __int16 @@unsignedint16@@ , unsigned __int16 @@unsignedint16@@ ) { __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; unsigned __int16 @@unsignedint16@@ ; struct stat @@structstat@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint16@@ = @@unsignedint16@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( ( @@unsignedint16@@ & Number ) == Number ) return ( ( @@unsignedint16@@ ^ @@unsignedint16@@ ) & Number ) != Number ; if ( ! ( unsigned int ) stat ( @@char@@ , & @@structstat@@ ) ) { @@unsignedint16@@ = @@structstat@@ . st_mode ; return ( ( @@unsignedint16@@ ^ @@unsignedint16@@ ) & Number ) != Number ; } if ( force_silent != Number ) { @@int64@@ = quote ( @@char@@ ) ; @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ , @@int64@@ ) ; } return Number ; }
_BYTE * __fastcall longest_relative_suffix ( _BYTE * @@BYTE@@ ) { while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; return @@BYTE@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall rpl_fcntl ( int @@int@@ , int @@int@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ ) { int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; if ( @@int@@ != Number ) return ( unsigned int ) fcntl ( @@int@@ , @@int@@ , @@int64@@ ) ; @@int@@ = @@int64@@ ; if ( have_dupfd_cloexec_2895 < Number ) { @@int@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@int@@ , Number , @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ ) ; } else { @@int@@ = fcntl ( @@int@@ , Number , ( unsigned int ) @@int64@@ ) ; if ( @@int@@ < Number && * __errno_location ( ) == Number ) { @@int@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@int@@ , Number , @@int@@ , @@int@@ , @@int@@ , @@int@@ ) ; if ( @@int@@ < Number ) return ( unsigned int ) @@int@@ ; have_dupfd_cloexec_2895 = Number ; } else { have_dupfd_cloexec_2895 = Number ; } } if ( @@int@@ >= Number && have_dupfd_cloexec_2895 == Number ) { @@int@@ = fcntl ( @@int@@ , Number ) ; if ( @@int@@ < Number || fcntl ( @@int@@ , Number , @@int@@ | Number ) == Number ) { @@int@@ = * __errno_location ( ) ; close ( @@int@@ ) ; * __errno_location ( ) = @@int@@ ; @@int@@ = Number ; } } return ( unsigned int ) @@int@@ ; }
unsigned __int64 __fastcall isaac_seed ( _DWORD * @@DWORD@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; isaac_seed_start ( @@DWORD@@ ) ; LODWORD ( @@int64@@ ) = getpid ( ) ; isaac_seed_data ( @@DWORD@@ , ( __int64 ) & @@int64@@ , Number ) ; LODWORD ( @@int64@@ ) = getppid ( ) ; isaac_seed_data ( @@DWORD@@ , ( __int64 ) & @@int64@@ , Number ) ; LODWORD ( @@int64@@ ) = getuid ( ) ; isaac_seed_data ( @@DWORD@@ , ( __int64 ) & @@int64@@ , Number ) ; LODWORD ( @@int64@@ ) = getgid ( ) ; isaac_seed_data ( @@DWORD@@ , ( __int64 ) & @@int64@@ , Number ) ; @@int64@@ = gethrxtime ( ) ; isaac_seed_data ( @@DWORD@@ , ( __int64 ) & @@int64@@ , Number ) ; isaac_seed_finish ( @@DWORD@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall setup_dir ( __int64 @@int64@@ ) { if ( ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number ) { * ( _QWORD * ) ( @@int64@@ + Number ) = hash_initialize ( Number L , Number L , AD_hash , AD_compare , & free ) ; if ( ! * ( _QWORD * ) ( @@int64@@ + Number ) ) return Number L ; } else { * ( _QWORD * ) ( @@int64@@ + Number ) = malloc ( Number ) ; if ( ! * ( _QWORD * ) ( @@int64@@ + Number ) ) return Number L ; cycle_check_init ( * ( _QWORD * ) ( @@int64@@ + Number ) ) ; } return Number L ; }
FILE * __fastcall freopen_safer ( const char * @@constchar@@ , const char * @@constchar@@ , FILE * @@FILE@@ ) { int @@int@@ ; FILE * @@FILE@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; int @@int@@ ; @@char@@ = Number ; @@char@@ = Number ; @@char@@ = Number ; @@int@@ = fileno ( @@FILE@@ ) ; if ( @@int@@ != Number ) { if ( @@int@@ != Number ) { if ( ! @@int@@ ) goto LABEL_10 ; if ( dup2 ( Number , Number ) != Number ) @@char@@ = Number ; } if ( dup2 ( Number , Number ) != Number ) @@char@@ = Number ; } if ( dup2 ( Number , Number ) ) @@char@@ = Number ; LABEL_10 : if ( @@char@@ && ( unsigned __int8 ) protect_fd ( Number ) != Number ) { @@FILE@@ = Number L ; } else if ( @@char@@ && ( unsigned __int8 ) protect_fd ( Number ) != Number ) { @@FILE@@ = Number L ; } else if ( @@char@@ && ( unsigned __int8 ) protect_fd ( Number ) != Number ) { @@FILE@@ = Number L ; } else { @@FILE@@ = freopen ( @@constchar@@ , @@constchar@@ , @@FILE@@ ) ; } @@int@@ = * __errno_location ( ) ; if ( @@char@@ ) close ( Number ) ; if ( @@char@@ ) close ( Number ) ; if ( @@char@@ ) close ( Number ) ; if ( ! @@FILE@@ ) * __errno_location ( ) = @@int@@ ; return @@FILE@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall cwd_advance_fd ( __int64 @@int64@@ , int @@int@@ , char @@char@@ ) { __int64 @@int64@@ ; int @@int@@ ; int @@int@@ ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) ; if ( @@int@@ == @@int@@ && @@int@@ != Number ) abort ( ) ; if ( @@char@@ ) { @@int@@ = i_ring_push ( @@int64@@ + Number , ( unsigned int ) @@int@@ ) ; if ( @@int@@ >= Number ) close ( @@int@@ ) ; } else if ( ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) == Number && @@int@@ >= Number ) { close ( @@int@@ ) ; } @@int64@@ = @@int64@@ ; * ( _DWORD * ) ( @@int64@@ + Number ) = @@int@@ ; return @@int64@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_2060C8 ; @@int648@@ [ Number ] = qword_2060D0 ; @@int648@@ [ Number ] = qword_2060D8 ; @@int648@@ [ Number ] = qword_2060E0 ; @@int648@@ [ Number ] = qword_2060E8 ; @@int648@@ [ Number ] = qword_2060F0 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
unsigned __int64 __fastcall LCO_hash ( _QWORD * @@QWORD@@ , unsigned __int64 @@unsignedint64@@ ) { return * @@QWORD@@ % @@unsignedint64@@ ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
bool __fastcall LCO_compare ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ ) { return * @@QWORD@@ == * @@QWORD@@ ; }
_BOOL8 __fastcall AD_compare ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ ) { return @@QWORD@@ [ Number ] == @@QWORD@@ [ Number ] && * @@QWORD@@ == * @@QWORD@@ ; }
_QWORD * __fastcall randint_new ( __int64 @@int64@@ , __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; @@QWORD@@ = xmalloc ( Number , @@int64@@ ) ; * @@QWORD@@ = @@int64@@ ; @@QWORD@@ [ Number ] = Number L ; @@QWORD@@ [ Number ] = @@QWORD@@ [ Number ] ; return @@QWORD@@ ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
void __fastcall free_dir ( __int64 @@int64@@ ) { if ( ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number ) { if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) hash_free ( * ( _QWORD * ) ( @@int64@@ + Number ) ) ; } else { free ( * ( void * * ) ( @@int64@@ + Number ) ) ; } }
void __fastcall randint_free ( void * @@void@@ ) { memset ( @@void@@ , Number , Number ) ; free ( @@void@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall fts_compare_ino ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; if ( * ( _QWORD * ) ( * ( _QWORD * ) @@int64@@ + Number L ) < * ( _QWORD * ) ( * ( _QWORD * ) @@int64@@ + Number L ) ) @@int64@@ = Number ; else @@int64@@ = * ( _QWORD * ) ( * ( _QWORD * ) @@int64@@ + Number L ) < * ( _QWORD * ) ( * ( _QWORD * ) @@int64@@ + Number L ) ; return @@int64@@ ; }
_QWORD * __fastcall simple_new ( __int64 @@int64@@ , __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; @@QWORD@@ = xmalloc ( Number , @@int64@@ ) ; * @@QWORD@@ = @@int64@@ ; @@QWORD@@ [ Number ] = randread_error ; @@QWORD@@ [ Number ] = @@int64@@ ; return @@QWORD@@ ; }
__int64 __fastcall fts_set_stat_required ( __int64 @@int64@@ , char @@char@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; if ( * ( _WORD * ) ( @@int64@@ + Number ) != Number ) abort ( ) ; if ( @@char@@ ) @@int64@@ = Number L ; else @@int64@@ = Number L ; @@int64@@ = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; return @@int64@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
__int64 __fastcall decode_switches ( int @@int@@ , char * const * @@charconst@@ ) { const char * @@constchar@@ ; const char * @@constchar@@ ; __int64 @@int64@@ ; char * @@char@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; int @@int@@ ; @@unsignedint@@ = Number ; if ( uname_mode == Number ) { @@int@@ = getopt_long ( @@int@@ , @@charconst@@ , & locale , & arch_long_options , Number L ) ; if ( @@int@@ != Number ) { if ( @@int@@ != Number ) { if ( @@int@@ == Number ) usage ( Number ) ; usage ( Number ) ; } if ( uname_mode == Number ) @@constchar@@ = String ; else @@constchar@@ = String ; version_etc ( ( _DWORD ) stdout , ( _DWORD ) @@constchar@@ , ( unsigned int ) String , ( _DWORD ) Version , ( unsigned int ) String , ( unsigned int ) String , Number ) ; exit ( Number ) ; } @@unsignedint@@ = Number ; } else { while ( Number ) { @@int@@ = getopt_long ( @@int@@ , @@charconst@@ , String , & uname_long_options , Number L ) ; if ( @@int@@ == Number ) break ; if ( @@int@@ == Number ) { @@unsignedint@@ |= Number ; } else if ( @@int@@ > Number ) { if ( @@int@@ == Number ) { @@unsignedint@@ |= Number ; } else if ( @@int@@ > Number ) { if ( @@int@@ == Number ) { @@unsignedint@@ |= Number ; } else { if ( @@int@@ != Number ) goto LABEL_44 ; @@unsignedint@@ |= Number ; } } else if ( @@int@@ == Number ) { @@unsignedint@@ |= Number ; } else { if ( @@int@@ != Number ) goto LABEL_44 ; @@unsignedint@@ |= Number ; } } else if ( @@int@@ == Number ) { @@unsignedint@@ = Number ; } else { if ( @@int@@ <= Number ) { if ( @@int@@ == Number ) { if ( uname_mode == Number ) @@constchar@@ = String ; else @@constchar@@ = String ; version_etc ( ( _DWORD ) stdout , ( _DWORD ) @@constchar@@ , ( unsigned int ) String , ( _DWORD ) Version , ( unsigned int ) String , Number , ( char ) @@charconst@@ ) ; exit ( Number ) ; } if ( @@int@@ == Number ) usage ( Number ) ; LABEL_44 : usage ( Number ) ; } if ( @@int@@ == Number ) { @@unsignedint@@ |= Number ; } else { if ( @@int@@ != Number ) goto LABEL_44 ; @@unsignedint@@ |= Number ; } } } } if ( @@int@@ != optind ) { @@int64@@ = quote ( @@charconst@@ [ optind ] ) ; @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ , @@int64@@ ) ; usage ( Number ) ; } return @@unsignedint@@ ; }
__int64 __fastcall fts_palloc ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; void * @@void@@ ; @@unsignedint64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) + @@int64@@ + Number ; if ( @@unsignedint64@@ >= * ( _QWORD * ) ( @@int64@@ + Number ) ) { * ( _QWORD * ) ( @@int64@@ + Number ) = @@unsignedint64@@ ; @@void@@ = realloc ( * ( void * * ) ( @@int64@@ + Number ) , * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( @@void@@ ) { * ( _QWORD * ) ( @@int64@@ + Number ) = @@void@@ ; @@int64@@ = Number L ; } else { free ( * ( void * * ) ( @@int64@@ + Number ) ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number L ; @@int64@@ = Number L ; } } else { free ( * ( void * * ) ( @@int64@@ + Number ) ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number L ; * __errno_location ( ) = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
size_t __fastcall readsource ( __int64 @@int64@@ , char * @@char@@ , size_t @@sizet@@ ) { size_t @@sizet@@ ; int @@int@@ ; int @@int@@ ; size_t @@sizet@@ ; while ( Number ) { @@sizet@@ = fread_unlocked ( @@char@@ , Number , @@sizet@@ , * ( FILE * * ) @@int64@@ ) ; @@int@@ = * __errno_location ( ) ; @@char@@ += @@sizet@@ ; @@sizet@@ = @@sizet@@ ; @@sizet@@ -= @@sizet@@ ; if ( ! @@sizet@@ ) break ; if ( ferror_unlocked ( * ( FILE * * ) @@int64@@ ) ) @@int@@ = @@int@@ ; else @@int@@ = Number ; * __errno_location ( ) = @@int@@ ; ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@int64@@ + Number ) ) ( * ( _QWORD * ) ( @@int64@@ + Number ) ) ; } return @@sizet@@ ; }
__int64 __fastcall diropen ( __int64 @@int64@@ , int @@int@@ , __int64 a3 , int @@int@@ , int @@int@@ , int @@int@@ ) { int @@int@@ ; int @@int@@ ; unsigned int @@unsignedint@@ ; @@int@@ = ( * ( _DWORD * ) ( @@int64@@ + Number ) << Number ) & Number | Number ; if ( ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number ) @@int@@ = openat_safer ( * ( _DWORD * ) ( @@int64@@ + Number ) , @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int@@ ) ; else @@int@@ = open_safer ( @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int@@ ) ; @@unsignedint@@ = @@int@@ ; if ( @@int@@ >= Number ) set_cloexec_flag ( ( unsigned int ) @@int@@ , Number L ) ; return @@unsignedint@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_207038 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall hash_get_n_buckets ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall hash_get_n_entries ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 __fastcall set_stat_type ( __int64 @@int64@@ , int @@int@@ ) { __int64 @@int64@@ ; int @@int@@ ; switch ( @@int@@ ) { case Number : @@int@@ = Number ; break ; case Number : @@int@@ = Number ; break ; case Number : @@int@@ = Number ; break ; case Number : @@int@@ = Number ; break ; case Number : @@int@@ = Number ; break ; case Number : @@int@@ = Number ; break ; case Number : @@int@@ = Number ; break ; default : @@int@@ = Number ; break ; } @@int64@@ = @@int64@@ ; * ( _DWORD * ) ( @@int64@@ + Number ) = @@int@@ ; return @@int64@@ ; }
_DWORD * __fastcall isaac_seed_data ( _DWORD * @@DWORD@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { _DWORD * @@DWORD@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; char * @@char@@ ; char * @@char@@ ; for ( @@unsignedint64@@ = Number L - ( unsigned int ) @@DWORD@@ [ Number ] ; @@unsignedint64@@ > @@unsignedint64@@ ; @@unsignedint64@@ = Number L ) { @@char@@ = ( char * ) @@DWORD@@ + ( unsigned int ) @@DWORD@@ [ Number ] ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@unsignedint64@@ ; ++ @@unsignedint64@@ ) { @@char@@ [ @@unsignedint64@@ ] ^= * ( _BYTE * ) ( @@int64@@ + @@unsignedint64@@ ) ; } @@int64@@ += @@unsignedint64@@ ; @@unsignedint64@@ -= @@unsignedint64@@ ; isaac_mix ( @@DWORD@@ , ( __int64 ) @@DWORD@@ ) ; @@DWORD@@ [ Number ] = Number ; } @@char@@ = ( char * ) @@DWORD@@ + ( unsigned int ) @@DWORD@@ [ Number ] ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@unsignedint64@@ ; ++ @@unsignedint64@@ ) { @@char@@ [ @@unsignedint64@@ ] ^= * ( _BYTE * ) ( @@int64@@ + @@unsignedint64@@ ) ; } @@DWORD@@ = @@DWORD@@ ; @@DWORD@@ [ Number ] = @@unsignedint64@@ ; return @@DWORD@@ ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
_BOOL8 __fastcall hash_table_ok ( __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; @@int64@@ = Number L ; @@int64@@ = Number L ; for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { @@QWORD@@ = @@QWORD@@ ; ++ @@int64@@ ; ++ @@int64@@ ; while ( Number ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; if ( ! @@QWORD@@ ) break ; ++ @@int64@@ ; } } } return @@int64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) && @@int64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
unsigned __int64 __fastcall describe_change ( __int64 @@int64@@ , unsigned int @@unsignedint@@ , int @@int@@ ) { __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; const char * @@constchar@@ ; char @@char@@ ; _BYTE @@BYTE11@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( @@int@@ ) { strmode ( @@unsignedint@@ , & @@char@@ ) ; @@BYTE11@@ [ Number ] = Number ; switch ( @@int@@ ) { case Number : @@constchar@@ = gettext ( String ) ; break ; case Number : @@constchar@@ = gettext ( String ) ; break ; case Number : @@constchar@@ = gettext ( String ) ; break ; default : abort ( ) ; } @@int64@@ = quote ( @@int64@@ ) ; printf ( @@constchar@@ , @@int64@@ , @@unsignedint@@ & Number , @@BYTE11@@ ) ; } else { @@int64@@ = quote ( @@int64@@ ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall fts_padjust ( __int64 @@int64@@ , _QWORD * @@QWORD@@ ) { _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; for ( @@QWORD@@ = * ( _QWORD * * ) ( @@int64@@ + Number ) ; @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { if ( ( _QWORD * ) @@QWORD@@ [ Number ] != @@QWORD@@ + Number ) @@QWORD@@ [ Number ] = @@int64@@ + @@QWORD@@ [ Number ] - @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; } while ( Number ) { @@int64@@ = @@QWORD@@ [ Number ] ; if ( @@int64@@ < Number ) break ; if ( ( _QWORD * ) @@QWORD@@ [ Number ] != @@QWORD@@ + Number ) @@QWORD@@ [ Number ] = @@int64@@ + @@QWORD@@ [ Number ] - @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; if ( @@QWORD@@ [ Number ] ) @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; else @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; @@QWORD@@ = @@QWORD@@ ; } return @@int64@@ ; }
__int64 __fastcall hash_do_for_each ( __int64 @@int64@@ , unsigned __int8 ( __fastcall * @ @ VAR_668 @ @ unsignedint8 ( fastcall ) ( QWORD , int64 ) @ @ Hashprocessor ) ( _QWORD , __int64 ) , __int64 @@int64@@ ) { __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; @@int64@@ = Number L ; for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { for ( @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { if ( @ @ VAR_668 @ @ unsignedint8 ( fastcall ) ( QWORD , int64 ) @ @ Hashprocessor ( * @@QWORD@@ , @@int64@@ ) != Number ) return @@int64@@ ; ++ @@int64@@ ; } } } return @@int64@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_2060A8 ; @@int648@@ [ Number ] = qword_2060B0 ; @@int648@@ [ Number ] = qword_2060B8 ; @@int648@@ [ Number ] = qword_2060C0 ; @@int648@@ [ Number ] = qword_2060C8 ; @@int648@@ [ Number ] = qword_2060D0 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
__int64 __fastcall ftypelet ( __int16 @@int16@@ ) { switch ( @@int16@@ & Number ) { case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; } return Number L ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
size_t * __fastcall hash_initialize ( __int64 @@int64@@ , void * @@void@@ , unsigned __int64 ( __fastcall * @ @ VAR_698 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ) ( __int64 a1 , unsigned __int64 a2 ) , bool ( __fastcall * @ @ VAR_700 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ) ( __int64 a1 , __int64 a2 ) , size_t @@sizet@@ ) { size_t * @@sizet@@ ; bool ( __fastcall * @ @ VAR_699 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ) ( __int64 , __int64 ) ; unsigned __int64 ( __fastcall * @ @ VAR_697 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ) ( __int64 , unsigned __int64 ) ; void * @@void@@ ; size_t * @@sizet@@ ; @@void@@ = @@void@@ ; @ @ VAR_697 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher = @ @ VAR_698 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ; @ @ VAR_699 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator = @ @ VAR_700 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ; if ( ! @ @ VAR_698 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ) @ @ VAR_697 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher = raw_hasher ; if ( ! @ @ VAR_700 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ) @ @ VAR_699 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator = raw_comparator ; @@sizet@@ = ( size_t * ) malloc ( Number ) ; if ( ! @@sizet@@ ) return Number L ; if ( ! @@void@@ ) @@void@@ = & default_tuning ; @@sizet@@ [ Number ] = ( size_t ) @@void@@ ; if ( ( unsigned __int8 ) check_tuning ( ( __int64 ) @@sizet@@ ) == Number && ( @@sizet@@ [ Number ] = compute_bucket_size ( @@int64@@ , ( __int64 ) @@void@@ ) ) != Number && ( * @@sizet@@ = ( size_t ) calloc ( @@sizet@@ [ Number ] , Number ) ) != Number ) { @@sizet@@ [ Number ] = Number * @@sizet@@ [ Number ] + * @@sizet@@ ; @@sizet@@ [ Number ] = Number L ; @@sizet@@ [ Number ] = Number L ; @@sizet@@ [ Number ] = ( size_t ) @ @ VAR_697 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ; @@sizet@@ [ Number ] = ( size_t ) @ @ VAR_699 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ; @@sizet@@ [ Number ] = @@sizet@@ ; @@sizet@@ [ Number ] = Number L ; @@sizet@@ = @@sizet@@ ; } else { free ( @@sizet@@ ) ; @@sizet@@ = Number L ; } return @@sizet@@ ; }
__int64 __fastcall hash_lookup ( __int64 * @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; @@int64@@ = * @@int64@@ ; @@QWORD@@ = ( _QWORD * ) ( @@int64@@ + Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@int64@@ [ Number ] ) ( @@int64@@ , @@int64@@ [ Number ] ) ) ; if ( ( unsigned __int64 ) @@QWORD@@ >= @@int64@@ [ Number ] ) abort ( ) ; if ( ! * @@QWORD@@ ) return Number L ; for ( @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { if ( @@int64@@ == * @@QWORD@@ || ( ( unsigned __int8 ( __fastcall * ) ( __int64 , _QWORD ) ) @@int64@@ [ Number ] ) ( @@int64@@ , * @@QWORD@@ ) ) { return * @@QWORD@@ ; } } return Number L ; }
_BOOL8 __fastcall dot_or_dotdot ( _BYTE * @@BYTE@@ ) { __int64 @@int64@@ ; char @@char@@ ; if ( * @@BYTE@@ != Number ) return Number L ; if ( @@BYTE@@ [ Number ] == Number ) @@int64@@ = Number L ; else @@int64@@ = Number L ; @@char@@ = @@BYTE@@ [ @@int64@@ ] ; return ! @@char@@ || @@char@@ == Number ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_206028 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
_BYTE * __fastcall strmode ( __int16 @@int16@@ , _BYTE * @@BYTE@@ ) { char @@char@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; _BYTE * @@BYTE@@ ; * @@BYTE@@ = ftypelet ( @@int16@@ ) ; if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) { if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; } else if ( ( @@int16@@ & Number ) != Number ) { @@char@@ = Number ; } else { @@char@@ = Number ; } @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) { if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; } else if ( ( @@int16@@ & Number ) != Number ) { @@char@@ = Number ; } else { @@char@@ = Number ; } @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) { if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; } else if ( ( @@int16@@ & Number ) != Number ) { @@char@@ = Number ; } else { @@char@@ = Number ; } @@BYTE@@ [ Number ] = @@char@@ ; @@BYTE@@ [ Number ] = Number ; @@BYTE@@ = @@BYTE@@ + Number ; @@BYTE@@ [ Number ] = Number ; return @@BYTE@@ ; }
__int64 __fastcall i_ring_push ( __int64 @@int64@@ , int @@int@@ ) { int @@int@@ ; unsigned int @@unsignedint@@ ; @@int@@ = ( ( unsigned __int8 ) * ( _DWORD * ) ( @@int64@@ + Number ) + ( * ( _BYTE * ) ( @@int64@@ + Number ) ^ Number ) ) & Number ; @@unsignedint@@ = * ( _DWORD * ) ( @@int64@@ + Number L * ( ( ( unsigned __int8 ) * ( _DWORD * ) ( @@int64@@ + Number ) + ( * ( _BYTE * ) ( @@int64@@ + Number ) ^ Number ) ) & Number ) ) ; * ( _DWORD * ) ( @@int64@@ + Number L * ( ( ( unsigned __int8 ) * ( _DWORD * ) ( @@int64@@ + Number ) + ( * ( _BYTE * ) ( @@int64@@ + Number ) ^ Number ) ) & Number ) ) = @@int@@ ; * ( _DWORD * ) ( @@int64@@ + Number ) = @@int@@ ; if ( @@int@@ == * ( _DWORD * ) ( @@int64@@ + Number ) ) * ( _DWORD * ) ( @@int64@@ + Number ) = ( ( unsigned __int8 ) * ( _DWORD * ) ( @@int64@@ + Number ) + ( * ( _BYTE * ) ( @@int64@@ + Number ) ^ Number ) ) & Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = Number ; return @@unsignedint@@ ; }
__int64 __fastcall next_prime ( unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = @@unsignedint64@@ ; if ( @@unsignedint64@@ <= Number ) @@int64@@ = Number L ; for ( @@int64@@ = @@int64@@ | Number ; @@int64@@ != Number && ! is_prime ( @@int64@@ ) ; @@int64@@ += Number L ) { ; } return @@int64@@ ; }
_BOOL8 __fastcall copy_dir ( __int64 @@int64@@ , __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ , _QWORD * @@QWORD@@ , int @@int@@ , __int64 @@int64@@ , __int64 @@int64@@ , bool * @@bool@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; _BOOL8 @@BOOL8@@ ; unsigned __int8 @@unsignedint8@@ ; size_t @@sizet@@ ; char @@char@@ ; bool @@bool@@ ; char * @@char@@ ; void * @@void@@ ; void * @@void@@ ; void * @@void@@ ; __int64 @@int6412@@ [ Number ] ; @@int6412@@ [ Number ] = __readfsqword ( Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int6412@@ [ Number ] = * ( _QWORD * ) @@int64@@ ; @@int6412@@ [ Number ] = @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int6412@@ [ Number ] = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int6412@@ [ Number ] = @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int6412@@ [ Number ] = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int6412@@ [ Number ] = @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int6412@@ [ Number ] = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int6412@@ [ Number ] = @@int64@@ ; @@int6412@@ [ Number ] = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@bool@@ = Number ; @@void@@ = ( void * ) savedir ( @@int64@@ ) ; if ( @@void@@ ) { if ( * ( _DWORD * ) ( @@int64@@ + Number ) == Number ) HIDWORD ( @@int6412@@ [ Number ] ) = Number ; for ( @@char@@ = ( char * ) @@void@@ ; * @@char@@ ; @@char@@ += @@sizet@@ + Number ) { @@void@@ = ( void * ) file_name_concat ( @@int64@@ , @@char@@ , Number L ) ; @@void@@ = ( void * ) file_name_concat ( @@int64@@ , @@char@@ , Number L ) ; @@unsignedint8@@ = copy_internal ( ( _DWORD ) @@void@@ , ( _DWORD ) @@void@@ , @@unsignedint8@@ , * @@QWORD@@ , @@int@@ , ( unsigned int ) @@int6412@@ , Number , @@int64@@ , ( __int64 ) & @@char@@ , Number L ) ; @@bool@@ = ( @@bool@@ & @@unsignedint8@@ ) != Number ; * @@bool@@ = ( unsigned __int8 ) ( * @@bool@@ | @@char@@ ) != Number ; free ( @@void@@ ) ; free ( @@void@@ ) ; if ( @@char@@ ) break ; @@sizet@@ = strlen ( @@char@@ ) ; } free ( @@void@@ ) ; @@BOOL8@@ = @@bool@@ ; } else { @@int64@@ = quote ( @@int64@@ ) ; @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ , @@int64@@ ) ; @@BOOL8@@ = Number L ; } return @@BOOL8@@ ; }
__int64 __fastcall is_ancestor ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ ) { while ( @@QWORD@@ ) { if ( @@QWORD@@ [ Number ] == @@QWORD@@ [ Number ] && @@QWORD@@ [ Number ] == * @@QWORD@@ ) { return Number L ; } @@QWORD@@ = ( _QWORD * ) * @@QWORD@@ ; } return Number L ; }
__int64 __fastcall hash_get_n_buckets_used ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 __fastcall mode_create_from_ref ( char * @@char@@ ) { __int64 @@int64@@ ; struct stat @@structstat@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( ( unsigned int ) stat ( @@char@@ , & @@structstat@@ ) ) @@int64@@ = Number L ; else @@int64@@ = make_node_op_equals ( @@structstat@@ . st_mode , Number ) ; return @@int64@@ ; }
void __fastcall hash_free ( __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) && * ( _QWORD * ) ( @@int64@@ + Number ) ) { for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { for ( @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@int64@@ + Number ) ) ( * @@QWORD@@ ) ; } } } } for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { for ( @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; @@QWORD@@ ; @@QWORD@@ = @@QWORD@@ ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; free ( @@QWORD@@ ) ; } } for ( @@QWORD@@ = * ( _QWORD * * ) ( @@int64@@ + Number ) ; @@QWORD@@ ; @@QWORD@@ = @@QWORD@@ ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; free ( @@QWORD@@ ) ; } free ( * ( void * * ) @@int64@@ ) ; free ( ( void * ) @@int64@@ ) ; }
__int64 __fastcall i_ring_empty ( __int64 @@int64@@ ) { return * ( unsigned __int8 * ) ( @@int64@@ + Number ) ; }
__int64 __fastcall openat_safer ( int @@int@@ , const char * @@constchar@@ , char @@char@@ , unsigned int @@unsignedint@@ ) { unsigned int @@unsignedint@@ ; unsigned int @@unsignedint@@ ; @@unsignedint@@ = Number ; if ( ( @@char@@ & Number ) != Number ) @@unsignedint@@ = @@unsignedint@@ ; @@unsignedint@@ = openat ( @@int@@ , @@constchar@@ , @@char@@ , @@unsignedint@@ ) ; return fd_safer ( @@unsignedint@@ ) ; }
__int64 __fastcall copy_acl ( __int64 @@int64@@ , unsigned int @@unsignedint@@ , const char * @@constchar@@ , int @@int@@ , __mode_t @@modet@@ ) { int @@int@@ ; const char * @@constchar@@ ; int * @@int@@ ; __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; __int64 @@int64@@ ; @@int@@ = qcopy_acl ( @@int64@@ , @@unsignedint@@ , @@constchar@@ , @@int@@ , @@modet@@ ) ; if ( @@int@@ == Number ) { @@constchar@@ = ( const char * ) quote ( @@int64@@ ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , String , @@constchar@@ ) ; @@int64@@ = Number ; } else if ( @@int@@ == Number ) { @@int64@@ = quote ( @@constchar@@ ) ; @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ , @@int64@@ ) ; @@int64@@ = Number ; } else { @@int64@@ = Number L ; } return @@int64@@ ; }
unsigned __int64 __fastcall hash_get_max_bucket_length ( __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = Number L ; for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { @@QWORD@@ = @@QWORD@@ ; for ( @@unsignedint64@@ = Number L ; ; ++ @@unsignedint64@@ ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; if ( ! @@QWORD@@ ) break ; } if ( @@unsignedint64@@ > @@unsignedint64@@ ) @@unsignedint64@@ = @@unsignedint64@@ ; } } return @@unsignedint64@@ ; }
_BOOL8 __fastcall abandon_move ( __int64 @@int64@@ , const char * @@constchar@@ , __int64 @@int64@@ ) { bool @@bool@@ ; if ( ! * ( _BYTE * ) ( @@int64@@ + Number ) ) __assert_fail ( String , String , Number , String ) ; @@bool@@ = Number ; if ( * ( _DWORD * ) ( @@int64@@ + Number ) != Number ) { if ( * ( _DWORD * ) ( @@int64@@ + Number ) != Number && ( * ( _DWORD * ) ( @@int64@@ + Number ) != Number || ! * ( _BYTE * ) ( @@int64@@ + Number ) || writable_destination ( @@constchar@@ , * ( _DWORD * ) ( @@int64@@ + Number ) ) ) || ( overwrite_prompt ( @@constchar@@ , @@int64@@ ) , ( unsigned __int8 ) yesno ( ) == Number ) ) { @@bool@@ = Number ; } } return @@bool@@ ; }
__int64 __fastcall i_ring_pop ( __int64 @@int64@@ ) { unsigned int @@unsignedint@@ ; if ( ( unsigned __int8 ) i_ring_empty ( @@int64@@ ) ) abort ( ) ; @@unsignedint@@ = * ( _DWORD * ) ( @@int64@@ + Number L * * ( unsigned int * ) ( @@int64@@ + Number ) ) ; * ( _DWORD * ) ( @@int64@@ + Number L * * ( unsigned int * ) ( @@int64@@ + Number ) ) = * ( _DWORD * ) ( @@int64@@ + Number ) ; if ( * ( _DWORD * ) ( @@int64@@ + Number ) == * ( _DWORD * ) ( @@int64@@ + Number ) ) * ( _BYTE * ) ( @@int64@@ + Number ) = Number ; else * ( _DWORD * ) ( @@int64@@ + Number ) = ( ( unsigned __int8 ) * ( _DWORD * ) ( @@int64@@ + Number ) + Number ) & Number ; return @@unsignedint@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
_BOOL8 __fastcall triple_compare ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ ) { return @@QWORD@@ [ Number ] == @@QWORD@@ [ Number ] && @@QWORD@@ [ Number ] == @@QWORD@@ [ Number ] && ( unsigned __int8 ) same_name ( * @@QWORD@@ , * @@QWORD@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
_BOOL8 __fastcall owner_failure_ok ( __int64 @@int64@@ ) { return ( * __errno_location ( ) == Number || * __errno_location ( ) == Number ) && * ( _BYTE * ) ( @@int64@@ + Number ) != Number ; }
__int64 __fastcall make_node_op_equals ( int @@int@@ , int @@int@@ ) { __int64 @@int64@@ ; @@int64@@ = xmalloc ( Number L ) ; * ( _BYTE * ) @@int64@@ = Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = Number ; * ( _DWORD * ) ( @@int64@@ + Number ) = Number ; * ( _DWORD * ) ( @@int64@@ + Number ) = @@int@@ ; * ( _DWORD * ) ( @@int64@@ + Number ) = @@int@@ ; * ( _BYTE * ) ( @@int64@@ + Number ) = Number ; return @@int64@@ ; }
unsigned __int64 __fastcall hash_get_entries ( __int64 @@int64@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; @@unsignedint64@@ = Number L ; for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { for ( @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { if ( @@unsignedint64@@ >= @@unsignedint64@@ ) return @@unsignedint64@@ ; @@int64@@ = @@unsignedint64@@ ++ ; * ( _QWORD * ) ( @@int64@@ + Number * @@int64@@ ) = * @@QWORD@@ ; } } } return @@unsignedint64@@ ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
bool __fastcall is_basic_0 ( unsigned __int8 @@unsignedint8@@ ) { return ( ( is_basic_table [ @@unsignedint8@@ >> Number ] >> ( @@unsignedint8@@ & Number ) ) & Number ) != Number ; }
_BOOL8 __fastcall src_to_dest_compare ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ ) { return * @@QWORD@@ == * @@QWORD@@ && @@QWORD@@ [ Number ] == @@QWORD@@ [ Number ] ; }
__int64 __fastcall open_safer ( const char * @@constchar@@ , char @@char@@ , unsigned int @@unsignedint@@ ) { unsigned int @@unsignedint@@ ; unsigned int @@unsignedint@@ ; @@unsignedint@@ = Number ; if ( ( @@char@@ & Number ) != Number ) @@unsignedint@@ = @@unsignedint@@ ; @@unsignedint@@ = open ( @@constchar@@ , @@char@@ , @@unsignedint@@ ) ; return fd_safer ( @@unsignedint@@ ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) { ; } return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
unsigned __int64 __fastcall compute_bucket_size ( __int64 @@int64@@ , __int64 @@int64@@ ) { float @@float@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; float @@float@@ ; @@unsignedint64@@ = @@int64@@ ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) != Number ) { if ( @@int64@@ < Number ) @@float@@ = ( float ) ( @@int64@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@int64@@ >> Number ) ) + ( float ) ( @@int64@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@int64@@ >> Number ) ) ; else @@float@@ = ( float ) ( int ) @@int64@@ ; @@float@@ = @@float@@ / * ( float * ) ( @@int64@@ + Number ) ; if ( @@float@@ >= Number ) return Number L ; if ( @@float@@ >= Number ) @@unsignedint64@@ = ( unsigned int ) ( int ) ( float ) ( @@float@@ - Number ) ^ Number ; else @@unsignedint64@@ = ( unsigned int ) ( int ) @@float@@ ; } @@unsignedint64@@ = next_prime ( @@unsignedint64@@ ) ; if ( @@unsignedint64@@ <= Number ) @@unsignedint64@@ = @@unsignedint64@@ ; else @@unsignedint64@@ = Number L ; return @@unsignedint64@@ ; }
__int64 __fastcall src_to_dest_lookup ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int644@@ [ Number ] ; @@int644@@ [ Number ] = __readfsqword ( Number ) ; @@int644@@ [ Number ] = @@int64@@ ; @@int644@@ [ Number ] = @@int64@@ ; @@int64@@ = hash_lookup ( src_to_dest , @@int644@@ ) ; if ( @@int64@@ ) @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; else @@int64@@ = Number L ; return @@int64@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
unsigned __int64 __fastcall buffer_lcm ( unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@unsignedint64@@ ) { if ( @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ ; for ( @@unsignedint64@@ = @@unsignedint64@@ ; ; @@unsignedint64@@ = @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ % @@unsignedint64@@ ; if ( ! ( @@unsignedint64@@ % @@unsignedint64@@ ) ) break ; @@unsignedint64@@ = @@unsignedint64@@ ; } if ( @@unsignedint64@@ * ( @@unsignedint64@@ / @@unsignedint64@@ ) <= @@unsignedint64@@ && @@unsignedint64@@ / @@unsignedint64@@ == @@unsignedint64@@ * ( @@unsignedint64@@ / @@unsignedint64@@ ) / @@unsignedint64@@ ) { return @@unsignedint64@@ * ( @@unsignedint64@@ / @@unsignedint64@@ ) ; } } @@unsignedint64@@ = @@unsignedint64@@ ; } else { if ( @@unsignedint64@@ ) @@int64@@ = @@unsignedint64@@ ; else @@int64@@ = Number ; @@unsignedint64@@ = @@int64@@ ; } @@unsignedint64@@ = @@unsignedint64@@ ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) @@unsignedint64@@ = @@unsignedint64@@ ; return @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
char * __fastcall areadlink_with_size ( const char * @@constchar@@ , unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; char * @@char@@ ; int @@int@@ ; size_t @@sizet@@ ; char * @@char@@ ; ssize_t @@ssizet@@ ; if ( @@unsignedint64@@ >= Number ) @@int64@@ = Number L ; else @@int64@@ = @@unsignedint64@@ + Number ; @@sizet@@ = @@int64@@ ; LABEL_5 : for ( @@char@@ = ( char * ) malloc ( @@sizet@@ ) ; ; @@char@@ = ( char * ) malloc ( Number ) ) { @@char@@ = @@char@@ ; if ( ! @@char@@ ) return Number L ; @@ssizet@@ = readlink ( @@constchar@@ , @@char@@ , @@sizet@@ ) ; if ( @@ssizet@@ < Number && * __errno_location ( ) != Number ) { @@int@@ = * __errno_location ( ) ; free ( @@char@@ ) ; * __errno_location ( ) = @@int@@ ; return Number L ; } if ( @@ssizet@@ < @@sizet@@ ) { @@char@@ [ @@ssizet@@ ] = Number ; return @@char@@ ; } free ( @@char@@ ) ; if ( @@sizet@@ <= Number ) { @@sizet@@ *= Number L ; goto LABEL_5 ; } if ( @@sizet@@ > Number ) break ; @@sizet@@ = Number ; } * __errno_location ( ) = Number ; return Number L ; }
__int64 __fastcall hash_rehash ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; void * @@void@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@unsignedint64@@ = compute_bucket_size ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( ! @@unsignedint64@@ ) return Number L ; if ( @@unsignedint64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ) return Number L ; @@void@@ = calloc ( @@unsignedint64@@ , Number ) ; if ( ! @@void@@ ) return Number L ; @@unsignedint64@@ = @@unsignedint64@@ ; @@int64@@ = ( __int64 ) @@void@@ + Number * @@unsignedint64@@ ; @@int64@@ = Number L ; @@int64@@ = Number L ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( ( unsigned __int8 ) transfer_entries ( ( __int64 ) & @@void@@ , @@int64@@ , Number ) ) { free ( * ( void * * ) @@int64@@ ) ; * ( _QWORD * ) @@int64@@ = @@void@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@unsignedint64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; @@int64@@ = Number L ; } else { * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; if ( ( unsigned __int8 ) transfer_entries ( @@int64@@ , ( __int64 ) & @@void@@ , Number ) != Number || ( unsigned __int8 ) transfer_entries ( @@int64@@ , ( __int64 ) & @@void@@ , Number ) != Number ) { abort ( ) ; } free ( @@void@@ ) ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ ) { return xmalloc ( @@int64@@ ) ; }
__int64 __fastcall xstr_cd_iconv ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = str_cd_iconv ( @@int64@@ , @@int64@@ ) ; if ( ! @@int64@@ && * __errno_location ( ) == Number ) xalloc_die ( ) ; return @@int64@@ ; }
__int64 __fastcall argmatch_to_argument ( const void * @@constvoid@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; ++ @@int64@@ ) { if ( ! memcmp ( @@constvoid@@ , ( const void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) , @@sizet@@ ) ) return * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; } return Number L ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall get_version ( __int64 @@int64@@ , const char * @@constchar@@ ) { __int64 @@int64@@ ; if ( @@constchar@@ && * @@constchar@@ ) @@int64@@ = backup_types [ _xargmatch_internal ( @@int64@@ , @@constchar@@ , ( __int64 ) backup_args , ( __int64 ) backup_types , Number , ( void ( * ) ( void ) ) argmatch_die ) ] ; else @@int64@@ = Number L ; return @@int64@@ ; }
_BOOL8 __fastcall cycle_warning_required ( __int64 @@int64@@ , __int64 @@int64@@ ) { return ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number && ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) == Number || ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number && ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number && * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 __fastcall mode_adjust ( __int16 @@int16@@ , unsigned __int8 @@unsignedint8@@ , int @@int@@ , char * @@char@@ , _DWORD * @@DWORD@@ ) { int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; @@unsignedint@@ = @@int16@@ & Number ; @@int@@ = Number ; while ( @@char@@ [ Number ] ) { @@int@@ = * ( ( _DWORD * ) @@char@@ + Number ) ; if ( @@unsignedint8@@ ) @@int@@ = Number ; else @@int@@ = Number ; @@int@@ = @@int@@ & ~ * ( ( _DWORD * ) @@char@@ + Number ) ; @@int@@ = * ( ( _DWORD * ) @@char@@ + Number ) ; @@int@@ = @@char@@ [ Number ] ; if ( @@int@@ == Number ) { if ( @@unsignedint@@ & Number | @@unsignedint8@@ ) @@int@@ |= Number ; } else if ( @@int@@ == Number ) { @@int@@ = @@unsignedint@@ & @@int@@ ; if ( ( @@int@@ & Number ) != Number ) @@int@@ = Number ; else @@int@@ = Number ; if ( ( @@int@@ & Number ) != Number ) @@int@@ = Number ; else @@int@@ = Number ; @@int@@ = @@int@@ | @@int@@ ; if ( ( @@int@@ & Number ) != Number ) @@int@@ = Number ; else @@int@@ = Number ; @@int@@ = @@int@@ | @@int@@ | @@int@@ ; } if ( @@int@@ ) @@int@@ = * ( ( _DWORD * ) @@char@@ + Number ) ; else @@int@@ = ~ @@int@@ ; @@int@@ = ~ @@int@@ & @@int@@ & @@int@@ ; @@int@@ = * @@char@@ ; switch ( @@int@@ ) { case String : @@int@@ |= @@int@@ ; @@unsignedint@@ &= ~ @@int@@ ; break ; case String : if ( @@int@@ ) @@int@@ = ~ @@int@@ ; else @@int@@ = Number ; @@int@@ |= ~ ( ( unsigned __int16 ) @@int@@ | ( unsigned __int16 ) @@int@@ ) & Number ; @@unsignedint@@ = @@int@@ | ( @@int@@ | @@int@@ ) & @@unsignedint@@ ; break ; case String : @@int@@ |= @@int@@ ; @@unsignedint@@ |= @@int@@ ; break ; } @@char@@ += Number ; } if ( @@DWORD@@ ) * @@DWORD@@ = @@int@@ ; return @@unsignedint@@ ; }
__int64 __fastcall set_cloexec_flag ( int @@int@@ , char @@char@@ , __int64 a3 , int @@int@@ , int @@int@@ , int @@int@@ ) { int @@int@@ ; int @@int@@ ; int @@int@@ ; unsigned int @@unsignedint@@ ; __int64 @@int64@@ ; int @@int@@ ; @@int@@ = rpl_fcntl ( @@int@@ , Number , Number , @@int@@ , @@int@@ , @@int@@ ) ; if ( @@int@@ < Number || ( ! @@char@@ ? ( @@unsignedint@@ = @@int@@ & Number ) : ( @@unsignedint@@ = @@int@@ | Number ) , @@int@@ != @@unsignedint@@ && ( unsigned int ) rpl_fcntl ( @@int@@ , Number , @@unsignedint@@ , @@int@@ , @@int@@ , @@int@@ ) == Number ) ) { @@int64@@ = Number ; } else { @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
__int64 close_stdin ( ) { const char * @@constchar@@ ; int * @@int@@ ; int * @@int@@ ; __int64 @@int64@@ ; char @@char@@ ; char * @@char@@ ; @@char@@ = Number ; if ( freadahead ( stdin ) && ! ( unsigned int ) rpl_fseeko ( stdin , Number L , Number L ) && ( unsigned int ) rpl_fflush ( stdin ) ) @@char@@ = Number ; if ( ( unsigned int ) close_stream ( stdin ) ) @@char@@ = Number ; if ( @@char@@ ) { @@char@@ = gettext ( String ) ; if ( file_name ) { @@constchar@@ = ( const char * ) quotearg_colon ( file_name ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , String , @@constchar@@ , @@char@@ ) ; } else { @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , String , @@char@@ ) ; } } @@int64@@ = close_stdout ( ) ; if ( @@char@@ ) _exit ( exit_failure ) ; return @@int64@@ ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
__int64 __fastcall argmatch ( const char * @@constchar@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { __int64 @@int64@@ ; char @@char@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; size_t @@sizet@@ ; @@int64@@ = Number ; @@char@@ = Number ; @@sizet@@ = strlen ( @@constchar@@ ) ; for ( @@int64@@ = Number L ; * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; ++ @@int64@@ ) { if ( ! strncmp ( * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) , @@constchar@@ , @@sizet@@ ) ) { if ( @@sizet@@ == strlen ( * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) ) ) return @@int64@@ ; if ( @@int64@@ == Number ) { @@int64@@ = @@int64@@ ; } else if ( ! @@int64@@ || memcmp ( ( const void * ) ( @@sizet@@ * @@int64@@ + @@int64@@ ) , ( const void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) , @@sizet@@ ) ) { @@char@@ = Number ; } } } if ( @@char@@ ) @@int64@@ = Number ; else @@int64@@ = @@int64@@ ; return @@int64@@ ; }
_BYTE * __fastcall longest_relative_suffix ( _BYTE * @@BYTE@@ ) { while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; return @@BYTE@@ ; }
__ino_t * __fastcall get_root_dev_ino ( __ino_t * @@inot@@ ) { struct stat @@structstat@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( ( unsigned int ) lstat ( String , & @@structstat@@ ) ) return Number L ; * @@inot@@ = @@structstat@@ . st_ino ; @@inot@@ [ Number ] = @@structstat@@ . st_dev ; return @@inot@@ ; }
__int64 __fastcall cksum ( const char * @@constchar@@ , char @@char@@ ) { size_t @@sizet@@ ; int * @@int@@ ; __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; int * @@int@@ ; int * @@int@@ ; char * @@char@@ ; int * @@int@@ ; __int64 @@int64@@ ; unsigned int @@unsignedint@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; FILE * @@FILE@@ ; char * @@char@@ ; const char * @@constchar@@ ; char @@char@@ [ Number ] ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = Number L ; @@sizet@@ = Number L ; if ( ! strcmp ( @@constchar@@ , String ) ) { @@FILE@@ = stdin ; have_read_stdin = Number ; for ( @@sizet@@ = fread_unlocked ( @@char@@ , Number , Number , stdin ) ; ; @@sizet@@ = fread_unlocked ( @@char@@ , Number , Number , @@FILE@@ ) ) { @@sizet@@ = @@sizet@@ ; if ( ! @@sizet@@ ) break ; @@char@@ = @@char@@ ; if ( @@sizet@@ > @@sizet@@ + @@sizet@@ ) { @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ , @@constchar@@ ) ; } @@sizet@@ += @@sizet@@ ; while ( @@sizet@@ -- ) { @@char@@ = @@char@@ ++ ; @@int64@@ = ( @@int64@@ << Number ) ^ crctab [ ( unsigned __int8 ) ( BYTE3 ( @@int64@@ ) ^ * @@char@@ ) ] ; } if ( feof_unlocked ( @@FILE@@ ) ) break ; LABEL_11 : ; } if ( ferror_unlocked ( @@FILE@@ ) ) { @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , String , @@constchar@@ ) ; if ( strcmp ( @@constchar@@ , String ) ) fclose ( @@FILE@@ ) ; @@int64@@ = Number L ; } else if ( ! strcmp ( @@constchar@@ , String ) || fclose ( @@FILE@@ ) != Number ) { @@constchar@@ = ( const char * ) umaxtostr ( @@sizet@@ , @@char@@ ) ; while ( @@sizet@@ ) { @@int64@@ = ( @@int64@@ << Number ) ^ crctab [ ( unsigned __int8 ) ( @@sizet@@ ^ BYTE3 ( @@int64@@ ) ) ] ; @@sizet@@ >>= Number ; } @@unsignedint@@ = ~ ( _DWORD ) @@int64@@ ; if ( @@char@@ ) printf ( String , @@unsignedint@@ , @@constchar@@ , @@constchar@@ ) ; else printf ( String , @@unsignedint@@ , @@constchar@@ ) ; if ( ferror_unlocked ( stdout ) ) { @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , String , @@char@@ ) ; } @@int64@@ = Number L ; } else { @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , String , @@constchar@@ ) ; @@int64@@ = Number L ; } } else { @@FILE@@ = fopen ( @@constchar@@ , String ) ; if ( @@FILE@@ ) goto LABEL_11 ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , String , @@constchar@@ ) ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
void * __fastcall find_backup_file_name ( const char * @@constchar@@ , int @@int@@ ) { int @@int@@ ; bool @@bool@@ ; void * @@void@@ ; size_t @@sizet@@ ; __int64 @@int64@@ ; size_t @@sizet@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = strlen ( @@constchar@@ ) ; @@bool@@ = Number ; @@sizet@@ = strlen ( simple_backup_suffix ) + Number ; @@sizet@@ = @@sizet@@ ; if ( @@sizet@@ <= Number ) @@sizet@@ = Number L ; @@unsignedint64@@ = @@int64@@ + @@sizet@@ + Number ; @@void@@ = ( void * ) xmalloc ( @@unsignedint64@@ ) ; memcpy ( @@void@@ , @@constchar@@ , @@int64@@ + Number ) ; if ( @@int@@ != Number ) { @@int@@ = numbered_backup ( ( __int64 * ) & @@void@@ , @@unsignedint64@@ , @@int64@@ ) ; switch ( @@int@@ ) { case Number : @@bool@@ = Number ; break ; case Number : return @@void@@ ; case Number : @@bool@@ = @@int@@ == Number ; break ; } } if ( @@bool@@ ) memcpy ( ( char * ) @@void@@ + @@int64@@ , simple_backup_suffix , @@sizet@@ ) ; check_extension ( ( const char * ) @@void@@ , @@int64@@ , Number ) ; return @@void@@ ; }
__int64 __fastcall hash_get_n_entries ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
bool __fastcall is_zero_or_power_of_two ( __int64 @@int64@@ ) { return ( @@int64@@ & ( @@int64@@ - Number ) ) == Number ; }
__int64 __fastcall clear_ungetc_buffer_preserving_position ( _DWORD * @@DWORD@@ ) { __int64 @@int64@@ ; @@int64@@ = * @@DWORD@@ & Number ; if ( ( _DWORD ) @@int64@@ ) @@int64@@ = rpl_fseeko ( @@DWORD@@ , Number L , Number L ) ; return @@int64@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
__int64 __fastcall cycle_check ( __int64 @@int64@@ , _QWORD * @@QWORD@@ ) { if ( * ( _DWORD * ) ( @@int64@@ + Number ) != Number ) __assert_fail ( String , String , Number , String ) ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) && @@QWORD@@ [ Number ] == * ( _QWORD * ) @@int64@@ && * @@QWORD@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ) { return Number L ; } if ( is_zero_or_power_of_two ( ++ * ( _QWORD * ) ( @@int64@@ + Number ) ) ) { if ( ! * ( _QWORD * ) ( @@int64@@ + Number ) ) return Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = * @@QWORD@@ ; * ( _QWORD * ) @@int64@@ = @@QWORD@@ [ Number ] ; } return Number L ; }
_BYTE * __fastcall strmode ( __int16 @@int16@@ , _BYTE * @@BYTE@@ ) { char @@char@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; _BYTE * @@BYTE@@ ; * @@BYTE@@ = ftypelet ( @@int16@@ ) ; if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) { if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; } else if ( ( @@int16@@ & Number ) != Number ) { @@char@@ = Number ; } else { @@char@@ = Number ; } @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) { if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; } else if ( ( @@int16@@ & Number ) != Number ) { @@char@@ = Number ; } else { @@char@@ = Number ; } @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) { if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; } else if ( ( @@int16@@ & Number ) != Number ) { @@char@@ = Number ; } else { @@char@@ = Number ; } @@BYTE@@ [ Number ] = @@char@@ ; @@BYTE@@ [ Number ] = Number ; @@BYTE@@ = @@BYTE@@ + Number ; @@BYTE@@ [ Number ] = Number ; return @@BYTE@@ ; }
int __fastcall hash_print_statistics ( __int64 @@int64@@ , FILE * @@FILE@@ ) { double @@double@@ ; double @@double@@ ; double @@double@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int64@@ = hash_get_n_entries ( @@int64@@ ) ; @@int64@@ = hash_get_n_buckets ( @@int64@@ ) ; @@int64@@ = hash_get_n_buckets_used ( @@int64@@ ) ; @@unsignedint64@@ = hash_get_max_bucket_length ( @@int64@@ ) ; fprintf ( @@FILE@@ , String , @@int64@@ ) ; fprintf ( @@FILE@@ , String , @@int64@@ ) ; if ( @@int64@@ < Number ) @@double@@ = ( double ) ( int ) ( @@int64@@ & Number | ( ( unsigned __int64 ) @@int64@@ >> Number ) ) + ( double ) ( int ) ( @@int64@@ & Number | ( ( unsigned __int64 ) @@int64@@ >> Number ) ) ; else @@double@@ = ( double ) ( int ) @@int64@@ ; @@double@@ = Number * @@double@@ ; if ( @@int64@@ < Number ) @@double@@ = ( double ) ( int ) ( @@int64@@ & Number | ( ( unsigned __int64 ) @@int64@@ >> Number ) ) + ( double ) ( int ) ( @@int64@@ & Number | ( ( unsigned __int64 ) @@int64@@ >> Number ) ) ; else @@double@@ = ( double ) ( int ) @@int64@@ ; fprintf ( @@FILE@@ , String , @@int64@@ , @@double@@ / @@double@@ ) ; return fprintf ( @@FILE@@ , String , @@unsignedint64@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
unsigned __int64 __fastcall hash_get_entries ( __int64 @@int64@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; @@unsignedint64@@ = Number L ; for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { for ( @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { if ( @@unsignedint64@@ >= @@unsignedint64@@ ) return @@unsignedint64@@ ; @@int64@@ = @@unsignedint64@@ ++ ; * ( _QWORD * ) ( @@int64@@ + Number * @@int64@@ ) = * @@QWORD@@ ; } } } return @@unsignedint64@@ ; }
void __fastcall hash_free ( __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) && * ( _QWORD * ) ( @@int64@@ + Number ) ) { for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { for ( @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@int64@@ + Number ) ) ( * @@QWORD@@ ) ; } } } } for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { for ( @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; @@QWORD@@ ; @@QWORD@@ = @@QWORD@@ ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; free ( @@QWORD@@ ) ; } } for ( @@QWORD@@ = * ( _QWORD * * ) ( @@int64@@ + Number ) ; @@QWORD@@ ; @@QWORD@@ = @@QWORD@@ ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; free ( @@QWORD@@ ) ; } free ( * ( void * * ) @@int64@@ ) ; free ( ( void * ) @@int64@@ ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
unsigned __int64 __fastcall raw_hasher ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { return rotr_sz ( @@int64@@ , Number ) % @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
__int64 __fastcall linkat_follow ( unsigned int @@unsignedint@@ , _BYTE * @@BYTE@@ , int @@int@@ , const char * @@constchar@@ ) { __int64 @@int64@@ ; int @@int@@ ; int @@int@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; @@BYTE@@ = @@BYTE@@ ; @@int@@ = Number ; while ( @@int@@ -- ) { @@BYTE@@ = ( _BYTE * ) areadlinkat ( @@unsignedint@@ , @@BYTE@@ ) ; if ( ! @@BYTE@@ ) break ; if ( * @@BYTE@@ == Number ) { if ( @@BYTE@@ != @@BYTE@@ ) free ( @@BYTE@@ ) ; @@BYTE@@ = @@BYTE@@ ; } else { @@BYTE@@ = mdir_name ( @@BYTE@@ ) ; if ( @@BYTE@@ != @@BYTE@@ ) free ( @@BYTE@@ ) ; if ( ! @@BYTE@@ ) { free ( @@BYTE@@ ) ; * __errno_location ( ) = Number ; return Number ; } @@BYTE@@ = mfile_name_concat ( @@BYTE@@ , @@BYTE@@ , Number L ) ; free ( @@BYTE@@ ) ; free ( @@BYTE@@ ) ; if ( ! @@BYTE@@ ) { * __errno_location ( ) = Number ; return Number ; } } } if ( @@int@@ < Number ) { @@BYTE@@ = Number L ; * __errno_location ( ) = Number ; } if ( @@BYTE@@ || * __errno_location ( ) == Number ) { @@unsignedint@@ = linkat ( @@unsignedint@@ , @@BYTE@@ , @@int@@ , @@constchar@@ , Number ) ; if ( @@BYTE@@ != @@BYTE@@ ) { @@int@@ = * __errno_location ( ) ; free ( @@BYTE@@ ) ; * __errno_location ( ) = @@int@@ ; } @@int64@@ = @@unsignedint@@ ; } else { if ( @@BYTE@@ != @@BYTE@@ ) { @@int@@ = * __errno_location ( ) ; free ( @@BYTE@@ ) ; * __errno_location ( ) = @@int@@ ; } @@int64@@ = Number ; } return @@int64@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
unsigned __int64 __fastcall compute_bucket_size ( __int64 @@int64@@ , __int64 @@int64@@ ) { float @@float@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; float @@float@@ ; @@unsignedint64@@ = @@int64@@ ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) != Number ) { if ( @@int64@@ < Number ) @@float@@ = ( float ) ( @@int64@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@int64@@ >> Number ) ) + ( float ) ( @@int64@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@int64@@ >> Number ) ) ; else @@float@@ = ( float ) ( int ) @@int64@@ ; @@float@@ = @@float@@ / * ( float * ) ( @@int64@@ + Number ) ; if ( @@float@@ >= Number ) return Number L ; if ( @@float@@ >= Number ) @@unsignedint64@@ = ( unsigned int ) ( int ) ( float ) ( @@float@@ - Number ) ^ Number ; else @@unsignedint64@@ = ( unsigned int ) ( int ) @@float@@ ; } @@unsignedint64@@ = next_prime ( @@unsignedint64@@ ) ; if ( @@unsignedint64@@ <= Number ) @@unsignedint64@@ = @@unsignedint64@@ ; else @@unsignedint64@@ = Number L ; return @@unsignedint64@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall umaxtostr ( unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = @@int64@@ + Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = Number ; do { * ( _BYTE * ) -- @@int64@@ = @@unsignedint64@@ % Number + Number ; @@unsignedint64@@ /= Number ; } while ( @@unsignedint64@@ ) ; return @@int64@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall select_plural ( __int64 @@int64@@ ) { return @@int64@@ ; }
__int64 __fastcall hash_rehash ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; void * @@void@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@unsignedint64@@ = compute_bucket_size ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( ! @@unsignedint64@@ ) return Number L ; if ( @@unsignedint64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ) return Number L ; @@void@@ = calloc ( @@unsignedint64@@ , Number ) ; if ( ! @@void@@ ) return Number L ; @@unsignedint64@@ = @@unsignedint64@@ ; @@int64@@ = ( __int64 ) @@void@@ + Number * @@unsignedint64@@ ; @@int64@@ = Number L ; @@int64@@ = Number L ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( ( unsigned __int8 ) transfer_entries ( ( __int64 ) & @@void@@ , @@int64@@ , Number ) ) { free ( * ( void * * ) @@int64@@ ) ; * ( _QWORD * ) @@int64@@ = @@void@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@unsignedint64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; @@int64@@ = Number L ; } else { * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; if ( ( unsigned __int8 ) transfer_entries ( @@int64@@ , ( __int64 ) & @@void@@ , Number ) != Number || ( unsigned __int8 ) transfer_entries ( @@int64@@ , ( __int64 ) & @@void@@ , Number ) != Number ) { abort ( ) ; } free ( @@void@@ ) ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return xmalloc ( @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
_BOOL8 __fastcall desirable_utmp_entry ( __int64 @@int64@@ , char @@char@@ ) { bool @@bool@@ ; @@bool@@ = * ( _BYTE * ) ( @@int64@@ + Number ) && * ( _WORD * ) @@int64@@ == Number ; if ( ( @@char@@ & Number ) != Number && ! @@bool@@ ) return Number L ; return ( @@char@@ & Number ) == Number || ! @@bool@@ || * ( int * ) ( @@int64@@ + Number ) > Number && ( kill ( * ( _DWORD * ) ( @@int64@@ + Number ) , Number ) >= Number || * __errno_location ( ) != Number ) ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_21D048 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_21D168 ; @@int648@@ [ Number ] = qword_21D170 ; @@int648@@ [ Number ] = qword_21D178 ; @@int648@@ [ Number ] = qword_21D180 ; @@int648@@ [ Number ] = qword_21D188 ; @@int648@@ [ Number ] = qword_21D190 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
__int64 __fastcall get_stat_atime_ns ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
unsigned __int64 __fastcall dev_info_hash ( _QWORD * @@QWORD@@ , unsigned __int64 @@unsignedint64@@ ) { return * @@QWORD@@ % @@unsignedint64@@ ; }
unsigned __int64 __fastcall uptime ( __int64 @@int64@@ , unsigned int @@unsignedint@@ ) { int * @@int@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( ( unsigned int ) read_utmp ( @@int64@@ , & @@int64@@ , & @@int64@@ , @@unsignedint@@ ) ) { @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , off_787A , @@int64@@ ) ; } print_uptime ( @@int64@@ , @@int64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
const char * __fastcall df_readable ( unsigned __int8 @@unsignedint8@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( ! known_value ( @@unsignedint64@@ ) && @@unsignedint8@@ != Number ) return String ; if ( @@unsignedint8@@ ) @@unsignedint64@@ = - ( __int64 ) @@unsignedint64@@ ; else @@unsignedint64@@ = @@unsignedint64@@ ; @@int64@@ = human_readable ( @@unsignedint64@@ , @@unsignedint8@@ + @@int64@@ , ( unsigned int ) human_output_opts , @@int64@@ , @@int64@@ ) ; if ( @@unsignedint8@@ ) * ( _BYTE * ) -- @@int64@@ = Number ; return ( const char * ) @@int64@@ ; }
const char * locale_charset ( ) { const char * @@constchar@@ ; char * @@char@@ ; char * @@char@@ ; @@constchar@@ = nl_langinfo ( Number ) ; if ( ! @@constchar@@ ) @@constchar@@ = ( const char * ) & unk_18B6F ; for ( @@char@@ = ( char * ) get_charset_aliases ( ) ; * @@char@@ ; @@char@@ = & @@char@@ [ strlen ( @@char@@ ) + Number ] ) { if ( ! strcmp ( @@constchar@@ , @@char@@ ) || * @@char@@ == Number && ! @@char@@ [ Number ] ) { @@constchar@@ = & @@char@@ [ strlen ( @@char@@ ) + Number ] ; break ; } @@char@@ = & @@char@@ [ strlen ( @@char@@ ) + Number ] ; } if ( ! * @@constchar@@ ) @@constchar@@ = String ; return @@constchar@@ ; }
__int64 __fastcall get_stat_atime_1 ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 __fastcall fprintftime ( FILE * @@FILE@@ , char * @@char@@ , __int64 @@int64@@ , unsigned int @@unsignedint@@ , unsigned int @@unsignedint@@ ) { return strftime_case_ ( Number , @@FILE@@ , @@char@@ , @@int64@@ , @@unsignedint@@ , @@unsignedint@@ ) ; }
_QWORD * __fastcall add_fs_type ( __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) xmalloc ( Number L ) ; * @@QWORD@@ = @@int64@@ ; @@QWORD@@ [ Number ] = fs_select_list ; fs_select_list = ( __int64 ) @@QWORD@@ ; return @@QWORD@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_20A028 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
int __fastcall gl_futimens ( int @@int@@ , char * @@char@@ , __int64 * @@int64@@ ) { return fdutimens ( @@char@@ , @@int@@ , @@int64@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
bool __fastcall is_basic ( unsigned __int8 @@unsignedint8@@ ) { return ( ( is_basic_table [ @@unsignedint8@@ >> Number ] >> ( @@unsignedint8@@ & Number ) ) & Number ) != Number ; }
char * __fastcall str_iconv ( char * @@char@@ , char * @@char@@ , char * @@char@@ ) { char * @@char@@ ; int @@int@@ ; int @@int@@ ; iconv_t @@iconvt@@ ; void * @@void@@ ; char * @@char@@ ; if ( * @@char@@ && ( unsigned int ) c_strcasecmp ( ( unsigned __int8 * ) @@char@@ , ( unsigned __int8 * ) @@char@@ ) ) { @@iconvt@@ = iconv_open ( @@char@@ , @@char@@ ) ; if ( @@iconvt@@ == ( iconv_t ) Number ) return Number L ; @@void@@ = str_cd_iconv ( @@char@@ , @@iconvt@@ ) ; if ( @@void@@ ) { if ( iconv_close ( @@iconvt@@ ) < Number ) { @@int@@ = * __errno_location ( ) ; free ( @@void@@ ) ; * __errno_location ( ) = @@int@@ ; return Number L ; } } else { @@int@@ = * __errno_location ( ) ; iconv_close ( @@iconvt@@ ) ; * __errno_location ( ) = @@int@@ ; } @@char@@ = ( char * ) @@void@@ ; } else { @@char@@ = strdup ( @@char@@ ) ; if ( ! @@char@@ ) * __errno_location ( ) = Number ; @@char@@ = @@char@@ ; } return @@char@@ ; }
__int64 __fastcall excluded_fstype ( const char * @@constchar@@ ) { __int64 @@int64@@ ; if ( ! fs_exclude_list || ! @@constchar@@ ) return Number L ; for ( @@int64@@ = fs_exclude_list ; @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ) { if ( ! strcmp ( @@constchar@@ , * ( const char * * ) @@int64@@ ) ) return Number L ; } return Number L ; }
bool __fastcall is_basic_0 ( unsigned __int8 @@unsignedint8@@ ) { return ( ( is_basic_table [ @@unsignedint8@@ >> Number ] >> ( @@unsignedint8@@ & Number ) ) & Number ) != Number ; }
__int64 __fastcall c_tolower ( int @@int@@ ) { __int64 @@int64@@ ; if ( @@int@@ <= Number || @@int@@ > Number ) @@int64@@ = ( unsigned int ) @@int@@ ; else @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; return @@int64@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
unsigned __int64 __fastcall show_entry ( char * @@char@@ , __int64 @@int64@@ ) { unsigned __int64 @@unsignedint64@@ ; if ( ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number && ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number || ( @@unsignedint64@@ = show_disk ( @@char@@ ) , ! ( _BYTE ) @@unsignedint64@@ ) ) { @@unsignedint64@@ = show_point ( @@char@@ , ( __dev_t * ) @@int64@@ ) ; } return @@unsignedint64@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
int __fastcall lutimens ( char * @@char@@ , __int64 * @@int64@@ ) { struct timespec * @@structtimespec@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; struct timespec * @@structtimespec@@ ; __syscall_slong_t @@syscallslongt@@ ; struct timespec * @@structtimespec@@ ; __syscall_slong_t @@syscallslongt@@ ; int @@int@@ ; int @@int@@ ; struct timespec * @@structtimespec@@ ; __int64 @@int64@@ [ Number ] ; struct stat @@structstat@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( @@int64@@ ) @@structtimespec@@ = ( struct timespec * ) @@int64@@ ; else @@structtimespec@@ = Number L ; @@structtimespec@@ = @@structtimespec@@ ; @@int@@ = Number ; if ( @@structtimespec@@ ) { @@int64@@ = @@int64@@ [ Number ] ; @@int64@@ [ Number ] = * @@int64@@ ; @@int64@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int64@@ [ Number ] ; @@int64@@ [ Number ] = @@int64@@ [ Number ] ; @@int64@@ [ Number ] = @@int64@@ ; @@int@@ = validate_timespec ( @@structtimespec@@ ) ; } if ( @@int@@ < Number ) return Number ; if ( lutimensat_works_really >= Number ) { if ( @@int@@ == Number ) { if ( ( unsigned int ) lstat ( @@char@@ , & @@structstat@@ ) ) return Number ; if ( @@structtimespec@@ -> tv_nsec == Number ) { @@structtimespec@@ = @@structtimespec@@ ; @@structtimespec@@ -> tv_sec = get_stat_atime_1 ( ( __int64 ) & @@structstat@@ ) ; @@structtimespec@@ -> tv_nsec = @@syscallslongt@@ ; } else if ( @@structtimespec@@ [ Number ] . tv_nsec == Number ) { @@structtimespec@@ = @@structtimespec@@ + Number ; @@structtimespec@@ [ Number ] . tv_sec = get_stat_mtime_1 ( ( __int64 ) & @@structstat@@ ) ; @@structtimespec@@ -> tv_nsec = @@syscallslongt@@ ; } @@int@@ = Number ; } @@int@@ = utimensat ( Number , @@char@@ , @@structtimespec@@ , Number ) ; if ( @@int@@ > Number ) * __errno_location ( ) = Number ; if ( ! @@int@@ || * __errno_location ( ) != Number ) { utimensat_works_really = Number ; lutimensat_works_really = Number ; return @@int@@ ; } } lutimensat_works_really = Number ; if ( ! @@int@@ ) goto LABEL_37 ; if ( @@int@@ != Number && ( unsigned int ) lstat ( @@char@@ , & @@structstat@@ ) ) { return Number ; } if ( @@structtimespec@@ && ( unsigned __int8 ) update_timespec ( ( __int64 ) & @@structstat@@ , ( __int64 * * ) & @@structtimespec@@ ) ) { return Number ; } LABEL_37 : if ( ! @@int@@ && ( unsigned int ) lstat ( @@char@@ , & @@structstat@@ ) ) return Number ; if ( ( @@structstat@@ . st_mode & Number ) != Number ) return fdutimens ( @@char@@ , Number , & @@structtimespec@@ -> tv_sec ) ; * __errno_location ( ) = Number ; return Number ; }
__int64 __fastcall c_toupper ( int @@int@@ ) { __int64 @@int64@@ ; if ( @@int@@ <= Number || @@int@@ > Number ) @@int64@@ = ( unsigned int ) @@int@@ ; else @@int64@@ = ( unsigned int ) ( @@int@@ - Number ) ; return @@int64@@ ; }
_QWORD * __fastcall add_excluded_fs_type ( __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) xmalloc ( Number L ) ; * @@QWORD@@ = @@int64@@ ; @@QWORD@@ [ Number ] = fs_exclude_list ; fs_exclude_list = ( __int64 ) @@QWORD@@ ; return @@QWORD@@ ; }
__int64 __fastcall read_utmp ( const char * @@constchar@@ , _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ , char @@char@@ ) { __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; struct utmpx * @@structutmpx@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; struct utmpx * @@structutmpx@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = Number L ; @@int64@@ = Number L ; @@int64@@ = Number L ; utmpxname ( @@constchar@@ ) ; setutxent ( ) ; while ( Number ) { @@structutmpx@@ = getutxent ( ) ; if ( ! @@structutmpx@@ ) break ; if ( desirable_utmp_entry ( ( __int64 ) @@structutmpx@@ , @@char@@ ) ) { if ( @@int64@@ == @@int64@@ ) @@int64@@ = x2nrealloc ( @@int64@@ , & @@int64@@ , Number L ) ; @@int64@@ = @@int64@@ ++ ; @@QWORD@@ = ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; @@structutmpx@@ = @@structutmpx@@ ; * @@QWORD@@ = * ( _QWORD * ) & @@structutmpx@@ -> ut_type ; @@QWORD@@ [ Number ] = * ( _QWORD * ) & @@structutmpx@@ -> __unused [ Number ] ; qmemcpy ( ( void * ) ( ( unsigned __int64 ) ( @@QWORD@@ + Number ) & Number ) , ( const void * ) ( ( char * ) @@structutmpx@@ - ( ( char * ) @@QWORD@@ - ( ( unsigned __int64 ) ( @@QWORD@@ + Number ) & Number ) ) ) , Number L * ( ( ( ( _DWORD ) @@QWORD@@ - ( ( ( _DWORD ) @@QWORD@@ + Number ) & Number ) + Number ) & Number ) >> Number ) ) ; } } endutxent ( ) ; * @@QWORD@@ = @@int64@@ ; * @@QWORD@@ = @@int64@@ ; return Number L ; }
__int64 default_block_size ( ) { __int64 @@int64@@ ; if ( getenv ( String ) ) @@int64@@ = Number L ; else @@int64@@ = Number L ; return @@int64@@ ; }
bool __fastcall known_value ( unsigned __int64 @@unsignedint64@@ ) { return @@unsignedint64@@ <= Number ; }
unsigned __int64 __fastcall mmalloca ( unsigned __int64 @@unsignedint64@@ ) { char * @@char@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@unsignedint64@@ + Number < @@unsignedint64@@ ) return Number L ; @@char@@ = ( char * ) malloc ( @@unsignedint64@@ + Number ) ; if ( ! @@char@@ ) return Number L ; @@unsignedint64@@ = ( unsigned __int64 ) ( @@char@@ + Number ) ; * ( _DWORD * ) ( @@unsignedint64@@ - Number ) = Number ; * ( _QWORD * ) ( @@unsignedint64@@ - Number ) = mmalloca_results [ @@unsignedint64@@ % Number ] ; mmalloca_results [ @@unsignedint64@@ % Number ] = @@unsignedint64@@ ; return @@unsignedint64@@ ; }
void __fastcall freea ( unsigned __int64 @@unsignedint64@@ ) { _QWORD * @@QWORD@@ ; if ( @@unsignedint64@@ && * ( _DWORD * ) ( @@unsignedint64@@ - Number ) == Number ) { for ( @@QWORD@@ = & mmalloca_results [ @@unsignedint64@@ % Number ] ; * @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) ( * @@QWORD@@ - Number L ) ) { if ( @@unsignedint64@@ == * @@QWORD@@ ) { * @@QWORD@@ = * ( _QWORD * ) ( @@unsignedint64@@ - Number ) ; free ( ( void * ) ( @@unsignedint64@@ - Number ) ) ; return ; } } } }
char * __fastcall proper_name_utf8 ( const char * @@constchar@@ , __int64 @@int64@@ ) { char * @@char@@ ; char * @@char@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; char * @@char@@ ; char * @@char@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; size_t @@sizet@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; @@char@@ = ( char * ) locale_charset ( ) ; @@char@@ = Number L ; @@char@@ = Number L ; @@int64@@ = Number L ; if ( ( unsigned int ) c_strcasecmp ( @@char@@ , String ) ) { @@char@@ = ( char * ) xstr_iconv ( @@int64@@ , String , @@char@@ ) ; @@int64@@ = ( __int64 ) @@char@@ ; @@sizet@@ = strlen ( @@char@@ ) ; @@char@@ = ( char * ) xmalloc ( @@sizet@@ + Number ) ; memcpy ( @@char@@ , @@char@@ , @@sizet@@ ) ; memcpy ( & @@char@@ [ @@sizet@@ ] , String , Number ) ; @@char@@ = ( char * ) xstr_iconv ( @@int64@@ , String , @@char@@ ) ; free ( @@char@@ ) ; if ( @@char@@ ) { if ( strchr ( @@char@@ , Number ) ) { free ( @@char@@ ) ; } else { @@char@@ = @@char@@ ; @@int64@@ = ( __int64 ) @@char@@ ; } } } else { @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; } if ( @@int64@@ ) { @@char@@ = ( char * ) @@int64@@ ; } else if ( @@int64@@ ) { @@char@@ = ( char * ) @@int64@@ ; } else { @@char@@ = ( char * ) @@constchar@@ ; } @@char@@ = @@char@@ ; if ( ! strcmp ( @@char@@ , @@constchar@@ ) ) { if ( @@char@@ && @@char@@ != @@char@@ ) free ( @@char@@ ) ; if ( @@char@@ && @@char@@ != @@char@@ ) free ( @@char@@ ) ; @@char@@ = @@char@@ ; } else if ( ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@char@@ , ( __int64 ) @@constchar@@ ) || @@int64@@ && ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@char@@ , @@int64@@ ) || @@int64@@ && ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@char@@ , @@int64@@ ) ) { if ( @@char@@ ) free ( @@char@@ ) ; if ( @@char@@ ) free ( @@char@@ ) ; @@char@@ = @@char@@ ; } else { @@sizet@@ = strlen ( @@char@@ ) ; @@sizet@@ = strlen ( @@char@@ ) ; @@char@@ = ( char * ) xmalloc ( @@sizet@@ + @@sizet@@ + Number ) ; sprintf ( @@char@@ , String , @@char@@ , @@char@@ ) ; if ( @@char@@ ) free ( @@char@@ ) ; if ( @@char@@ ) free ( @@char@@ ) ; @@char@@ = @@char@@ ; } return @@char@@ ; }
__int64 __fastcall human_options ( char * @@char@@ , int * @@int@@ , _QWORD * @@QWORD@@ ) { unsigned int @@unsignedint@@ ; @@unsignedint@@ = humblock ( @@char@@ , @@QWORD@@ , @@int@@ ) ; if ( ! * @@QWORD@@ ) { * @@QWORD@@ = default_block_size ( ) ; @@unsignedint@@ = Number ; } return @@unsignedint@@ ; }
__int64 __fastcall show_disk ( const char * @@constchar@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = Number L ; for ( @@int64@@ = mount_list ; @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ) { if ( ! strcmp ( @@constchar@@ , * ( const char * * ) @@int64@@ ) ) @@int64@@ = @@int64@@ ; } if ( ! @@int64@@ ) return Number L ; show_dev ( * ( char * * ) @@int64@@ , * ( const char * * ) ( @@int64@@ + Number ) , Number L , * ( const char * * ) ( @@int64@@ + Number ) , ( * ( _BYTE * ) ( @@int64@@ + Number ) & Number ) != Number , ( * ( _BYTE * ) ( @@int64@@ + Number ) & Number ) != Number , Number L ) ; return Number L ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
void __fastcall list_entries_users ( __int64 @@int64@@ , __int64 @@int64@@ ) { char @@char@@ ; __int64 @@int64@@ ; char @@char@@ ; unsigned __int64 @@unsignedint64@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; _QWORD * @@QWORD@@ ; @@int64@@ = @@int64@@ ; @@QWORD@@ = ( _QWORD * ) xnmalloc ( @@int64@@ , Number L ) ; @@sizet@@ = Number L ; while ( @@int64@@ -- ) { if ( * ( _BYTE * ) ( @@int64@@ + Number ) && * ( _WORD * ) @@int64@@ == Number ) @@QWORD@@ [ @@sizet@@ ++ ] = extract_trimmed_name ( @@int64@@ ) ; @@int64@@ += Number L ; } qsort ( @@QWORD@@ , @@sizet@@ , Number , userid_compare ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@sizet@@ ; ++ @@unsignedint64@@ ) { if ( @@unsignedint64@@ >= @@sizet@@ - Number ) @@char@@ = Number ; else @@char@@ = Number ; @@char@@ = @@char@@ ; fputs_unlocked ( ( const char * ) @@QWORD@@ [ @@unsignedint64@@ ] , stdout ) ; putchar_unlocked ( @@char@@ ) ; } for ( @@sizet@@ = Number L ; @@sizet@@ < @@sizet@@ ; ++ @@sizet@@ ) free ( ( void * ) @@QWORD@@ [ @@sizet@@ ] ) ; free ( @@QWORD@@ ) ; }
__int64 __fastcall strnlen1 ( const void * @@constvoid@@ , size_t @@sizet@@ ) { __int64 @@int64@@ ; _BYTE * @@BYTE@@ ; @@BYTE@@ = memchr ( @@constvoid@@ , Number , @@sizet@@ ) ; if ( @@BYTE@@ ) @@int64@@ = @@BYTE@@ - ( _BYTE * ) @@constvoid@@ + Number ; else @@int64@@ = @@sizet@@ ; return @@int64@@ ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
__int64 __fastcall xstr_cd_iconv ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = str_cd_iconv ( @@int64@@ , @@int64@@ ) ; if ( ! @@int64@@ && * __errno_location ( ) == Number ) xalloc_die ( ) ; return @@int64@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
void * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall dir_name ( __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = mdir_name ( @@int64@@ ) ; if ( ! @@int64@@ ) xalloc_die ( ) ; return @@int64@@ ; }
void * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
_BOOL8 __fastcall desirable_utmp_entry ( __int64 @@int64@@ , char @@char@@ ) { bool @@bool@@ ; @@bool@@ = * ( _BYTE * ) ( @@int64@@ + Number ) && * ( _WORD * ) @@int64@@ == Number ; if ( ( @@char@@ & Number ) != Number && ! @@bool@@ ) return Number L ; return ( @@char@@ & Number ) == Number || ! @@bool@@ || * ( int * ) ( @@int64@@ + Number ) > Number && ( kill ( * ( _DWORD * ) ( @@int64@@ + Number ) , Number ) >= Number || * __errno_location ( ) != Number ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_2070C8 ; @@int648@@ [ Number ] = qword_2070D0 ; @@int648@@ [ Number ] = qword_2070D8 ; @@int648@@ [ Number ] = qword_2070E0 ; @@int648@@ [ Number ] = qword_2070E8 ; @@int648@@ [ Number ] = qword_2070F0 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
void * __fastcall mdir_name ( _BYTE * @@BYTE@@ ) { _BYTE * @@BYTE@@ ; void * @@void@@ ; @@BYTE@@ = dir_len ( @@BYTE@@ ) ; @@void@@ = malloc ( ( size_t ) & @@BYTE@@ [ ( @@BYTE@@ == Number L ) + Number ] ) ; if ( ! @@void@@ ) return Number L ; memcpy ( @@void@@ , @@BYTE@@ , ( size_t ) @@BYTE@@ ) ; if ( ! @@BYTE@@ ) { @@BYTE@@ = ( _BYTE * ) ( & dword_0 + Number ) ; * ( _BYTE * ) @@void@@ = Number ; } @@BYTE@@ [ ( _QWORD ) @@void@@ ] = Number ; return @@void@@ ; }
void * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
int __cdecl __noreturn main ( int @@int@@ , const char * * @@constchar@@ , const char * * @@constchar@@ ) { __int64 @@int64@@ ; char * @@char@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@unsignedint64@@ = Number L ; set_program_name ( * @@constchar@@ , @@constchar@@ , @@constchar@@ ) ; setlocale ( Number , & shortopts ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; @@unsignedint@@ = Number ; while ( Number ) { @@int@@ = getopt_long ( @@int@@ , ( char * const * ) @@constchar@@ , & shortopts , & longopts , Number L ) ; if ( @@int@@ == Number ) { @@unsignedint64@@ = num_processors ( @@unsignedint@@ ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) @@unsignedint64@@ = Number L ; else @@unsignedint64@@ -= @@unsignedint64@@ ; printf ( String , @@unsignedint64@@ ) ; exit ( Number ) ; } if ( @@int@@ == Number ) usage ( Number ) ; if ( @@int@@ <= Number ) break ; if ( @@int@@ == Number ) { @@unsignedint@@ = Number ; } else { if ( @@int@@ != Number ) goto LABEL_15 ; if ( ( unsigned int ) xstrtoul ( optarg , Number L , Number L , & @@unsignedint64@@ , & shortopts ) ) { @@int64@@ = optarg ; @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ , @@int64@@ ) ; usage ( Number ) ; } } } if ( @@int@@ == Number ) { version_etc ( ( _DWORD ) stdout , ( unsigned int ) String , ( unsigned int ) String , ( _DWORD ) Version , ( unsigned int ) String , Number , ( char ) @@constchar@@ ) ; exit ( Number ) ; } LABEL_15 : usage ( Number ) ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
void * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
void * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
__int64 __fastcall humblock ( char * @@char@@ , _QWORD * @@QWORD@@ , int * @@int@@ ) { char * @@char@@ ; int @@int@@ ; int @@int@@ ; unsigned int @@unsignedint@@ ; __int64 @@int642@@ [ Number ] ; @@char@@ = @@char@@ ; @@int642@@ [ Number ] = __readfsqword ( Number ) ; @@int@@ = Number ; if ( @@char@@ || ( @@char@@ = getenv ( String ) ) != Number L || ( @@char@@ = getenv ( String ) ) != Number L ) { if ( * @@char@@ == Number ) { @@int@@ = Number ; ++ @@char@@ ; } @@int@@ = argmatch ( @@char@@ , & block_size_args , block_size_opts , Number L ) ; if ( @@int@@ < Number ) { @@unsignedint@@ = xstrtoumax ( @@char@@ , @@int642@@ , Number L , @@QWORD@@ , String ) ; if ( @@unsignedint@@ ) { * @@int@@ = Number ; return @@unsignedint@@ ; } while ( * @@char@@ <= Number || * @@char@@ > Number ) { if ( @@char@@ == ( char * ) @@int642@@ [ Number ] ) { @@int@@ |= Number ; if ( * ( _BYTE * ) ( @@int642@@ [ Number ] - Number ) == Number ) @@int@@ |= Number ; if ( * ( _BYTE * ) ( @@int642@@ [ Number ] - Number ) != Number || * ( _BYTE * ) ( @@int642@@ [ Number ] - Number ) == Number ) @@int@@ |= Number ; break ; } ++ @@char@@ ; } } else { @@int@@ |= block_size_opts [ @@int@@ ] ; * @@QWORD@@ = Number L ; } } else { * @@QWORD@@ = default_block_size ( ) ; } * @@int@@ = @@int@@ ; return Number L ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
void __fastcall free_cwd ( __int64 @@int64@@ ) { if ( * ( int * ) @@int64@@ >= Number ) close ( * ( _DWORD * ) @@int64@@ ) ; free ( * ( void * * ) ( @@int64@@ + Number ) ) ; }
void * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_211148 ; @@int648@@ [ Number ] = qword_211150 ; @@int648@@ [ Number ] = qword_211158 ; @@int648@@ [ Number ] = qword_211160 ; @@int648@@ [ Number ] = qword_211168 ; @@int648@@ [ Number ] = qword_211170 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall umaxtostr ( unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = @@int64@@ + Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = Number ; do { * ( _BYTE * ) -- @@int64@@ = @@unsignedint64@@ % Number + Number ; @@unsignedint64@@ /= Number ; } while ( @@unsignedint64@@ ) ; return @@int64@@ ; }
__int64 __fastcall x2nrealloc ( __int64 @@int64@@ , unsigned __int64 * @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = * @@unsignedint64@@ ; if ( @@int64@@ ) { if ( @@unsignedint64@@ >= Number / @@unsignedint64@@ ) xalloc_die ( ) ; @@unsignedint64@@ += ( @@unsignedint64@@ + Number ) >> Number ; } else if ( ! @@unsignedint64@@ ) { @@unsignedint64@@ = ( Number / @@unsignedint64@@ == Number ) + Number / @@unsignedint64@@ ; } * @@unsignedint64@@ = @@unsignedint64@@ ; return xrealloc ( @@int64@@ , @@unsignedint64@@ * @@unsignedint64@@ ) ; }
void * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * @@int64@@ ; void * @@void@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; void * @@void@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == ( __int64 * ) & slotvec0 ; if ( slotvec == ( __int64 * ) & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@void@@ = off_211028 ; * @@int64@@ = ( __int64 ) slotvec0 ; @@int64@@ [ Number ] = ( __int64 ) @@void@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = @@int64@@ [ Number * @@int@@ ] ; @@void@@ = ( void * ) @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@void@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = @@unsignedint64@@ + Number ; if ( @@void@@ != & slot0 ) free ( @@void@@ ) ; @@void@@ = ( void * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = ( __int64 ) @@void@@ ; quotearg_buffer_restyled ( ( __int64 ) @@void@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@void@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 __fastcall bkm_scale_by_power ( unsigned __int64 * @@unsignedint64@@ , int @@int@@ , int @@int@@ ) { unsigned int @@unsignedint@@ ; for ( @@unsignedint@@ = Number ; @@int@@ -- ; @@unsignedint@@ |= bkm_scale ( @@unsignedint64@@ , @@int@@ ) ) { ; } return @@unsignedint@@ ; }
unsigned __int64 __fastcall xstrtol_error ( unsigned int @@unsignedint@@ , int @@int@@ , char @@char@@ , __int64 @@int64@@ , __int64 @@int64@@ , int @@int@@ ) { char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; char @@char2@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@char@@ = ( char * ) & unk_EA30 ; if ( @@unsignedint@@ > Number ) { if ( @@unsignedint@@ != Number ) goto LABEL_6 ; @@char@@ = String ; } else if ( @@unsignedint@@ >= Number ) { @@char@@ = String ; } else { if ( @@unsignedint@@ != Number ) LABEL_6 : abort ( ) ; @@char@@ = String ; } if ( @@int@@ >= Number ) { @@char@@ = * ( char * * ) ( Number L * @@int@@ + @@int64@@ ) ; } else { @@char@@ = ( char * ) & unk_EA30 - @@int@@ ; @@char2@@ [ Number ] = @@char@@ ; @@char2@@ [ Number ] = Number ; @@char@@ = @@char2@@ ; } @@char@@ = gettext ( @@char@@ ) ; error ( @@int@@ , Number , @@char@@ , @@char@@ , @@char@@ , @@int64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@unsignedint64@@ , int @@int@@ ) { __int64 @@int64@@ ; if ( is_mul_ok ( @@int@@ , * @@unsignedint64@@ ) ) { * @@unsignedint64@@ *= @@int@@ ; @@int64@@ = Number L ; } else { * @@unsignedint64@@ = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall argmatch ( const char * @@constchar@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { __int64 @@int64@@ ; char @@char@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; size_t @@sizet@@ ; @@int64@@ = Number ; @@char@@ = Number ; @@sizet@@ = strlen ( @@constchar@@ ) ; for ( @@int64@@ = Number L ; * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; ++ @@int64@@ ) { if ( ! strncmp ( * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) , @@constchar@@ , @@sizet@@ ) ) { if ( @@sizet@@ == strlen ( * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) ) ) return @@int64@@ ; if ( @@int64@@ == Number ) { @@int64@@ = @@int64@@ ; } else if ( ! @@int64@@ || memcmp ( ( const void * ) ( @@sizet@@ * @@int64@@ + @@int64@@ ) , ( const void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) , @@sizet@@ ) ) { @@char@@ = Number ; } } } if ( @@char@@ ) @@int64@@ = Number ; else @@int64@@ = @@int64@@ ; return @@int64@@ ; }
__int64 __fastcall mem_cd_iconv ( char * @@char@@ , size_t @@sizet@@ , void * @@void@@ , void * * @@void@@ , size_t * @@sizet@@ ) { int @@int@@ ; char * @@char@@ ; size_t @@sizet@@ ; char * @@char@@ ; size_t @@sizet@@ ; void * @@void@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; char @@char@@ $D1F1B2789FC85C59BE59CF61C76BFA1E [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; iconv ( @@void@@ , Number L , Number L , Number L , Number L ) ; @@sizet@@ = Number L ; @@char@@ = @@char@@ ; @@sizet@@ = @@sizet@@ ; while ( @@sizet@@ ) { @@char@@ = @@char@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; @@sizet@@ = Number L ; @@sizet@@ = iconv ( @@void@@ , & @@char@@ , & @@sizet@@ , & @@char@@ , & @@sizet@@ ) ; if ( @@sizet@@ == Number && * __errno_location ( ) != Number ) { if ( * __errno_location ( ) != Number ) return Number ; break ; } @@sizet@@ += @@char@@ - @@char@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; } @@char@@ = @@char@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; @@sizet@@ = Number L ; @@sizet@@ = iconv ( @@void@@ , Number L , Number L , & @@char@@ , & @@sizet@@ ) ; if ( @@sizet@@ == Number ) return Number ; @@sizet@@ += @@char@@ - @@char@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; @@sizet@@ = @@sizet@@ ; if ( ! @@sizet@@ ) { * @@sizet@@ = Number L ; return Number L ; } if ( * @@void@@ && @@sizet@@ <= * @@sizet@@ ) { @@void@@ = * @@void@@ ; } else { @@void@@ = malloc ( @@sizet@@ ) ; if ( ! @@void@@ ) { * __errno_location ( ) = Number ; return Number ; } } iconv ( @@void@@ , Number L , Number L , Number L , Number L ) ; @@char@@ = @@char@@ ; @@sizet@@ = @@sizet@@ ; @@char@@ = ( char * ) @@void@@ ; @@sizet@@ = @@sizet@@ ; while ( @@sizet@@ ) { @@sizet@@ = iconv ( @@void@@ , & @@char@@ , & @@sizet@@ , & @@char@@ , & @@sizet@@ ) ; if ( @@sizet@@ == Number ) { if ( * __errno_location ( ) != Number ) goto LABEL_26 ; break ; } } @@sizet@@ = iconv ( @@void@@ , Number L , Number L , & @@char@@ , & @@sizet@@ ) ; if ( @@sizet@@ != Number ) { if ( @@sizet@@ ) abort ( ) ; * @@void@@ = @@void@@ ; * @@sizet@@ = @@sizet@@ ; return Number L ; } LABEL_26 : if ( @@void@@ != * @@void@@ ) { @@int@@ = * __errno_location ( ) ; free ( @@void@@ ) ; * __errno_location ( ) = @@int@@ ; } return Number ; }
__int64 __fastcall bad_cast ( __int64 @@int64@@ ) { return @@int64@@ ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@unsignedint64@@ , int @@int@@ ) { __int64 @@int64@@ ; if ( is_mul_ok ( @@int@@ , * @@unsignedint64@@ ) ) { * @@unsignedint64@@ *= @@int@@ ; @@int64@@ = Number L ; } else { * @@unsignedint64@@ = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall c_tolower ( int @@int@@ ) { __int64 @@int64@@ ; if ( @@int@@ <= Number || @@int@@ > Number ) @@int64@@ = ( unsigned int ) @@int@@ ; else @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; return @@int64@@ ; }
int __fastcall cdb_fchdir ( int * @@int@@ ) { return fchdir ( * @@int@@ ) ; }
__int64 __fastcall select_plural ( __int64 @@int64@@ ) { return @@int64@@ ; }
bool __fastcall hex_digits ( _BYTE * @@BYTE@@ ) { unsigned int @@unsignedint@@ ; for ( @@unsignedint@@ = Number ; @@unsignedint@@ < ( unsigned __int64 ) digest_hex_bytes ; ++ @@unsignedint@@ ) { if ( ( ( * __ctype_b_loc ( ) ) [ ( unsigned __int8 ) * @@BYTE@@ ] & Number ) == Number ) return Number ; ++ @@BYTE@@ ; } return * @@BYTE@@ == Number ; }
void __fastcall argmatch_invalid ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { char * @@char@@ ; __int64 @@int64@@ ; void * @@void@@ ; char * @@char@@ ; if ( @@int64@@ == Number ) @@char@@ = gettext ( String ) ; else @@char@@ = gettext ( String ) ; @@char@@ = @@char@@ ; @@int64@@ = quote_n ( Number , @@int64@@ ) ; @@void@@ = quotearg_n_style ( Number , Number , @@int64@@ ) ; error ( Number , Number , @@char@@ , @@void@@ , @@int64@@ ) ; }
__int64 __fastcall cdb_free ( int * @@int@@ ) { __int64 @@int64@@ ; @@int64@@ = ( unsigned int ) * @@int@@ ; if ( ( int ) @@int64@@ >= Number ) { @@int64@@ = close ( * @@int@@ ) == Number ; if ( ! ( _BYTE ) @@int64@@ ) __assert_fail ( String , String , Number , String ) ; } return @@int64@@ ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
unsigned __int64 __fastcall mmalloca ( unsigned __int64 @@unsignedint64@@ ) { char * @@char@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@unsignedint64@@ + Number < @@unsignedint64@@ ) return Number L ; @@char@@ = ( char * ) malloc ( @@unsignedint64@@ + Number ) ; if ( ! @@char@@ ) return Number L ; @@unsignedint64@@ = ( unsigned __int64 ) ( @@char@@ + Number ) ; * ( _DWORD * ) ( @@unsignedint64@@ - Number ) = Number ; * ( _QWORD * ) ( @@unsignedint64@@ - Number ) = mmalloca_results [ @@unsignedint64@@ % Number ] ; mmalloca_results [ @@unsignedint64@@ % Number ] = @@unsignedint64@@ ; return @@unsignedint64@@ ; }
__int64 __fastcall digest_file ( const char * @@constchar@@ , __int64 a2 , __int64 @@int64@@ ) { int @@int@@ ; int @@int@@ ; int * @@int@@ ; int * @@int@@ ; bool @@bool@@ ; FILE * @@FILE@@ ; @@int@@ = strcmp ( @@constchar@@ , String ) ; @@bool@@ = @@int@@ == Number ; if ( @@int@@ ) { @@FILE@@ = ( FILE * ) fopen_safer ( @@constchar@@ , String ) ; if ( ! @@FILE@@ ) goto LABEL_4 ; @@int@@ = sha256_stream ( @@FILE@@ , @@int64@@ ) ; } else { have_read_stdin = Number ; @@FILE@@ = stdin ; @@int@@ = sha256_stream ( stdin , @@int64@@ ) ; } if ( ! @@int@@ ) { if ( @@bool@@ || ! fclose ( @@FILE@@ ) ) return Number L ; LABEL_4 : @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , String , @@constchar@@ ) ; return Number L ; } @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , String , @@constchar@@ ) ; if ( @@FILE@@ != stdin ) fclose ( @@FILE@@ ) ; return Number L ; }
int __fastcall argmatch_valid ( __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { char * @@char@@ ; __int64 @@int64@@ ; void * @@void@@ ; @@void@@ = Number L ; @@char@@ = gettext ( String ) ; fprintf ( stderr , @@char@@ ) ; for ( @@int64@@ = Number L ; * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; ++ @@int64@@ ) { if ( @@int64@@ && ! memcmp ( @@void@@ , ( const void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) , @@sizet@@ ) ) { fprintf ( stderr , String , * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) ) ; } else { fprintf ( stderr , String , * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) ) ; @@void@@ = ( void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) ; } } return putc_unlocked ( Number , stderr ) ; }
__int64 __fastcall bsd_split_3 ( __int64 @@int64@@ , __int64 @@int64@@ , _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; if ( ! @@int64@@ ) return Number L ; * @@QWORD@@ = @@int64@@ ; for ( @@int64@@ = @@int64@@ - Number ; @@int64@@ && * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) != Number ; -- @@int64@@ ) { ; } if ( * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) != Number ) return Number L ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ + Number ; * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) = Number ; while ( * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) == Number || * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) == Number ) ++ @@int64@@ ; if ( * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) != Number ) return Number L ; for ( @@int64@@ = @@int64@@ + Number ; * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) == Number || * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) == Number ; ++ @@int64@@ ) { ; } * @@QWORD@@ = @@int64@@ + @@int64@@ ; return Number L ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
__int64 __fastcall c_toupper ( int @@int@@ ) { __int64 @@int64@@ ; if ( @@int@@ <= Number || @@int@@ > Number ) @@int64@@ = ( unsigned int ) @@int@@ ; else @@int64@@ = ( unsigned int ) ( @@int@@ - Number ) ; return @@int64@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return xmalloc ( @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
size_t __fastcall mbslen ( const char * @@constchar@@ ) { __int64 @@int64@@ ; char @@char4@@ [ Number ] ; int @@int@@ ; char @@char@@ ; const char * @@constchar@@ ; __int64 @@int64@@ ; char @@char@@ ; int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( __ctype_get_mb_cur_max ( ) <= Number ) return strlen ( @@constchar@@ ) ; @@int64@@ = Number L ; @@constchar@@ = @@constchar@@ ; @@char4@@ [ Number ] = Number ; memset ( & @@int@@ , Number , Number ) ; for ( @@char@@ = Number ; ; @@char@@ = Number ) { mbuiter_multi_next_1 ( ( __int64 ) @@char4@@ ) ; if ( @@char@@ == Number && ! @@int@@ ) break ; ++ @@int64@@ ; @@constchar@@ += @@int64@@ ; } return @@int64@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall sha256_finish_ctx ( __int64 @@int64@@ , __int64 @@int64@@ ) { sha256_conclude_ctx ( @@int64@@ ) ; return sha256_read_ctx ( @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_20D028 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
__int64 __fastcall sha224_finish_ctx ( __int64 @@int64@@ , __int64 @@int64@@ ) { sha256_conclude_ctx ( @@int64@@ ) ; return sha224_read_ctx ( @@int64@@ , @@int64@@ ) ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
__int64 __fastcall hextobin ( unsigned __int8 @@unsignedint8@@ ) { __int64 @@int64@@ ; switch ( @@unsignedint8@@ ) { case String : case String : @@int64@@ = Number L ; break ; case String : case String : @@int64@@ = Number L ; break ; case String : case String : @@int64@@ = Number L ; break ; case String : case String : @@int64@@ = Number L ; break ; case String : case String : @@int64@@ = Number L ; break ; case String : case String : @@int64@@ = Number L ; break ; default : @@int64@@ = ( unsigned int ) @@unsignedint8@@ - Number ; break ; } return @@int64@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall sha224_stream ( FILE * @@FILE@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; char * @@char@@ ; size_t @@sizet@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@char@@ = ( char * ) malloc ( Number ) ; if ( ! @@char@@ ) return Number L ; sha224_init_ctx ( ( __int64 ) @@char@@ ) ; LABEL_4 : @@int64@@ = Number L ; while ( Number ) { @@sizet@@ = fread_unlocked ( & @@char@@ [ @@int64@@ ] , Number , Number - @@int64@@ , @@FILE@@ ) ; @@int64@@ += @@sizet@@ ; if ( @@int64@@ == Number ) { sha256_process_block ( @@char@@ , Number , @@char@@ ) ; goto LABEL_4 ; } if ( ! @@sizet@@ ) break ; if ( feof_unlocked ( @@FILE@@ ) ) goto LABEL_12 ; } if ( ferror_unlocked ( @@FILE@@ ) ) { free ( @@char@@ ) ; return Number L ; } LABEL_12 : if ( @@int64@@ ) sha256_process_bytes ( @@char@@ , @@int64@@ , @@char@@ ) ; sha224_finish_ctx ( ( __int64 ) @@char@@ , @@int64@@ ) ; free ( @@char@@ ) ; return Number L ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_206028 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
__int64 __fastcall get_stat_mtime ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 __fastcall select_plural ( __int64 @@int64@@ ) { return @@int64@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall bsd_split_3 ( __int64 @@int64@@ , __int64 @@int64@@ , _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; if ( ! @@int64@@ ) return Number L ; * @@QWORD@@ = @@int64@@ ; for ( @@int64@@ = @@int64@@ - Number ; @@int64@@ && * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) != Number ; -- @@int64@@ ) { ; } if ( * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) != Number ) return Number L ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ + Number ; * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) = Number ; while ( * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) == Number || * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) == Number ) ++ @@int64@@ ; if ( * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) != Number ) return Number L ; for ( @@int64@@ = @@int64@@ + Number ; * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) == Number || * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) == Number ; ++ @@int64@@ ) { ; } * @@QWORD@@ = @@int64@@ + @@int64@@ ; return Number L ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
void __fastcall decode_preserve_arg ( __int64 @@int64@@ , _BYTE * @@BYTE@@ , char @@char@@ ) { char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; @@char@@ = ( char * ) xstrdup ( @@int64@@ ) ; @@char@@ = @@char@@ ; do { @@char@@ = strchr ( @@char@@ , Number ) ; if ( @@char@@ ) { @@char@@ = @@char@@ ++ ; * @@char@@ = Number ; } switch ( _xargmatch_internal ( String , @@char@@ , preserve_args_5954 , & preserve_vals_5953 , Number L , argmatch_die ) ) { case Number L : case Number L : @@BYTE@@ [ Number ] = @@char@@ ; break ; case Number L : @@BYTE@@ [ Number ] = @@char@@ ; break ; case Number L : @@BYTE@@ [ Number ] = @@char@@ ; break ; case Number L : @@BYTE@@ [ Number ] = @@char@@ ; break ; case Number L : @@BYTE@@ [ Number ] = @@char@@ ; @@BYTE@@ [ Number ] = @@char@@ ; break ; case Number L : @@BYTE@@ [ Number ] = @@char@@ ; @@BYTE@@ [ Number ] = @@char@@ ; break ; case Number L : @@BYTE@@ [ Number ] = @@char@@ ; @@BYTE@@ [ Number ] = @@char@@ ; @@BYTE@@ [ Number ] = @@char@@ ; @@BYTE@@ [ Number ] = @@char@@ ; if ( selinux_enabled ) @@BYTE@@ [ Number ] = @@char@@ ; @@BYTE@@ [ Number ] = @@char@@ ; break ; default : abort ( ) ; } @@char@@ = @@char@@ ; } while ( @@char@@ ) ; free ( @@char@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_2070C8 ; @@int648@@ [ Number ] = qword_2070D0 ; @@int648@@ [ Number ] = qword_2070D8 ; @@int648@@ [ Number ] = qword_2070E0 ; @@int648@@ [ Number ] = qword_2070E8 ; @@int648@@ [ Number ] = qword_2070F0 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
unsigned __int64 __fastcall overwrite_prompt ( const char * @@constchar@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; char * @@char@@ ; char @@char@@ ; _BYTE @@BYTE11@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( ! writable_destination ( @@constchar@@ , * ( _DWORD * ) ( @@int64@@ + Number ) ) ) { strmode ( * ( unsigned int * ) ( @@int64@@ + Number ) , & @@char@@ ) ; @@BYTE11@@ [ Number ] = Number ; @@int64@@ = * ( _DWORD * ) ( @@int64@@ + Number ) & Number ; @@int64@@ = quote ( @@constchar@@ ) ; @@int64@@ = program_name ; @@char@@ = gettext ( String ) ; fprintf ( stderr , @@char@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@BYTE11@@ ) ; } else { @@int64@@ = quote ( @@constchar@@ ) ; @@int64@@ = program_name ; @@char@@ = gettext ( String ) ; fprintf ( stderr , @@char@@ , @@int64@@ , @@int64@@ ) ; } return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall copy ( char * @@char@@ , char * @@char@@ , char @@char@@ , unsigned int * @@unsignedint@@ , bool * @@bool@@ , _BYTE * @@BYTE@@ ) { char @@char@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( ! ( unsigned __int8 ) valid_options ( ( __int64 ) @@unsignedint@@ ) ) __assert_fail ( String , String , Number , String ) ; top_level_src_name = ( __int64 ) @@char@@ ; top_level_dst_name = ( __int64 ) @@char@@ ; @@char@@ = Number ; return copy_internal ( @@char@@ , @@char@@ , @@char@@ , Number L , Number L , @@unsignedint@@ , Number , & @@char@@ , @@bool@@ , @@BYTE@@ ) ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
_BOOL8 __fastcall chown_failure_ok ( __int64 @@int64@@ ) { return ( * __errno_location ( ) == Number || * __errno_location ( ) == Number ) && * ( _BYTE * ) ( @@int64@@ + Number ) != Number ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
unsigned __int64 __fastcall src_to_dest_hash ( _QWORD * @@QWORD@@ , unsigned __int64 @@unsignedint64@@ ) { return * @@QWORD@@ % @@unsignedint64@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall sha256_finish_ctx ( __int64 @@int64@@ , __int64 @@int64@@ ) { sha256_conclude_ctx ( @@int64@@ ) ; return sha256_read_ctx ( @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
unsigned __int64 __fastcall forget_created ( __int64 @@int64@@ , __int64 @@int64@@ ) { void * * @@void@@ ; __int64 @@int643@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int643@@ [ Number ] = @@int64@@ ; @@int643@@ [ Number ] = @@int64@@ ; @@int643@@ [ Number ] = Number L ; @@void@@ = ( void * * ) hash_delete ( src_to_dest , @@int643@@ ) ; if ( @@void@@ ) src_to_dest_free ( @@void@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return xmalloc ( @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
__int64 __fastcall sha224_finish_ctx ( __int64 @@int64@@ , __int64 @@int64@@ ) { sha256_conclude_ctx ( @@int64@@ ) ; return sha224_read_ctx ( @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
__int64 __fastcall remember_copied ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = xmalloc ( Number L ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = xstrdup ( @@int64@@ ) ; * ( _QWORD * ) @@int64@@ = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; @@int64@@ = hash_insert ( src_to_dest , @@int64@@ ) ; if ( ! @@int64@@ ) xalloc_die ( ) ; if ( @@int64@@ == @@int64@@ ) return Number L ; src_to_dest_free ( ( void * * ) @@int64@@ ) ; return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 __fastcall sha256_read_ctx ( __int64 @@int64@@ , __int64 @@int64@@ ) { int @@int@@ ; for ( @@int@@ = Number ; @@int@@ <= Number ; ++ @@int@@ ) set_uint32 ( ( _DWORD * ) ( Number L * @@int@@ + @@int64@@ ) , HIBYTE ( * ( _DWORD * ) ( @@int64@@ + Number L * @@int@@ ) ) | ( * ( _DWORD * ) ( @@int64@@ + Number L * @@int@@ ) >> Number ) & Number | ( * ( _DWORD * ) ( @@int64@@ + Number L * @@int@@ ) << Number ) & Number | ( * ( _DWORD * ) ( @@int64@@ + Number L * @@int@@ ) << Number ) ) ; return @@int64@@ ; }
__int64 __fastcall sha224_stream ( FILE * @@FILE@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; char * @@char@@ ; size_t @@sizet@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@char@@ = ( char * ) malloc ( Number ) ; if ( ! @@char@@ ) return Number L ; sha224_init_ctx ( ( __int64 ) @@char@@ ) ; LABEL_4 : @@int64@@ = Number L ; while ( Number ) { @@sizet@@ = fread_unlocked ( & @@char@@ [ @@int64@@ ] , Number , Number - @@int64@@ , @@FILE@@ ) ; @@int64@@ += @@sizet@@ ; if ( @@int64@@ == Number ) { sha256_process_block ( @@char@@ , Number , @@char@@ ) ; goto LABEL_4 ; } if ( ! @@sizet@@ ) break ; if ( feof_unlocked ( @@FILE@@ ) ) goto LABEL_12 ; } if ( ferror_unlocked ( @@FILE@@ ) ) { free ( @@char@@ ) ; return Number L ; } LABEL_12 : if ( @@int64@@ ) sha256_process_bytes ( @@char@@ , @@int64@@ , @@char@@ ) ; sha224_finish_ctx ( ( __int64 ) @@char@@ , @@int64@@ ) ; free ( @@char@@ ) ; return Number L ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 __fastcall full_write ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = Number L ; while ( @@int64@@ ) { @@int64@@ = safe_write ( @@unsignedint@@ , @@int64@@ , @@int64@@ ) ; if ( @@int64@@ == Number ) break ; if ( ! @@int64@@ ) { * __errno_location ( ) = Number ; return @@int64@@ ; } @@int64@@ += @@int64@@ ; @@int64@@ += @@int64@@ ; @@int64@@ -= @@int64@@ ; } return @@int64@@ ; }
__int64 __fastcall sha256_buffer ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; sha256_init_ctx ( ( __int64 ) @@char@@ ) ; sha256_process_bytes ( @@int64@@ , @@int64@@ , @@char@@ ) ; return sha256_finish_ctx ( ( __int64 ) @@char@@ , @@int64@@ ) ; }
__int64 __fastcall copy_fd ( unsigned int @@unsignedint@@ , FILE * @@FILE@@ , unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; while ( @@unsignedint64@@ ) { @@int64@@ = Number ; if ( @@unsignedint64@@ <= Number ) @@int64@@ = @@unsignedint64@@ ; @@unsignedint64@@ = safe_read ( @@unsignedint@@ , @@char@@ , @@int64@@ ) ; if ( @@unsignedint64@@ == Number ) return Number L ; @@unsignedint64@@ -= @@unsignedint64@@ ; if ( ! @@unsignedint64@@ && @@unsignedint64@@ ) return Number L ; if ( @@unsignedint64@@ > fwrite_unlocked ( @@char@@ , Number , @@unsignedint64@@ , @@FILE@@ ) ) return Number L ; } return Number L ; }
unsigned __int64 __fastcall lcm ( unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { return @@unsignedint64@@ * ( @@unsignedint64@@ / gcd ( @@unsignedint64@@ , @@unsignedint64@@ ) ) ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
__int64 __fastcall get_stat_atime_0 ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
__int64 __fastcall get_stat_mtime_0 ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
char * __fastcall proper_name_utf8 ( const char * @@constchar@@ , __int64 @@int64@@ ) { char * @@char@@ ; char * @@char@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; char * @@char@@ ; char * @@char@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; size_t @@sizet@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; @@char@@ = ( char * ) locale_charset ( ) ; @@char@@ = Number L ; @@char@@ = Number L ; @@int64@@ = Number L ; if ( ( unsigned int ) c_strcasecmp ( @@char@@ , String ) ) { @@char@@ = ( char * ) xstr_iconv ( @@int64@@ , String , @@char@@ ) ; @@int64@@ = ( __int64 ) @@char@@ ; @@sizet@@ = strlen ( @@char@@ ) ; @@char@@ = ( char * ) xmalloc ( @@sizet@@ + Number ) ; memcpy ( @@char@@ , @@char@@ , @@sizet@@ ) ; memcpy ( & @@char@@ [ @@sizet@@ ] , String , Number ) ; @@char@@ = ( char * ) xstr_iconv ( @@int64@@ , String , @@char@@ ) ; free ( @@char@@ ) ; if ( @@char@@ ) { if ( strchr ( @@char@@ , Number ) ) { free ( @@char@@ ) ; } else { @@char@@ = @@char@@ ; @@int64@@ = ( __int64 ) @@char@@ ; } } } else { @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; } if ( @@int64@@ ) { @@char@@ = ( char * ) @@int64@@ ; } else if ( @@int64@@ ) { @@char@@ = ( char * ) @@int64@@ ; } else { @@char@@ = ( char * ) @@constchar@@ ; } @@char@@ = @@char@@ ; if ( ! strcmp ( @@char@@ , @@constchar@@ ) ) { if ( @@char@@ && @@char@@ != @@char@@ ) free ( @@char@@ ) ; if ( @@char@@ && @@char@@ != @@char@@ ) free ( @@char@@ ) ; @@char@@ = @@char@@ ; } else if ( ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@char@@ , ( __int64 ) @@constchar@@ ) || @@int64@@ && ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@char@@ , @@int64@@ ) || @@int64@@ && ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@char@@ , @@int64@@ ) ) { if ( @@char@@ ) free ( @@char@@ ) ; if ( @@char@@ ) free ( @@char@@ ) ; @@char@@ = @@char@@ ; } else { @@sizet@@ = strlen ( @@char@@ ) ; @@sizet@@ = strlen ( @@char@@ ) ; @@char@@ = ( char * ) xmalloc ( @@sizet@@ + @@sizet@@ + Number ) ; sprintf ( @@char@@ , String , @@char@@ , @@char@@ ) ; if ( @@char@@ ) free ( @@char@@ ) ; if ( @@char@@ ) free ( @@char@@ ) ; @@char@@ = @@char@@ ; } return @@char@@ ; }
unsigned __int64 __fastcall sha256_process_bytes ( char * @@char@@ , unsigned __int64 @@unsignedint64@@ , size_t * @@sizet@@ ) { unsigned __int64 @@unsignedint64@@ ; size_t @@sizet@@ ; void * @@void@@ ; size_t @@sizet@@ ; char * @@char@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; @@char@@ = @@char@@ ; @@sizet@@ = @@unsignedint64@@ ; @@unsignedint64@@ = @@sizet@@ [ Number ] ; if ( @@unsignedint64@@ ) { @@sizet@@ = @@sizet@@ [ Number ] ; @@sizet@@ = Number - @@sizet@@ ; if ( @@unsignedint64@@ <= Number - @@sizet@@ ) @@sizet@@ = @@unsignedint64@@ ; @@sizet@@ = @@sizet@@ ; memcpy ( ( char * ) @@sizet@@ + @@sizet@@ + Number , @@char@@ , @@sizet@@ ) ; @@sizet@@ [ Number ] += @@sizet@@ ; if ( @@sizet@@ [ Number ] > Number ) { sha256_process_block ( @@sizet@@ + Number , @@sizet@@ [ Number ] & Number , @@sizet@@ ) ; @@sizet@@ [ Number ] &= Number ; memcpy ( @@sizet@@ + Number , ( char * ) @@sizet@@ + ( ( @@sizet@@ + @@sizet@@ ) & Number ) + Number , @@sizet@@ [ Number ] ) ; } @@char@@ = & @@char@@ [ @@sizet@@ ] ; @@unsignedint64@@ = @@sizet@@ ; @@sizet@@ = @@unsignedint64@@ - @@sizet@@ ; } if ( @@sizet@@ > Number ) { @@unsignedint64@@ = ( unsigned __int8 ) @@char@@ & Number ; if ( ( ( unsigned __int8 ) @@char@@ & Number ) != Number ) { while ( @@sizet@@ > Number ) { @@void@@ = memcpy ( @@sizet@@ + Number , @@char@@ , Number ) ; @@unsignedint64@@ = sha256_process_block ( @@void@@ , Number L , @@sizet@@ ) ; @@char@@ += Number ; @@sizet@@ -= Number L ; } } else { sha256_process_block ( @@char@@ , @@sizet@@ & Number , @@sizet@@ ) ; @@unsignedint64@@ = @@sizet@@ & Number ; @@char@@ += @@sizet@@ & Number ; @@sizet@@ &= Number ; } } if ( @@sizet@@ ) { @@sizet@@ = @@sizet@@ [ Number ] ; memcpy ( ( char * ) @@sizet@@ + @@sizet@@ + Number , @@char@@ , @@sizet@@ ) ; @@sizet@@ = @@sizet@@ + @@sizet@@ ; if ( @@sizet@@ > Number ) { sha256_process_block ( @@sizet@@ + Number , Number L , @@sizet@@ ) ; @@sizet@@ -= Number L ; memcpy ( @@sizet@@ + Number , @@sizet@@ + Number , @@sizet@@ ) ; } @@unsignedint64@@ = ( unsigned __int64 ) @@sizet@@ ; @@sizet@@ [ Number ] = @@sizet@@ ; } return @@unsignedint64@@ ; }
__int64 __fastcall utimens_symlink ( __int64 @@int64@@ , __int64 @@int64@@ ) { unsigned int @@unsignedint@@ ; @@unsignedint@@ = lutimens ( @@int64@@ , @@int64@@ ) ; if ( @@unsignedint@@ && * __errno_location ( ) == Number ) @@unsignedint@@ = Number ; return @@unsignedint@@ ; }
__int64 __fastcall elide_tail_bytes_file ( __int64 @@int64@@ , unsigned int @@unsignedint@@ , unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; int @@int@@ ; __off_t @@offt@@ ; __off_t @@offt@@ ; unsigned __int64 @@unsignedint64@@ ; struct stat @@structstat@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( presume_input_pipe || ( unsigned int ) fstat ( @@unsignedint@@ , & @@structstat@@ ) || ( @@structstat@@ . st_mode & Number ) != Number ) { return elide_tail_bytes_pipe ( @@int64@@ , @@unsignedint@@ , @@unsignedint64@@ ) ; } @@offt@@ = lseek ( @@unsignedint@@ , Number L , Number ) ; if ( @@offt@@ == Number || ( @@offt@@ = lseek ( @@unsignedint@@ , Number L , Number ) , @@offt@@ == Number ) ) { @@int64@@ = quote ( @@int64@@ ) ; @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ , @@int64@@ ) ; @@int64@@ = Number L ; } else { if ( @@offt@@ - @@offt@@ < Number ) @@unsignedint64@@ = Number L ; else @@unsignedint64@@ = @@offt@@ - @@offt@@ ; @@unsignedint64@@ = @@unsignedint64@@ ; if ( @@unsignedint64@@ > @@unsignedint64@@ ) { if ( lseek ( @@unsignedint@@ , Number L , @@offt@@ ) == Number ) { @@int64@@ = quote ( @@int64@@ ) ; @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ , @@int64@@ ) ; @@int64@@ = Number L ; } else { @@int@@ = copy_fd ( @@unsignedint@@ , stdout , @@unsignedint64@@ - @@unsignedint64@@ ) ; if ( @@int@@ ) { diagnose_copy_fd_failure ( @@int@@ , @@int64@@ ) ; @@int64@@ = Number L ; } else { @@int64@@ = Number L ; } } } else { @@int64@@ = Number L ; } } return @@int64@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
_BYTE * __fastcall dir_len ( _BYTE * @@BYTE@@ ) { _BYTE * @@BYTE@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = * @@BYTE@@ == Number ; for ( @@BYTE@@ = ( _BYTE * ) ( last_component ( @@BYTE@@ ) - @@BYTE@@ ) ; @@unsignedint64@@ < ( unsigned __int64 ) @@BYTE@@ && @@BYTE@@ [ ( _QWORD ) ( @@BYTE@@ - Number ) ] == Number ; -- @@BYTE@@ ) { ; } return @@BYTE@@ ; }
_BOOL8 __fastcall writable_destination ( const char * @@constchar@@ , __int16 @@int16@@ ) { return ( @@int16@@ & Number ) == Number || ( unsigned __int8 ) can_write_any_file ( ) || ! euidaccess ( @@constchar@@ , Number ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall string_to_integer ( char @@char@@ , const char * @@constchar@@ ) { char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; int @@int@@ ; __int64 @@int644@@ [ Number ] ; @@int644@@ [ Number ] = __readfsqword ( Number ) ; @@int@@ = xstrtoumax ( @@constchar@@ , Number L , Number L , @@int644@@ , String ) ; if ( @@int@@ == Number ) { if ( @@char@@ ) @@char@@ = gettext ( String ) ; else @@char@@ = gettext ( String ) ; @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ , @@constchar@@ , @@char@@ ) ; } if ( @@int@@ ) { if ( @@char@@ ) @@char@@ = gettext ( String ) ; else @@char@@ = gettext ( String ) ; error ( Number , Number , String , @@constchar@@ , @@char@@ ) ; } return @@int644@@ [ Number ] ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
_BYTE * __fastcall filemodestring ( __int64 @@int64@@ , _BYTE * @@BYTE@@ ) { return strmode ( * ( _DWORD * ) ( @@int64@@ + Number ) , @@BYTE@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall bkm_scale_by_power ( unsigned __int64 * @@unsignedint64@@ , int @@int@@ , int @@int@@ ) { unsigned int @@unsignedint@@ ; for ( @@unsignedint@@ = Number ; @@int@@ -- ; @@unsignedint@@ |= bkm_scale ( @@unsignedint64@@ , @@int@@ ) ) { ; } return @@unsignedint@@ ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@unsignedint64@@ , int @@int@@ ) { __int64 @@int64@@ ; if ( is_mul_ok ( @@int@@ , * @@unsignedint64@@ ) ) { * @@unsignedint64@@ *= @@int@@ ; @@int64@@ = Number L ; } else { * @@unsignedint64@@ = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
int __fastcall emit_verbose ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { const char * @@constchar@@ ; const char * @@constchar@@ ; __int64 @@int64@@ ; char * @@char@@ ; @@constchar@@ = ( const char * ) quote_n ( Number L , @@int64@@ ) ; @@constchar@@ = ( const char * ) quote_n ( Number L , @@int64@@ ) ; printf ( String , @@constchar@@ , @@constchar@@ ) ; if ( @@int64@@ ) { @@int64@@ = quote ( @@int64@@ ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } return putchar_unlocked ( Number ) ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return xmalloc ( @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
__int64 __fastcall get_stat_atime ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
void * __fastcall mfile_name_concat ( _BYTE * @@BYTE@@ , _BYTE * @@BYTE@@ , _QWORD * @@QWORD@@ ) { _BOOL4 @@BOOL4@@ ; const char * @@constchar@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; _BOOL8 @@BOOL8@@ ; char * @@char@@ ; size_t @@sizet@@ ; void * @@void@@ ; _BYTE * @@BYTE@@ ; char * @@char@@ ; @@constchar@@ = last_component ( @@BYTE@@ ) ; @@sizet@@ = base_len ( @@constchar@@ ) ; @@sizet@@ = @@constchar@@ - @@BYTE@@ + @@sizet@@ ; @@BOOL4@@ = @@sizet@@ && @@constchar@@ [ @@sizet@@ - Number ] != Number ; @@BOOL8@@ = @@BOOL4@@ ; @@char@@ = longest_relative_suffix ( @@BYTE@@ ) ; @@sizet@@ = strlen ( @@char@@ ) ; @@void@@ = malloc ( @@BOOL8@@ + @@sizet@@ + @@sizet@@ + Number ) ; if ( ! @@void@@ ) return Number L ; @@BYTE@@ = mempcpy ( @@void@@ , @@BYTE@@ , @@sizet@@ ) ; * @@BYTE@@ = Number ; @@char@@ = & @@BYTE@@ [ @@BOOL8@@ ] ; if ( @@QWORD@@ ) * @@QWORD@@ = & @@char@@ [ - ( * @@BYTE@@ == Number ) ] ; * ( _BYTE * ) mempcpy ( @@char@@ , @@char@@ , @@sizet@@ ) = Number ; return @@void@@ ; }
__int64 __fastcall offtostr ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ + Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = Number ; if ( @@int64@@ >= Number ) { do { * ( _BYTE * ) -- @@int64@@ = ( char ) @@int64@@ % Number + Number ; @@int64@@ /= Number L ; } while ( @@int64@@ ) ; } else { do { * ( _BYTE * ) -- @@int64@@ = Number - ( char ) @@int64@@ % Number ; @@int64@@ /= Number L ; } while ( @@int64@@ ) ; * ( _BYTE * ) -- @@int64@@ = Number ; } return @@int64@@ ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
_BOOL8 __fastcall target_directory_operand ( char * @@char@@ , struct stat * @@structstat@@ , _BYTE * @@BYTE@@ ) { int @@int@@ ; bool @@bool@@ ; __int64 @@int64@@ ; char * @@char@@ ; bool @@bool@@ ; int @@int@@ ; if ( ( unsigned int ) stat ( @@char@@ , @@structstat@@ ) ) @@int@@ = * __errno_location ( ) ; else @@int@@ = Number ; @@int@@ = @@int@@ ; @@bool@@ = ! @@int@@ && ( @@structstat@@ -> st_mode & Number ) == Number ; @@bool@@ = @@bool@@ ; if ( @@int@@ ) { if ( @@int@@ != Number ) { @@int64@@ = quote ( @@char@@ ) ; @@char@@ = gettext ( String ) ; error ( Number , @@int@@ , @@char@@ , @@int64@@ ) ; } * @@BYTE@@ = Number ; } return @@bool@@ ; }
__int64 __fastcall valid_options ( __int64 @@int64@@ ) { if ( ! @@int64@@ ) __assert_fail ( String , String , Number , String ) ; if ( * ( _DWORD * ) @@int64@@ > Number ) __assert_fail ( String , String , Number , String ) ; if ( * ( _DWORD * ) ( @@int64@@ + Number ) != Number && * ( _DWORD * ) ( @@int64@@ + Number ) != Number && * ( _DWORD * ) ( @@int64@@ + Number ) != Number ) { __assert_fail ( String , String , Number , String ) ; } if ( * ( _DWORD * ) ( @@int64@@ + Number ) && * ( _DWORD * ) ( @@int64@@ + Number ) != Number && * ( _DWORD * ) ( @@int64@@ + Number ) != Number ) { __assert_fail ( String , String , Number , String ) ; } if ( * ( _BYTE * ) ( @@int64@@ + Number ) == Number && * ( _BYTE * ) ( @@int64@@ + Number ) == Number ) __assert_fail ( String , String , Number , String ) ; if ( * ( _DWORD * ) ( @@int64@@ + Number ) == Number && * ( _DWORD * ) ( @@int64@@ + Number ) != Number ) { __assert_fail ( String , String , Number , String ) ; } return Number L ; }
__int64 __fastcall hash_get_first ( unsigned __int64 * @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; if ( ! @@unsignedint64@@ [ Number ] ) return Number L ; for ( @@unsignedint64@@ = * @@unsignedint64@@ ; ; @@unsignedint64@@ += Number L ) { if ( @@unsignedint64@@ >= @@unsignedint64@@ [ Number ] ) abort ( ) ; if ( * ( _QWORD * ) @@unsignedint64@@ ) break ; } return * ( _QWORD * ) @@unsignedint64@@ ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
unsigned __int64 __fastcall gcd ( unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; do { @@unsignedint64@@ = @@unsignedint64@@ % @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint64@@ ; } while ( @@unsignedint64@@ ) ; return @@unsignedint64@@ ; }
bool __fastcall seen_file ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 * @@int64@@ ) { __int64 @@int644@@ [ Number ] ; @@int644@@ [ Number ] = __readfsqword ( Number ) ; if ( ! @@int64@@ ) return Number ; @@int644@@ [ Number ] = @@int64@@ ; @@int644@@ [ Number ] = @@int64@@ [ Number ] ; @@int644@@ [ Number ] = * @@int64@@ ; return hash_lookup ( @@int64@@ , @@int644@@ ) != Number ; }
unsigned __int64 __fastcall hash_string ( _BYTE * @@BYTE@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = Number L ; while ( * @@BYTE@@ ) @@unsignedint64@@ = ( Number * @@unsignedint64@@ + ( unsigned __int8 ) * @@BYTE@@ ++ ) % @@unsignedint64@@ ; return @@unsignedint64@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
unsigned __int64 __fastcall triple_hash ( _QWORD * @@QWORD@@ , unsigned __int64 @@unsignedint64@@ ) { return ( ( unsigned __int64 ) hash_pjw ( * @@QWORD@@ , @@unsignedint64@@ ) ^ @@QWORD@@ [ Number ] ) % @@unsignedint64@@ ; }
__int64 __fastcall io_blksize ( __int64 a1 , __int64 a2 , __int64 a3 , __int64 a4 , __int64 a5 , __int64 a6 , int a7 , int a8 , int a9 , int a10 , int a11 , int a12 , int a13 , __int64 @@int64@@ ) { __int64 @@int64@@ ; if ( @@int64@@ <= Number || ( unsigned __int64 ) @@int64@@ > Number || @@int64@@ <= Number ) { @@int64@@ = Number ; } else { @@int64@@ = @@int64@@ ; } return @@int64@@ ; }
_BOOL8 __fastcall triple_compare_ino_str ( __int64 @@int64@@ , __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) == * ( _QWORD * ) ( @@int64@@ + Number ) && * ( _QWORD * ) ( @@int64@@ + Number ) == * ( _QWORD * ) ( @@int64@@ + Number ) && ! strcmp ( * ( const char * * ) @@int64@@ , * ( const char * * ) @@int64@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
__int64 __fastcall bad_cast ( __int64 @@int64@@ ) { return @@int64@@ ; }
void * __fastcall allocate_entry ( __int64 @@int64@@ ) { __int64 @@int64@@ ; if ( ! * ( _QWORD * ) ( @@int64@@ + Number ) ) return malloc ( Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; return ( void * ) @@int64@@ ; }
int __fastcall clone_file ( int @@int@@ , unsigned int @@unsignedint@@ ) { return ioctl ( @@int@@ , Number , @@unsignedint@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall free_entry ( __int64 @@int64@@ , _QWORD * @@QWORD@@ ) { __int64 @@int64@@ ; * @@QWORD@@ = Number L ; @@QWORD@@ [ Number ] = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@QWORD@@ ; return @@int64@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall _xargmatch_internal ( __int64 @@int64@@ , const char * @@constchar@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ , void ( * @ @ VAR_1258 @ @ void ( ) ( void ) @ @ argmatchexitfn ) ( void ) ) { __int64 @@int64@@ ; @@int64@@ = argmatch ( @@constchar@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; if ( @@int64@@ >= Number ) return @@int64@@ ; argmatch_invalid ( @@int64@@ , ( __int64 ) @@constchar@@ , @@int64@@ ) ; argmatch_valid ( @@int64@@ , @@int64@@ , @@sizet@@ ) ; @ @ VAR_1258 @ @ void ( ) ( void ) @ @ argmatchexitfn ( ) ; return Number ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
__int64 __fastcall set_owner ( __int64 @@int64@@ , const char * @@constchar@@ , unsigned int @@unsignedint@@ , _DWORD * @@DWORD@@ , char @@char@@ , __int64 @@int64@@ ) { int @@int@@ ; unsigned __int16 @@unsignedint16@@ ; __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; __uid_t @@uidt@@ ; __gid_t @@gidt@@ ; int @@int@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; int @@int@@ ; @@uidt@@ = @@DWORD@@ [ Number ] ; @@gidt@@ = @@DWORD@@ [ Number ] ; if ( @@char@@ != Number && ( * ( _BYTE * ) ( @@int64@@ + Number ) || * ( _BYTE * ) ( @@int64@@ + Number ) || * ( _BYTE * ) ( @@int64@@ + Number ) ) && ( ( @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) , ! * ( _BYTE * ) ( @@int64@@ + Number ) ) && ! * ( _BYTE * ) ( @@int64@@ + Number ) ? ( @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) ) : ( @@int@@ = @@DWORD@@ [ Number ] ) , ( @@unsignedint@@ = ( unsigned __int16 ) @@int@@ & ( unsigned __int16 ) @@int@@ & Number , @@unsignedint16@@ = ~ ( _WORD ) @@int@@ , HIBYTE ( @@unsignedint16@@ ) |= Number , ( ( unsigned __int16 ) @@int@@ & @@unsignedint16@@ & Number ) != Number ) && ( unsigned int ) qset_acl ( @@constchar@@ , @@unsignedint@@ , @@unsignedint@@ ) ) ) { if ( ( unsigned __int8 ) owner_failure_ok ( @@int64@@ ) != Number ) { @@int64@@ = quote ( @@constchar@@ ) ; @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ , @@int64@@ ) ; } @@int64@@ = ( unsigned int ) - * ( unsigned __int8 * ) ( @@int64@@ + Number ) ; } else { if ( @@unsignedint@@ == Number ) { if ( ! lchown ( @@constchar@@ , @@uidt@@ , @@gidt@@ ) ) return Number L ; if ( * __errno_location ( ) == Number || * __errno_location ( ) == Number ) { @@int@@ = * __errno_location ( ) ; lchown ( @@constchar@@ , Number , @@gidt@@ ) ; ignore_value_0 ( ) ; * __errno_location ( ) = @@int@@ ; } } else { if ( ! fchown ( @@unsignedint@@ , @@uidt@@ , @@gidt@@ ) ) return Number L ; if ( * __errno_location ( ) == Number || * __errno_location ( ) == Number ) { @@int@@ = * __errno_location ( ) ; fchown ( @@unsignedint@@ , Number , @@gidt@@ ) ; ignore_value_0 ( ) ; * __errno_location ( ) = @@int@@ ; } } if ( ( unsigned __int8 ) chown_failure_ok ( @@int64@@ ) != Number && ( @@int64@@ = quote ( @@constchar@@ ) , @@char@@ = gettext ( String ) , @@int@@ = __errno_location ( ) , error ( Number , * @@int@@ , @@char@@ , @@int64@@ ) , * ( _BYTE * ) ( @@int64@@ + Number ) ) ) { @@int64@@ = Number ; } else { @@int64@@ = Number L ; } } return @@int64@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall transfer_entries ( __int64 @@int64@@ , __int64 @@int64@@ , char @@char@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 * @@int64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; for ( @@int64@@ = * ( __int64 * * ) @@int64@@ ; ( unsigned __int64 ) @@int64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ += Number ) { if ( * @@int64@@ ) { for ( @@QWORD@@ = ( _QWORD * ) @@int64@@ [ Number ] ; @@QWORD@@ ; @@QWORD@@ = @@QWORD@@ ) { @@int64@@ = * @@QWORD@@ ; @@int64@@ = * ( _QWORD * ) @@int64@@ ; @@QWORD@@ = ( _QWORD * ) ( @@int64@@ + Number * ( * ( __int64 ( __fastcall * * ) ( _QWORD , _QWORD ) ) ( @@int64@@ + Number ) ) ( * @@QWORD@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@QWORD@@ >= * ( _QWORD * ) ( @@int64@@ + Number ) ) abort ( ) ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; if ( * @@QWORD@@ ) { @@QWORD@@ [ Number ] = @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = @@QWORD@@ ; } else { * @@QWORD@@ = @@int64@@ ; ++ * ( _QWORD * ) ( @@int64@@ + Number ) ; free_entry ( @@int64@@ , @@QWORD@@ ) ; } } @@int64@@ = * @@int64@@ ; @@int64@@ [ Number ] = Number L ; if ( ! @@char@@ ) { @@int64@@ = * ( _QWORD * ) @@int64@@ ; @@QWORD@@ = ( _QWORD * ) ( @@int64@@ + Number * ( * ( __int64 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@int64@@ + Number ) ) ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@QWORD@@ >= * ( _QWORD * ) ( @@int64@@ + Number ) ) abort ( ) ; if ( * @@QWORD@@ ) { @@QWORD@@ = allocate_entry ( @@int64@@ ) ; if ( ! @@QWORD@@ ) return Number L ; * @@QWORD@@ = @@int64@@ ; @@QWORD@@ [ Number ] = @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = @@QWORD@@ ; } else { * @@QWORD@@ = @@int64@@ ; ++ * ( _QWORD * ) ( @@int64@@ + Number ) ; } * @@int64@@ = Number L ; -- * ( _QWORD * ) ( @@int64@@ + Number ) ; } } } return Number L ; }
unsigned __int64 __fastcall check_extension ( const char * @@constchar@@ , __int64 @@int64@@ , char @@char@@ ) { unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; char * @@char@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int16 @@int16@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@char@@ = ( char * ) last_component ( @@constchar@@ ) ; @@unsignedint64@@ = base_len ( @@char@@ ) ; @@unsignedint64@@ = Number L ; if ( @@unsignedint64@@ > Number ) { @@int16@@ = * ( _WORD * ) @@char@@ ; * ( _WORD * ) @@char@@ = Number ; * __errno_location ( ) = Number ; @@int64@@ = pathconf ( @@constchar@@ , Number ) ; if ( @@int64@@ >= Number || ! * __errno_location ( ) ) @@unsignedint64@@ = @@int64@@ ; * ( _WORD * ) @@char@@ = @@int16@@ ; } if ( @@unsignedint64@@ < @@unsignedint64@@ ) { @@unsignedint64@@ = & @@constchar@@ [ @@int64@@ ] - @@char@@ ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) @@unsignedint64@@ = @@unsignedint64@@ - Number ; @@char@@ [ @@unsignedint64@@ ] = @@char@@ ; @@char@@ [ @@unsignedint64@@ + Number ] = Number ; } return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ ) { return xmalloc ( @@int64@@ ) ; }
void __fastcall record_file ( __int64 @@int64@@ , __int64 @@int64@@ , _QWORD * @@QWORD@@ ) { _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) { @@QWORD@@ = ( _QWORD * ) xmalloc ( Number L ) ; * @@QWORD@@ = xstrdup ( @@int64@@ ) ; @@QWORD@@ [ Number ] = @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = * @@QWORD@@ ; @@int64@@ = hash_insert ( @@int64@@ , @@QWORD@@ ) ; if ( ! @@int64@@ ) xalloc_die ( ) ; if ( ( _QWORD * ) @@int64@@ != @@QWORD@@ ) triple_free ( @@QWORD@@ ) ; } }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
void * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
unsigned __int64 __fastcall triple_hash_no_name ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) % @@unsignedint64@@ ; }
void * __fastcall mdir_name ( _BYTE * @@BYTE@@ ) { _BYTE * @@BYTE@@ ; void * @@void@@ ; @@BYTE@@ = dir_len ( @@BYTE@@ ) ; @@void@@ = malloc ( ( size_t ) & @@BYTE@@ [ ( @@BYTE@@ == Number L ) + Number ] ) ; if ( ! @@void@@ ) return Number L ; memcpy ( @@void@@ , @@BYTE@@ , ( size_t ) @@BYTE@@ ) ; if ( ! @@BYTE@@ ) { @@BYTE@@ = ( _BYTE * ) ( & dword_0 + Number ) ; * ( _BYTE * ) @@void@@ = Number ; } @@BYTE@@ [ ( _QWORD ) @@void@@ ] = Number ; return @@void@@ ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
bool __fastcall is_basic ( unsigned __int8 @@unsignedint8@@ ) { return ( ( is_basic_table [ @@unsignedint8@@ >> Number ] >> ( @@unsignedint8@@ & Number ) ) & Number ) != Number ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
__int64 __fastcall hash_get_n_buckets_used ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
void * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall strnlen1 ( const void * @@constvoid@@ , size_t @@sizet@@ ) { __int64 @@int64@@ ; _BYTE * @@BYTE@@ ; @@BYTE@@ = memchr ( @@constvoid@@ , Number , @@sizet@@ ) ; if ( @@BYTE@@ ) @@int64@@ = @@BYTE@@ - ( _BYTE * ) @@constvoid@@ + Number ; else @@int64@@ = @@sizet@@ ; return @@int64@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
_BOOL8 __fastcall hash_table_ok ( __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; @@int64@@ = Number L ; @@int64@@ = Number L ; for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { @@QWORD@@ = @@QWORD@@ ; ++ @@int64@@ ; ++ @@int64@@ ; while ( Number ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; if ( ! @@QWORD@@ ) break ; ++ @@int64@@ ; } } } return @@int64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) && @@int64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall xstr_iconv ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = str_iconv ( @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( ! @@int64@@ && * __errno_location ( ) == Number ) xalloc_die ( ) ; return @@int64@@ ; }
_BOOL8 __fastcall dot_or_dotdot ( _BYTE * @@BYTE@@ ) { __int64 @@int64@@ ; char @@char@@ ; if ( * @@BYTE@@ != Number ) return Number L ; if ( @@BYTE@@ [ Number ] == Number ) @@int64@@ = Number L ; else @@int64@@ = Number L ; @@char@@ = @@BYTE@@ [ @@int64@@ ] ; return ! @@char@@ || @@char@@ == Number ; }
_BOOL8 __fastcall strip_trailing_slashes ( char * @@char@@ ) { char @@char@@ ; const char * @@constchar@@ ; const char * @@constchar@@ ; @@constchar@@ = last_component ( @@char@@ ) ; if ( ! * @@constchar@@ ) @@constchar@@ = @@char@@ ; @@constchar@@ = & @@constchar@@ [ base_len ( @@constchar@@ ) ] ; @@char@@ = * @@constchar@@ ; * @@constchar@@ = Number ; return @@char@@ != Number ; }
void * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
__int64 __fastcall get_stat_ctime_ns ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 __fastcall get_stat_ctime ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
void __fastcall argmatch_invalid ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { char * @@char@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; char * @@char@@ ; if ( @@int64@@ == Number ) @@char@@ = gettext ( String ) ; else @@char@@ = gettext ( String ) ; @@char@@ = @@char@@ ; @@int64@@ = quote_n ( Number L , @@int64@@ ) ; @@int64@@ = quotearg_n_style ( Number L , Number L , @@int64@@ ) ; error ( Number , Number , @@char@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall get_stat_mtime_ns ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 __fastcall hash_lookup ( __int64 * @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; @@int64@@ = * @@int64@@ ; @@QWORD@@ = ( _QWORD * ) ( @@int64@@ + Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@int64@@ [ Number ] ) ( @@int64@@ , @@int64@@ [ Number ] ) ) ; if ( ( unsigned __int64 ) @@QWORD@@ >= @@int64@@ [ Number ] ) abort ( ) ; if ( ! * @@QWORD@@ ) return Number L ; for ( @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { if ( @@int64@@ == * @@QWORD@@ || ( ( unsigned __int8 ( __fastcall * ) ( __int64 , _QWORD ) ) @@int64@@ [ Number ] ) ( @@int64@@ , * @@QWORD@@ ) ) { return * @@QWORD@@ ; } } return Number L ; }
char * __fastcall parse_user_spec ( char * @@char@@ , int * @@int@@ , __gid_t * @@gidt@@ , char * * @@char@@ , void * * @@void@@ ) { char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; @@char@@ = strchr ( @@char@@ , Number ) ; @@char@@ = parse_with_separator ( @@char@@ , @@char@@ , @@int@@ , @@gidt@@ , @@char@@ , @@void@@ ) ; if ( ! @@char@@ ) { if ( @@char@@ ) { @@char@@ = strchr ( @@char@@ , Number ) ; if ( @@char@@ ) { if ( ! parse_with_separator ( @@char@@ , @@char@@ , @@int@@ , @@gidt@@ , @@char@@ , @@void@@ ) ) @@char@@ = Number L ; } } } return @@char@@ ; }
bool __fastcall dev_info_compare ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ ) { return * @@QWORD@@ == * @@QWORD@@ ; }
unsigned int __fastcall dired_dump_obstack ( const char * @@constchar@@ , __int64 @@int64@@ ) { unsigned int @@unsignedint@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; @@unsignedint@@ = ( unsigned int ) ( * ( _DWORD * ) ( @@int64@@ + Number ) - * ( _DWORD * ) ( @@int64@@ + Number ) ) >> Number ; @@unsignedint64@@ = @@unsignedint@@ ; if ( @@unsignedint@@ ) { @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( @@int64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ) * ( _BYTE * ) ( @@int64@@ + Number ) |= Number ; * ( _QWORD * ) ( @@int64@@ + Number ) = ( * ( int * ) ( @@int64@@ + Number ) + * ( _QWORD * ) ( @@int64@@ + Number ) ) & ~ * ( _DWORD * ) ( @@int64@@ + Number ) ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) - * ( _QWORD * ) ( @@int64@@ + Number ) > * ( _QWORD * ) ( @@int64@@ + Number ) - * ( _QWORD * ) ( @@int64@@ + Number ) ) * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; fputs_unlocked ( @@constchar@@ , stdout ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@unsignedint64@@ ; ++ @@unsignedint64@@ ) { printf ( String , * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@int64@@ ) ) ; } @@unsignedint@@ = putchar_unlocked ( Number ) ; } return @@unsignedint@@ ; }
int __fastcall argmatch_valid ( __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { char * @@char@@ ; __int64 @@int64@@ ; void * @@void@@ ; @@void@@ = Number L ; @@char@@ = gettext ( String ) ; fprintf ( stderr , @@char@@ ) ; for ( @@int64@@ = Number L ; * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; ++ @@int64@@ ) { if ( @@int64@@ && ! memcmp ( @@void@@ , ( const void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) , @@sizet@@ ) ) { fprintf ( stderr , String , * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) ) ; } else { fprintf ( stderr , String , * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) ) ; @@void@@ = ( void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) ; } } return putc_unlocked ( Number , stderr ) ; }
bool __fastcall is_prime ( unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = Number L ; @@unsignedint64@@ = Number L ; while ( @@unsignedint64@@ < @@unsignedint64@@ && @@unsignedint64@@ % @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@unsignedint64@@ += Number * @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint64@@ + Number ; } return @@unsignedint64@@ % @@unsignedint64@@ != Number ; }
__int64 __fastcall get_stat_mtime_1 ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
_BOOL8 __fastcall basename_is_dot_or_dotdot ( __int64 @@int64@@ ) { _BYTE * @@BYTE@@ ; @@BYTE@@ = ( _BYTE * ) last_component ( @@int64@@ ) ; return dot_or_dotdot ( @@BYTE@@ ) ; }
__int64 __fastcall unsigned_file_size ( __int64 @@int64@@ ) { return @@int64@@ ; }
__int64 __fastcall xget_version ( __int64 @@int64@@ , const char * @@constchar@@ ) { char * @@char@@ ; if ( @@constchar@@ && * @@constchar@@ ) return get_version ( @@int64@@ , @@constchar@@ ) ; @@char@@ = getenv ( String ) ; return get_version ( ( __int64 ) String , @@char@@ ) ; }
__int64 __fastcall check_tuning ( __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( ( _UNKNOWN * ) @@int64@@ == & default_tuning ) return Number L ; if ( * ( float * ) ( @@int64@@ + Number ) > Number && ( float ) ( Number - Number ) > * ( float * ) ( @@int64@@ + Number ) && * ( float * ) ( @@int64@@ + Number ) > ( float ) ( Number + Number ) && * ( float * ) @@int64@@ >= Number && * ( float * ) ( @@int64@@ + Number ) > ( float ) ( * ( float * ) @@int64@@ + Number ) && * ( float * ) ( @@int64@@ + Number ) <= Number && * ( float * ) ( @@int64@@ + Number ) > ( float ) ( * ( float * ) @@int64@@ + Number ) ) { return Number L ; } * ( _QWORD * ) ( @@int64@@ + Number ) = & default_tuning ; return Number L ; }
int __fastcall utimens ( char * @@char@@ , __int64 * @@int64@@ ) { return fdutimens ( @@char@@ , Number , @@int64@@ ) ; }
__int64 __fastcall cmp_ctime ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ , __int64 ( __fastcall * @ @ VAR_490 @ @ int64 ( fastcall ) ( QWORD , QWORD ) @ @ int ( ) ( constchar , constchar ) ) ( _QWORD , _QWORD ) ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = get_stat_ctime ( ( __int64 ) ( @@QWORD@@ + Number ) ) ; @@int64@@ = @@int64@@ ; @@int64@@ = get_stat_ctime ( ( __int64 ) ( @@QWORD@@ + Number ) ) ; @@unsignedint@@ = timespec_cmp ( @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( @@unsignedint@@ ) @@int64@@ = @@unsignedint@@ ; else @@int64@@ = @ @ VAR_490 @ @ int64 ( fastcall ) ( QWORD , QWORD ) @ @ int ( ) ( constchar , constchar ) ( * @@QWORD@@ , * @@QWORD@@ ) ; return @@int64@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
__int64 clear_files ( ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; void * * @@void@@ ; for ( @@unsignedint64@@ = Number L ; ; ++ @@unsignedint64@@ ) { @@int64@@ = cwd_n_used ; if ( @@unsignedint64@@ >= cwd_n_used ) break ; @@void@@ = ( void * * ) * ( ( _QWORD * ) sorted_file + @@unsignedint64@@ ) ; free ( * @@void@@ ) ; free ( @@void@@ [ Number ] ) ; if ( @@void@@ [ Number ] != & UNKNOWN_SECURITY_CONTEXT ) freecon ( ) ; } cwd_n_used = Number L ; any_has_acl = Number ; inode_number_width = Number ; block_size_width = Number ; nlink_width = Number ; owner_width = Number ; group_width = Number ; author_width = Number ; scontext_width = Number ; major_device_number_width = Number ; minor_device_number_width = Number ; file_size_width = Number ; return @@int64@@ ; }
__int64 __fastcall xnrealloc ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { if ( ! is_mul_ok ( @@unsignedint64@@ , @@unsignedint64@@ ) ) xalloc_die ( ) ; return xrealloc ( @@int64@@ , @@unsignedint64@@ * @@unsignedint64@@ ) ; }
__int64 __fastcall cmp_atime ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ , __int64 ( __fastcall * @ @ VAR_510 @ @ int64 ( fastcall ) ( QWORD , QWORD ) @ @ int ( ) ( constchar , constchar ) ) ( _QWORD , _QWORD ) ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = get_stat_atime ( ( __int64 ) ( @@QWORD@@ + Number ) ) ; @@int64@@ = @@int64@@ ; @@int64@@ = get_stat_atime ( ( __int64 ) ( @@QWORD@@ + Number ) ) ; @@unsignedint@@ = timespec_cmp ( @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( @@unsignedint@@ ) @@int64@@ = @@unsignedint@@ ; else @@int64@@ = @ @ VAR_510 @ @ int64 ( fastcall ) ( QWORD , QWORD ) @ @ int ( ) ( constchar , constchar ) ( * @@QWORD@@ , * @@QWORD@@ ) ; return @@int64@@ ; }
__int64 __fastcall hash_find_entry ( __int64 @@int64@@ , __int64 @@int64@@ , _QWORD * @@QWORD@@ , char @@char@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; @@int64@@ = * ( _QWORD * ) @@int64@@ ; @@QWORD@@ = ( _QWORD * ) ( @@int64@@ + Number * ( * ( __int64 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@int64@@ + Number ) ) ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@QWORD@@ >= * ( _QWORD * ) ( @@int64@@ + Number ) ) abort ( ) ; * @@QWORD@@ = @@QWORD@@ ; if ( ! * @@QWORD@@ ) return Number L ; if ( @@int64@@ == * @@QWORD@@ || ( * ( unsigned __int8 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@int64@@ + Number ) ) ( @@int64@@ , * @@QWORD@@ ) ) { @@int64@@ = * @@QWORD@@ ; if ( @@char@@ ) { if ( @@QWORD@@ [ Number ] ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; @@int64@@ = @@QWORD@@ [ Number ] ; * @@QWORD@@ = * @@QWORD@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; free_entry ( @@int64@@ , @@QWORD@@ ) ; } else { * @@QWORD@@ = Number L ; } } @@int64@@ = @@int64@@ ; } else { for ( @@QWORD@@ = @@QWORD@@ ; ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { if ( ! @@QWORD@@ [ Number ] ) return Number L ; if ( @@int64@@ == * ( _QWORD * ) @@QWORD@@ [ Number ] || ( * ( unsigned __int8 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@int64@@ + Number ) ) ( @@int64@@ , * ( _QWORD * ) @@QWORD@@ [ Number ] ) ) { break ; } } @@int64@@ = * ( _QWORD * ) @@QWORD@@ [ Number ] ; if ( @@char@@ ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = @@QWORD@@ [ Number ] ; free_entry ( @@int64@@ , @@QWORD@@ ) ; } @@int64@@ = @@int64@@ ; } return @@int64@@ ; }
__int64 __fastcall dir_name ( __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = mdir_name ( @@int64@@ ) ; if ( ! @@int64@@ ) xalloc_die ( ) ; return @@int64@@ ; }
__int64 __fastcall cmp_size ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ , __int64 ( __fastcall * @ @ VAR_514 @ @ int64 ( fastcall ) ( QWORD , QWORD ) @ @ int ( ) ( constchar , constchar ) ) ( _QWORD , _QWORD ) ) { __int64 @@int64@@ ; if ( @@QWORD@@ [ Number ] < @@QWORD@@ [ Number ] ) LODWORD ( @@int64@@ ) = Number ; else LODWORD ( @@int64@@ ) = @@QWORD@@ [ Number ] > @@QWORD@@ [ Number ] ; if ( ( _DWORD ) @@int64@@ ) @@int64@@ = ( unsigned int ) @@int64@@ ; else @@int64@@ = @ @ VAR_514 @ @ int64 ( fastcall ) ( QWORD , QWORD ) @ @ int ( ) ( constchar , constchar ) ( * @@QWORD@@ , * @@QWORD@@ ) ; return @@int64@@ ; }
__int64 __fastcall x2nrealloc ( __int64 @@int64@@ , unsigned __int64 * @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = * @@unsignedint64@@ ; if ( @@int64@@ ) { if ( @@unsignedint64@@ >= Number / @@unsignedint64@@ ) xalloc_die ( ) ; @@unsignedint64@@ += ( @@unsignedint64@@ + Number ) >> Number ; } else if ( ! @@unsignedint64@@ ) { @@unsignedint64@@ = ( Number / @@unsignedint64@@ == Number ) + Number / @@unsignedint64@@ ; } * @@unsignedint64@@ = @@unsignedint64@@ ; return xrealloc ( @@int64@@ , @@unsignedint64@@ * @@unsignedint64@@ ) ; }
__int64 sort_files ( ) { __int64 @@int64@@ ; int @@int@@ ; unsigned __int8 @@unsignedint8@@ ; if ( cwd_n_used + ( ( unsigned __int64 ) cwd_n_used >> Number ) > sorted_file_alloc ) { free ( sorted_file ) ; sorted_file = ( void * ) xnmalloc ( cwd_n_used , Number L ) ; sorted_file_alloc = Number * cwd_n_used ; } initialize_ordering_vector ( ) ; @@int64@@ = ( unsigned int ) sort_type ; if ( sort_type != Number ) { if ( _setjmp ( failed_strcoll ) ) { @@unsignedint8@@ = Number ; if ( sort_type == Number ) __assert_fail ( String , String , Number , String ) ; initialize_ordering_vector ( ) ; } else { @@unsignedint8@@ = Number ; } if ( sort_type == Number ) @@int@@ = time_type ; else @@int@@ = Number ; @@int64@@ = mpsort ( sorted_file , cwd_n_used , * ( & sort_functions [ Number * ( unsigned int ) ( @@int@@ + sort_type ) ] + Number * @@unsignedint8@@ + Number * ( unsigned __int8 ) sort_reverse + ( unsigned __int8 ) directories_first ) ) ; } return @@int64@@ ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
__int64 __fastcall ftypelet ( __int16 @@int16@@ ) { switch ( @@int16@@ & Number ) { case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; } return Number L ; }
__int64 __fastcall freadahead ( __int64 @@int64@@ ) { __int64 @@int64@@ ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) > * ( _QWORD * ) ( @@int64@@ + Number ) ) return Number L ; if ( ( * ( _DWORD * ) @@int64@@ & Number ) != Number ) @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) - * ( _QWORD * ) ( @@int64@@ + Number ) ; else @@int64@@ = Number L ; return * ( _QWORD * ) ( @@int64@@ + Number ) - * ( _QWORD * ) ( @@int64@@ + Number ) + @@int64@@ ; }
__int64 print_current_files ( ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int64@@ = ( unsigned int ) format ; switch ( format ) { case Number : for ( @@unsignedint64@@ = Number L ; ; ++ @@unsignedint64@@ ) { @@int64@@ = cwd_n_used ; if ( @@unsignedint64@@ >= cwd_n_used ) break ; print_long_format ( * ( ( _QWORD * ) sorted_file + @@unsignedint64@@ ) ) ; putchar_unlocked ( Number ) ; ++ dired_pos ; } break ; case Number : for ( @@unsignedint64@@ = Number L ; ; ++ @@unsignedint64@@ ) { @@int64@@ = cwd_n_used ; if ( @@unsignedint64@@ >= cwd_n_used ) break ; print_file_name_and_frills ( * ( ( _QWORD * ) sorted_file + @@unsignedint64@@ ) , Number L ) ; putchar_unlocked ( Number ) ; } break ; case Number : @@int64@@ = print_many_per_line ( ) ; break ; case Number : @@int64@@ = print_horizontal ( ) ; break ; case Number : @@int64@@ = print_with_commas ( ) ; break ; default : return @@int64@@ ; } return @@int64@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall file_name_concat ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = mfile_name_concat ( @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( ! @@int64@@ ) xalloc_die ( ) ; return @@int64@@ ; }
size_t __fastcall format_user_or_group_width ( __int64 @@int64@@ , __int64 @@int64@@ ) { size_t @@sizet@@ ; int @@int@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( @@int64@@ ) { @@int@@ = gnu_mbswidth ( @@int64@@ , Number L ) ; @@sizet@@ = Number L ; if ( @@int@@ >= Number ) @@sizet@@ = ( unsigned int ) @@int@@ ; } else { sprintf ( @@char@@ , String , @@int64@@ ) ; @@sizet@@ = strlen ( @@char@@ ) ; } return @@sizet@@ ; }
__int64 __fastcall format_user ( unsigned int @@unsignedint@@ , int @@int@@ , char @@char@@ ) { const char * @@constchar@@ ; if ( @@char@@ != Number ) { @@constchar@@ = String ; } else if ( numeric_ids ) { @@constchar@@ = Number L ; } else { @@constchar@@ = ( const char * ) getuser ( @@unsignedint@@ ) ; } return format_user_or_group ( @@constchar@@ , @@unsignedint@@ , @@int@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
__int64 __fastcall hash_get_n_buckets ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 __fastcall knuth_morris_pratt_unibyte ( _BYTE * @@BYTE@@ , char * @@char@@ , _QWORD * @@QWORD@@ ) { void * @@void@@ ; unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; char * @@char@@ ; _BYTE * @@BYTE@@ ; char @@char@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; size_t @@sizet@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@BYTE@@ = @@BYTE@@ ; @@char@@ = @@char@@ ; @@QWORD@@ = @@QWORD@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@sizet@@ = strlen ( @@char@@ ) ; if ( @@sizet@@ > Number ) { @@unsignedint64@@ = Number L ; } else if ( Number * @@sizet@@ > Number ) { @@unsignedint64@@ = mmalloca ( Number * @@sizet@@ ) ; } else { @@void@@ = alloca ( Number * ( ( Number * ( @@sizet@@ + Number ) + Number ) / Number ) ) ; @@unsignedint64@@ = Number * ( ( ( unsigned __int64 ) & @@QWORD@@ + Number ) >> Number ) + Number ; } @@unsignedint64@@ = @@unsignedint64@@ ; if ( ! @@unsignedint64@@ ) return Number L ; * ( _QWORD * ) ( @@unsignedint64@@ + Number ) = Number L ; @@int64@@ = Number L ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@sizet@@ ; ++ @@unsignedint64@@ ) { @@char@@ = @@char@@ [ @@unsignedint64@@ - Number ] ; while ( Number ) { if ( @@char@@ == @@char@@ [ @@int64@@ ] ) { ++ @@int64@@ ; * ( _QWORD * ) ( @@unsignedint64@@ + Number * @@unsignedint64@@ ) = @@unsignedint64@@ - @@int64@@ ; goto LABEL_15 ; } if ( ! @@int64@@ ) break ; @@int64@@ -= * ( _QWORD * ) ( Number * @@int64@@ + @@unsignedint64@@ ) ; } * ( _QWORD * ) ( @@unsignedint64@@ + Number * @@unsignedint64@@ ) = @@unsignedint64@@ ; LABEL_15 : ; } * @@QWORD@@ = Number L ; @@int64@@ = Number L ; @@BYTE@@ = @@BYTE@@ ; @@BYTE@@ = @@BYTE@@ ; while ( * @@BYTE@@ ) { if ( @@char@@ [ @@int64@@ ] == * @@BYTE@@ ) { ++ @@int64@@ ; ++ @@BYTE@@ ; if ( @@int64@@ == @@sizet@@ ) { * @@QWORD@@ = @@BYTE@@ ; break ; } } else if ( @@int64@@ ) { @@BYTE@@ += * ( _QWORD * ) ( Number * @@int64@@ + @@unsignedint64@@ ) ; @@int64@@ -= * ( _QWORD * ) ( Number * @@int64@@ + @@unsignedint64@@ ) ; } else { ++ @@BYTE@@ ; ++ @@BYTE@@ ; } } freea ( @@unsignedint64@@ ) ; return Number L ; }
size_t __fastcall put_indicator ( __int64 @@int64@@ ) { if ( used_color != Number ) { used_color = Number ; prep_non_filename_text ( ) ; } return fwrite_unlocked ( * ( const void * * ) ( @@int64@@ + Number ) , * ( _QWORD * ) @@int64@@ , Number , stdout ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
bool __fastcall is_basic_2 ( unsigned __int8 @@unsignedint8@@ ) { return ( ( is_basic_table [ @@unsignedint8@@ >> Number ] >> ( @@unsignedint8@@ & Number ) ) & Number ) != Number ; }
unsigned __int64 __fastcall hash_get_max_bucket_length ( __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = Number L ; for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { @@QWORD@@ = @@QWORD@@ ; for ( @@unsignedint64@@ = Number L ; ; ++ @@unsignedint64@@ ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; if ( ! @@QWORD@@ ) break ; } if ( @@unsignedint64@@ > @@unsignedint64@@ ) @@unsignedint64@@ = @@unsignedint64@@ ; } } return @@unsignedint64@@ ; }
size_t __fastcall print_name_with_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , struct obstack * @@structobstack@@ , unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; bool @@bool@@ ; bool @@bool@@ ; __int64 @@int64@@ ; size_t @@sizet@@ ; if ( @@unsignedint8@@ ) @@int64@@ = @@int64@@ [ Number ] ; else @@int64@@ = * @@int64@@ ; @@int64@@ = @@int64@@ ; @@bool@@ = print_with_color && ( unsigned __int8 ) print_color_indicator ( @@int64@@ , @@unsignedint8@@ ) ; @@bool@@ = @@bool@@ ; if ( @@structobstack@@ && dired ) { if ( @@structobstack@@ -> next_free + Number > @@structobstack@@ -> chunk_limit ) _obstack_newchunk ( @@structobstack@@ , Number ) ; memcpy ( @@structobstack@@ -> next_free , & dired_pos , Number ) ; @@structobstack@@ -> next_free += Number ; } @@sizet@@ = quote_name ( stdout , @@int64@@ , filename_quoting_options , Number L ) ; dired_pos += @@sizet@@ ; if ( @@structobstack@@ && dired ) { if ( @@structobstack@@ -> next_free + Number > @@structobstack@@ -> chunk_limit ) _obstack_newchunk ( @@structobstack@@ , Number ) ; memcpy ( @@structobstack@@ -> next_free , & dired_pos , Number ) ; @@structobstack@@ -> next_free += Number ; } if ( @@bool@@ ) { process_signals ( ) ; prep_non_filename_text ( ) ; if ( @@unsignedint64@@ / line_length != ( @@unsignedint64@@ + @@sizet@@ - Number ) / line_length ) put_indicator ( & unk_21F1F0 ) ; } return @@sizet@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall hash_do_for_each ( __int64 @@int64@@ , unsigned __int8 ( __fastcall * @ @ VAR_1428 @ @ unsignedint8 ( fastcall ) ( QWORD , int64 ) @ @ Hashprocessor ) ( _QWORD , __int64 ) , __int64 @@int64@@ ) { __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; @@int64@@ = Number L ; for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { for ( @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { if ( @ @ VAR_1428 @ @ unsignedint8 ( fastcall ) ( QWORD , int64 ) @ @ Hashprocessor ( * @@QWORD@@ , @@int64@@ ) != Number ) return @@int64@@ ; ++ @@int64@@ ; } } } return @@int64@@ ; }
size_t __fastcall mbslen ( const char * @@constchar@@ ) { __int64 @@int64@@ ; char @@char4@@ [ Number ] ; int @@int@@ ; char @@char@@ ; const char * @@constchar@@ ; __int64 @@int64@@ ; char @@char@@ ; int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( __ctype_get_mb_cur_max ( ) <= Number ) return strlen ( @@constchar@@ ) ; @@int64@@ = Number L ; @@constchar@@ = @@constchar@@ ; @@char4@@ [ Number ] = Number ; memset ( & @@int@@ , Number , Number ) ; for ( @@char@@ = Number ; ; @@char@@ = Number ) { mbuiter_multi_next_1 ( ( __int64 ) @@char4@@ ) ; if ( @@char@@ == Number && ! @@int@@ ) break ; ++ @@int64@@ ; @@constchar@@ += @@int64@@ ; } return @@int64@@ ; }
unsigned __int64 print_many_per_line ( ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; @@unsignedint64@@ = calculate_columns ( Number L ) ; @@int64@@ = column_info + Number * @@unsignedint64@@ - Number ; @@unsignedint64@@ = cwd_n_used / @@unsignedint64@@ + ( cwd_n_used % @@unsignedint64@@ != Number ) ; for ( @@unsignedint64@@ = Number L ; ; ++ @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ ; if ( @@unsignedint64@@ >= @@unsignedint64@@ ) break ; @@int64@@ = Number L ; @@unsignedint64@@ = @@unsignedint64@@ ; for ( @@unsignedint64@@ = Number L ; ; @@unsignedint64@@ += @@int64@@ ) { @@int64@@ = * ( ( _QWORD * ) sorted_file + @@unsignedint64@@ ) ; @@int64@@ = length_of_file_name_and_frills ( @@int64@@ ) ; @@int64@@ = @@int64@@ ++ ; @@int64@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ ) ; print_file_name_and_frills ( @@int64@@ , @@unsignedint64@@ ) ; @@unsignedint64@@ += @@unsignedint64@@ ; if ( @@unsignedint64@@ >= cwd_n_used ) break ; indent ( @@unsignedint64@@ + @@int64@@ , @@int64@@ + @@unsignedint64@@ ) ; } putchar_unlocked ( Number ) ; } return @@unsignedint64@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall next_prime ( unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = @@unsignedint64@@ ; if ( @@unsignedint64@@ <= Number ) @@int64@@ = Number L ; for ( @@int64@@ = @@int64@@ | Number ; @@int64@@ != Number && ! is_prime ( @@int64@@ ) ; @@int64@@ += Number L ) { ; } return @@int64@@ ; }
int print_horizontal ( ) { unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; @@unsignedint64@@ = Number L ; @@unsignedint64@@ = calculate_columns ( Number L ) ; @@int64@@ = column_info + Number * @@unsignedint64@@ - Number ; @@int64@@ = * ( _QWORD * ) sorted_file ; @@int64@@ = length_of_file_name_and_frills ( * ( _QWORD * ) sorted_file ) ; @@int64@@ = * * ( _QWORD * * ) ( @@int64@@ + Number ) ; print_file_name_and_frills ( @@int64@@ , Number L ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < cwd_n_used ; ++ @@unsignedint64@@ ) { if ( @@unsignedint64@@ % @@unsignedint64@@ ) { indent ( @@unsignedint64@@ + @@int64@@ , @@int64@@ + @@unsignedint64@@ ) ; @@unsignedint64@@ += @@int64@@ ; } else { putchar_unlocked ( Number ) ; @@unsignedint64@@ = Number L ; } @@int64@@ = * ( ( _QWORD * ) sorted_file + @@unsignedint64@@ ) ; print_file_name_and_frills ( @@int64@@ , @@unsignedint64@@ ) ; @@int64@@ = length_of_file_name_and_frills ( @@int64@@ ) ; @@int64@@ = * ( _QWORD * ) ( Number * ( @@unsignedint64@@ % @@unsignedint64@@ ) + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; } return putchar_unlocked ( Number ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
_BYTE * __fastcall attach ( _BYTE * @@BYTE@@ , _BYTE * @@BYTE@@ , _BYTE * @@BYTE@@ ) { _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; @@BYTE@@ = @@BYTE@@ ; if ( * @@BYTE@@ != Number || @@BYTE@@ [ Number ] ) { while ( * @@BYTE@@ ) { @@BYTE@@ = @@BYTE@@ ++ ; @@BYTE@@ = @@BYTE@@ ++ ; * @@BYTE@@ = * @@BYTE@@ ; } if ( @@BYTE@@ > @@BYTE@@ && * ( @@BYTE@@ - Number ) != Number ) { @@BYTE@@ = @@BYTE@@ ++ ; * @@BYTE@@ = Number ; } } while ( * @@BYTE@@ ) { @@BYTE@@ = @@BYTE@@ ++ ; @@BYTE@@ = @@BYTE@@ ++ ; * @@BYTE@@ = * @@BYTE@@ ; } @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ = Number ; return @@BYTE@@ ; }
_BYTE * __fastcall savedirstream ( DIR * @@DIR@@ ) { __int64 @@int64@@ ; int @@int@@ ; _BYTE * @@BYTE@@ ; unsigned __int64 @@unsignedint64@@ ; size_t @@sizet@@ ; struct dirent * @@structdirent@@ ; char * @@char@@ ; size_t @@sizet@@ ; @@unsignedint64@@ = Number L ; @@sizet@@ = Number L ; if ( ! @@DIR@@ ) return Number L ; @@BYTE@@ = ( _BYTE * ) xmalloc ( Number L ) ; while ( Number ) { * __errno_location ( ) = Number ; @@structdirent@@ = readdir ( @@DIR@@ ) ; if ( ! @@structdirent@@ ) break ; @@char@@ = @@structdirent@@ -> d_name ; if ( @@structdirent@@ -> d_name [ Number ] == Number ) { if ( @@structdirent@@ -> d_name [ Number ] == Number ) @@int64@@ = Number L ; else @@int64@@ = Number L ; } else { @@int64@@ = Number L ; } if ( @@char@@ [ @@int64@@ ] ) { @@sizet@@ = strlen ( @@structdirent@@ -> d_name ) + Number ; if ( @@sizet@@ > @@sizet@@ + @@sizet@@ ) xalloc_die ( ) ; if ( @@unsignedint64@@ <= @@sizet@@ + @@sizet@@ ) { do { if ( @@unsignedint64@@ > Number * @@unsignedint64@@ ) xalloc_die ( ) ; @@unsignedint64@@ *= Number L ; } while ( @@unsignedint64@@ <= @@sizet@@ + @@sizet@@ ) ; @@BYTE@@ = ( _BYTE * ) xrealloc ( @@BYTE@@ , @@unsignedint64@@ ) ; } memcpy ( & @@BYTE@@ [ @@sizet@@ ] , @@char@@ , @@sizet@@ ) ; @@sizet@@ += @@sizet@@ ; } } @@BYTE@@ [ @@sizet@@ ] = Number ; @@int@@ = * __errno_location ( ) ; if ( closedir ( @@DIR@@ ) ) @@int@@ = * __errno_location ( ) ; if ( ! @@int@@ ) return @@BYTE@@ ; free ( @@BYTE@@ ) ; * __errno_location ( ) = @@int@@ ; return Number L ; }
size_t * __fastcall hash_initialize ( __int64 @@int64@@ , void * @@void@@ , unsigned __int64 ( __fastcall * @ @ VAR_1458 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ) ( __int64 a1 , unsigned __int64 a2 ) , bool ( __fastcall * @ @ VAR_1460 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ) ( __int64 a1 , __int64 a2 ) , size_t @@sizet@@ ) { size_t * @@sizet@@ ; bool ( __fastcall * @ @ VAR_1459 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ) ( __int64 , __int64 ) ; unsigned __int64 ( __fastcall * @ @ VAR_1457 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ) ( __int64 , unsigned __int64 ) ; void * @@void@@ ; size_t * @@sizet@@ ; @@void@@ = @@void@@ ; @ @ VAR_1457 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher = @ @ VAR_1458 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ; @ @ VAR_1459 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator = @ @ VAR_1460 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ; if ( ! @ @ VAR_1458 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ) @ @ VAR_1457 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher = raw_hasher ; if ( ! @ @ VAR_1460 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ) @ @ VAR_1459 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator = raw_comparator ; @@sizet@@ = ( size_t * ) malloc ( Number ) ; if ( ! @@sizet@@ ) return Number L ; if ( ! @@void@@ ) @@void@@ = & default_tuning ; @@sizet@@ [ Number ] = ( size_t ) @@void@@ ; if ( ( unsigned __int8 ) check_tuning ( ( __int64 ) @@sizet@@ ) == Number && ( @@sizet@@ [ Number ] = compute_bucket_size ( @@int64@@ , ( __int64 ) @@void@@ ) ) != Number && ( * @@sizet@@ = ( size_t ) calloc ( @@sizet@@ [ Number ] , Number ) ) != Number ) { @@sizet@@ [ Number ] = Number * @@sizet@@ [ Number ] + * @@sizet@@ ; @@sizet@@ [ Number ] = Number L ; @@sizet@@ [ Number ] = Number L ; @@sizet@@ [ Number ] = ( size_t ) @ @ VAR_1457 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ; @@sizet@@ [ Number ] = ( size_t ) @ @ VAR_1459 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ; @@sizet@@ [ Number ] = @@sizet@@ ; @@sizet@@ [ Number ] = Number L ; @@sizet@@ = @@sizet@@ ; } else { free ( @@sizet@@ ) ; @@sizet@@ = Number L ; } return @@sizet@@ ; }
char * __fastcall areadlink_with_size ( const char * @@constchar@@ , unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; char * @@char@@ ; int @@int@@ ; size_t @@sizet@@ ; char * @@char@@ ; ssize_t @@ssizet@@ ; if ( @@unsignedint64@@ >= Number ) @@int64@@ = Number L ; else @@int64@@ = @@unsignedint64@@ + Number ; @@sizet@@ = @@int64@@ ; LABEL_5 : for ( @@char@@ = ( char * ) malloc ( @@sizet@@ ) ; ; @@char@@ = ( char * ) malloc ( Number ) ) { @@char@@ = @@char@@ ; if ( ! @@char@@ ) return Number L ; @@ssizet@@ = readlink ( @@constchar@@ , @@char@@ , @@sizet@@ ) ; if ( @@ssizet@@ < Number && * __errno_location ( ) != Number ) { @@int@@ = * __errno_location ( ) ; free ( @@char@@ ) ; * __errno_location ( ) = @@int@@ ; return Number L ; } if ( @@ssizet@@ < @@sizet@@ ) { @@char@@ [ @@ssizet@@ ] = Number ; return @@char@@ ; } free ( @@char@@ ) ; if ( @@sizet@@ <= Number ) { @@sizet@@ *= Number L ; goto LABEL_5 ; } if ( @@sizet@@ > Number ) break ; @@sizet@@ = Number ; } * __errno_location ( ) = Number ; return Number L ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
__int64 __fastcall verrevcmp ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { int @@int@@ ; int @@int@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = Number L ; @@unsignedint64@@ = Number L ; while ( @@unsignedint64@@ < @@unsignedint64@@ || @@unsignedint64@@ < @@unsignedint64@@ ) { @@unsignedint@@ = Number ; while ( @@unsignedint64@@ < @@unsignedint64@@ && ( unsigned __int8 ) c_isdigit ( ( unsigned int ) * ( char * ) ( @@int64@@ + @@unsignedint64@@ ) ) != Number || @@unsignedint64@@ < @@unsignedint64@@ && ( unsigned __int8 ) c_isdigit ( ( unsigned int ) * ( char * ) ( @@int64@@ + @@unsignedint64@@ ) ) != Number ) { if ( @@unsignedint64@@ == @@unsignedint64@@ ) @@int@@ = Number ; else @@int@@ = order ( * ( _BYTE * ) ( @@int64@@ + @@unsignedint64@@ ) ) ; @@int@@ = @@int@@ ; if ( @@unsignedint64@@ == @@unsignedint64@@ ) @@int@@ = Number ; else @@int@@ = order ( * ( _BYTE * ) ( @@int64@@ + @@unsignedint64@@ ) ) ; if ( @@int@@ != @@int@@ ) return ( unsigned int ) ( @@int@@ - @@int@@ ) ; ++ @@unsignedint64@@ ; ++ @@unsignedint64@@ ; } while ( * ( _BYTE * ) ( @@int64@@ + @@unsignedint64@@ ) == Number ) ++ @@unsignedint64@@ ; while ( * ( _BYTE * ) ( @@int64@@ + @@unsignedint64@@ ) == Number ) ++ @@unsignedint64@@ ; while ( ( unsigned __int8 ) c_isdigit ( ( unsigned int ) * ( char * ) ( @@int64@@ + @@unsignedint64@@ ) ) && ( unsigned __int8 ) c_isdigit ( ( unsigned int ) * ( char * ) ( @@int64@@ + @@unsignedint64@@ ) ) ) { if ( ! @@unsignedint@@ ) @@unsignedint@@ = * ( char * ) ( @@int64@@ + @@unsignedint64@@ ) - * ( char * ) ( @@int64@@ + @@unsignedint64@@ ) ; ++ @@unsignedint64@@ ; ++ @@unsignedint64@@ ; } if ( ( unsigned __int8 ) c_isdigit ( ( unsigned int ) * ( char * ) ( @@int64@@ + @@unsignedint64@@ ) ) ) return Number L ; if ( ( unsigned __int8 ) c_isdigit ( ( unsigned int ) * ( char * ) ( @@int64@@ + @@unsignedint64@@ ) ) ) return Number ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; } return Number L ; }
unsigned __int64 __fastcall hash_pjw ( _BYTE * @@BYTE@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = Number L ; while ( * @@BYTE@@ ) @@unsignedint64@@ = __ROL8__ ( @@unsignedint64@@ , Number ) + ( char ) * @@BYTE@@ ++ ; return @@unsignedint64@@ % @@unsignedint64@@ ; }
__int64 __fastcall argmatch ( const char * @@constchar@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { __int64 @@int64@@ ; char @@char@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; size_t @@sizet@@ ; @@int64@@ = Number ; @@char@@ = Number ; @@sizet@@ = strlen ( @@constchar@@ ) ; for ( @@int64@@ = Number L ; * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; ++ @@int64@@ ) { if ( ! strncmp ( * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) , @@constchar@@ , @@sizet@@ ) ) { if ( @@sizet@@ == strlen ( * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) ) ) return @@int64@@ ; if ( @@int64@@ == Number ) { @@int64@@ = @@int64@@ ; } else if ( ! @@int64@@ || memcmp ( ( const void * ) ( @@sizet@@ * @@int64@@ + @@int64@@ ) , ( const void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) , @@sizet@@ ) ) { @@char@@ = Number ; } } } if ( @@char@@ ) @@int64@@ = Number ; else @@int64@@ = @@int64@@ ; return @@int64@@ ; }
int __fastcall rpl_linkat ( unsigned int @@unsignedint@@ , char * @@char@@ , int @@int@@ , const char * @@constchar@@ , int @@int@@ ) { int @@int@@ ; int @@int@@ ; if ( ! @@int@@ ) return linkat ( @@unsignedint@@ , @@char@@ , @@int@@ , @@constchar@@ , Number ) ; @@int@@ = @@int@@ ; BYTE1 ( @@int@@ ) = BYTE1 ( @@int@@ ) & Number ; if ( @@int@@ ) { * __errno_location ( ) = Number ; return Number ; } if ( have_follow_really_4385 >= Number ) { @@int@@ = linkat ( @@unsignedint@@ , @@char@@ , @@int@@ , @@constchar@@ , @@int@@ ) ; if ( @@int@@ != Number || * __errno_location ( ) != Number ) { have_follow_really_4385 = Number ; return @@int@@ ; } have_follow_really_4385 = Number ; } return linkat_follow ( @@unsignedint@@ , @@char@@ , @@int@@ , @@constchar@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
__int64 __fastcall wc_ensure_printable ( wint_t * @@wintt@@ ) { unsigned __int8 @@unsignedint8@@ ; @@unsignedint8@@ = Number ; while ( * @@wintt@@ ) { if ( ! iswprint ( * @@wintt@@ ) ) { * @@wintt@@ = Number ; @@unsignedint8@@ = Number ; } ++ @@wintt@@ ; } return @@unsignedint8@@ ; }
bool __fastcall is_basic_1 ( unsigned __int8 @@unsignedint8@@ ) { return ( ( is_basic_table [ @@unsignedint8@@ >> Number ] >> ( @@unsignedint8@@ & Number ) ) & Number ) != Number ; }
__int64 __fastcall open_safer ( const char * @@constchar@@ , char @@char@@ , unsigned int @@unsignedint@@ ) { unsigned int @@unsignedint@@ ; unsigned int @@unsignedint@@ ; @@unsignedint@@ = Number ; if ( ( @@char@@ & Number ) != Number ) @@unsignedint@@ = @@unsignedint@@ ; @@unsignedint@@ = open ( @@constchar@@ , @@char@@ , @@unsignedint@@ ) ; return fd_safer ( @@unsignedint@@ ) ; }
__int64 __fastcall argmatch_to_argument ( const void * @@constvoid@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; ++ @@int64@@ ) { if ( ! memcmp ( @@constvoid@@ , ( const void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) , @@sizet@@ ) ) return * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; } return Number L ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
__int64 __fastcall rpl_wcswidth ( wchar_t * @@wchart@@ , __int64 @@int64@@ ) { wchar_t * @@wchart@@ ; __int64 @@int64@@ ; int @@int@@ ; int @@int@@ ; for ( @@int@@ = Number ; ; @@int@@ += @@int@@ ) { @@int64@@ = @@int64@@ -- ; if ( ! @@int64@@ || ! * @@wchart@@ ) break ; @@wchart@@ = @@wchart@@ ++ ; @@int@@ = wcwidth ( * @@wchart@@ ) ; if ( @@int@@ == Number ) return Number ; if ( @@int@@ > Number - @@int@@ ) return Number ; } return ( unsigned int ) @@int@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall ftypelet ( __int16 @@int16@@ ) { switch ( @@int16@@ & Number ) { case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; } return Number L ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ ) { return xmalloc ( @@int64@@ ) ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
__int64 __fastcall mbsnwidth ( char * @@char@@ , __int64 @@int64@@ , char @@char@@ ) { int @@int@@ ; char * @@char@@ ; unsigned __int8 @@unsignedint8@@ ; wchar_t @@wchart@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; char * @@char@@ ; size_t @@sizet@@ ; char * @@char@@ ; mbstate_t @@mbstatet2@@ [ Number ] ; @@mbstatet2@@ [ Number ] = ( mbstate_t ) __readfsqword ( Number ) ; @@char@@ = @@char@@ ; @@char@@ = & @@char@@ [ @@int64@@ ] ; @@unsignedint@@ = Number ; if ( __ctype_get_mb_cur_max ( ) > Number ) { while ( Number ) { LABEL_28 : if ( @@char@@ >= @@char@@ ) return @@unsignedint@@ ; @@int@@ = * @@char@@ ; if ( @@int@@ > Number ) { if ( @@int@@ < Number || @@int@@ > Number && ( unsigned int ) ( @@int@@ - Number ) > Number ) { LABEL_11 : memset ( @@mbstatet2@@ , Number , Number ) ; while ( Number ) { @@sizet@@ = mbrtowc ( & @@wchart@@ , @@char@@ , @@char@@ - @@char@@ , @@mbstatet2@@ ) ; if ( @@sizet@@ == Number ) { if ( ( @@char@@ & Number ) == Number ) { ++ @@char@@ ; ++ @@unsignedint@@ ; goto LABEL_28 ; } return Number ; } if ( @@sizet@@ == Number ) break ; if ( ! @@sizet@@ ) @@sizet@@ = Number L ; @@int@@ = wcwidth ( @@wchart@@ ) ; if ( @@int@@ < Number ) { if ( ( @@char@@ & Number ) != Number ) return Number ; @@unsignedint@@ += iswcntrl ( @@wchart@@ ) == Number ; } else { @@unsignedint@@ += @@int@@ ; } @@char@@ += @@sizet@@ ; if ( mbsinit ( @@mbstatet2@@ ) ) goto LABEL_28 ; } if ( ( @@char@@ & Number ) == Number ) { @@char@@ = @@char@@ ; ++ @@unsignedint@@ ; continue ; } return Number ; } } else if ( @@int@@ < Number && ( unsigned int ) ( @@int@@ - Number ) > Number ) { goto LABEL_11 ; } ++ @@char@@ ; ++ @@unsignedint@@ ; } } while ( @@char@@ < @@char@@ ) { @@char@@ = @@char@@ ++ ; @@unsignedint8@@ = * @@char@@ ; if ( ( ( * __ctype_b_loc ( ) ) [ @@unsignedint8@@ ] & Number ) != Number ) { ++ @@unsignedint@@ ; } else { if ( ( @@char@@ & Number ) != Number ) return Number ; @@unsignedint@@ += ( ( * __ctype_b_loc ( ) ) [ @@unsignedint8@@ ] & Number ) == Number ; } } return @@unsignedint@@ ; }
__int64 __fastcall mem_cd_iconv ( char * @@char@@ , size_t @@sizet@@ , void * @@void@@ , void * * @@void@@ , size_t * @@sizet@@ ) { int @@int@@ ; char * @@char@@ ; size_t @@sizet@@ ; char * @@char@@ ; size_t @@sizet@@ ; void * @@void@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; char @@char@@ $D1F1B2789FC85C59BE59CF61C76BFA1E [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; iconv ( @@void@@ , Number L , Number L , Number L , Number L ) ; @@sizet@@ = Number L ; @@char@@ = @@char@@ ; @@sizet@@ = @@sizet@@ ; while ( @@sizet@@ ) { @@char@@ = @@char@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; @@sizet@@ = Number L ; @@sizet@@ = iconv ( @@void@@ , & @@char@@ , & @@sizet@@ , & @@char@@ , & @@sizet@@ ) ; if ( @@sizet@@ == Number && * __errno_location ( ) != Number ) { if ( * __errno_location ( ) != Number ) return Number ; break ; } @@sizet@@ += @@char@@ - @@char@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; } @@char@@ = @@char@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; @@sizet@@ = Number L ; @@sizet@@ = iconv ( @@void@@ , Number L , Number L , & @@char@@ , & @@sizet@@ ) ; if ( @@sizet@@ == Number ) return Number ; @@sizet@@ += @@char@@ - @@char@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; @@sizet@@ = @@sizet@@ ; if ( ! @@sizet@@ ) { * @@sizet@@ = Number L ; return Number L ; } if ( * @@void@@ && @@sizet@@ <= * @@sizet@@ ) { @@void@@ = * @@void@@ ; } else { @@void@@ = malloc ( @@sizet@@ ) ; if ( ! @@void@@ ) { * __errno_location ( ) = Number ; return Number ; } } iconv ( @@void@@ , Number L , Number L , Number L , Number L ) ; @@char@@ = @@char@@ ; @@sizet@@ = @@sizet@@ ; @@char@@ = ( char * ) @@void@@ ; @@sizet@@ = @@sizet@@ ; while ( @@sizet@@ ) { @@sizet@@ = iconv ( @@void@@ , & @@char@@ , & @@sizet@@ , & @@char@@ , & @@sizet@@ ) ; if ( @@sizet@@ == Number ) { if ( * __errno_location ( ) != Number ) goto LABEL_26 ; break ; } } @@sizet@@ = iconv ( @@void@@ , Number L , Number L , & @@char@@ , & @@sizet@@ ) ; if ( @@sizet@@ != Number ) { if ( @@sizet@@ ) abort ( ) ; * @@void@@ = @@void@@ ; * @@sizet@@ = @@sizet@@ ; return Number L ; } LABEL_26 : if ( @@void@@ != * @@void@@ ) { @@int@@ = * __errno_location ( ) ; free ( @@void@@ ) ; * __errno_location ( ) = @@int@@ ; } return Number ; }
_BYTE * __fastcall longest_relative_suffix ( _BYTE * @@BYTE@@ ) { while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; return @@BYTE@@ ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
unsigned __int64 __fastcall hash_get_max_bucket_length ( __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = Number L ; for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { @@QWORD@@ = @@QWORD@@ ; for ( @@unsignedint64@@ = Number L ; ; ++ @@unsignedint64@@ ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; if ( ! @@QWORD@@ ) break ; } if ( @@unsignedint64@@ > @@unsignedint64@@ ) @@unsignedint64@@ = @@unsignedint64@@ ; } } return @@unsignedint64@@ ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
void * __fastcall mfile_name_concat ( _BYTE * @@BYTE@@ , _BYTE * @@BYTE@@ , _QWORD * @@QWORD@@ ) { _BOOL4 @@BOOL4@@ ; const char * @@constchar@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; _BOOL8 @@BOOL8@@ ; char * @@char@@ ; size_t @@sizet@@ ; void * @@void@@ ; _BYTE * @@BYTE@@ ; char * @@char@@ ; @@constchar@@ = last_component ( @@BYTE@@ ) ; @@sizet@@ = base_len ( @@constchar@@ ) ; @@sizet@@ = @@constchar@@ - @@BYTE@@ + @@sizet@@ ; @@BOOL4@@ = @@sizet@@ && @@constchar@@ [ @@sizet@@ - Number ] != Number ; @@BOOL8@@ = @@BOOL4@@ ; @@char@@ = longest_relative_suffix ( @@BYTE@@ ) ; @@sizet@@ = strlen ( @@char@@ ) ; @@void@@ = malloc ( @@BOOL8@@ + @@sizet@@ + @@sizet@@ + Number ) ; if ( ! @@void@@ ) return Number L ; @@BYTE@@ = mempcpy ( @@void@@ , @@BYTE@@ , @@sizet@@ ) ; * @@BYTE@@ = Number ; @@char@@ = & @@BYTE@@ [ @@BOOL8@@ ] ; if ( @@QWORD@@ ) * @@QWORD@@ = & @@char@@ [ - ( * @@BYTE@@ == Number ) ] ; * ( _BYTE * ) mempcpy ( @@char@@ , @@char@@ , @@sizet@@ ) = Number ; return @@void@@ ; }
__int64 __fastcall hash_lookup ( __int64 * @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; @@int64@@ = * @@int64@@ ; @@QWORD@@ = ( _QWORD * ) ( @@int64@@ + Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@int64@@ [ Number ] ) ( @@int64@@ , @@int64@@ [ Number ] ) ) ; if ( ( unsigned __int64 ) @@QWORD@@ >= @@int64@@ [ Number ] ) abort ( ) ; if ( ! * @@QWORD@@ ) return Number L ; for ( @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { if ( @@int64@@ == * @@QWORD@@ || ( ( unsigned __int8 ( __fastcall * ) ( __int64 , _QWORD ) ) @@int64@@ [ Number ] ) ( @@int64@@ , * @@QWORD@@ ) ) { return * @@QWORD@@ ; } } return Number L ; }
unsigned __int64 __fastcall hash_get_entries ( __int64 @@int64@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; @@unsignedint64@@ = Number L ; for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { for ( @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { if ( @@unsignedint64@@ >= @@unsignedint64@@ ) return @@unsignedint64@@ ; @@int64@@ = @@unsignedint64@@ ++ ; * ( _QWORD * ) ( @@int64@@ + Number * @@int64@@ ) = * @@QWORD@@ ; } } } return @@unsignedint64@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
_BOOL8 __fastcall same_name ( _BYTE * @@BYTE@@ , _BYTE * @@BYTE@@ ) { bool @@bool@@ ; int * @@int@@ ; int * @@int@@ ; bool @@bool@@ ; bool @@bool@@ ; const char * @@constchar@@ ; const char * @@constchar@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; char * @@char@@ ; char * @@char@@ ; struct stat @@structstat@@ ; struct stat @@structstat@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@constchar@@ = last_component ( @@BYTE@@ ) ; @@constchar@@ = last_component ( @@BYTE@@ ) ; @@sizet@@ = base_len ( @@constchar@@ ) ; @@sizet@@ = base_len ( @@constchar@@ ) ; @@bool@@ = @@sizet@@ == @@sizet@@ && ! memcmp ( @@constchar@@ , @@constchar@@ , @@sizet@@ ) ; @@bool@@ = Number ; if ( @@bool@@ ) { @@char@@ = ( char * ) dir_name ( ( __int64 ) @@BYTE@@ ) ; @@char@@ = ( char * ) dir_name ( ( __int64 ) @@BYTE@@ ) ; if ( ( unsigned int ) stat ( @@char@@ , & @@structstat@@ ) ) { @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , off_18B08 , @@char@@ ) ; } if ( ( unsigned int ) stat ( @@char@@ , & @@structstat@@ ) ) { @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , off_18B08 , @@char@@ ) ; } @@bool@@ = @@structstat@@ . st_ino == @@structstat@@ . st_ino && @@structstat@@ . st_dev == @@structstat@@ . st_dev ; @@bool@@ = @@bool@@ ; free ( @@char@@ ) ; free ( @@char@@ ) ; } return @@bool@@ ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ ) { return xmalloc ( @@int64@@ ) ; }
unsigned __int64 __fastcall hash_string ( _BYTE * @@BYTE@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = Number L ; while ( * @@BYTE@@ ) @@unsignedint64@@ = ( Number * @@unsignedint64@@ + ( unsigned __int8 ) * @@BYTE@@ ++ ) % @@unsignedint64@@ ; return @@unsignedint64@@ ; }
__int64 __fastcall next_prime ( unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = @@unsignedint64@@ ; if ( @@unsignedint64@@ <= Number ) @@int64@@ = Number L ; for ( @@int64@@ = @@int64@@ | Number ; @@int64@@ != Number && ! is_prime ( @@int64@@ ) ; @@int64@@ += Number L ) { ; } return @@int64@@ ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
unsigned __int64 __fastcall raw_hasher ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { return rotr_sz ( @@int64@@ , Number ) % @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
char * __fastcall areadlinkat ( int @@int@@ , const char * @@constchar@@ ) { signed __int64 @@signedint64@@ ; int @@int@@ ; char * @@char@@ ; __int64 @@int64@@ ; signed __int64 @@signedint64@@ ; size_t @@sizet@@ ; char * @@char@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@char@@ = @@char@@ ; @@int64@@ = Number L ; while ( Number ) { @@signedint64@@ = readlinkat ( @@int@@ , @@constchar@@ , @@char@@ , @@int64@@ ) ; if ( @@signedint64@@ < Number && * __errno_location ( ) != Number ) { if ( @@char@@ != @@char@@ ) { @@int@@ = * __errno_location ( ) ; free ( @@char@@ ) ; * __errno_location ( ) = @@int@@ ; } return Number L ; } if ( @@int64@@ > ( unsigned __int64 ) @@signedint64@@ ) break ; if ( @@char@@ != @@char@@ ) free ( @@char@@ ) ; @@int64@@ *= Number L ; if ( @@int64@@ < Number ) { * __errno_location ( ) = Number ; return Number L ; } @@char@@ = ( char * ) malloc ( @@int64@@ ) ; if ( ! @@char@@ ) return Number L ; } @@signedint64@@ = @@signedint64@@ ; @@sizet@@ = @@signedint64@@ + Number ; @@char@@ [ @@signedint64@@ ] = Number ; if ( @@char@@ == @@char@@ ) { @@char@@ = ( char * ) malloc ( @@sizet@@ ) ; if ( ! @@char@@ ) return Number L ; memcpy ( @@char@@ , @@char@@ , @@sizet@@ ) ; } else if ( @@int64@@ > @@sizet@@ ) { @@char@@ = ( char * ) realloc ( @@char@@ , @@sizet@@ ) ; if ( @@char@@ ) @@char@@ = @@char@@ ; } return @@char@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall check_tuning ( __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( ( _UNKNOWN * ) @@int64@@ == & default_tuning ) return Number L ; if ( * ( float * ) ( @@int64@@ + Number ) > Number && ( float ) ( Number - Number ) > * ( float * ) ( @@int64@@ + Number ) && * ( float * ) ( @@int64@@ + Number ) > ( float ) ( Number + Number ) && * ( float * ) @@int64@@ >= Number && * ( float * ) ( @@int64@@ + Number ) > ( float ) ( * ( float * ) @@int64@@ + Number ) && * ( float * ) ( @@int64@@ + Number ) <= Number && * ( float * ) ( @@int64@@ + Number ) > ( float ) ( * ( float * ) @@int64@@ + Number ) ) { return Number L ; } * ( _QWORD * ) ( @@int64@@ + Number ) = & default_tuning ; return Number L ; }
void __fastcall hash_free ( __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) && * ( _QWORD * ) ( @@int64@@ + Number ) ) { for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { for ( @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@int64@@ + Number ) ) ( * @@QWORD@@ ) ; } } } } for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { for ( @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; @@QWORD@@ ; @@QWORD@@ = @@QWORD@@ ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; free ( @@QWORD@@ ) ; } } for ( @@QWORD@@ = * ( _QWORD * * ) ( @@int64@@ + Number ) ; @@QWORD@@ ; @@QWORD@@ = @@QWORD@@ ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; free ( @@QWORD@@ ) ; } free ( * ( void * * ) @@int64@@ ) ; free ( ( void * ) @@int64@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 default_block_size ( ) { __int64 @@int64@@ ; if ( getenv ( String ) ) @@int64@@ = Number L ; else @@int64@@ = Number L ; return @@int64@@ ; }
__int64 __fastcall rpl_fcntl ( int @@int@@ , int @@int@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ ) { int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; if ( @@int@@ != Number ) return ( unsigned int ) fcntl ( @@int@@ , @@int@@ , @@int64@@ ) ; @@int@@ = @@int64@@ ; if ( have_dupfd_cloexec_2895 < Number ) { @@int@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@int@@ , Number , @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ ) ; } else { @@int@@ = fcntl ( @@int@@ , Number , ( unsigned int ) @@int64@@ ) ; if ( @@int@@ < Number && * __errno_location ( ) == Number ) { @@int@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@int@@ , Number , @@int@@ , @@int@@ , @@int@@ , @@int@@ ) ; if ( @@int@@ < Number ) return ( unsigned int ) @@int@@ ; have_dupfd_cloexec_2895 = Number ; } else { have_dupfd_cloexec_2895 = Number ; } } if ( @@int@@ >= Number && have_dupfd_cloexec_2895 == Number ) { @@int@@ = fcntl ( @@int@@ , Number ) ; if ( @@int@@ < Number || fcntl ( @@int@@ , Number , @@int@@ | Number ) == Number ) { @@int@@ = * __errno_location ( ) ; close ( @@int@@ ) ; * __errno_location ( ) = @@int@@ ; @@int@@ = Number ; } } return ( unsigned int ) @@int@@ ; }
__int64 __fastcall hash_find_entry ( __int64 @@int64@@ , __int64 @@int64@@ , _QWORD * @@QWORD@@ , char @@char@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; @@int64@@ = * ( _QWORD * ) @@int64@@ ; @@QWORD@@ = ( _QWORD * ) ( @@int64@@ + Number * ( * ( __int64 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@int64@@ + Number ) ) ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@QWORD@@ >= * ( _QWORD * ) ( @@int64@@ + Number ) ) abort ( ) ; * @@QWORD@@ = @@QWORD@@ ; if ( ! * @@QWORD@@ ) return Number L ; if ( @@int64@@ == * @@QWORD@@ || ( * ( unsigned __int8 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@int64@@ + Number ) ) ( @@int64@@ , * @@QWORD@@ ) ) { @@int64@@ = * @@QWORD@@ ; if ( @@char@@ ) { if ( @@QWORD@@ [ Number ] ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; @@int64@@ = @@QWORD@@ [ Number ] ; * @@QWORD@@ = * @@QWORD@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; free_entry ( @@int64@@ , @@QWORD@@ ) ; } else { * @@QWORD@@ = Number L ; } } @@int64@@ = @@int64@@ ; } else { for ( @@QWORD@@ = @@QWORD@@ ; ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { if ( ! @@QWORD@@ [ Number ] ) return Number L ; if ( @@int64@@ == * ( _QWORD * ) @@QWORD@@ [ Number ] || ( * ( unsigned __int8 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@int64@@ + Number ) ) ( @@int64@@ , * ( _QWORD * ) @@QWORD@@ [ Number ] ) ) { break ; } } @@int64@@ = * ( _QWORD * ) @@QWORD@@ [ Number ] ; if ( @@char@@ ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = @@QWORD@@ [ Number ] ; free_entry ( @@int64@@ , @@QWORD@@ ) ; } @@int64@@ = @@int64@@ ; } return @@int64@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
__int64 __fastcall read_utmp ( const char * @@constchar@@ , _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ , char @@char@@ ) { __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; struct utmpx * @@structutmpx@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; struct utmpx * @@structutmpx@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = Number L ; @@int64@@ = Number L ; @@int64@@ = Number L ; utmpxname ( @@constchar@@ ) ; setutxent ( ) ; while ( Number ) { @@structutmpx@@ = getutxent ( ) ; if ( ! @@structutmpx@@ ) break ; if ( desirable_utmp_entry ( ( __int64 ) @@structutmpx@@ , @@char@@ ) ) { if ( @@int64@@ == @@int64@@ ) @@int64@@ = x2nrealloc ( @@int64@@ , & @@int64@@ , Number L ) ; @@int64@@ = @@int64@@ ++ ; @@QWORD@@ = ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; @@structutmpx@@ = @@structutmpx@@ ; * @@QWORD@@ = * ( _QWORD * ) & @@structutmpx@@ -> ut_type ; @@QWORD@@ [ Number ] = * ( _QWORD * ) & @@structutmpx@@ -> __unused [ Number ] ; qmemcpy ( ( void * ) ( ( unsigned __int64 ) ( @@QWORD@@ + Number ) & Number ) , ( const void * ) ( ( char * ) @@structutmpx@@ - ( ( char * ) @@QWORD@@ - ( ( unsigned __int64 ) ( @@QWORD@@ + Number ) & Number ) ) ) , Number L * ( ( ( ( _DWORD ) @@QWORD@@ - ( ( ( _DWORD ) @@QWORD@@ + Number ) & Number ) + Number ) & Number ) >> Number ) ) ; } } endutxent ( ) ; * @@QWORD@@ = @@int64@@ ; * @@QWORD@@ = @@int64@@ ; return Number L ; }
__int64 __fastcall humblock ( char * @@char@@ , _QWORD * @@QWORD@@ , int * @@int@@ ) { char * @@char@@ ; int @@int@@ ; int @@int@@ ; unsigned int @@unsignedint@@ ; __int64 @@int642@@ [ Number ] ; @@char@@ = @@char@@ ; @@int642@@ [ Number ] = __readfsqword ( Number ) ; @@int@@ = Number ; if ( @@char@@ || ( @@char@@ = getenv ( String ) ) != Number L || ( @@char@@ = getenv ( String ) ) != Number L ) { if ( * @@char@@ == Number ) { @@int@@ = Number ; ++ @@char@@ ; } @@int@@ = argmatch ( @@char@@ , ( __int64 ) block_size_args , ( __int64 ) block_size_opts , Number ) ; if ( @@int@@ < Number ) { @@unsignedint@@ = xstrtoumax ( @@char@@ , @@int642@@ , Number L , @@QWORD@@ , String ) ; if ( @@unsignedint@@ ) { * @@int@@ = Number ; return @@unsignedint@@ ; } while ( * @@char@@ <= Number || * @@char@@ > Number ) { if ( @@char@@ == ( char * ) @@int642@@ [ Number ] ) { @@int@@ |= Number ; if ( * ( _BYTE * ) ( @@int642@@ [ Number ] - Number ) == Number ) @@int@@ |= Number ; if ( * ( _BYTE * ) ( @@int642@@ [ Number ] - Number ) != Number || * ( _BYTE * ) ( @@int642@@ [ Number ] - Number ) == Number ) @@int@@ |= Number ; break ; } ++ @@char@@ ; } } else { @@int@@ |= block_size_opts [ @@int@@ ] ; * @@QWORD@@ = Number L ; } } else { * @@QWORD@@ = default_block_size ( ) ; } * @@int@@ = @@int@@ ; return Number L ; }
int __fastcall mknod ( char * @@char@@ , __mode_t @@modet@@ , __dev_t @@devt@@ ) { __dev_t @@devt2@@ [ Number ] ; @@devt2@@ [ Number ] = @@devt@@ ; return __xmknod ( Number , @@char@@ , @@modet@@ , @@devt2@@ ) ; }
__int64 __fastcall getgidbyname ( const char * @@constchar@@ ) { __int64 @@int64@@ ; size_t @@sizet@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; struct group * @@structgroup@@ ; for ( @@int64@@ = group_alist ; @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ) { if ( * ( _BYTE * ) ( @@int64@@ + Number ) == * @@constchar@@ && ! strcmp ( ( const char * ) ( @@int64@@ + Number ) , @@constchar@@ ) ) { return @@int64@@ ; } } for ( @@int64@@ = nogroup_alist ; @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ) { if ( * ( _BYTE * ) ( @@int64@@ + Number ) == * @@constchar@@ && ! strcmp ( ( const char * ) ( @@int64@@ + Number ) , @@constchar@@ ) ) { return Number L ; } } @@structgroup@@ = getgrnam ( @@constchar@@ ) ; @@sizet@@ = strlen ( @@constchar@@ ) ; @@int64@@ = xmalloc ( @@sizet@@ + Number ) ; strcpy ( ( char * ) ( @@int64@@ + Number ) , @@constchar@@ ) ; if ( @@structgroup@@ ) { * ( _DWORD * ) @@int64@@ = @@structgroup@@ -> gr_gid ; * ( _QWORD * ) ( @@int64@@ + Number ) = group_alist ; group_alist = @@int64@@ ; @@int64@@ = @@int64@@ ; } else { * ( _QWORD * ) ( @@int64@@ + Number ) = nogroup_alist ; nogroup_alist = @@int64@@ ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
unsigned __int64 __fastcall users ( const char * @@constchar@@ , unsigned int @@unsignedint@@ ) { int * @@int@@ ; __int64 @@int64@@ ; void * @@void@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( ( unsigned int ) read_utmp ( @@constchar@@ , & @@int64@@ , & @@void@@ , @@unsignedint@@ ) ) { @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , String , @@constchar@@ ) ; } list_entries_users ( @@int64@@ , ( __int64 ) @@void@@ ) ; free ( @@void@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
__int64 __fastcall imaxtostr ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ + Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = Number ; if ( @@int64@@ >= Number ) { do { * ( _BYTE * ) -- @@int64@@ = ( char ) @@int64@@ % Number + Number ; @@int64@@ /= Number L ; } while ( @@int64@@ ) ; } else { do { * ( _BYTE * ) -- @@int64@@ = Number - ( char ) @@int64@@ % Number ; @@int64@@ /= Number L ; } while ( @@int64@@ ) ; * ( _BYTE * ) -- @@int64@@ = Number ; } return @@int64@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
void __fastcall mpsort ( __int64 * @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 ( __fastcall * @ @ VAR_1625 @ @ int64 ( fastcall ) ( int64 , int64 ) @ @ comparisonfunction ) ( __int64 , __int64 ) ) { mpsort_with_tmp ( @@int64@@ , @@unsignedint64@@ , & @@int64@@ [ @@unsignedint64@@ ] , @ @ VAR_1625 @ @ int64 ( fastcall ) ( int64 , int64 ) @ @ comparisonfunction ) ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return xmalloc ( @@int64@@ , @@int64@@ , @@int64@@ ) ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
__int64 __fastcall c_toupper ( int @@int@@ ) { __int64 @@int64@@ ; if ( @@int@@ <= Number || @@int@@ > Number ) @@int64@@ = ( unsigned int ) @@int@@ ; else @@int64@@ = ( unsigned int ) ( @@int@@ - Number ) ; return @@int64@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_207028 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_21FE88 ; @@int648@@ [ Number ] = qword_21FE90 ; @@int648@@ [ Number ] = qword_21FE98 ; @@int648@@ [ Number ] = qword_21FEA0 ; @@int648@@ [ Number ] = qword_21FEA8 ; @@int648@@ [ Number ] = qword_21FEB0 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ ) { return xmalloc ( @@int64@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_2070A8 ; @@int648@@ [ Number ] = qword_2070B0 ; @@int648@@ [ Number ] = qword_2070B8 ; @@int648@@ [ Number ] = qword_2070C0 ; @@int648@@ [ Number ] = qword_2070C8 ; @@int648@@ [ Number ] = qword_2070D0 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
__int64 __fastcall num_processors ( int @@int@@ ) { __int64 @@int64@@ ; int @@int@@ ; int @@int@@ ; char * @@char@@ ; char * @@char@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; cpu_set_t @@cpusett@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = @@int@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( @@int@@ == Number ) { @@char@@ = getenv ( String ) ; if ( @@char@@ ) { while ( * @@char@@ && ( unsigned __int8 ) c_isspace ( ( unsigned int ) * @@char@@ ) ) ++ @@char@@ ; if ( ( unsigned __int8 ) c_isdigit ( ( unsigned int ) * @@char@@ ) ) { @@char@@ = Number L ; @@unsignedint64@@ = strtoul ( @@char@@ , & @@char@@ , Number ) ; if ( @@char@@ ) { while ( * @@char@@ && ( unsigned __int8 ) c_isspace ( ( unsigned int ) * @@char@@ ) ) ++ @@char@@ ; if ( ! * @@char@@ ) { if ( @@unsignedint64@@ ) @@int64@@ = @@unsignedint64@@ ; else @@int64@@ = Number L ; return @@int64@@ ; } } } } @@int@@ = Number ; } if ( @@int@@ == Number ) { if ( ! sched_getaffinity ( Number , Number , & @@cpusett@@ ) ) { @@int@@ = __sched_cpucount ( Number , & @@cpusett@@ ) ; @@int64@@ = @@int@@ ; if ( @@int@@ ) return @@int64@@ ; } @@int64@@ = sysconf ( Number ) ; if ( @@int64@@ > Number ) return @@int64@@ ; } else { @@int64@@ = sysconf ( Number ) ; if ( @@int64@@ > Number ) return @@int64@@ ; } return Number L ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@unsignedint64@@ , int @@int@@ ) { __int64 @@int64@@ ; if ( is_mul_ok ( @@int@@ , * @@unsignedint64@@ ) ) { * @@unsignedint64@@ *= @@int@@ ; @@int64@@ = Number L ; } else { * @@unsignedint64@@ = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
__int64 __fastcall sha256_read_ctx ( __int64 @@int64@@ , __int64 @@int64@@ ) { int @@int@@ ; for ( @@int@@ = Number ; @@int@@ <= Number ; ++ @@int@@ ) set_uint32 ( ( _DWORD * ) ( Number L * @@int@@ + @@int64@@ ) , HIBYTE ( * ( _DWORD * ) ( @@int64@@ + Number L * @@int@@ ) ) | ( * ( _DWORD * ) ( @@int64@@ + Number L * @@int@@ ) >> Number ) & Number | ( * ( _DWORD * ) ( @@int64@@ + Number L * @@int@@ ) << Number ) & Number | ( * ( _DWORD * ) ( @@int64@@ + Number L * @@int@@ ) << Number ) ) ; return @@int64@@ ; }
__int64 __fastcall c_toupper ( int @@int@@ ) { __int64 @@int64@@ ; if ( @@int@@ <= Number || @@int@@ > Number ) @@int64@@ = ( unsigned int ) @@int@@ ; else @@int64@@ = ( unsigned int ) ( @@int@@ - Number ) ; return @@int64@@ ; }
__int64 __fastcall sha256_buffer ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; sha256_init_ctx ( ( __int64 ) @@char@@ ) ; sha256_process_bytes ( @@int64@@ , @@int64@@ , @@char@@ ) ; return sha256_finish_ctx ( ( __int64 ) @@char@@ , @@int64@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_207028 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall bad_cast ( __int64 @@int64@@ ) { return @@int64@@ ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
unsigned __int64 __fastcall sha256_process_bytes ( char * @@char@@ , unsigned __int64 @@unsignedint64@@ , size_t * @@sizet@@ ) { unsigned __int64 @@unsignedint64@@ ; size_t @@sizet@@ ; void * @@void@@ ; size_t @@sizet@@ ; char * @@char@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; @@char@@ = @@char@@ ; @@sizet@@ = @@unsignedint64@@ ; @@unsignedint64@@ = @@sizet@@ [ Number ] ; if ( @@unsignedint64@@ ) { @@sizet@@ = @@sizet@@ [ Number ] ; @@sizet@@ = Number - @@sizet@@ ; if ( @@unsignedint64@@ <= Number - @@sizet@@ ) @@sizet@@ = @@unsignedint64@@ ; @@sizet@@ = @@sizet@@ ; memcpy ( ( char * ) @@sizet@@ + @@sizet@@ + Number , @@char@@ , @@sizet@@ ) ; @@sizet@@ [ Number ] += @@sizet@@ ; if ( @@sizet@@ [ Number ] > Number ) { sha256_process_block ( @@sizet@@ + Number , @@sizet@@ [ Number ] & Number , @@sizet@@ ) ; @@sizet@@ [ Number ] &= Number ; memcpy ( @@sizet@@ + Number , ( char * ) @@sizet@@ + ( ( @@sizet@@ + @@sizet@@ ) & Number ) + Number , @@sizet@@ [ Number ] ) ; } @@char@@ = & @@char@@ [ @@sizet@@ ] ; @@unsignedint64@@ = @@sizet@@ ; @@sizet@@ = @@unsignedint64@@ - @@sizet@@ ; } if ( @@sizet@@ > Number ) { @@unsignedint64@@ = ( unsigned __int8 ) @@char@@ & Number ; if ( ( ( unsigned __int8 ) @@char@@ & Number ) != Number ) { while ( @@sizet@@ > Number ) { @@void@@ = memcpy ( @@sizet@@ + Number , @@char@@ , Number ) ; @@unsignedint64@@ = sha256_process_block ( @@void@@ , Number L , @@sizet@@ ) ; @@char@@ += Number ; @@sizet@@ -= Number L ; } } else { sha256_process_block ( @@char@@ , @@sizet@@ & Number , @@sizet@@ ) ; @@unsignedint64@@ = @@sizet@@ & Number ; @@char@@ += @@sizet@@ & Number ; @@sizet@@ &= Number ; } } if ( @@sizet@@ ) { @@sizet@@ = @@sizet@@ [ Number ] ; memcpy ( ( char * ) @@sizet@@ + @@sizet@@ + Number , @@char@@ , @@sizet@@ ) ; @@sizet@@ = @@sizet@@ + @@sizet@@ ; if ( @@sizet@@ > Number ) { sha256_process_block ( @@sizet@@ + Number , Number L , @@sizet@@ ) ; @@sizet@@ -= Number L ; memcpy ( @@sizet@@ + Number , @@sizet@@ + Number , @@sizet@@ ) ; } @@unsignedint64@@ = ( unsigned __int64 ) @@sizet@@ ; @@sizet@@ [ Number ] = @@sizet@@ ; } return @@unsignedint64@@ ; }
__int64 __fastcall nstrftime ( char * @@char@@ , __int64 @@int64@@ , char * @@char@@ , __int64 @@int64@@ , int @@int@@ , int @@int@@ ) { return strftime_case_ ( Number , @@char@@ , @@int64@@ , @@char@@ , @@int64@@ , @@int@@ , @@int@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall uid_to_name ( __uid_t @@uidt@@ ) { __int64 @@int64@@ ; struct passwd * @@structpasswd@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@structpasswd@@ = getpwuid ( @@uidt@@ ) ; if ( @@structpasswd@@ ) @@int64@@ = ( __int64 ) @@structpasswd@@ -> pw_name ; else @@int64@@ = umaxtostr ( @@uidt@@ , @@char@@ ) ; return xstrdup ( @@int64@@ ) ; }
__int64 __fastcall xnrealloc ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { if ( ! is_mul_ok ( @@unsignedint64@@ , @@unsignedint64@@ ) ) xalloc_die ( ) ; return xrealloc ( @@int64@@ , @@unsignedint64@@ * @@unsignedint64@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_20D0E8 ; @@int648@@ [ Number ] = qword_20D0F0 ; @@int648@@ [ Number ] = qword_20D0F8 ; @@int648@@ [ Number ] = qword_20D100 ; @@int648@@ [ Number ] = qword_20D108 ; @@int648@@ [ Number ] = qword_20D110 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
unsigned __int64 __fastcall xstrtol_error ( unsigned int @@unsignedint@@ , int @@int@@ , char @@char@@ , __int64 @@int64@@ , __int64 @@int64@@ , int @@int@@ ) { char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; char @@char2@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@char@@ = ( char * ) & unk_1A278 ; if ( @@unsignedint@@ > Number ) { if ( @@unsignedint@@ != Number ) goto LABEL_6 ; @@char@@ = String ; } else if ( @@unsignedint@@ >= Number ) { @@char@@ = String ; } else { if ( @@unsignedint@@ != Number ) LABEL_6 : abort ( ) ; @@char@@ = String ; } if ( @@int@@ >= Number ) { @@char@@ = * ( char * * ) ( Number L * @@int@@ + @@int64@@ ) ; } else { @@char@@ = ( char * ) & unk_1A278 - @@int@@ ; @@char2@@ [ Number ] = @@char@@ ; @@char2@@ [ Number ] = Number ; @@char@@ = @@char2@@ ; } @@char@@ = gettext ( @@char@@ ) ; error ( @@int@@ , Number , @@char@@ , @@char@@ , @@char@@ , @@int64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall restricted_chown ( int @@int@@ , const char * @@constchar@@ , __int64 @@int64@@ , __uid_t @@uidt@@ , __gid_t @@gidt@@ , int @@int@@ , int @@int@@ ) { __int64 @@int64@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; struct stat @@structstat@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@unsignedint@@ = Number ; @@int@@ = Number ; if ( @@int@@ == Number && @@int@@ == Number ) return Number L ; if ( ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number ) { if ( ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number ) return Number L ; @@int@@ = Number ; } @@int@@ = openat ( @@int@@ , @@constchar@@ , @@int@@ ) ; if ( @@int@@ < Number ) { if ( * __errno_location ( ) != Number || ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number || ( @@int@@ = openat ( @@int@@ , @@constchar@@ , @@int@@ | Number ) , @@int@@ < Number ) ) { if ( * __errno_location ( ) == Number ) @@int64@@ = Number L ; else @@int64@@ = Number L ; return @@int64@@ ; } } if ( ( unsigned int ) fstat ( @@int@@ , & @@structstat@@ ) ) { @@unsignedint@@ = Number ; LABEL_30 : @@int@@ = * __errno_location ( ) ; close ( @@int@@ ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint@@ ; } if ( * ( _QWORD * ) ( @@int64@@ + Number ) != @@structstat@@ . st_ino || * ( _QWORD * ) @@int64@@ != @@structstat@@ . st_dev ) { @@unsignedint@@ = Number ; goto LABEL_30 ; } if ( @@int@@ != Number && @@int@@ != @@structstat@@ . st_uid || @@int@@ != Number && @@int@@ != @@structstat@@ . st_gid ) { goto LABEL_30 ; } if ( fchown ( @@int@@ , @@uidt@@ , @@gidt@@ ) ) { @@unsignedint@@ = Number ; goto LABEL_30 ; } if ( close ( @@int@@ ) ) LODWORD ( @@int64@@ ) = Number ; else LODWORD ( @@int64@@ ) = Number ; return ( unsigned int ) @@int64@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_206028 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall sha256_stream ( FILE * @@FILE@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; char * @@char@@ ; size_t @@sizet@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@char@@ = ( char * ) malloc ( Number ) ; if ( ! @@char@@ ) return Number L ; sha256_init_ctx ( ( __int64 ) @@char@@ ) ; LABEL_4 : @@int64@@ = Number L ; while ( Number ) { @@sizet@@ = fread_unlocked ( & @@char@@ [ @@int64@@ ] , Number , Number - @@int64@@ , @@FILE@@ ) ; @@int64@@ += @@sizet@@ ; if ( @@int64@@ == Number ) { sha256_process_block ( @@char@@ , Number , @@char@@ ) ; goto LABEL_4 ; } if ( ! @@sizet@@ ) break ; if ( feof_unlocked ( @@FILE@@ ) ) goto LABEL_12 ; } if ( ferror_unlocked ( @@FILE@@ ) ) { free ( @@char@@ ) ; return Number L ; } LABEL_12 : if ( @@int64@@ ) sha256_process_bytes ( @@char@@ , @@int64@@ , @@char@@ ) ; sha256_finish_ctx ( ( __int64 ) @@char@@ , @@int64@@ ) ; free ( @@char@@ ) ; return Number L ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
void __fastcall free_dir ( __int64 @@int64@@ ) { if ( ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number ) { if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) hash_free ( * ( _QWORD * ) ( @@int64@@ + Number ) ) ; } else { free ( * ( void * * ) ( @@int64@@ + Number ) ) ; } }
void __fastcall describe_change ( __int64 @@int64@@ , int @@int@@ , const char * @@constchar@@ , const char * @@constchar@@ ) { __int64 @@int64@@ ; char * @@char@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; void * @@void@@ ; char * @@char@@ ; @@char@@ = Number L ; if ( @@int@@ == Number ) { @@int64@@ = quote ( @@int64@@ ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } else { if ( @@constchar@@ ) { if ( @@constchar@@ ) { @@sizet@@ = strlen ( @@constchar@@ ) ; @@sizet@@ = strlen ( @@constchar@@ ) ; @@char@@ = ( char * ) xmalloc ( @@sizet@@ + @@sizet@@ + Number ) ; @@char@@ = stpcpy ( @@char@@ , @@constchar@@ ) ; * ( _WORD * ) @@char@@ = Number ; strcpy ( @@char@@ + Number , @@constchar@@ ) ; @@void@@ = @@char@@ ; } else { @@void@@ = ( void * ) @@constchar@@ ; } } else { @@void@@ = ( void * ) @@constchar@@ ; } switch ( @@int@@ ) { case Number : if ( @@constchar@@ ) { @@char@@ = gettext ( String ) ; } else if ( @@constchar@@ ) { @@char@@ = gettext ( String ) ; } else { @@char@@ = gettext ( String ) ; } @@char@@ = @@char@@ ; break ; case Number : if ( @@constchar@@ ) { @@char@@ = gettext ( String ) ; } else if ( @@constchar@@ ) { @@char@@ = gettext ( String ) ; } else { @@char@@ = gettext ( String ) ; } @@char@@ = @@char@@ ; break ; case Number : if ( @@constchar@@ ) { @@char@@ = gettext ( String ) ; } else if ( @@constchar@@ ) { @@char@@ = gettext ( String ) ; } else { @@char@@ = gettext ( String ) ; } @@char@@ = @@char@@ ; break ; default : abort ( ) ; } @@int64@@ = quote ( @@int64@@ ) ; printf ( @@char@@ , @@int64@@ , @@void@@ ) ; free ( @@char@@ ) ; } }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall fts_set_stat_required ( __int64 @@int64@@ , char @@char@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; if ( * ( _WORD * ) ( @@int64@@ + Number ) != Number ) abort ( ) ; if ( @@char@@ ) @@int64@@ = Number L ; else @@int64@@ = Number L ; @@int64@@ = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; return @@int64@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
__int64 __fastcall sha224_read_ctx ( __int64 @@int64@@ , __int64 @@int64@@ ) { int @@int@@ ; for ( @@int@@ = Number ; @@int@@ <= Number ; ++ @@int@@ ) set_uint32 ( ( _DWORD * ) ( Number L * @@int@@ + @@int64@@ ) , HIBYTE ( * ( _DWORD * ) ( @@int64@@ + Number L * @@int@@ ) ) | ( * ( _DWORD * ) ( @@int64@@ + Number L * @@int@@ ) >> Number ) & Number | ( * ( _DWORD * ) ( @@int64@@ + Number L * @@int@@ ) << Number ) & Number | ( * ( _DWORD * ) ( @@int64@@ + Number L * @@int@@ ) << Number ) ) ; return @@int64@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall cwd_advance_fd ( __int64 @@int64@@ , int @@int@@ , char @@char@@ ) { __int64 @@int64@@ ; int @@int@@ ; int @@int@@ ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) ; if ( @@int@@ == @@int@@ && @@int@@ != Number ) abort ( ) ; if ( @@char@@ ) { @@int@@ = i_ring_push ( @@int64@@ + Number , ( unsigned int ) @@int@@ ) ; if ( @@int@@ >= Number ) close ( @@int@@ ) ; } else if ( ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) == Number && @@int@@ >= Number ) { close ( @@int@@ ) ; } @@int64@@ = @@int64@@ ; * ( _DWORD * ) ( @@int64@@ + Number ) = @@int@@ ; return @@int64@@ ; }
unsigned __int64 __fastcall leave_dir ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 * @@int64@@ ; __int64 * @@int64@@ ; void * @@void@@ ; __int64 @@int643@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = ( __int64 * ) ( @@int64@@ + Number ) ; if ( ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number ) { @@int643@@ [ Number ] = * @@int64@@ ; @@int643@@ [ Number ] = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@void@@ = ( void * ) hash_delete ( * ( _QWORD * ) ( @@int64@@ + Number ) , @@int643@@ ) ; if ( ! @@void@@ ) abort ( ) ; free ( @@void@@ ) ; } else { @@int64@@ = * ( __int64 * * ) ( @@int64@@ + Number ) ; if ( @@int64@@ && @@int64@@ [ Number ] >= Number ) { if ( ! * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) ) abort ( ) ; if ( * * ( _QWORD * * ) ( @@int64@@ + Number ) == * ( _QWORD * ) ( @@int64@@ + Number ) && * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) == * @@int64@@ ) { * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) = @@int64@@ [ Number ] ; * * ( _QWORD * * ) ( @@int64@@ + Number ) = @@int64@@ [ Number ] ; } } } return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall sha224_buffer ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; sha224_init_ctx ( ( __int64 ) @@char@@ ) ; sha256_process_bytes ( @@int64@@ , @@int64@@ , @@char@@ ) ; return sha224_finish_ctx ( ( __int64 ) @@char@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_20D0E8 ; @@int648@@ [ Number ] = qword_20D0F0 ; @@int648@@ [ Number ] = qword_20D0F8 ; @@int648@@ [ Number ] = qword_20D100 ; @@int648@@ [ Number ] = qword_20D108 ; @@int648@@ [ Number ] = qword_20D110 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
__int64 __fastcall link_count_optimize_ok ( __int64 @@int64@@ ) { __int64 @@int64@@ ; bool @@bool@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; _BYTE * @@BYTE@@ ; __int64 @@int644@@ [ Number ] ; @@int644@@ [ Number ] = __readfsqword ( Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) == Number ) return Number L ; if ( ! @@int64@@ ) { * ( _QWORD * ) ( @@int64@@ + Number ) = hash_initialize ( Number L , Number L , LCO_hash , LCO_compare , & free ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( ! @@int64@@ ) return Number L ; } @@int644@@ [ Number ] = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = hash_lookup ( @@int64@@ , @@int644@@ ) ; if ( @@int64@@ ) return * ( unsigned __int8 * ) ( @@int64@@ + Number ) ; @@BYTE@@ = malloc ( Number ) ; if ( ! @@BYTE@@ ) return Number L ; @@bool@@ = leaf_optimization_applies ( * ( _DWORD * ) ( @@int64@@ + Number ) ) ; @@BYTE@@ [ Number ] = @@bool@@ ; * ( _QWORD * ) @@BYTE@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = hash_insert ( @@int64@@ , @@BYTE@@ ) ; if ( @@int64@@ ) { if ( ( _BYTE * ) @@int64@@ != @@BYTE@@ ) abort ( ) ; @@int64@@ = @@bool@@ ; } else { free ( @@BYTE@@ ) ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return xmalloc ( @@int64@@ , @@int64@@ , @@int64@@ ) ; }
_BOOL8 __fastcall leaf_optimization_applies ( int @@int@@ ) { _BOOL8 @@BOOL8@@ ; struct statfs @@structstatfs@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( fstatfs ( @@int@@ , & @@structstatfs@@ ) ) @@BOOL8@@ = Number L ; else @@BOOL8@@ = @@structstatfs@@ . f_type == Number ; return @@BOOL8@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
__int64 __fastcall sha256_stream ( FILE * @@FILE@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; char * @@char@@ ; size_t @@sizet@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@char@@ = ( char * ) malloc ( Number ) ; if ( ! @@char@@ ) return Number L ; sha256_init_ctx ( ( __int64 ) @@char@@ ) ; LABEL_4 : @@int64@@ = Number L ; while ( Number ) { @@sizet@@ = fread_unlocked ( & @@char@@ [ @@int64@@ ] , Number , Number - @@int64@@ , @@FILE@@ ) ; @@int64@@ += @@sizet@@ ; if ( @@int64@@ == Number ) { sha256_process_block ( @@char@@ , Number , @@char@@ ) ; goto LABEL_4 ; } if ( ! @@sizet@@ ) break ; if ( feof_unlocked ( @@FILE@@ ) ) goto LABEL_12 ; } if ( ferror_unlocked ( @@FILE@@ ) ) { free ( @@char@@ ) ; return Number L ; } LABEL_12 : if ( @@int64@@ ) sha256_process_bytes ( @@char@@ , @@int64@@ , @@char@@ ) ; sha256_finish_ctx ( ( __int64 ) @@char@@ , @@int64@@ ) ; free ( @@char@@ ) ; return Number L ; }
__int64 __fastcall fts_compare_ino ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; if ( * ( _QWORD * ) ( * ( _QWORD * ) @@int64@@ + Number L ) < * ( _QWORD * ) ( * ( _QWORD * ) @@int64@@ + Number L ) ) @@int64@@ = Number ; else @@int64@@ = * ( _QWORD * ) ( * ( _QWORD * ) @@int64@@ + Number L ) < * ( _QWORD * ) ( * ( _QWORD * ) @@int64@@ + Number L ) ; return @@int64@@ ; }
__int64 __fastcall fts_padjust ( __int64 @@int64@@ , _QWORD * @@QWORD@@ ) { _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; for ( @@QWORD@@ = * ( _QWORD * * ) ( @@int64@@ + Number ) ; @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { if ( ( _QWORD * ) @@QWORD@@ [ Number ] != @@QWORD@@ + Number ) @@QWORD@@ [ Number ] = @@int64@@ + @@QWORD@@ [ Number ] - @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; } while ( Number ) { @@int64@@ = @@QWORD@@ [ Number ] ; if ( @@int64@@ < Number ) break ; if ( ( _QWORD * ) @@QWORD@@ [ Number ] != @@QWORD@@ + Number ) @@QWORD@@ [ Number ] = @@int64@@ + @@QWORD@@ [ Number ] - @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; if ( @@QWORD@@ [ Number ] ) @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; else @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; @@QWORD@@ = @@QWORD@@ ; } return @@int64@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
__int64 __fastcall rpl_fcntl ( int @@int@@ , int @@int@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ ) { int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; if ( @@int@@ != Number ) return ( unsigned int ) fcntl ( @@int@@ , @@int@@ , @@int64@@ ) ; @@int@@ = @@int64@@ ; if ( have_dupfd_cloexec_2895 < Number ) { @@int@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@int@@ , Number , @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ ) ; } else { @@int@@ = fcntl ( @@int@@ , Number , ( unsigned int ) @@int64@@ ) ; if ( @@int@@ < Number && * __errno_location ( ) == Number ) { @@int@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@int@@ , Number , @@int@@ , @@int@@ , @@int@@ , @@int@@ ) ; if ( @@int@@ < Number ) return ( unsigned int ) @@int@@ ; have_dupfd_cloexec_2895 = Number ; } else { have_dupfd_cloexec_2895 = Number ; } } if ( @@int@@ >= Number && have_dupfd_cloexec_2895 == Number ) { @@int@@ = fcntl ( @@int@@ , Number ) ; if ( @@int@@ < Number || fcntl ( @@int@@ , Number , @@int@@ | Number ) == Number ) { @@int@@ = * __errno_location ( ) ; close ( @@int@@ ) ; * __errno_location ( ) = @@int@@ ; @@int@@ = Number ; } } return ( unsigned int ) @@int@@ ; }
__int64 __fastcall fts_sort ( __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { size_t @@sizet@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; int ( * @ @ VAR_637 @ @ int ( ) ( constvoid , constvoid ) @ @ int ( ) ( constvoid , constvoid ) ) ( const void * , const void * ) ; void * @@void@@ ; @@sizet@@ = @@sizet@@ ; @ @ VAR_637 @ @ int ( ) ( constvoid , constvoid ) @ @ int ( ) ( constvoid , constvoid ) = * ( int ( * * ) ( const void * , const void * ) ) ( @@int64@@ + Number ) ; if ( @@sizet@@ > * ( _QWORD * ) ( @@int64@@ + Number ) ) { * ( _QWORD * ) ( @@int64@@ + Number ) = @@sizet@@ + Number ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) > Number || ( @@void@@ = realloc ( * ( void * * ) ( @@int64@@ + Number ) , Number L * * ( _QWORD * ) ( @@int64@@ + Number ) ) ) == Number L ) { free ( * ( void * * ) ( @@int64@@ + Number ) ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number L ; return @@int64@@ ; } * ( _QWORD * ) ( @@int64@@ + Number ) = @@void@@ ; } @@QWORD@@ = * ( _QWORD * * ) ( @@int64@@ + Number ) ; for ( @@int64@@ = @@int64@@ ; @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ) { @@QWORD@@ = @@QWORD@@ ++ ; * @@QWORD@@ = @@int64@@ ; } qsort ( * ( void * * ) ( @@int64@@ + Number ) , @@sizet@@ , Number , @ @ VAR_637 @ @ int ( ) ( constvoid , constvoid ) @ @ int ( ) ( constvoid , constvoid ) ) ; @@QWORD@@ = * ( _QWORD * * ) ( @@int64@@ + Number ) ; @@int64@@ = * @@QWORD@@ ; while ( -- @@sizet@@ ) { * ( _QWORD * ) ( * @@QWORD@@ + Number L ) = @@QWORD@@ [ Number ] ; ++ @@QWORD@@ ; } * ( _QWORD * ) ( * @@QWORD@@ + Number L ) = Number L ; return @@int64@@ ; }
int __fastcall hash_print_statistics ( __int64 @@int64@@ , FILE * @@FILE@@ ) { double @@double@@ ; double @@double@@ ; double @@double@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int64@@ = hash_get_n_entries ( @@int64@@ ) ; @@int64@@ = hash_get_n_buckets ( @@int64@@ ) ; @@int64@@ = hash_get_n_buckets_used ( @@int64@@ ) ; @@unsignedint64@@ = hash_get_max_bucket_length ( @@int64@@ ) ; fprintf ( @@FILE@@ , String , @@int64@@ ) ; fprintf ( @@FILE@@ , String , @@int64@@ ) ; if ( @@int64@@ < Number ) @@double@@ = ( double ) ( int ) ( @@int64@@ & Number | ( ( unsigned __int64 ) @@int64@@ >> Number ) ) + ( double ) ( int ) ( @@int64@@ & Number | ( ( unsigned __int64 ) @@int64@@ >> Number ) ) ; else @@double@@ = ( double ) ( int ) @@int64@@ ; @@double@@ = Number * @@double@@ ; if ( @@int64@@ < Number ) @@double@@ = ( double ) ( int ) ( @@int64@@ & Number | ( ( unsigned __int64 ) @@int64@@ >> Number ) ) + ( double ) ( int ) ( @@int64@@ & Number | ( ( unsigned __int64 ) @@int64@@ >> Number ) ) ; else @@double@@ = ( double ) ( int ) @@int64@@ ; fprintf ( @@FILE@@ , String , @@int64@@ , @@double@@ / @@double@@ ) ; return fprintf ( @@FILE@@ , String , @@unsignedint64@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall head_bytes ( __int64 @@int64@@ , unsigned int @@unsignedint@@ , unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; char * @@char@@ ; int * @@int@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@unsignedint64@@ = Number ; while ( @@unsignedint64@@ ) { if ( @@unsignedint64@@ < @@unsignedint64@@ ) @@unsignedint64@@ = @@unsignedint64@@ ; @@unsignedint64@@ = safe_read ( @@unsignedint@@ , @@char@@ , @@unsignedint64@@ ) ; if ( @@unsignedint64@@ == Number ) { @@int64@@ = quote ( @@int64@@ ) ; @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ , @@int64@@ ) ; return Number L ; } if ( ! @@unsignedint64@@ ) break ; if ( @@unsignedint64@@ > fwrite_unlocked ( @@char@@ , Number , @@unsignedint64@@ , stdout ) ) { @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ ) ; } @@unsignedint64@@ -= @@unsignedint64@@ ; } return Number L ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
unsigned __int64 __fastcall hash_get_max_bucket_length ( __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = Number L ; for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { @@QWORD@@ = @@QWORD@@ ; for ( @@unsignedint64@@ = Number L ; ; ++ @@unsignedint64@@ ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; if ( ! @@QWORD@@ ) break ; } if ( @@unsignedint64@@ > @@unsignedint64@@ ) @@unsignedint64@@ = @@unsignedint64@@ ; } } return @@unsignedint64@@ ; }
__int64 __fastcall next_prime ( unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = @@unsignedint64@@ ; if ( @@unsignedint64@@ <= Number ) @@int64@@ = Number L ; for ( @@int64@@ = @@int64@@ | Number ; @@int64@@ != Number && ! is_prime ( @@int64@@ ) ; @@int64@@ += Number L ) { ; } return @@int64@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_2060A8 ; @@int648@@ [ Number ] = qword_2060B0 ; @@int648@@ [ Number ] = qword_2060B8 ; @@int648@@ [ Number ] = qword_2060C0 ; @@int648@@ [ Number ] = qword_2060C8 ; @@int648@@ [ Number ] = qword_2060D0 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
__int64 __fastcall head_file ( const char * @@constchar@@ , size_t @@sizet@@ , char @@char@@ , char @@char@@ ) { int @@int@@ ; unsigned __int8 @@unsignedint8@@ ; __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; const char * @@constchar@@ ; bool @@bool@@ ; unsigned __int8 @@unsignedint8@@ ; int @@int@@ ; @@constchar@@ = @@constchar@@ ; @@int@@ = strcmp ( @@constchar@@ , String ) ; @@bool@@ = @@int@@ == Number ; if ( @@int@@ ) { @@int@@ = open ( @@constchar@@ , Number ) ; if ( @@int@@ < Number ) { @@int64@@ = quote ( @@constchar@@ ) ; @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ , @@int64@@ ) ; return Number L ; } @@unsignedint8@@ = head ( @@constchar@@ , @@int@@ , @@sizet@@ , @@char@@ , @@char@@ ) ; } else { have_read_stdin = Number ; @@int@@ = Number ; @@constchar@@ = gettext ( String ) ; @@unsignedint8@@ = head ( @@constchar@@ , Number , @@sizet@@ , @@char@@ , @@char@@ ) ; } @@unsignedint8@@ = @@unsignedint8@@ ; if ( @@bool@@ || ! close ( @@int@@ ) ) return @@unsignedint8@@ ; @@int64@@ = quote ( @@constchar@@ ) ; @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ , @@int64@@ ) ; return Number L ; }
unsigned __int64 __fastcall hash_get_entries ( __int64 @@int64@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; @@unsignedint64@@ = Number L ; for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { for ( @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { if ( @@unsignedint64@@ >= @@unsignedint64@@ ) return @@unsignedint64@@ ; @@int64@@ = @@unsignedint64@@ ++ ; * ( _QWORD * ) ( @@int64@@ + Number * @@int64@@ ) = * @@QWORD@@ ; } } } return @@unsignedint64@@ ; }
unsigned __int64 __fastcall compute_bucket_size ( __int64 @@int64@@ , __int64 @@int64@@ ) { float @@float@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; float @@float@@ ; @@unsignedint64@@ = @@int64@@ ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) != Number ) { if ( @@int64@@ < Number ) @@float@@ = ( float ) ( @@int64@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@int64@@ >> Number ) ) + ( float ) ( @@int64@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@int64@@ >> Number ) ) ; else @@float@@ = ( float ) ( int ) @@int64@@ ; @@float@@ = @@float@@ / * ( float * ) ( @@int64@@ + Number ) ; if ( @@float@@ >= Number ) return Number L ; if ( @@float@@ >= Number ) @@unsignedint64@@ = ( unsigned int ) ( int ) ( float ) ( @@float@@ - Number ) ^ Number ; else @@unsignedint64@@ = ( unsigned int ) ( int ) @@float@@ ; } @@unsignedint64@@ = next_prime ( @@unsignedint64@@ ) ; if ( @@unsignedint64@@ <= Number ) @@unsignedint64@@ = @@unsignedint64@@ ; else @@unsignedint64@@ = Number L ; return @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
void * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
unsigned __int64 __fastcall hash_string ( _BYTE * @@BYTE@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = Number L ; while ( * @@BYTE@@ ) @@unsignedint64@@ = ( Number * @@unsignedint64@@ + ( unsigned __int8 ) * @@BYTE@@ ++ ) % @@unsignedint64@@ ; return @@unsignedint64@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
void * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return xmalloc ( @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
void * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
__int64 __fastcall bad_cast ( __int64 @@int64@@ ) { return @@int64@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
void * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
bool __fastcall hex_digits ( _BYTE * @@BYTE@@ ) { unsigned int @@unsignedint@@ ; for ( @@unsignedint@@ = Number ; @@unsignedint@@ < ( unsigned __int64 ) digest_hex_bytes ; ++ @@unsignedint@@ ) { if ( ( ( * __ctype_b_loc ( ) ) [ ( unsigned __int8 ) * @@BYTE@@ ] & Number ) == Number ) return Number ; ++ @@BYTE@@ ; } return * @@BYTE@@ == Number ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_2090E8 ; @@int648@@ [ Number ] = qword_2090F0 ; @@int648@@ [ Number ] = qword_2090F8 ; @@int648@@ [ Number ] = qword_209100 ; @@int648@@ [ Number ] = qword_209108 ; @@int648@@ [ Number ] = qword_209110 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
void * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall digest_file ( const char * @@constchar@@ , __int64 a2 , __int64 @@int64@@ ) { int @@int@@ ; int @@int@@ ; int * @@int@@ ; int * @@int@@ ; bool @@bool@@ ; FILE * @@FILE@@ ; @@int@@ = strcmp ( @@constchar@@ , String ) ; @@bool@@ = @@int@@ == Number ; if ( @@int@@ ) { @@FILE@@ = ( FILE * ) fopen_safer ( @@constchar@@ , String ) ; if ( ! @@FILE@@ ) goto LABEL_4 ; @@int@@ = sha224_stream ( @@FILE@@ , @@int64@@ ) ; } else { have_read_stdin = Number ; @@FILE@@ = stdin ; @@int@@ = sha224_stream ( stdin , @@int64@@ ) ; } if ( ! @@int@@ ) { if ( @@bool@@ || ! fclose ( @@FILE@@ ) ) return Number L ; LABEL_4 : @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , String , @@constchar@@ ) ; return Number L ; } @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , String , @@constchar@@ ) ; if ( @@FILE@@ != stdin ) fclose ( @@FILE@@ ) ; return Number L ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
void * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
void * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
void * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
__ino_t * __fastcall get_root_dev_ino ( __ino_t * @@inot@@ ) { struct stat @@structstat@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( ( unsigned int ) lstat ( String , & @@structstat@@ ) ) return Number L ; * @@inot@@ = @@structstat@@ . st_ino ; @@inot@@ [ Number ] = @@structstat@@ . st_dev ; return @@inot@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
__int64 __fastcall sha224_read_ctx ( __int64 @@int64@@ , __int64 @@int64@@ ) { int @@int@@ ; for ( @@int@@ = Number ; @@int@@ <= Number ; ++ @@int@@ ) set_uint32 ( ( _DWORD * ) ( Number L * @@int@@ + @@int64@@ ) , HIBYTE ( * ( _DWORD * ) ( @@int64@@ + Number L * @@int@@ ) ) | ( * ( _DWORD * ) ( @@int64@@ + Number L * @@int@@ ) >> Number ) & Number | ( * ( _DWORD * ) ( @@int64@@ + Number L * @@int@@ ) << Number ) & Number | ( * ( _DWORD * ) ( @@int64@@ + Number L * @@int@@ ) << Number ) ) ; return @@int64@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_20D028 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
char * __fastcall parse_user_spec ( char * @@char@@ , int * @@int@@ , __gid_t * @@gidt@@ , char * * @@char@@ , void * * @@void@@ ) { char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; @@char@@ = strchr ( @@char@@ , Number ) ; @@char@@ = parse_with_separator ( @@char@@ , @@char@@ , @@int@@ , @@gidt@@ , @@char@@ , @@void@@ ) ; if ( ! @@char@@ ) { if ( @@char@@ ) { @@char@@ = strchr ( @@char@@ , Number ) ; if ( @@char@@ ) { if ( ! parse_with_separator ( @@char@@ , @@char@@ , @@int@@ , @@gidt@@ , @@char@@ , @@void@@ ) ) @@char@@ = Number L ; } } } return @@char@@ ; }
void * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall sha224_buffer ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; sha224_init_ctx ( ( __int64 ) @@char@@ ) ; sha256_process_bytes ( @@int64@@ , @@int64@@ , @@char@@ ) ; return sha224_finish_ctx ( ( __int64 ) @@char@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return xmalloc ( @@int64@@ , @@int64@@ , @@int64@@ ) ; }
void * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
void * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
__int64 __fastcall elide_tail_lines_file ( __int64 @@int64@@ , unsigned int @@unsignedint@@ , size_t @@sizet@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; if ( presume_input_pipe == Number ) return elide_tail_lines_pipe ( @@int64@@ , @@unsignedint@@ , @@sizet@@ ) ; @@int64@@ = lseek ( @@unsignedint@@ , Number L , Number ) ; @@int64@@ = lseek ( @@unsignedint@@ , Number L , Number ) ; if ( @@int64@@ < Number || @@int64@@ >= @@int64@@ ) return elide_tail_lines_pipe ( @@int64@@ , @@unsignedint@@ , @@sizet@@ ) ; if ( @@int64@@ ) return elide_tail_lines_seekable ( @@int64@@ , @@unsignedint@@ , @@sizet@@ , @@int64@@ , @@int64@@ ) ; return Number L ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return xmalloc ( @@int64@@ , @@int64@@ , @@int64@@ ) ; }
void * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall set_cloexec_flag ( int @@int@@ , char @@char@@ , __int64 a3 , int @@int@@ , int @@int@@ , int @@int@@ ) { int @@int@@ ; int @@int@@ ; int @@int@@ ; unsigned int @@unsignedint@@ ; __int64 @@int64@@ ; int @@int@@ ; @@int@@ = rpl_fcntl ( @@int@@ , Number , Number , @@int@@ , @@int@@ , @@int@@ ) ; if ( @@int@@ < Number || ( ! @@char@@ ? ( @@unsignedint@@ = @@int@@ & Number ) : ( @@unsignedint@@ = @@int@@ | Number ) , @@int@@ != @@unsignedint@@ && ( unsigned int ) rpl_fcntl ( @@int@@ , Number , @@unsignedint@@ , @@int@@ , @@int@@ , @@int@@ ) == Number ) ) { @@int64@@ = Number ; } else { @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall rpl_fcntl ( int @@int@@ , int @@int@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ ) { int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; if ( @@int@@ != Number ) return ( unsigned int ) fcntl ( @@int@@ , @@int@@ , @@int64@@ ) ; @@int@@ = @@int64@@ ; if ( have_dupfd_cloexec_2895 < Number ) { @@int@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@int@@ , Number , @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ ) ; } else { @@int@@ = fcntl ( @@int@@ , Number , ( unsigned int ) @@int64@@ ) ; if ( @@int@@ < Number && * __errno_location ( ) == Number ) { @@int@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@int@@ , Number , @@int@@ , @@int@@ , @@int@@ , @@int@@ ) ; if ( @@int@@ < Number ) return ( unsigned int ) @@int@@ ; have_dupfd_cloexec_2895 = Number ; } else { have_dupfd_cloexec_2895 = Number ; } } if ( @@int@@ >= Number && have_dupfd_cloexec_2895 == Number ) { @@int@@ = fcntl ( @@int@@ , Number ) ; if ( @@int@@ < Number || fcntl ( @@int@@ , Number , @@int@@ | Number ) == Number ) { @@int@@ = * __errno_location ( ) ; close ( @@int@@ ) ; * __errno_location ( ) = @@int@@ ; @@int@@ = Number ; } } return ( unsigned int ) @@int@@ ; }
void * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall head_lines ( __int64 @@int64@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; size_t @@sizet@@ ; __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; int * @@int@@ ; int @@int@@ ; size_t @@sizet@@ ; unsigned __int64 @@unsignedint64@@ ; struct stat @@structstat@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; while ( @@int64@@ ) { @@unsignedint64@@ = safe_read ( @@unsignedint@@ , @@char@@ , Number ) ; @@sizet@@ = Number L ; if ( @@unsignedint64@@ == Number ) { @@int64@@ = quote ( @@int64@@ ) ; @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ , @@int64@@ ) ; return Number L ; } if ( ! @@unsignedint64@@ ) break ; while ( @@sizet@@ < @@unsignedint64@@ ) { @@sizet@@ = @@sizet@@ ++ ; if ( @@char@@ [ @@sizet@@ ] == Number && ! -- @@int64@@ ) { if ( lseek ( @@unsignedint@@ , @@sizet@@ - @@unsignedint64@@ , Number ) < Number ) { @@int@@ = * __errno_location ( ) ; if ( ( unsigned int ) fstat ( @@unsignedint@@ , & @@structstat@@ ) || ( @@structstat@@ . st_mode & Number ) == Number ) { @@int64@@ = quote ( @@int64@@ ) ; @@char@@ = gettext ( String ) ; error ( Number , @@int@@ , @@char@@ , @@int64@@ ) ; } } break ; } } if ( @@sizet@@ > fwrite_unlocked ( @@char@@ , Number , @@sizet@@ , stdout ) ) { @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ ) ; } } return Number L ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
void * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall head ( const char * @@constchar@@ , unsigned int @@unsignedint@@ , size_t @@sizet@@ , char @@char@@ , char @@char@@ ) { __int64 @@int64@@ ; if ( print_headers ) write_header ( @@constchar@@ ) ; if ( @@char@@ ) { if ( @@char@@ ) @@int64@@ = elide_tail_lines_file ( ( __int64 ) @@constchar@@ , @@unsignedint@@ , @@sizet@@ ) ; else @@int64@@ = elide_tail_bytes_file ( ( __int64 ) @@constchar@@ , @@unsignedint@@ , @@sizet@@ ) ; } else if ( @@char@@ ) { @@int64@@ = head_lines ( ( __int64 ) @@constchar@@ , @@unsignedint@@ , @@sizet@@ ) ; } else { @@int64@@ = head_bytes ( ( __int64 ) @@constchar@@ , @@unsignedint@@ , @@sizet@@ ) ; } return @@int64@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return xmalloc ( @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall append_quoted ( char * @@char@@ ) { int @@int@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; __int64 @@int64@@ ; bool @@bool@@ ; @@bool@@ = Number ; while ( Number ) { @@int64@@ = ( unsigned __int8 ) * @@char@@ ; if ( ! ( _BYTE ) @@int64@@ ) return @@int64@@ ; @@int@@ = * @@char@@ ; if ( @@int@@ == Number ) goto LABEL_18 ; if ( @@int@@ > Number ) { if ( @@int@@ == Number || @@int@@ == Number ) { @@bool@@ = ! @@bool@@ ; goto LABEL_23 ; } goto LABEL_22 ; } if ( @@int@@ != Number ) { if ( @@int@@ == Number ) { LABEL_18 : if ( @@bool@@ ) { if ( lsc_obstack . next_free + Number > lsc_obstack . chunk_limit ) _obstack_newchunk ( & lsc_obstack , Number ) ; @@char@@ = lsc_obstack . next_free ; lsc_obstack . next_free = @@char@@ + Number ; * @@char@@ = Number ; } } LABEL_22 : @@bool@@ = Number ; goto LABEL_23 ; } if ( lsc_obstack . next_free + Number > lsc_obstack . chunk_limit ) _obstack_newchunk ( & lsc_obstack , Number ) ; @@char@@ = lsc_obstack . next_free ; lsc_obstack . next_free = @@char@@ + Number ; * @@char@@ = Number ; if ( lsc_obstack . next_free + Number > lsc_obstack . chunk_limit ) _obstack_newchunk ( & lsc_obstack , Number ) ; @@char@@ = lsc_obstack . next_free ; lsc_obstack . next_free = @@char@@ + Number ; * @@char@@ = Number ; if ( lsc_obstack . next_free + Number > lsc_obstack . chunk_limit ) _obstack_newchunk ( & lsc_obstack , Number ) ; @@char@@ = lsc_obstack . next_free ; lsc_obstack . next_free = @@char@@ + Number ; * @@char@@ = Number ; @@bool@@ = Number ; LABEL_23 : if ( lsc_obstack . next_free + Number > lsc_obstack . chunk_limit ) _obstack_newchunk ( & lsc_obstack , Number ) ; @@char@@ = lsc_obstack . next_free ; lsc_obstack . next_free = @@char@@ + Number ; * @@char@@ = * @@char@@ ++ ; } }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@unsignedint64@@ , int @@int@@ ) { __int64 @@int64@@ ; if ( is_mul_ok ( @@int@@ , * @@unsignedint64@@ ) ) { * @@unsignedint64@@ *= @@int@@ ; @@int64@@ = Number L ; } else { * @@unsignedint64@@ = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall full_read ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = Number L ; while ( @@int64@@ ) { @@int64@@ = safe_read ( @@unsignedint@@ , @@int64@@ , @@int64@@ ) ; if ( @@int64@@ == Number ) break ; if ( ! @@int64@@ ) { * __errno_location ( ) = Number ; return @@int64@@ ; } @@int64@@ += @@int64@@ ; @@int64@@ += @@int64@@ ; @@int64@@ -= @@int64@@ ; } return @@int64@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_206028 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
unsigned __int64 process_signals ( ) { int @@int@@ ; sigset_t @@sigsett@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; while ( interrupt_signal || stop_signal_count ) { if ( used_color ) restore_default_color ( ) ; fflush_unlocked ( stdout ) ; sigprocmask ( Number , & caught_signals , & @@sigsett@@ ) ; @@int@@ = interrupt_signal ; if ( stop_signal_count ) { -- stop_signal_count ; raise ( Number ) ; } else { signal ( interrupt_signal , Number L ) ; raise ( @@int@@ ) ; } sigprocmask ( Number , & @@sigsett@@ , Number L ) ; } return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
_QWORD * __fastcall add_ignore_pattern ( __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) xmalloc ( Number L ) ; * @@QWORD@@ = @@int64@@ ; @@QWORD@@ [ Number ] = ignore_patterns ; ignore_patterns = ( __int64 ) @@QWORD@@ ; return @@QWORD@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_20A128 ; @@int648@@ [ Number ] = qword_20A130 ; @@int648@@ [ Number ] = qword_20A138 ; @@int648@@ [ Number ] = qword_20A140 ; @@int648@@ [ Number ] = qword_20A148 ; @@int648@@ [ Number ] = qword_20A150 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_209038 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
_BOOL8 __fastcall is_directory ( __int64 @@int64@@ ) { return * ( _DWORD * ) ( @@int64@@ + Number ) == Number || * ( _DWORD * ) ( @@int64@@ + Number ) == Number ; }
unsigned __int64 __fastcall print_char ( unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ , unsigned __int8 * @@unsignedint8@@ , int @@int@@ , int @@int@@ , int @@int@@ ) { unsigned __int8 * @@unsignedint8@@ ; unsigned __int64 @@unsignedint64@@ ; char @@char@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = @@int@@ ; @@int@@ = @@int@@ ; for ( @@unsignedint64@@ = @@unsignedint64@@ ; ; -- @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ ; if ( @@unsignedint64@@ >= @@unsignedint64@@ ) break ; @@int@@ = ( @@unsignedint64@@ - Number ) * @@int@@ / @@unsignedint64@@ ; @@unsignedint8@@ = @@unsignedint8@@ ++ ; xprintf ( @@int@@ , @@int@@ + @@int@@ - @@int@@ , * @@unsignedint8@@ , @@int@@ + @@int@@ - @@int@@ , @@int@@ , @@int@@ , @@char@@ ) ; @@int@@ = @@int@@ ; } return @@unsignedint64@@ ; }
FILE * __fastcall freopen_safer ( const char * @@constchar@@ , const char * @@constchar@@ , FILE * @@FILE@@ ) { int @@int@@ ; FILE * @@FILE@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; int @@int@@ ; @@char@@ = Number ; @@char@@ = Number ; @@char@@ = Number ; @@int@@ = fileno ( @@FILE@@ ) ; if ( @@int@@ != Number ) { if ( @@int@@ != Number ) { if ( ! @@int@@ ) goto LABEL_10 ; if ( dup2 ( Number , Number ) != Number ) @@char@@ = Number ; } if ( dup2 ( Number , Number ) != Number ) @@char@@ = Number ; } if ( dup2 ( Number , Number ) ) @@char@@ = Number ; LABEL_10 : if ( @@char@@ && ( unsigned __int8 ) protect_fd ( Number ) != Number ) { @@FILE@@ = Number L ; } else if ( @@char@@ && ( unsigned __int8 ) protect_fd ( Number ) != Number ) { @@FILE@@ = Number L ; } else if ( @@char@@ && ( unsigned __int8 ) protect_fd ( Number ) != Number ) { @@FILE@@ = Number L ; } else { @@FILE@@ = freopen ( @@constchar@@ , @@constchar@@ , @@FILE@@ ) ; } @@int@@ = * __errno_location ( ) ; if ( @@char@@ ) close ( Number ) ; if ( @@char@@ ) close ( Number ) ; if ( @@char@@ ) close ( Number ) ; if ( ! @@FILE@@ ) * __errno_location ( ) = @@int@@ ; return @@FILE@@ ; }
__int64 __fastcall umaxtostr ( unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = @@int64@@ + Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = Number ; do { * ( _BYTE * ) -- @@int64@@ = @@unsignedint64@@ % Number + Number ; @@unsignedint64@@ /= Number ; } while ( @@unsignedint64@@ ) ; return @@int64@@ ; }
__int64 __fastcall make_link_name ( const char * @@constchar@@ , const char * @@constchar@@ ) { size_t @@sizet@@ ; char * @@char@@ ; char * @@char@@ ; __int64 @@int64@@ ; if ( ! @@constchar@@ ) return Number L ; if ( * @@constchar@@ == Number ) return xstrdup ( @@constchar@@ ) ; @@char@@ = strrchr ( @@constchar@@ , Number ) ; if ( ! @@char@@ ) return xstrdup ( @@constchar@@ ) ; @@int64@@ = @@char@@ - @@constchar@@ + Number ; @@sizet@@ = strlen ( @@constchar@@ ) ; @@char@@ = ( char * ) xmalloc ( @@sizet@@ + @@int64@@ + Number ) ; strncpy ( @@char@@ , @@constchar@@ , @@int64@@ ) ; strcpy ( & @@char@@ [ @@int64@@ ] , @@constchar@@ ) ; return ( __int64 ) @@char@@ ; }
unsigned __int64 __fastcall print_int ( unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ , _DWORD * @@DWORD@@ , int @@int@@ , int @@int@@ , int @@int@@ ) { _DWORD * @@DWORD@@ ; unsigned __int64 @@unsignedint64@@ ; char @@char@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = @@int@@ ; @@int@@ = @@int@@ ; for ( @@unsignedint64@@ = @@unsignedint64@@ ; ; -- @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ ; if ( @@unsignedint64@@ >= @@unsignedint64@@ ) break ; @@int@@ = ( @@unsignedint64@@ - Number ) * @@int@@ / @@unsignedint64@@ ; @@DWORD@@ = @@DWORD@@ ++ ; xprintf ( @@int@@ , @@int@@ + @@int@@ - @@int@@ , * @@DWORD@@ , @@int@@ + @@int@@ - @@int@@ , @@int@@ , @@int@@ , @@char@@ ) ; @@int@@ = @@int@@ ; } return @@unsignedint64@@ ; }
void * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * @@int64@@ ; void * @@void@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; void * @@void@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == ( __int64 * ) & slotvec0 ; if ( slotvec == ( __int64 * ) & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@void@@ = off_208028 ; * @@int64@@ = ( __int64 ) slotvec0 ; @@int64@@ [ Number ] = ( __int64 ) @@void@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = @@int64@@ [ Number * @@int@@ ] ; @@void@@ = ( void * ) @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@void@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = @@unsignedint64@@ + Number ; if ( @@void@@ != & slot0 ) free ( @@void@@ ) ; @@void@@ = ( void * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = ( __int64 ) @@void@@ ; quotearg_buffer_restyled ( ( __int64 ) @@void@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@void@@ ; }
__int64 __fastcall cmp_name ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ , __int64 ( __fastcall * @ @ VAR_515 @ @ int64 ( fastcall ) ( QWORD , QWORD ) @ @ int ( ) ( constchar , constchar ) ) ( _QWORD , _QWORD ) ) { return @ @ VAR_515 @ @ int64 ( fastcall ) ( QWORD , QWORD ) @ @ int ( ) ( constchar , constchar ) ( * @@QWORD@@ , * @@QWORD@@ ) ; }
unsigned __int64 __fastcall print_long_double ( unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ , long double * @@longdouble@@ , int @@int@@ , int @@int@@ , int @@int@@ ) { long double * @@longdouble@@ ; unsigned __int64 @@unsignedint64@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = @@int@@ ; @@int@@ = @@int@@ ; for ( @@unsignedint64@@ = @@unsignedint64@@ ; ; -- @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ ; if ( @@unsignedint64@@ >= @@unsignedint64@@ ) break ; @@int@@ = ( @@unsignedint64@@ - Number ) * @@int@@ / @@unsignedint64@@ ; @@longdouble@@ = @@longdouble@@ ++ ; xprintf ( @@int@@ , @@int@@ + @@int@@ - @@int@@ , @@int@@ + @@int@@ - @@int@@ , @@int@@ , @@int@@ , @@int@@ , * @@longdouble@@ ) ; @@int@@ = @@int@@ ; } return @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_20A028 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall set_additional_groups ( __int64 @@int64@@ ) { __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; size_t @@sizet@@ ; __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; int * @@int@@ ; unsigned int @@unsignedint@@ ; __int64 @@int64@@ ; __gid_t @@gidt2@@ [ Number ] ; __gid_t * @@gidt@@ ; size_t @@sizet@@ ; char * @@char@@ ; struct group * @@structgroup@@ ; char * @@char@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@gidt@@ = Number L ; @@int64@@ = Number L ; @@sizet@@ = Number L ; @@char@@ = ( char * ) xstrdup ( @@int64@@ ) ; @@unsignedint@@ = Number ; for ( @@char@@ = strtok ( @@char@@ , String ) ; @@char@@ ; @@char@@ = strtok ( Number L , String ) ) { if ( ( unsigned int ) xstrtoul ( @@char@@ , Number L , Number L , @@gidt2@@ , & locale ) || * ( _QWORD * ) @@gidt2@@ > Number ) { @@structgroup@@ = getgrnam ( @@char@@ ) ; if ( @@structgroup@@ ) * ( _QWORD * ) @@gidt2@@ = @@structgroup@@ -> gr_gid ; } else { @@structgroup@@ = getgrgid ( @@gidt2@@ [ Number ] ) ; } if ( @@structgroup@@ ) { if ( @@sizet@@ == @@int64@@ ) @@gidt@@ = ( __gid_t * ) x2nrealloc ( @@gidt@@ , & @@int64@@ , Number L ) ; @@sizet@@ = @@sizet@@ ++ ; @@gidt@@ [ @@sizet@@ ] = @@gidt2@@ [ Number ] ; } else { @@int64@@ = quote ( @@char@@ ) ; @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ , @@int64@@ ) ; @@unsignedint@@ = Number ; } } if ( ! @@unsignedint@@ && ! @@sizet@@ ) { @@int64@@ = quote ( @@int64@@ ) ; @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ , @@int64@@ ) ; @@unsignedint@@ = Number ; } if ( ! @@unsignedint@@ ) { @@unsignedint@@ = setgroups ( @@sizet@@ , @@gidt@@ ) ; if ( @@unsignedint@@ ) { @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ ) ; } } free ( @@char@@ ) ; free ( @@gidt@@ ) ; return @@unsignedint@@ ; }
int __fastcall format_address_label ( unsigned __int64 @@unsignedint64@@ , char @@char@@ ) { format_address_std ( @@unsignedint64@@ , Number ) ; return format_address_paren ( pseudo_offset + @@unsignedint64@@ , @@char@@ ) ; }
_BOOL8 __fastcall visit_dir ( __int64 @@int64@@ , __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; @@QWORD@@ = ( _QWORD * ) xmalloc ( Number L ) ; * @@QWORD@@ = @@int64@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = hash_insert ( active_dir_set , @@QWORD@@ ) ; if ( ! @@int64@@ ) xalloc_die ( ) ; if ( ( _QWORD * ) @@int64@@ != @@QWORD@@ ) free ( @@QWORD@@ ) ; return @@int64@@ != ( _QWORD ) @@QWORD@@ ; }
__int64 __fastcall cmp_extension ( const char * * @@constchar@@ , const char * * @@constchar@@ , __int64 ( __fastcall * @ @ VAR_525 @ @ int64 ( fastcall ) ( constchar , constchar ) @ @ int ( ) ( constchar , constchar ) ) ( const char * , const char * ) ) { const char * @@constchar@@ ; const char * @@constchar@@ ; __int64 @@int64@@ ; unsigned int @@unsignedint@@ ; char * @@char@@ ; char * @@char@@ ; @@char@@ = strrchr ( * @@constchar@@ , Number ) ; @@char@@ = strrchr ( * @@constchar@@ , Number ) ; if ( @@char@@ ) @@constchar@@ = @@char@@ ; else @@constchar@@ = & off_16E97 [ Number ] ; if ( @@char@@ ) @@constchar@@ = @@char@@ ; else @@constchar@@ = & off_16E97 [ Number ] ; @@unsignedint@@ = @ @ VAR_525 @ @ int64 ( fastcall ) ( constchar , constchar ) @ @ int ( ) ( constchar , constchar ) ( @@constchar@@ , @@constchar@@ ) ; if ( @@unsignedint@@ ) @@int64@@ = @@unsignedint@@ ; else @@int64@@ = @ @ VAR_525 @ @ int64 ( fastcall ) ( constchar , constchar ) @ @ int ( ) ( constchar , constchar ) ( * @@constchar@@ , * @@constchar@@ ) ; return @@int64@@ ; }
unsigned __int64 __fastcall print_float ( unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , int @@int@@ , int @@int@@ , int @@int@@ ) { unsigned __int64 @@unsignedint64@@ ; char @@char@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = @@int@@ ; @@int@@ = @@int@@ ; for ( @@unsignedint64@@ = @@unsignedint64@@ ; ; -- @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ ; if ( @@unsignedint64@@ >= @@unsignedint64@@ ) break ; @@int@@ = ( @@unsignedint64@@ - Number ) * @@int@@ / @@unsignedint64@@ ; @@int64@@ += Number L ; xprintf ( @@int@@ , @@int@@ + @@int@@ - @@int@@ , @@int@@ + @@int@@ - @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@char@@ ) ; @@int@@ = @@int@@ ; } return @@unsignedint64@@ ; }
__int64 __fastcall file_failure ( unsigned __int8 @@unsignedint8@@ , const char * @@constchar@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; int * @@int@@ ; @@int64@@ = quotearg_colon ( @@int64@@ ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@constchar@@ , @@int64@@ ) ; return set_exit_status ( @@unsignedint8@@ ) ; }
void * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_208108 ; @@int648@@ [ Number ] = qword_208110 ; @@int648@@ [ Number ] = qword_208118 ; @@int648@@ [ Number ] = qword_208120 ; @@int648@@ [ Number ] = qword_208128 ; @@int648@@ [ Number ] = qword_208130 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
bool __fastcall parse_old_offset ( char * @@char@@ , __int64 @@int64@@ ) { char * @@char@@ ; unsigned int @@unsignedint@@ ; @@char@@ = @@char@@ ; if ( ! * @@char@@ ) return Number ; if ( * @@char@@ == Number ) @@char@@ = @@char@@ + Number ; if ( strchr ( @@char@@ , Number ) ) { @@unsignedint@@ = Number ; } else if ( * @@char@@ == Number && ( @@char@@ [ Number ] == Number || @@char@@ [ Number ] == Number ) ) { @@unsignedint@@ = Number ; } else { @@unsignedint@@ = Number ; } return ( unsigned int ) xstrtoumax ( @@char@@ , Number L , @@unsignedint@@ , @@int64@@ , & off_EF09 ) == Number ; }
__int64 long_time_expected_width ( ) { time_t @@timet@@ ; struct tm * @@structtm@@ ; __int64 @@int64@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( width_8232 < Number ) { @@timet@@ = Number L ; @@structtm@@ = localtime ( & @@timet@@ ) ; if ( @@structtm@@ ) { @@int64@@ = align_nstrftime ( ( __int64 ) @@char@@ , Number L , long_time_format , ( __int64 ) @@structtm@@ , Number , Number ) ; if ( @@int64@@ ) width_8232 = mbsnwidth ( @@char@@ , @@int64@@ , Number L ) ; } if ( width_8232 < Number ) width_8232 = Number ; } return ( unsigned int ) width_8232 ; }
__int64 __fastcall patterns_match ( __int64 @@int64@@ , const char * @@constchar@@ ) { while ( @@int64@@ ) { if ( ! fnmatch ( * ( const char * * ) @@int64@@ , @@constchar@@ , Number ) ) return Number L ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; } return Number L ; }
unsigned __int64 __fastcall format_address_std ( unsigned __int64 @@unsignedint64@@ , char @@char@@ ) { char * @@char@@ ; char * @@char@@ ; _BYTE @@BYTE17@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@BYTE17@@ [ Number ] = Number ; @@char@@ = @@BYTE17@@ ; @@BYTE17@@ [ Number ] = @@char@@ ; @@char@@ = & @@BYTE17@@ [ - address_pad_len ] ; switch ( address_base ) { case Number : do { * -- @@char@@ = @@unsignedint64@@ % Number + Number ; @@unsignedint64@@ /= Number ; } while ( @@unsignedint64@@ ) ; break ; case Number : do { * -- @@char@@ = a0123456789abcd [ @@unsignedint64@@ & Number ] ; @@unsignedint64@@ >>= Number ; } while ( @@unsignedint64@@ ) ; break ; case Number : do { * -- @@char@@ = ( @@unsignedint64@@ & Number ) + Number ; @@unsignedint64@@ >>= Number ; } while ( @@unsignedint64@@ ) ; break ; } while ( @@char@@ < @@char@@ ) * -- @@char@@ = Number ; fputs_unlocked ( @@char@@ , stdout ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall umaxtostr ( unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = @@int64@@ + Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = Number ; do { * ( _BYTE * ) -- @@int64@@ = @@unsignedint64@@ % Number + Number ; @@unsignedint64@@ /= Number ; } while ( @@unsignedint64@@ ) ; return @@int64@@ ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall bad_cast ( __int64 @@int64@@ ) { return @@int64@@ ; }
__int64 __fastcall format_group ( unsigned int @@unsignedint@@ , int @@int@@ , char @@char@@ ) { const char * @@constchar@@ ; if ( @@char@@ != Number ) { @@constchar@@ = String ; } else if ( numeric_ids ) { @@constchar@@ = Number L ; } else { @@constchar@@ = ( const char * ) getgroup ( @@unsignedint@@ ) ; } return format_user_or_group ( @@constchar@@ , @@unsignedint@@ , @@int@@ ) ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
__int64 __fastcall get_link_name ( __int64 @@int64@@ , __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int64@@ ; char * @@char@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = areadlink_with_size ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( ! @@int64@@ ) { @@char@@ = gettext ( String ) ; @@int64@@ = file_failure ( @@unsignedint8@@ , @@char@@ , @@int64@@ ) ; } return @@int64@@ ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@unsignedint64@@ , int @@int@@ ) { __int64 @@int64@@ ; if ( is_mul_ok ( @@int@@ , * @@unsignedint64@@ ) ) { * @@unsignedint64@@ *= @@int@@ ; @@int64@@ = Number L ; } else { * @@unsignedint64@@ = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall get_stat_atime ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 __fastcall get_stat_mtime ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
const char * __fastcall format_inode ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ ) { const char * @@constchar@@ ; if ( @@unsignedint64@@ <= Number ) __assert_fail ( String , String , Number , String ) ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) && * ( _QWORD * ) ( @@int64@@ + Number ) ) @@constchar@@ = ( const char * ) umaxtostr ( * ( _QWORD * ) ( @@int64@@ + Number ) , @@int64@@ ) ; else @@constchar@@ = String ; return @@constchar@@ ; }
__int64 __fastcall bkm_scale_by_power ( unsigned __int64 * @@unsignedint64@@ , int @@int@@ , int @@int@@ ) { unsigned int @@unsignedint@@ ; for ( @@unsignedint@@ = Number ; @@int@@ -- ; @@unsignedint@@ |= bkm_scale ( @@unsignedint64@@ , @@int@@ ) ) { ; } return @@unsignedint@@ ; }
__int64 __fastcall cmp_mtime ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ , __int64 ( __fastcall * @ @ VAR_500 @ @ int64 ( fastcall ) ( QWORD , QWORD ) @ @ int ( ) ( constchar , constchar ) ) ( _QWORD , _QWORD ) ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = get_stat_mtime ( ( __int64 ) ( @@QWORD@@ + Number ) ) ; @@int64@@ = @@int64@@ ; @@int64@@ = get_stat_mtime ( ( __int64 ) ( @@QWORD@@ + Number ) ) ; @@unsignedint@@ = timespec_cmp ( @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( @@unsignedint@@ ) @@int64@@ = @@unsignedint@@ ; else @@int64@@ = @ @ VAR_500 @ @ int64 ( fastcall ) ( QWORD , QWORD ) @ @ int ( ) ( constchar , constchar ) ( * @@QWORD@@ , * @@QWORD@@ ) ; return @@int64@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
unsigned __int64 __fastcall dev_ino_hash ( _QWORD * @@QWORD@@ , unsigned __int64 @@unsignedint64@@ ) { return * @@QWORD@@ % @@unsignedint64@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
__int64 __fastcall length_of_file_name_and_frills ( __int64 @@int64@@ ) { const char * @@constchar@@ ; __int64 @@int64@@ ; const char * @@constchar@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; char @@char@@ ; size_t @@sizet@@ ; __int64 @@int64@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = Number L ; if ( print_inode ) { if ( format == Number ) { @@constchar@@ = ( const char * ) umaxtostr ( * ( _QWORD * ) ( @@int64@@ + Number ) , @@char@@ ) ; @@int64@@ = strlen ( @@constchar@@ ) + Number ; } else { @@int64@@ = inode_number_width + Number L ; } @@int64@@ += @@int64@@ ; } if ( print_block_size ) { if ( format == Number ) { if ( * ( _BYTE * ) ( @@int64@@ + Number ) != Number ) @@constchar@@ = String ; else @@constchar@@ = ( const char * ) human_readable ( * ( _QWORD * ) ( @@int64@@ + Number ) , @@char@@ , ( unsigned int ) human_output_opts , Number L , output_block_size ) ; @@int64@@ = strlen ( @@constchar@@ ) + Number ; } else { @@int64@@ = block_size_width + Number L ; } @@int64@@ += @@int64@@ ; } if ( print_scontext ) { if ( format == Number ) @@int64@@ = strlen ( * ( const char * * ) ( @@int64@@ + Number ) ) + Number ; else @@int64@@ = scontext_width + Number L ; @@int64@@ += @@int64@@ ; } quote_name ( Number L , * ( _QWORD * ) @@int64@@ , filename_quoting_options , & @@sizet@@ ) ; @@int64@@ += @@sizet@@ ; if ( indicator_style ) { @@char@@ = get_type_indicator ( * ( _BYTE * ) ( @@int64@@ + Number ) , * ( _DWORD * ) ( @@int64@@ + Number ) , * ( _DWORD * ) ( @@int64@@ + Number ) ) ; @@int64@@ += @@char@@ != Number ; } return @@int64@@ ; }
__int64 __fastcall format_user_or_group ( const char * @@constchar@@ , __int64 @@int64@@ , int @@int@@ ) { int @@int@@ ; __int64 @@int64@@ ; int @@int@@ ; int @@int@@ ; size_t @@sizet@@ ; if ( @@constchar@@ ) { @@int@@ = @@int@@ - gnu_mbswidth ( @@constchar@@ , Number L ) ; @@int@@ = Number ; if ( @@int@@ >= Number ) @@int@@ = @@int@@ ; @@int@@ = @@int@@ ; fputs_unlocked ( @@constchar@@ , stdout ) ; @@sizet@@ = strlen ( @@constchar@@ ) + @@int@@ ; do putchar_unlocked ( Number ) ; while ( @@int@@ -- ) ; } else { printf ( String , @@int@@ , @@int64@@ ) ; @@sizet@@ = @@int@@ ; } @@int64@@ = dired_pos + @@sizet@@ + Number ; dired_pos = @@int64@@ ; return @@int64@@ ; }
_BOOL8 __fastcall dev_ino_compare ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ ) { return * @@QWORD@@ == * @@QWORD@@ && @@QWORD@@ [ Number ] == @@QWORD@@ [ Number ] ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_212038 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
size_t __fastcall format_group_width ( unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; if ( numeric_ids ) @@int64@@ = Number L ; else @@int64@@ = getgroup ( @@unsignedint@@ ) ; return format_user_or_group_width ( @@int64@@ , @@unsignedint@@ ) ; }
_BOOL8 __fastcall is_colored ( unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; char * @@char@@ ; @@int64@@ = * ( ( _QWORD * ) & color_indicator + Number * @@unsignedint@@ ) ; @@char@@ = ( char * ) * ( & off_21F088 + Number * @@unsignedint@@ ) ; return @@int64@@ && ( @@int64@@ != Number || * @@char@@ != Number ) && ( @@int64@@ != Number || strncmp ( @@char@@ , off_16E97 , Number ) ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
unsigned __int64 init_column_info ( ) { unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = max_idx ; if ( cwd_n_used <= ( unsigned __int64 ) max_idx ) @@unsignedint64@@ = cwd_n_used ; @@unsignedint64@@ = @@unsignedint64@@ ; if ( @@unsignedint64@@ > column_info_alloc_8572 ) { if ( @@unsignedint64@@ >= ( unsigned __int64 ) max_idx >> Number ) { column_info = xnrealloc ( column_info , max_idx , Number L ) ; @@unsignedint64@@ = max_idx ; } else { column_info = xnrealloc ( column_info , @@unsignedint64@@ , Number L ) ; @@unsignedint64@@ = Number * @@unsignedint64@@ ; } @@unsignedint64@@ = ( @@unsignedint64@@ - column_info_alloc_8572 ) * ( column_info_alloc_8572 + @@unsignedint64@@ + Number ) ; if ( column_info_alloc_8572 + @@unsignedint64@@ + Number < @@unsignedint64@@ || column_info_alloc_8572 + @@unsignedint64@@ + Number != @@unsignedint64@@ / ( @@unsignedint64@@ - column_info_alloc_8572 ) ) { xalloc_die ( ) ; } @@int64@@ = xnmalloc ( @@unsignedint64@@ >> Number , Number L ) ; for ( @@unsignedint64@@ = column_info_alloc_8572 ; @@unsignedint64@@ < @@unsignedint64@@ ; ++ @@unsignedint64@@ ) { * ( _QWORD * ) ( column_info + Number * @@unsignedint64@@ + Number ) = @@int64@@ ; @@int64@@ += Number * ( @@unsignedint64@@ + Number ) ; } column_info_alloc_8572 = @@unsignedint64@@ ; } for ( @@unsignedint64@@ = Number L ; ; ++ @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ ; if ( @@unsignedint64@@ >= @@unsignedint64@@ ) break ; * ( _BYTE * ) ( column_info + Number * @@unsignedint64@@ ) = Number ; * ( _QWORD * ) ( column_info + Number * @@unsignedint64@@ + Number ) = Number * ( @@unsignedint64@@ + Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= @@unsignedint64@@ ; ++ @@unsignedint64@@ ) { * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( column_info + Number * @@unsignedint64@@ + Number ) ) = Number L ; } } return @@unsignedint64@@ ; }
void __fastcall freebuffer ( __int64 @@int64@@ ) { free ( * ( void * * ) ( @@int64@@ + Number ) ) ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ ) { return xmalloc ( @@int64@@ ) ; }
__int64 __fastcall queue_directory ( __int64 @@int64@@ , __int64 @@int64@@ , char @@char@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = xmalloc ( Number L ) ; if ( @@int64@@ ) @@int64@@ = xstrdup ( @@int64@@ ) ; else @@int64@@ = Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; if ( @@int64@@ ) @@int64@@ = xstrdup ( @@int64@@ ) ; else @@int64@@ = Number L ; * ( _QWORD * ) @@int64@@ = @@int64@@ ; * ( _BYTE * ) ( @@int64@@ + Number ) = @@char@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = pending_dirs ; @@int64@@ = @@int64@@ ; pending_dirs = @@int64@@ ; return @@int64@@ ; }
__int64 __fastcall get_type_indicator ( char @@char@@ , __int16 @@int16@@ , int @@int@@ ) { bool @@bool@@ ; bool @@bool@@ ; bool @@bool@@ ; bool @@bool@@ ; bool @@bool@@ ; bool @@bool@@ ; unsigned __int8 @@unsignedint8@@ ; if ( @@char@@ ) @@bool@@ = ( @@int16@@ & Number ) == Number ; else @@bool@@ = @@int@@ == Number ; if ( @@bool@@ ) { if ( @@char@@ && indicator_style == Number && ( @@int16@@ & Number ) != Number ) @@unsignedint8@@ = Number ; else @@unsignedint8@@ = Number ; } else { if ( @@char@@ ) { @@bool@@ = ( @@int16@@ & Number ) == Number ; } else { @@bool@@ = @@int@@ == Number || @@int@@ == Number ; @@bool@@ = @@bool@@ ; } if ( @@bool@@ ) { @@unsignedint8@@ = Number ; } else if ( indicator_style == Number ) { @@unsignedint8@@ = Number ; } else { if ( @@char@@ ) @@bool@@ = ( @@int16@@ & Number ) == Number ; else @@bool@@ = @@int@@ == Number ; if ( @@bool@@ ) { @@unsignedint8@@ = Number ; } else { if ( @@char@@ ) @@bool@@ = ( @@int16@@ & Number ) == Number ; else @@bool@@ = @@int@@ == Number ; if ( @@bool@@ ) { @@unsignedint8@@ = Number ; } else { if ( @@char@@ ) @@bool@@ = ( @@int16@@ & Number ) == Number ; else @@bool@@ = @@int@@ == Number ; if ( @@bool@@ ) @@unsignedint8@@ = Number ; else @@unsignedint8@@ = Number ; } } } } return @@unsignedint8@@ ; }
__int64 __fastcall wc_truncate ( wchar_t * @@wchart@@ , unsigned __int64 @@unsignedint64@@ ) { int @@int@@ ; __int64 @@int64@@ ; @@int64@@ = Number L ; while ( * @@wchart@@ ) { @@int@@ = wcwidth ( * @@wchart@@ ) ; if ( @@int@@ == Number ) { * @@wchart@@ = Number ; @@int@@ = Number ; } if ( @@unsignedint64@@ < @@int@@ + @@int64@@ ) break ; @@int64@@ += @@int@@ ; ++ @@wchart@@ ; } * @@wchart@@ = Number ; return @@int64@@ ; }
__int64 __fastcall xsum ( unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; if ( @@unsignedint64@@ + @@int64@@ < @@unsignedint64@@ ) @@int64@@ = Number ; else @@int64@@ = @@unsignedint64@@ + @@int64@@ ; return @@int64@@ ; }
int print_with_commas ( ) { char @@char@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; @@unsignedint64@@ = Number L ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < cwd_n_used ; ++ @@unsignedint64@@ ) { @@int64@@ = * ( ( _QWORD * ) sorted_file + @@unsignedint64@@ ) ; @@int64@@ = length_of_file_name_and_frills ( @@int64@@ ) ; if ( @@unsignedint64@@ ) { if ( @@unsignedint64@@ + @@int64@@ + Number >= line_length ) { @@unsignedint64@@ = Number L ; @@char@@ = Number ; } else { @@unsignedint64@@ += Number L ; @@char@@ = Number ; } putchar_unlocked ( Number ) ; putchar_unlocked ( @@char@@ ) ; } print_file_name_and_frills ( @@int64@@ , @@unsignedint64@@ ) ; @@unsignedint64@@ += @@int64@@ ; } return putchar_unlocked ( Number ) ; }
__int64 __fastcall memcmp2 ( const void * @@constvoid@@ , size_t @@sizet@@ , const void * @@constvoid@@ , size_t @@sizet@@ ) { size_t @@sizet@@ ; size_t @@sizet@@ ; unsigned int @@unsignedint@@ ; @@sizet@@ = @@sizet@@ ; @@sizet@@ = @@sizet@@ ; if ( @@sizet@@ <= @@sizet@@ ) @@sizet@@ = @@sizet@@ ; @@unsignedint@@ = memcmp ( @@constvoid@@ , @@constvoid@@ , @@sizet@@ ) ; if ( ! @@unsignedint@@ ) { if ( @@sizet@@ >= @@sizet@@ ) { if ( @@sizet@@ > @@sizet@@ ) @@unsignedint@@ = Number ; } else { @@unsignedint@@ = Number ; } } return @@unsignedint@@ ; }
__int64 __fastcall extract_dirs_from_files ( __int64 @@int64@@ , char @@char@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 * @@int64@@ ; void * @@void@@ ; if ( @@int64@@ && active_dir_set ) queue_directory ( Number L , @@int64@@ , Number ) ; @@int64@@ = cwd_n_used ; while ( @@int64@@ -- ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) sorted_file + @@int64@@ ) ; if ( is_directory ( ( __int64 ) @@int64@@ ) && ( ! @@int64@@ || ! basename_is_dot_or_dotdot ( * @@int64@@ ) ) ) { if ( @@int64@@ && * ( _BYTE * ) * @@int64@@ != Number ) { @@void@@ = ( void * ) file_name_concat ( @@int64@@ , * @@int64@@ , Number L ) ; queue_directory ( ( __int64 ) @@void@@ , @@int64@@ [ Number ] , @@char@@ ) ; free ( @@void@@ ) ; } else { queue_directory ( * @@int64@@ , @@int64@@ [ Number ] , @@char@@ ) ; } if ( * ( ( _DWORD * ) @@int64@@ + Number ) == Number ) free ( ( void * ) * @@int64@@ ) ; } } @@unsignedint64@@ = Number L ; @@int64@@ = Number L ; while ( @@unsignedint64@@ < cwd_n_used ) { @@int64@@ = * ( ( _QWORD * ) sorted_file + @@unsignedint64@@ ) ; * ( ( _QWORD * ) sorted_file + @@int64@@ ) = @@int64@@ ; @@int64@@ += * ( _DWORD * ) ( @@int64@@ + Number ) != Number ; ++ @@unsignedint64@@ ; } @@int64@@ = @@int64@@ ; cwd_n_used = @@int64@@ ; return @@int64@@ ; }
__int64 __fastcall gnu_mbswidth ( const char * @@constchar@@ , unsigned int @@unsignedint@@ ) { size_t @@sizet@@ ; @@sizet@@ = strlen ( @@constchar@@ ) ; return mbsnwidth ( @@constchar@@ , @@sizet@@ , @@unsignedint@@ ) ; }
unsigned __int64 __fastcall xmax ( unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint64@@ ; if ( @@unsignedint64@@ >= @@unsignedint64@@ ) @@unsignedint64@@ = @@unsignedint64@@ ; return @@unsignedint64@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
_BYTE * __fastcall match_suffix ( _BYTE * * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@BYTE@@ = Number L ; @@char@@ = Number ; while ( * * @@BYTE@@ ) { if ( @@char@@ ) { @@char@@ = Number ; if ( ( unsigned __int8 ) c_isalpha ( ( unsigned int ) ( char ) * * @@BYTE@@ ) != Number && * * @@BYTE@@ != Number ) { @@BYTE@@ = Number L ; } } else if ( * * @@BYTE@@ == Number ) { @@char@@ = Number ; if ( ! @@BYTE@@ ) @@BYTE@@ = * @@BYTE@@ ; } else if ( ( unsigned __int8 ) c_isalnum ( ( unsigned int ) ( char ) * * @@BYTE@@ ) != Number && * * @@BYTE@@ != Number ) { @@BYTE@@ = Number L ; } ++ * @@BYTE@@ ; } return @@BYTE@@ ; }
__int64 __fastcall align_nstrftime ( __int64 @@int64@@ , __int64 @@int64@@ , const char * @@constchar@@ , __int64 @@int64@@ , unsigned int @@unsignedint@@ , unsigned int @@unsignedint@@ ) { char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@char@@ = ( char * ) @@constchar@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@char@@ = ( char * ) @@constchar@@ ; if ( required_mon_width ) { @@char@@ = strstr ( @@constchar@@ , needle ) ; if ( @@char@@ ) { if ( strlen ( @@char@@ ) <= Number ) { @@char@@ = @@char@@ ; @@char@@ = ( char * ) mempcpy ( @@char@@ , @@char@@ , @@char@@ - @@char@@ ) ; @@char@@ = stpcpy ( @@char@@ , & abmon [ Number * * ( int * ) ( @@int64@@ + Number ) ] ) ; strcpy ( @@char@@ , @@char@@ + Number ) ; } } } return nstrftime ( @@int64@@ , @@int64@@ , @@char@@ , @@int64@@ , @@unsignedint@@ , @@unsignedint@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
_BOOL8 __fastcall rpl_isnanl ( __int64 a1 , __int64 a2 , __int64 a3 , __int64 a4 , __int64 a5 , __int64 a6 , __int128 @@int128@@ ) { if ( ( WORD4 ( @@int128@@ ) & Number ) == Number ) return DWORD1 ( @@int128@@ ) >> Number ; if ( ( WORD4 ( @@int128@@ ) & Number ) == Number ) return ( DWORD1 ( @@int128@@ ) ^ Number | ( unsigned int ) @@int128@@ ) != Number ; return ( DWORD1 ( @@int128@@ ) & Number ) == Number ; }
__int64 __fastcall hard_locale ( int @@int@@ ) { unsigned __int8 @@unsignedint8@@ ; const char * @@constchar@@ ; @@unsignedint8@@ = Number ; @@constchar@@ = setlocale ( @@int@@ , Number L ) ; if ( @@constchar@@ && ( ! strcmp ( @@constchar@@ , String ) || ! strcmp ( @@constchar@@ , String ) ) ) { @@unsignedint8@@ = Number ; } return @@unsignedint8@@ ; }
__int64 __fastcall filevercmp ( const char * @@constchar@@ , const char * @@constchar@@ ) { __int64 @@int64@@ ; _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned int @@unsignedint@@ ; unsigned int @@unsignedint@@ ; _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; size_t @@sizet@@ ; _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; unsigned __int64 @@unsignedint64@@ ; @@int64@@ = ( __int64 ) @@constchar@@ ; @@int64@@ = ( __int64 ) @@constchar@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@unsignedint@@ = strcmp ( @@constchar@@ , @@constchar@@ ) ; if ( ! @@unsignedint@@ ) return Number L ; if ( ! * @@constchar@@ ) return Number ; if ( ! * @@constchar@@ ) return Number L ; if ( ! strcmp ( String , @@constchar@@ ) ) return Number ; if ( ! strcmp ( String , @@constchar@@ ) ) return Number L ; if ( ! strcmp ( String , @@constchar@@ ) ) return Number ; if ( ! strcmp ( String , @@constchar@@ ) ) return Number L ; if ( * @@constchar@@ == Number && * @@constchar@@ != Number ) return Number ; if ( * @@constchar@@ != Number && * @@constchar@@ == Number ) return Number L ; if ( * @@constchar@@ == Number && * @@constchar@@ == Number ) { @@int64@@ = ( __int64 ) ( @@constchar@@ + Number ) ; @@int64@@ = ( __int64 ) ( @@constchar@@ + Number ) ; } @@BYTE@@ = ( _BYTE * ) @@int64@@ ; @@BYTE@@ = ( _BYTE * ) @@int64@@ ; @@BYTE@@ = match_suffix ( & @@BYTE@@ ) ; @@BYTE@@ = match_suffix ( & @@BYTE@@ ) ; if ( @@BYTE@@ ) @@BYTE@@ = @@BYTE@@ ; else @@BYTE@@ = @@BYTE@@ ; @@sizet@@ = ( size_t ) & @@BYTE@@ [ - @@int64@@ ] ; if ( @@BYTE@@ ) @@BYTE@@ = @@BYTE@@ ; else @@BYTE@@ = @@BYTE@@ ; @@BYTE@@ = & @@BYTE@@ [ - @@int64@@ ] ; if ( ( @@BYTE@@ || @@BYTE@@ ) && ( _BYTE * ) @@sizet@@ == @@BYTE@@ && ! strncmp ( ( const char * ) @@int64@@ , ( const char * ) @@int64@@ , @@sizet@@ ) ) { @@sizet@@ = ( size_t ) & @@BYTE@@ [ - @@int64@@ ] ; @@BYTE@@ = & @@BYTE@@ [ - @@int64@@ ] ; } @@unsignedint@@ = verrevcmp ( @@int64@@ , @@sizet@@ , @@int64@@ , ( unsigned __int64 ) @@BYTE@@ ) ; if ( @@unsignedint@@ ) @@int64@@ = @@unsignedint@@ ; else @@int64@@ = @@unsignedint@@ ; return @@int64@@ ; }
size_t __fastcall format_user_width ( unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; if ( numeric_ids ) @@int64@@ = Number L ; else @@int64@@ = getuser ( @@unsignedint@@ ) ; return format_user_or_group_width ( @@int64@@ , @@unsignedint@@ ) ; }
_BYTE * __fastcall filemodestring ( __int64 @@int64@@ , _BYTE * @@BYTE@@ ) { return strmode ( * ( _DWORD * ) ( @@int64@@ + Number ) , @@BYTE@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 __fastcall _xargmatch_internal ( __int64 @@int64@@ , const char * @@constchar@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ , void ( * @ @ VAR_1227 @ @ void ( ) ( void ) @ @ argmatchexitfn ) ( void ) ) { __int64 @@int64@@ ; @@int64@@ = argmatch ( @@constchar@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; if ( @@int64@@ >= Number ) return @@int64@@ ; argmatch_invalid ( @@int64@@ , ( __int64 ) @@constchar@@ , @@int64@@ ) ; argmatch_valid ( @@int64@@ , @@int64@@ , @@sizet@@ ) ; @ @ VAR_1227 @ @ void ( ) ( void ) @ @ argmatchexitfn ( ) ; return Number ; }
__int64 __fastcall file_name_concat ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = mfile_name_concat ( @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( ! @@int64@@ ) xalloc_die ( ) ; return @@int64@@ ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
__int64 __fastcall hard_locale ( int @@int@@ ) { unsigned __int8 @@unsignedint8@@ ; const char * @@constchar@@ ; @@unsignedint8@@ = Number ; @@constchar@@ = setlocale ( @@int@@ , Number L ) ; if ( @@constchar@@ && ( ! strcmp ( @@constchar@@ , String ) || ! strcmp ( @@constchar@@ , String ) ) ) { @@unsignedint8@@ = Number ; } return @@unsignedint8@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_208028 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
size_t __fastcall print_file_name_and_frills ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { const char * @@constchar@@ ; int @@int@@ ; const char * @@constchar@@ ; int @@int@@ ; int @@int@@ ; size_t @@sizet@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( print_inode ) { @@constchar@@ = format_inode ( ( __int64 ) @@char@@ , Number , @@int64@@ ) ; if ( format == Number ) @@int@@ = Number ; else @@int@@ = inode_number_width ; printf ( String , @@int@@ , @@constchar@@ ) ; } if ( print_block_size ) { if ( * ( _BYTE * ) ( @@int64@@ + Number ) != Number ) @@constchar@@ = String ; else @@constchar@@ = ( const char * ) human_readable ( * ( _QWORD * ) ( @@int64@@ + Number ) , @@char@@ , ( unsigned int ) human_output_opts , Number L , output_block_size ) ; if ( format == Number ) @@int@@ = Number ; else @@int@@ = block_size_width ; printf ( String , @@int@@ , @@constchar@@ ) ; } if ( print_scontext ) { if ( format == Number ) @@int@@ = Number ; else @@int@@ = scontext_width ; printf ( String , @@int@@ , * ( const char * * ) ( @@int64@@ + Number ) ) ; } @@sizet@@ = print_name_with_quoting ( ( __int64 * ) @@int64@@ , Number , Number L , @@unsignedint64@@ ) ; if ( indicator_style ) @@sizet@@ += ( unsigned __int8 ) print_type_indicator ( * ( unsigned __int8 * ) ( @@int64@@ + Number ) , * ( unsigned int * ) ( @@int64@@ + Number ) , * ( unsigned int * ) ( @@int64@@ + Number ) ) ; return @@sizet@@ ; }
__int64 __fastcall xmemcoll ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { char * @@char@@ ; char * @@char@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; char * @@char@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; @@unsignedint@@ = memcoll ( @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ ) ; @@int@@ = * __errno_location ( ) ; if ( @@int@@ ) { @@char@@ = gettext ( String ) ; error ( Number , @@int@@ , @@char@@ ) ; @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ ) ; @@int64@@ = quotearg_n_style_mem ( Number L , Number L , @@int64@@ , @@int64@@ ) ; @@int64@@ = quotearg_n_style_mem ( Number L , Number L , @@int64@@ , @@int64@@ ) ; @@char@@ = gettext ( String ) ; error ( exit_failure , Number , @@char@@ , @@int64@@ , @@int64@@ ) ; } return @@unsignedint@@ ; }
_BYTE * __fastcall strmode ( __int16 @@int16@@ , _BYTE * @@BYTE@@ ) { char @@char@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; _BYTE * @@BYTE@@ ; * @@BYTE@@ = ftypelet ( @@int16@@ ) ; if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) { if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; } else if ( ( @@int16@@ & Number ) != Number ) { @@char@@ = Number ; } else { @@char@@ = Number ; } @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) { if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; } else if ( ( @@int16@@ & Number ) != Number ) { @@char@@ = Number ; } else { @@char@@ = Number ; } @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) { if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; } else if ( ( @@int16@@ & Number ) != Number ) { @@char@@ = Number ; } else { @@char@@ = Number ; } @@BYTE@@ [ Number ] = @@char@@ ; @@BYTE@@ [ Number ] = Number ; @@BYTE@@ = @@BYTE@@ + Number ; @@BYTE@@ [ Number ] = Number ; return @@BYTE@@ ; }
int __fastcall hash_print_statistics ( __int64 @@int64@@ , FILE * @@FILE@@ ) { double @@double@@ ; double @@double@@ ; double @@double@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int64@@ = hash_get_n_entries ( @@int64@@ ) ; @@int64@@ = hash_get_n_buckets ( @@int64@@ ) ; @@int64@@ = hash_get_n_buckets_used ( @@int64@@ ) ; @@unsignedint64@@ = hash_get_max_bucket_length ( @@int64@@ ) ; fprintf ( @@FILE@@ , String , @@int64@@ ) ; fprintf ( @@FILE@@ , String , @@int64@@ ) ; if ( @@int64@@ < Number ) @@double@@ = ( double ) ( int ) ( @@int64@@ & Number | ( ( unsigned __int64 ) @@int64@@ >> Number ) ) + ( double ) ( int ) ( @@int64@@ & Number | ( ( unsigned __int64 ) @@int64@@ >> Number ) ) ; else @@double@@ = ( double ) ( int ) @@int64@@ ; @@double@@ = Number * @@double@@ ; if ( @@int64@@ < Number ) @@double@@ = ( double ) ( int ) ( @@int64@@ & Number | ( ( unsigned __int64 ) @@int64@@ >> Number ) ) + ( double ) ( int ) ( @@int64@@ & Number | ( ( unsigned __int64 ) @@int64@@ >> Number ) ) ; else @@double@@ = ( double ) ( int ) @@int64@@ ; fprintf ( @@FILE@@ , String , @@int64@@ , @@double@@ / @@double@@ ) ; return fprintf ( @@FILE@@ , String , @@unsignedint64@@ ) ; }
unsigned __int8 * __fastcall translate_buffer ( unsigned __int8 * @@unsignedint8@@ , __int64 @@int64@@ ) { unsigned __int8 * @@unsignedint8@@ ; unsigned __int8 @@unsignedint8@@ ; unsigned __int8 * @@unsignedint8@@ ; @@unsignedint8@@ = @@unsignedint8@@ ; @@unsignedint8@@ = @@unsignedint8@@ ; while ( @@int64@@ ) { @@unsignedint8@@ = trans_table [ ( unsigned __int8 ) to_uchar ( * @@unsignedint8@@ ) ] ; @@unsignedint8@@ = @@unsignedint8@@ ; * @@unsignedint8@@ = @@unsignedint8@@ ; -- @@int64@@ ; ++ @@unsignedint8@@ ; } return @@unsignedint8@@ ; }
unsigned __int64 __fastcall calculate_columns ( char @@char@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = max_idx ; if ( cwd_n_used <= ( unsigned __int64 ) max_idx ) @@int64@@ = cwd_n_used ; @@unsignedint64@@ = @@int64@@ ; init_column_info ( ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < cwd_n_used ; ++ @@unsignedint64@@ ) { @@int64@@ = length_of_file_name_and_frills ( * ( ( _QWORD * ) sorted_file + @@unsignedint64@@ ) ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@unsignedint64@@ ; ++ @@unsignedint64@@ ) { if ( * ( _BYTE * ) ( column_info + Number * @@unsignedint64@@ ) ) { @@unsignedint64@@ = @@char@@ ? @@unsignedint64@@ / ( ( cwd_n_used + @@unsignedint64@@ ) / ( @@unsignedint64@@ + Number ) ) : @@unsignedint64@@ % ( @@unsignedint64@@ + Number ) ; @@int64@@ = @@unsignedint64@@ == @@unsignedint64@@ ? Number L : Number L ; @@int64@@ = @@int64@@ + @@int64@@ ; if ( ( unsigned __int64 ) ( @@int64@@ + @@int64@@ ) > * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( column_info + Number * @@unsignedint64@@ + Number ) ) ) { * ( _QWORD * ) ( column_info + Number * @@unsignedint64@@ + Number ) += @@int64@@ - * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( column_info + Number * @@unsignedint64@@ + Number ) ) ; * ( _QWORD * ) ( * ( _QWORD * ) ( column_info + Number * @@unsignedint64@@ + Number ) + Number * @@unsignedint64@@ ) = @@int64@@ ; * ( _BYTE * ) ( column_info + Number * @@unsignedint64@@ ) = * ( _QWORD * ) ( column_info + Number * @@unsignedint64@@ + Number ) < ( unsigned __int64 ) line_length ; } } } } for ( @@unsignedint64@@ = @@unsignedint64@@ ; @@unsignedint64@@ > Number && ! * ( _BYTE * ) ( column_info + Number * @@unsignedint64@@ - Number ) ; -- @@unsignedint64@@ ) { ; } return @@unsignedint64@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
void * __fastcall allocate_entry ( __int64 @@int64@@ ) { __int64 @@int64@@ ; if ( ! * ( _QWORD * ) ( @@int64@@ + Number ) ) return malloc ( Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; return ( void * ) @@int64@@ ; }
__int64 __fastcall advance_input_offset ( unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; input_offset += @@unsignedint64@@ ; @@int64@@ = input_offset ; if ( @@unsignedint64@@ > input_offset ) input_offset_overflow = Number ; return @@int64@@ ; }
bool __fastcall is_prime ( unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = Number L ; @@unsignedint64@@ = Number L ; while ( @@unsignedint64@@ < @@unsignedint64@@ && @@unsignedint64@@ % @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@unsignedint64@@ += Number * @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint64@@ + Number ; } return @@unsignedint64@@ % @@unsignedint64@@ != Number ; }
_BYTE * __fastcall mbs_align_pad ( _BYTE * @@BYTE@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ ) { _BYTE * @@BYTE@@ ; __int64 @@int64@@ ; while ( Number ) { @@int64@@ = @@int64@@ -- ; if ( ! @@int64@@ || ( unsigned __int64 ) @@BYTE@@ >= @@unsignedint64@@ ) break ; @@BYTE@@ = @@BYTE@@ ++ ; * @@BYTE@@ = Number ; } * @@BYTE@@ = Number ; return @@BYTE@@ ; }
__int64 __fastcall free_entry ( __int64 @@int64@@ , _QWORD * @@QWORD@@ ) { __int64 @@int64@@ ; * @@QWORD@@ = Number L ; @@QWORD@@ [ Number ] = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@QWORD@@ ; return @@int64@@ ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) { ; } return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
void __fastcall argmatch_invalid ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { char * @@char@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; char * @@char@@ ; if ( @@int64@@ == Number ) @@char@@ = gettext ( String ) ; else @@char@@ = gettext ( String ) ; @@char@@ = @@char@@ ; @@int64@@ = quote_n ( Number L , @@int64@@ ) ; @@int64@@ = quotearg_n_style ( Number L , Number L , @@int64@@ ) ; error ( Number , Number , @@char@@ , @@int64@@ , @@int64@@ ) ; }
size_t * __fastcall hash_initialize ( __int64 @@int64@@ , void * @@void@@ , unsigned __int64 ( __fastcall * @ @ VAR_1363 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ) ( __int64 a1 , unsigned __int64 a2 ) , bool ( __fastcall * @ @ VAR_1365 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ) ( __int64 a1 , __int64 a2 ) , size_t @@sizet@@ ) { size_t * @@sizet@@ ; bool ( __fastcall * @ @ VAR_1364 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ) ( __int64 , __int64 ) ; unsigned __int64 ( __fastcall * @ @ VAR_1362 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ) ( __int64 , unsigned __int64 ) ; void * @@void@@ ; size_t * @@sizet@@ ; @@void@@ = @@void@@ ; @ @ VAR_1362 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher = @ @ VAR_1363 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ; @ @ VAR_1364 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator = @ @ VAR_1365 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ; if ( ! @ @ VAR_1363 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ) @ @ VAR_1362 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher = raw_hasher ; if ( ! @ @ VAR_1365 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ) @ @ VAR_1364 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator = raw_comparator ; @@sizet@@ = ( size_t * ) malloc ( Number ) ; if ( ! @@sizet@@ ) return Number L ; if ( ! @@void@@ ) @@void@@ = & default_tuning ; @@sizet@@ [ Number ] = ( size_t ) @@void@@ ; if ( ( unsigned __int8 ) check_tuning ( ( __int64 ) @@sizet@@ ) == Number && ( @@sizet@@ [ Number ] = compute_bucket_size ( @@int64@@ , ( __int64 ) @@void@@ ) ) != Number && ( * @@sizet@@ = ( size_t ) calloc ( @@sizet@@ [ Number ] , Number ) ) != Number ) { @@sizet@@ [ Number ] = Number * @@sizet@@ [ Number ] + * @@sizet@@ ; @@sizet@@ [ Number ] = Number L ; @@sizet@@ [ Number ] = Number L ; @@sizet@@ [ Number ] = ( size_t ) @ @ VAR_1362 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ; @@sizet@@ [ Number ] = ( size_t ) @ @ VAR_1364 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ; @@sizet@@ [ Number ] = @@sizet@@ ; @@sizet@@ [ Number ] = Number L ; @@sizet@@ = @@sizet@@ ; } else { free ( @@sizet@@ ) ; @@sizet@@ = Number L ; } return @@sizet@@ ; }
__int64 __fastcall transfer_entries ( __int64 @@int64@@ , __int64 @@int64@@ , char @@char@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 * @@int64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; for ( @@int64@@ = * ( __int64 * * ) @@int64@@ ; ( unsigned __int64 ) @@int64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ += Number ) { if ( * @@int64@@ ) { for ( @@QWORD@@ = ( _QWORD * ) @@int64@@ [ Number ] ; @@QWORD@@ ; @@QWORD@@ = @@QWORD@@ ) { @@int64@@ = * @@QWORD@@ ; @@int64@@ = * ( _QWORD * ) @@int64@@ ; @@QWORD@@ = ( _QWORD * ) ( @@int64@@ + Number * ( * ( __int64 ( __fastcall * * ) ( _QWORD , _QWORD ) ) ( @@int64@@ + Number ) ) ( * @@QWORD@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@QWORD@@ >= * ( _QWORD * ) ( @@int64@@ + Number ) ) abort ( ) ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; if ( * @@QWORD@@ ) { @@QWORD@@ [ Number ] = @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = @@QWORD@@ ; } else { * @@QWORD@@ = @@int64@@ ; ++ * ( _QWORD * ) ( @@int64@@ + Number ) ; free_entry ( @@int64@@ , @@QWORD@@ ) ; } } @@int64@@ = * @@int64@@ ; @@int64@@ [ Number ] = Number L ; if ( ! @@char@@ ) { @@int64@@ = * ( _QWORD * ) @@int64@@ ; @@QWORD@@ = ( _QWORD * ) ( @@int64@@ + Number * ( * ( __int64 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@int64@@ + Number ) ) ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@QWORD@@ >= * ( _QWORD * ) ( @@int64@@ + Number ) ) abort ( ) ; if ( * @@QWORD@@ ) { @@QWORD@@ = allocate_entry ( @@int64@@ ) ; if ( ! @@QWORD@@ ) return Number L ; * @@QWORD@@ = @@int64@@ ; @@QWORD@@ [ Number ] = @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = @@QWORD@@ ; } else { * @@QWORD@@ = @@int64@@ ; ++ * ( _QWORD * ) ( @@int64@@ + Number ) ; } * @@int64@@ = Number L ; -- * ( _QWORD * ) ( @@int64@@ + Number ) ; } } } return Number L ; }
unsigned __int64 __fastcall skip ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; __int64 @@int64@@ ; char * @@char@@ ; unsigned __int64 @@unsignedint64@@ ; __off_t @@offt@@ ; int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; signed __int64 @@signedint64@@ ; struct stat @@structstat@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@unsignedint64@@ = @@unsignedint64@@ * @@unsignedint64@@ ; * __errno_location ( ) = Number ; if ( @@unsignedint64@@ > Number / @@unsignedint64@@ || skip_via_lseek ( @@int64@@ , @@unsignedint@@ , @@unsignedint64@@ , Number ) < Number ) { @@int@@ = * __errno_location ( ) ; if ( skip_via_lseek ( @@int64@@ , @@unsignedint@@ , Number L , Number ) >= Number ) { if ( ! @@int@@ ) @@int@@ = Number ; @@int64@@ = quote ( @@int64@@ ) ; if ( @@unsignedint@@ ) @@char@@ = gettext ( String ) ; else @@char@@ = gettext ( String ) ; error ( Number , @@int@@ , @@char@@ , @@int64@@ ) ; quit ( Number ) ; } do { @@signedint64@@ = iread_fnc ( @@unsignedint@@ , @@int64@@ , @@unsignedint64@@ ) ; if ( @@signedint64@@ >= Number ) { if ( ! @@signedint64@@ ) break ; if ( ! @@unsignedint@@ ) advance_input_offset ( @@signedint64@@ ) ; } else { if ( @@unsignedint@@ ) { @@int64@@ = quote ( @@int64@@ ) ; @@char@@ = gettext ( String ) ; error ( Number , @@int@@ , @@char@@ , @@int64@@ ) ; LABEL_24 : quit ( Number ) ; } @@int64@@ = quote ( @@int64@@ ) ; @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ , @@int64@@ ) ; if ( ( conversions_mask & Number ) == Number ) goto LABEL_24 ; print_stats ( ) ; } -- @@unsignedint64@@ ; } while ( @@unsignedint64@@ ) ; @@unsignedint64@@ = @@unsignedint64@@ ; } else { if ( @@unsignedint@@ ) { @@offt@@ = Number L ; } else { if ( ( unsigned int ) fstat ( Number , & @@structstat@@ ) ) { @@int64@@ = quote ( @@int64@@ ) ; @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ , @@int64@@ ) ; } if ( ( @@structstat@@ . st_mode & Number ) == Number && @@structstat@@ . st_size < input_offset + @@unsignedint64@@ ) { @@offt@@ = ( @@unsignedint64@@ - @@structstat@@ . st_size ) / @@unsignedint64@@ ; advance_input_offset ( @@structstat@@ . st_size - input_offset ) ; } else { @@offt@@ = Number L ; advance_input_offset ( @@unsignedint64@@ ) ; } } @@unsignedint64@@ = @@offt@@ ; } return @@unsignedint64@@ ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
int __fastcall argmatch_valid ( __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { char * @@char@@ ; __int64 @@int64@@ ; void * @@void@@ ; @@void@@ = Number L ; @@char@@ = gettext ( String ) ; fprintf ( stderr , @@char@@ ) ; for ( @@int64@@ = Number L ; * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; ++ @@int64@@ ) { if ( @@int64@@ && ! memcmp ( @@void@@ , ( const void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) , @@sizet@@ ) ) { fprintf ( stderr , String , * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) ) ; } else { fprintf ( stderr , String , * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) ) ; @@void@@ = ( void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) ; } } return putc_unlocked ( Number , stderr ) ; }
char * __fastcall group_number ( char * @@char@@ , size_t @@sizet@@ , unsigned __int8 * @@unsignedint8@@ , const char * @@constchar@@ ) { char * @@char@@ ; size_t @@sizet@@ ; char * @@char@@ ; unsigned __int8 @@unsignedint8@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@sizet@@ = Number ; @@sizet@@ = strlen ( @@constchar@@ ) ; @@sizet@@ = @@sizet@@ ; memcpy ( @@char@@ , @@char@@ , @@sizet@@ ) ; for ( @@char@@ = & @@char@@ [ @@sizet@@ ] ; ; memcpy ( @@char@@ , @@constchar@@ , @@sizet@@ ) ) { @@unsignedint8@@ = * @@unsignedint8@@ ; if ( * @@unsignedint8@@ ) { if ( @@unsignedint8@@ > Number ) @@sizet@@ = @@sizet@@ ; else @@sizet@@ = @@unsignedint8@@ ; @@sizet@@ = @@sizet@@ ; ++ @@unsignedint8@@ ; } if ( @@sizet@@ < @@sizet@@ ) @@sizet@@ = @@sizet@@ ; @@char@@ = & @@char@@ [ - @@sizet@@ ] ; @@sizet@@ -= @@sizet@@ ; memcpy ( @@char@@ , & @@char@@ [ @@sizet@@ ] , @@sizet@@ ) ; if ( ! @@sizet@@ ) break ; @@char@@ = & @@char@@ [ - @@sizet@@ ] ; } return @@char@@ ; }
__int64 __fastcall getgroup ( __gid_t @@gidt@@ ) { const char * @@constchar@@ ; size_t @@sizet@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; struct group * @@structgroup@@ ; char * @@char@@ ; @@int64@@ = Number L ; for ( @@int64@@ = group_alist ; @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ) { if ( @@gidt@@ == * ( _DWORD * ) @@int64@@ ) { @@int64@@ = @@int64@@ ; break ; } } if ( ! @@int64@@ ) { @@structgroup@@ = getgrgid ( @@gidt@@ ) ; if ( @@structgroup@@ ) @@constchar@@ = @@structgroup@@ -> gr_name ; else @@constchar@@ = ( const char * ) & unk_19CC0 ; @@char@@ = ( char * ) @@constchar@@ ; @@sizet@@ = strlen ( @@constchar@@ ) ; @@int64@@ = xmalloc ( @@sizet@@ + Number ) ; * ( _DWORD * ) @@int64@@ = @@gidt@@ ; strcpy ( ( char * ) ( @@int64@@ + Number ) , @@char@@ ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = group_alist ; group_alist = @@int64@@ ; } if ( * ( _BYTE * ) ( @@int64@@ + Number ) ) @@int64@@ = @@int64@@ + Number ; else @@int64@@ = Number L ; return @@int64@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall human_options ( char * @@char@@ , int * @@int@@ , _QWORD * @@QWORD@@ ) { unsigned int @@unsignedint@@ ; @@unsignedint@@ = humblock ( @@char@@ , @@QWORD@@ , @@int@@ ) ; if ( ! * @@QWORD@@ ) { * @@QWORD@@ = default_block_size ( ) ; @@unsignedint@@ = Number ; } return @@unsignedint@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
__int64 __fastcall humblock ( char * @@char@@ , uintmax_t * @@uintmaxt@@ , int * @@int@@ ) { char * @@char@@ ; int @@int@@ ; int @@int@@ ; unsigned int @@unsignedint@@ ; char * @@char2@@ [ Number ] ; @@char@@ = @@char@@ ; @@char2@@ [ Number ] = ( char * ) __readfsqword ( Number ) ; @@int@@ = Number ; if ( @@char@@ || ( @@char@@ = getenv ( String ) ) != Number L || ( @@char@@ = getenv ( String ) ) != Number L ) { if ( * @@char@@ == Number ) { @@int@@ = Number ; ++ @@char@@ ; } @@int@@ = argmatch ( @@char@@ , & block_size_args , block_size_opts , Number L ) ; if ( @@int@@ < Number ) { @@unsignedint@@ = xstrtoumax ( @@char@@ , @@char2@@ , Number , @@uintmaxt@@ , String ) ; if ( @@unsignedint@@ ) { * @@int@@ = Number ; return @@unsignedint@@ ; } while ( * @@char@@ <= Number || * @@char@@ > Number ) { if ( @@char@@ == @@char2@@ [ Number ] ) { @@int@@ |= Number ; if ( * ( @@char2@@ [ Number ] - Number ) == Number ) @@int@@ |= Number ; if ( * ( @@char2@@ [ Number ] - Number ) != Number || * ( @@char2@@ [ Number ] - Number ) == Number ) @@int@@ |= Number ; break ; } ++ @@char@@ ; } } else { @@int@@ |= block_size_opts [ @@int@@ ] ; * @@uintmaxt@@ = Number L ; } } else { * @@uintmaxt@@ = default_block_size ( ) ; } * @@int@@ = @@int@@ ; return Number L ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ ) { return xmalloc ( @@int64@@ ) ; }
__int64 __fastcall getuidbyname ( const char * @@constchar@@ ) { __int64 @@int64@@ ; size_t @@sizet@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; struct passwd * @@structpasswd@@ ; for ( @@int64@@ = user_alist ; @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ) { if ( * ( _BYTE * ) ( @@int64@@ + Number ) == * @@constchar@@ && ! strcmp ( ( const char * ) ( @@int64@@ + Number ) , @@constchar@@ ) ) { return @@int64@@ ; } } for ( @@int64@@ = nouser_alist ; @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ) { if ( * ( _BYTE * ) ( @@int64@@ + Number ) == * @@constchar@@ && ! strcmp ( ( const char * ) ( @@int64@@ + Number ) , @@constchar@@ ) ) { return Number L ; } } @@structpasswd@@ = getpwnam ( @@constchar@@ ) ; @@sizet@@ = strlen ( @@constchar@@ ) ; @@int64@@ = xmalloc ( @@sizet@@ + Number ) ; strcpy ( ( char * ) ( @@int64@@ + Number ) , @@constchar@@ ) ; if ( @@structpasswd@@ ) { * ( _DWORD * ) @@int64@@ = @@structpasswd@@ -> pw_uid ; * ( _QWORD * ) ( @@int64@@ + Number ) = user_alist ; user_alist = @@int64@@ ; @@int64@@ = @@int64@@ ; } else { * ( _QWORD * ) ( @@int64@@ + Number ) = nouser_alist ; nouser_alist = @@int64@@ ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall hash_get_n_buckets ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
__int64 __fastcall hash_get_n_buckets_used ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall select_plural ( __int64 @@int64@@ ) { return @@int64@@ ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
void __fastcall mpsort_with_tmp ( __int64 * @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 * @@int64@@ , __int64 ( __fastcall * @ @ VAR_1614 @ @ int64 ( fastcall ) ( int64 , int64 ) @ @ int64 ( fastcall ) ( int64 , int64 ) ) ( __int64 , __int64 ) ) { int @@int@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; if ( @@unsignedint64@@ > Number ) { @@int64@@ = Number L ; @@unsignedint64@@ = @@unsignedint64@@ >> Number ; @@unsignedint64@@ = @@unsignedint64@@ >> Number ; mpsort_with_tmp ( & @@int64@@ [ @@unsignedint64@@ >> Number ] , @@unsignedint64@@ - ( @@unsignedint64@@ >> Number ) , @@int64@@ , @ @ VAR_1614 @ @ int64 ( fastcall ) ( int64 , int64 ) @ @ int64 ( fastcall ) ( int64 , int64 ) ) ; if ( @@unsignedint64@@ >> Number > Number ) mpsort_into_tmp ( @@int64@@ , @@unsignedint64@@ >> Number , @@int64@@ , @ @ VAR_1614 @ @ int64 ( fastcall ) ( int64 , int64 ) @ @ int64 ( fastcall ) ( int64 , int64 ) ) ; else * @@int64@@ = * @@int64@@ ; @@int64@@ = * @@int64@@ ; @@int64@@ = @@int64@@ [ @@unsignedint64@@ ] ; @@int64@@ = Number L ; for ( @@int@@ = @ @ VAR_1614 @ @ int64 ( fastcall ) ( int64 , int64 ) @ @ int64 ( fastcall ) ( int64 , int64 ) ( * @@int64@@ , @@int64@@ ) ; ; @@int@@ = @ @ VAR_1614 @ @ int64 ( fastcall ) ( int64 , int64 ) @ @ int64 ( fastcall ) ( int64 , int64 ) ( @@int64@@ , @@int64@@ ) ) { while ( @@int@@ <= Number ) { @@int64@@ = @@int64@@ ++ ; @@int64@@ [ @@int64@@ ] = @@int64@@ ; if ( ++ @@int64@@ == @@unsignedint64@@ ) return ; @@int64@@ = @@int64@@ [ @@int64@@ ] ; @@int@@ = @ @ VAR_1614 @ @ int64 ( fastcall ) ( int64 , int64 ) @ @ int64 ( fastcall ) ( int64 , int64 ) ( @@int64@@ , @@int64@@ ) ; } @@int64@@ = @@int64@@ ++ ; @@int64@@ [ @@int64@@ ] = @@int64@@ ; if ( ++ @@unsignedint64@@ == @@unsignedint64@@ ) break ; @@int64@@ = @@int64@@ [ @@unsignedint64@@ ] ; } memcpy ( & @@int64@@ [ @@int64@@ ] , & @@int64@@ [ @@int64@@ ] , Number * ( @@unsignedint64@@ - @@int64@@ ) ) ; } else if ( @@unsignedint64@@ == Number ) { @@int64@@ = * @@int64@@ ; @@int64@@ = @@int64@@ [ Number ] ; if ( ( int ) @ @ VAR_1614 @ @ int64 ( fastcall ) ( int64 , int64 ) @ @ int64 ( fastcall ) ( int64 , int64 ) ( * @@int64@@ , @@int64@@ ) > Number ) { * @@int64@@ = @@int64@@ ; @@int64@@ [ Number ] = @@int64@@ ; } } }
__int64 __fastcall hash_get_n_entries ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 __fastcall _xargmatch_internal ( __int64 @@int64@@ , const char * @@constchar@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ , void ( * @ @ VAR_1011 @ @ void ( ) ( void ) @ @ argmatchexitfn ) ( void ) ) { __int64 @@int64@@ ; @@int64@@ = argmatch ( @@constchar@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; if ( @@int64@@ >= Number ) return @@int64@@ ; argmatch_invalid ( @@int64@@ , ( __int64 ) @@constchar@@ , @@int64@@ ) ; argmatch_valid ( @@int64@@ , @@int64@@ , @@sizet@@ ) ; @ @ VAR_1011 @ @ void ( ) ( void ) @ @ argmatchexitfn ( ) ; return Number ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
ssize_t __fastcall iread ( int @@int@@ , void * @@void@@ , size_t @@sizet@@ ) { ssize_t @@ssizet@@ ; do { process_signals ( ) ; @@ssizet@@ = read ( @@int@@ , @@void@@ , @@sizet@@ ) ; } while ( @@ssizet@@ < Number && * __errno_location ( ) == Number ) ; return @@ssizet@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
unsigned __int64 __fastcall validate_tab_stops ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { char * @@char@@ ; char * @@char@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = Number L ; for ( @@unsignedint64@@ = Number L ; ; ++ @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ ; if ( @@unsignedint64@@ >= @@unsignedint64@@ ) break ; if ( ! * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@int64@@ ) ) { @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ ) ; } if ( @@unsignedint64@@ >= * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@int64@@ ) ) { @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ ) ; } @@unsignedint64@@ = * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@int64@@ ) ; } return @@unsignedint64@@ ; }
_BOOL8 __fastcall hash_table_ok ( __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; @@int64@@ = Number L ; @@int64@@ = Number L ; for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { @@QWORD@@ = @@QWORD@@ ; ++ @@int64@@ ; ++ @@int64@@ ; while ( Number ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; if ( ! @@QWORD@@ ) break ; ++ @@int64@@ ; } } } return @@int64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) && @@int64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
__int64 __fastcall memcpy_uppcase ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { while ( @@int64@@ -- ) * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) = toupper ( * ( unsigned __int8 * ) ( @@int64@@ + @@int64@@ ) ) ; return @@int64@@ ; }
__int64 __fastcall parse_integer ( __int64 @@int64@@ , _BYTE * @@BYTE@@ ) { int @@int@@ ; __int64 @@int64@@ ; _BYTE * @@BYTE@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int@@ = xstrtoumax ( @@int64@@ , & @@BYTE@@ , Number L , & @@int64@@ , String ) ; if ( @@int@@ == Number && * @@BYTE@@ == Number ) { @@unsignedint64@@ = parse_integer ( ( __int64 ) ( @@BYTE@@ + Number ) , @@BYTE@@ ) ; if ( @@unsignedint64@@ && @@unsignedint64@@ * @@int64@@ / @@unsignedint64@@ != @@int64@@ ) { * @@BYTE@@ = Number ; return Number L ; } @@int64@@ *= @@unsignedint64@@ ; } else if ( @@int@@ ) { * @@BYTE@@ = Number ; return Number L ; } return @@int64@@ ; }
__int64 __fastcall memcpy_lowcase ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { while ( @@int64@@ -- ) * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) = tolower ( * ( unsigned __int8 * ) ( @@int64@@ + @@int64@@ ) ) ; return @@int64@@ ; }
__int64 __fastcall x2nrealloc ( __int64 @@int64@@ , unsigned __int64 * @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = * @@unsignedint64@@ ; if ( @@int64@@ ) { if ( @@unsignedint64@@ >= Number / @@unsignedint64@@ ) xalloc_die ( ) ; @@unsignedint64@@ += ( @@unsignedint64@@ + Number ) >> Number ; } else if ( ! @@unsignedint64@@ ) { @@unsignedint64@@ = ( Number / @@unsignedint64@@ == Number ) + Number / @@unsignedint64@@ ; } * @@unsignedint64@@ = @@unsignedint64@@ ; return xrealloc ( @@int64@@ , @@unsignedint64@@ * @@unsignedint64@@ ) ; }
__int64 __fastcall hash_get_first ( unsigned __int64 * @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; if ( ! @@unsignedint64@@ [ Number ] ) return Number L ; for ( @@unsignedint64@@ = * @@unsignedint64@@ ; ; @@unsignedint64@@ += Number L ) { if ( @@unsignedint64@@ >= @@unsignedint64@@ [ Number ] ) abort ( ) ; if ( * ( _QWORD * ) @@unsignedint64@@ ) break ; } return * ( _QWORD * ) @@unsignedint64@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 __fastcall umaxtostr ( unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = @@int64@@ + Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = Number ; do { * ( _BYTE * ) -- @@int64@@ = @@unsignedint64@@ % Number + Number ; @@unsignedint64@@ /= Number ; } while ( @@unsignedint64@@ ) ; return @@int64@@ ; }
__int64 __fastcall hash_do_for_each ( __int64 @@int64@@ , unsigned __int8 ( __fastcall * @ @ VAR_1333 @ @ unsignedint8 ( fastcall ) ( QWORD , int64 ) @ @ Hashprocessor ) ( _QWORD , __int64 ) , __int64 @@int64@@ ) { __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; @@int64@@ = Number L ; for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { for ( @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { if ( @ @ VAR_1333 @ @ unsignedint8 ( fastcall ) ( QWORD , int64 ) @ @ Hashprocessor ( * @@QWORD@@ , @@int64@@ ) != Number ) return @@int64@@ ; ++ @@int64@@ ; } } } return @@int64@@ ; }
__int64 __fastcall advance_input_after_read_error ( unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; __off_t @@offt@@ ; unsigned __int64 @@unsignedint64@@ ; if ( input_seekable != Number ) { if ( input_seek_errno == Number ) return Number L ; * __errno_location ( ) = input_seek_errno ; } else { advance_input_offset ( @@unsignedint64@@ ) ; input_offset_overflow = ( ( unsigned __int8 ) input_offset_overflow | ( input_offset < Number ) ) != Number ; if ( input_offset_overflow ) { @@int64@@ = quote ( input_file ) ; @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ , @@int64@@ ) ; return Number L ; } @@offt@@ = lseek ( Number , Number L , Number ) ; if ( @@offt@@ >= Number ) { if ( @@offt@@ == input_offset ) return Number L ; @@unsignedint64@@ = input_offset - @@offt@@ ; if ( input_offset - @@offt@@ < Number || @@unsignedint64@@ < @@unsignedint64@@ ) { @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ ) ; } if ( skip_via_lseek ( input_file , Number , @@unsignedint64@@ , Number ) >= Number ) return Number L ; if ( ! * __errno_location ( ) ) { @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ ) ; } } } @@int64@@ = quote ( input_file ) ; @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ , @@int64@@ ) ; return Number L ; }
__int64 __fastcall bkm_scale_0 ( unsigned __int64 * @@unsignedint64@@ , int @@int@@ ) { __int64 @@int64@@ ; if ( is_mul_ok ( @@int@@ , * @@unsignedint64@@ ) ) { * @@unsignedint64@@ *= @@int@@ ; @@int64@@ = Number L ; } else { * @@unsignedint64@@ = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall c_tolower ( int @@int@@ ) { __int64 @@int64@@ ; if ( @@int@@ <= Number || @@int@@ > Number ) @@int64@@ = ( unsigned int ) @@int@@ ; else @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; return @@int64@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
unsigned __int64 __fastcall compute_bucket_size ( __int64 @@int64@@ , __int64 @@int64@@ ) { float @@float@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; float @@float@@ ; @@unsignedint64@@ = @@int64@@ ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) != Number ) { if ( @@int64@@ < Number ) @@float@@ = ( float ) ( @@int64@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@int64@@ >> Number ) ) + ( float ) ( @@int64@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@int64@@ >> Number ) ) ; else @@float@@ = ( float ) ( int ) @@int64@@ ; @@float@@ = @@float@@ / * ( float * ) ( @@int64@@ + Number ) ; if ( @@float@@ >= Number ) return Number L ; if ( @@float@@ >= Number ) @@unsignedint64@@ = ( unsigned int ) ( int ) ( float ) ( @@float@@ - Number ) ^ Number ; else @@unsignedint64@@ = ( unsigned int ) ( int ) @@float@@ ; } @@unsignedint64@@ = next_prime ( @@unsignedint64@@ ) ; if ( @@unsignedint64@@ <= Number ) @@unsignedint64@@ = @@unsignedint64@@ ; else @@unsignedint64@@ = Number L ; return @@unsignedint64@@ ; }
__int64 __fastcall bkm_scale_by_power ( unsigned __int64 * @@unsignedint64@@ , int @@int@@ , int @@int@@ ) { unsigned int @@unsignedint@@ ; for ( @@unsignedint@@ = Number ; @@int@@ -- ; @@unsignedint@@ |= bkm_scale ( @@unsignedint64@@ , @@int@@ ) ) { ; } return @@unsignedint@@ ; }
__int64 __fastcall bkm_scale_by_power_0 ( unsigned __int64 * @@unsignedint64@@ , int @@int@@ , int @@int@@ ) { unsigned int @@unsignedint@@ ; for ( @@unsignedint@@ = Number ; @@int@@ -- ; @@unsignedint@@ |= bkm_scale_0 ( @@unsignedint64@@ , @@int@@ ) ) { ; } return @@unsignedint@@ ; }
__int64 __fastcall gid_to_name ( __gid_t @@gidt@@ ) { __int64 @@int64@@ ; struct group * @@structgroup@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@structgroup@@ = getgrgid ( @@gidt@@ ) ; if ( @@structgroup@@ ) @@int64@@ = ( __int64 ) @@structgroup@@ -> gr_name ; else @@int64@@ = umaxtostr ( @@gidt@@ , @@char@@ ) ; return xstrdup ( @@int64@@ ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall hash_rehash ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; void * @@void@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@unsignedint64@@ = compute_bucket_size ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( ! @@unsignedint64@@ ) return Number L ; if ( @@unsignedint64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ) return Number L ; @@void@@ = calloc ( @@unsignedint64@@ , Number ) ; if ( ! @@void@@ ) return Number L ; @@unsignedint64@@ = @@unsignedint64@@ ; @@int64@@ = ( __int64 ) @@void@@ + Number * @@unsignedint64@@ ; @@int64@@ = Number L ; @@int64@@ = Number L ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( ( unsigned __int8 ) transfer_entries ( ( __int64 ) & @@void@@ , @@int64@@ , Number ) ) { free ( * ( void * * ) @@int64@@ ) ; * ( _QWORD * ) @@int64@@ = @@void@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@unsignedint64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; @@int64@@ = Number L ; } else { * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; if ( ( unsigned __int8 ) transfer_entries ( @@int64@@ , ( __int64 ) & @@void@@ , Number ) != Number || ( unsigned __int8 ) transfer_entries ( @@int64@@ , ( __int64 ) & @@void@@ , Number ) != Number ) { abort ( ) ; } free ( @@void@@ ) ; @@int64@@ = Number L ; } return @@int64@@ ; }
_BOOL8 __fastcall chown_files ( __int64 @@int64@@ , unsigned int @@unsignedint@@ , __uid_t @@uidt@@ , __gid_t @@gidt@@ , int @@int@@ , int @@int@@ , __int64 @@int64@@ ) { int @@int@@ ; char * @@char@@ ; int * @@int@@ ; char * @@char@@ ; int * @@int@@ ; bool @@bool@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; @@bool@@ = Number ; if ( @@int@@ == Number && @@int@@ == Number && ! * ( _BYTE * ) ( @@int64@@ + Number ) && * ( _DWORD * ) @@int64@@ == Number ) { @@int@@ = Number ; } else { @@int@@ = Number ; } for ( @@int64@@ = xfts_open ( @@int64@@ , @@int@@ | @@unsignedint@@ , Number L ) ; ; @@bool@@ = ( @@bool@@ & ( unsigned __int8 ) change_file_owner ( @@int64@@ , @@int64@@ , @@uidt@@ , @@gidt@@ , @@int@@ , @@int@@ , @@int64@@ ) ) != Number ) { @@int64@@ = fts_read ( @@int64@@ ) ; if ( ! @@int64@@ ) break ; } if ( * __errno_location ( ) ) { if ( * ( _BYTE * ) ( @@int64@@ + Number ) != Number ) { @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ ) ; } @@bool@@ = Number ; } if ( ( unsigned int ) fts_close ( @@int64@@ ) ) { @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ ) ; @@bool@@ = Number ; } return @@bool@@ ; }
__int64 __fastcall rpl_fcntl ( int @@int@@ , int @@int@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ ) { int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; if ( @@int@@ != Number ) return ( unsigned int ) fcntl ( @@int@@ , @@int@@ , @@int64@@ ) ; @@int@@ = @@int64@@ ; if ( have_dupfd_cloexec_2895 < Number ) { @@int@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@int@@ , Number , @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ ) ; } else { @@int@@ = fcntl ( @@int@@ , Number , ( unsigned int ) @@int64@@ ) ; if ( @@int@@ < Number && * __errno_location ( ) == Number ) { @@int@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@int@@ , Number , @@int@@ , @@int@@ , @@int@@ , @@int@@ ) ; if ( @@int@@ < Number ) return ( unsigned int ) @@int@@ ; have_dupfd_cloexec_2895 = Number ; } else { have_dupfd_cloexec_2895 = Number ; } } if ( @@int@@ >= Number && have_dupfd_cloexec_2895 == Number ) { @@int@@ = fcntl ( @@int@@ , Number ) ; if ( @@int@@ < Number || fcntl ( @@int@@ , Number , @@int@@ | Number ) == Number ) { @@int@@ = * __errno_location ( ) ; close ( @@int@@ ) ; * __errno_location ( ) = @@int@@ ; @@int@@ = Number ; } } return ( unsigned int ) @@int@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall getuser ( __uid_t @@uidt@@ ) { const char * @@constchar@@ ; size_t @@sizet@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; struct passwd * @@structpasswd@@ ; char * @@char@@ ; @@int64@@ = Number L ; for ( @@int64@@ = user_alist ; @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ) { if ( @@uidt@@ == * ( _DWORD * ) @@int64@@ ) { @@int64@@ = @@int64@@ ; break ; } } if ( ! @@int64@@ ) { @@structpasswd@@ = getpwuid ( @@uidt@@ ) ; if ( @@structpasswd@@ ) @@constchar@@ = @@structpasswd@@ -> pw_name ; else @@constchar@@ = ( const char * ) & unk_19CC0 ; @@char@@ = ( char * ) @@constchar@@ ; @@sizet@@ = strlen ( @@constchar@@ ) ; @@int64@@ = xmalloc ( @@sizet@@ + Number ) ; * ( _DWORD * ) @@int64@@ = @@uidt@@ ; strcpy ( ( char * ) ( @@int64@@ + Number ) , @@char@@ ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = user_alist ; user_alist = @@int64@@ ; } if ( * ( _BYTE * ) ( @@int64@@ + Number ) ) @@int64@@ = @@int64@@ + Number ; else @@int64@@ = Number L ; return @@int64@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall enter_dir ( __int64 @@int64@@ , __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; if ( ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number ) { @@QWORD@@ = malloc ( Number ) ; if ( ! @@QWORD@@ ) return Number L ; * @@QWORD@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ [ Number ] = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = hash_insert ( * ( _QWORD * ) ( @@int64@@ + Number ) , @@QWORD@@ ) ; if ( ( _QWORD * ) @@int64@@ != @@QWORD@@ ) { free ( @@QWORD@@ ) ; if ( ! @@int64@@ ) return Number L ; * ( _QWORD * ) @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _WORD * ) ( @@int64@@ + Number ) = Number ; } } else if ( ( unsigned __int8 ) cycle_check ( * ( _QWORD * ) ( @@int64@@ + Number ) , @@int64@@ + Number ) ) { * ( _QWORD * ) @@int64@@ = @@int64@@ ; * ( _WORD * ) ( @@int64@@ + Number ) = Number ; } return Number L ; }
void * __fastcall mpsort_into_tmp ( __int64 * @@int64@@ , unsigned __int64 @@unsignedint64@@ , _QWORD * @@QWORD@@ , __int64 ( __fastcall * @ @ VAR_1602 @ @ int64 ( fastcall ) ( int64 , int64 ) @ @ int64 ( fastcall ) ( int64 , int64 ) ) ( __int64 , __int64 ) ) { int @@int@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; @@QWORD@@ = @@QWORD@@ ; @@unsignedint64@@ = Number L ; @@unsignedint64@@ = @@unsignedint64@@ >> Number ; @@unsignedint64@@ = @@unsignedint64@@ >> Number ; mpsort_with_tmp ( & @@int64@@ [ @@unsignedint64@@ >> Number ] , @@unsignedint64@@ - ( @@unsignedint64@@ >> Number ) , @@QWORD@@ , @ @ VAR_1602 @ @ int64 ( fastcall ) ( int64 , int64 ) @ @ int64 ( fastcall ) ( int64 , int64 ) ) ; mpsort_with_tmp ( @@int64@@ , @@unsignedint64@@ >> Number , @@QWORD@@ , @ @ VAR_1602 @ @ int64 ( fastcall ) ( int64 , int64 ) @ @ int64 ( fastcall ) ( int64 , int64 ) ) ; @@int64@@ = * @@int64@@ ; @@int64@@ = @@int64@@ [ @@unsignedint64@@ >> Number ] ; for ( @@int@@ = @ @ VAR_1602 @ @ int64 ( fastcall ) ( int64 , int64 ) @ @ int64 ( fastcall ) ( int64 , int64 ) ( * @@int64@@ , @@int64@@ ) ; ; @@int@@ = @ @ VAR_1602 @ @ int64 ( fastcall ) ( int64 , int64 ) @ @ int64 ( fastcall ) ( int64 , int64 ) ( @@int64@@ , @@int64@@ ) ) { while ( @@int@@ > Number ) { @@QWORD@@ = @@QWORD@@ ++ ; * @@QWORD@@ = @@int64@@ ; if ( ++ @@unsignedint64@@ == @@unsignedint64@@ ) return memcpy ( @@QWORD@@ , & @@int64@@ [ @@unsignedint64@@ ] , Number * ( @@unsignedint64@@ - @@unsignedint64@@ ) ) ; @@int64@@ = @@int64@@ [ @@unsignedint64@@ ] ; @@int@@ = @ @ VAR_1602 @ @ int64 ( fastcall ) ( int64 , int64 ) @ @ int64 ( fastcall ) ( int64 , int64 ) ( @@int64@@ , @@int64@@ ) ; } @@QWORD@@ = @@QWORD@@ ++ ; * @@QWORD@@ = @@int64@@ ; if ( ++ @@unsignedint64@@ == @@unsignedint64@@ ) break ; @@int64@@ = @@int64@@ [ @@unsignedint64@@ ] ; } @@unsignedint64@@ = @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint64@@ ; return memcpy ( @@QWORD@@ , & @@int64@@ [ @@unsignedint64@@ ] , Number * ( @@unsignedint64@@ - @@unsignedint64@@ ) ) ; }
void * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
_BOOL8 __fastcall AD_compare ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ ) { return @@QWORD@@ [ Number ] == @@QWORD@@ [ Number ] && * @@QWORD@@ == * @@QWORD@@ ; }
unsigned __int64 __fastcall LCO_hash ( _QWORD * @@QWORD@@ , unsigned __int64 @@unsignedint64@@ ) { return * @@QWORD@@ % @@unsignedint64@@ ; }
void * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_21F238 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
unsigned __int64 __fastcall AD_hash ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) % @@unsignedint64@@ ; }
bool __fastcall LCO_compare ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ ) { return * @@QWORD@@ == * @@QWORD@@ ; }
void * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
__int64 __fastcall fts_set ( __int64 a1 , __int64 @@int64@@ , int @@int@@ ) { __int64 @@int64@@ ; if ( ! @@int@@ || @@int@@ == Number || @@int@@ == Number || @@int@@ == Number || @@int@@ == Number ) { * ( _WORD * ) ( @@int64@@ + Number ) = @@int@@ ; @@int64@@ = Number L ; } else { * __errno_location ( ) = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall setup_dir ( __int64 @@int64@@ ) { if ( ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number ) { * ( _QWORD * ) ( @@int64@@ + Number ) = hash_initialize ( Number L , Number L , AD_hash , AD_compare , & free ) ; if ( ! * ( _QWORD * ) ( @@int64@@ + Number ) ) return Number L ; } else { * ( _QWORD * ) ( @@int64@@ + Number ) = malloc ( Number ) ; if ( ! * ( _QWORD * ) ( @@int64@@ + Number ) ) return Number L ; cycle_check_init ( * ( _QWORD * ) ( @@int64@@ + Number ) ) ; } return Number L ; }
__int64 __fastcall fts_compar ( __int64 @@int64@@ , __int64 @@int64@@ ) { return ( * ( __int64 ( __fastcall * * ) ( __int64 , __int64 ) ) ( * ( _QWORD * ) ( * ( _QWORD * ) @@int64@@ + Number L ) + Number L ) ) ( @@int64@@ , @@int64@@ ) ; }
void * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_20E368 ; @@int648@@ [ Number ] = qword_20E370 ; @@int648@@ [ Number ] = qword_20E378 ; @@int648@@ [ Number ] = qword_20E380 ; @@int648@@ [ Number ] = qword_20E388 ; @@int648@@ [ Number ] = qword_20E390 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
void __fastcall hash_free ( __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) && * ( _QWORD * ) ( @@int64@@ + Number ) ) { for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { for ( @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@int64@@ + Number ) ) ( * @@QWORD@@ ) ; } } } } for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { for ( @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; @@QWORD@@ ; @@QWORD@@ = @@QWORD@@ ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; free ( @@QWORD@@ ) ; } } for ( @@QWORD@@ = * ( _QWORD * * ) ( @@int64@@ + Number ) ; @@QWORD@@ ; @@QWORD@@ = @@QWORD@@ ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; free ( @@QWORD@@ ) ; } free ( * ( void * * ) @@int64@@ ) ; free ( ( void * ) @@int64@@ ) ; }
__int64 __fastcall diropen ( __int64 @@int64@@ , int @@int@@ , __int64 a3 , int @@int@@ , int @@int@@ , int @@int@@ ) { int @@int@@ ; int @@int@@ ; unsigned int @@unsignedint@@ ; @@int@@ = ( * ( _DWORD * ) ( @@int64@@ + Number ) << Number ) & Number | Number ; if ( ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number ) @@int@@ = openat_safer ( * ( _DWORD * ) ( @@int64@@ + Number ) , @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int@@ ) ; else @@int@@ = open_safer ( @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int@@ ) ; @@unsignedint@@ = @@int@@ ; if ( @@int@@ >= Number ) set_cloexec_flag ( ( unsigned int ) @@int@@ , Number L ) ; return @@unsignedint@@ ; }
__int64 __fastcall fts_palloc ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; void * @@void@@ ; @@unsignedint64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) + @@int64@@ + Number ; if ( @@unsignedint64@@ >= * ( _QWORD * ) ( @@int64@@ + Number ) ) { * ( _QWORD * ) ( @@int64@@ + Number ) = @@unsignedint64@@ ; @@void@@ = realloc ( * ( void * * ) ( @@int64@@ + Number ) , * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( @@void@@ ) { * ( _QWORD * ) ( @@int64@@ + Number ) = @@void@@ ; @@int64@@ = Number L ; } else { free ( * ( void * * ) ( @@int64@@ + Number ) ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number L ; @@int64@@ = Number L ; } } else { free ( * ( void * * ) ( @@int64@@ + Number ) ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number L ; * __errno_location ( ) = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
void __fastcall argmatch_invalid ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { char * @@char@@ ; __int64 @@int64@@ ; void * @@void@@ ; char * @@char@@ ; if ( @@int64@@ == Number ) @@char@@ = gettext ( String ) ; else @@char@@ = gettext ( String ) ; @@char@@ = @@char@@ ; @@int64@@ = quote_n ( Number , @@int64@@ ) ; @@void@@ = quotearg_n_style ( Number , Number , @@int64@@ ) ; error ( Number , Number , @@char@@ , @@void@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
void * __fastcall allocate_entry ( __int64 @@int64@@ ) { __int64 @@int64@@ ; if ( ! * ( _QWORD * ) ( @@int64@@ + Number ) ) return malloc ( Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; return ( void * ) @@int64@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_20A0E8 ; @@int648@@ [ Number ] = qword_20A0F0 ; @@int648@@ [ Number ] = qword_20A0F8 ; @@int648@@ [ Number ] = qword_20A100 ; @@int648@@ [ Number ] = qword_20A108 ; @@int648@@ [ Number ] = qword_20A110 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
__int64 __fastcall set_stat_type ( __int64 @@int64@@ , int @@int@@ ) { __int64 @@int64@@ ; int @@int@@ ; switch ( @@int@@ ) { case Number : @@int@@ = Number ; break ; case Number : @@int@@ = Number ; break ; case Number : @@int@@ = Number ; break ; case Number : @@int@@ = Number ; break ; case Number : @@int@@ = Number ; break ; case Number : @@int@@ = Number ; break ; case Number : @@int@@ = Number ; break ; default : @@int@@ = Number ; break ; } @@int64@@ = @@int64@@ ; * ( _DWORD * ) ( @@int64@@ + Number ) = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall argmatch_to_argument ( const void * @@constvoid@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; ++ @@int64@@ ) { if ( ! memcmp ( @@constvoid@@ , ( const void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) , @@sizet@@ ) ) return * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; } return Number L ; }
size_t __fastcall fts_maxarglen ( const char * * @@constchar@@ ) { size_t @@sizet@@ ; size_t @@sizet@@ ; @@sizet@@ = Number L ; while ( * @@constchar@@ ) { @@sizet@@ = strlen ( * @@constchar@@ ) ; if ( @@sizet@@ > @@sizet@@ ) @@sizet@@ = @@sizet@@ ; ++ @@constchar@@ ; } return @@sizet@@ + Number ; }
_DWORD * __fastcall sha1_buffer ( __int64 @@int64@@ , __int64 @@int64@@ , _DWORD * @@DWORD@@ ) { _DWORD @@DWORD@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; sha1_init_ctx ( @@DWORD@@ ) ; sha1_process_bytes ( @@int64@@ , @@int64@@ , @@DWORD@@ ) ; return sha1_finish_ctx ( @@DWORD@@ , @@DWORD@@ ) ; }
__int64 __fastcall free_entry ( __int64 @@int64@@ , _QWORD * @@QWORD@@ ) { __int64 @@int64@@ ; * @@QWORD@@ = Number L ; @@QWORD@@ [ Number ] = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@QWORD@@ ; return @@int64@@ ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall hash_get_n_buckets ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 __fastcall hash_rehash ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; void * @@void@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@unsignedint64@@ = compute_bucket_size ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( ! @@unsignedint64@@ ) return Number L ; if ( @@unsignedint64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ) return Number L ; @@void@@ = calloc ( @@unsignedint64@@ , Number ) ; if ( ! @@void@@ ) return Number L ; @@unsignedint64@@ = @@unsignedint64@@ ; @@int64@@ = ( __int64 ) @@void@@ + Number * @@unsignedint64@@ ; @@int64@@ = Number L ; @@int64@@ = Number L ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( ( unsigned __int8 ) transfer_entries ( ( __int64 ) & @@void@@ , @@int64@@ , Number ) ) { free ( * ( void * * ) @@int64@@ ) ; * ( _QWORD * ) @@int64@@ = @@void@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@unsignedint64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; @@int64@@ = Number L ; } else { * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; if ( ( unsigned __int8 ) transfer_entries ( @@int64@@ , ( __int64 ) & @@void@@ , Number ) != Number || ( unsigned __int8 ) transfer_entries ( @@int64@@ , ( __int64 ) & @@void@@ , Number ) != Number ) { abort ( ) ; } free ( @@void@@ ) ; @@int64@@ = Number L ; } return @@int64@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
__int64 __fastcall hash_get_n_buckets_used ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 __fastcall hash_find_entry ( __int64 @@int64@@ , __int64 @@int64@@ , _QWORD * @@QWORD@@ , char @@char@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; @@int64@@ = * ( _QWORD * ) @@int64@@ ; @@QWORD@@ = ( _QWORD * ) ( @@int64@@ + Number * ( * ( __int64 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@int64@@ + Number ) ) ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@QWORD@@ >= * ( _QWORD * ) ( @@int64@@ + Number ) ) abort ( ) ; * @@QWORD@@ = @@QWORD@@ ; if ( ! * @@QWORD@@ ) return Number L ; if ( @@int64@@ == * @@QWORD@@ || ( * ( unsigned __int8 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@int64@@ + Number ) ) ( @@int64@@ , * @@QWORD@@ ) ) { @@int64@@ = * @@QWORD@@ ; if ( @@char@@ ) { if ( @@QWORD@@ [ Number ] ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; @@int64@@ = @@QWORD@@ [ Number ] ; * @@QWORD@@ = * @@QWORD@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; free_entry ( @@int64@@ , @@QWORD@@ ) ; } else { * @@QWORD@@ = Number L ; } } @@int64@@ = @@int64@@ ; } else { for ( @@QWORD@@ = @@QWORD@@ ; ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { if ( ! @@QWORD@@ [ Number ] ) return Number L ; if ( @@int64@@ == * ( _QWORD * ) @@QWORD@@ [ Number ] || ( * ( unsigned __int8 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@int64@@ + Number ) ) ( @@int64@@ , * ( _QWORD * ) @@QWORD@@ [ Number ] ) ) { break ; } } @@int64@@ = * ( _QWORD * ) @@QWORD@@ [ Number ] ; if ( @@char@@ ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = @@QWORD@@ [ Number ] ; free_entry ( @@int64@@ , @@QWORD@@ ) ; } @@int64@@ = @@int64@@ ; } return @@int64@@ ; }
unsigned __int64 __fastcall sha1_process_bytes ( char * @@char@@ , unsigned __int64 @@unsignedint64@@ , unsigned int * @@unsignedint@@ ) { unsigned __int64 @@unsignedint64@@ ; size_t @@sizet@@ ; void * @@void@@ ; size_t @@sizet@@ ; char * @@char@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; __int64 @@int64@@ ; size_t @@sizet@@ ; @@char@@ = @@char@@ ; @@sizet@@ = @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint@@ [ Number ] ; if ( ( _DWORD ) @@unsignedint64@@ ) { @@int64@@ = @@unsignedint@@ [ Number ] ; @@sizet@@ = Number - @@int64@@ ; if ( @@unsignedint64@@ <= Number - @@int64@@ ) @@sizet@@ = @@unsignedint64@@ ; @@sizet@@ = @@sizet@@ ; memcpy ( ( char * ) @@unsignedint@@ + @@int64@@ + Number , @@char@@ , @@sizet@@ ) ; @@unsignedint@@ [ Number ] += @@sizet@@ ; if ( @@unsignedint@@ [ Number ] > Number ) { sha1_process_block ( @@unsignedint@@ + Number , @@unsignedint@@ [ Number ] & Number , @@unsignedint@@ ) ; @@unsignedint@@ [ Number ] &= Number ; memcpy ( @@unsignedint@@ + Number , ( char * ) @@unsignedint@@ + ( ( @@int64@@ + @@sizet@@ ) & Number ) + Number , @@unsignedint@@ [ Number ] ) ; } @@char@@ = & @@char@@ [ @@sizet@@ ] ; @@unsignedint64@@ = @@sizet@@ ; @@sizet@@ = @@unsignedint64@@ - @@sizet@@ ; } if ( @@sizet@@ > Number ) { @@unsignedint64@@ = ( unsigned __int8 ) @@char@@ & Number ; if ( ( ( unsigned __int8 ) @@char@@ & Number ) != Number ) { while ( @@sizet@@ > Number ) { @@void@@ = memcpy ( @@unsignedint@@ + Number , @@char@@ , Number ) ; @@unsignedint64@@ = sha1_process_block ( @@void@@ , Number L , @@unsignedint@@ ) ; @@char@@ += Number ; @@sizet@@ -= Number L ; } } else { sha1_process_block ( @@char@@ , @@sizet@@ & Number , @@unsignedint@@ ) ; @@unsignedint64@@ = @@sizet@@ & Number ; @@char@@ += @@sizet@@ & Number ; @@sizet@@ &= Number ; } } if ( @@sizet@@ ) { @@sizet@@ = @@unsignedint@@ [ Number ] ; memcpy ( ( char * ) @@unsignedint@@ + @@sizet@@ + Number , @@char@@ , @@sizet@@ ) ; @@sizet@@ = @@sizet@@ + @@sizet@@ ; if ( @@sizet@@ > Number ) { sha1_process_block ( @@unsignedint@@ + Number , Number L , @@unsignedint@@ ) ; @@sizet@@ -= Number L ; memcpy ( @@unsignedint@@ + Number , @@unsignedint@@ + Number , @@sizet@@ ) ; } @@unsignedint64@@ = ( unsigned __int64 ) @@unsignedint@@ ; @@unsignedint@@ [ Number ] = @@sizet@@ ; } return @@unsignedint64@@ ; }
__int64 __fastcall hash_get_n_entries ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall i_ring_pop ( __int64 @@int64@@ ) { unsigned int @@unsignedint@@ ; if ( ( unsigned __int8 ) i_ring_empty ( @@int64@@ ) ) abort ( ) ; @@unsignedint@@ = * ( _DWORD * ) ( @@int64@@ + Number L * * ( unsigned int * ) ( @@int64@@ + Number ) ) ; * ( _DWORD * ) ( @@int64@@ + Number L * * ( unsigned int * ) ( @@int64@@ + Number ) ) = * ( _DWORD * ) ( @@int64@@ + Number ) ; if ( * ( _DWORD * ) ( @@int64@@ + Number ) == * ( _DWORD * ) ( @@int64@@ + Number ) ) * ( _BYTE * ) ( @@int64@@ + Number ) = Number ; else * ( _DWORD * ) ( @@int64@@ + Number ) = ( ( unsigned __int8 ) * ( _DWORD * ) ( @@int64@@ + Number ) + Number ) & Number ; return @@unsignedint@@ ; }
__int64 __fastcall transfer_entries ( __int64 @@int64@@ , __int64 @@int64@@ , char @@char@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 * @@int64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; for ( @@int64@@ = * ( __int64 * * ) @@int64@@ ; ( unsigned __int64 ) @@int64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ += Number ) { if ( * @@int64@@ ) { for ( @@QWORD@@ = ( _QWORD * ) @@int64@@ [ Number ] ; @@QWORD@@ ; @@QWORD@@ = @@QWORD@@ ) { @@int64@@ = * @@QWORD@@ ; @@int64@@ = * ( _QWORD * ) @@int64@@ ; @@QWORD@@ = ( _QWORD * ) ( @@int64@@ + Number * ( * ( __int64 ( __fastcall * * ) ( _QWORD , _QWORD ) ) ( @@int64@@ + Number ) ) ( * @@QWORD@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@QWORD@@ >= * ( _QWORD * ) ( @@int64@@ + Number ) ) abort ( ) ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; if ( * @@QWORD@@ ) { @@QWORD@@ [ Number ] = @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = @@QWORD@@ ; } else { * @@QWORD@@ = @@int64@@ ; ++ * ( _QWORD * ) ( @@int64@@ + Number ) ; free_entry ( @@int64@@ , @@QWORD@@ ) ; } } @@int64@@ = * @@int64@@ ; @@int64@@ [ Number ] = Number L ; if ( ! @@char@@ ) { @@int64@@ = * ( _QWORD * ) @@int64@@ ; @@QWORD@@ = ( _QWORD * ) ( @@int64@@ + Number * ( * ( __int64 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@int64@@ + Number ) ) ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@QWORD@@ >= * ( _QWORD * ) ( @@int64@@ + Number ) ) abort ( ) ; if ( * @@QWORD@@ ) { @@QWORD@@ = allocate_entry ( @@int64@@ ) ; if ( ! @@QWORD@@ ) return Number L ; * @@QWORD@@ = @@int64@@ ; @@QWORD@@ [ Number ] = @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = @@QWORD@@ ; } else { * @@QWORD@@ = @@int64@@ ; ++ * ( _QWORD * ) ( @@int64@@ + Number ) ; } * @@int64@@ = Number L ; -- * ( _QWORD * ) ( @@int64@@ + Number ) ; } } } return Number L ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
__int64 __fastcall openat_safer ( int @@int@@ , const char * @@constchar@@ , char @@char@@ , unsigned int @@unsignedint@@ ) { unsigned int @@unsignedint@@ ; unsigned int @@unsignedint@@ ; @@unsignedint@@ = Number ; if ( ( @@char@@ & Number ) != Number ) @@unsignedint@@ = @@unsignedint@@ ; @@unsignedint@@ = openat ( @@int@@ , @@constchar@@ , @@char@@ , @@unsignedint@@ ) ; return fd_safer ( @@unsignedint@@ ) ; }
_BOOL8 __fastcall hash_table_ok ( __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; @@int64@@ = Number L ; @@int64@@ = Number L ; for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { @@QWORD@@ = @@QWORD@@ ; ++ @@int64@@ ; ++ @@int64@@ ; while ( Number ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; if ( ! @@QWORD@@ ) break ; ++ @@int64@@ ; } } } return @@int64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) && @@int64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 __fastcall i_ring_empty ( __int64 @@int64@@ ) { return * ( unsigned __int8 * ) ( @@int64@@ + Number ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall hash_lookup ( __int64 * @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; @@int64@@ = * @@int64@@ ; @@QWORD@@ = ( _QWORD * ) ( @@int64@@ + Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@int64@@ [ Number ] ) ( @@int64@@ , @@int64@@ [ Number ] ) ) ; if ( ( unsigned __int64 ) @@QWORD@@ >= @@int64@@ [ Number ] ) abort ( ) ; if ( ! * @@QWORD@@ ) return Number L ; for ( @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { if ( @@int64@@ == * @@QWORD@@ || ( ( unsigned __int8 ( __fastcall * ) ( __int64 , _QWORD ) ) @@int64@@ [ Number ] ) ( @@int64@@ , * @@QWORD@@ ) ) { return * @@QWORD@@ ; } } return Number L ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
__int64 __fastcall i_ring_push ( __int64 @@int64@@ , int @@int@@ ) { int @@int@@ ; unsigned int @@unsignedint@@ ; @@int@@ = ( ( unsigned __int8 ) * ( _DWORD * ) ( @@int64@@ + Number ) + ( * ( _BYTE * ) ( @@int64@@ + Number ) ^ Number ) ) & Number ; @@unsignedint@@ = * ( _DWORD * ) ( @@int64@@ + Number L * ( ( ( unsigned __int8 ) * ( _DWORD * ) ( @@int64@@ + Number ) + ( * ( _BYTE * ) ( @@int64@@ + Number ) ^ Number ) ) & Number ) ) ; * ( _DWORD * ) ( @@int64@@ + Number L * ( ( ( unsigned __int8 ) * ( _DWORD * ) ( @@int64@@ + Number ) + ( * ( _BYTE * ) ( @@int64@@ + Number ) ^ Number ) ) & Number ) ) = @@int@@ ; * ( _DWORD * ) ( @@int64@@ + Number ) = @@int@@ ; if ( @@int@@ == * ( _DWORD * ) ( @@int64@@ + Number ) ) * ( _DWORD * ) ( @@int64@@ + Number ) = ( ( unsigned __int8 ) * ( _DWORD * ) ( @@int64@@ + Number ) + ( * ( _BYTE * ) ( @@int64@@ + Number ) ^ Number ) ) & Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = Number ; return @@unsignedint@@ ; }
__int64 __fastcall hash_get_first ( unsigned __int64 * @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; if ( ! @@unsignedint64@@ [ Number ] ) return Number L ; for ( @@unsignedint64@@ = * @@unsignedint64@@ ; ; @@unsignedint64@@ += Number L ) { if ( @@unsignedint64@@ >= @@unsignedint64@@ [ Number ] ) abort ( ) ; if ( * ( _QWORD * ) @@unsignedint64@@ ) break ; } return * ( _QWORD * ) @@unsignedint64@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ ) { return xmalloc ( @@int64@@ ) ; }
__int64 __fastcall open_safer ( const char * @@constchar@@ , char @@char@@ , unsigned int @@unsignedint@@ ) { unsigned int @@unsignedint@@ ; unsigned int @@unsignedint@@ ; @@unsignedint@@ = Number ; if ( ( @@char@@ & Number ) != Number ) @@unsignedint@@ = @@unsignedint@@ ; @@unsignedint@@ = open ( @@constchar@@ , @@char@@ , @@unsignedint@@ ) ; return fd_safer ( @@unsignedint@@ ) ; }
__int64 __fastcall hash_do_for_each ( __int64 @@int64@@ , unsigned __int8 ( __fastcall * @ @ VAR_728 @ @ unsignedint8 ( fastcall ) ( QWORD , int64 ) @ @ Hashprocessor ) ( _QWORD , __int64 ) , __int64 @@int64@@ ) { __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; @@int64@@ = Number L ; for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { for ( @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { if ( @ @ VAR_728 @ @ unsignedint8 ( fastcall ) ( QWORD , int64 ) @ @ Hashprocessor ( * @@QWORD@@ , @@int64@@ ) != Number ) return @@int64@@ ; ++ @@int64@@ ; } } } return @@int64@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
__int64 __fastcall select_plural ( __int64 @@int64@@ ) { return @@int64@@ ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
bool __fastcall is_prime ( unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = Number L ; @@unsignedint64@@ = Number L ; while ( @@unsignedint64@@ < @@unsignedint64@@ && @@unsignedint64@@ % @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@unsignedint64@@ += Number * @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint64@@ + Number ; } return @@unsignedint64@@ % @@unsignedint64@@ != Number ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
void * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
unsigned __int64 __fastcall raw_hasher ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { return rotr_sz ( @@int64@@ , Number ) % @@unsignedint64@@ ; }
__int64 __fastcall bsd_split_3 ( __int64 @@int64@@ , __int64 @@int64@@ , _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; if ( ! @@int64@@ ) return Number L ; * @@QWORD@@ = @@int64@@ ; for ( @@int64@@ = @@int64@@ - Number ; @@int64@@ && * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) != Number ; -- @@int64@@ ) { ; } if ( * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) != Number ) return Number L ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ + Number ; * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) = Number ; while ( * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) == Number || * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) == Number ) ++ @@int64@@ ; if ( * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) != Number ) return Number L ; for ( @@int64@@ = @@int64@@ + Number ; * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) == Number || * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) == Number ; ++ @@int64@@ ) { ; } * @@QWORD@@ = @@int64@@ + @@int64@@ ; return Number L ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall check_tuning ( __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( ( _UNKNOWN * ) @@int64@@ == & default_tuning ) return Number L ; if ( * ( float * ) ( @@int64@@ + Number ) > Number && ( float ) ( Number - Number ) > * ( float * ) ( @@int64@@ + Number ) && * ( float * ) ( @@int64@@ + Number ) > ( float ) ( Number + Number ) && * ( float * ) @@int64@@ >= Number && * ( float * ) ( @@int64@@ + Number ) > ( float ) ( * ( float * ) @@int64@@ + Number ) && * ( float * ) ( @@int64@@ + Number ) <= Number && * ( float * ) ( @@int64@@ + Number ) > ( float ) ( * ( float * ) @@int64@@ + Number ) ) { return Number L ; } * ( _QWORD * ) ( @@int64@@ + Number ) = & default_tuning ; return Number L ; }
void * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_210108 ; @@int648@@ [ Number ] = qword_210110 ; @@int648@@ [ Number ] = qword_210118 ; @@int648@@ [ Number ] = qword_210120 ; @@int648@@ [ Number ] = qword_210128 ; @@int648@@ [ Number ] = qword_210130 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_20A028 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall umaxtostr ( unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = @@int64@@ + Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = Number ; do { * ( _BYTE * ) -- @@int64@@ = @@unsignedint64@@ % Number + Number ; @@unsignedint64@@ /= Number ; } while ( @@unsignedint64@@ ) ; return @@int64@@ ; }
size_t * __fastcall hash_initialize ( __int64 @@int64@@ , void * @@void@@ , unsigned __int64 ( __fastcall * @ @ VAR_758 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ) ( __int64 a1 , unsigned __int64 a2 ) , bool ( __fastcall * @ @ VAR_760 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ) ( __int64 a1 , __int64 a2 ) , size_t @@sizet@@ ) { size_t * @@sizet@@ ; bool ( __fastcall * @ @ VAR_759 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ) ( __int64 , __int64 ) ; unsigned __int64 ( __fastcall * @ @ VAR_757 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ) ( __int64 , unsigned __int64 ) ; void * @@void@@ ; size_t * @@sizet@@ ; @@void@@ = @@void@@ ; @ @ VAR_757 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher = @ @ VAR_758 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ; @ @ VAR_759 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator = @ @ VAR_760 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ; if ( ! @ @ VAR_758 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ) @ @ VAR_757 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher = raw_hasher ; if ( ! @ @ VAR_760 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ) @ @ VAR_759 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator = raw_comparator ; @@sizet@@ = ( size_t * ) malloc ( Number ) ; if ( ! @@sizet@@ ) return Number L ; if ( ! @@void@@ ) @@void@@ = & default_tuning ; @@sizet@@ [ Number ] = ( size_t ) @@void@@ ; if ( ( unsigned __int8 ) check_tuning ( ( __int64 ) @@sizet@@ ) == Number && ( @@sizet@@ [ Number ] = compute_bucket_size ( @@int64@@ , ( __int64 ) @@void@@ ) ) != Number && ( * @@sizet@@ = ( size_t ) calloc ( @@sizet@@ [ Number ] , Number ) ) != Number ) { @@sizet@@ [ Number ] = Number * @@sizet@@ [ Number ] + * @@sizet@@ ; @@sizet@@ [ Number ] = Number L ; @@sizet@@ [ Number ] = Number L ; @@sizet@@ [ Number ] = ( size_t ) @ @ VAR_757 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ; @@sizet@@ [ Number ] = ( size_t ) @ @ VAR_759 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ; @@sizet@@ [ Number ] = @@sizet@@ ; @@sizet@@ [ Number ] = Number L ; @@sizet@@ = @@sizet@@ ; } else { free ( @@sizet@@ ) ; @@sizet@@ = Number L ; } return @@sizet@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ ) { return xmalloc ( @@int64@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@unsignedint64@@ , int @@int@@ ) { __int64 @@int64@@ ; if ( is_mul_ok ( @@int@@ , * @@unsignedint64@@ ) ) { * @@unsignedint64@@ *= @@int@@ ; @@int64@@ = Number L ; } else { * @@unsignedint64@@ = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
__int64 __fastcall rpl_fcntl ( int @@int@@ , int @@int@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ ) { int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; if ( @@int@@ != Number ) return ( unsigned int ) fcntl ( @@int@@ , @@int@@ , @@int64@@ ) ; @@int@@ = @@int64@@ ; if ( have_dupfd_cloexec_2895 < Number ) { @@int@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@int@@ , Number , @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ ) ; } else { @@int@@ = fcntl ( @@int@@ , Number , ( unsigned int ) @@int64@@ ) ; if ( @@int@@ < Number && * __errno_location ( ) == Number ) { @@int@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@int@@ , Number , @@int@@ , @@int@@ , @@int@@ , @@int@@ ) ; if ( @@int@@ < Number ) return ( unsigned int ) @@int@@ ; have_dupfd_cloexec_2895 = Number ; } else { have_dupfd_cloexec_2895 = Number ; } } if ( @@int@@ >= Number && have_dupfd_cloexec_2895 == Number ) { @@int@@ = fcntl ( @@int@@ , Number ) ; if ( @@int@@ < Number || fcntl ( @@int@@ , Number , @@int@@ | Number ) == Number ) { @@int@@ = * __errno_location ( ) ; close ( @@int@@ ) ; * __errno_location ( ) = @@int@@ ; @@int@@ = Number ; } } return ( unsigned int ) @@int@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
bool __fastcall is_zero_or_power_of_two ( __int64 @@int64@@ ) { return ( @@int64@@ & ( @@int64@@ - Number ) ) == Number ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_2070C8 ; @@int648@@ [ Number ] = qword_2070D0 ; @@int648@@ [ Number ] = qword_2070D8 ; @@int648@@ [ Number ] = qword_2070E0 ; @@int648@@ [ Number ] = qword_2070E8 ; @@int648@@ [ Number ] = qword_2070F0 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
__int64 __fastcall cycle_check ( __int64 @@int64@@ , _QWORD * @@QWORD@@ ) { if ( * ( _DWORD * ) ( @@int64@@ + Number ) != Number ) __assert_fail ( String , String , Number , String ) ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) && @@QWORD@@ [ Number ] == * ( _QWORD * ) @@int64@@ && * @@QWORD@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ) { return Number L ; } if ( is_zero_or_power_of_two ( ++ * ( _QWORD * ) ( @@int64@@ + Number ) ) ) { if ( ! * ( _QWORD * ) ( @@int64@@ + Number ) ) return Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = * @@QWORD@@ ; * ( _QWORD * ) @@int64@@ = @@QWORD@@ [ Number ] ; } return Number L ; }
__int64 __fastcall c_tolower ( int @@int@@ ) { __int64 @@int64@@ ; if ( @@int@@ <= Number || @@int@@ > Number ) @@int64@@ = ( unsigned int ) @@int@@ ; else @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; return @@int64@@ ; }
void * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * @@int64@@ ; void * @@void@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; void * @@void@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == ( __int64 * ) & slotvec0 ; if ( slotvec == ( __int64 * ) & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@void@@ = off_210028 ; * @@int64@@ = ( __int64 ) slotvec0 ; @@int64@@ [ Number ] = ( __int64 ) @@void@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = @@int64@@ [ Number * @@int@@ ] ; @@void@@ = ( void * ) @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@void@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = @@unsignedint64@@ + Number ; if ( @@void@@ != & slot0 ) free ( @@void@@ ) ; @@void@@ = ( void * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = ( __int64 ) @@void@@ ; quotearg_buffer_restyled ( ( __int64 ) @@void@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@void@@ ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
_QWORD * __fastcall randint_new ( __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) xmalloc ( Number L ) ; * @@QWORD@@ = @@int64@@ ; @@QWORD@@ [ Number ] = Number L ; @@QWORD@@ [ Number ] = @@QWORD@@ [ Number ] ; return @@QWORD@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
_BOOL8 __fastcall cycle_warning_required ( __int64 @@int64@@ , __int64 @@int64@@ ) { return ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number && ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) == Number || ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number && ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number && * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
unsigned __int64 __fastcall print_long_long ( unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ , _QWORD * @@QWORD@@ , int @@int@@ , int @@int@@ , int @@int@@ ) { _QWORD * @@QWORD@@ ; unsigned __int64 @@unsignedint64@@ ; char @@char@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = @@int@@ ; @@int@@ = @@int@@ ; for ( @@unsignedint64@@ = @@unsignedint64@@ ; ; -- @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ ; if ( @@unsignedint64@@ >= @@unsignedint64@@ ) break ; @@int@@ = ( @@unsignedint64@@ - Number ) * @@int@@ / @@unsignedint64@@ ; @@QWORD@@ = @@QWORD@@ ++ ; xprintf ( @@int@@ , @@int@@ + @@int@@ - @@int@@ , * @@QWORD@@ , @@int@@ + @@int@@ - @@int@@ , @@int@@ , @@int@@ , @@char@@ ) ; @@int@@ = @@int@@ ; } return @@unsignedint64@@ ; }
unsigned __int64 __fastcall randint_genmax ( __int64 * @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = * @@int64@@ ; @@unsignedint64@@ = @@int64@@ [ Number ] ; @@unsignedint64@@ = @@int64@@ [ Number ] ; @@unsignedint64@@ = @@unsignedint64@@ + Number ; while ( Number ) { if ( @@unsignedint64@@ < @@unsignedint64@@ ) { @@int64@@ = Number L ; @@unsignedint64@@ = @@unsignedint64@@ ; do { @@unsignedint64@@ = shift_left ( @@unsignedint64@@ ) + Number ; ++ @@int64@@ ; } while ( @@unsignedint64@@ < @@unsignedint64@@ ) ; randread ( @@int64@@ , @@char@@ , @@int64@@ ) ; @@int64@@ = Number L ; do { @@unsignedint64@@ = shift_left ( @@unsignedint64@@ ) + ( unsigned __int8 ) @@char@@ [ @@int64@@ ] ; @@unsignedint64@@ = shift_left ( @@unsignedint64@@ ) + Number ; ++ @@int64@@ ; } while ( @@unsignedint64@@ < @@unsignedint64@@ ) ; } if ( @@unsignedint64@@ == @@unsignedint64@@ ) { @@int64@@ [ Number ] = Number L ; @@int64@@ [ Number ] = @@int64@@ [ Number ] ; return @@unsignedint64@@ ; } @@unsignedint64@@ = ( @@unsignedint64@@ - @@unsignedint64@@ ) % @@unsignedint64@@ ; if ( @@unsignedint64@@ <= @@unsignedint64@@ - @@unsignedint64@@ ) break ; @@unsignedint64@@ %= @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint64@@ - Number ; } @@int64@@ [ Number ] = @@unsignedint64@@ / @@unsignedint64@@ ; @@int64@@ [ Number ] = ( @@unsignedint64@@ - @@unsignedint64@@ ) / @@unsignedint64@@ ; return @@unsignedint64@@ % @@unsignedint64@@ ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
__int64 __fastcall rpl_fcntl ( int @@int@@ , int @@int@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ ) { int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; if ( @@int@@ != Number ) return ( unsigned int ) fcntl ( @@int@@ , @@int@@ , @@int64@@ ) ; @@int@@ = @@int64@@ ; if ( have_dupfd_cloexec_2895 < Number ) { @@int@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@int@@ , Number , @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ ) ; } else { @@int@@ = fcntl ( @@int@@ , Number , ( unsigned int ) @@int64@@ ) ; if ( @@int@@ < Number && * __errno_location ( ) == Number ) { @@int@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@int@@ , Number , @@int@@ , @@int@@ , @@int@@ , @@int@@ ) ; if ( @@int@@ < Number ) return ( unsigned int ) @@int@@ ; have_dupfd_cloexec_2895 = Number ; } else { have_dupfd_cloexec_2895 = Number ; } } if ( @@int@@ >= Number && have_dupfd_cloexec_2895 == Number ) { @@int@@ = fcntl ( @@int@@ , Number ) ; if ( @@int@@ < Number || fcntl ( @@int@@ , Number , @@int@@ | Number ) == Number ) { @@int@@ = * __errno_location ( ) ; close ( @@int@@ ) ; * __errno_location ( ) = @@int@@ ; @@int@@ = Number ; } } return ( unsigned int ) @@int@@ ; }
__int64 __fastcall decode_format_string ( __int64 @@int64@@ ) { char * @@char@@ ; char * @@char@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@char@@ = ( char * ) @@int64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) __assert_fail ( String , String , Number , String ) ; while ( * @@char@@ ) { if ( n_specs_allocated <= ( unsigned __int64 ) n_specs ) spec = x2nrealloc ( spec , & n_specs_allocated , Number L ) ; if ( ( unsigned __int8 ) decode_one_format ( @@int64@@ , @@char@@ , & @@char@@ , Number * n_specs + spec ) != Number ) return Number L ; if ( @@char@@ == @@char@@ ) __assert_fail ( String , String , Number , String ) ; @@char@@ = @@char@@ ; ++ n_specs ; } return Number L ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_2060C8 ; @@int648@@ [ Number ] = qword_2060D0 ; @@int648@@ [ Number ] = qword_2060D8 ; @@int648@@ [ Number ] = qword_2060E0 ; @@int648@@ [ Number ] = qword_2060E8 ; @@int648@@ [ Number ] = qword_2060F0 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 dump ( ) { size_t @@sizet@@ ; bool @@bool@@ ; unsigned __int8 @@unsignedint8@@ ; int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; size_t @@sizet@@ ; unsigned __int64 @@unsignedint64@@ ; void * @@void4@@ [ Number ] ; @@void4@@ [ Number ] = ( void * ) __readfsqword ( Number ) ; @@bool@@ = Number ; @@unsignedint8@@ = Number ; @@void4@@ [ Number ] = ( void * ) xnmalloc ( Number L , bytes_per_block ) ; @@void4@@ [ Number ] = ( char * ) @@void4@@ [ Number ] + bytes_per_block ; @@unsignedint64@@ = n_bytes_to_skip ; if ( limit_bytes_to_format ) { while ( @@unsignedint64@@ < end_offset ) { @@sizet@@ = bytes_per_block ; if ( end_offset - @@unsignedint64@@ <= bytes_per_block ) @@sizet@@ = end_offset - @@unsignedint64@@ ; @@sizet@@ = @@sizet@@ ; @@unsignedint8@@ &= read_block ( @@sizet@@ , ( __int64 ) @@void4@@ [ @@bool@@ ] , & @@unsignedint64@@ ) ; if ( @@unsignedint64@@ < bytes_per_block ) goto LABEL_14 ; if ( @@unsignedint64@@ != bytes_per_block ) __assert_fail ( String , String , Number , String ) ; write_block ( @@unsignedint64@@ , @@unsignedint64@@ , @@void4@@ [ ! @@bool@@ ] , ( unsigned __int8 * ) @@void4@@ [ @@bool@@ ] ) ; @@unsignedint64@@ += @@unsignedint64@@ ; @@bool@@ = ! @@bool@@ ; } @@unsignedint64@@ = Number L ; } else { while ( Number ) { @@unsignedint8@@ &= read_block ( bytes_per_block , ( __int64 ) @@void4@@ [ @@bool@@ ] , & @@unsignedint64@@ ) ; if ( @@unsignedint64@@ < bytes_per_block ) break ; if ( @@unsignedint64@@ != bytes_per_block ) __assert_fail ( String , String , Number , String ) ; write_block ( @@unsignedint64@@ , @@unsignedint64@@ , @@void4@@ [ ! @@bool@@ ] , ( unsigned __int8 * ) @@void4@@ [ @@bool@@ ] ) ; @@unsignedint64@@ += @@unsignedint64@@ ; @@bool@@ = ! @@bool@@ ; } } LABEL_14 : if ( @@unsignedint64@@ ) { @@int@@ = get_lcm ( ) ; @@unsignedint64@@ = @@int@@ * ( ( @@int@@ + @@unsignedint64@@ - Number ) / @@int@@ ) ; memset ( ( char * ) @@void4@@ [ @@bool@@ ] + @@unsignedint64@@ , Number , @@unsignedint64@@ - @@unsignedint64@@ ) ; write_block ( @@unsignedint64@@ , @@unsignedint64@@ , @@void4@@ [ ! @@bool@@ ] , ( unsigned __int8 * ) @@void4@@ [ @@bool@@ ] ) ; @@unsignedint64@@ += @@unsignedint64@@ ; } format_address ( @@unsignedint64@@ , Number L ) ; if ( limit_bytes_to_format && @@unsignedint64@@ >= end_offset ) @@unsignedint8@@ = ( unsigned __int8 ) ( @@unsignedint8@@ & check_and_close ( Number ) ) != Number ; free ( @@void4@@ [ Number ] ) ; return @@unsignedint8@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_2060C8 ; @@int648@@ [ Number ] = qword_2060D0 ; @@int648@@ [ Number ] = qword_2060D8 ; @@int648@@ [ Number ] = qword_2060E0 ; @@int648@@ [ Number ] = qword_2060E8 ; @@int648@@ [ Number ] = qword_2060F0 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
FILE * __fastcall freopen_safer ( const char * @@constchar@@ , const char * @@constchar@@ , FILE * @@FILE@@ ) { int @@int@@ ; FILE * @@FILE@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; int @@int@@ ; @@char@@ = Number ; @@char@@ = Number ; @@char@@ = Number ; @@int@@ = fileno ( @@FILE@@ ) ; if ( @@int@@ != Number ) { if ( @@int@@ != Number ) { if ( ! @@int@@ ) goto LABEL_10 ; if ( dup2 ( Number , Number ) != Number ) @@char@@ = Number ; } if ( dup2 ( Number , Number ) != Number ) @@char@@ = Number ; } if ( dup2 ( Number , Number ) ) @@char@@ = Number ; LABEL_10 : if ( @@char@@ && ( unsigned __int8 ) protect_fd ( Number ) != Number ) { @@FILE@@ = Number L ; } else if ( @@char@@ && ( unsigned __int8 ) protect_fd ( Number ) != Number ) { @@FILE@@ = Number L ; } else if ( @@char@@ && ( unsigned __int8 ) protect_fd ( Number ) != Number ) { @@FILE@@ = Number L ; } else { @@FILE@@ = freopen ( @@constchar@@ , @@constchar@@ , @@FILE@@ ) ; } @@int@@ = * __errno_location ( ) ; if ( @@char@@ ) close ( Number ) ; if ( @@char@@ ) close ( Number ) ; if ( @@char@@ ) close ( Number ) ; if ( ! @@FILE@@ ) * __errno_location ( ) = @@int@@ ; return @@FILE@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
__int64 * __fastcall parse_line ( unsigned __int8 * @@unsignedint8@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { const unsigned __int16 * @@constunsignedint16@@ ; __int64 * @@int64@@ ; const unsigned __int16 * @@constunsignedint16@@ ; const unsigned __int16 * @@constunsignedint16@@ ; const unsigned __int16 * @@constunsignedint16@@ ; __int64 @@int64@@ ; unsigned __int8 * @@unsignedint8@@ ; unsigned __int8 * @@unsignedint8@@ ; unsigned __int8 * @@unsignedint8@@ ; * @@QWORD@@ = Number L ; * @@int64@@ = Number L ; while ( Number ) { @@constunsignedint16@@ = * __ctype_b_loc ( ) ; if ( ( @@constunsignedint16@@ [ ( unsigned __int8 ) to_uchar ( * @@unsignedint8@@ ) ] & Number ) == Number ) break ; ++ @@unsignedint8@@ ; } @@int64@@ = ( __int64 * ) * @@unsignedint8@@ ; if ( ( _BYTE ) @@int64@@ ) { @@int64@@ = ( __int64 * ) * @@unsignedint8@@ ; if ( ( _BYTE ) @@int64@@ != Number ) { @@unsignedint8@@ = @@unsignedint8@@ ; while ( Number ) { @@constunsignedint16@@ = * __ctype_b_loc ( ) ; if ( ( @@constunsignedint16@@ [ ( unsigned __int8 ) to_uchar ( * @@unsignedint8@@ ) ] & Number ) != Number || ! * @@unsignedint8@@ ) { break ; } ++ @@unsignedint8@@ ; } * @@QWORD@@ = xstrndup ( @@unsignedint8@@ , @@unsignedint8@@ - @@unsignedint8@@ ) ; @@int64@@ = ( __int64 * ) * @@unsignedint8@@ ; if ( ( _BYTE ) @@int64@@ ) { do { ++ @@unsignedint8@@ ; @@constunsignedint16@@ = * __ctype_b_loc ( ) ; } while ( ( @@constunsignedint16@@ [ ( unsigned __int8 ) to_uchar ( * @@unsignedint8@@ ) ] & Number ) != Number ) ; @@int64@@ = ( __int64 * ) * @@unsignedint8@@ ; if ( ( _BYTE ) @@int64@@ ) { @@int64@@ = ( __int64 * ) * @@unsignedint8@@ ; if ( ( _BYTE ) @@int64@@ != Number ) { @@unsignedint8@@ = @@unsignedint8@@ ; while ( * @@unsignedint8@@ && * @@unsignedint8@@ != Number ) ++ @@unsignedint8@@ ; for ( @@unsignedint8@@ = @@unsignedint8@@ - Number ; ; -- @@unsignedint8@@ ) { @@constunsignedint16@@ = * __ctype_b_loc ( ) ; if ( ( @@constunsignedint16@@ [ ( unsigned __int8 ) to_uchar ( * @@unsignedint8@@ ) ] & Number ) == Number ) break ; } @@int64@@ = xstrndup ( @@unsignedint8@@ , @@unsignedint8@@ + Number - @@unsignedint8@@ ) ; @@int64@@ = @@int64@@ ; * @@int64@@ = @@int64@@ ; } } } } } return @@int64@@ ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_212208 ; @@int648@@ [ Number ] = qword_212210 ; @@int648@@ [ Number ] = qword_212218 ; @@int648@@ [ Number ] = qword_212220 ; @@int648@@ [ Number ] = qword_212228 ; @@int648@@ [ Number ] = qword_212230 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 decimal_point_char ( ) { __int64 @@int64@@ ; char * @@char@@ ; @@char@@ = nl_langinfo ( Number ) ; if ( * @@char@@ ) @@int64@@ = ( unsigned __int8 ) * @@char@@ ; else @@int64@@ = Number L ; return @@int64@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall xsum_0 ( unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; if ( @@unsignedint64@@ + @@int64@@ < @@unsignedint64@@ ) @@int64@@ = Number ; else @@int64@@ = @@unsignedint64@@ + @@int64@@ ; return @@int64@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_20A0C8 ; @@int648@@ [ Number ] = qword_20A0D0 ; @@int648@@ [ Number ] = qword_20A0D8 ; @@int648@@ [ Number ] = qword_20A0E0 ; @@int648@@ [ Number ] = qword_20A0E8 ; @@int648@@ [ Number ] = qword_20A0F0 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
__int64 __fastcall dc_parse_file ( const char * @@constchar@@ ) { int * @@int@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; int * @@int@@ ; unsigned __int8 @@unsignedint8@@ ; if ( ! strcmp ( @@constchar@@ , String ) || freopen_safer ( @@constchar@@ , String , stdin ) ) { @@unsignedint8@@ = dc_parse_stream ( stdin , ( __int64 ) @@constchar@@ ) ; if ( fclose ( stdin ) ) { @@int64@@ = quote ( @@constchar@@ ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , format , @@int64@@ ) ; @@int64@@ = Number L ; } else { @@int64@@ = @@unsignedint8@@ ; } } else { @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , format , @@constchar@@ ) ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return xmalloc ( @@int64@@ , @@int64@@ , @@int64@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
unsigned __int64 __fastcall gcd ( unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; do { @@unsignedint64@@ = @@unsignedint64@@ % @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint64@@ ; } while ( @@unsignedint64@@ ) ; return @@unsignedint64@@ ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
unsigned __int64 __fastcall lcm ( unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { return @@unsignedint64@@ * ( @@unsignedint64@@ / gcd ( @@unsignedint64@@ , @@unsignedint64@@ ) ) ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
unsigned __int64 __fastcall print_s_short ( unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ , __int16 * @@int16@@ , int @@int@@ , int @@int@@ , int @@int@@ ) { __int16 * @@int16@@ ; unsigned __int64 @@unsignedint64@@ ; char @@char@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = @@int@@ ; @@int@@ = @@int@@ ; for ( @@unsignedint64@@ = @@unsignedint64@@ ; ; -- @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ ; if ( @@unsignedint64@@ >= @@unsignedint64@@ ) break ; @@int@@ = ( @@unsignedint64@@ - Number ) * @@int@@ / @@unsignedint64@@ ; @@int16@@ = @@int16@@ ++ ; xprintf ( @@int@@ , @@int@@ + @@int@@ - @@int@@ , * @@int16@@ , @@int@@ + @@int@@ - @@int@@ , @@int@@ , @@int@@ , @@char@@ ) ; @@int@@ = @@int@@ ; } return @@unsignedint64@@ ; }
__int64 __fastcall write_permuted_output ( unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , char @@char@@ ) { unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; size_t @@sizet@@ ; if ( @@int64@@ ) { for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@unsignedint64@@ ; ++ @@unsignedint64@@ ) { @@int64@@ = Number L * * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@int64@@ ) + @@int64@@ ; @@sizet@@ = * ( _QWORD * ) ( @@int64@@ + Number ) - * ( _QWORD * ) @@int64@@ ; if ( @@sizet@@ != fwrite_unlocked ( * ( const void * * ) @@int64@@ , Number , @@sizet@@ , stdout ) ) return Number ; } } else { for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@unsignedint64@@ ; ++ @@unsignedint64@@ ) { if ( printf ( String , * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@int64@@ ) + @@int64@@ , ( unsigned int ) @@char@@ ) < Number ) return Number ; } } return Number L ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
__int64 __fastcall hash_lookup ( __int64 * @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; @@int64@@ = * @@int64@@ ; @@QWORD@@ = ( _QWORD * ) ( @@int64@@ + Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@int64@@ [ Number ] ) ( @@int64@@ , @@int64@@ [ Number ] ) ) ; if ( ( unsigned __int64 ) @@QWORD@@ >= @@int64@@ [ Number ] ) abort ( ) ; if ( ! * @@QWORD@@ ) return Number L ; for ( @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { if ( @@int64@@ == * @@QWORD@@ || ( ( unsigned __int8 ( __fastcall * ) ( __int64 , _QWORD ) ) @@int64@@ [ Number ] ) ( @@int64@@ , * @@QWORD@@ ) ) { return * @@QWORD@@ ; } } return Number L ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
unsigned __int64 __fastcall print_long ( unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ , _QWORD * @@QWORD@@ , int @@int@@ , int @@int@@ , int @@int@@ ) { _QWORD * @@QWORD@@ ; unsigned __int64 @@unsignedint64@@ ; char @@char@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = @@int@@ ; @@int@@ = @@int@@ ; for ( @@unsignedint64@@ = @@unsignedint64@@ ; ; -- @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ ; if ( @@unsignedint64@@ >= @@unsignedint64@@ ) break ; @@int@@ = ( @@unsignedint64@@ - Number ) * @@int@@ / @@unsignedint64@@ ; @@QWORD@@ = @@QWORD@@ ++ ; xprintf ( @@int@@ , @@int@@ + @@int@@ - @@int@@ , * @@QWORD@@ , @@int@@ + @@int@@ - @@int@@ , @@int@@ , @@int@@ , @@char@@ ) ; @@int@@ = @@int@@ ; } return @@unsignedint64@@ ; }
unsigned __int64 * __fastcall randperm_new ( __int64 * @@int64@@ , unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; unsigned __int64 * @@unsignedint64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( ! @@unsignedint64@@ ) return Number L ; if ( @@unsignedint64@@ == Number ) { @@unsignedint64@@ = ( unsigned __int64 * ) xmalloc ( Number L ) ; * @@unsignedint64@@ = randint_choose ( @@int64@@ , @@unsignedint64@@ ) ; } else { @@int64@@ = xnmalloc ( @@unsignedint64@@ , Number L ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@unsignedint64@@ ; ++ @@unsignedint64@@ ) { * ( _QWORD * ) ( @@int64@@ + Number * @@unsignedint64@@ ) = @@unsignedint64@@ ; } for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@unsignedint64@@ ; ++ @@unsignedint64@@ ) { @@unsignedint64@@ = randint_choose ( @@int64@@ , @@unsignedint64@@ - @@unsignedint64@@ ) ; @@int64@@ = * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@int64@@ ) ; * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@int64@@ ) = * ( _QWORD * ) ( Number * ( @@unsignedint64@@ + @@unsignedint64@@ ) + @@int64@@ ) ; * ( _QWORD * ) ( @@int64@@ + Number * ( @@unsignedint64@@ + @@unsignedint64@@ ) ) = @@int64@@ ; } @@unsignedint64@@ = ( unsigned __int64 * ) xnrealloc ( @@int64@@ , @@unsignedint64@@ , Number L ) ; } return @@unsignedint64@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
__int64 __fastcall next_prime ( unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = @@unsignedint64@@ ; if ( @@unsignedint64@@ <= Number ) @@int64@@ = Number L ; for ( @@int64@@ = @@int64@@ | Number ; @@int64@@ != Number && ! is_prime ( @@int64@@ ) ; @@int64@@ += Number L ) { ; } return @@int64@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
int __fastcall dump_hexl_mode_trailer ( __int64 @@int64@@ , unsigned __int8 * @@unsignedint8@@ ) { unsigned __int8 * @@unsignedint8@@ ; unsigned __int8 @@unsignedint8@@ ; unsigned __int8 @@unsignedint8@@ ; fwrite_unlocked ( String , Number , Number , stdout ) ; while ( @@int64@@ ) { @@unsignedint8@@ = @@unsignedint8@@ ++ ; @@unsignedint8@@ = * @@unsignedint8@@ ; if ( ( ( * __ctype_b_loc ( ) ) [ @@unsignedint8@@ ] & Number ) != Number ) @@unsignedint8@@ = @@unsignedint8@@ ; else @@unsignedint8@@ = Number ; putchar_unlocked ( @@unsignedint8@@ ) ; -- @@int64@@ ; } return putchar_unlocked ( Number ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
unsigned __int64 __fastcall isaac_seed ( _DWORD * @@DWORD@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; isaac_seed_start ( @@DWORD@@ ) ; LODWORD ( @@int64@@ ) = getpid ( ) ; isaac_seed_data ( @@DWORD@@ , ( __int64 ) & @@int64@@ , Number ) ; LODWORD ( @@int64@@ ) = getppid ( ) ; isaac_seed_data ( @@DWORD@@ , ( __int64 ) & @@int64@@ , Number ) ; LODWORD ( @@int64@@ ) = getuid ( ) ; isaac_seed_data ( @@DWORD@@ , ( __int64 ) & @@int64@@ , Number ) ; LODWORD ( @@int64@@ ) = getgid ( ) ; isaac_seed_data ( @@DWORD@@ , ( __int64 ) & @@int64@@ , Number ) ; @@int64@@ = gethrxtime ( ) ; isaac_seed_data ( @@DWORD@@ , ( __int64 ) & @@int64@@ , Number ) ; isaac_seed_finish ( @@DWORD@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
void __fastcall hash_free ( __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) && * ( _QWORD * ) ( @@int64@@ + Number ) ) { for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { for ( @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@int64@@ + Number ) ) ( * @@QWORD@@ ) ; } } } } for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { for ( @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; @@QWORD@@ ; @@QWORD@@ = @@QWORD@@ ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; free ( @@QWORD@@ ) ; } } for ( @@QWORD@@ = * ( _QWORD * * ) ( @@int64@@ + Number ) ; @@QWORD@@ ; @@QWORD@@ = @@QWORD@@ ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; free ( @@QWORD@@ ) ; } free ( * ( void * * ) @@int64@@ ) ; free ( ( void * ) @@int64@@ ) ; }
int __fastcall format_address_paren ( unsigned __int64 @@unsignedint64@@ , char @@char@@ ) { int @@int@@ ; putchar_unlocked ( Number ) ; @@int@@ = format_address_std ( @@unsignedint64@@ , Number ) ; if ( @@char@@ ) @@int@@ = putchar_unlocked ( @@char@@ ) ; return @@int@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
_BOOL8 __fastcall read_block ( size_t @@sizet@@ , __int64 @@int64@@ , _QWORD * @@QWORD@@ ) { int * @@int@@ ; bool @@bool@@ ; bool @@bool@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; @@bool@@ = Number ; if ( ! @@sizet@@ || @@sizet@@ > bytes_per_block ) __assert_fail ( String , String , Number , String ) ; * @@QWORD@@ = Number L ; while ( in_stream ) { @@sizet@@ = @@sizet@@ - * @@QWORD@@ ; @@sizet@@ = fread_unlocked ( ( void * ) ( * @@QWORD@@ + @@int64@@ ) , Number , @@sizet@@ , in_stream ) ; * @@QWORD@@ += @@sizet@@ ; if ( @@sizet@@ == @@sizet@@ ) break ; @@int@@ = __errno_location ( ) ; @@bool@@ = ( @@bool@@ & ( unsigned __int8 ) check_and_close ( * @@int@@ ) ) != Number ; @@bool@@ = ( @@bool@@ & ( unsigned __int8 ) open_next_file ( ) ) != Number ; } return @@bool@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
__int64 __fastcall c_toupper ( int @@int@@ ) { __int64 @@int64@@ ; if ( @@int@@ <= Number || @@int@@ > Number ) @@int64@@ = ( unsigned int ) @@int@@ ; else @@int64@@ = ( unsigned int ) ( @@int@@ - Number ) ; return @@int64@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall rpl_fcntl ( int @@int@@ , int @@int@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ ) { int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; if ( @@int@@ != Number ) return ( unsigned int ) fcntl ( @@int@@ , @@int@@ , @@int64@@ ) ; @@int@@ = @@int64@@ ; if ( have_dupfd_cloexec_2895 < Number ) { @@int@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@int@@ , Number , @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ ) ; } else { @@int@@ = fcntl ( @@int@@ , Number , ( unsigned int ) @@int64@@ ) ; if ( @@int@@ < Number && * __errno_location ( ) == Number ) { @@int@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@int@@ , Number , @@int@@ , @@int@@ , @@int@@ , @@int@@ ) ; if ( @@int@@ < Number ) return ( unsigned int ) @@int@@ ; have_dupfd_cloexec_2895 = Number ; } else { have_dupfd_cloexec_2895 = Number ; } } if ( @@int@@ >= Number && have_dupfd_cloexec_2895 == Number ) { @@int@@ = fcntl ( @@int@@ , Number ) ; if ( @@int@@ < Number || fcntl ( @@int@@ , Number , @@int@@ | Number ) == Number ) { @@int@@ = * __errno_location ( ) ; close ( @@int@@ ) ; * __errno_location ( ) = @@int@@ ; @@int@@ = Number ; } } return ( unsigned int ) @@int@@ ; }
unsigned __int64 __fastcall print_s_char ( unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ , char * @@char@@ , int @@int@@ , int @@int@@ , int @@int@@ ) { char * @@char@@ ; unsigned __int64 @@unsignedint64@@ ; char @@char@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = @@int@@ ; @@int@@ = @@int@@ ; for ( @@unsignedint64@@ = @@unsignedint64@@ ; ; -- @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ ; if ( @@unsignedint64@@ >= @@unsignedint64@@ ) break ; @@int@@ = ( @@unsignedint64@@ - Number ) * @@int@@ / @@unsignedint64@@ ; @@char@@ = @@char@@ ++ ; xprintf ( @@int@@ , @@int@@ + @@int@@ - @@int@@ , * @@char@@ , @@int@@ + @@int@@ - @@int@@ , @@int@@ , @@int@@ , @@char@@ ) ; @@int@@ = @@int@@ ; } return @@unsignedint64@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@unsignedint64@@ , int @@int@@ ) { __int64 @@int64@@ ; if ( is_mul_ok ( @@int@@ , * @@unsignedint64@@ ) ) { * @@unsignedint64@@ *= @@int@@ ; @@int64@@ = Number L ; } else { * @@unsignedint64@@ = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall xnrealloc ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { if ( ! is_mul_ok ( @@unsignedint64@@ , @@unsignedint64@@ ) ) xalloc_die ( ) ; return xrealloc ( @@int64@@ , @@unsignedint64@@ * @@unsignedint64@@ ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ ) { return xmalloc ( @@int64@@ ) ; }
unsigned __int64 __fastcall print_short ( unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ , unsigned __int16 * @@unsignedint16@@ , int @@int@@ , int @@int@@ , int @@int@@ ) { unsigned __int16 * @@unsignedint16@@ ; unsigned __int64 @@unsignedint64@@ ; char @@char@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = @@int@@ ; @@int@@ = @@int@@ ; for ( @@unsignedint64@@ = @@unsignedint64@@ ; ; -- @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ ; if ( @@unsignedint64@@ >= @@unsignedint64@@ ) break ; @@int@@ = ( @@unsignedint64@@ - Number ) * @@int@@ / @@unsignedint64@@ ; @@unsignedint16@@ = @@unsignedint16@@ ++ ; xprintf ( @@int@@ , @@int@@ + @@int@@ - @@int@@ , * @@unsignedint16@@ , @@int@@ + @@int@@ - @@int@@ , @@int@@ , @@int@@ , @@char@@ ) ; @@int@@ = @@int@@ ; } return @@unsignedint64@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
unsigned __int64 __fastcall print_double ( unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ , _QWORD * @@QWORD@@ , int @@int@@ , int @@int@@ , int @@int@@ ) { _QWORD * @@QWORD@@ ; unsigned __int64 @@unsignedint64@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = @@int@@ ; @@int@@ = @@int@@ ; for ( @@unsignedint64@@ = @@unsignedint64@@ ; ; -- @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ ; if ( @@unsignedint64@@ >= @@unsignedint64@@ ) break ; @@int@@ = ( @@unsignedint64@@ - Number ) * @@int@@ / @@unsignedint64@@ ; @@QWORD@@ = @@QWORD@@ ++ ; xprintf ( @@int@@ , @@int@@ + @@int@@ - @@int@@ , * @@QWORD@@ , @@int@@ + @@int@@ - @@int@@ , @@int@@ , @@int@@ , * @@QWORD@@ ) ; @@int@@ = @@int@@ ; } return @@unsignedint64@@ ; }
__int64 __fastcall rpl_fcntl ( int @@int@@ , int @@int@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ ) { int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; if ( @@int@@ != Number ) return ( unsigned int ) fcntl ( @@int@@ , @@int@@ , @@int64@@ ) ; @@int@@ = @@int64@@ ; if ( have_dupfd_cloexec_2895 < Number ) { @@int@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@int@@ , Number , @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ ) ; } else { @@int@@ = fcntl ( @@int@@ , Number , ( unsigned int ) @@int64@@ ) ; if ( @@int@@ < Number && * __errno_location ( ) == Number ) { @@int@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@int@@ , Number , @@int@@ , @@int@@ , @@int@@ , @@int@@ ) ; if ( @@int@@ < Number ) return ( unsigned int ) @@int@@ ; have_dupfd_cloexec_2895 = Number ; } else { have_dupfd_cloexec_2895 = Number ; } } if ( @@int@@ >= Number && have_dupfd_cloexec_2895 == Number ) { @@int@@ = fcntl ( @@int@@ , Number ) ; if ( @@int@@ < Number || fcntl ( @@int@@ , Number , @@int@@ | Number ) == Number ) { @@int@@ = * __errno_location ( ) ; close ( @@int@@ ) ; * __errno_location ( ) = @@int@@ ; @@int@@ = Number ; } } return ( unsigned int ) @@int@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
int __fastcall write_block ( __int64 @@int64@@ , __int64 @@int64@@ , const void * @@constvoid@@ , unsigned __int8 * @@unsignedint8@@ ) { int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; if ( abbreviate_duplicate_blocks && first_5993 != Number && @@int64@@ == bytes_per_block && ! memcmp ( @@constvoid@@ , @@unsignedint8@@ , bytes_per_block ) ) { @@int@@ = ( unsigned __int8 ) prev_pair_equal_5994 ; if ( ! prev_pair_equal_5994 ) { @@int@@ = puts ( String ) ; prev_pair_equal_5994 = Number ; } } else { prev_pair_equal_5994 = Number ; for ( @@unsignedint64@@ = Number L ; ; ++ @@unsignedint64@@ ) { @@int@@ = n_specs ; if ( @@unsignedint64@@ >= n_specs ) break ; @@int@@ = width_bytes [ * ( unsigned int * ) ( spec + Number * @@unsignedint64@@ + Number ) ] ; @@int@@ = bytes_per_block / @@int@@ ; @@int@@ = ( bytes_per_block - @@int64@@ ) / @@int@@ ; if ( @@unsignedint64@@ ) printf ( String , address_pad_len , & locale ) ; else format_address ( @@int64@@ , Number L ) ; ( * ( void ( __fastcall * * ) ( _QWORD , _QWORD , unsigned __int8 * , unsigned __int64 , _QWORD , _QWORD ) ) ( spec + Number * @@unsignedint64@@ + Number ) ) ( @@int@@ , @@int@@ , @@unsignedint8@@ , spec + Number * @@unsignedint64@@ + Number , * ( unsigned int * ) ( spec + Number * @@unsignedint64@@ + Number ) , * ( unsigned int * ) ( spec + Number * @@unsignedint64@@ + Number ) ) ; if ( * ( _BYTE * ) ( spec + Number * @@unsignedint64@@ + Number ) ) { printf ( String , * ( _DWORD * ) ( spec + Number * @@unsignedint64@@ + Number ) * @@int@@ + @@int@@ * * ( _DWORD * ) ( spec + Number * @@unsignedint64@@ + Number ) / @@int@@ , & locale ) ; dump_hexl_mode_trailer ( @@int64@@ , @@unsignedint8@@ ) ; } putchar_unlocked ( Number ) ; } } first_5993 = Number ; return @@int@@ ; }
__int64 __fastcall xtime_make ( __int64 @@int64@@ , __int64 @@int64@@ ) { return Number * @@int64@@ + @@int64@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
__int64 gethrxtime ( ) { struct timespec @@structtimespec@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( clock_gettime ( Number , & @@structtimespec@@ ) ) gettime ( & @@structtimespec@@ ) ; return xtime_make ( @@structtimespec@@ . tv_sec , @@structtimespec@@ . tv_nsec ) ; }
int __fastcall hash_print_statistics ( __int64 @@int64@@ , FILE * @@FILE@@ ) { double @@double@@ ; double @@double@@ ; double @@double@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int64@@ = hash_get_n_entries ( @@int64@@ ) ; @@int64@@ = hash_get_n_buckets ( @@int64@@ ) ; @@int64@@ = hash_get_n_buckets_used ( @@int64@@ ) ; @@unsignedint64@@ = hash_get_max_bucket_length ( @@int64@@ ) ; fprintf ( @@FILE@@ , String , @@int64@@ ) ; fprintf ( @@FILE@@ , String , @@int64@@ ) ; if ( @@int64@@ < Number ) @@double@@ = ( double ) ( int ) ( @@int64@@ & Number | ( ( unsigned __int64 ) @@int64@@ >> Number ) ) + ( double ) ( int ) ( @@int64@@ & Number | ( ( unsigned __int64 ) @@int64@@ >> Number ) ) ; else @@double@@ = ( double ) ( int ) @@int64@@ ; @@double@@ = Number * @@double@@ ; if ( @@int64@@ < Number ) @@double@@ = ( double ) ( int ) ( @@int64@@ & Number | ( ( unsigned __int64 ) @@int64@@ >> Number ) ) + ( double ) ( int ) ( @@int64@@ & Number | ( ( unsigned __int64 ) @@int64@@ >> Number ) ) ; else @@double@@ = ( double ) ( int ) @@int64@@ ; fprintf ( @@FILE@@ , String , @@int64@@ , @@double@@ / @@double@@ ) ; return fprintf ( @@FILE@@ , String , @@unsignedint64@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 default_block_size ( ) { __int64 @@int64@@ ; if ( getenv ( String ) ) @@int64@@ = Number L ; else @@int64@@ = Number L ; return @@int64@@ ; }
__int64 __fastcall xnrealloc ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { if ( ! is_mul_ok ( @@unsignedint64@@ , @@unsignedint64@@ ) ) xalloc_die ( ) ; return xrealloc ( @@int64@@ , @@unsignedint64@@ * @@unsignedint64@@ ) ; }
void * __fastcall allocate_entry ( __int64 @@int64@@ ) { __int64 @@int64@@ ; if ( ! * ( _QWORD * ) ( @@int64@@ + Number ) ) return malloc ( Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; return ( void * ) @@int64@@ ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall free_entry ( __int64 @@int64@@ , _QWORD * @@QWORD@@ ) { __int64 @@int64@@ ; * @@QWORD@@ = Number L ; @@QWORD@@ [ Number ] = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@QWORD@@ ; return @@int64@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall freadseek ( FILE * @@FILE@@ , unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; unsigned __int64 @@unsignedint64@@ ; int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; size_t @@sizet@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( ! @@unsignedint64@@ ) return Number L ; for ( @@int64@@ = freadahead ( @@FILE@@ ) ; @@int64@@ ; -- @@int64@@ ) { if ( freadptr ( @@FILE@@ , & @@unsignedint64@@ ) && @@unsignedint64@@ ) { @@int64@@ = @@unsignedint64@@ ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) @@int64@@ = @@unsignedint64@@ ; @@int64@@ = @@int64@@ ; freadptrinc ( ( __int64 ) @@FILE@@ , @@int64@@ ) ; @@unsignedint64@@ -= @@int64@@ ; if ( ! @@unsignedint64@@ ) return Number L ; @@int64@@ -= @@int64@@ ; if ( ! @@int64@@ ) break ; } if ( fgetc ( @@FILE@@ ) == Number ) goto LABEL_24 ; if ( ! -- @@unsignedint64@@ ) return Number L ; } @@int@@ = fileno ( @@FILE@@ ) ; if ( @@int@@ >= Number && lseek ( @@int@@ , Number L , Number ) >= Number ) return rpl_fseeko ( @@FILE@@ , @@unsignedint64@@ , Number L ) ; while ( Number ) { @@sizet@@ = Number L ; if ( @@unsignedint64@@ <= Number ) @@sizet@@ = @@unsignedint64@@ ; @@sizet@@ = @@sizet@@ ; @@sizet@@ = fread ( @@char@@ , Number , @@sizet@@ , @@FILE@@ ) ; if ( @@sizet@@ > @@sizet@@ ) break ; @@unsignedint64@@ -= @@sizet@@ ; if ( ! @@unsignedint64@@ ) return Number L ; } LABEL_24 : if ( ferror ( @@FILE@@ ) ) @@int64@@ = Number ; else @@int64@@ = Number L ; return @@int64@@ ; }
size_t __fastcall rpl_vfprintf ( FILE * @@FILE@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { size_t @@sizet@@ ; size_t @@sizet@@ ; int @@int@@ ; size_t @@sizet@@ ; void * @@void@@ ; size_t @@sizet@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@sizet@@ = Number L ; @@void@@ = ( void * ) vasnprintf ( @@char@@ , & @@sizet@@ , @@int64@@ , @@int64@@ ) ; @@sizet@@ = @@sizet@@ ; if ( @@void@@ ) { @@sizet@@ = fwrite ( @@void@@ , Number , @@sizet@@ , @@FILE@@ ) ; if ( @@sizet@@ <= @@sizet@@ ) { if ( @@void@@ != @@char@@ ) free ( @@void@@ ) ; if ( @@sizet@@ <= Number ) { @@sizet@@ = @@sizet@@ ; } else { * __errno_location ( ) = Number ; fseterr ( @@FILE@@ ) ; @@sizet@@ = Number ; } } else { if ( @@void@@ != @@char@@ ) { @@int@@ = * __errno_location ( ) ; free ( @@void@@ ) ; * __errno_location ( ) = @@int@@ ; } @@sizet@@ = Number ; } } else { fseterr ( @@FILE@@ ) ; @@sizet@@ = Number ; } return @@sizet@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 __fastcall hash_find_entry ( __int64 @@int64@@ , __int64 @@int64@@ , _QWORD * @@QWORD@@ , char @@char@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; @@int64@@ = * ( _QWORD * ) @@int64@@ ; @@QWORD@@ = ( _QWORD * ) ( @@int64@@ + Number * ( * ( __int64 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@int64@@ + Number ) ) ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@QWORD@@ >= * ( _QWORD * ) ( @@int64@@ + Number ) ) abort ( ) ; * @@QWORD@@ = @@QWORD@@ ; if ( ! * @@QWORD@@ ) return Number L ; if ( @@int64@@ == * @@QWORD@@ || ( * ( unsigned __int8 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@int64@@ + Number ) ) ( @@int64@@ , * @@QWORD@@ ) ) { @@int64@@ = * @@QWORD@@ ; if ( @@char@@ ) { if ( @@QWORD@@ [ Number ] ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; @@int64@@ = @@QWORD@@ [ Number ] ; * @@QWORD@@ = * @@QWORD@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; free_entry ( @@int64@@ , @@QWORD@@ ) ; } else { * @@QWORD@@ = Number L ; } } @@int64@@ = @@int64@@ ; } else { for ( @@QWORD@@ = @@QWORD@@ ; ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { if ( ! @@QWORD@@ [ Number ] ) return Number L ; if ( @@int64@@ == * ( _QWORD * ) @@QWORD@@ [ Number ] || ( * ( unsigned __int8 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@int64@@ + Number ) ) ( @@int64@@ , * ( _QWORD * ) @@QWORD@@ [ Number ] ) ) { break ; } } @@int64@@ = * ( _QWORD * ) @@QWORD@@ [ Number ] ; if ( @@char@@ ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = @@QWORD@@ [ Number ] ; free_entry ( @@int64@@ , @@QWORD@@ ) ; } @@int64@@ = @@int64@@ ; } return @@int64@@ ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
size_t __fastcall writeline ( __int64 @@int64@@ , FILE * @@FILE@@ , int @@int@@ ) { size_t @@sizet@@ ; if ( @@int@@ == Number ) { @@sizet@@ = ( unsigned __int8 ) only_file_2 ^ Number ; if ( only_file_2 != Number ) return @@sizet@@ ; if ( ! only_file_1 ) return fwrite_unlocked ( * ( const void * * ) ( @@int64@@ + Number ) , Number , * ( _QWORD * ) ( @@int64@@ + Number ) , @@FILE@@ ) ; goto LABEL_13 ; } if ( @@int@@ == Number ) { @@sizet@@ = ( unsigned __int8 ) both ^ Number ; if ( both != Number ) return @@sizet@@ ; if ( only_file_1 ) fputs_unlocked ( delimiter , @@FILE@@ ) ; if ( ! only_file_2 ) return fwrite_unlocked ( * ( const void * * ) ( @@int64@@ + Number ) , Number , * ( _QWORD * ) ( @@int64@@ + Number ) , @@FILE@@ ) ; LABEL_13 : fputs_unlocked ( delimiter , @@FILE@@ ) ; return fwrite_unlocked ( * ( const void * * ) ( @@int64@@ + Number ) , Number , * ( _QWORD * ) ( @@int64@@ + Number ) , @@FILE@@ ) ; } if ( @@int@@ != Number ) return fwrite_unlocked ( * ( const void * * ) ( @@int64@@ + Number ) , Number , * ( _QWORD * ) ( @@int64@@ + Number ) , @@FILE@@ ) ; @@sizet@@ = ( unsigned __int8 ) only_file_1 ^ Number ; if ( only_file_1 == Number ) return fwrite_unlocked ( * ( const void * * ) ( @@int64@@ + Number ) , Number , * ( _QWORD * ) ( @@int64@@ + Number ) , @@FILE@@ ) ; return @@sizet@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
void * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
void * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
size_t __fastcall rpl_vprintf ( __int64 @@int64@@ , __int64 @@int64@@ ) { return rpl_vfprintf ( stdout , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
void * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall memcoll ( const char * @@constchar@@ , size_t @@sizet@@ , const char * @@constchar@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; const char * @@constchar@@ ; size_t @@sizet@@ ; const char * @@constchar@@ ; char @@char@@ ; char @@char@@ ; unsigned int @@unsignedint@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; @@constchar@@ = @@constchar@@ ; @@constchar@@ = @@constchar@@ ; if ( @@sizet@@ == @@int64@@ && ! memcmp ( @@constchar@@ , @@constchar@@ , @@sizet@@ ) ) { * __errno_location ( ) = Number ; @@unsignedint@@ = Number ; } else { @@char@@ = @@constchar@@ [ @@sizet@@ ] ; @@char@@ = @@constchar@@ [ @@int64@@ ] ; @@sizet@@ = @@sizet@@ + Number ; @@constchar@@ [ @@sizet@@ ] = Number ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ + Number ; @@constchar@@ [ @@int64@@ ] = Number ; while ( Number ) { * __errno_location ( ) = Number ; @@unsignedint@@ = strcoll ( @@constchar@@ , @@constchar@@ ) ; if ( @@unsignedint@@ || * __errno_location ( ) ) break ; @@sizet@@ = strlen ( @@constchar@@ ) + Number ; @@sizet@@ = strlen ( @@constchar@@ ) + Number ; @@constchar@@ += @@sizet@@ ; @@constchar@@ += @@sizet@@ ; @@sizet@@ -= @@sizet@@ ; @@int64@@ -= @@sizet@@ ; if ( ! @@sizet@@ ) { if ( @@int64@@ ) @@unsignedint@@ = Number ; break ; } if ( ! @@int64@@ ) { @@unsignedint@@ = Number ; break ; } } @@constchar@@ [ @@sizet@@ - Number ] = @@char@@ ; @@constchar@@ [ @@int64@@ - Number ] = @@char@@ ; } return @@unsignedint@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
unsigned __int64 __fastcall xstrtol_error ( unsigned int @@unsignedint@@ , int @@int@@ , char @@char@@ , __int64 @@int64@@ , __int64 @@int64@@ , int @@int@@ ) { char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; char @@char2@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@char@@ = ( char * ) & unk_FE08 ; if ( @@unsignedint@@ > Number ) { if ( @@unsignedint@@ != Number ) goto LABEL_6 ; @@char@@ = String ; } else if ( @@unsignedint@@ >= Number ) { @@char@@ = String ; } else { if ( @@unsignedint@@ != Number ) LABEL_6 : abort ( ) ; @@char@@ = String ; } if ( @@int@@ >= Number ) { @@char@@ = * ( char * * ) ( Number L * @@int@@ + @@int64@@ ) ; } else { @@char@@ = ( char * ) & unk_FE08 - @@int@@ ; @@char2@@ [ Number ] = @@char@@ ; @@char2@@ [ Number ] = Number ; @@char@@ = @@char2@@ ; } @@char@@ = gettext ( @@char@@ ) ; error ( @@int@@ , Number , @@char@@ , @@char@@ , @@char@@ , @@int64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
void * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
void * __fastcall initbuffer ( void * @@void@@ ) { return memset ( @@void@@ , Number , Number ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_20B128 ; @@int648@@ [ Number ] = qword_20B130 ; @@int648@@ [ Number ] = qword_20B138 ; @@int648@@ [ Number ] = qword_20B140 ; @@int648@@ [ Number ] = qword_20B148 ; @@int648@@ [ Number ] = qword_20B150 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_2080C8 ; @@int648@@ [ Number ] = qword_2080D0 ; @@int648@@ [ Number ] = qword_2080D8 ; @@int648@@ [ Number ] = qword_2080E0 ; @@int648@@ [ Number ] = qword_2080E8 ; @@int648@@ [ Number ] = qword_2080F0 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
__int64 __fastcall readlinebuffer ( __int64 @@int64@@ , __int64 @@int64@@ ) { return readlinebuffer_delim ( @@int64@@ , @@int64@@ , Number L ) ; }
_BYTE * __fastcall memchr2 ( const void * @@constvoid@@ , unsigned __int8 @@unsignedint8@@ , unsigned __int8 @@unsignedint8@@ , size_t @@sizet@@ ) { size_t @@sizet@@ ; _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; _QWORD * @@QWORD@@ longword ; __int64 @@int64@@ ; __int64 @@int64@@ longword ; __int64 @@int64@@ longword ; __int64 @@int64@@ longword ; @@sizet@@ = @@sizet@@ ; if ( @@unsignedint8@@ == @@unsignedint8@@ ) return memchr ( @@constvoid@@ , @@unsignedint8@@ , @@sizet@@ ) ; for ( @@BYTE@@ = @@constvoid@@ ; @@sizet@@ && ( ( unsigned __int8 ) @@BYTE@@ & Number ) != Number ; ++ @@BYTE@@ ) { if ( @@unsignedint8@@ == * @@BYTE@@ || @@unsignedint8@@ == * @@BYTE@@ ) { return @@BYTE@@ ; } -- @@sizet@@ ; } @@QWORD@@ longword = @@BYTE@@ ; @@int64@@ longword = ( @@unsignedint8@@ << Number ) | ( unsigned int ) @@unsignedint8@@ ; @@int64@@ = ( ( __int64 ) ( ( @@unsignedint8@@ << Number ) | ( unsigned int ) @@unsignedint8@@ ) << Number ) | ( @@unsignedint8@@ << Number ) | ( unsigned int ) @@unsignedint8@@ ; @@int64@@ longword = ( @@int64@@ << Number ) | @@int64@@ ; @@int64@@ longword = ( ( ( @@int64@@ longword << Number ) | @@int64@@ longword ) << Number ) | ( @@int64@@ longword << Number ) | @@int64@@ longword ; while ( @@sizet@@ > Number && ( ( ~ ( @@int64@@ longword ^ * @@QWORD@@ longword ) & ( ( @@int64@@ longword ^ * @@QWORD@@ longword ) - Number ) | ~ ( @@int64@@ longword ^ * @@QWORD@@ longword ) & ( ( @@int64@@ longword ^ * @@QWORD@@ longword ) - Number ) ) & Number ) == Number ) { ++ @@QWORD@@ longword ; @@sizet@@ -= Number L ; } @@BYTE@@ = @@QWORD@@ longword ; while ( @@sizet@@ ) { if ( @@unsignedint8@@ == * @@BYTE@@ || @@unsignedint8@@ == * @@BYTE@@ ) { return @@BYTE@@ ; } -- @@sizet@@ ; ++ @@BYTE@@ ; } return Number L ; }
unsigned __int64 print_stats ( ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; char * @@char@@ ; unsigned __int64 @@unsignedint64@@ ; double @@double@@ ; char * @@char@@ ; double @@double@@ ; char * @@char@@ ; __int64 @@int64@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = gethrxtime ( ) ; @@int64@@ = w_partial ; @@int64@@ = w_full ; @@int64@@ = r_partial ; @@int64@@ = r_full ; @@char@@ = gettext ( String ) ; fprintf ( stderr , @@char@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( r_truncate ) { @@int64@@ = r_truncate ; @@int64@@ = select_plural ( r_truncate ) ; @@char@@ = ngettext ( String , String , @@int64@@ ) ; fprintf ( stderr , @@char@@ , @@int64@@ ) ; } if ( ( status_flags & Number ) == Number ) { @@int64@@ = human_readable ( w_bytes , @@char@@ , Number L , Number L , Number L ) ; @@int64@@ = w_bytes ; @@int64@@ = select_plural ( w_bytes ) ; @@char@@ = ngettext ( String , String , @@int64@@ ) ; fprintf ( stderr , @@char@@ , @@int64@@ , @@int64@@ ) ; if ( @@int64@@ <= start_time ) { @@double@@ = Number ; @@char@@ = gettext ( String ) ; } else { @@unsignedint64@@ = @@int64@@ - start_time ; if ( @@int64@@ - start_time < Number ) @@double@@ = ( double ) ( int ) ( @@unsignedint64@@ & Number | ( @@unsignedint64@@ >> Number ) ) + ( double ) ( int ) ( @@unsignedint64@@ & Number | ( @@unsignedint64@@ >> Number ) ) ; else @@double@@ = ( double ) ( int ) @@unsignedint64@@ ; @@double@@ = @@double@@ / Number ; @@char@@ = ( char * ) human_readable ( w_bytes , @@char@@ , Number L , Number L , @@int64@@ - start_time ) ; } @@char@@ = gettext ( String ) ; fprintf ( stderr , @@char@@ , @@char@@ , @@double@@ ) ; } return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall fd_reopen ( int @@int@@ , const char * @@constchar@@ , int @@int@@ , unsigned int @@unsignedint@@ ) { int @@int@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; @@int@@ = open ( @@constchar@@ , @@int@@ , @@unsignedint@@ ) ; if ( @@int@@ == @@int@@ || @@int@@ < Number ) return ( unsigned int ) @@int@@ ; @@unsignedint@@ = dup2 ( @@int@@ , @@int@@ ) ; @@int@@ = * __errno_location ( ) ; close ( @@int@@ ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 * __fastcall readlinebuffer_delim ( __int64 * @@int64@@ , FILE * @@FILE@@ , char @@char@@ ) { _BYTE * @@BYTE@@ ; int @@int@@ ; __int64 @@int64@@ ; _BYTE * @@BYTE@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = @@int64@@ [ Number ] ; @@BYTE@@ = ( _BYTE * ) @@int64@@ ; @@int64@@ = * @@int64@@ + @@int64@@ ; if ( feof_unlocked ( @@FILE@@ ) ) return Number L ; while ( Number ) { @@int@@ = getc_unlocked ( @@FILE@@ ) ; if ( @@int@@ == Number ) break ; LABEL_9 : if ( @@BYTE@@ == ( _BYTE * ) @@int64@@ ) { @@int64@@ = * @@int64@@ ; @@int64@@ = x2realloc ( @@int64@@ , @@int64@@ ) ; @@BYTE@@ = ( _BYTE * ) ( @@int64@@ + @@int64@@ ) ; @@int64@@ [ Number ] = @@int64@@ ; @@int64@@ = * @@int64@@ + @@int64@@ ; } @@BYTE@@ = @@BYTE@@ ++ ; * @@BYTE@@ = @@int@@ ; if ( @@int@@ == @@char@@ ) goto LABEL_12 ; } if ( @@BYTE@@ == ( _BYTE * ) @@int64@@ || ferror_unlocked ( @@FILE@@ ) ) return Number L ; if ( @@char@@ != * ( @@BYTE@@ - Number ) ) { @@int@@ = @@char@@ ; goto LABEL_9 ; } LABEL_12 : @@int64@@ [ Number ] = ( __int64 ) & @@BYTE@@ [ - @@int64@@ ] ; return @@int64@@ ; }
int __cdecl __noreturn main ( int @@int@@ , const char * * @@constchar@@ , const char * * @@constchar@@ ) { __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; unsigned __int8 @@unsignedint8@@ ; set_program_name ( * @@constchar@@ , @@constchar@@ , @@constchar@@ ) ; setlocale ( Number , & shortopts ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; parse_long_options ( @@int@@ , ( _DWORD ) @@constchar@@ , ( unsigned int ) String , ( unsigned int ) String , ( _DWORD ) Version , ( unsigned int ) usage , String , Number L ) ; if ( getopt_long ( @@int@@ , ( char * const * ) @@constchar@@ , & shortopts , Number L , Number L ) != Number ) usage ( Number ) ; if ( @@int@@ - optind > Number ) { @@int64@@ = quote ( @@constchar@@ [ optind + Number ] ) ; @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ , @@int64@@ ) ; usage ( Number ) ; } if ( @@int@@ == optind ) @@constchar@@ = String ; else @@constchar@@ = @@constchar@@ [ optind ] ; @@unsignedint8@@ = tsort ( @@constchar@@ ) ; exit ( @@unsignedint8@@ ^ Number ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
int __fastcall argmatch_valid ( __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { char * @@char@@ ; __int64 @@int64@@ ; void * @@void@@ ; @@void@@ = Number L ; @@char@@ = gettext ( String ) ; fprintf ( stderr , @@char@@ ) ; for ( @@int64@@ = Number L ; * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; ++ @@int64@@ ) { if ( @@int64@@ && ! memcmp ( @@void@@ , ( const void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) , @@sizet@@ ) ) { fprintf ( stderr , String , * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) ) ; } else { fprintf ( stderr , String , * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) ) ; @@void@@ = ( void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) ; } } return putc_unlocked ( Number , stderr ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall copy_with_block ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 a3 , __int64 a4 , int @@int@@ , int @@int@@ ) { __int64 @@int64@@ ; int @@int@@ ; __int64 @@int64@@ ; int @@int@@ ; __int64 @@int64@@ ; _BYTE * @@BYTE@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@BYTE@@ = ( _BYTE * ) @@int64@@ ; @@int64@@ = @@int64@@ ; for ( @@int64@@ = @@int64@@ ; @@int64@@ ; -- @@int64@@ ) { if ( * @@BYTE@@ == newline_character ) { @@int64@@ = conversion_blocksize ; if ( col < ( unsigned __int64 ) conversion_blocksize ) { for ( @@unsignedint64@@ = col ; ; ++ @@unsignedint64@@ ) { @@int64@@ = conversion_blocksize ; if ( @@unsignedint64@@ >= conversion_blocksize ) break ; @@int@@ = ( int ) obuf ; @@int64@@ = oc ++ ; * ( ( _BYTE * ) obuf + @@int64@@ ) = space_character ; if ( oc >= output_blocksize ) write_output ( @@int64@@ , @@int64@@ , oc , @@int@@ , @@int@@ , @@int@@ ) ; } } col = Number L ; } else { if ( col == conversion_blocksize ) { ++ r_truncate ; } else if ( col < ( unsigned __int64 ) conversion_blocksize ) { @@int@@ = ( int ) obuf ; @@int64@@ = oc ++ ; * ( ( _BYTE * ) obuf + @@int64@@ ) = * @@BYTE@@ ; if ( oc >= output_blocksize ) write_output ( @@int64@@ , @@int64@@ , oc , @@int@@ , @@int@@ , @@int@@ ) ; } @@int64@@ = ++ col ; } ++ @@BYTE@@ ; } return @@int64@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
char * __fastcall group_number ( char * @@char@@ , size_t @@sizet@@ , unsigned __int8 * @@unsignedint8@@ , const char * @@constchar@@ ) { char * @@char@@ ; size_t @@sizet@@ ; char * @@char@@ ; unsigned __int8 @@unsignedint8@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@sizet@@ = Number ; @@sizet@@ = strlen ( @@constchar@@ ) ; @@sizet@@ = @@sizet@@ ; memcpy ( @@char@@ , @@char@@ , @@sizet@@ ) ; for ( @@char@@ = & @@char@@ [ @@sizet@@ ] ; ; memcpy ( @@char@@ , @@constchar@@ , @@sizet@@ ) ) { @@unsignedint8@@ = * @@unsignedint8@@ ; if ( * @@unsignedint8@@ ) { if ( @@unsignedint8@@ > Number ) @@sizet@@ = @@sizet@@ ; else @@sizet@@ = @@unsignedint8@@ ; @@sizet@@ = @@sizet@@ ; ++ @@unsignedint8@@ ; } if ( @@sizet@@ < @@sizet@@ ) @@sizet@@ = @@sizet@@ ; @@char@@ = & @@char@@ [ - @@sizet@@ ] ; @@sizet@@ -= @@sizet@@ ; memcpy ( @@char@@ , & @@char@@ [ @@sizet@@ ] , @@sizet@@ ) ; if ( ! @@sizet@@ ) break ; @@char@@ = & @@char@@ [ - @@sizet@@ ] ; } return @@char@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ ) { return xmalloc ( @@int64@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return xmalloc ( @@int64@@ , @@int64@@ , @@int64@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
unsigned __int8 * __fastcall translate_charset ( __int64 @@int64@@ ) { unsigned __int8 * @@unsignedint8@@ ; int @@int@@ ; for ( @@int@@ = Number ; @@int@@ <= Number ; ++ @@int@@ ) { @@unsignedint8@@ = trans_table ; trans_table [ @@int@@ ] = * ( _BYTE * ) ( trans_table [ @@int@@ ] + @@int64@@ ) ; } translation_needed = Number ; return @@unsignedint8@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
void * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
void * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
unsigned __int64 process_signals ( ) { int @@int@@ ; sigset_t @@sigsett@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; while ( interrupt_signal || info_signal_count ) { sigprocmask ( Number , & caught_signals , & @@sigsett@@ ) ; @@int@@ = interrupt_signal ; if ( info_signal_count ) -- info_signal_count ; sigprocmask ( Number , & @@sigsett@@ , Number L ) ; if ( @@int@@ ) cleanup ( ) ; print_stats ( ) ; if ( @@int@@ ) raise ( @@int@@ ) ; } return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
ssize_t __fastcall iread_fullblock ( int @@int@@ , char * @@char@@ , size_t @@sizet@@ ) { __int64 @@int64@@ ; ssize_t @@ssizet@@ ; @@int64@@ = Number L ; while ( @@sizet@@ ) { @@ssizet@@ = iread ( @@int@@ , @@char@@ , @@sizet@@ ) ; if ( @@ssizet@@ < Number ) return @@ssizet@@ ; if ( ! @@ssizet@@ ) break ; @@int64@@ += @@ssizet@@ ; @@char@@ += @@ssizet@@ ; @@sizet@@ -= @@ssizet@@ ; } return @@int64@@ ; }
__int64 __fastcall argmatch ( const char * @@constchar@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { __int64 @@int64@@ ; char @@char@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; size_t @@sizet@@ ; @@int64@@ = Number ; @@char@@ = Number ; @@sizet@@ = strlen ( @@constchar@@ ) ; for ( @@int64@@ = Number L ; * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; ++ @@int64@@ ) { if ( ! strncmp ( * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) , @@constchar@@ , @@sizet@@ ) ) { if ( @@sizet@@ == strlen ( * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) ) ) return @@int64@@ ; if ( @@int64@@ == Number ) { @@int64@@ = @@int64@@ ; } else if ( ! @@int64@@ || memcmp ( ( const void * ) ( @@sizet@@ * @@int64@@ + @@int64@@ ) , ( const void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) , @@sizet@@ ) ) { @@char@@ = Number ; } } } if ( @@char@@ ) @@int64@@ = Number ; else @@int64@@ = @@int64@@ ; return @@int64@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
unsigned __int64 __fastcall readtokens ( FILE * @@FILE@@ , __int64 @@int64@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ ) { void * * @@void@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; void * @@void@@ ; char @@char@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = ( __int64 * ) & @@char@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ + Number ; else @@int64@@ = Number L ; @@unsignedint64@@ = @@int64@@ ; @@int64@@ = xnmalloc ( @@int64@@ , Number L ) ; @@int64@@ = xnmalloc ( @@int64@@ , Number L ) ; @@unsignedint64@@ = Number L ; init_tokenbuffer ( @@int64@@ ) ; while ( Number ) { @@int64@@ = readtoken ( @@FILE@@ , @@int64@@ , @@unsignedint64@@ , @@int64@@ ) ; if ( @@unsignedint64@@ >= @@unsignedint64@@ ) { @@int64@@ = x2nrealloc ( @@int64@@ , & @@unsignedint64@@ , Number L ) ; @@int64@@ = xnrealloc ( @@int64@@ , @@unsignedint64@@ , Number L ) ; } if ( @@int64@@ == Number ) break ; @@void@@ = ( void * ) xnmalloc ( @@int64@@ + Number , Number L ) ; * ( _QWORD * ) ( @@int64@@ + Number * @@unsignedint64@@ ) = @@int64@@ ; @@void@@ = ( void * * ) ( Number * @@unsignedint64@@ + @@int64@@ ) ; * @@void@@ = memcpy ( @@void@@ , ( const void * ) @@int64@@ [ Number ] , @@int64@@ + Number ) ; ++ @@unsignedint64@@ ; } * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@int64@@ ) = Number L ; * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@int64@@ ) = Number L ; free ( ( void * ) @@int64@@ [ Number ] ) ; * @@QWORD@@ = @@int64@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@int64@@ ; return @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall swab_buffer ( __int64 @@int64@@ , _QWORD * @@QWORD@@ ) { __int64 @@int64@@ ; _BYTE * @@BYTE@@ ; __int64 @@int64@@ ; @@int64@@ = @@int64@@ ; if ( char_is_saved ) { @@int64@@ = @@int64@@ - Number ; * ( _BYTE * ) ( @@int64@@ - Number ) = saved_char ; ++ * @@QWORD@@ ; char_is_saved = Number ; } if ( ( * @@QWORD@@ & Number L ) != Number ) { saved_char = * ( _BYTE * ) ( -- * @@QWORD@@ + @@int64@@ ) ; char_is_saved = Number ; } @@BYTE@@ = ( _BYTE * ) ( * @@QWORD@@ + @@int64@@ ) ; for ( @@int64@@ = * @@QWORD@@ >> Number ; @@int64@@ ; -- @@int64@@ ) { * @@BYTE@@ = * ( @@BYTE@@ - Number ) ; @@BYTE@@ -= Number ; } return @@int64@@ + Number ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
unsigned __int64 __fastcall parse_tab_stops ( unsigned __int8 * @@unsignedint8@@ ) { const unsigned __int16 * @@constunsignedint16@@ ; char @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; char @@char@@ ; char @@char@@ ; unsigned __int64 @@unsignedint64@@ ; char * @@char@@ ; size_t @@sizet@@ ; void * @@void@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@char@@ = Number ; @@char@@ = Number ; while ( * @@unsignedint8@@ ) { if ( * @@unsignedint8@@ == Number || ( @@constunsignedint16@@ = * __ctype_b_loc ( ) , ( @@constunsignedint16@@ [ ( unsigned __int8 ) to_uchar ( * @@unsignedint8@@ ) ] & Number ) != Number ) ) { if ( @@char@@ ) add_tab_stop ( @@unsignedint64@@ ) ; @@char@@ = Number ; } else { if ( ( unsigned int ) ( ( char ) * @@unsignedint8@@ - Number ) > Number ) { @@int64@@ = quote ( @@unsignedint8@@ ) ; @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ , @@int64@@ ) ; @@char@@ = Number ; break ; } if ( @@char@@ != Number ) { @@unsignedint64@@ = Number L ; @@char@@ = Number ; @@char@@ = ( char * ) @@unsignedint8@@ ; } if ( @@unsignedint64@@ > Number || ( char ) * @@unsignedint8@@ - Number + Number * @@unsignedint64@@ < @@unsignedint64@@ ) { @@char@@ = Number ; } else { @@unsignedint64@@ = Number * @@unsignedint64@@ + ( char ) * @@unsignedint8@@ - Number ; @@char@@ = Number ; } if ( @@char@@ ) { @@sizet@@ = strspn ( @@char@@ , String ) ; @@void@@ = ( void * ) xstrndup ( @@char@@ , @@sizet@@ ) ; @@int64@@ = quote ( @@void@@ ) ; @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ , @@int64@@ ) ; free ( @@void@@ ) ; @@char@@ = Number ; @@unsignedint8@@ = ( unsigned __int8 * ) & @@char@@ [ @@sizet@@ - Number ] ; } } ++ @@unsignedint8@@ ; } if ( @@char@@ != Number ) exit ( Number ) ; if ( @@char@@ ) add_tab_stop ( @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall bad_cast ( __int64 @@int64@@ ) { return @@int64@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall copy_simple ( char * @@char@@ , size_t @@sizet@@ ) { size_t @@sizet@@ ; __int64 @@int64@@ ; char * @@char@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; __int64 @@int64@@ ; size_t @@sizet@@ ; do { @@sizet@@ = output_blocksize - oc ; if ( @@sizet@@ <= output_blocksize - oc ) @@sizet@@ = @@sizet@@ ; @@sizet@@ = @@sizet@@ ; @@int64@@ = ( __int64 ) @@char@@ ; @@char@@ = ( char * ) obuf + oc ; memcpy ( ( char * ) obuf + oc , @@char@@ , @@sizet@@ ) ; @@sizet@@ -= @@sizet@@ ; @@char@@ += @@sizet@@ ; oc += @@sizet@@ ; @@int64@@ = output_blocksize ; if ( oc >= output_blocksize ) @@int64@@ = write_output ( ( __int64 ) @@char@@ , @@int64@@ , oc , @@int@@ , @@int@@ , @@int@@ ) ; } while ( @@sizet@@ ) ; return @@int64@@ ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_207028 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
bool __fastcall hex_digits ( _BYTE * @@BYTE@@ ) { unsigned int @@unsignedint@@ ; for ( @@unsignedint@@ = Number ; @@unsignedint@@ < ( unsigned __int64 ) digest_hex_bytes ; ++ @@unsignedint@@ ) { if ( ( ( * __ctype_b_loc ( ) ) [ ( unsigned __int8 ) * @@BYTE@@ ] & Number ) == Number ) return Number ; ++ @@BYTE@@ ; } return * @@BYTE@@ == Number ; }
unsigned __int64 __fastcall set_fd_flags ( int @@int@@ , int @@int@@ , __int64 @@int64@@ , int @@int@@ , int @@int@@ , int @@int@@ ) { int @@int@@ ; int @@int@@ ; int @@int@@ ; __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; char @@char@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; struct stat @@structstat@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( ( @@int@@ & Number ) != Number ) { @@int@@ = rpl_fcntl ( @@int@@ , Number , @@int64@@ , @@int@@ , @@int@@ , @@int@@ ) ; @@unsignedint@@ = @@int@@ & Number | @@int@@ ; @@char@@ = Number ; if ( @@int@@ >= Number ) { if ( @@int@@ != @@unsignedint@@ ) { if ( ( @@unsignedint@@ & Number ) != Number ) { if ( ( unsigned int ) fstat ( @@int@@ , & @@structstat@@ ) ) { @@char@@ = Number ; } else if ( ( @@unsignedint@@ & Number ) != Number && ( @@structstat@@ . st_mode & Number ) != Number ) { * __errno_location ( ) = Number ; @@char@@ = Number ; } @@unsignedint@@ &= Number ; } if ( @@char@@ && @@int@@ != @@unsignedint@@ && ( unsigned int ) rpl_fcntl ( @@int@@ , Number , @@unsignedint@@ , @@int@@ , @@int@@ , @@int@@ ) == Number ) { @@char@@ = Number ; } } } else { @@char@@ = Number ; } if ( @@char@@ != Number ) { @@int64@@ = quote ( @@int64@@ ) ; @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ , @@int64@@ ) ; } } return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall human_options ( char * @@char@@ , int * @@int@@ , uintmax_t * @@uintmaxt@@ ) { unsigned int @@unsignedint@@ ; @@unsignedint@@ = humblock ( @@char@@ , @@uintmaxt@@ , @@int@@ ) ; if ( ! * @@uintmaxt@@ ) { * @@uintmaxt@@ = default_block_size ( ) ; @@unsignedint@@ = Number ; } return @@unsignedint@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_207128 ; @@int648@@ [ Number ] = qword_207130 ; @@int648@@ [ Number ] = qword_207138 ; @@int648@@ [ Number ] = qword_207140 ; @@int648@@ [ Number ] = qword_207148 ; @@int648@@ [ Number ] = qword_207150 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
__int64 __fastcall xstr_cd_iconv ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = str_cd_iconv ( @@int64@@ , @@int64@@ ) ; if ( ! @@int64@@ && * __errno_location ( ) == Number ) xalloc_die ( ) ; return @@int64@@ ; }
__int64 __fastcall parse_size ( __int64 @@int64@@ , _QWORD * @@QWORD@@ ) { __int64 @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 @@int644@@ [ Number ] ; @@int644@@ [ Number ] = __readfsqword ( Number ) ; @@int@@ = xstrtoumax ( @@int64@@ , Number L , Number L , @@int644@@ , String ) ; if ( @@int@@ ) { if ( @@int@@ == Number ) @@int@@ = Number ; else @@int@@ = Number ; * __errno_location ( ) = @@int@@ ; @@int64@@ = Number ; } else { * __errno_location ( ) = Number ; * @@QWORD@@ = @@int644@@ [ Number ] ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@unsignedint64@@ , int @@int@@ ) { __int64 @@int64@@ ; if ( is_mul_ok ( @@int@@ , * @@unsignedint64@@ ) ) { * @@unsignedint64@@ *= @@int@@ ; @@int64@@ = Number L ; } else { * @@unsignedint64@@ = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall digest_file ( const char * @@constchar@@ , __int64 a2 , __int64 @@int64@@ ) { int @@int@@ ; int @@int@@ ; int * @@int@@ ; int * @@int@@ ; bool @@bool@@ ; FILE * @@FILE@@ ; @@int@@ = strcmp ( @@constchar@@ , String ) ; @@bool@@ = @@int@@ == Number ; if ( @@int@@ ) { @@FILE@@ = ( FILE * ) fopen_safer ( @@constchar@@ , String ) ; if ( ! @@FILE@@ ) goto LABEL_4 ; @@int@@ = sha1_stream ( @@FILE@@ , @@int64@@ ) ; } else { have_read_stdin = Number ; @@FILE@@ = stdin ; @@int@@ = sha1_stream ( stdin , @@int64@@ ) ; } if ( ! @@int@@ ) { if ( @@bool@@ || ! fclose ( @@FILE@@ ) ) return Number L ; LABEL_4 : @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , String , @@constchar@@ ) ; return Number L ; } @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , String , @@constchar@@ ) ; if ( @@FILE@@ != stdin ) fclose ( @@FILE@@ ) ; return Number L ; }
__int64 __fastcall c_tolower ( int @@int@@ ) { __int64 @@int64@@ ; if ( @@int@@ <= Number || @@int@@ > Number ) @@int64@@ = ( unsigned int ) @@int@@ ; else @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; return @@int64@@ ; }
__int64 __fastcall dir_name ( __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = mdir_name ( @@int64@@ ) ; if ( ! @@int64@@ ) xalloc_die ( ) ; return @@int64@@ ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall file_name_concat ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = mfile_name_concat ( @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( ! @@int64@@ ) xalloc_die ( ) ; return @@int64@@ ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
_BYTE * __fastcall longest_relative_suffix ( _BYTE * @@BYTE@@ ) { while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; return @@BYTE@@ ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
void * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * @@int64@@ ; void * @@void@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; void * @@void@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == ( __int64 * ) & slotvec0 ; if ( slotvec == ( __int64 * ) & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@void@@ = off_20E038 ; * @@int64@@ = ( __int64 ) slotvec0 ; @@int64@@ [ Number ] = ( __int64 ) @@void@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = @@int64@@ [ Number * @@int@@ ] ; @@void@@ = ( void * ) @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@void@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = @@unsignedint64@@ + Number ; if ( @@void@@ != & slot0 ) free ( @@void@@ ) ; @@void@@ = ( void * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = ( __int64 ) @@void@@ ; quotearg_buffer_restyled ( ( __int64 ) @@void@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@void@@ ; }
char * __fastcall proper_name_utf8 ( const char * @@constchar@@ , __int64 @@int64@@ ) { char * @@char@@ ; char * @@char@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; char * @@char@@ ; char * @@char@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; size_t @@sizet@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; @@char@@ = ( char * ) locale_charset ( ) ; @@char@@ = Number L ; @@char@@ = Number L ; @@int64@@ = Number L ; if ( ( unsigned int ) c_strcasecmp ( @@char@@ , String ) ) { @@char@@ = ( char * ) xstr_iconv ( @@int64@@ , String , @@char@@ ) ; @@int64@@ = ( __int64 ) @@char@@ ; @@sizet@@ = strlen ( @@char@@ ) ; @@char@@ = ( char * ) xmalloc ( @@sizet@@ + Number ) ; memcpy ( @@char@@ , @@char@@ , @@sizet@@ ) ; memcpy ( & @@char@@ [ @@sizet@@ ] , String , Number ) ; @@char@@ = ( char * ) xstr_iconv ( @@int64@@ , String , @@char@@ ) ; free ( @@char@@ ) ; if ( @@char@@ ) { if ( strchr ( @@char@@ , Number ) ) { free ( @@char@@ ) ; } else { @@char@@ = @@char@@ ; @@int64@@ = ( __int64 ) @@char@@ ; } } } else { @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; } if ( @@int64@@ ) { @@char@@ = ( char * ) @@int64@@ ; } else if ( @@int64@@ ) { @@char@@ = ( char * ) @@int64@@ ; } else { @@char@@ = ( char * ) @@constchar@@ ; } @@char@@ = @@char@@ ; if ( ! strcmp ( @@char@@ , @@constchar@@ ) ) { if ( @@char@@ && @@char@@ != @@char@@ ) free ( @@char@@ ) ; if ( @@char@@ && @@char@@ != @@char@@ ) free ( @@char@@ ) ; @@char@@ = @@char@@ ; } else if ( ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@char@@ , ( __int64 ) @@constchar@@ ) || @@int64@@ && ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@char@@ , @@int64@@ ) || @@int64@@ && ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@char@@ , @@int64@@ ) ) { if ( @@char@@ ) free ( @@char@@ ) ; if ( @@char@@ ) free ( @@char@@ ) ; @@char@@ = @@char@@ ; } else { @@sizet@@ = strlen ( @@char@@ ) ; @@sizet@@ = strlen ( @@char@@ ) ; @@char@@ = ( char * ) xmalloc ( @@sizet@@ + @@sizet@@ + Number ) ; sprintf ( @@char@@ , String , @@char@@ , @@char@@ ) ; if ( @@char@@ ) free ( @@char@@ ) ; if ( @@char@@ ) free ( @@char@@ ) ; @@char@@ = @@char@@ ; } return @@char@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall sha1_stream ( FILE * @@FILE@@ , _DWORD * @@DWORD@@ ) { __int64 @@int64@@ ; char * @@char@@ ; size_t @@sizet@@ ; _DWORD @@DWORD@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@char@@ = ( char * ) malloc ( Number ) ; if ( ! @@char@@ ) return Number L ; sha1_init_ctx ( @@DWORD@@ ) ; LABEL_4 : @@int64@@ = Number L ; while ( Number ) { @@sizet@@ = fread_unlocked ( & @@char@@ [ @@int64@@ ] , Number , Number - @@int64@@ , @@FILE@@ ) ; @@int64@@ += @@sizet@@ ; if ( @@int64@@ == Number ) { sha1_process_block ( @@char@@ , String , @@DWORD@@ ) ; goto LABEL_4 ; } if ( ! @@sizet@@ ) break ; if ( feof_unlocked ( @@FILE@@ ) ) goto LABEL_12 ; } if ( ferror_unlocked ( @@FILE@@ ) ) { free ( @@char@@ ) ; return Number L ; } LABEL_12 : if ( @@int64@@ ) sha1_process_bytes ( @@char@@ , @@int64@@ , @@DWORD@@ ) ; sha1_finish_ctx ( @@DWORD@@ , @@DWORD@@ ) ; free ( @@char@@ ) ; return Number L ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_212028 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
_DWORD * __fastcall sha1_finish_ctx ( _DWORD * @@DWORD@@ , _DWORD * @@DWORD@@ ) { __int64 @@int64@@ ; unsigned int @@unsignedint@@ ; __int64 @@int64@@ ; @@unsignedint@@ = @@DWORD@@ [ Number ] ; if ( @@unsignedint@@ > Number ) @@int64@@ = Number L ; else @@int64@@ = Number L ; @@int64@@ = @@int64@@ ; @@DWORD@@ [ Number ] += @@unsignedint@@ ; if ( @@unsignedint@@ > @@DWORD@@ [ Number ] ) ++ @@DWORD@@ [ Number ] ; @@DWORD@@ [ @@int64@@ + Number ] = ( ( unsigned int ) ( * ( __int64 * ) ( @@DWORD@@ + Number ) >> Number ) >> Number ) & Number | ( ( unsigned int ) ( * ( __int64 * ) ( @@DWORD@@ + Number ) >> Number ) << Number ) & Number | ( ( unsigned int ) ( * ( __int64 * ) ( @@DWORD@@ + Number ) >> Number ) << Number ) | ( ( unsigned int ) ( * ( __int64 * ) ( @@DWORD@@ + Number ) >> Number ) >> Number ) ; @@DWORD@@ [ @@int64@@ + Number ] = ( ( unsigned int ) ( Number * @@DWORD@@ [ Number ] ) >> Number ) & Number | ( @@DWORD@@ [ Number ] << Number ) & Number | ( @@DWORD@@ [ Number ] << Number ) | ( ( unsigned int ) ( Number * @@DWORD@@ [ Number ] ) >> Number ) ; memcpy ( ( char * ) @@DWORD@@ + @@unsignedint@@ + Number , & fillbuf , Number * @@int64@@ - @@unsignedint@@ - Number ) ; sha1_process_block ( @@DWORD@@ + Number , Number * @@int64@@ , @@DWORD@@ ) ; return sha1_read_ctx ( @@DWORD@@ , @@DWORD@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return xmalloc ( @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall xsum ( unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; if ( @@unsignedint64@@ + @@int64@@ < @@unsignedint64@@ ) @@int64@@ = Number ; else @@int64@@ = @@unsignedint64@@ + @@int64@@ ; return @@int64@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_212128 ; @@int648@@ [ Number ] = qword_212130 ; @@int648@@ [ Number ] = qword_212138 ; @@int648@@ [ Number ] = qword_212140 ; @@int648@@ [ Number ] = qword_212148 ; @@int648@@ [ Number ] = qword_212150 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_207038 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
unsigned __int64 __fastcall xmax ( unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint64@@ ; if ( @@unsignedint64@@ >= @@unsignedint64@@ ) @@unsignedint64@@ = @@unsignedint64@@ ; return @@unsignedint64@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ ) { return xmalloc ( @@int64@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
__int64 decimal_point_char ( ) { __int64 @@int64@@ ; char * @@char@@ ; @@char@@ = nl_langinfo ( Number ) ; if ( * @@char@@ ) @@int64@@ = ( unsigned __int8 ) * @@char@@ ; else @@int64@@ = Number L ; return @@int64@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
void __fastcall freea ( unsigned __int64 @@unsignedint64@@ ) { _QWORD * @@QWORD@@ ; if ( @@unsignedint64@@ && * ( _DWORD * ) ( @@unsignedint64@@ - Number ) == Number ) { for ( @@QWORD@@ = & mmalloca_results [ @@unsignedint64@@ % Number ] ; * @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) ( * @@QWORD@@ - Number L ) ) { if ( @@unsignedint64@@ == * @@QWORD@@ ) { * @@QWORD@@ = * ( _QWORD * ) ( @@unsignedint64@@ - Number ) ; free ( ( void * ) ( @@unsignedint64@@ - Number ) ) ; return ; } } } }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
char * __fastcall areadlink ( const char * @@constchar@@ ) { signed __int64 @@signedint64@@ ; int @@int@@ ; char * @@char@@ ; __int64 @@int64@@ ; signed __int64 @@signedint64@@ ; size_t @@sizet@@ ; char * @@char@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@char@@ = @@char@@ ; @@int64@@ = Number L ; while ( Number ) { @@signedint64@@ = readlink ( @@constchar@@ , @@char@@ , @@int64@@ ) ; if ( @@signedint64@@ < Number && * __errno_location ( ) != Number ) { if ( @@char@@ != @@char@@ ) { @@int@@ = * __errno_location ( ) ; free ( @@char@@ ) ; * __errno_location ( ) = @@int@@ ; } return Number L ; } if ( @@int64@@ > ( unsigned __int64 ) @@signedint64@@ ) break ; if ( @@char@@ != @@char@@ ) free ( @@char@@ ) ; @@int64@@ *= Number L ; if ( @@int64@@ < Number ) { * __errno_location ( ) = Number ; return Number L ; } @@char@@ = ( char * ) malloc ( @@int64@@ ) ; if ( ! @@char@@ ) return Number L ; } @@signedint64@@ = @@signedint64@@ ; @@sizet@@ = @@signedint64@@ + Number ; @@char@@ [ @@signedint64@@ ] = Number ; if ( @@char@@ == @@char@@ ) { @@char@@ = ( char * ) malloc ( @@sizet@@ ) ; if ( ! @@char@@ ) return Number L ; memcpy ( @@char@@ , @@char@@ , @@sizet@@ ) ; } else if ( @@int64@@ > @@sizet@@ ) { @@char@@ = ( char * ) realloc ( @@char@@ , @@sizet@@ ) ; if ( @@char@@ ) @@char@@ = @@char@@ ; } return @@char@@ ; }
__int64 __fastcall xsum_0 ( unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; if ( @@unsignedint64@@ + @@int64@@ < @@unsignedint64@@ ) @@int64@@ = Number ; else @@int64@@ = @@unsignedint64@@ + @@int64@@ ; return @@int64@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
unsigned __int64 __fastcall mmalloca ( unsigned __int64 @@unsignedint64@@ ) { char * @@char@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@unsignedint64@@ + Number < @@unsignedint64@@ ) return Number L ; @@char@@ = ( char * ) malloc ( @@unsignedint64@@ + Number ) ; if ( ! @@char@@ ) return Number L ; @@unsignedint64@@ = ( unsigned __int64 ) ( @@char@@ + Number ) ; * ( _DWORD * ) ( @@unsignedint64@@ - Number ) = Number ; * ( _QWORD * ) ( @@unsignedint64@@ - Number ) = mmalloca_results [ @@unsignedint64@@ % Number ] ; mmalloca_results [ @@unsignedint64@@ % Number ] = @@unsignedint64@@ ; return @@unsignedint64@@ ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
size_t __fastcall mbslen ( const char * @@constchar@@ ) { __int64 @@int64@@ ; char @@char4@@ [ Number ] ; int @@int@@ ; char @@char@@ ; const char * @@constchar@@ ; __int64 @@int64@@ ; char @@char@@ ; int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( __ctype_get_mb_cur_max ( ) <= Number ) return strlen ( @@constchar@@ ) ; @@int64@@ = Number L ; @@constchar@@ = @@constchar@@ ; @@char4@@ [ Number ] = Number ; memset ( & @@int@@ , Number , Number ) ; for ( @@char@@ = Number ; ; @@char@@ = Number ) { mbuiter_multi_next_1 ( ( __int64 ) @@char4@@ ) ; if ( @@char@@ == Number && ! @@int@@ ) break ; ++ @@int64@@ ; @@constchar@@ += @@int64@@ ; } return @@int64@@ ; }
_DWORD * __fastcall sha1_read_ctx ( _DWORD * @@DWORD@@ , _DWORD * @@DWORD@@ ) { set_uint32 ( @@DWORD@@ , HIBYTE ( * @@DWORD@@ ) | ( * @@DWORD@@ >> Number ) & Number | ( * @@DWORD@@ << Number ) & Number | ( * @@DWORD@@ << Number ) ) ; set_uint32 ( @@DWORD@@ + Number , HIBYTE ( @@DWORD@@ [ Number ] ) | ( @@DWORD@@ [ Number ] >> Number ) & Number | ( @@DWORD@@ [ Number ] << Number ) & Number | ( @@DWORD@@ [ Number ] << Number ) ) ; set_uint32 ( @@DWORD@@ + Number , HIBYTE ( @@DWORD@@ [ Number ] ) | ( @@DWORD@@ [ Number ] >> Number ) & Number | ( @@DWORD@@ [ Number ] << Number ) & Number | ( @@DWORD@@ [ Number ] << Number ) ) ; set_uint32 ( @@DWORD@@ + Number , HIBYTE ( @@DWORD@@ [ Number ] ) | ( @@DWORD@@ [ Number ] >> Number ) & Number | ( @@DWORD@@ [ Number ] << Number ) & Number | ( @@DWORD@@ [ Number ] << Number ) ) ; set_uint32 ( @@DWORD@@ + Number , HIBYTE ( @@DWORD@@ [ Number ] ) | ( @@DWORD@@ [ Number ] >> Number ) & Number | ( @@DWORD@@ [ Number ] << Number ) & Number | ( @@DWORD@@ [ Number ] << Number ) ) ; return @@DWORD@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
unsigned __int64 __fastcall adjust_column ( unsigned __int64 @@unsignedint64@@ , char @@char@@ ) { unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint64@@ ; if ( count_bytes == Number ) return @@unsignedint64@@ + Number ; switch ( @@char@@ ) { case Number : if ( @@unsignedint64@@ ) @@unsignedint64@@ = @@unsignedint64@@ - Number ; break ; case Number : @@unsignedint64@@ = Number L ; break ; case Number : @@unsignedint64@@ = ( @@unsignedint64@@ & Number ) + Number ; break ; default : @@unsignedint64@@ = @@unsignedint64@@ + Number ; break ; } return @@unsignedint64@@ ; }
__int64 __fastcall c_toupper ( int @@int@@ ) { __int64 @@int64@@ ; if ( @@int@@ <= Number || @@int@@ > Number ) @@int64@@ = ( unsigned int ) @@int@@ ; else @@int64@@ = ( unsigned int ) ( @@int@@ - Number ) ; return @@int64@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_206028 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall strnlen1 ( const void * @@constvoid@@ , size_t @@sizet@@ ) { __int64 @@int64@@ ; _BYTE * @@BYTE@@ ; @@BYTE@@ = memchr ( @@constvoid@@ , Number , @@sizet@@ ) ; if ( @@BYTE@@ ) @@int64@@ = @@BYTE@@ - ( _BYTE * ) @@constvoid@@ + Number ; else @@int64@@ = @@sizet@@ ; return @@int64@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
int __cdecl __noreturn main ( int @@int@@ , const char * * @@constchar@@ , const char * * @@constchar@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; char * @@char@@ ; char @@char@@ ; const char * @@constchar@@ ; bool @@bool@@ ; char @@char@@ ; unsigned __int8 @@unsignedint8@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; const char * * @@constchar@@ ; char * * @@char@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@char@@ = Number ; set_program_name ( * @@constchar@@ , @@constchar@@ , @@constchar@@ ) ; setlocale ( Number , & locale ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; initialize_exit_failure ( Number ) ; atexit ( close_stdout ) ; while ( Number ) { @@int@@ = getopt_long ( @@int@@ , ( char * const * ) @@constchar@@ , String , & longopts , Number L ) ; if ( @@int@@ == Number ) break ; if ( @@int@@ == Number ) usage ( Number ) ; if ( @@int@@ != Number ) { if ( @@int@@ != Number ) usage ( Number ) ; version_etc ( ( _DWORD ) stdout , ( unsigned int ) String , ( unsigned int ) String , ( _DWORD ) Version , ( unsigned int ) String , ( unsigned int ) String , Number ) ; exit ( Number ) ; } @@char@@ = Number ; } if ( @@int@@ > optind ) { @@int@@ = Number ; for ( @@int@@ = optind ; @@int@@ < @@int@@ ; ++ @@int@@ ) { @@unsignedint8@@ = Number ; if ( ! strchr ( @@constchar@@ [ @@int@@ ] , Number ) ) { for ( @@char@@ = ( char * * ) environ ; * @@char@@ ; ++ @@char@@ ) { @@char@@ = * @@char@@ ; @@constchar@@ = @@constchar@@ [ @@int@@ ] ; do { if ( * @@char@@ ) { if ( * @@constchar@@ ) { @@char@@ = @@char@@ ++ ; @@char@@ = * @@char@@ ; @@constchar@@ = @@constchar@@ ++ ; if ( @@char@@ == * @@constchar@@ ) continue ; } } goto LABEL_31 ; } while ( * @@char@@ != Number || * @@constchar@@ ) ; if ( @@char@@ ) @@int64@@ = Number L ; else @@int64@@ = Number L ; printf ( String , @@char@@ + Number , @@int64@@ ) ; @@unsignedint8@@ = Number ; LABEL_31 : ; } @@int@@ += @@unsignedint8@@ ; } } @@bool@@ = @@int@@ == @@int@@ - optind ; } else { for ( @@constchar@@ = ( const char * * ) environ ; * @@constchar@@ ; ++ @@constchar@@ ) { if ( @@char@@ ) @@int64@@ = Number L ; else @@int64@@ = Number L ; printf ( String , * @@constchar@@ , @@int64@@ ) ; } @@bool@@ = Number ; } exit ( ! @@bool@@ ) ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_20C028 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall xstr_iconv ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = str_iconv ( @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( ! @@int64@@ && * __errno_location ( ) == Number ) xalloc_die ( ) ; return @@int64@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_207028 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall randint_get_source ( __int64 @@int64@@ ) { return * ( _QWORD * ) @@int64@@ ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
void __fastcall randint_free ( void * @@void@@ ) { memset ( @@void@@ , Number , Number ) ; free ( @@void@@ ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
unsigned __int64 __fastcall randint_choose ( __int64 * @@int64@@ , __int64 @@int64@@ ) { return randint_genmax ( @@int64@@ , @@int64@@ - Number ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return xmalloc ( @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall ceil_lg ( __int64 @@int64@@ ) { unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; @@int64@@ = Number L ; for ( @@unsignedint64@@ = @@int64@@ - Number ; @@unsignedint64@@ ; @@unsignedint64@@ >>= Number ) { ++ @@int64@@ ; } return @@int64@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
int __cdecl __noreturn main ( int @@int@@ , const char * * @@constchar@@ , const char * * @@constchar@@ ) { __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; char @@char@@ ; int @@int@@ ; int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; char @@char2@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@unsignedint64@@ = Number L ; set_program_name ( * @@constchar@@ , @@constchar@@ , @@constchar@@ ) ; setlocale ( Number , & locale ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; have_read_stdin = Number ; count_bytes = Number ; break_spaces = Number ; while ( Number ) { @@int@@ = getopt_long ( @@int@@ , ( char * const * ) @@constchar@@ , String , & longopts , Number L ) ; if ( @@int@@ == Number ) { if ( @@int@@ == optind ) { @@char@@ = fold_file ( String , @@unsignedint64@@ ) ; } else { @@char@@ = Number ; for ( @@int@@ = optind ; @@int@@ < @@int@@ ; ++ @@int@@ ) @@char@@ = ( unsigned __int8 ) ( @@char@@ & fold_file ( @@constchar@@ [ @@int@@ ] , @@unsignedint64@@ ) ) != Number ; } if ( have_read_stdin ) { if ( fclose ( stdin ) == Number ) { @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , String ) ; } } exit ( ( unsigned __int8 ) @@char@@ ^ Number ) ; } if ( @@int@@ > Number ) { switch ( @@int@@ ) { case String : break_spaces = Number ; break ; case String : goto LABEL_15 ; case String : count_bytes = Number ; break ; default : goto LABEL_22 ; } } else { if ( @@int@@ < Number ) { if ( @@int@@ == Number ) { version_etc ( ( _DWORD ) stdout , ( unsigned int ) String , ( unsigned int ) String , ( _DWORD ) Version , ( unsigned int ) String , Number , ( char ) @@constchar@@ ) ; exit ( Number ) ; } if ( @@int@@ == Number ) usage ( Number ) ; LABEL_22 : usage ( Number ) ; } if ( optarg ) { -- optarg ; } else { @@char2@@ [ Number ] = @@int@@ ; @@char2@@ [ Number ] = Number ; optarg = ( __int64 ) @@char2@@ ; } LABEL_15 : if ( ( unsigned int ) xstrtoul ( optarg , Number L , Number L , & @@unsignedint64@@ , & locale ) || ! @@unsignedint64@@ || @@unsignedint64@@ > Number ) { @@int64@@ = quote ( optarg ) ; @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ , @@int64@@ ) ; } @@unsignedint64@@ = @@unsignedint64@@ ; } } }
_QWORD * __fastcall simple_new ( __int64 @@int64@@ , __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) xmalloc ( Number L ) ; * @@QWORD@@ = @@int64@@ ; @@QWORD@@ [ Number ] = randread_error ; @@QWORD@@ [ Number ] = @@int64@@ ; return @@QWORD@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
size_t __fastcall readsource ( __int64 @@int64@@ , char * @@char@@ , size_t @@sizet@@ ) { size_t @@sizet@@ ; int @@int@@ ; int @@int@@ ; size_t @@sizet@@ ; while ( Number ) { @@sizet@@ = fread_unlocked ( @@char@@ , Number , @@sizet@@ , * ( FILE * * ) @@int64@@ ) ; @@int@@ = * __errno_location ( ) ; @@char@@ += @@sizet@@ ; @@sizet@@ = @@sizet@@ ; @@sizet@@ -= @@sizet@@ ; if ( ! @@sizet@@ ) break ; if ( ferror_unlocked ( * ( FILE * * ) @@int64@@ ) ) @@int@@ = @@int@@ ; else @@int@@ = Number ; * __errno_location ( ) = @@int@@ ; ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@int64@@ + Number ) ) ( * ( _QWORD * ) ( @@int64@@ + Number ) ) ; } return @@sizet@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall queue_directory ( __int64 @@int64@@ , __int64 @@int64@@ , char @@char@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = xmalloc ( Number L ) ; if ( @@int64@@ ) @@int64@@ = xstrdup ( @@int64@@ ) ; else @@int64@@ = Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; if ( @@int64@@ ) @@int64@@ = xstrdup ( @@int64@@ ) ; else @@int64@@ = Number L ; * ( _QWORD * ) @@int64@@ = @@int64@@ ; * ( _BYTE * ) ( @@int64@@ + Number ) = @@char@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = pending_dirs ; @@int64@@ = @@int64@@ ; pending_dirs = @@int64@@ ; return @@int64@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return xmalloc ( @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
size_t __fastcall randread ( _QWORD * @@QWORD@@ , char * @@char@@ , size_t @@sizet@@ ) { size_t @@sizet@@ ; if ( * @@QWORD@@ ) @@sizet@@ = readsource ( ( __int64 ) @@QWORD@@ , @@char@@ , @@sizet@@ ) ; else @@sizet@@ = ( size_t ) readisaac ( @@QWORD@@ + Number , @@char@@ , @@sizet@@ ) ; return @@sizet@@ ; }
_BOOL8 __fastcall input_numbers_option_used ( __int64 @@int64@@ , __int64 @@int64@@ ) { return @@int64@@ != Number || @@int64@@ ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@unsignedint64@@ , int @@int@@ ) { __int64 @@int64@@ ; if ( is_mul_ok ( @@int@@ , * @@unsignedint64@@ ) ) { * @@unsignedint64@@ *= @@int@@ ; @@int64@@ = Number L ; } else { * @@unsignedint64@@ = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall extract_dirs_from_files ( __int64 @@int64@@ , char @@char@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 * @@int64@@ ; void * @@void@@ ; if ( @@int64@@ && active_dir_set ) queue_directory ( Number L , @@int64@@ , Number ) ; @@int64@@ = cwd_n_used ; while ( @@int64@@ -- ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) sorted_file + @@int64@@ ) ; if ( is_directory ( ( __int64 ) @@int64@@ ) && ( ! @@int64@@ || ! basename_is_dot_or_dotdot ( * @@int64@@ ) ) ) { if ( @@int64@@ && * ( _BYTE * ) * @@int64@@ != Number ) { @@void@@ = ( void * ) file_name_concat ( @@int64@@ , * @@int64@@ , Number L ) ; queue_directory ( ( __int64 ) @@void@@ , @@int64@@ [ Number ] , @@char@@ ) ; free ( @@void@@ ) ; } else { queue_directory ( * @@int64@@ , @@int64@@ [ Number ] , @@char@@ ) ; } if ( * ( ( _DWORD * ) @@int64@@ + Number ) == Number ) free ( ( void * ) * @@int64@@ ) ; } } @@unsignedint64@@ = Number L ; @@int64@@ = Number L ; while ( @@unsignedint64@@ < cwd_n_used ) { @@int64@@ = * ( ( _QWORD * ) sorted_file + @@unsignedint64@@ ) ; * ( ( _QWORD * ) sorted_file + @@int64@@ ) = @@int64@@ ; @@int64@@ += * ( _DWORD * ) ( @@int64@@ + Number ) != Number ; ++ @@unsignedint64@@ ; } @@int64@@ = @@int64@@ ; cwd_n_used = @@int64@@ ; return @@int64@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_20C0C8 ; @@int648@@ [ Number ] = qword_20C0D0 ; @@int648@@ [ Number ] = qword_20C0D8 ; @@int648@@ [ Number ] = qword_20C0E0 ; @@int648@@ [ Number ] = qword_20C0E8 ; @@int648@@ [ Number ] = qword_20C0F0 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
char * __fastcall input_from_argv ( __int64 @@int64@@ , int @@int@@ , char @@char@@ ) { char * @@char@@ ; int @@int@@ ; int @@int@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; @@int64@@ = @@int@@ ; for ( @@int@@ = Number ; @@int@@ < @@int@@ ; ++ @@int@@ ) @@int64@@ += strlen ( * ( const char * * ) ( Number L * @@int@@ + @@int64@@ ) ) ; @@char@@ = ( char * ) xmalloc ( @@int64@@ ) ; for ( @@int@@ = Number ; @@int@@ < @@int@@ ; ++ @@int@@ ) { @@char@@ = stpcpy ( @@char@@ , * ( const char * * ) ( Number L * @@int@@ + @@int64@@ ) ) ; * ( _QWORD * ) ( @@int64@@ + Number L * @@int@@ ) = @@char@@ ; @@char@@ = @@char@@ + Number ; * @@char@@ = @@char@@ ; } @@char@@ = @@char@@ ; * ( _QWORD * ) ( @@int64@@ + Number L * @@int@@ ) = @@char@@ ; return @@char@@ ; }
unsigned __int64 __fastcall read_input ( FILE * @@FILE@@ , char @@char@@ , __int64 * * @@int64@@ ) { int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; int @@int@@ ; char * @@char@@ ; char * @@char@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __off_t @@offt@@ ; __off_t @@offt@@ ; __int64 @@int64@@ ; size_t @@sizet@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 * @@int64@@ ; struct stat @@structstat@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = Number L ; @@unsignedint64@@ = Number L ; @@int64@@ = Number L ; @@unsignedint64@@ = Number L ; @@int@@ = fileno ( @@FILE@@ ) ; if ( ! ( unsigned int ) fstat ( @@int@@ , & @@structstat@@ ) && ( @@structstat@@ . st_mode & Number ) == Number ) { @@offt@@ = @@structstat@@ . st_size ; @@offt@@ = ftello ( @@FILE@@ ) ; if ( @@offt@@ >= Number ) { if ( @@offt@@ >= @@offt@@ ) @@unsignedint64@@ = Number L ; else @@unsignedint64@@ = @@offt@@ - @@offt@@ ; if ( @@unsignedint64@@ > Number ) xalloc_die ( ) ; @@unsignedint64@@ = @@unsignedint64@@ + Number ; } } do { if ( @@unsignedint64@@ <= @@int64@@ + Number ) { if ( @@unsignedint64@@ == Number ) xalloc_die ( ) ; @@unsignedint64@@ = @@unsignedint64@@ ; @@unsignedint64@@ *= Number L ; if ( @@unsignedint64@@ < @@unsignedint64@@ ) @@unsignedint64@@ = Number ; @@int64@@ = xrealloc ( @@int64@@ , @@unsignedint64@@ ) ; } @@int64@@ = @@unsignedint64@@ - @@int64@@ - Number ; @@sizet@@ = fread_unlocked ( ( void * ) ( @@int64@@ + @@int64@@ ) , Number , @@int64@@ , @@FILE@@ ) ; @@int64@@ += @@sizet@@ ; } while ( @@sizet@@ == @@int64@@ ) ; @@int@@ = * __errno_location ( ) ; if ( @@int64@@ && @@char@@ != * ( _BYTE * ) ( @@int64@@ - Number + @@int64@@ ) ) { @@int64@@ = @@int64@@ ++ ; * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) = @@char@@ ; } @@unsignedint64@@ = @@int64@@ + @@int64@@ ; @@unsignedint64@@ = Number L ; for ( @@char@@ = ( char * ) @@int64@@ ; ( unsigned __int64 ) @@char@@ < @@unsignedint64@@ ; @@char@@ = next_line ( @@char@@ , @@char@@ , @@unsignedint64@@ - ( _QWORD ) @@char@@ ) ) { ++ @@unsignedint64@@ ; } @@int64@@ = ( __int64 * ) xnmalloc ( @@unsignedint64@@ + Number , Number L ) ; * @@int64@@ = @@int64@@ ; @@char@@ = ( char * ) @@int64@@ ; * @@int64@@ = @@int64@@ ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= @@unsignedint64@@ ; ++ @@unsignedint64@@ ) { @@char@@ = next_line ( @@char@@ , @@char@@ , @@unsignedint64@@ - ( _QWORD ) @@char@@ ) ; @@int64@@ [ @@unsignedint64@@ ] = ( __int64 ) @@char@@ ; } * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
__int64 __fastcall format_user_or_group ( const char * @@constchar@@ , __int64 @@int64@@ , int @@int@@ ) { int @@int@@ ; __int64 @@int64@@ ; int @@int@@ ; int @@int@@ ; size_t @@sizet@@ ; if ( @@constchar@@ ) { @@int@@ = @@int@@ - gnu_mbswidth ( @@constchar@@ , Number L ) ; @@int@@ = Number ; if ( @@int@@ >= Number ) @@int@@ = @@int@@ ; @@int@@ = @@int@@ ; fputs_unlocked ( @@constchar@@ , stdout ) ; @@sizet@@ = strlen ( @@constchar@@ ) + @@int@@ ; do putchar_unlocked ( Number ) ; while ( @@int@@ -- ) ; } else { printf ( String , @@int@@ , @@int64@@ ) ; @@sizet@@ = @@int@@ ; } @@int64@@ = dired_pos + @@sizet@@ + Number ; dired_pos = @@int64@@ ; return @@int64@@ ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
char * __fastcall str_iconv ( char * @@char@@ , char * @@char@@ , char * @@char@@ ) { char * @@char@@ ; int @@int@@ ; int @@int@@ ; iconv_t @@iconvt@@ ; void * @@void@@ ; char * @@char@@ ; if ( * @@char@@ && ( unsigned int ) c_strcasecmp ( ( unsigned __int8 * ) @@char@@ , ( unsigned __int8 * ) @@char@@ ) ) { @@iconvt@@ = iconv_open ( @@char@@ , @@char@@ ) ; if ( @@iconvt@@ == ( iconv_t ) Number ) return Number L ; @@void@@ = str_cd_iconv ( @@char@@ , @@iconvt@@ ) ; if ( @@void@@ ) { if ( iconv_close ( @@iconvt@@ ) < Number ) { @@int@@ = * __errno_location ( ) ; free ( @@void@@ ) ; * __errno_location ( ) = @@int@@ ; return Number L ; } } else { @@int@@ = * __errno_location ( ) ; iconv_close ( @@iconvt@@ ) ; * __errno_location ( ) = @@int@@ ; } @@char@@ = ( char * ) @@void@@ ; } else { @@char@@ = strdup ( @@char@@ ) ; if ( ! @@char@@ ) * __errno_location ( ) = Number ; @@char@@ = @@char@@ ; } return @@char@@ ; }
_QWORD * __fastcall randint_all_new ( __int64 @@int64@@ , __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; @@int64@@ = randread_new ( @@int64@@ , @@int64@@ ) ; if ( @@int64@@ ) @@QWORD@@ = randint_new ( @@int64@@ ) ; else @@QWORD@@ = Number L ; return @@QWORD@@ ; }
__int64 __fastcall shift_left ( __int64 @@int64@@ ) { return @@int64@@ << Number ; }
const char * __fastcall format_inode ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ ) { const char * @@constchar@@ ; if ( @@unsignedint64@@ <= Number ) __assert_fail ( String , String , Number , String ) ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) && * ( _QWORD * ) ( @@int64@@ + Number ) ) @@constchar@@ = ( const char * ) umaxtostr ( * ( _QWORD * ) ( @@int64@@ + Number ) , @@int64@@ ) ; else @@constchar@@ = String ; return @@constchar@@ ; }
void __fastcall freea ( unsigned __int64 @@unsignedint64@@ ) { _QWORD * @@QWORD@@ ; if ( @@unsignedint64@@ && * ( _DWORD * ) ( @@unsignedint64@@ - Number ) == Number ) { for ( @@QWORD@@ = & mmalloca_results [ @@unsignedint64@@ % Number ] ; * @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) ( * @@QWORD@@ - Number L ) ) { if ( @@unsignedint64@@ == * @@QWORD@@ ) { * @@QWORD@@ = * ( _QWORD * ) ( @@unsignedint64@@ - Number ) ; free ( ( void * ) ( @@unsignedint64@@ - Number ) ) ; return ; } } } }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
_DWORD * __fastcall isaac_seed_data ( _DWORD * @@DWORD@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { _DWORD * @@DWORD@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; char * @@char@@ ; char * @@char@@ ; for ( @@unsignedint64@@ = Number L - ( unsigned int ) @@DWORD@@ [ Number ] ; @@unsignedint64@@ > @@unsignedint64@@ ; @@unsignedint64@@ = Number L ) { @@char@@ = ( char * ) @@DWORD@@ + ( unsigned int ) @@DWORD@@ [ Number ] ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@unsignedint64@@ ; ++ @@unsignedint64@@ ) { @@char@@ [ @@unsignedint64@@ ] ^= * ( _BYTE * ) ( @@int64@@ + @@unsignedint64@@ ) ; } @@int64@@ += @@unsignedint64@@ ; @@unsignedint64@@ -= @@unsignedint64@@ ; isaac_mix ( @@DWORD@@ , ( __int64 ) @@DWORD@@ ) ; @@DWORD@@ [ Number ] = Number ; } @@char@@ = ( char * ) @@DWORD@@ + ( unsigned int ) @@DWORD@@ [ Number ] ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@unsignedint64@@ ; ++ @@unsignedint64@@ ) { @@char@@ [ @@unsignedint64@@ ] ^= * ( _BYTE * ) ( @@int64@@ + @@unsignedint64@@ ) ; } @@DWORD@@ = @@DWORD@@ ; @@DWORD@@ [ Number ] = @@unsignedint64@@ ; return @@DWORD@@ ; }
__int64 __fastcall randint_all_free ( _QWORD * @@QWORD@@ ) { unsigned int @@unsignedint@@ ; int @@int@@ ; @@unsignedint@@ = randread_free ( * @@QWORD@@ ) ; @@int@@ = * __errno_location ( ) ; randint_free ( @@QWORD@@ ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint@@ ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
_BOOL8 __fastcall dot_or_dotdot ( _BYTE * @@BYTE@@ ) { __int64 @@int64@@ ; char @@char@@ ; if ( * @@BYTE@@ != Number ) return Number L ; if ( @@BYTE@@ [ Number ] == Number ) @@int64@@ = Number L ; else @@int64@@ = Number L ; @@char@@ = @@BYTE@@ [ @@int64@@ ] ; return ! @@char@@ || @@char@@ == Number ; }
__int64 __fastcall length_of_file_name_and_frills ( __int64 @@int64@@ ) { const char * @@constchar@@ ; __int64 @@int64@@ ; const char * @@constchar@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; char @@char@@ ; size_t @@sizet@@ ; __int64 @@int64@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = Number L ; if ( print_inode ) { if ( format == Number ) { @@constchar@@ = ( const char * ) umaxtostr ( * ( _QWORD * ) ( @@int64@@ + Number ) , @@char@@ ) ; @@int64@@ = strlen ( @@constchar@@ ) + Number ; } else { @@int64@@ = inode_number_width + Number L ; } @@int64@@ += @@int64@@ ; } if ( print_block_size ) { if ( format == Number ) { if ( * ( _BYTE * ) ( @@int64@@ + Number ) != Number ) @@constchar@@ = String ; else @@constchar@@ = ( const char * ) human_readable ( * ( _QWORD * ) ( @@int64@@ + Number ) , @@char@@ , ( unsigned int ) human_output_opts , Number L , output_block_size ) ; @@int64@@ = strlen ( @@constchar@@ ) + Number ; } else { @@int64@@ = block_size_width + Number L ; } @@int64@@ += @@int64@@ ; } if ( print_scontext ) { if ( format == Number ) @@int64@@ = strlen ( * ( const char * * ) ( @@int64@@ + Number ) ) + Number ; else @@int64@@ = scontext_width + Number L ; @@int64@@ += @@int64@@ ; } quote_name ( Number L , * ( _QWORD * ) @@int64@@ , filename_quoting_options , & @@sizet@@ ) ; @@int64@@ += @@sizet@@ ; if ( indicator_style ) { @@char@@ = get_type_indicator ( * ( _BYTE * ) ( @@int64@@ + Number ) , * ( _DWORD * ) ( @@int64@@ + Number ) , * ( _DWORD * ) ( @@int64@@ + Number ) ) ; @@int64@@ += @@char@@ != Number ; } return @@int64@@ ; }
unsigned __int64 __fastcall randperm_bound ( __int64 @@int64@@ , __int64 @@int64@@ ) { return ( unsigned __int64 ) ( @@int64@@ * ceil_lg ( @@int64@@ ) + Number ) >> Number ; }
__int64 gethrxtime ( ) { struct timespec @@structtimespec@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( clock_gettime ( Number , & @@structtimespec@@ ) ) gettime ( & @@structtimespec@@ ) ; return xtime_make ( @@structtimespec@@ . tv_sec , @@structtimespec@@ . tv_nsec ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
unsigned int __fastcall dired_dump_obstack ( const char * @@constchar@@ , __int64 @@int64@@ ) { unsigned int @@unsignedint@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; @@unsignedint@@ = ( unsigned int ) ( * ( _DWORD * ) ( @@int64@@ + Number ) - * ( _DWORD * ) ( @@int64@@ + Number ) ) >> Number ; @@unsignedint64@@ = @@unsignedint@@ ; if ( @@unsignedint@@ ) { @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( @@int64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ) * ( _BYTE * ) ( @@int64@@ + Number ) |= Number ; * ( _QWORD * ) ( @@int64@@ + Number ) = ( * ( int * ) ( @@int64@@ + Number ) + * ( _QWORD * ) ( @@int64@@ + Number ) ) & ~ * ( _DWORD * ) ( @@int64@@ + Number ) ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) - * ( _QWORD * ) ( @@int64@@ + Number ) > * ( _QWORD * ) ( @@int64@@ + Number ) - * ( _QWORD * ) ( @@int64@@ + Number ) ) * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; fputs_unlocked ( @@constchar@@ , stdout ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@unsignedint64@@ ; ++ @@unsignedint64@@ ) { printf ( String , * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@int64@@ ) ) ; } @@unsignedint@@ = putchar_unlocked ( Number ) ; } return @@unsignedint@@ ; }
_BYTE * __fastcall attach ( _BYTE * @@BYTE@@ , _BYTE * @@BYTE@@ , _BYTE * @@BYTE@@ ) { _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; @@BYTE@@ = @@BYTE@@ ; if ( * @@BYTE@@ != Number || @@BYTE@@ [ Number ] ) { while ( * @@BYTE@@ ) { @@BYTE@@ = @@BYTE@@ ++ ; @@BYTE@@ = @@BYTE@@ ++ ; * @@BYTE@@ = * @@BYTE@@ ; } if ( @@BYTE@@ > @@BYTE@@ && * ( @@BYTE@@ - Number ) != Number ) { @@BYTE@@ = @@BYTE@@ ++ ; * @@BYTE@@ = Number ; } } while ( * @@BYTE@@ ) { @@BYTE@@ = @@BYTE@@ ++ ; @@BYTE@@ = @@BYTE@@ ++ ; * @@BYTE@@ = * @@BYTE@@ ; } @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ = Number ; return @@BYTE@@ ; }
char * __fastcall randread_new ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { size_t @@sizet@@ ; FILE * @@FILE@@ ; char * @@char@@ ; if ( ! @@unsignedint64@@ ) return ( char * ) simple_new ( Number L , Number L ) ; @@FILE@@ = Number L ; if ( @@int64@@ ) { @@FILE@@ = ( FILE * ) fopen_safer ( @@int64@@ , & off_796B ) ; if ( ! @@FILE@@ ) return Number L ; } @@char@@ = ( char * ) simple_new ( ( __int64 ) @@FILE@@ , @@int64@@ ) ; if ( @@FILE@@ ) { @@sizet@@ = Number L ; if ( @@unsignedint64@@ <= Number ) @@sizet@@ = @@unsignedint64@@ ; setvbuf ( @@FILE@@ , @@char@@ + Number , Number , @@sizet@@ ) ; } else { * ( ( _QWORD * ) @@char@@ + Number ) = Number L ; isaac_seed ( @@char@@ + Number ) ; } return @@char@@ ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@unsignedint64@@ , int @@int@@ ) { __int64 @@int64@@ ; if ( is_mul_ok ( @@int@@ , * @@unsignedint64@@ ) ) { * @@unsignedint64@@ *= @@int@@ ; @@int64@@ = Number L ; } else { * @@unsignedint64@@ = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_20A028 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
_BOOL8 __fastcall is_directory ( __int64 @@int64@@ ) { return * ( _DWORD * ) ( @@int64@@ + Number ) == Number || * ( _DWORD * ) ( @@int64@@ + Number ) == Number ; }
__int64 __fastcall hash_get_n_buckets ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
size_t * __fastcall readisaac ( size_t * @@sizet@@ , char * @@char@@ , size_t @@sizet@@ ) { size_t * @@sizet@@ ; size_t @@sizet@@ ; char * @@char@@ ; for ( @@sizet@@ = * @@sizet@@ ; @@sizet@@ > @@sizet@@ ; @@sizet@@ = Number L ) { memcpy ( @@char@@ , ( char * ) @@sizet@@ + Number - @@sizet@@ + Number , @@sizet@@ ) ; @@char@@ += @@sizet@@ ; @@sizet@@ -= @@sizet@@ ; if ( ( ( unsigned __int8 ) @@char@@ & Number ) == Number ) { @@char@@ = @@char@@ ; while ( @@sizet@@ > Number ) { isaac_refill ( @@sizet@@ + Number , @@char@@ ) ; @@char@@ += Number ; @@sizet@@ -= Number L ; if ( ! @@sizet@@ ) { @@sizet@@ = @@sizet@@ ; * @@sizet@@ = Number L ; return @@sizet@@ ; } } @@char@@ = @@char@@ ; } isaac_refill ( @@sizet@@ + Number , ( char * ) @@sizet@@ + Number ) ; } memcpy ( @@char@@ , ( char * ) @@sizet@@ + Number - @@sizet@@ + Number , @@sizet@@ ) ; @@sizet@@ = @@sizet@@ ; * @@sizet@@ = @@sizet@@ - @@sizet@@ ; return @@sizet@@ ; }
__int64 __fastcall hash_get_n_buckets_used ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
_BYTE * __fastcall mark_printable_field ( unsigned __int64 @@unsignedint64@@ ) { _BYTE * @@BYTE@@ ; @@BYTE@@ = ( _BYTE * ) ( printable_field + ( @@unsignedint64@@ >> Number ) ) ; * @@BYTE@@ |= Number << ( @@unsignedint64@@ & Number ) ; return @@BYTE@@ ; }
__int64 __fastcall verrevcmp ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { int @@int@@ ; int @@int@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = Number L ; @@unsignedint64@@ = Number L ; while ( @@unsignedint64@@ < @@unsignedint64@@ || @@unsignedint64@@ < @@unsignedint64@@ ) { @@unsignedint@@ = Number ; while ( @@unsignedint64@@ < @@unsignedint64@@ && ( unsigned __int8 ) c_isdigit ( ( unsigned int ) * ( char * ) ( @@int64@@ + @@unsignedint64@@ ) ) != Number || @@unsignedint64@@ < @@unsignedint64@@ && ( unsigned __int8 ) c_isdigit ( ( unsigned int ) * ( char * ) ( @@int64@@ + @@unsignedint64@@ ) ) != Number ) { if ( @@unsignedint64@@ == @@unsignedint64@@ ) @@int@@ = Number ; else @@int@@ = order ( * ( _BYTE * ) ( @@int64@@ + @@unsignedint64@@ ) ) ; @@int@@ = @@int@@ ; if ( @@unsignedint64@@ == @@unsignedint64@@ ) @@int@@ = Number ; else @@int@@ = order ( * ( _BYTE * ) ( @@int64@@ + @@unsignedint64@@ ) ) ; if ( @@int@@ != @@int@@ ) return ( unsigned int ) ( @@int@@ - @@int@@ ) ; ++ @@unsignedint64@@ ; ++ @@unsignedint64@@ ; } while ( * ( _BYTE * ) ( @@int64@@ + @@unsignedint64@@ ) == Number ) ++ @@unsignedint64@@ ; while ( * ( _BYTE * ) ( @@int64@@ + @@unsignedint64@@ ) == Number ) ++ @@unsignedint64@@ ; while ( ( unsigned __int8 ) c_isdigit ( ( unsigned int ) * ( char * ) ( @@int64@@ + @@unsignedint64@@ ) ) && ( unsigned __int8 ) c_isdigit ( ( unsigned int ) * ( char * ) ( @@int64@@ + @@unsignedint64@@ ) ) ) { if ( ! @@unsignedint@@ ) @@unsignedint@@ = * ( char * ) ( @@int64@@ + @@unsignedint64@@ ) - * ( char * ) ( @@int64@@ + @@unsignedint64@@ ) ; ++ @@unsignedint64@@ ; ++ @@unsignedint64@@ ; } if ( ( unsigned __int8 ) c_isdigit ( ( unsigned int ) * ( char * ) ( @@int64@@ + @@unsignedint64@@ ) ) ) return Number L ; if ( ( unsigned __int8 ) c_isdigit ( ( unsigned int ) * ( char * ) ( @@int64@@ + @@unsignedint64@@ ) ) ) return Number ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; } return Number L ; }
__int64 __fastcall xtime_make ( __int64 @@int64@@ , __int64 @@int64@@ ) { return Number * @@int64@@ + @@int64@@ ; }
__int64 __fastcall hash_get_n_entries ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
bool __fastcall is_range_start_index ( __int64 @@int64@@ ) { return hash_lookup ( range_start_ht , @@int64@@ ) != Number ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
__int64 __fastcall make_link_name ( const char * @@constchar@@ , const char * @@constchar@@ ) { size_t @@sizet@@ ; char * @@char@@ ; char * @@char@@ ; __int64 @@int64@@ ; if ( ! @@constchar@@ ) return Number L ; if ( * @@constchar@@ == Number ) return xstrdup ( @@constchar@@ ) ; @@char@@ = strrchr ( @@constchar@@ , Number ) ; if ( ! @@char@@ ) return xstrdup ( @@constchar@@ ) ; @@int64@@ = @@char@@ - @@constchar@@ + Number ; @@sizet@@ = strlen ( @@constchar@@ ) ; @@char@@ = ( char * ) xmalloc ( @@sizet@@ + @@int64@@ + Number ) ; strncpy ( @@char@@ , @@constchar@@ , @@int64@@ ) ; strcpy ( & @@char@@ [ @@int64@@ ] , @@constchar@@ ) ; return ( __int64 ) @@char@@ ; }
__int64 __fastcall cmp_name ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ , __int64 ( __fastcall * @ @ VAR_515 @ @ int64 ( fastcall ) ( QWORD , QWORD ) @ @ int ( ) ( constchar , constchar ) ) ( _QWORD , _QWORD ) ) { return @ @ VAR_515 @ @ int64 ( fastcall ) ( QWORD , QWORD ) @ @ int ( ) ( constchar , constchar ) ( * @@QWORD@@ , * @@QWORD@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall compare_ranges ( const void * @@constvoid@@ , const void * @@constvoid@@ ) { __int64 @@int64@@ ; int @@int@@ ; int @@int@@ ; @@int@@ = * ( _QWORD * ) @@constvoid@@ ; @@int@@ = * ( _QWORD * ) @@constvoid@@ ; if ( @@int@@ < @@int@@ ) @@int64@@ = Number ; else @@int64@@ = @@int@@ > @@int@@ ; return @@int64@@ ; }
unsigned __int64 __fastcall hash_get_max_bucket_length ( __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = Number L ; for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { @@QWORD@@ = @@QWORD@@ ; for ( @@unsignedint64@@ = Number L ; ; ++ @@unsignedint64@@ ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; if ( ! @@QWORD@@ ) break ; } if ( @@unsignedint64@@ > @@unsignedint64@@ ) @@unsignedint64@@ = @@unsignedint64@@ ; } } return @@unsignedint64@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
int __fastcall argmatch_valid ( __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { char * @@char@@ ; __int64 @@int64@@ ; void * @@void@@ ; @@void@@ = Number L ; @@char@@ = gettext ( String ) ; fprintf ( stderr , @@char@@ ) ; for ( @@int64@@ = Number L ; * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; ++ @@int64@@ ) { if ( @@int64@@ && ! memcmp ( @@void@@ , ( const void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) , @@sizet@@ ) ) { fprintf ( stderr , String , * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) ) ; } else { fprintf ( stderr , String , * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) ) ; @@void@@ = ( void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) ; } } return putc_unlocked ( Number , stderr ) ; }
__int64 __fastcall cmp_extension ( const char * * @@constchar@@ , const char * * @@constchar@@ , __int64 ( __fastcall * @ @ VAR_525 @ @ int64 ( fastcall ) ( constchar , constchar ) @ @ int ( ) ( constchar , constchar ) ) ( const char * , const char * ) ) { const char * @@constchar@@ ; const char * @@constchar@@ ; __int64 @@int64@@ ; unsigned int @@unsignedint@@ ; char * @@char@@ ; char * @@char@@ ; @@char@@ = strrchr ( * @@constchar@@ , Number ) ; @@char@@ = strrchr ( * @@constchar@@ , Number ) ; if ( @@char@@ ) @@constchar@@ = @@char@@ ; else @@constchar@@ = & off_16E97 [ Number ] ; if ( @@char@@ ) @@constchar@@ = @@char@@ ; else @@constchar@@ = & off_16E97 [ Number ] ; @@unsignedint@@ = @ @ VAR_525 @ @ int64 ( fastcall ) ( constchar , constchar ) @ @ int ( ) ( constchar , constchar ) ( @@constchar@@ , @@constchar@@ ) ; if ( @@unsignedint@@ ) @@int64@@ = @@unsignedint@@ ; else @@int64@@ = @ @ VAR_525 @ @ int64 ( fastcall ) ( constchar , constchar ) @ @ int ( ) ( constchar , constchar ) ( * @@constchar@@ , * @@constchar@@ ) ; return @@int64@@ ; }
unsigned __int64 __fastcall cut_bytes ( FILE * @@FILE@@ ) { bool * @@bool@@ ; char @@char@@ ; char @@char@@ ; int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; bool * @@bool@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@unsignedint64@@ = Number L ; @@char@@ = Number ; while ( Number ) { while ( Number ) { @@int@@ = getc_unlocked ( @@FILE@@ ) ; if ( @@int@@ != Number ) break ; putchar_unlocked ( Number ) ; @@unsignedint64@@ = Number L ; @@char@@ = Number ; } if ( @@int@@ == Number ) break ; if ( output_delimiter_specified ) @@bool@@ = ( bool * ) & @@char@@ ; else @@bool@@ = Number L ; @@bool@@ = @@bool@@ ; if ( print_kth ( ++ @@unsignedint64@@ , @@bool@@ ) ) { if ( @@bool@@ && * @@bool@@ && @@char@@ ) fwrite_unlocked ( output_delimiter_string , Number , output_delimiter_length , stdout ) ; @@char@@ = Number ; putchar_unlocked ( @@int@@ ) ; } } if ( @@unsignedint64@@ ) putchar_unlocked ( Number ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
unsigned __int64 __fastcall hash_get_entries ( __int64 @@int64@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; @@unsignedint64@@ = Number L ; for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { for ( @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { if ( @@unsignedint64@@ >= @@unsignedint64@@ ) return @@unsignedint64@@ ; @@int64@@ = @@unsignedint64@@ ++ ; * ( _QWORD * ) ( @@int64@@ + Number * @@int64@@ ) = * @@QWORD@@ ; } } } return @@unsignedint64@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
__int64 __fastcall file_name_concat ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = mfile_name_concat ( @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( ! @@int64@@ ) xalloc_die ( ) ; return @@int64@@ ; }
__int64 long_time_expected_width ( ) { time_t @@timet@@ ; struct tm * @@structtm@@ ; __int64 @@int64@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( width_8232 < Number ) { @@timet@@ = Number L ; @@structtm@@ = localtime ( & @@timet@@ ) ; if ( @@structtm@@ ) { @@int64@@ = align_nstrftime ( ( __int64 ) @@char@@ , Number L , long_time_format , ( __int64 ) @@structtm@@ , Number , Number ) ; if ( @@int64@@ ) width_8232 = mbsnwidth ( @@char@@ , @@int64@@ , Number L ) ; } if ( width_8232 < Number ) width_8232 = Number ; } return ( unsigned int ) width_8232 ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
unsigned __int64 __fastcall raw_hasher ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { return rotr_sz ( @@int64@@ , Number ) % @@unsignedint64@@ ; }
__int64 __fastcall hash_get_first ( unsigned __int64 * @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; if ( ! @@unsignedint64@@ [ Number ] ) return Number L ; for ( @@unsignedint64@@ = * @@unsignedint64@@ ; ; @@unsignedint64@@ += Number L ) { if ( @@unsignedint64@@ >= @@unsignedint64@@ [ Number ] ) abort ( ) ; if ( * ( _QWORD * ) @@unsignedint64@@ ) break ; } return * ( _QWORD * ) @@unsignedint64@@ ; }
__int64 __fastcall hash_get_n_buckets ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 __fastcall hash_do_for_each ( __int64 @@int64@@ , unsigned __int8 ( __fastcall * @ @ VAR_428 @ @ unsignedint8 ( fastcall ) ( QWORD , int64 ) @ @ Hashprocessor ) ( _QWORD , __int64 ) , __int64 @@int64@@ ) { __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; @@int64@@ = Number L ; for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { for ( @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { if ( @ @ VAR_428 @ @ unsignedint8 ( fastcall ) ( QWORD , int64 ) @ @ Hashprocessor ( * @@QWORD@@ , @@int64@@ ) != Number ) return @@int64@@ ; ++ @@int64@@ ; } } } return @@int64@@ ; }
size_t __fastcall format_user_width ( unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; if ( numeric_ids ) @@int64@@ = Number L ; else @@int64@@ = getuser ( @@unsignedint@@ ) ; return format_user_or_group_width ( @@int64@@ , @@unsignedint@@ ) ; }
unsigned __int64 __fastcall compute_bucket_size ( __int64 @@int64@@ , __int64 @@int64@@ ) { float @@float@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; float @@float@@ ; @@unsignedint64@@ = @@int64@@ ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) != Number ) { if ( @@int64@@ < Number ) @@float@@ = ( float ) ( @@int64@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@int64@@ >> Number ) ) + ( float ) ( @@int64@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@int64@@ >> Number ) ) ; else @@float@@ = ( float ) ( int ) @@int64@@ ; @@float@@ = @@float@@ / * ( float * ) ( @@int64@@ + Number ) ; if ( @@float@@ >= Number ) return Number L ; if ( @@float@@ >= Number ) @@unsignedint64@@ = ( unsigned int ) ( int ) ( float ) ( @@float@@ - Number ) ^ Number ; else @@unsignedint64@@ = ( unsigned int ) ( int ) @@float@@ ; } @@unsignedint64@@ = next_prime ( @@unsignedint64@@ ) ; if ( @@unsignedint64@@ <= Number ) @@unsignedint64@@ = @@unsignedint64@@ ; else @@unsignedint64@@ = Number L ; return @@unsignedint64@@ ; }
__int64 __fastcall hash_get_n_buckets_used ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 __fastcall check_tuning ( __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( ( _UNKNOWN * ) @@int64@@ == & default_tuning ) return Number L ; if ( * ( float * ) ( @@int64@@ + Number ) > Number && ( float ) ( Number - Number ) > * ( float * ) ( @@int64@@ + Number ) && * ( float * ) ( @@int64@@ + Number ) > ( float ) ( Number + Number ) && * ( float * ) @@int64@@ >= Number && * ( float * ) ( @@int64@@ + Number ) > ( float ) ( * ( float * ) @@int64@@ + Number ) && * ( float * ) ( @@int64@@ + Number ) <= Number && * ( float * ) ( @@int64@@ + Number ) > ( float ) ( * ( float * ) @@int64@@ + Number ) ) { return Number L ; } * ( _QWORD * ) ( @@int64@@ + Number ) = & default_tuning ; return Number L ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
size_t __fastcall print_name_with_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , struct obstack * @@structobstack@@ , unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; bool @@bool@@ ; bool @@bool@@ ; __int64 @@int64@@ ; size_t @@sizet@@ ; if ( @@unsignedint8@@ ) @@int64@@ = @@int64@@ [ Number ] ; else @@int64@@ = * @@int64@@ ; @@int64@@ = @@int64@@ ; @@bool@@ = print_with_color && ( unsigned __int8 ) print_color_indicator ( @@int64@@ , @@unsignedint8@@ ) ; @@bool@@ = @@bool@@ ; if ( @@structobstack@@ && dired ) { if ( @@structobstack@@ -> next_free + Number > @@structobstack@@ -> chunk_limit ) _obstack_newchunk ( @@structobstack@@ , Number ) ; memcpy ( @@structobstack@@ -> next_free , & dired_pos , Number ) ; @@structobstack@@ -> next_free += Number ; } @@sizet@@ = quote_name ( stdout , @@int64@@ , filename_quoting_options , Number L ) ; dired_pos += @@sizet@@ ; if ( @@structobstack@@ && dired ) { if ( @@structobstack@@ -> next_free + Number > @@structobstack@@ -> chunk_limit ) _obstack_newchunk ( @@structobstack@@ , Number ) ; memcpy ( @@structobstack@@ -> next_free , & dired_pos , Number ) ; @@structobstack@@ -> next_free += Number ; } if ( @@bool@@ ) { process_signals ( ) ; prep_non_filename_text ( ) ; if ( @@unsignedint64@@ / line_length != ( @@unsignedint64@@ + @@sizet@@ - Number ) / line_length ) put_indicator ( & unk_21F1F0 ) ; } return @@sizet@@ ; }
unsigned __int64 __fastcall hash_get_max_bucket_length ( __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = Number L ; for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { @@QWORD@@ = @@QWORD@@ ; for ( @@unsignedint64@@ = Number L ; ; ++ @@unsignedint64@@ ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; if ( ! @@QWORD@@ ) break ; } if ( @@unsignedint64@@ > @@unsignedint64@@ ) @@unsignedint64@@ = @@unsignedint64@@ ; } } return @@unsignedint64@@ ; }
__int64 __fastcall hash_rehash ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; void * @@void@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@unsignedint64@@ = compute_bucket_size ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( ! @@unsignedint64@@ ) return Number L ; if ( @@unsignedint64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ) return Number L ; @@void@@ = calloc ( @@unsignedint64@@ , Number ) ; if ( ! @@void@@ ) return Number L ; @@unsignedint64@@ = @@unsignedint64@@ ; @@int64@@ = ( __int64 ) @@void@@ + Number * @@unsignedint64@@ ; @@int64@@ = Number L ; @@int64@@ = Number L ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( ( unsigned __int8 ) transfer_entries ( ( __int64 ) & @@void@@ , @@int64@@ , Number ) ) { free ( * ( void * * ) @@int64@@ ) ; * ( _QWORD * ) @@int64@@ = @@void@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@unsignedint64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; @@int64@@ = Number L ; } else { * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; if ( ( unsigned __int8 ) transfer_entries ( @@int64@@ , ( __int64 ) & @@void@@ , Number ) != Number || ( unsigned __int8 ) transfer_entries ( @@int64@@ , ( __int64 ) & @@void@@ , Number ) != Number ) { abort ( ) ; } free ( @@void@@ ) ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
int print_horizontal ( ) { unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; @@unsignedint64@@ = Number L ; @@unsignedint64@@ = calculate_columns ( Number L ) ; @@int64@@ = column_info + Number * @@unsignedint64@@ - Number ; @@int64@@ = * ( _QWORD * ) sorted_file ; @@int64@@ = length_of_file_name_and_frills ( * ( _QWORD * ) sorted_file ) ; @@int64@@ = * * ( _QWORD * * ) ( @@int64@@ + Number ) ; print_file_name_and_frills ( @@int64@@ , Number L ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < cwd_n_used ; ++ @@unsignedint64@@ ) { if ( @@unsignedint64@@ % @@unsignedint64@@ ) { indent ( @@unsignedint64@@ + @@int64@@ , @@int64@@ + @@unsignedint64@@ ) ; @@unsignedint64@@ += @@int64@@ ; } else { putchar_unlocked ( Number ) ; @@unsignedint64@@ = Number L ; } @@int64@@ = * ( ( _QWORD * ) sorted_file + @@unsignedint64@@ ) ; print_file_name_and_frills ( @@int64@@ , @@unsignedint64@@ ) ; @@int64@@ = length_of_file_name_and_frills ( @@int64@@ ) ; @@int64@@ = * ( _QWORD * ) ( Number * ( @@unsignedint64@@ % @@unsignedint64@@ ) + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; } return putchar_unlocked ( Number ) ; }
__int64 __fastcall hash_lookup ( __int64 * @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; @@int64@@ = * @@int64@@ ; @@QWORD@@ = ( _QWORD * ) ( @@int64@@ + Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@int64@@ [ Number ] ) ( @@int64@@ , @@int64@@ [ Number ] ) ) ; if ( ( unsigned __int64 ) @@QWORD@@ >= @@int64@@ [ Number ] ) abort ( ) ; if ( ! * @@QWORD@@ ) return Number L ; for ( @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { if ( @@int64@@ == * @@QWORD@@ || ( ( unsigned __int8 ( __fastcall * ) ( __int64 , _QWORD ) ) @@int64@@ [ Number ] ) ( @@int64@@ , * @@QWORD@@ ) ) { return * @@QWORD@@ ; } } return Number L ; }
__int64 __fastcall transfer_entries ( __int64 @@int64@@ , __int64 @@int64@@ , char @@char@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 * @@int64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; for ( @@int64@@ = * ( __int64 * * ) @@int64@@ ; ( unsigned __int64 ) @@int64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ += Number ) { if ( * @@int64@@ ) { for ( @@QWORD@@ = ( _QWORD * ) @@int64@@ [ Number ] ; @@QWORD@@ ; @@QWORD@@ = @@QWORD@@ ) { @@int64@@ = * @@QWORD@@ ; @@int64@@ = * ( _QWORD * ) @@int64@@ ; @@QWORD@@ = ( _QWORD * ) ( @@int64@@ + Number * ( * ( __int64 ( __fastcall * * ) ( _QWORD , _QWORD ) ) ( @@int64@@ + Number ) ) ( * @@QWORD@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@QWORD@@ >= * ( _QWORD * ) ( @@int64@@ + Number ) ) abort ( ) ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; if ( * @@QWORD@@ ) { @@QWORD@@ [ Number ] = @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = @@QWORD@@ ; } else { * @@QWORD@@ = @@int64@@ ; ++ * ( _QWORD * ) ( @@int64@@ + Number ) ; free_entry ( @@int64@@ , @@QWORD@@ ) ; } } @@int64@@ = * @@int64@@ ; @@int64@@ [ Number ] = Number L ; if ( ! @@char@@ ) { @@int64@@ = * ( _QWORD * ) @@int64@@ ; @@QWORD@@ = ( _QWORD * ) ( @@int64@@ + Number * ( * ( __int64 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@int64@@ + Number ) ) ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@QWORD@@ >= * ( _QWORD * ) ( @@int64@@ + Number ) ) abort ( ) ; if ( * @@QWORD@@ ) { @@QWORD@@ = allocate_entry ( @@int64@@ ) ; if ( ! @@QWORD@@ ) return Number L ; * @@QWORD@@ = @@int64@@ ; @@QWORD@@ [ Number ] = @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = @@QWORD@@ ; } else { * @@QWORD@@ = @@int64@@ ; ++ * ( _QWORD * ) ( @@int64@@ + Number ) ; } * @@int64@@ = Number L ; -- * ( _QWORD * ) ( @@int64@@ + Number ) ; } } } return Number L ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
_BYTE * __fastcall match_suffix ( _BYTE * * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@BYTE@@ = Number L ; @@char@@ = Number ; while ( * * @@BYTE@@ ) { if ( @@char@@ ) { @@char@@ = Number ; if ( ( unsigned __int8 ) c_isalpha ( ( unsigned int ) ( char ) * * @@BYTE@@ ) != Number && * * @@BYTE@@ != Number ) { @@BYTE@@ = Number L ; } } else if ( * * @@BYTE@@ == Number ) { @@char@@ = Number ; if ( ! @@BYTE@@ ) @@BYTE@@ = * @@BYTE@@ ; } else if ( ( unsigned __int8 ) c_isalnum ( ( unsigned int ) ( char ) * * @@BYTE@@ ) != Number && * * @@BYTE@@ != Number ) { @@BYTE@@ = Number L ; } ++ * @@BYTE@@ ; } return @@BYTE@@ ; }
__int64 __fastcall hash_do_for_each ( __int64 @@int64@@ , unsigned __int8 ( __fastcall * @ @ VAR_1333 @ @ unsignedint8 ( fastcall ) ( QWORD , int64 ) @ @ Hashprocessor ) ( _QWORD , __int64 ) , __int64 @@int64@@ ) { __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; @@int64@@ = Number L ; for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { for ( @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { if ( @ @ VAR_1333 @ @ unsignedint8 ( fastcall ) ( QWORD , int64 ) @ @ Hashprocessor ( * @@QWORD@@ , @@int64@@ ) != Number ) return @@int64@@ ; ++ @@int64@@ ; } } } return @@int64@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return xmalloc ( @@int64@@ , @@int64@@ , @@int64@@ ) ; }
unsigned __int64 __fastcall raw_hasher ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { return rotr_sz ( @@int64@@ , Number ) % @@unsignedint64@@ ; }
__int64 __fastcall x2nrealloc ( __int64 @@int64@@ , unsigned __int64 * @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = * @@unsignedint64@@ ; if ( @@int64@@ ) { if ( @@unsignedint64@@ >= Number / @@unsignedint64@@ ) xalloc_die ( ) ; @@unsignedint64@@ += ( @@unsignedint64@@ + Number ) >> Number ; } else if ( ! @@unsignedint64@@ ) { @@unsignedint64@@ = ( Number / @@unsignedint64@@ == Number ) + Number / @@unsignedint64@@ ; } * @@unsignedint64@@ = @@unsignedint64@@ ; return xrealloc ( @@int64@@ , @@unsignedint64@@ * @@unsignedint64@@ ) ; }
__int64 __fastcall freadptr ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ ) { __int64 @@int64@@ ; if ( @@QWORD@@ [ Number ] > @@QWORD@@ [ Number ] ) return Number L ; @@int64@@ = @@QWORD@@ [ Number ] - @@QWORD@@ [ Number ] ; if ( ! @@int64@@ ) return Number L ; * @@QWORD@@ = @@int64@@ ; return @@QWORD@@ [ Number ] ; }
__int64 __fastcall check_tuning ( __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( ( _UNKNOWN * ) @@int64@@ == & default_tuning ) return Number L ; if ( * ( float * ) ( @@int64@@ + Number ) > Number && ( float ) ( Number - Number ) > * ( float * ) ( @@int64@@ + Number ) && * ( float * ) ( @@int64@@ + Number ) > ( float ) ( Number + Number ) && * ( float * ) @@int64@@ >= Number && * ( float * ) ( @@int64@@ + Number ) > ( float ) ( * ( float * ) @@int64@@ + Number ) && * ( float * ) ( @@int64@@ + Number ) <= Number && * ( float * ) ( @@int64@@ + Number ) > ( float ) ( * ( float * ) @@int64@@ + Number ) ) { return Number L ; } * ( _QWORD * ) ( @@int64@@ + Number ) = & default_tuning ; return Number L ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_20B028 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall filevercmp ( const char * @@constchar@@ , const char * @@constchar@@ ) { __int64 @@int64@@ ; _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned int @@unsignedint@@ ; unsigned int @@unsignedint@@ ; _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; size_t @@sizet@@ ; _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; unsigned __int64 @@unsignedint64@@ ; @@int64@@ = ( __int64 ) @@constchar@@ ; @@int64@@ = ( __int64 ) @@constchar@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@unsignedint@@ = strcmp ( @@constchar@@ , @@constchar@@ ) ; if ( ! @@unsignedint@@ ) return Number L ; if ( ! * @@constchar@@ ) return Number ; if ( ! * @@constchar@@ ) return Number L ; if ( ! strcmp ( String , @@constchar@@ ) ) return Number ; if ( ! strcmp ( String , @@constchar@@ ) ) return Number L ; if ( ! strcmp ( String , @@constchar@@ ) ) return Number ; if ( ! strcmp ( String , @@constchar@@ ) ) return Number L ; if ( * @@constchar@@ == Number && * @@constchar@@ != Number ) return Number ; if ( * @@constchar@@ != Number && * @@constchar@@ == Number ) return Number L ; if ( * @@constchar@@ == Number && * @@constchar@@ == Number ) { @@int64@@ = ( __int64 ) ( @@constchar@@ + Number ) ; @@int64@@ = ( __int64 ) ( @@constchar@@ + Number ) ; } @@BYTE@@ = ( _BYTE * ) @@int64@@ ; @@BYTE@@ = ( _BYTE * ) @@int64@@ ; @@BYTE@@ = match_suffix ( & @@BYTE@@ ) ; @@BYTE@@ = match_suffix ( & @@BYTE@@ ) ; if ( @@BYTE@@ ) @@BYTE@@ = @@BYTE@@ ; else @@BYTE@@ = @@BYTE@@ ; @@sizet@@ = ( size_t ) & @@BYTE@@ [ - @@int64@@ ] ; if ( @@BYTE@@ ) @@BYTE@@ = @@BYTE@@ ; else @@BYTE@@ = @@BYTE@@ ; @@BYTE@@ = & @@BYTE@@ [ - @@int64@@ ] ; if ( ( @@BYTE@@ || @@BYTE@@ ) && ( _BYTE * ) @@sizet@@ == @@BYTE@@ && ! strncmp ( ( const char * ) @@int64@@ , ( const char * ) @@int64@@ , @@sizet@@ ) ) { @@sizet@@ = ( size_t ) & @@BYTE@@ [ - @@int64@@ ] ; @@BYTE@@ = & @@BYTE@@ [ - @@int64@@ ] ; } @@unsignedint@@ = verrevcmp ( @@int64@@ , @@sizet@@ , @@int64@@ , ( unsigned __int64 ) @@BYTE@@ ) ; if ( @@unsignedint@@ ) @@int64@@ = @@unsignedint@@ ; else @@int64@@ = @@unsignedint@@ ; return @@int64@@ ; }
bool __fastcall is_printable_field ( unsigned __int64 @@unsignedint64@@ ) { return ( ( ( int ) * ( unsigned __int8 * ) ( printable_field + ( @@unsignedint64@@ >> Number ) ) >> ( @@unsignedint64@@ & Number ) ) & Number ) != Number ; }
__int64 __fastcall freadahead ( __int64 @@int64@@ ) { __int64 @@int64@@ ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) > * ( _QWORD * ) ( @@int64@@ + Number ) ) return Number L ; if ( ( * ( _DWORD * ) @@int64@@ & Number ) != Number ) @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) - * ( _QWORD * ) ( @@int64@@ + Number ) ; else @@int64@@ = Number L ; return * ( _QWORD * ) ( @@int64@@ + Number ) - * ( _QWORD * ) ( @@int64@@ + Number ) + @@int64@@ ; }
__int64 __fastcall transfer_entries ( __int64 @@int64@@ , __int64 @@int64@@ , char @@char@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 * @@int64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; for ( @@int64@@ = * ( __int64 * * ) @@int64@@ ; ( unsigned __int64 ) @@int64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ += Number ) { if ( * @@int64@@ ) { for ( @@QWORD@@ = ( _QWORD * ) @@int64@@ [ Number ] ; @@QWORD@@ ; @@QWORD@@ = @@QWORD@@ ) { @@int64@@ = * @@QWORD@@ ; @@int64@@ = * ( _QWORD * ) @@int64@@ ; @@QWORD@@ = ( _QWORD * ) ( @@int64@@ + Number * ( * ( __int64 ( __fastcall * * ) ( _QWORD , _QWORD ) ) ( @@int64@@ + Number ) ) ( * @@QWORD@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@QWORD@@ >= * ( _QWORD * ) ( @@int64@@ + Number ) ) abort ( ) ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; if ( * @@QWORD@@ ) { @@QWORD@@ [ Number ] = @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = @@QWORD@@ ; } else { * @@QWORD@@ = @@int64@@ ; ++ * ( _QWORD * ) ( @@int64@@ + Number ) ; free_entry ( @@int64@@ , @@QWORD@@ ) ; } } @@int64@@ = * @@int64@@ ; @@int64@@ [ Number ] = Number L ; if ( ! @@char@@ ) { @@int64@@ = * ( _QWORD * ) @@int64@@ ; @@QWORD@@ = ( _QWORD * ) ( @@int64@@ + Number * ( * ( __int64 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@int64@@ + Number ) ) ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@QWORD@@ >= * ( _QWORD * ) ( @@int64@@ + Number ) ) abort ( ) ; if ( * @@QWORD@@ ) { @@QWORD@@ = allocate_entry ( @@int64@@ ) ; if ( ! @@QWORD@@ ) return Number L ; * @@QWORD@@ = @@int64@@ ; @@QWORD@@ [ Number ] = @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = @@QWORD@@ ; } else { * @@QWORD@@ = @@int64@@ ; ++ * ( _QWORD * ) ( @@int64@@ + Number ) ; } * @@int64@@ = Number L ; -- * ( _QWORD * ) ( @@int64@@ + Number ) ; } } } return Number L ; }
int __fastcall record_relation ( __int64 @@int64@@ , __int64 @@int64@@ ) { int @@int@@ ; _QWORD * @@QWORD@@ ; @@int@@ = strcmp ( * ( const char * * ) @@int64@@ , * ( const char * * ) @@int64@@ ) ; if ( @@int@@ ) { ++ * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ = ( _QWORD * ) xmalloc ( Number L ) ; * @@QWORD@@ = @@int64@@ ; @@QWORD@@ [ Number ] = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int@@ = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@QWORD@@ ; } return @@int@@ ; }
__int64 __fastcall _xargmatch_internal ( __int64 @@int64@@ , const char * @@constchar@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ , void ( * @ @ VAR_1227 @ @ void ( ) ( void ) @ @ argmatchexitfn ) ( void ) ) { __int64 @@int64@@ ; @@int64@@ = argmatch ( @@constchar@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; if ( @@int64@@ >= Number ) return @@int64@@ ; argmatch_invalid ( @@int64@@ , ( __int64 ) @@constchar@@ , @@int64@@ ) ; argmatch_valid ( @@int64@@ , @@int64@@ , @@sizet@@ ) ; @ @ VAR_1227 @ @ void ( ) ( void ) @ @ argmatchexitfn ( ) ; return Number ; }
_BOOL8 __fastcall print_kth ( unsigned __int64 @@unsignedint64@@ , bool * @@bool@@ ) { bool @@bool@@ ; bool @@bool@@ ; @@bool@@ = eol_range_start && @@unsignedint64@@ >= eol_range_start || @@unsignedint64@@ <= max_range_endpoint && is_printable_field ( @@unsignedint64@@ ) ; @@bool@@ = ( unsigned __int8 ) ( @@bool@@ ^ complement ) != Number ; if ( @@bool@@ && @@bool@@ != complement ) * @@bool@@ = is_range_start_index ( @@unsignedint64@@ ) ; return @@bool@@ ; }
__int64 __fastcall new_item ( __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = xmalloc ( Number L ) ; if ( @@int64@@ ) @@int64@@ = xstrdup ( @@int64@@ ) ; else @@int64@@ = Number L ; * ( _QWORD * ) @@int64@@ = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _DWORD * ) ( @@int64@@ + Number ) = Number ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number L ; return @@int64@@ ; }
__int64 __fastcall walk_tree ( __int64 @@int64@@ , __int64 ( __fastcall * @ @ VAR_130 @ @ int64 ( fastcall ) ( int64 ) @ @ bool ( ) ( item ) ) ( __int64 ) ) { __int64 @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( @@int64@@ ) @@int64@@ = recurse_tree ( * ( _QWORD * ) ( @@int64@@ + Number ) , @ @ VAR_130 @ @ int64 ( fastcall ) ( int64 ) @ @ bool ( ) ( item ) ) ; return @@int64@@ ; }
__int64 __fastcall ftypelet ( __int16 @@int16@@ ) { switch ( @@int16@@ & Number ) { case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; } return Number L ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall getgidbyname ( const char * @@constchar@@ ) { __int64 @@int64@@ ; size_t @@sizet@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; struct group * @@structgroup@@ ; for ( @@int64@@ = group_alist ; @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ) { if ( * ( _BYTE * ) ( @@int64@@ + Number ) == * @@constchar@@ && ! strcmp ( ( const char * ) ( @@int64@@ + Number ) , @@constchar@@ ) ) { return @@int64@@ ; } } for ( @@int64@@ = nogroup_alist ; @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ) { if ( * ( _BYTE * ) ( @@int64@@ + Number ) == * @@constchar@@ && ! strcmp ( ( const char * ) ( @@int64@@ + Number ) , @@constchar@@ ) ) { return Number L ; } } @@structgroup@@ = getgrnam ( @@constchar@@ ) ; @@sizet@@ = strlen ( @@constchar@@ ) ; @@int64@@ = xmalloc ( @@sizet@@ + Number ) ; strcpy ( ( char * ) ( @@int64@@ + Number ) , @@constchar@@ ) ; if ( @@structgroup@@ ) { * ( _DWORD * ) @@int64@@ = @@structgroup@@ -> gr_gid ; * ( _QWORD * ) ( @@int64@@ + Number ) = group_alist ; group_alist = @@int64@@ ; @@int64@@ = @@int64@@ ; } else { * ( _QWORD * ) ( @@int64@@ + Number ) = nogroup_alist ; nogroup_alist = @@int64@@ ; @@int64@@ = Number L ; } return @@int64@@ ; }
_BYTE * __fastcall filemodestring ( __int64 @@int64@@ , _BYTE * @@BYTE@@ ) { return strmode ( * ( _DWORD * ) ( @@int64@@ + Number ) , @@BYTE@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
__int64 __fastcall detect_loop ( __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) { if ( loop ) { for ( @@int64@@ = @@int64@@ + Number ; * ( _QWORD * ) @@int64@@ ; @@int64@@ = * ( _QWORD * ) @@int64@@ + Number L ) { if ( * * ( _QWORD * * ) @@int64@@ == loop ) { if ( ! * ( _QWORD * ) ( @@int64@@ + Number ) ) { * ( _QWORD * ) ( @@int64@@ + Number ) = loop ; loop = @@int64@@ ; return Number L ; } while ( loop ) { @@int64@@ = * ( _QWORD * ) ( loop + Number ) ; fprintf ( stderr , String , ( const char * ) program_name , * ( const char * * ) loop ) ; if ( @@int64@@ == loop ) { -- * ( _QWORD * ) ( * * ( _QWORD * * ) @@int64@@ + Number L ) ; * ( _QWORD * ) @@int64@@ = * ( _QWORD * ) ( * ( _QWORD * ) @@int64@@ + Number L ) ; break ; } * ( _QWORD * ) ( loop + Number ) = Number L ; loop = @@int64@@ ; } while ( loop ) { @@int64@@ = * ( _QWORD * ) ( loop + Number ) ; * ( _QWORD * ) ( loop + Number ) = Number L ; loop = @@int64@@ ; } return Number L ; } } } else { loop = @@int64@@ ; } } return Number L ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
_BOOL8 __fastcall hash_table_ok ( __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; @@int64@@ = Number L ; @@int64@@ = Number L ; for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { @@QWORD@@ = @@QWORD@@ ; ++ @@int64@@ ; ++ @@int64@@ ; while ( Number ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; if ( ! @@QWORD@@ ) break ; ++ @@int64@@ ; } } } return @@int64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) && @@int64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
void * __fastcall mfile_name_concat ( _BYTE * @@BYTE@@ , _BYTE * @@BYTE@@ , _QWORD * @@QWORD@@ ) { _BOOL4 @@BOOL4@@ ; const char * @@constchar@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; _BOOL8 @@BOOL8@@ ; char * @@char@@ ; size_t @@sizet@@ ; void * @@void@@ ; _BYTE * @@BYTE@@ ; char * @@char@@ ; @@constchar@@ = last_component ( @@BYTE@@ ) ; @@sizet@@ = base_len ( @@constchar@@ ) ; @@sizet@@ = @@constchar@@ - @@BYTE@@ + @@sizet@@ ; @@BOOL4@@ = @@sizet@@ && @@constchar@@ [ @@sizet@@ - Number ] != Number ; @@BOOL8@@ = @@BOOL4@@ ; @@char@@ = longest_relative_suffix ( @@BYTE@@ ) ; @@sizet@@ = strlen ( @@char@@ ) ; @@void@@ = malloc ( @@BOOL8@@ + @@sizet@@ + @@sizet@@ + Number ) ; if ( ! @@void@@ ) return Number L ; @@BYTE@@ = mempcpy ( @@void@@ , @@BYTE@@ , @@sizet@@ ) ; * @@BYTE@@ = Number ; @@char@@ = & @@BYTE@@ [ @@BOOL8@@ ] ; if ( @@QWORD@@ ) * @@QWORD@@ = & @@char@@ [ - ( * @@BYTE@@ == Number ) ] ; * ( _BYTE * ) mempcpy ( @@char@@ , @@char@@ , @@sizet@@ ) = Number ; return @@void@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
unsigned __int64 __fastcall hash_string ( _BYTE * @@BYTE@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = Number L ; while ( * @@BYTE@@ ) @@unsignedint64@@ = ( Number * @@unsignedint64@@ + ( unsigned __int8 ) * @@BYTE@@ ++ ) % @@unsignedint64@@ ; return @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_207028 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
unsigned __int64 __fastcall hash_string ( _BYTE * @@BYTE@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = Number L ; while ( * @@BYTE@@ ) @@unsignedint64@@ = ( Number * @@unsignedint64@@ + ( unsigned __int8 ) * @@BYTE@@ ++ ) % @@unsignedint64@@ ; return @@unsignedint64@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
bool __fastcall is_prime ( unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = Number L ; @@unsignedint64@@ = Number L ; while ( @@unsignedint64@@ < @@unsignedint64@@ && @@unsignedint64@@ % @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@unsignedint64@@ += Number * @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint64@@ + Number ; } return @@unsignedint64@@ % @@unsignedint64@@ != Number ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall next_prime ( unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = @@unsignedint64@@ ; if ( @@unsignedint64@@ <= Number ) @@int64@@ = Number L ; for ( @@int64@@ = @@int64@@ | Number ; @@int64@@ != Number && ! is_prime ( @@int64@@ ) ; @@int64@@ += Number L ) { ; } return @@int64@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
__int64 __fastcall readtoken ( FILE * @@FILE@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; char @@char@@ ; int @@int@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( ! @@int64@@ && ! saved_delim_3296 ) abort ( ) ; @@char@@ = Number ; if ( @@int64@@ != saved_delim_3296 && saved_delim_3296 ) { @@char@@ = Number ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@unsignedint64@@ ; ++ @@unsignedint64@@ ) { if ( * ( _BYTE * ) ( @@int64@@ + @@unsignedint64@@ ) != * ( _BYTE * ) ( saved_delim_3296 + @@unsignedint64@@ ) ) { @@char@@ = Number ; break ; } } } if ( @@char@@ != Number ) { saved_delim_3296 = @@int64@@ ; memset ( isdelim_3297 , Number , sizeof ( isdelim_3297 ) ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@unsignedint64@@ ; ++ @@unsignedint64@@ ) { isdelim_3297 [ * ( unsigned __int8 * ) ( @@int64@@ + @@unsignedint64@@ ) ] = Number ; } } do @@int@@ = getc_unlocked ( @@FILE@@ ) ; while ( @@int@@ >= Number && isdelim_3297 [ @@int@@ ] ) ; @@int64@@ = @@int64@@ [ Number ] ; @@int64@@ = * @@int64@@ ; @@unsignedint64@@ = Number L ; while ( Number ) { if ( @@int@@ < Number && ! @@unsignedint64@@ ) return Number ; if ( @@unsignedint64@@ == @@int64@@ ) @@int64@@ = x2nrealloc ( @@int64@@ , & @@int64@@ , Number L ) ; if ( @@int@@ < Number ) { * ( _BYTE * ) ( @@int64@@ + @@unsignedint64@@ ) = Number ; goto LABEL_28 ; } if ( isdelim_3297 [ @@int@@ ] ) break ; @@int64@@ = @@unsignedint64@@ ++ ; * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) = @@int@@ ; @@int@@ = getc_unlocked ( @@FILE@@ ) ; } * ( _BYTE * ) ( @@int64@@ + @@unsignedint64@@ ) = Number ; LABEL_28 : @@int64@@ [ Number ] = @@int64@@ ; * @@int64@@ = @@int64@@ ; return @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
void * __fastcall allocate_entry ( __int64 @@int64@@ ) { __int64 @@int64@@ ; if ( ! * ( _QWORD * ) ( @@int64@@ + Number ) ) return malloc ( Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; return ( void * ) @@int64@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
size_t * __fastcall hash_initialize ( __int64 @@int64@@ , void * @@void@@ , unsigned __int64 ( __fastcall * @ @ VAR_458 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ) ( __int64 a1 , unsigned __int64 a2 ) , bool ( __fastcall * @ @ VAR_460 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ) ( __int64 a1 , __int64 a2 ) , size_t @@sizet@@ ) { size_t * @@sizet@@ ; bool ( __fastcall * @ @ VAR_459 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ) ( __int64 , __int64 ) ; unsigned __int64 ( __fastcall * @ @ VAR_457 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ) ( __int64 , unsigned __int64 ) ; void * @@void@@ ; size_t * @@sizet@@ ; @@void@@ = @@void@@ ; @ @ VAR_457 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher = @ @ VAR_458 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ; @ @ VAR_459 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator = @ @ VAR_460 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ; if ( ! @ @ VAR_458 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ) @ @ VAR_457 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher = raw_hasher ; if ( ! @ @ VAR_460 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ) @ @ VAR_459 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator = raw_comparator ; @@sizet@@ = ( size_t * ) malloc ( Number ) ; if ( ! @@sizet@@ ) return Number L ; if ( ! @@void@@ ) @@void@@ = & default_tuning ; @@sizet@@ [ Number ] = ( size_t ) @@void@@ ; if ( ( unsigned __int8 ) check_tuning ( ( __int64 ) @@sizet@@ ) == Number && ( @@sizet@@ [ Number ] = compute_bucket_size ( @@int64@@ , ( __int64 ) @@void@@ ) ) != Number && ( * @@sizet@@ = ( size_t ) calloc ( @@sizet@@ [ Number ] , Number ) ) != Number ) { @@sizet@@ [ Number ] = Number * @@sizet@@ [ Number ] + * @@sizet@@ ; @@sizet@@ [ Number ] = Number L ; @@sizet@@ [ Number ] = Number L ; @@sizet@@ [ Number ] = ( size_t ) @ @ VAR_457 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ; @@sizet@@ [ Number ] = ( size_t ) @ @ VAR_459 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ; @@sizet@@ [ Number ] = @@sizet@@ ; @@sizet@@ [ Number ] = Number L ; @@sizet@@ = @@sizet@@ ; } else { free ( @@sizet@@ ) ; @@sizet@@ = Number L ; } return @@sizet@@ ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
__int64 __fastcall memcpy_uppcase ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { while ( @@int64@@ -- ) * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) = toupper ( * ( unsigned __int8 * ) ( @@int64@@ + @@int64@@ ) ) ; return @@int64@@ ; }
__int64 __fastcall free_entry ( __int64 @@int64@@ , _QWORD * @@QWORD@@ ) { __int64 @@int64@@ ; * @@QWORD@@ = Number L ; @@QWORD@@ [ Number ] = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@QWORD@@ ; return @@int64@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 __fastcall xnrealloc ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { if ( ! is_mul_ok ( @@unsignedint64@@ , @@unsignedint64@@ ) ) xalloc_die ( ) ; return xrealloc ( @@int64@@ , @@unsignedint64@@ * @@unsignedint64@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_2070E8 ; @@int648@@ [ Number ] = qword_2070F0 ; @@int648@@ [ Number ] = qword_2070F8 ; @@int648@@ [ Number ] = qword_207100 ; @@int648@@ [ Number ] = qword_207108 ; @@int648@@ [ Number ] = qword_207110 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
unsigned __int64 __fastcall xstrtol_error ( unsigned int @@unsignedint@@ , int @@int@@ , char @@char@@ , __int64 @@int64@@ , __int64 @@int64@@ , int @@int@@ ) { char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; char @@char2@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@char@@ = ( char * ) & unk_1A278 ; if ( @@unsignedint@@ > Number ) { if ( @@unsignedint@@ != Number ) goto LABEL_6 ; @@char@@ = String ; } else if ( @@unsignedint@@ >= Number ) { @@char@@ = String ; } else { if ( @@unsignedint@@ != Number ) LABEL_6 : abort ( ) ; @@char@@ = String ; } if ( @@int@@ >= Number ) { @@char@@ = * ( char * * ) ( Number L * @@int@@ + @@int64@@ ) ; } else { @@char@@ = ( char * ) & unk_1A278 - @@int@@ ; @@char2@@ [ Number ] = @@char@@ ; @@char2@@ [ Number ] = Number ; @@char@@ = @@char2@@ ; } @@char@@ = gettext ( @@char@@ ) ; error ( @@int@@ , Number , @@char@@ , @@char@@ , @@char@@ , @@int64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 __fastcall hash_find_entry ( __int64 @@int64@@ , __int64 @@int64@@ , _QWORD * @@QWORD@@ , char @@char@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; @@int64@@ = * ( _QWORD * ) @@int64@@ ; @@QWORD@@ = ( _QWORD * ) ( @@int64@@ + Number * ( * ( __int64 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@int64@@ + Number ) ) ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@QWORD@@ >= * ( _QWORD * ) ( @@int64@@ + Number ) ) abort ( ) ; * @@QWORD@@ = @@QWORD@@ ; if ( ! * @@QWORD@@ ) return Number L ; if ( @@int64@@ == * @@QWORD@@ || ( * ( unsigned __int8 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@int64@@ + Number ) ) ( @@int64@@ , * @@QWORD@@ ) ) { @@int64@@ = * @@QWORD@@ ; if ( @@char@@ ) { if ( @@QWORD@@ [ Number ] ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; @@int64@@ = @@QWORD@@ [ Number ] ; * @@QWORD@@ = * @@QWORD@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; free_entry ( @@int64@@ , @@QWORD@@ ) ; } else { * @@QWORD@@ = Number L ; } } @@int64@@ = @@int64@@ ; } else { for ( @@QWORD@@ = @@QWORD@@ ; ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { if ( ! @@QWORD@@ [ Number ] ) return Number L ; if ( @@int64@@ == * ( _QWORD * ) @@QWORD@@ [ Number ] || ( * ( unsigned __int8 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@int64@@ + Number ) ) ( @@int64@@ , * ( _QWORD * ) @@QWORD@@ [ Number ] ) ) { break ; } } @@int64@@ = * ( _QWORD * ) @@QWORD@@ [ Number ] ; if ( @@char@@ ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = @@QWORD@@ [ Number ] ; free_entry ( @@int64@@ , @@QWORD@@ ) ; } @@int64@@ = @@int64@@ ; } return @@int64@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
unsigned __int64 set_LD_PRELOAD ( ) { int @@int@@ ; int @@int@@ ; int @@int@@ ; __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; char @@char@@ ; int @@int@@ ; char * @@char@@ ; void * @@void@@ ; __int64 * @@int64@@ ; char * @@char@@ ; __int64 @@int644@@ [ Number ] ; struct stat @@structstat@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@char@@ = getenv ( String ) ; @@int644@@ [ Number ] = ( __int64 ) program_path ; @@int644@@ [ Number ] = ( __int64 ) String ; @@int644@@ [ Number ] = ( __int64 ) & locale ; @@int644@@ [ Number ] = Number L ; @@int64@@ = @@int644@@ ; while ( * ( _BYTE * ) * @@int64@@ ) { if ( ( int ) rpl_asprintf ( ( unsigned int ) & @@void@@ , ( unsigned int ) String , * @@int64@@ , ( unsigned int ) String , @@int@@ , @@int@@ , @@char@@ ) < Number ) xalloc_die ( ) ; if ( ( unsigned int ) stat ( ( char * ) @@void@@ , & @@structstat@@ ) ) { free ( @@void@@ ) ; if ( * ++ @@int64@@ ) continue ; } goto LABEL_8 ; } @@void@@ = ( void * ) xstrdup ( String ) ; LABEL_8 : if ( @@char@@ ) @@int@@ = rpl_asprintf ( ( unsigned int ) & @@char@@ , ( unsigned int ) String , ( _DWORD ) @@char@@ , ( _DWORD ) @@void@@ , @@int@@ , @@int@@ , @@char@@ ) ; else @@int@@ = rpl_asprintf ( ( unsigned int ) & @@char@@ , ( unsigned int ) String , ( _DWORD ) @@void@@ , @@int@@ , @@int@@ , @@int@@ , @@char@@ ) ; if ( @@int@@ < Number ) xalloc_die ( ) ; free ( @@void@@ ) ; if ( putenv ( @@char@@ ) ) { @@int64@@ = quote ( @@char@@ ) ; @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ , @@int64@@ ) ; } return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall x2nrealloc ( __int64 @@int64@@ , unsigned __int64 * @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = * @@unsignedint64@@ ; if ( @@int64@@ ) { if ( @@unsignedint64@@ >= Number / @@unsignedint64@@ ) xalloc_die ( ) ; @@unsignedint64@@ += ( @@unsignedint64@@ + Number ) >> Number ; } else if ( ! @@unsignedint64@@ ) { @@unsignedint64@@ = ( Number / @@unsignedint64@@ == Number ) + Number / @@unsignedint64@@ ; } * @@unsignedint64@@ = @@unsignedint64@@ ; return xrealloc ( @@int64@@ , @@unsignedint64@@ * @@unsignedint64@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall getuser ( __uid_t @@uidt@@ ) { const char * @@constchar@@ ; size_t @@sizet@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; struct passwd * @@structpasswd@@ ; char * @@char@@ ; @@int64@@ = Number L ; for ( @@int64@@ = user_alist ; @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ) { if ( @@uidt@@ == * ( _DWORD * ) @@int64@@ ) { @@int64@@ = @@int64@@ ; break ; } } if ( ! @@int64@@ ) { @@structpasswd@@ = getpwuid ( @@uidt@@ ) ; if ( @@structpasswd@@ ) @@constchar@@ = @@structpasswd@@ -> pw_name ; else @@constchar@@ = ( const char * ) & unk_19CC0 ; @@char@@ = ( char * ) @@constchar@@ ; @@sizet@@ = strlen ( @@constchar@@ ) ; @@int64@@ = xmalloc ( @@sizet@@ + Number ) ; * ( _DWORD * ) @@int64@@ = @@uidt@@ ; strcpy ( ( char * ) ( @@int64@@ + Number ) , @@char@@ ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = user_alist ; user_alist = @@int64@@ ; } if ( * ( _BYTE * ) ( @@int64@@ + Number ) ) @@int64@@ = @@int64@@ + Number ; else @@int64@@ = Number L ; return @@int64@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
void * __fastcall mpsort_into_tmp ( __int64 * @@int64@@ , unsigned __int64 @@unsignedint64@@ , _QWORD * @@QWORD@@ , __int64 ( __fastcall * @ @ VAR_1602 @ @ int64 ( fastcall ) ( int64 , int64 ) @ @ int64 ( fastcall ) ( int64 , int64 ) ) ( __int64 , __int64 ) ) { int @@int@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; @@QWORD@@ = @@QWORD@@ ; @@unsignedint64@@ = Number L ; @@unsignedint64@@ = @@unsignedint64@@ >> Number ; @@unsignedint64@@ = @@unsignedint64@@ >> Number ; mpsort_with_tmp ( & @@int64@@ [ @@unsignedint64@@ >> Number ] , @@unsignedint64@@ - ( @@unsignedint64@@ >> Number ) , @@QWORD@@ , @ @ VAR_1602 @ @ int64 ( fastcall ) ( int64 , int64 ) @ @ int64 ( fastcall ) ( int64 , int64 ) ) ; mpsort_with_tmp ( @@int64@@ , @@unsignedint64@@ >> Number , @@QWORD@@ , @ @ VAR_1602 @ @ int64 ( fastcall ) ( int64 , int64 ) @ @ int64 ( fastcall ) ( int64 , int64 ) ) ; @@int64@@ = * @@int64@@ ; @@int64@@ = @@int64@@ [ @@unsignedint64@@ >> Number ] ; for ( @@int@@ = @ @ VAR_1602 @ @ int64 ( fastcall ) ( int64 , int64 ) @ @ int64 ( fastcall ) ( int64 , int64 ) ( * @@int64@@ , @@int64@@ ) ; ; @@int@@ = @ @ VAR_1602 @ @ int64 ( fastcall ) ( int64 , int64 ) @ @ int64 ( fastcall ) ( int64 , int64 ) ( @@int64@@ , @@int64@@ ) ) { while ( @@int@@ > Number ) { @@QWORD@@ = @@QWORD@@ ++ ; * @@QWORD@@ = @@int64@@ ; if ( ++ @@unsignedint64@@ == @@unsignedint64@@ ) return memcpy ( @@QWORD@@ , & @@int64@@ [ @@unsignedint64@@ ] , Number * ( @@unsignedint64@@ - @@unsignedint64@@ ) ) ; @@int64@@ = @@int64@@ [ @@unsignedint64@@ ] ; @@int@@ = @ @ VAR_1602 @ @ int64 ( fastcall ) ( int64 , int64 ) @ @ int64 ( fastcall ) ( int64 , int64 ) ( @@int64@@ , @@int64@@ ) ; } @@QWORD@@ = @@QWORD@@ ++ ; * @@QWORD@@ = @@int64@@ ; if ( ++ @@unsignedint64@@ == @@unsignedint64@@ ) break ; @@int64@@ = @@int64@@ [ @@unsignedint64@@ ] ; } @@unsignedint64@@ = @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint64@@ ; return memcpy ( @@QWORD@@ , & @@int64@@ [ @@unsignedint64@@ ] , Number * ( @@unsignedint64@@ - @@unsignedint64@@ ) ) ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return xmalloc ( @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall make_printable_str ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { char * @@char@@ ; unsigned __int8 @@unsignedint8@@ ; char * @@char@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; char @@char5@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = xnmalloc ( @@unsignedint64@@ + Number , Number L ) ; @@char@@ = ( char * ) @@int64@@ ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@unsignedint64@@ ; ++ @@unsignedint64@@ ) { @@unsignedint8@@ = * ( _BYTE * ) ( @@int64@@ + @@unsignedint64@@ ) ; if ( @@unsignedint8@@ == Number ) { @@char@@ = stpcpy ( @@char@@ , String ) ; goto LABEL_24 ; } if ( @@unsignedint8@@ > Number ) { if ( @@unsignedint8@@ == Number ) { @@char@@ = stpcpy ( @@char@@ , String ) ; goto LABEL_24 ; } if ( @@unsignedint8@@ < Number ) { @@char@@ = stpcpy ( @@char@@ , String ) ; goto LABEL_24 ; } if ( @@unsignedint8@@ == Number ) { @@char@@ = stpcpy ( @@char@@ , String ) ; goto LABEL_24 ; } if ( @@unsignedint8@@ == Number ) { @@char@@ = stpcpy ( @@char@@ , String ) ; goto LABEL_24 ; } } else { if ( @@unsignedint8@@ == Number ) { @@char@@ = stpcpy ( @@char@@ , String ) ; goto LABEL_24 ; } if ( @@unsignedint8@@ > Number ) { @@char@@ = stpcpy ( @@char@@ , String ) ; goto LABEL_24 ; } if ( @@unsignedint8@@ == Number ) { @@char@@ = stpcpy ( @@char@@ , String ) ; goto LABEL_24 ; } } if ( ( ( * __ctype_b_loc ( ) ) [ @@unsignedint8@@ ] & Number ) != Number ) { @@char5@@ [ Number ] = @@unsignedint8@@ ; @@char5@@ [ Number ] = Number ; } else { sprintf ( @@char5@@ , String , @@unsignedint8@@ ) ; } @@char@@ = stpcpy ( @@char@@ , @@char5@@ ) ; LABEL_24 : @@char@@ = @@char@@ ; } return @@int64@@ ; }
__int64 __fastcall scan_zeros ( _QWORD * @@QWORD@@ ) { if ( ! @@QWORD@@ [ Number ] && * @@QWORD@@ ) { if ( head ) * ( _QWORD * ) ( zeros + Number ) = @@QWORD@@ ; else head = ( __int64 ) @@QWORD@@ ; zeros = ( __int64 ) @@QWORD@@ ; } return Number L ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
_BOOL8 __fastcall parse_str ( const char * @@constchar@@ , __int64 @@int64@@ ) { bool @@bool@@ ; bool @@bool@@ ; void * @@void4@@ [ Number ] ; @@void4@@ [ Number ] = ( void * ) __readfsqword ( Number ) ; @@bool@@ = ( unsigned __int8 ) unquote ( @@constchar@@ , @@void4@@ ) && ( unsigned __int8 ) build_spec_list ( ( __int64 * ) @@void4@@ , @@int64@@ ) ; @@bool@@ = @@bool@@ ; es_free ( @@void4@@ ) ; return @@bool@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_21F238 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall c_toupper ( int @@int@@ ) { __int64 @@int64@@ ; if ( @@int@@ <= Number || @@int@@ > Number ) @@int64@@ = ( unsigned int ) @@int@@ ; else @@int64@@ = ( unsigned int ) ( @@int@@ - Number ) ; return @@int64@@ ; }
__int64 __fastcall recurse_tree ( __int64 @@int64@@ , __int64 ( __fastcall * @ @ VAR_126 @ @ int64 ( fastcall ) ( int64 ) @ @ bool ( ) ( item ) ) ( __int64 ) ) { if ( ! * ( _QWORD * ) ( @@int64@@ + Number ) && ! * ( _QWORD * ) ( @@int64@@ + Number ) ) return @ @ VAR_126 @ @ int64 ( fastcall ) ( int64 ) @ @ bool ( ) ( item ) ( @@int64@@ ) ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) && ( unsigned __int8 ) recurse_tree ( * ( _QWORD * ) ( @@int64@@ + Number ) , @ @ VAR_126 @ @ int64 ( fastcall ) ( int64 ) @ @ bool ( ) ( item ) ) ) { return Number L ; } if ( ( unsigned __int8 ) @ @ VAR_126 @ @ int64 ( fastcall ) ( int64 ) @ @ bool ( ) ( item ) ( @@int64@@ ) ) return Number L ; return * ( _QWORD * ) ( @@int64@@ + Number ) && ( unsigned __int8 ) recurse_tree ( * ( _QWORD * ) ( @@int64@@ + Number ) , @ @ VAR_126 @ @ int64 ( fastcall ) ( int64 ) @ @ bool ( ) ( item ) ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
void __fastcall validate ( __int64 @@int64@@ , __int64 @@int64@@ ) { char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; get_s1_spec_stats ( ( _QWORD * ) @@int64@@ ) ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) { @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ ) ; } if ( @@int64@@ ) { get_s2_spec_stats ( ( _QWORD * ) @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) > Number ) { @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ ) ; } if ( translating ) { if ( * ( _BYTE * ) ( @@int64@@ + Number ) ) { @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ ) ; } if ( * ( _QWORD * ) ( @@int64@@ + Number ) > * ( _QWORD * ) ( @@int64@@ + Number ) && truncate_set1 != Number ) { if ( ! * ( _QWORD * ) ( @@int64@@ + Number ) ) { @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ ) ; } string2_extend ( @@int64@@ , @@int64@@ ) ; } if ( complement && * ( _BYTE * ) ( @@int64@@ + Number ) && ( * ( _QWORD * ) ( @@int64@@ + Number ) != * ( _QWORD * ) ( @@int64@@ + Number ) || ( unsigned __int8 ) homogeneous_spec_list ( ( _QWORD * ) @@int64@@ ) != Number ) ) { @@char@@ = gettext ( String String ) ; error ( Number , Number , @@char@@ ) ; } if ( * ( _BYTE * ) ( @@int64@@ + Number ) ) { @@char@@ = gettext ( String String ) ; error ( Number , Number , @@char@@ ) ; } } else if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) { @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ ) ; } } }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
__int64 __fastcall strnlen1 ( const void * @@constvoid@@ , size_t @@sizet@@ ) { __int64 @@int64@@ ; _BYTE * @@BYTE@@ ; @@BYTE@@ = memchr ( @@constvoid@@ , Number , @@sizet@@ ) ; if ( @@BYTE@@ ) @@int64@@ = @@BYTE@@ - ( _BYTE * ) @@constvoid@@ + Number ; else @@int64@@ = @@sizet@@ ; return @@int64@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
FILE * __fastcall freopen_safer ( const char * @@constchar@@ , const char * @@constchar@@ , FILE * @@FILE@@ ) { int @@int@@ ; FILE * @@FILE@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; int @@int@@ ; @@char@@ = Number ; @@char@@ = Number ; @@char@@ = Number ; @@int@@ = fileno ( @@FILE@@ ) ; if ( @@int@@ != Number ) { if ( @@int@@ != Number ) { if ( ! @@int@@ ) goto LABEL_10 ; if ( dup2 ( Number , Number ) != Number ) @@char@@ = Number ; } if ( dup2 ( Number , Number ) != Number ) @@char@@ = Number ; } if ( dup2 ( Number , Number ) ) @@char@@ = Number ; LABEL_10 : if ( @@char@@ && ( unsigned __int8 ) protect_fd ( Number ) != Number ) { @@FILE@@ = Number L ; } else if ( @@char@@ && ( unsigned __int8 ) protect_fd ( Number ) != Number ) { @@FILE@@ = Number L ; } else if ( @@char@@ && ( unsigned __int8 ) protect_fd ( Number ) != Number ) { @@FILE@@ = Number L ; } else { @@FILE@@ = freopen ( @@constchar@@ , @@constchar@@ , @@FILE@@ ) ; } @@int@@ = * __errno_location ( ) ; if ( @@char@@ ) close ( Number ) ; if ( @@char@@ ) close ( Number ) ; if ( @@char@@ ) close ( Number ) ; if ( ! @@FILE@@ ) * __errno_location ( ) = @@int@@ ; return @@FILE@@ ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall xreadlink ( __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = areadlink ( @@int64@@ ) ; if ( ! @@int64@@ && * __errno_location ( ) == Number ) xalloc_die ( ) ; return @@int64@@ ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@unsignedint64@@ , int @@int@@ ) { __int64 @@int64@@ ; if ( is_mul_ok ( @@int@@ , * @@unsignedint64@@ ) ) { * @@unsignedint64@@ *= @@int@@ ; @@int64@@ = Number L ; } else { * @@unsignedint64@@ = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
__int64 __fastcall xstr_iconv ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = str_iconv ( @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( ! @@int64@@ && * __errno_location ( ) == Number ) xalloc_die ( ) ; return @@int64@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_207108 ; @@int648@@ [ Number ] = qword_207110 ; @@int648@@ [ Number ] = qword_207118 ; @@int648@@ [ Number ] = qword_207120 ; @@int648@@ [ Number ] = qword_207128 ; @@int648@@ [ Number ] = qword_207130 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
__int64 __fastcall bkm_scale_by_power ( unsigned __int64 * @@unsignedint64@@ , int @@int@@ , int @@int@@ ) { unsigned int @@unsignedint@@ ; for ( @@unsignedint@@ = Number ; @@int@@ -- ; @@unsignedint@@ |= bkm_scale ( @@unsignedint64@@ , @@int@@ ) ) { ; } return @@unsignedint@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_2060A8 ; @@int648@@ [ Number ] = qword_2060B0 ; @@int648@@ [ Number ] = qword_2060B8 ; @@int648@@ [ Number ] = qword_2060C0 ; @@int648@@ [ Number ] = qword_2060C8 ; @@int648@@ [ Number ] = qword_2060D0 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
_BYTE * __fastcall dir_len ( _BYTE * @@BYTE@@ ) { _BYTE * @@BYTE@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = * @@BYTE@@ == Number ; for ( @@BYTE@@ = ( _BYTE * ) ( last_component ( @@BYTE@@ ) - @@BYTE@@ ) ; @@unsignedint64@@ < ( unsigned __int64 ) @@BYTE@@ && @@BYTE@@ [ ( _QWORD ) ( @@BYTE@@ - Number ) ] == Number ; -- @@BYTE@@ ) { ; } return @@BYTE@@ ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
unsigned __int64 __fastcall rpl_vasprintf ( void * * @@void@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; void * @@void@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@void@@ = ( void * ) vasnprintf ( Number L , & @@unsignedint64@@ , @@int64@@ , @@int64@@ ) ; if ( ! @@void@@ ) return Number ; if ( @@unsignedint64@@ <= Number ) { * @@void@@ = @@void@@ ; @@unsignedint64@@ = @@unsignedint64@@ ; } else { free ( @@void@@ ) ; * __errno_location ( ) = Number ; @@unsignedint64@@ = Number ; } return @@unsignedint64@@ ; }
__int64 __fastcall append_range ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ , unsigned __int8 @@unsignedint8@@ ) { char * @@char@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; if ( @@unsignedint8@@ >= @@unsignedint8@@ ) { @@int64@@ = xmalloc ( Number L ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number L ; * ( _DWORD * ) @@int64@@ = Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = @@unsignedint8@@ ; * ( _BYTE * ) ( @@int64@@ + Number ) = @@unsignedint8@@ ; if ( ! * ( _QWORD * ) ( @@int64@@ + Number ) ) __assert_fail ( String , String , Number , String ) ; * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; @@int64@@ = Number L ; } else { @@char@@ = make_printable_char ( @@unsignedint8@@ ) ; @@char@@ = make_printable_char ( @@unsignedint8@@ ) ; @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ , @@char@@ , @@char@@ ) ; free ( @@char@@ ) ; free ( @@char@@ ) ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_20B028 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
void * __fastcall mfile_name_concat ( _BYTE * @@BYTE@@ , _BYTE * @@BYTE@@ , _QWORD * @@QWORD@@ ) { _BOOL4 @@BOOL4@@ ; const char * @@constchar@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; _BOOL8 @@BOOL8@@ ; char * @@char@@ ; size_t @@sizet@@ ; void * @@void@@ ; _BYTE * @@BYTE@@ ; char * @@char@@ ; @@constchar@@ = last_component ( @@BYTE@@ ) ; @@sizet@@ = base_len ( @@constchar@@ ) ; @@sizet@@ = @@constchar@@ - @@BYTE@@ + @@sizet@@ ; @@BOOL4@@ = @@sizet@@ && @@constchar@@ [ @@sizet@@ - Number ] != Number ; @@BOOL8@@ = @@BOOL4@@ ; @@char@@ = longest_relative_suffix ( @@BYTE@@ ) ; @@sizet@@ = strlen ( @@char@@ ) ; @@void@@ = malloc ( @@BOOL8@@ + @@sizet@@ + @@sizet@@ + Number ) ; if ( ! @@void@@ ) return Number L ; @@BYTE@@ = mempcpy ( @@void@@ , @@BYTE@@ , @@sizet@@ ) ; * @@BYTE@@ = Number ; @@char@@ = & @@BYTE@@ [ @@BOOL8@@ ] ; if ( @@QWORD@@ ) * @@QWORD@@ = & @@char@@ [ - ( * @@BYTE@@ == Number ) ] ; * ( _BYTE * ) mempcpy ( @@char@@ , @@char@@ , @@sizet@@ ) = Number ; return @@void@@ ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
const char * locale_charset ( ) { const char * @@constchar@@ ; char * @@char@@ ; char * @@char@@ ; @@constchar@@ = nl_langinfo ( Number ) ; if ( ! @@constchar@@ ) @@constchar@@ = ( const char * ) & unk_FD75 ; for ( @@char@@ = ( char * ) get_charset_aliases ( ) ; * @@char@@ ; @@char@@ = & @@char@@ [ strlen ( @@char@@ ) + Number ] ) { if ( ! strcmp ( @@constchar@@ , @@char@@ ) || * @@char@@ == Number && ! @@char@@ [ Number ] ) { @@constchar@@ = & @@char@@ [ strlen ( @@char@@ ) + Number ] ; break ; } @@char@@ = & @@char@@ [ strlen ( @@char@@ ) + Number ] ; } if ( ! * @@constchar@@ ) @@constchar@@ = String ; return @@constchar@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
__int64 __fastcall find_closing_delim ( _QWORD * @@QWORD@@ , unsigned __int64 @@unsignedint64@@ , char @@char@@ , unsigned __int64 * @@unsignedint64@@ ) { while ( @@unsignedint64@@ < @@QWORD@@ [ Number ] - Number L ) { if ( @@char@@ == * ( _BYTE * ) ( * @@QWORD@@ + @@unsignedint64@@ ) && * ( _BYTE * ) ( @@unsignedint64@@ + Number + * @@QWORD@@ ) == Number && * ( _BYTE * ) ( @@QWORD@@ [ Number ] + @@unsignedint64@@ ) != Number && * ( _BYTE * ) ( @@unsignedint64@@ + Number + @@QWORD@@ [ Number ] ) != Number ) { * @@unsignedint64@@ = @@unsignedint64@@ ; return Number L ; } ++ @@unsignedint64@@ ; } return Number L ; }
__int64 __fastcall xnrealloc ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { if ( ! is_mul_ok ( @@unsignedint64@@ , @@unsignedint64@@ ) ) xalloc_die ( ) ; return xrealloc ( @@int64@@ , @@unsignedint64@@ * @@unsignedint64@@ ) ; }
char * __fastcall str_iconv ( char * @@char@@ , char * @@char@@ , char * @@char@@ ) { char * @@char@@ ; int @@int@@ ; int @@int@@ ; iconv_t @@iconvt@@ ; void * @@void@@ ; char * @@char@@ ; if ( * @@char@@ && ( unsigned int ) c_strcasecmp ( ( unsigned __int8 * ) @@char@@ , ( unsigned __int8 * ) @@char@@ ) ) { @@iconvt@@ = iconv_open ( @@char@@ , @@char@@ ) ; if ( @@iconvt@@ == ( iconv_t ) Number ) return Number L ; @@void@@ = str_cd_iconv ( @@char@@ , @@iconvt@@ ) ; if ( @@void@@ ) { if ( iconv_close ( @@iconvt@@ ) < Number ) { @@int@@ = * __errno_location ( ) ; free ( @@void@@ ) ; * __errno_location ( ) = @@int@@ ; return Number L ; } } else { @@int@@ = * __errno_location ( ) ; iconv_close ( @@iconvt@@ ) ; * __errno_location ( ) = @@int@@ ; } @@char@@ = ( char * ) @@void@@ ; } else { @@char@@ = strdup ( @@char@@ ) ; if ( ! @@char@@ ) * __errno_location ( ) = Number ; @@char@@ = @@char@@ ; } return @@char@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
__int64 __fastcall card_of_complement ( _QWORD * @@QWORD@@ ) { unsigned int @@unsignedint@@ ; int @@int@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@unsignedint@@ = Number ; memset ( @@char@@ , Number , Number ) ; @@QWORD@@ [ Number ] = Number ; while ( Number ) { @@int@@ = get_next ( @@QWORD@@ , Number L ) ; if ( @@int@@ == Number ) break ; @@unsignedint@@ -= ( unsigned __int8 ) @@char@@ [ @@int@@ ] ^ Number ; @@char@@ [ @@int@@ ] = Number ; } return @@unsignedint@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 __fastcall x2nrealloc ( __int64 @@int64@@ , unsigned __int64 * @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = * @@unsignedint64@@ ; if ( @@int64@@ ) { if ( @@unsignedint64@@ >= Number / @@unsignedint64@@ ) xalloc_die ( ) ; @@unsignedint64@@ += ( @@unsignedint64@@ + Number ) >> Number ; } else if ( ! @@unsignedint64@@ ) { @@unsignedint64@@ = ( Number / @@unsignedint64@@ == Number ) + Number / @@unsignedint64@@ ; } * @@unsignedint64@@ = @@unsignedint64@@ ; return xrealloc ( @@int64@@ , @@unsignedint64@@ * @@unsignedint64@@ ) ; }
bool __fastcall is_basic_2 ( unsigned __int8 @@unsignedint8@@ ) { return ( ( * ( ( _DWORD * ) & is_basic_table + ( @@unsignedint8@@ >> Number ) ) >> ( @@unsignedint8@@ & Number ) ) & Number ) != Number ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
__int64 __fastcall spec_init ( _QWORD * @@QWORD@@ ) { __int64 @@int64@@ ; @@QWORD@@ [ Number ] = xmalloc ( Number L ) ; * @@QWORD@@ = @@QWORD@@ [ Number ] ; @@int64@@ = * @@QWORD@@ ; * ( _QWORD * ) ( * @@QWORD@@ + Number L ) = Number L ; return @@int64@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
_BOOL8 __fastcall rpl_isnanl ( __int64 a1 , __int64 a2 , __int64 a3 , __int64 a4 , __int64 a5 , __int64 a6 , __int128 @@int128@@ ) { if ( ( WORD4 ( @@int128@@ ) & Number ) == Number ) return DWORD1 ( @@int128@@ ) >> Number ; if ( ( WORD4 ( @@int128@@ ) & Number ) == Number ) return ( DWORD1 ( @@int128@@ ) ^ Number | ( unsigned int ) @@int128@@ ) != Number ; return ( DWORD1 ( @@int128@@ ) & Number ) == Number ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall homogeneous_spec_list ( _QWORD * @@QWORD@@ ) { int @@int@@ ; int @@int@@ ; @@QWORD@@ [ Number ] = Number ; @@int@@ = get_next ( @@QWORD@@ , Number L ) ; if ( @@int@@ == Number ) return Number L ; while ( Number ) { @@int@@ = get_next ( @@QWORD@@ , Number L ) ; if ( @@int@@ == Number ) break ; if ( @@int@@ != @@int@@ ) return Number L ; } return Number L ; }
__int64 __fastcall knuth_morris_pratt_unibyte ( _BYTE * @@BYTE@@ , char * @@char@@ , _QWORD * @@QWORD@@ ) { void * @@void@@ ; unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; char * @@char@@ ; _BYTE * @@BYTE@@ ; char @@char@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; size_t @@sizet@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@BYTE@@ = @@BYTE@@ ; @@char@@ = @@char@@ ; @@QWORD@@ = @@QWORD@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@sizet@@ = strlen ( @@char@@ ) ; if ( @@sizet@@ > Number ) { @@unsignedint64@@ = Number L ; } else if ( Number * @@sizet@@ > Number ) { @@unsignedint64@@ = mmalloca ( Number * @@sizet@@ ) ; } else { @@void@@ = alloca ( Number * ( ( Number * ( @@sizet@@ + Number ) + Number ) / Number ) ) ; @@unsignedint64@@ = Number * ( ( ( unsigned __int64 ) & @@QWORD@@ + Number ) >> Number ) + Number ; } @@unsignedint64@@ = @@unsignedint64@@ ; if ( ! @@unsignedint64@@ ) return Number L ; * ( _QWORD * ) ( @@unsignedint64@@ + Number ) = Number L ; @@int64@@ = Number L ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@sizet@@ ; ++ @@unsignedint64@@ ) { @@char@@ = @@char@@ [ @@unsignedint64@@ - Number ] ; while ( Number ) { if ( @@char@@ == @@char@@ [ @@int64@@ ] ) { ++ @@int64@@ ; * ( _QWORD * ) ( @@unsignedint64@@ + Number * @@unsignedint64@@ ) = @@unsignedint64@@ - @@int64@@ ; goto LABEL_15 ; } if ( ! @@int64@@ ) break ; @@int64@@ -= * ( _QWORD * ) ( Number * @@int64@@ + @@unsignedint64@@ ) ; } * ( _QWORD * ) ( @@unsignedint64@@ + Number * @@unsignedint64@@ ) = @@unsignedint64@@ ; LABEL_15 : ; } * @@QWORD@@ = Number L ; @@int64@@ = Number L ; @@BYTE@@ = @@BYTE@@ ; @@BYTE@@ = @@BYTE@@ ; while ( * @@BYTE@@ ) { if ( @@char@@ [ @@int64@@ ] == * @@BYTE@@ ) { ++ @@int64@@ ; ++ @@BYTE@@ ; if ( @@int64@@ == @@sizet@@ ) { * @@QWORD@@ = @@BYTE@@ ; break ; } } else if ( @@int64@@ ) { @@BYTE@@ += * ( _QWORD * ) ( Number * @@int64@@ + @@unsignedint64@@ ) ; @@int64@@ -= * ( _QWORD * ) ( Number * @@int64@@ + @@unsignedint64@@ ) ; } else { ++ @@BYTE@@ ; ++ @@BYTE@@ ; } } freea ( @@unsignedint64@@ ) ; return Number L ; }
bool __fastcall is_basic ( unsigned __int8 @@unsignedint8@@ ) { return ( ( * ( ( _DWORD * ) & is_basic_table + ( @@unsignedint8@@ >> Number ) ) >> ( @@unsignedint8@@ & Number ) ) & Number ) != Number ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
char * __fastcall decimal_ascii_add ( const char * @@constchar@@ , const char * @@constchar@@ ) { int @@int@@ ; char * @@char@@ ; char @@char@@ ; char * @@char@@ ; char @@char@@ ; _BOOL4 @@BOOL4@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; _BOOL4 @@BOOL4@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; char * @@char@@ ; const char * @@constchar@@ ; const char * @@constchar@@ ; char * @@char@@ ; @@int@@ = strlen ( @@constchar@@ ) ; @@int@@ = strlen ( @@constchar@@ ) ; @@int@@ = @@int@@ ; if ( @@int@@ >= @@int@@ ) @@int@@ = @@int@@ ; @@int@@ = @@int@@ + Number ; @@char@@ = ( char * ) xmalloc ( @@int@@ + Number ) ; @@char@@ = & @@char@@ [ @@int@@ - Number ] ; @@constchar@@ = & @@constchar@@ [ @@int@@ - Number ] ; @@constchar@@ = & @@constchar@@ [ @@int@@ - Number ] ; @@BOOL4@@ = Number ; for ( * @@char@@ = Number ; ; * @@char@@ = ( Number * @@BOOL4@@ + @@char@@ ) & Number | Number ) { if ( @@constchar@@ < @@constchar@@ ) { @@char@@ = Number ; } else if ( * @@constchar@@ == Number ) { @@char@@ = Number ; } else { @@char@@ = ( char * ) @@constchar@@ -- ; @@char@@ = * @@char@@ ; } @@char@@ = @@char@@ ; if ( @@constchar@@ < @@constchar@@ ) { @@char@@ = Number ; } else if ( * @@constchar@@ == Number ) { @@char@@ = Number ; } else { @@char@@ = ( char * ) @@constchar@@ -- ; @@char@@ = * @@char@@ ; } @@char@@ = @@char@@ ; @@char@@ = @@char@@ + @@char@@ + @@BOOL4@@ ; if ( ( unsigned __int8 ) c_isdigit ( ( unsigned int ) @@char@@ ) != Number && ( unsigned __int8 ) c_isdigit ( ( unsigned int ) @@char@@ ) != Number && ! @@BOOL4@@ ) { break ; } @@BOOL4@@ = @@char@@ > Number || @@char@@ == Number ; @@BOOL4@@ = @@BOOL4@@ ; -- @@char@@ ; } if ( @@constchar@@ >= @@constchar@@ && * @@constchar@@ == Number || @@constchar@@ >= @@constchar@@ && * @@constchar@@ == Number ) { * -- @@char@@ = Number ; } if ( @@char@@ != @@char@@ ) memmove ( @@char@@ , @@char@@ , @@int@@ - ( @@char@@ - @@char@@ ) ) ; return @@char@@ ; }
__int64 __fastcall squeeze_filter ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 ( __fastcall * @ @ VAR_283 @ @ int64 ( fastcall ) ( int64 , int64 ) @ @ sizet ( ) ( char , sizet ) ) ( __int64 , __int64 ) ) { __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = Number ; @@unsignedint64@@ = Number L ; @@unsignedint64@@ = Number L ; while ( Number ) { if ( @@unsignedint64@@ < @@unsignedint64@@ ) goto LABEL_5 ; @@int64@@ = @ @ VAR_283 @ @ int64 ( fastcall ) ( int64 , int64 ) @ @ sizet ( ) ( char , sizet ) ( @@int64@@ , @@int64@@ ) ; @@unsignedint64@@ = @@int64@@ ; if ( ! @@int64@@ ) return @@int64@@ ; @@unsignedint64@@ = Number L ; LABEL_5 : @@unsignedint64@@ = @@unsignedint64@@ ; if ( @@int@@ == Number ) { while ( @@unsignedint64@@ < @@unsignedint64@@ && in_squeeze_set [ ( unsigned __int8 ) to_uchar ( * ( _BYTE * ) ( @@int64@@ + @@unsignedint64@@ ) ) ] != Number ) @@unsignedint64@@ += Number L ; if ( @@unsignedint64@@ == @@unsignedint64@@ && in_squeeze_set [ ( unsigned __int8 ) to_uchar ( * ( _BYTE * ) ( @@unsignedint64@@ - Number + @@int64@@ ) ) ] ) { -- @@unsignedint64@@ ; } if ( @@unsignedint64@@ < @@unsignedint64@@ ) { @@int@@ = * ( char * ) ( @@int64@@ + @@unsignedint64@@ ) ; @@int64@@ = @@unsignedint64@@ - @@unsignedint64@@ + Number ; if ( @@unsignedint64@@ && @@int@@ == * ( char * ) ( @@unsignedint64@@ - Number + @@int64@@ ) ) { @@int64@@ = @@unsignedint64@@ - @@unsignedint64@@ ; } ++ @@unsignedint64@@ ; } else { @@int64@@ = @@unsignedint64@@ - @@unsignedint64@@ ; } if ( @@int64@@ && @@int64@@ != fwrite_unlocked ( ( const void * ) ( @@int64@@ + @@unsignedint64@@ ) , Number , @@int64@@ , stdout ) ) { @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ ) ; } } if ( @@int@@ != Number ) { while ( @@unsignedint64@@ < @@unsignedint64@@ && @@int@@ == * ( char * ) ( @@int64@@ + @@unsignedint64@@ ) ) ++ @@unsignedint64@@ ; if ( @@unsignedint64@@ < @@unsignedint64@@ ) @@int@@ = Number ; } } }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
bool __fastcall is_basic_0 ( unsigned __int8 @@unsignedint8@@ ) { return ( ( * ( ( _DWORD * ) & is_basic_table + ( @@unsignedint8@@ >> Number ) ) >> ( @@unsignedint8@@ & Number ) ) & Number ) != Number ; }
__int64 __fastcall c_tolower ( int @@int@@ ) { __int64 @@int64@@ ; if ( @@int@@ <= Number || @@int@@ > Number ) @@int64@@ = ( unsigned int ) @@int@@ ; else @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; return @@int64@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_20D3C8 ; @@int648@@ [ Number ] = qword_20D3D0 ; @@int648@@ [ Number ] = qword_20D3D8 ; @@int648@@ [ Number ] = qword_20D3E0 ; @@int648@@ [ Number ] = qword_20D3E8 ; @@int648@@ [ Number ] = qword_20D3F0 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
char * __fastcall proper_name_utf8 ( const char * @@constchar@@ , __int64 @@int64@@ ) { char * @@char@@ ; char * @@char@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; char * @@char@@ ; char * @@char@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; size_t @@sizet@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; @@char@@ = ( char * ) locale_charset ( ) ; @@char@@ = Number L ; @@char@@ = Number L ; @@int64@@ = Number L ; if ( ( unsigned int ) c_strcasecmp ( @@char@@ , String ) ) { @@char@@ = ( char * ) xstr_iconv ( @@int64@@ , String , @@char@@ ) ; @@int64@@ = ( __int64 ) @@char@@ ; @@sizet@@ = strlen ( @@char@@ ) ; @@char@@ = ( char * ) xmalloc ( @@sizet@@ + Number ) ; memcpy ( @@char@@ , @@char@@ , @@sizet@@ ) ; memcpy ( & @@char@@ [ @@sizet@@ ] , String , Number ) ; @@char@@ = ( char * ) xstr_iconv ( @@int64@@ , String , @@char@@ ) ; free ( @@char@@ ) ; if ( @@char@@ ) { if ( strchr ( @@char@@ , Number ) ) { free ( @@char@@ ) ; } else { @@char@@ = @@char@@ ; @@int64@@ = ( __int64 ) @@char@@ ; } } } else { @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; } if ( @@int64@@ ) { @@char@@ = ( char * ) @@int64@@ ; } else if ( @@int64@@ ) { @@char@@ = ( char * ) @@int64@@ ; } else { @@char@@ = ( char * ) @@constchar@@ ; } @@char@@ = @@char@@ ; if ( ! strcmp ( @@char@@ , @@constchar@@ ) ) { if ( @@char@@ && @@char@@ != @@char@@ ) free ( @@char@@ ) ; if ( @@char@@ && @@char@@ != @@char@@ ) free ( @@char@@ ) ; @@char@@ = @@char@@ ; } else if ( ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@char@@ , ( __int64 ) @@constchar@@ ) || @@int64@@ && ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@char@@ , @@int64@@ ) || @@int64@@ && ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@char@@ , @@int64@@ ) ) { if ( @@char@@ ) free ( @@char@@ ) ; if ( @@char@@ ) free ( @@char@@ ) ; @@char@@ = @@char@@ ; } else { @@sizet@@ = strlen ( @@char@@ ) ; @@sizet@@ = strlen ( @@char@@ ) ; @@char@@ = ( char * ) xmalloc ( @@sizet@@ + @@sizet@@ + Number ) ; sprintf ( @@char@@ , String , @@char@@ , @@char@@ ) ; if ( @@char@@ ) free ( @@char@@ ) ; if ( @@char@@ ) free ( @@char@@ ) ; @@char@@ = @@char@@ ; } return @@char@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
__int64 __fastcall print_group ( __gid_t @@gidt@@ , char @@char@@ ) { char * @@char@@ ; unsigned __int8 @@unsignedint8@@ ; struct group * @@structgroup@@ ; @@structgroup@@ = Number L ; @@unsignedint8@@ = Number ; if ( @@char@@ ) { @@structgroup@@ = getgrgid ( @@gidt@@ ) ; if ( ! @@structgroup@@ ) { @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ , @@gidt@@ ) ; @@unsignedint8@@ = Number ; } } if ( @@structgroup@@ ) printf ( String , @@structgroup@@ -> gr_name ) ; else printf ( String , @@gidt@@ ) ; return @@unsignedint8@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
void * __fastcall mdir_name ( _BYTE * @@BYTE@@ ) { _BYTE * @@BYTE@@ ; void * @@void@@ ; @@BYTE@@ = dir_len ( @@BYTE@@ ) ; @@void@@ = malloc ( ( size_t ) & @@BYTE@@ [ ( @@BYTE@@ == Number L ) + Number ] ) ; if ( ! @@void@@ ) return Number L ; memcpy ( @@void@@ , @@BYTE@@ , ( size_t ) @@BYTE@@ ) ; if ( ! @@BYTE@@ ) { @@BYTE@@ = ( _BYTE * ) ( & dword_0 + Number ) ; * ( _BYTE * ) @@void@@ = Number ; } @@BYTE@@ [ ( _QWORD ) @@void@@ ] = Number ; return @@void@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ ) { return xmalloc ( @@int64@@ ) ; }
__int64 __fastcall getugroups ( int @@int@@ , _DWORD * @@DWORD@@ , const char * @@constchar@@ , int @@int@@ ) { int @@int@@ ; int @@int@@ ; int @@int@@ ; const char * * @@constchar@@ ; struct group * @@structgroup@@ ; @@int@@ = Number ; if ( @@int@@ != Number ) { if ( @@int@@ ) * @@DWORD@@ = @@int@@ ; @@int@@ = Number ; } setgrent ( ) ; while ( Number ) { * __errno_location ( ) = Number ; @@structgroup@@ = getgrent ( ) ; if ( ! @@structgroup@@ ) break ; for ( @@constchar@@ = ( const char * * ) @@structgroup@@ -> gr_mem ; * @@constchar@@ ; ++ @@constchar@@ ) { if ( ! strcmp ( @@constchar@@ , * @@constchar@@ ) ) { for ( @@int@@ = Number ; @@int@@ < @@int@@ && ( ! @@DWORD@@ || @@DWORD@@ [ @@int@@ ] != @@structgroup@@ -> gr_gid ) ; ++ @@int@@ ) { ; } if ( @@int@@ == @@int@@ ) { if ( @@int@@ ) { if ( @@int@@ >= @@int@@ ) goto LABEL_26 ; @@DWORD@@ [ @@int@@ ] = @@structgroup@@ -> gr_gid ; } if ( @@int@@ == Number ) { * __errno_location ( ) = Number ; goto LABEL_26 ; } ++ @@int@@ ; } } } } if ( * __errno_location ( ) ) @@int@@ = Number ; LABEL_26 : @@int@@ = * __errno_location ( ) ; endgrent ( ) ; * __errno_location ( ) = @@int@@ ; return ( unsigned int ) @@int@@ ; }
void * __fastcall realloc_groupbuf ( void * @@void@@ , unsigned __int64 @@unsignedint64@@ ) { if ( @@unsignedint64@@ <= Number ) return realloc ( @@void@@ , Number * @@unsignedint64@@ ) ; * __errno_location ( ) = Number ; return Number L ; }
__int64 __fastcall xnrealloc ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { if ( ! is_mul_ok ( @@unsignedint64@@ , @@unsignedint64@@ ) ) xalloc_die ( ) ; return xrealloc ( @@int64@@ , @@unsignedint64@@ * @@unsignedint64@@ ) ; }
bool __fastcall is_basic_1 ( unsigned __int8 @@unsignedint8@@ ) { return ( ( is_basic_table [ @@unsignedint8@@ >> Number ] >> ( @@unsignedint8@@ & Number ) ) & Number ) != Number ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
void * __fastcall initbuffer ( void * @@void@@ ) { return memset ( @@void@@ , Number , Number ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
const char * locale_charset ( ) { const char * @@constchar@@ ; char * @@char@@ ; char * @@char@@ ; @@constchar@@ = nl_langinfo ( Number ) ; if ( ! @@constchar@@ ) @@constchar@@ = ( const char * ) & unk_9975 ; for ( @@char@@ = ( char * ) get_charset_aliases ( ) ; * @@char@@ ; @@char@@ = & @@char@@ [ strlen ( @@char@@ ) + Number ] ) { if ( ! strcmp ( @@constchar@@ , @@char@@ ) || * @@char@@ == Number && ! @@char@@ [ Number ] ) { @@constchar@@ = & @@char@@ [ strlen ( @@char@@ ) + Number ] ; break ; } @@char@@ = & @@char@@ [ strlen ( @@char@@ ) + Number ] ; } if ( ! * @@constchar@@ ) @@constchar@@ = String ; return @@constchar@@ ; }
__int64 __fastcall knuth_morris_pratt_unibyte ( _BYTE * @@BYTE@@ , char * @@char@@ , _QWORD * @@QWORD@@ ) { void * @@void@@ ; unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; char * @@char@@ ; _BYTE * @@BYTE@@ ; char @@char@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; size_t @@sizet@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@BYTE@@ = @@BYTE@@ ; @@char@@ = @@char@@ ; @@QWORD@@ = @@QWORD@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@sizet@@ = strlen ( @@char@@ ) ; if ( @@sizet@@ > Number ) { @@unsignedint64@@ = Number L ; } else if ( Number * @@sizet@@ > Number ) { @@unsignedint64@@ = mmalloca ( Number * @@sizet@@ ) ; } else { @@void@@ = alloca ( Number * ( ( Number * ( @@sizet@@ + Number ) + Number ) / Number ) ) ; @@unsignedint64@@ = Number * ( ( ( unsigned __int64 ) & @@QWORD@@ + Number ) >> Number ) + Number ; } @@unsignedint64@@ = @@unsignedint64@@ ; if ( ! @@unsignedint64@@ ) return Number L ; * ( _QWORD * ) ( @@unsignedint64@@ + Number ) = Number L ; @@int64@@ = Number L ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@sizet@@ ; ++ @@unsignedint64@@ ) { @@char@@ = @@char@@ [ @@unsignedint64@@ - Number ] ; while ( Number ) { if ( @@char@@ == @@char@@ [ @@int64@@ ] ) { ++ @@int64@@ ; * ( _QWORD * ) ( @@unsignedint64@@ + Number * @@unsignedint64@@ ) = @@unsignedint64@@ - @@int64@@ ; goto LABEL_15 ; } if ( ! @@int64@@ ) break ; @@int64@@ -= * ( _QWORD * ) ( Number * @@int64@@ + @@unsignedint64@@ ) ; } * ( _QWORD * ) ( @@unsignedint64@@ + Number * @@unsignedint64@@ ) = @@unsignedint64@@ ; LABEL_15 : ; } * @@QWORD@@ = Number L ; @@int64@@ = Number L ; @@BYTE@@ = @@BYTE@@ ; @@BYTE@@ = @@BYTE@@ ; while ( * @@BYTE@@ ) { if ( @@char@@ [ @@int64@@ ] == * @@BYTE@@ ) { ++ @@int64@@ ; ++ @@BYTE@@ ; if ( @@int64@@ == @@sizet@@ ) { * @@QWORD@@ = @@BYTE@@ ; break ; } } else if ( @@int64@@ ) { @@BYTE@@ += * ( _QWORD * ) ( Number * @@int64@@ + @@unsignedint64@@ ) ; @@int64@@ -= * ( _QWORD * ) ( Number * @@int64@@ + @@unsignedint64@@ ) ; } else { ++ @@BYTE@@ ; ++ @@BYTE@@ ; } } freea ( @@unsignedint64@@ ) ; return Number L ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
__int64 __fastcall bad_cast ( __int64 @@int64@@ ) { return @@int64@@ ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
unsigned __int64 __fastcall mmalloca ( unsigned __int64 @@unsignedint64@@ ) { char * @@char@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@unsignedint64@@ + Number < @@unsignedint64@@ ) return Number L ; @@char@@ = ( char * ) malloc ( @@unsignedint64@@ + Number ) ; if ( ! @@char@@ ) return Number L ; @@unsignedint64@@ = ( unsigned __int64 ) ( @@char@@ + Number ) ; * ( _DWORD * ) ( @@unsignedint64@@ - Number ) = Number ; * ( _QWORD * ) ( @@unsignedint64@@ - Number ) = mmalloca_results [ @@unsignedint64@@ % Number ] ; mmalloca_results [ @@unsignedint64@@ % Number ] = @@unsignedint64@@ ; return @@unsignedint64@@ ; }
__int64 __fastcall get_stat_atime ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
__int64 * __fastcall readlinebuffer_delim ( __int64 * @@int64@@ , FILE * @@FILE@@ , char @@char@@ ) { _BYTE * @@BYTE@@ ; int @@int@@ ; __int64 @@int64@@ ; _BYTE * @@BYTE@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = @@int64@@ [ Number ] ; @@BYTE@@ = ( _BYTE * ) @@int64@@ ; @@int64@@ = * @@int64@@ + @@int64@@ ; if ( feof_unlocked ( @@FILE@@ ) ) return Number L ; while ( Number ) { @@int@@ = getc_unlocked ( @@FILE@@ ) ; if ( @@int@@ == Number ) break ; LABEL_9 : if ( @@BYTE@@ == ( _BYTE * ) @@int64@@ ) { @@int64@@ = * @@int64@@ ; @@int64@@ = x2realloc ( @@int64@@ , @@int64@@ ) ; @@BYTE@@ = ( _BYTE * ) ( @@int64@@ + @@int64@@ ) ; @@int64@@ [ Number ] = @@int64@@ ; @@int64@@ = * @@int64@@ + @@int64@@ ; } @@BYTE@@ = @@BYTE@@ ++ ; * @@BYTE@@ = @@int@@ ; if ( @@int@@ == @@char@@ ) goto LABEL_12 ; } if ( @@BYTE@@ == ( _BYTE * ) @@int64@@ || ferror_unlocked ( @@FILE@@ ) ) return Number L ; if ( @@char@@ != * ( @@BYTE@@ - Number ) ) { @@int@@ = @@char@@ ; goto LABEL_9 ; } LABEL_12 : @@int64@@ [ Number ] = ( __int64 ) & @@BYTE@@ [ - @@int64@@ ] ; return @@int64@@ ; }
__int64 __fastcall get_stat_ctime ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
bool __fastcall is_basic_2 ( unsigned __int8 @@unsignedint8@@ ) { return ( ( is_basic_table [ @@unsignedint8@@ >> Number ] >> ( @@unsignedint8@@ & Number ) ) & Number ) != Number ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_208038 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall get_stat_mtime ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
unsigned __int64 __fastcall dev_ino_hash ( _QWORD * @@QWORD@@ , unsigned __int64 @@unsignedint64@@ ) { return * @@QWORD@@ % @@unsignedint64@@ ; }
size_t __fastcall mbslen ( const char * @@constchar@@ ) { __int64 @@int64@@ ; char @@char4@@ [ Number ] ; int @@int@@ ; char @@char@@ ; const char * @@constchar@@ ; __int64 @@int64@@ ; char @@char@@ ; int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( __ctype_get_mb_cur_max ( ) <= Number ) return strlen ( @@constchar@@ ) ; @@int64@@ = Number L ; @@constchar@@ = @@constchar@@ ; @@char4@@ [ Number ] = Number ; memset ( & @@int@@ , Number , Number ) ; for ( @@char@@ = Number ; ; @@char@@ = Number ) { mbuiter_multi_next_1 ( ( __int64 ) @@char4@@ ) ; if ( @@char@@ == Number && ! @@int@@ ) break ; ++ @@int64@@ ; @@constchar@@ += @@int64@@ ; } return @@int64@@ ; }
bool __fastcall is_basic_1 ( unsigned __int8 @@unsignedint8@@ ) { return ( ( * ( ( _DWORD * ) & is_basic_table + ( @@unsignedint8@@ >> Number ) ) >> ( @@unsignedint8@@ & Number ) ) & Number ) != Number ; }
__int64 __fastcall readlinebuffer ( __int64 @@int64@@ , __int64 @@int64@@ ) { return readlinebuffer_delim ( @@int64@@ , @@int64@@ , Number L ) ; }
_BOOL8 __fastcall dev_ino_compare ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ ) { return * @@QWORD@@ == * @@QWORD@@ && @@QWORD@@ [ Number ] == @@QWORD@@ [ Number ] ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
_BOOL8 __fastcall is_colored ( unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; char * @@char@@ ; @@int64@@ = * ( ( _QWORD * ) & color_indicator + Number * @@unsignedint@@ ) ; @@char@@ = ( char * ) * ( & off_21F088 + Number * @@unsignedint@@ ) ; return @@int64@@ && ( @@int64@@ != Number || * @@char@@ != Number ) && ( @@int64@@ != Number || strncmp ( @@char@@ , off_16E97 , Number ) ) ; }
__int64 posix2_version ( ) { __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = Number L ; @@char@@ = getenv ( String ) ; if ( @@char@@ ) { if ( * @@char@@ ) { @@int64@@ = strtol ( @@char@@ , & @@char@@ , Number ) ; if ( ! * @@char@@ ) @@int64@@ = @@int64@@ ; } } if ( @@int64@@ < ( __int64 ) Number ) return Number ; @@int64@@ = Number ; if ( @@int64@@ <= Number ) @@int64@@ = @@int64@@ ; return @@int64@@ ; }
unsigned __int64 process_signals ( ) { int @@int@@ ; sigset_t @@sigsett@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; while ( interrupt_signal || stop_signal_count ) { if ( used_color ) restore_default_color ( ) ; fflush_unlocked ( stdout ) ; sigprocmask ( Number , & caught_signals , & @@sigsett@@ ) ; @@int@@ = interrupt_signal ; if ( stop_signal_count ) { -- stop_signal_count ; raise ( Number ) ; } else { signal ( interrupt_signal , Number L ) ; raise ( @@int@@ ) ; } sigprocmask ( Number , & @@sigsett@@ , Number L ) ; } return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall argmatch ( const char * @@constchar@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { __int64 @@int64@@ ; char @@char@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; size_t @@sizet@@ ; @@int64@@ = Number ; @@char@@ = Number ; @@sizet@@ = strlen ( @@constchar@@ ) ; for ( @@int64@@ = Number L ; * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; ++ @@int64@@ ) { if ( ! strncmp ( * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) , @@constchar@@ , @@sizet@@ ) ) { if ( @@sizet@@ == strlen ( * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) ) ) return @@int64@@ ; if ( @@int64@@ == Number ) { @@int64@@ = @@int64@@ ; } else if ( ! @@int64@@ || memcmp ( ( const void * ) ( @@sizet@@ * @@int64@@ + @@int64@@ ) , ( const void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) , @@sizet@@ ) ) { @@char@@ = Number ; } } } if ( @@char@@ ) @@int64@@ = Number ; else @@int64@@ = @@int64@@ ; return @@int64@@ ; }
__int64 __fastcall mem_cd_iconv ( char * @@char@@ , size_t @@sizet@@ , void * @@void@@ , void * * @@void@@ , size_t * @@sizet@@ ) { int @@int@@ ; char * @@char@@ ; size_t @@sizet@@ ; char * @@char@@ ; size_t @@sizet@@ ; void * @@void@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; char @@char@@ $D1F1B2789FC85C59BE59CF61C76BFA1E [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; iconv ( @@void@@ , Number L , Number L , Number L , Number L ) ; @@sizet@@ = Number L ; @@char@@ = @@char@@ ; @@sizet@@ = @@sizet@@ ; while ( @@sizet@@ ) { @@char@@ = @@char@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; @@sizet@@ = Number L ; @@sizet@@ = iconv ( @@void@@ , & @@char@@ , & @@sizet@@ , & @@char@@ , & @@sizet@@ ) ; if ( @@sizet@@ == Number && * __errno_location ( ) != Number ) { if ( * __errno_location ( ) != Number ) return Number ; break ; } @@sizet@@ += @@char@@ - @@char@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; } @@char@@ = @@char@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; @@sizet@@ = Number L ; @@sizet@@ = iconv ( @@void@@ , Number L , Number L , & @@char@@ , & @@sizet@@ ) ; if ( @@sizet@@ == Number ) return Number ; @@sizet@@ += @@char@@ - @@char@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; @@sizet@@ = @@sizet@@ ; if ( ! @@sizet@@ ) { * @@sizet@@ = Number L ; return Number L ; } if ( * @@void@@ && @@sizet@@ <= * @@sizet@@ ) { @@void@@ = * @@void@@ ; } else { @@void@@ = malloc ( @@sizet@@ ) ; if ( ! @@void@@ ) { * __errno_location ( ) = Number ; return Number ; } } iconv ( @@void@@ , Number L , Number L , Number L , Number L ) ; @@char@@ = @@char@@ ; @@sizet@@ = @@sizet@@ ; @@char@@ = ( char * ) @@void@@ ; @@sizet@@ = @@sizet@@ ; while ( @@sizet@@ ) { @@sizet@@ = iconv ( @@void@@ , & @@char@@ , & @@sizet@@ , & @@char@@ , & @@sizet@@ ) ; if ( @@sizet@@ == Number ) { if ( * __errno_location ( ) != Number ) goto LABEL_26 ; break ; } } @@sizet@@ = iconv ( @@void@@ , Number L , Number L , & @@char@@ , & @@sizet@@ ) ; if ( @@sizet@@ != Number ) { if ( @@sizet@@ ) abort ( ) ; * @@void@@ = @@void@@ ; * @@sizet@@ = @@sizet@@ ; return Number L ; } LABEL_26 : if ( @@void@@ != * @@void@@ ) { @@int@@ = * __errno_location ( ) ; free ( @@void@@ ) ; * __errno_location ( ) = @@int@@ ; } return Number ; }
_QWORD * __fastcall add_ignore_pattern ( __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) xmalloc ( Number L ) ; * @@QWORD@@ = @@int64@@ ; @@QWORD@@ [ Number ] = ignore_patterns ; ignore_patterns = ( __int64 ) @@QWORD@@ ; return @@QWORD@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
__int64 __fastcall unsigned_file_size ( __int64 @@int64@@ ) { return @@int64@@ ; }
_BOOL8 __fastcall basename_is_dot_or_dotdot ( __int64 @@int64@@ ) { _BYTE * @@BYTE@@ ; @@BYTE@@ = ( _BYTE * ) last_component ( @@int64@@ ) ; return dot_or_dotdot ( @@BYTE@@ ) ; }
FILE * __fastcall freopen_safer ( const char * @@constchar@@ , const char * @@constchar@@ , FILE * @@FILE@@ ) { int @@int@@ ; FILE * @@FILE@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; int @@int@@ ; @@char@@ = Number ; @@char@@ = Number ; @@char@@ = Number ; @@int@@ = fileno ( @@FILE@@ ) ; if ( @@int@@ != Number ) { if ( @@int@@ != Number ) { if ( ! @@int@@ ) goto LABEL_10 ; if ( dup2 ( Number , Number ) != Number ) @@char@@ = Number ; } if ( dup2 ( Number , Number ) != Number ) @@char@@ = Number ; } if ( dup2 ( Number , Number ) ) @@char@@ = Number ; LABEL_10 : if ( @@char@@ && ( unsigned __int8 ) protect_fd ( Number ) != Number ) { @@FILE@@ = Number L ; } else if ( @@char@@ && ( unsigned __int8 ) protect_fd ( Number ) != Number ) { @@FILE@@ = Number L ; } else if ( @@char@@ && ( unsigned __int8 ) protect_fd ( Number ) != Number ) { @@FILE@@ = Number L ; } else { @@FILE@@ = freopen ( @@constchar@@ , @@constchar@@ , @@FILE@@ ) ; } @@int@@ = * __errno_location ( ) ; if ( @@char@@ ) close ( Number ) ; if ( @@char@@ ) close ( Number ) ; if ( @@char@@ ) close ( Number ) ; if ( ! @@FILE@@ ) * __errno_location ( ) = @@int@@ ; return @@FILE@@ ; }
bool __fastcall is_basic ( unsigned __int8 @@unsignedint8@@ ) { return ( ( is_basic_table [ @@unsignedint8@@ >> Number ] >> ( @@unsignedint8@@ & Number ) ) & Number ) != Number ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall cmp_ctime ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ , __int64 ( __fastcall * @ @ VAR_490 @ @ int64 ( fastcall ) ( QWORD , QWORD ) @ @ int ( ) ( constchar , constchar ) ) ( _QWORD , _QWORD ) ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = get_stat_ctime ( ( __int64 ) ( @@QWORD@@ + Number ) ) ; @@int64@@ = @@int64@@ ; @@int64@@ = get_stat_ctime ( ( __int64 ) ( @@QWORD@@ + Number ) ) ; @@unsignedint@@ = timespec_cmp ( @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( @@unsignedint@@ ) @@int64@@ = @@unsignedint@@ ; else @@int64@@ = @ @ VAR_490 @ @ int64 ( fastcall ) ( QWORD , QWORD ) @ @ int ( ) ( constchar , constchar ) ( * @@QWORD@@ , * @@QWORD@@ ) ; return @@int64@@ ; }
__int64 clear_files ( ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; void * * @@void@@ ; for ( @@unsignedint64@@ = Number L ; ; ++ @@unsignedint64@@ ) { @@int64@@ = cwd_n_used ; if ( @@unsignedint64@@ >= cwd_n_used ) break ; @@void@@ = ( void * * ) * ( ( _QWORD * ) sorted_file + @@unsignedint64@@ ) ; free ( * @@void@@ ) ; free ( @@void@@ [ Number ] ) ; if ( @@void@@ [ Number ] != & UNKNOWN_SECURITY_CONTEXT ) freecon ( ) ; } cwd_n_used = Number L ; any_has_acl = Number ; inode_number_width = Number ; block_size_width = Number ; nlink_width = Number ; owner_width = Number ; group_width = Number ; author_width = Number ; scontext_width = Number ; major_device_number_width = Number ; minor_device_number_width = Number ; file_size_width = Number ; return @@int64@@ ; }
bool __fastcall is_basic_0 ( unsigned __int8 @@unsignedint8@@ ) { return ( ( is_basic_table [ @@unsignedint8@@ >> Number ] >> ( @@unsignedint8@@ & Number ) ) & Number ) != Number ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall xstr_cd_iconv ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = str_cd_iconv ( @@int64@@ , @@int64@@ ) ; if ( ! @@int64@@ && * __errno_location ( ) == Number ) xalloc_die ( ) ; return @@int64@@ ; }
__int64 __fastcall cmp_size ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ , __int64 ( __fastcall * @ @ VAR_514 @ @ int64 ( fastcall ) ( QWORD , QWORD ) @ @ int ( ) ( constchar , constchar ) ) ( _QWORD , _QWORD ) ) { __int64 @@int64@@ ; if ( @@QWORD@@ [ Number ] < @@QWORD@@ [ Number ] ) LODWORD ( @@int64@@ ) = Number ; else LODWORD ( @@int64@@ ) = @@QWORD@@ [ Number ] > @@QWORD@@ [ Number ] ; if ( ( _DWORD ) @@int64@@ ) @@int64@@ = ( unsigned int ) @@int64@@ ; else @@int64@@ = @ @ VAR_514 @ @ int64 ( fastcall ) ( QWORD , QWORD ) @ @ int ( ) ( constchar , constchar ) ( * @@QWORD@@ , * @@QWORD@@ ) ; return @@int64@@ ; }
__int64 __fastcall cmp_atime ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ , __int64 ( __fastcall * @ @ VAR_510 @ @ int64 ( fastcall ) ( QWORD , QWORD ) @ @ int ( ) ( constchar , constchar ) ) ( _QWORD , _QWORD ) ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = get_stat_atime ( ( __int64 ) ( @@QWORD@@ + Number ) ) ; @@int64@@ = @@int64@@ ; @@int64@@ = get_stat_atime ( ( __int64 ) ( @@QWORD@@ + Number ) ) ; @@unsignedint@@ = timespec_cmp ( @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( @@unsignedint@@ ) @@int64@@ = @@unsignedint@@ ; else @@int64@@ = @ @ VAR_510 @ @ int64 ( fastcall ) ( QWORD , QWORD ) @ @ int ( ) ( constchar , constchar ) ( * @@QWORD@@ , * @@QWORD@@ ) ; return @@int64@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_209038 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
__int64 print_current_files ( ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int64@@ = ( unsigned int ) format ; switch ( format ) { case Number : for ( @@unsignedint64@@ = Number L ; ; ++ @@unsignedint64@@ ) { @@int64@@ = cwd_n_used ; if ( @@unsignedint64@@ >= cwd_n_used ) break ; print_long_format ( * ( ( _QWORD * ) sorted_file + @@unsignedint64@@ ) ) ; putchar_unlocked ( Number ) ; ++ dired_pos ; } break ; case Number : for ( @@unsignedint64@@ = Number L ; ; ++ @@unsignedint64@@ ) { @@int64@@ = cwd_n_used ; if ( @@unsignedint64@@ >= cwd_n_used ) break ; print_file_name_and_frills ( * ( ( _QWORD * ) sorted_file + @@unsignedint64@@ ) , Number L ) ; putchar_unlocked ( Number ) ; } break ; case Number : @@int64@@ = print_many_per_line ( ) ; break ; case Number : @@int64@@ = print_horizontal ( ) ; break ; case Number : @@int64@@ = print_with_commas ( ) ; break ; default : return @@int64@@ ; } return @@int64@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall align_nstrftime ( __int64 @@int64@@ , __int64 @@int64@@ , const char * @@constchar@@ , __int64 @@int64@@ , unsigned int @@unsignedint@@ , unsigned int @@unsignedint@@ ) { char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@char@@ = ( char * ) @@constchar@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@char@@ = ( char * ) @@constchar@@ ; if ( required_mon_width ) { @@char@@ = strstr ( @@constchar@@ , needle ) ; if ( @@char@@ ) { if ( strlen ( @@char@@ ) <= Number ) { @@char@@ = @@char@@ ; @@char@@ = ( char * ) mempcpy ( @@char@@ , @@char@@ , @@char@@ - @@char@@ ) ; @@char@@ = stpcpy ( @@char@@ , & abmon [ Number * * ( int * ) ( @@int64@@ + Number ) ] ) ; strcpy ( @@char@@ , @@char@@ + Number ) ; } } } return nstrftime ( @@int64@@ , @@int64@@ , @@char@@ , @@int64@@ , @@unsignedint@@ , @@unsignedint@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return xmalloc ( @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
size_t __fastcall format_user_or_group_width ( __int64 @@int64@@ , __int64 @@int64@@ ) { size_t @@sizet@@ ; int @@int@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( @@int64@@ ) { @@int@@ = gnu_mbswidth ( @@int64@@ , Number L ) ; @@sizet@@ = Number L ; if ( @@int@@ >= Number ) @@sizet@@ = ( unsigned int ) @@int@@ ; } else { sprintf ( @@char@@ , String , @@int64@@ ) ; @@sizet@@ = strlen ( @@char@@ ) ; } return @@sizet@@ ; }
__int64 __fastcall format_group ( unsigned int @@unsignedint@@ , int @@int@@ , char @@char@@ ) { const char * @@constchar@@ ; if ( @@char@@ != Number ) { @@constchar@@ = String ; } else if ( numeric_ids ) { @@constchar@@ = Number L ; } else { @@constchar@@ = ( const char * ) getgroup ( @@unsignedint@@ ) ; } return format_user_or_group ( @@constchar@@ , @@unsignedint@@ , @@int@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_2060C8 ; @@int648@@ [ Number ] = qword_2060D0 ; @@int648@@ [ Number ] = qword_2060D8 ; @@int648@@ [ Number ] = qword_2060E0 ; @@int648@@ [ Number ] = qword_2060E8 ; @@int648@@ [ Number ] = qword_2060F0 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
size_t __fastcall put_indicator ( __int64 @@int64@@ ) { if ( used_color != Number ) { used_color = Number ; prep_non_filename_text ( ) ; } return fwrite_unlocked ( * ( const void * * ) ( @@int64@@ + Number ) , * ( _QWORD * ) @@int64@@ , Number , stdout ) ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
size_t __fastcall print_file_name_and_frills ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { const char * @@constchar@@ ; int @@int@@ ; const char * @@constchar@@ ; int @@int@@ ; int @@int@@ ; size_t @@sizet@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( print_inode ) { @@constchar@@ = format_inode ( ( __int64 ) @@char@@ , Number , @@int64@@ ) ; if ( format == Number ) @@int@@ = Number ; else @@int@@ = inode_number_width ; printf ( String , @@int@@ , @@constchar@@ ) ; } if ( print_block_size ) { if ( * ( _BYTE * ) ( @@int64@@ + Number ) != Number ) @@constchar@@ = String ; else @@constchar@@ = ( const char * ) human_readable ( * ( _QWORD * ) ( @@int64@@ + Number ) , @@char@@ , ( unsigned int ) human_output_opts , Number L , output_block_size ) ; if ( format == Number ) @@int@@ = Number ; else @@int@@ = block_size_width ; printf ( String , @@int@@ , @@constchar@@ ) ; } if ( print_scontext ) { if ( format == Number ) @@int@@ = Number ; else @@int@@ = scontext_width ; printf ( String , @@int@@ , * ( const char * * ) ( @@int64@@ + Number ) ) ; } @@sizet@@ = print_name_with_quoting ( ( __int64 * ) @@int64@@ , Number , Number L , @@unsignedint64@@ ) ; if ( indicator_style ) @@sizet@@ += ( unsigned __int8 ) print_type_indicator ( * ( unsigned __int8 * ) ( @@int64@@ + Number ) , * ( unsigned int * ) ( @@int64@@ + Number ) , * ( unsigned int * ) ( @@int64@@ + Number ) ) ; return @@sizet@@ ; }
void * __fastcall realloc_groupbuf ( void * @@void@@ , unsigned __int64 @@unsignedint64@@ ) { if ( @@unsignedint64@@ <= Number ) return realloc ( @@void@@ , Number * @@unsignedint64@@ ) ; * __errno_location ( ) = Number ; return Number L ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_206028 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
unsigned __int64 print_many_per_line ( ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; @@unsignedint64@@ = calculate_columns ( Number L ) ; @@int64@@ = column_info + Number * @@unsignedint64@@ - Number ; @@unsignedint64@@ = cwd_n_used / @@unsignedint64@@ + ( cwd_n_used % @@unsignedint64@@ != Number ) ; for ( @@unsignedint64@@ = Number L ; ; ++ @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ ; if ( @@unsignedint64@@ >= @@unsignedint64@@ ) break ; @@int64@@ = Number L ; @@unsignedint64@@ = @@unsignedint64@@ ; for ( @@unsignedint64@@ = Number L ; ; @@unsignedint64@@ += @@int64@@ ) { @@int64@@ = * ( ( _QWORD * ) sorted_file + @@unsignedint64@@ ) ; @@int64@@ = length_of_file_name_and_frills ( @@int64@@ ) ; @@int64@@ = @@int64@@ ++ ; @@int64@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ ) ; print_file_name_and_frills ( @@int64@@ , @@unsignedint64@@ ) ; @@unsignedint64@@ += @@unsignedint64@@ ; if ( @@unsignedint64@@ >= cwd_n_used ) break ; indent ( @@unsignedint64@@ + @@int64@@ , @@int64@@ + @@unsignedint64@@ ) ; } putchar_unlocked ( Number ) ; } return @@unsignedint64@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
int print_with_commas ( ) { char @@char@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; @@unsignedint64@@ = Number L ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < cwd_n_used ; ++ @@unsignedint64@@ ) { @@int64@@ = * ( ( _QWORD * ) sorted_file + @@unsignedint64@@ ) ; @@int64@@ = length_of_file_name_and_frills ( @@int64@@ ) ; if ( @@unsignedint64@@ ) { if ( @@unsignedint64@@ + @@int64@@ + Number >= line_length ) { @@unsignedint64@@ = Number L ; @@char@@ = Number ; } else { @@unsignedint64@@ += Number L ; @@char@@ = Number ; } putchar_unlocked ( Number ) ; putchar_unlocked ( @@char@@ ) ; } print_file_name_and_frills ( @@int64@@ , @@unsignedint64@@ ) ; @@unsignedint64@@ += @@int64@@ ; } return putchar_unlocked ( Number ) ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
char * __fastcall areadlink_with_size ( const char * @@constchar@@ , unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; char * @@char@@ ; int @@int@@ ; size_t @@sizet@@ ; char * @@char@@ ; ssize_t @@ssizet@@ ; if ( @@unsignedint64@@ >= Number ) @@int64@@ = Number L ; else @@int64@@ = @@unsignedint64@@ + Number ; @@sizet@@ = @@int64@@ ; LABEL_5 : for ( @@char@@ = ( char * ) malloc ( @@sizet@@ ) ; ; @@char@@ = ( char * ) malloc ( Number ) ) { @@char@@ = @@char@@ ; if ( ! @@char@@ ) return Number L ; @@ssizet@@ = readlink ( @@constchar@@ , @@char@@ , @@sizet@@ ) ; if ( @@ssizet@@ < Number && * __errno_location ( ) != Number ) { @@int@@ = * __errno_location ( ) ; free ( @@char@@ ) ; * __errno_location ( ) = @@int@@ ; return Number L ; } if ( @@ssizet@@ < @@sizet@@ ) { @@char@@ [ @@ssizet@@ ] = Number ; return @@char@@ ; } free ( @@char@@ ) ; if ( @@sizet@@ <= Number ) { @@sizet@@ *= Number L ; goto LABEL_5 ; } if ( @@sizet@@ > Number ) break ; @@sizet@@ = Number ; } * __errno_location ( ) = Number ; return Number L ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
unsigned __int64 init_column_info ( ) { unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = max_idx ; if ( cwd_n_used <= ( unsigned __int64 ) max_idx ) @@unsignedint64@@ = cwd_n_used ; @@unsignedint64@@ = @@unsignedint64@@ ; if ( @@unsignedint64@@ > column_info_alloc_8572 ) { if ( @@unsignedint64@@ >= ( unsigned __int64 ) max_idx >> Number ) { column_info = xnrealloc ( column_info , max_idx , Number L ) ; @@unsignedint64@@ = max_idx ; } else { column_info = xnrealloc ( column_info , @@unsignedint64@@ , Number L ) ; @@unsignedint64@@ = Number * @@unsignedint64@@ ; } @@unsignedint64@@ = ( @@unsignedint64@@ - column_info_alloc_8572 ) * ( column_info_alloc_8572 + @@unsignedint64@@ + Number ) ; if ( column_info_alloc_8572 + @@unsignedint64@@ + Number < @@unsignedint64@@ || column_info_alloc_8572 + @@unsignedint64@@ + Number != @@unsignedint64@@ / ( @@unsignedint64@@ - column_info_alloc_8572 ) ) { xalloc_die ( ) ; } @@int64@@ = xnmalloc ( @@unsignedint64@@ >> Number , Number L ) ; for ( @@unsignedint64@@ = column_info_alloc_8572 ; @@unsignedint64@@ < @@unsignedint64@@ ; ++ @@unsignedint64@@ ) { * ( _QWORD * ) ( column_info + Number * @@unsignedint64@@ + Number ) = @@int64@@ ; @@int64@@ += Number * ( @@unsignedint64@@ + Number ) ; } column_info_alloc_8572 = @@unsignedint64@@ ; } for ( @@unsignedint64@@ = Number L ; ; ++ @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ ; if ( @@unsignedint64@@ >= @@unsignedint64@@ ) break ; * ( _BYTE * ) ( column_info + Number * @@unsignedint64@@ ) = Number ; * ( _QWORD * ) ( column_info + Number * @@unsignedint64@@ + Number ) = Number * ( @@unsignedint64@@ + Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= @@unsignedint64@@ ; ++ @@unsignedint64@@ ) { * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( column_info + Number * @@unsignedint64@@ + Number ) ) = Number L ; } } return @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall wc_ensure_printable ( wint_t * @@wintt@@ ) { unsigned __int8 @@unsignedint8@@ ; @@unsignedint8@@ = Number ; while ( * @@wintt@@ ) { if ( ! iswprint ( * @@wintt@@ ) ) { * @@wintt@@ = Number ; @@unsignedint8@@ = Number ; } ++ @@wintt@@ ; } return @@unsignedint8@@ ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall x2nrealloc ( __int64 @@int64@@ , unsigned __int64 * @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = * @@unsignedint64@@ ; if ( @@int64@@ ) { if ( @@unsignedint64@@ >= Number / @@unsignedint64@@ ) xalloc_die ( ) ; @@unsignedint64@@ += ( @@unsignedint64@@ + Number ) >> Number ; } else if ( ! @@unsignedint64@@ ) { @@unsignedint64@@ = ( Number / @@unsignedint64@@ == Number ) + Number / @@unsignedint64@@ ; } * @@unsignedint64@@ = @@unsignedint64@@ ; return xrealloc ( @@int64@@ , @@unsignedint64@@ * @@unsignedint64@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return xmalloc ( @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall rpl_wcswidth ( wchar_t * @@wchart@@ , __int64 @@int64@@ ) { wchar_t * @@wchart@@ ; __int64 @@int64@@ ; int @@int@@ ; int @@int@@ ; for ( @@int@@ = Number ; ; @@int@@ += @@int@@ ) { @@int64@@ = @@int64@@ -- ; if ( ! @@int64@@ || ! * @@wchart@@ ) break ; @@wchart@@ = @@wchart@@ ++ ; @@int@@ = wcwidth ( * @@wchart@@ ) ; if ( @@int@@ == Number ) return Number ; if ( @@int@@ > Number - @@int@@ ) return Number ; } return ( unsigned int ) @@int@@ ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@unsignedint64@@ , int @@int@@ ) { __int64 @@int64@@ ; if ( is_mul_ok ( @@int@@ , * @@unsignedint64@@ ) ) { * @@unsignedint64@@ *= @@int@@ ; @@int64@@ = Number L ; } else { * @@unsignedint64@@ = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall wc_truncate ( wchar_t * @@wchart@@ , unsigned __int64 @@unsignedint64@@ ) { int @@int@@ ; __int64 @@int64@@ ; @@int64@@ = Number L ; while ( * @@wchart@@ ) { @@int@@ = wcwidth ( * @@wchart@@ ) ; if ( @@int@@ == Number ) { * @@wchart@@ = Number ; @@int@@ = Number ; } if ( @@unsignedint64@@ < @@int@@ + @@int64@@ ) break ; @@int64@@ += @@int@@ ; ++ @@wchart@@ ; } * @@wchart@@ = Number ; return @@int64@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall mem_cd_iconv ( char * @@char@@ , size_t @@sizet@@ , void * @@void@@ , void * * @@void@@ , size_t * @@sizet@@ ) { int @@int@@ ; char * @@char@@ ; size_t @@sizet@@ ; char * @@char@@ ; size_t @@sizet@@ ; void * @@void@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; char @@char@@ $D1F1B2789FC85C59BE59CF61C76BFA1E [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; iconv ( @@void@@ , Number L , Number L , Number L , Number L ) ; @@sizet@@ = Number L ; @@char@@ = @@char@@ ; @@sizet@@ = @@sizet@@ ; while ( @@sizet@@ ) { @@char@@ = @@char@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; @@sizet@@ = Number L ; @@sizet@@ = iconv ( @@void@@ , & @@char@@ , & @@sizet@@ , & @@char@@ , & @@sizet@@ ) ; if ( @@sizet@@ == Number && * __errno_location ( ) != Number ) { if ( * __errno_location ( ) != Number ) return Number ; break ; } @@sizet@@ += @@char@@ - @@char@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; } @@char@@ = @@char@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; @@sizet@@ = Number L ; @@sizet@@ = iconv ( @@void@@ , Number L , Number L , & @@char@@ , & @@sizet@@ ) ; if ( @@sizet@@ == Number ) return Number ; @@sizet@@ += @@char@@ - @@char@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; @@sizet@@ = @@sizet@@ ; if ( ! @@sizet@@ ) { * @@sizet@@ = Number L ; return Number L ; } if ( * @@void@@ && @@sizet@@ <= * @@sizet@@ ) { @@void@@ = * @@void@@ ; } else { @@void@@ = malloc ( @@sizet@@ ) ; if ( ! @@void@@ ) { * __errno_location ( ) = Number ; return Number ; } } iconv ( @@void@@ , Number L , Number L , Number L , Number L ) ; @@char@@ = @@char@@ ; @@sizet@@ = @@sizet@@ ; @@char@@ = ( char * ) @@void@@ ; @@sizet@@ = @@sizet@@ ; while ( @@sizet@@ ) { @@sizet@@ = iconv ( @@void@@ , & @@char@@ , & @@sizet@@ , & @@char@@ , & @@sizet@@ ) ; if ( @@sizet@@ == Number ) { if ( * __errno_location ( ) != Number ) goto LABEL_26 ; break ; } } @@sizet@@ = iconv ( @@void@@ , Number L , Number L , & @@char@@ , & @@sizet@@ ) ; if ( @@sizet@@ != Number ) { if ( @@sizet@@ ) abort ( ) ; * @@void@@ = @@void@@ ; * @@sizet@@ = @@sizet@@ ; return Number L ; } LABEL_26 : if ( @@void@@ != * @@void@@ ) { @@int@@ = * __errno_location ( ) ; free ( @@void@@ ) ; * __errno_location ( ) = @@int@@ ; } return Number ; }
__int64 __fastcall gnu_mbswidth ( const char * @@constchar@@ , unsigned int @@unsignedint@@ ) { size_t @@sizet@@ ; @@sizet@@ = strlen ( @@constchar@@ ) ; return mbsnwidth ( @@constchar@@ , @@sizet@@ , @@unsignedint@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
void __fastcall argmatch_invalid ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { char * @@char@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; char * @@char@@ ; if ( @@int64@@ == Number ) @@char@@ = gettext ( String ) ; else @@char@@ = gettext ( String ) ; @@char@@ = @@char@@ ; @@int64@@ = quote_n ( Number L , @@int64@@ ) ; @@int64@@ = quotearg_n_style ( Number L , Number L , @@int64@@ ) ; error ( Number , Number , @@char@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall copy_to_temp ( FILE * * @@FILE@@ , char * * @@char@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { size_t @@sizet@@ ; size_t @@sizet@@ ; __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; int @@int@@ ; char * @@char@@ ; FILE * @@FILE@@ ; __int64 @@int64@@ ; if ( ! template_5765 ) { tempdir_5766 = getenv ( String ) ; if ( ! tempdir_5766 ) tempdir_5766 = String ; @@sizet@@ = strlen ( tempdir_5766 ) ; @@sizet@@ = strlen ( String ) ; template_5765 = ( char * ) xmalloc ( @@sizet@@ + @@sizet@@ - Number ) ; sprintf ( template_5765 , String , tempdir_5766 ) ; } @@char@@ = template_5765 ; @@int@@ = mkstemp_safer ( template_5765 ) ; if ( @@int@@ >= Number ) { @@FILE@@ = fdopen ( @@int@@ , String ) ; if ( @@FILE@@ ) { record_or_unlink_tempfile ( @@char@@ ) ; while ( Number ) { @@int64@@ = safe_read ( @@unsignedint@@ , G_buffer , read_size ) ; if ( ! @@int64@@ ) break ; if ( @@int64@@ == Number ) { @@int64@@ = quotearg_colon ( @@int64@@ ) ; @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ , @@int64@@ ) ; goto LABEL_17 ; } if ( @@int64@@ != fwrite_unlocked ( G_buffer , Number , @@int64@@ , @@FILE@@ ) ) goto LABEL_14 ; } if ( ! fflush_unlocked ( @@FILE@@ ) ) { * @@FILE@@ = @@FILE@@ ; * @@char@@ = @@char@@ ; return Number L ; } LABEL_14 : @@int64@@ = quotearg_colon ( @@char@@ ) ; @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ , @@int64@@ ) ; LABEL_17 : fclose ( @@FILE@@ ) ; @@int64@@ = Number L ; } else { @@int64@@ = quote ( @@char@@ ) ; @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ , @@int64@@ ) ; close ( @@int@@ ) ; unlink ( @@char@@ ) ; @@int64@@ = Number L ; } } else { @@int64@@ = quote ( tempdir_5766 ) ; @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ , @@int64@@ ) ; @@int64@@ = Number L ; } return @@int64@@ ; }
_BOOL8 __fastcall visit_dir ( __int64 @@int64@@ , __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; @@QWORD@@ = ( _QWORD * ) xmalloc ( Number L ) ; * @@QWORD@@ = @@int64@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = hash_insert ( active_dir_set , @@QWORD@@ ) ; if ( ! @@int64@@ ) xalloc_die ( ) ; if ( ( _QWORD * ) @@int64@@ != @@QWORD@@ ) free ( @@QWORD@@ ) ; return @@int64@@ != ( _QWORD ) @@QWORD@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall mbsnwidth ( char * @@char@@ , __int64 @@int64@@ , char @@char@@ ) { int @@int@@ ; char * @@char@@ ; unsigned __int8 @@unsignedint8@@ ; wchar_t @@wchart@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; char * @@char@@ ; size_t @@sizet@@ ; char * @@char@@ ; mbstate_t @@mbstatet2@@ [ Number ] ; @@mbstatet2@@ [ Number ] = ( mbstate_t ) __readfsqword ( Number ) ; @@char@@ = @@char@@ ; @@char@@ = & @@char@@ [ @@int64@@ ] ; @@unsignedint@@ = Number ; if ( __ctype_get_mb_cur_max ( ) > Number ) { while ( Number ) { LABEL_28 : if ( @@char@@ >= @@char@@ ) return @@unsignedint@@ ; @@int@@ = * @@char@@ ; if ( @@int@@ > Number ) { if ( @@int@@ < Number || @@int@@ > Number && ( unsigned int ) ( @@int@@ - Number ) > Number ) { LABEL_11 : memset ( @@mbstatet2@@ , Number , Number ) ; while ( Number ) { @@sizet@@ = mbrtowc ( & @@wchart@@ , @@char@@ , @@char@@ - @@char@@ , @@mbstatet2@@ ) ; if ( @@sizet@@ == Number ) { if ( ( @@char@@ & Number ) == Number ) { ++ @@char@@ ; ++ @@unsignedint@@ ; goto LABEL_28 ; } return Number ; } if ( @@sizet@@ == Number ) break ; if ( ! @@sizet@@ ) @@sizet@@ = Number L ; @@int@@ = wcwidth ( @@wchart@@ ) ; if ( @@int@@ < Number ) { if ( ( @@char@@ & Number ) != Number ) return Number ; @@unsignedint@@ += iswcntrl ( @@wchart@@ ) == Number ; } else { @@unsignedint@@ += @@int@@ ; } @@char@@ += @@sizet@@ ; if ( mbsinit ( @@mbstatet2@@ ) ) goto LABEL_28 ; } if ( ( @@char@@ & Number ) == Number ) { @@char@@ = @@char@@ ; ++ @@unsignedint@@ ; continue ; } return Number ; } } else if ( @@int@@ < Number && ( unsigned int ) ( @@int@@ - Number ) > Number ) { goto LABEL_11 ; } ++ @@char@@ ; ++ @@unsignedint@@ ; } } while ( @@char@@ < @@char@@ ) { @@char@@ = @@char@@ ++ ; @@unsignedint8@@ = * @@char@@ ; if ( ( ( * __ctype_b_loc ( ) ) [ @@unsignedint8@@ ] & Number ) != Number ) { ++ @@unsignedint@@ ; } else { if ( ( @@char@@ & Number ) != Number ) return Number ; @@unsignedint@@ += ( ( * __ctype_b_loc ( ) ) [ @@unsignedint8@@ ] & Number ) == Number ; } } return @@unsignedint@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall hash_get_n_entries ( __int64 @@int64@@ ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; }
_BYTE * __fastcall longest_relative_suffix ( _BYTE * @@BYTE@@ ) { while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; return @@BYTE@@ ; }
__int64 __fastcall file_failure ( unsigned __int8 @@unsignedint8@@ , const char * @@constchar@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; int * @@int@@ ; @@int64@@ = quotearg_colon ( @@int64@@ ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@constchar@@ , @@int64@@ ) ; return set_exit_status ( @@unsignedint8@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
__int64 __fastcall patterns_match ( __int64 @@int64@@ , const char * @@constchar@@ ) { while ( @@int64@@ ) { if ( ! fnmatch ( * ( const char * * ) @@int64@@ , @@constchar@@ , Number ) ) return Number L ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; } return Number L ; }
__int64 __fastcall hard_locale ( int @@int@@ ) { unsigned __int8 @@unsignedint8@@ ; const char * @@constchar@@ ; @@unsignedint8@@ = Number ; @@constchar@@ = setlocale ( @@int@@ , Number L ) ; if ( @@constchar@@ && ( ! strcmp ( @@constchar@@ , String ) || ! strcmp ( @@constchar@@ , String ) ) ) { @@unsignedint8@@ = Number ; } return @@unsignedint8@@ ; }
__int64 __fastcall get_link_name ( __int64 @@int64@@ , __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int64@@ ; char * @@char@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = areadlink_with_size ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( ! @@int64@@ ) { @@char@@ = gettext ( String ) ; @@int64@@ = file_failure ( @@unsignedint8@@ , @@char@@ , @@int64@@ ) ; } return @@int64@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
_BOOL8 __fastcall hash_table_ok ( __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; @@int64@@ = Number L ; @@int64@@ = Number L ; for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { @@QWORD@@ = @@QWORD@@ ; ++ @@int64@@ ; ++ @@int64@@ ; while ( Number ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; if ( ! @@QWORD@@ ) break ; ++ @@int64@@ ; } } } return @@int64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) && @@int64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ; }
_QWORD * __fastcall bitset_clear ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { _QWORD * @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) ( Number * ( @@unsignedint64@@ >> Number ) + @@int64@@ ) ; * @@QWORD@@ &= ~ ( Number L << ( @@unsignedint64@@ & Number ) ) ; return @@QWORD@@ ; }
__int64 __fastcall cmp_mtime ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ , __int64 ( __fastcall * @ @ VAR_500 @ @ int64 ( fastcall ) ( QWORD , QWORD ) @ @ int ( ) ( constchar , constchar ) ) ( _QWORD , _QWORD ) ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = get_stat_mtime ( ( __int64 ) ( @@QWORD@@ + Number ) ) ; @@int64@@ = @@int64@@ ; @@int64@@ = get_stat_mtime ( ( __int64 ) ( @@QWORD@@ + Number ) ) ; @@unsignedint@@ = timespec_cmp ( @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( @@unsignedint@@ ) @@int64@@ = @@unsignedint@@ ; else @@int64@@ = @ @ VAR_500 @ @ int64 ( fastcall ) ( QWORD , QWORD ) @ @ int ( ) ( constchar , constchar ) ( * @@QWORD@@ , * @@QWORD@@ ) ; return @@int64@@ ; }
int __fastcall hash_print_statistics ( __int64 @@int64@@ , FILE * @@FILE@@ ) { double @@double@@ ; double @@double@@ ; double @@double@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int64@@ = hash_get_n_entries ( @@int64@@ ) ; @@int64@@ = hash_get_n_buckets ( @@int64@@ ) ; @@int64@@ = hash_get_n_buckets_used ( @@int64@@ ) ; @@unsignedint64@@ = hash_get_max_bucket_length ( @@int64@@ ) ; fprintf ( @@FILE@@ , String , @@int64@@ ) ; fprintf ( @@FILE@@ , String , @@int64@@ ) ; if ( @@int64@@ < Number ) @@double@@ = ( double ) ( int ) ( @@int64@@ & Number | ( ( unsigned __int64 ) @@int64@@ >> Number ) ) + ( double ) ( int ) ( @@int64@@ & Number | ( ( unsigned __int64 ) @@int64@@ >> Number ) ) ; else @@double@@ = ( double ) ( int ) @@int64@@ ; @@double@@ = Number * @@double@@ ; if ( @@int64@@ < Number ) @@double@@ = ( double ) ( int ) ( @@int64@@ & Number | ( ( unsigned __int64 ) @@int64@@ >> Number ) ) + ( double ) ( int ) ( @@int64@@ & Number | ( ( unsigned __int64 ) @@int64@@ >> Number ) ) ; else @@double@@ = ( double ) ( int ) @@int64@@ ; fprintf ( @@FILE@@ , String , @@int64@@ , @@double@@ / @@double@@ ) ; return fprintf ( @@FILE@@ , String , @@unsignedint64@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_222288 ; @@int648@@ [ Number ] = qword_222290 ; @@int648@@ [ Number ] = qword_222298 ; @@int648@@ [ Number ] = qword_2222A0 ; @@int648@@ [ Number ] = qword_2222A8 ; @@int648@@ [ Number ] = qword_2222B0 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
__int64 __fastcall hash_get_first ( unsigned __int64 * @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; if ( ! @@unsignedint64@@ [ Number ] ) return Number L ; for ( @@unsignedint64@@ = * @@unsignedint64@@ ; ; @@unsignedint64@@ += Number L ) { if ( @@unsignedint64@@ >= @@unsignedint64@@ [ Number ] ) abort ( ) ; if ( * ( _QWORD * ) @@unsignedint64@@ ) break ; } return * ( _QWORD * ) @@unsignedint64@@ ; }
_QWORD * __fastcall bitset_mask ( __int64 @@int64@@ , __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; int @@int@@ ; for ( @@int@@ = Number ; @@int@@ <= Number ; ++ @@int@@ ) { @@QWORD@@ = ( _QWORD * ) ( Number L * @@int@@ + @@int64@@ ) ; * @@QWORD@@ &= * ( _QWORD * ) ( Number L * @@int@@ + @@int64@@ ) ; } return @@QWORD@@ ; }
__int64 sort_files ( ) { __int64 @@int64@@ ; int @@int@@ ; unsigned __int8 @@unsignedint8@@ ; if ( cwd_n_used + ( ( unsigned __int64 ) cwd_n_used >> Number ) > sorted_file_alloc ) { free ( sorted_file ) ; sorted_file = ( void * ) xnmalloc ( cwd_n_used , Number L ) ; sorted_file_alloc = Number * cwd_n_used ; } initialize_ordering_vector ( ) ; @@int64@@ = ( unsigned int ) sort_type ; if ( sort_type != Number ) { if ( _setjmp ( failed_strcoll ) ) { @@unsignedint8@@ = Number ; if ( sort_type == Number ) __assert_fail ( String , String , Number , String ) ; initialize_ordering_vector ( ) ; } else { @@unsignedint8@@ = Number ; } if ( sort_type == Number ) @@int@@ = time_type ; else @@int@@ = Number ; @@int64@@ = mpsort ( sorted_file , cwd_n_used , * ( & sort_functions [ Number * ( unsigned int ) ( @@int@@ + sort_type ) ] + Number * @@unsignedint8@@ + Number * ( unsigned __int8 ) sort_reverse + ( unsigned __int8 ) directories_first ) ) ; } return @@int64@@ ; }
size_t * __fastcall hash_initialize ( __int64 @@int64@@ , void * @@void@@ , unsigned __int64 ( __fastcall * @ @ VAR_1363 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ) ( __int64 a1 , unsigned __int64 a2 ) , bool ( __fastcall * @ @ VAR_1365 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ) ( __int64 a1 , __int64 a2 ) , size_t @@sizet@@ ) { size_t * @@sizet@@ ; bool ( __fastcall * @ @ VAR_1364 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ) ( __int64 , __int64 ) ; unsigned __int64 ( __fastcall * @ @ VAR_1362 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ) ( __int64 , unsigned __int64 ) ; void * @@void@@ ; size_t * @@sizet@@ ; @@void@@ = @@void@@ ; @ @ VAR_1362 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher = @ @ VAR_1363 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ; @ @ VAR_1364 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator = @ @ VAR_1365 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ; if ( ! @ @ VAR_1363 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ) @ @ VAR_1362 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher = raw_hasher ; if ( ! @ @ VAR_1365 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ) @ @ VAR_1364 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator = raw_comparator ; @@sizet@@ = ( size_t * ) malloc ( Number ) ; if ( ! @@sizet@@ ) return Number L ; if ( ! @@void@@ ) @@void@@ = & default_tuning ; @@sizet@@ [ Number ] = ( size_t ) @@void@@ ; if ( ( unsigned __int8 ) check_tuning ( ( __int64 ) @@sizet@@ ) == Number && ( @@sizet@@ [ Number ] = compute_bucket_size ( @@int64@@ , ( __int64 ) @@void@@ ) ) != Number && ( * @@sizet@@ = ( size_t ) calloc ( @@sizet@@ [ Number ] , Number ) ) != Number ) { @@sizet@@ [ Number ] = Number * @@sizet@@ [ Number ] + * @@sizet@@ ; @@sizet@@ [ Number ] = Number L ; @@sizet@@ [ Number ] = Number L ; @@sizet@@ [ Number ] = ( size_t ) @ @ VAR_1362 @ @ unsignedint64 ( fastcall ) ( int64a1 , unsignedint64a2 ) @ @ Hashhasher ; @@sizet@@ [ Number ] = ( size_t ) @ @ VAR_1364 @ @ bool ( fastcall ) ( int64a1 , int64a2 ) @ @ Hashcomparator ; @@sizet@@ [ Number ] = @@sizet@@ ; @@sizet@@ [ Number ] = Number L ; @@sizet@@ = @@sizet@@ ; } else { free ( @@sizet@@ ) ; @@sizet@@ = Number L ; } return @@sizet@@ ; }
void * __fastcall bitset_empty ( void * @@void@@ ) { return memset ( @@void@@ , Number , Number ) ; }
unsigned __int64 __fastcall hash_get_entries ( __int64 @@int64@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; @@unsignedint64@@ = Number L ; for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { for ( @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { if ( @@unsignedint64@@ >= @@unsignedint64@@ ) return @@unsignedint64@@ ; @@int64@@ = @@unsignedint64@@ ++ ; * ( _QWORD * ) ( @@int64@@ + Number * @@int64@@ ) = * @@QWORD@@ ; } } } return @@unsignedint64@@ ; }
__int64 __fastcall re_string_construct ( __int64 @@int64@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; unsigned int @@unsignedint@@ ; unsigned int @@unsignedint@@ ; unsigned int @@unsignedint@@ ; memset ( ( void * ) @@int64@@ , Number , Number ) ; re_string_construct_common ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@int64@@ , @@unsignedint8@@ , @@int64@@ ) ; if ( @@unsignedint64@@ ) { @@unsignedint@@ = re_string_realloc_buffers ( @@int64@@ , @@unsignedint64@@ + Number ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; } if ( * ( _BYTE * ) ( @@int64@@ + Number ) ) @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; else @@int64@@ = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; if ( ! @@unsignedint8@@ ) { if ( * ( int * ) ( @@int64@@ + Number ) <= Number ) { if ( @@int64@@ ) { re_string_translate_buffer ( @@int64@@ ) ; } else { * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; } } else { build_wcs_buffer ( @@int64@@ ) ; } return Number L ; } if ( * ( int * ) ( @@int64@@ + Number ) <= Number ) { build_upper_buffer ( @@int64@@ ) ; return Number L ; } do { @@unsignedint@@ = build_wcs_upper_buffer ( @@int64@@ ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; if ( @@unsignedint64@@ <= * ( _QWORD * ) ( @@int64@@ + Number ) || * ( _QWORD * ) ( @@int64@@ + Number ) > ( unsigned __int64 ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + * ( int * ) ( @@int64@@ + Number ) ) ) { return Number L ; } @@unsignedint@@ = re_string_realloc_buffers ( @@int64@@ , Number L * * ( _QWORD * ) ( @@int64@@ + Number ) ) ; } while ( ! @@unsignedint@@ ) ; return @@unsignedint@@ ; }
__int64 __fastcall format_user ( unsigned int @@unsignedint@@ , int @@int@@ , char @@char@@ ) { const char * @@constchar@@ ; if ( @@char@@ != Number ) { @@constchar@@ = String ; } else if ( numeric_ids ) { @@constchar@@ = Number L ; } else { @@constchar@@ = ( const char * ) getuser ( @@unsignedint@@ ) ; } return format_user_or_group ( @@constchar@@ , @@unsignedint@@ , @@int@@ ) ; }
__int64 default_block_size ( ) { __int64 @@int64@@ ; if ( getenv ( String ) ) @@int64@@ = Number L ; else @@int64@@ = Number L ; return @@int64@@ ; }
void * __fastcall bitset_set_all ( void * @@void@@ ) { return memset ( @@void@@ , Number , Number ) ; }
bool __fastcall is_prime ( unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = Number L ; @@unsignedint64@@ = Number L ; while ( @@unsignedint64@@ < @@unsignedint64@@ && @@unsignedint64@@ % @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@unsignedint64@@ += Number * @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint64@@ + Number ; } return @@unsignedint64@@ % @@unsignedint64@@ != Number ; }
size_t __fastcall format_group_width ( unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; if ( numeric_ids ) @@int64@@ = Number L ; else @@int64@@ = getgroup ( @@unsignedint@@ ) ; return format_user_or_group_width ( @@int64@@ , @@unsignedint@@ ) ; }
void __fastcall re_string_destruct ( __int64 @@int64@@ ) { free ( * ( void * * ) ( @@int64@@ + Number ) ) ; free ( * ( void * * ) ( @@int64@@ + Number ) ) ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) ) free ( * ( void * * ) ( @@int64@@ + Number ) ) ; }
__int64 __fastcall re_string_char_size_at ( __int64 @@int64@@ , __int64 @@int64@@ ) { int @@int@@ ; if ( * ( _DWORD * ) ( @@int64@@ + Number ) == Number ) return Number L ; for ( @@int@@ = Number ; ( unsigned __int64 ) ( @@int64@@ + @@int@@ ) < * ( _QWORD * ) ( @@int64@@ + Number ) && * ( _DWORD * ) ( Number * ( @@int@@ + @@int64@@ ) + * ( _QWORD * ) ( @@int64@@ + Number ) ) == Number ; ++ @@int@@ ) { ; } return ( unsigned int ) @@int@@ ; }
void __fastcall hash_free ( __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) && * ( _QWORD * ) ( @@int64@@ + Number ) ) { for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { if ( * @@QWORD@@ ) { for ( @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ) { ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@int64@@ + Number ) ) ( * @@QWORD@@ ) ; } } } } for ( @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; ( unsigned __int64 ) @@QWORD@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ += Number ) { for ( @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; @@QWORD@@ ; @@QWORD@@ = @@QWORD@@ ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; free ( @@QWORD@@ ) ; } } for ( @@QWORD@@ = * ( _QWORD * * ) ( @@int64@@ + Number ) ; @@QWORD@@ ; @@QWORD@@ = @@QWORD@@ ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; free ( @@QWORD@@ ) ; } free ( * ( void * * ) @@int64@@ ) ; free ( ( void * ) @@int64@@ ) ; }
__int64 __fastcall humblock ( char * @@char@@ , _QWORD * @@QWORD@@ , int * @@int@@ ) { char * @@char@@ ; int @@int@@ ; int @@int@@ ; unsigned int @@unsignedint@@ ; __int64 @@int642@@ [ Number ] ; @@char@@ = @@char@@ ; @@int642@@ [ Number ] = __readfsqword ( Number ) ; @@int@@ = Number ; if ( @@char@@ || ( @@char@@ = getenv ( String ) ) != Number L || ( @@char@@ = getenv ( String ) ) != Number L ) { if ( * @@char@@ == Number ) { @@int@@ = Number ; ++ @@char@@ ; } @@int@@ = argmatch ( @@char@@ , ( __int64 ) block_size_args , ( __int64 ) block_size_opts , Number ) ; if ( @@int@@ < Number ) { @@unsignedint@@ = xstrtoumax ( @@char@@ , @@int642@@ , Number L , @@QWORD@@ , String ) ; if ( @@unsignedint@@ ) { * @@int@@ = Number ; return @@unsignedint@@ ; } while ( * @@char@@ <= Number || * @@char@@ > Number ) { if ( @@char@@ == ( char * ) @@int642@@ [ Number ] ) { @@int@@ |= Number ; if ( * ( _BYTE * ) ( @@int642@@ [ Number ] - Number ) == Number ) @@int@@ |= Number ; if ( * ( _BYTE * ) ( @@int642@@ [ Number ] - Number ) != Number || * ( _BYTE * ) ( @@int642@@ [ Number ] - Number ) == Number ) @@int@@ |= Number ; break ; } ++ @@char@@ ; } } else { @@int@@ |= block_size_opts [ @@int@@ ] ; * @@QWORD@@ = Number L ; } } else { * @@QWORD@@ = default_block_size ( ) ; } * @@int@@ = @@int@@ ; return Number L ; }
__int64 __fastcall get_type_indicator ( char @@char@@ , __int16 @@int16@@ , int @@int@@ ) { bool @@bool@@ ; bool @@bool@@ ; bool @@bool@@ ; bool @@bool@@ ; bool @@bool@@ ; bool @@bool@@ ; unsigned __int8 @@unsignedint8@@ ; if ( @@char@@ ) @@bool@@ = ( @@int16@@ & Number ) == Number ; else @@bool@@ = @@int@@ == Number ; if ( @@bool@@ ) { if ( @@char@@ && indicator_style == Number && ( @@int16@@ & Number ) != Number ) @@unsignedint8@@ = Number ; else @@unsignedint8@@ = Number ; } else { if ( @@char@@ ) { @@bool@@ = ( @@int16@@ & Number ) == Number ; } else { @@bool@@ = @@int@@ == Number || @@int@@ == Number ; @@bool@@ = @@bool@@ ; } if ( @@bool@@ ) { @@unsignedint8@@ = Number ; } else if ( indicator_style == Number ) { @@unsignedint8@@ = Number ; } else { if ( @@char@@ ) @@bool@@ = ( @@int16@@ & Number ) == Number ; else @@bool@@ = @@int@@ == Number ; if ( @@bool@@ ) { @@unsignedint8@@ = Number ; } else { if ( @@char@@ ) @@bool@@ = ( @@int16@@ & Number ) == Number ; else @@bool@@ = @@int@@ == Number ; if ( @@bool@@ ) { @@unsignedint8@@ = Number ; } else { if ( @@char@@ ) @@bool@@ = ( @@int16@@ & Number ) == Number ; else @@bool@@ = @@int@@ == Number ; if ( @@bool@@ ) @@unsignedint8@@ = Number ; else @@unsignedint8@@ = Number ; } } } } return @@unsignedint8@@ ; }
__int64 __fastcall re_string_construct_common ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , char @@char@@ , __int64 @@int64@@ ) { bool @@bool@@ ; __int64 @@int64@@ ; * ( _QWORD * ) @@int64@@ = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _BYTE * ) ( @@int64@@ + Number ) = @@char@@ ; @@bool@@ = @@int64@@ || @@char@@ ; * ( _BYTE * ) ( @@int64@@ + Number ) = @@bool@@ ; * ( _DWORD * ) ( @@int64@@ + Number ) = * ( _DWORD * ) ( @@int64@@ + Number ) ; * ( _BYTE * ) ( @@int64@@ + Number ) = ( * ( _BYTE * ) ( @@int64@@ + Number ) & Number ) != Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = ( * ( _BYTE * ) ( @@int64@@ + Number ) & Number ) != Number ; * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; return @@int64@@ ; }
unsigned __int64 __fastcall calculate_columns ( char @@char@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = max_idx ; if ( cwd_n_used <= ( unsigned __int64 ) max_idx ) @@int64@@ = cwd_n_used ; @@unsignedint64@@ = @@int64@@ ; init_column_info ( ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < cwd_n_used ; ++ @@unsignedint64@@ ) { @@int64@@ = length_of_file_name_and_frills ( * ( ( _QWORD * ) sorted_file + @@unsignedint64@@ ) ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@unsignedint64@@ ; ++ @@unsignedint64@@ ) { if ( * ( _BYTE * ) ( column_info + Number * @@unsignedint64@@ ) ) { @@unsignedint64@@ = @@char@@ ? @@unsignedint64@@ / ( ( cwd_n_used + @@unsignedint64@@ ) / ( @@unsignedint64@@ + Number ) ) : @@unsignedint64@@ % ( @@unsignedint64@@ + Number ) ; @@int64@@ = @@unsignedint64@@ == @@unsignedint64@@ ? Number L : Number L ; @@int64@@ = @@int64@@ + @@int64@@ ; if ( ( unsigned __int64 ) ( @@int64@@ + @@int64@@ ) > * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( column_info + Number * @@unsignedint64@@ + Number ) ) ) { * ( _QWORD * ) ( column_info + Number * @@unsignedint64@@ + Number ) += @@int64@@ - * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( column_info + Number * @@unsignedint64@@ + Number ) ) ; * ( _QWORD * ) ( * ( _QWORD * ) ( column_info + Number * @@unsignedint64@@ + Number ) + Number * @@unsignedint64@@ ) = @@int64@@ ; * ( _BYTE * ) ( column_info + Number * @@unsignedint64@@ ) = * ( _QWORD * ) ( column_info + Number * @@unsignedint64@@ + Number ) < ( unsigned __int64 ) line_length ; } } } } for ( @@unsignedint64@@ = @@unsignedint64@@ ; @@unsignedint64@@ > Number && ! * ( _BYTE * ) ( column_info + Number * @@unsignedint64@@ - Number ) ; -- @@unsignedint64@@ ) { ; } return @@unsignedint64@@ ; }
char * __fastcall group_number ( char * @@char@@ , size_t @@sizet@@ , unsigned __int8 * @@unsignedint8@@ , const char * @@constchar@@ ) { char * @@char@@ ; size_t @@sizet@@ ; char * @@char@@ ; unsigned __int8 @@unsignedint8@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@sizet@@ = Number ; @@sizet@@ = strlen ( @@constchar@@ ) ; @@sizet@@ = @@sizet@@ ; memcpy ( @@char@@ , @@char@@ , @@sizet@@ ) ; for ( @@char@@ = & @@char@@ [ @@sizet@@ ] ; ; memcpy ( @@char@@ , @@constchar@@ , @@sizet@@ ) ) { @@unsignedint8@@ = * @@unsignedint8@@ ; if ( * @@unsignedint8@@ ) { if ( @@unsignedint8@@ > Number ) @@sizet@@ = @@sizet@@ ; else @@sizet@@ = @@unsignedint8@@ ; @@sizet@@ = @@sizet@@ ; ++ @@unsignedint8@@ ; } if ( @@sizet@@ < @@sizet@@ ) @@sizet@@ = @@sizet@@ ; @@char@@ = & @@char@@ [ - @@sizet@@ ] ; @@sizet@@ -= @@sizet@@ ; memcpy ( @@char@@ , & @@char@@ [ @@sizet@@ ] , @@sizet@@ ) ; if ( ! @@sizet@@ ) break ; @@char@@ = & @@char@@ [ - @@sizet@@ ] ; } return @@char@@ ; }
__int64 __fastcall imaxtostr ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ + Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = Number ; if ( @@int64@@ >= Number ) { do { * ( _BYTE * ) -- @@int64@@ = ( char ) @@int64@@ % Number + Number ; @@int64@@ /= Number L ; } while ( @@int64@@ ) ; } else { do { * ( _BYTE * ) -- @@int64@@ = Number - ( char ) @@int64@@ % Number ; @@int64@@ /= Number L ; } while ( @@int64@@ ) ; * ( _BYTE * ) -- @@int64@@ = Number ; } return @@int64@@ ; }
__int64 __fastcall re_string_context_at ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , char @@char@@ ) { __int64 @@int64@@ ; int @@int@@ ; wint_t @@wintt@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@unsignedint64@@ > Number ) return * ( unsigned int * ) ( @@int64@@ + Number ) ; if ( @@unsignedint64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ) { if ( ( @@char@@ & Number ) != Number ) @@int64@@ = Number L ; else @@int64@@ = Number L ; } else if ( * ( int * ) ( @@int64@@ + Number ) <= Number ) { @@int@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + @@unsignedint64@@ ) ; if ( bitset_contain ( * ( _QWORD * ) ( @@int64@@ + Number ) , * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + @@unsignedint64@@ ) ) ) { @@int64@@ = Number L ; } else if ( @@int@@ == Number && * ( _BYTE * ) ( @@int64@@ + Number ) ) { @@int64@@ = Number L ; } else { @@int64@@ = Number L ; } } else { @@unsignedint64@@ = @@unsignedint64@@ ; while ( * ( _DWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) == Number ) { if ( -- @@unsignedint64@@ > Number ) return * ( unsigned int * ) ( @@int64@@ + Number ) ; } @@wintt@@ = * ( _DWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) && ( iswalnum ( @@wintt@@ ) || @@wintt@@ == Number ) ) { @@int64@@ = Number L ; } else if ( @@wintt@@ == Number && * ( _BYTE * ) ( @@int64@@ + Number ) ) { @@int64@@ = Number L ; } else { @@int64@@ = Number L ; } } return @@int64@@ ; }
_BYTE * __fastcall mbs_align_pad ( _BYTE * @@BYTE@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ ) { _BYTE * @@BYTE@@ ; __int64 @@int64@@ ; while ( Number ) { @@int64@@ = @@int64@@ -- ; if ( ! @@int64@@ || ( unsigned __int64 ) @@BYTE@@ >= @@unsignedint64@@ ) break ; @@BYTE@@ = @@BYTE@@ ++ ; * @@BYTE@@ = Number ; } * @@BYTE@@ = Number ; return @@BYTE@@ ; }
__int64 __fastcall re_string_fetch_byte_case ( __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned int @@unsignedint@@ ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) ) { if ( * ( _BYTE * ) ( @@int64@@ + Number ) ) { if ( * ( _QWORD * ) ( @@int64@@ + Number ) == * ( _QWORD * ) ( @@int64@@ + Number ) || * ( _DWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L * * ( _QWORD * ) ( @@int64@@ + Number ) ) != Number ) { @@unsignedint@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) + * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L * * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; if ( ( @@unsignedint@@ & Number ) != Number ) { @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ + Number ; @@int64@@ = * ( unsigned __int8 * ) ( @@int64@@ + @@int64@@ ) ; } else { @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ + ( int ) re_string_char_size_at ( @@int64@@ , @@int64@@ ) ; @@int64@@ = @@unsignedint@@ ; } } else { @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ + Number ; @@int64@@ = * ( unsigned __int8 * ) ( @@int64@@ + @@int64@@ ) ; } } else { @@int64@@ = * ( _QWORD * ) @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ + Number ; @@int64@@ = * ( unsigned __int8 * ) ( @@int64@@ + @@int64@@ + @@int64@@ ) ; } } else { @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ + Number ; @@int64@@ = * ( unsigned __int8 * ) ( @@int64@@ + @@int64@@ ) ; } return @@int64@@ ; }
__int64 __fastcall human_options ( char * @@char@@ , int * @@int@@ , _QWORD * @@QWORD@@ ) { unsigned int @@unsignedint@@ ; @@unsignedint@@ = humblock ( @@char@@ , @@QWORD@@ , @@int@@ ) ; if ( ! * @@QWORD@@ ) { * @@QWORD@@ = default_block_size ( ) ; @@unsignedint@@ = Number ; } return @@unsignedint@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) { ; } return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall re_node_set_insert_last ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; void * @@void@@ ; if ( * ( _QWORD * ) @@int64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ) { * ( _QWORD * ) @@int64@@ = Number * ( * ( _QWORD * ) @@int64@@ + Number L ) ; @@void@@ = realloc ( * ( void * * ) ( @@int64@@ + Number ) , Number L * * ( _QWORD * ) @@int64@@ ) ; if ( ! @@void@@ ) return Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@void@@ ; } @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ + Number ; * ( _QWORD * ) ( @@int64@@ + Number * @@int64@@ ) = @@int64@@ ; return Number L ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
__int64 __fastcall re_node_set_compare ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; if ( ! @@int64@@ || ! @@int64@@ || * ( _QWORD * ) ( @@int64@@ + Number ) != * ( _QWORD * ) ( @@int64@@ + Number ) ) { return Number L ; } @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; while ( ( unsigned __int64 ) -- @@int64@@ <= Number ) { if ( * ( _QWORD * ) ( Number * @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) != * ( _QWORD * ) ( Number * @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ) return Number L ; } return Number L ; }
__int64 __fastcall argmatch ( const char * @@constchar@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { __int64 @@int64@@ ; char @@char@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; size_t @@sizet@@ ; @@int64@@ = Number ; @@char@@ = Number ; @@sizet@@ = strlen ( @@constchar@@ ) ; for ( @@int64@@ = Number L ; * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; ++ @@int64@@ ) { if ( ! strncmp ( * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) , @@constchar@@ , @@sizet@@ ) ) { if ( @@sizet@@ == strlen ( * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) ) ) return @@int64@@ ; if ( @@int64@@ == Number ) { @@int64@@ = @@int64@@ ; } else if ( ! @@int64@@ || memcmp ( ( const void * ) ( @@sizet@@ * @@int64@@ + @@int64@@ ) , ( const void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) , @@sizet@@ ) ) { @@char@@ = Number ; } } } if ( @@char@@ ) @@int64@@ = Number ; else @@int64@@ = @@int64@@ ; return @@int64@@ ; }
_QWORD * __fastcall re_acquire_state ( _DWORD * @@DWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; unsigned __int64 * @@unsignedint64@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) { @@int64@@ = calc_state_hash ( @@int64@@ , Number ) ; @@unsignedint64@@ = ( unsigned __int64 * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * ( @@int64@@ & * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * @@unsignedint64@@ ; ++ @@unsignedint64@@ ) { @@QWORD@@ = * ( _QWORD * * ) ( Number * @@unsignedint64@@ + @@unsignedint64@@ [ Number ] ) ; if ( @@int64@@ == * @@QWORD@@ && ( unsigned __int8 ) re_node_set_compare ( ( __int64 ) ( @@QWORD@@ + Number ) , @@int64@@ ) ) { return @@QWORD@@ ; } } @@int64@@ = create_ci_newstate ( @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( ! @@int64@@ ) * @@DWORD@@ = Number ; @@QWORD@@ = ( _QWORD * ) @@int64@@ ; } else { * @@DWORD@@ = Number ; @@QWORD@@ = Number L ; } return @@QWORD@@ ; }
__int64 __fastcall getuidbyname ( const char * @@constchar@@ ) { __int64 @@int64@@ ; size_t @@sizet@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; struct passwd * @@structpasswd@@ ; for ( @@int64@@ = user_alist ; @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ) { if ( * ( _BYTE * ) ( @@int64@@ + Number ) == * @@constchar@@ && ! strcmp ( ( const char * ) ( @@int64@@ + Number ) , @@constchar@@ ) ) { return @@int64@@ ; } } for ( @@int64@@ = nouser_alist ; @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ) { if ( * ( _BYTE * ) ( @@int64@@ + Number ) == * @@constchar@@ && ! strcmp ( ( const char * ) ( @@int64@@ + Number ) , @@constchar@@ ) ) { return Number L ; } } @@structpasswd@@ = getpwnam ( @@constchar@@ ) ; @@sizet@@ = strlen ( @@constchar@@ ) ; @@int64@@ = xmalloc ( @@sizet@@ + Number ) ; strcpy ( ( char * ) ( @@int64@@ + Number ) , @@constchar@@ ) ; if ( @@structpasswd@@ ) { * ( _DWORD * ) @@int64@@ = @@structpasswd@@ -> pw_uid ; * ( _QWORD * ) ( @@int64@@ + Number ) = user_alist ; user_alist = @@int64@@ ; @@int64@@ = @@int64@@ ; } else { * ( _QWORD * ) ( @@int64@@ + Number ) = nouser_alist ; nouser_alist = @@int64@@ ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 __fastcall calc_state_hash ( __int64 @@int64@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) + @@unsignedint@@ ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { @@int64@@ += * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; } return @@int64@@ ; }
__int64 __fastcall argmatch_to_argument ( const void * @@constvoid@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; ++ @@int64@@ ) { if ( ! memcmp ( @@constvoid@@ , ( const void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) , @@sizet@@ ) ) return * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; } return Number L ; }
__int64 __fastcall rpl_re_compile_fastmap ( __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; void * @@void@@ ; @@QWORD@@ = * ( _QWORD * * ) @@int64@@ ; @@void@@ = * ( void * * ) ( @@int64@@ + Number ) ; memset ( @@void@@ , Number , Number ) ; re_compile_fastmap_iter ( @@int64@@ , @@QWORD@@ [ Number ] , @@void@@ ) ; if ( @@QWORD@@ [ Number ] != @@QWORD@@ [ Number ] ) re_compile_fastmap_iter ( @@int64@@ , @@QWORD@@ [ Number ] , @@void@@ ) ; if ( @@QWORD@@ [ Number ] != @@QWORD@@ [ Number ] ) re_compile_fastmap_iter ( @@int64@@ , @@QWORD@@ [ Number ] , @@void@@ ) ; if ( @@QWORD@@ [ Number ] != @@QWORD@@ [ Number ] ) re_compile_fastmap_iter ( @@int64@@ , @@QWORD@@ [ Number ] , @@void@@ ) ; * ( _BYTE * ) ( @@int64@@ + Number ) |= Number ; return Number L ; }
__int64 __fastcall register_state ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; void * @@void@@ ; __int64 @@int64@@ ; * @@QWORD@@ = @@int64@@ ; if ( ( unsigned int ) re_node_set_alloc ( @@QWORD@@ + Number , @@QWORD@@ [ Number ] ) ) return Number L ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@QWORD@@ [ Number ] ; ++ @@unsignedint64@@ ) { @@int64@@ = * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@QWORD@@ [ Number ] ) ; if ( ( * ( _BYTE * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) & Number ) == Number && ( unsigned __int8 ) re_node_set_insert_last ( ( __int64 ) ( @@QWORD@@ + Number ) , @@int64@@ ) != Number ) { return Number L ; } } @@int64@@ = @@QWORD@@ [ Number ] + Number * ( @@int64@@ & @@QWORD@@ [ Number ] ) ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) <= * ( _QWORD * ) @@int64@@ ) { @@int64@@ = * ( _QWORD * ) @@int64@@ + Number L ; @@int64@@ = Number * @@int64@@ ; @@void@@ = realloc ( * ( void * * ) ( @@int64@@ + Number ) , Number * @@int64@@ ) ; if ( ! @@void@@ ) return Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@void@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; } @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = ( * ( _QWORD * ) @@int64@@ ) ++ ; * ( _QWORD * ) ( @@int64@@ + Number * @@int64@@ ) = @@QWORD@@ ; return Number L ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
void __fastcall mpsort ( __int64 * @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 ( __fastcall * @ @ VAR_1625 @ @ int64 ( fastcall ) ( int64 , int64 ) @ @ comparisonfunction ) ( __int64 , __int64 ) ) { mpsort_with_tmp ( @@int64@@ , @@unsignedint64@@ , & @@int64@@ [ @@unsignedint64@@ ] , @ @ VAR_1625 @ @ int64 ( fastcall ) ( int64 , int64 ) @ @ comparisonfunction ) ; }
__int64 __fastcall free_workarea_compile ( __int64 * @@int64@@ ) { __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; @@int64@@ = * @@int64@@ ; for ( @@QWORD@@ = * ( _QWORD * * ) ( * @@int64@@ + Number ) ; @@QWORD@@ ; @@QWORD@@ = @@QWORD@@ ) { @@QWORD@@ = ( _QWORD * ) * @@QWORD@@ ; free ( @@QWORD@@ ) ; } * ( _QWORD * ) ( @@int64@@ + Number ) = Number L ; * ( _DWORD * ) ( @@int64@@ + Number ) = Number ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number L ; free ( * ( void * * ) ( @@int64@@ + Number ) ) ; @@int64@@ = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number L ; return @@int64@@ ; }
_BYTE * __fastcall strmode ( __int16 @@int16@@ , _BYTE * @@BYTE@@ ) { char @@char@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; char @@char@@ ; _BYTE * @@BYTE@@ ; * @@BYTE@@ = ftypelet ( @@int16@@ ) ; if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) { if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; } else if ( ( @@int16@@ & Number ) != Number ) { @@char@@ = Number ; } else { @@char@@ = Number ; } @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) { if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; } else if ( ( @@int16@@ & Number ) != Number ) { @@char@@ = Number ; } else { @@char@@ = Number ; } @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; @@BYTE@@ [ Number ] = @@char@@ ; if ( ( @@int16@@ & Number ) != Number ) { if ( ( @@int16@@ & Number ) != Number ) @@char@@ = Number ; else @@char@@ = Number ; } else if ( ( @@int16@@ & Number ) != Number ) { @@char@@ = Number ; } else { @@char@@ = Number ; } @@BYTE@@ [ Number ] = @@char@@ ; @@BYTE@@ [ Number ] = Number ; @@BYTE@@ = @@BYTE@@ + Number ; @@BYTE@@ [ Number ] = Number ; return @@BYTE@@ ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_21FE88 ; @@int648@@ [ Number ] = qword_21FE90 ; @@int648@@ [ Number ] = qword_21FE98 ; @@int648@@ [ Number ] = qword_21FEA0 ; @@int648@@ [ Number ] = qword_21FEA8 ; @@int648@@ [ Number ] = qword_21FEB0 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
__int64 __fastcall optimize_subexps ( __int64 @@int64@@ , __int64 @@int64@@ ) { unsigned __int64 @@unsignedint64@@ ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) == Number && * ( _QWORD * ) ( @@int64@@ + Number ) ) { * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( Number L * ( int ) * ( _QWORD * ) ( @@int64@@ + Number ) + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; * ( _QWORD * ) ( @@int64@@ + Number ) |= Number << * ( _QWORD * ) ( @@int64@@ + Number ) ; } else if ( * ( _BYTE * ) ( @@int64@@ + Number ) == Number && * ( _QWORD * ) ( @@int64@@ + Number ) && * ( _BYTE * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) == Number ) { @@unsignedint64@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) * * ( _QWORD * * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@unsignedint64@@ ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L * * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= Number ) * ( _QWORD * ) ( @@int64@@ + Number ) &= ~ ( Number L << @@unsignedint64@@ ) ; } return Number L ; }
__int64 __fastcall lower_subexps ( __int64 @@int64@@ , __int64 @@int64@@ ) { unsigned int @@unsignedint@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = @@int64@@ ; @@unsignedint@@ = Number ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) { if ( * ( _BYTE * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) == Number ) { * ( _QWORD * ) ( @@int64@@ + Number ) = lower_subexp ( & @@unsignedint@@ , @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) * * ( _QWORD * * ) ( @@int64@@ + Number ) = @@int64@@ ; } } if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) { if ( * ( _BYTE * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) == Number ) { * ( _QWORD * ) ( @@int64@@ + Number ) = lower_subexp ( & @@unsignedint@@ , @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) * * ( _QWORD * * ) ( @@int64@@ + Number ) = @@int64@@ ; } } return @@unsignedint@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ ) { return xmalloc ( @@int64@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
unsigned __int64 __fastcall compute_bucket_size ( __int64 @@int64@@ , __int64 @@int64@@ ) { float @@float@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; float @@float@@ ; @@unsignedint64@@ = @@int64@@ ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) != Number ) { if ( @@int64@@ < Number ) @@float@@ = ( float ) ( @@int64@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@int64@@ >> Number ) ) + ( float ) ( @@int64@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@int64@@ >> Number ) ) ; else @@float@@ = ( float ) ( int ) @@int64@@ ; @@float@@ = @@float@@ / * ( float * ) ( @@int64@@ + Number ) ; if ( @@float@@ >= Number ) return Number L ; if ( @@float@@ >= Number ) @@unsignedint64@@ = ( unsigned int ) ( int ) ( float ) ( @@float@@ - Number ) ^ Number ; else @@unsignedint64@@ = ( unsigned int ) ( int ) @@float@@ ; } @@unsignedint64@@ = next_prime ( @@unsignedint64@@ ) ; if ( @@unsignedint64@@ <= Number ) @@unsignedint64@@ = @@unsignedint64@@ ; else @@unsignedint64@@ = Number L ; return @@unsignedint64@@ ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@unsignedint64@@ , int @@int@@ ) { __int64 @@int64@@ ; if ( is_mul_ok ( @@int@@ , * @@unsignedint64@@ ) ) { * @@unsignedint64@@ *= @@int@@ ; @@int64@@ = Number L ; } else { * @@unsignedint64@@ = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 __fastcall search_duplicated_node ( _QWORD * @@QWORD@@ , __int64 @@int64@@ , int @@int@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = @@QWORD@@ [ Number ] - Number L ; ( * ( _BYTE * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) & Number ) != Number && @@int64@@ ; -- @@int64@@ ) { if ( @@int64@@ == * ( _QWORD * ) ( Number * @@int64@@ + @@QWORD@@ [ Number ] ) && @@int@@ == ( ( * ( _DWORD * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) >> Number ) & Number ) ) { return @@int64@@ ; } } return Number ; }
__int64 __fastcall link_nfa_nodes ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; unsigned int @@unsignedint@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@unsignedint@@ = Number ; switch ( * ( _BYTE * ) ( @@int64@@ + Number ) ) { case Number : if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) __assert_fail ( String , String , Number , String ) ; return @@int64@@ ; case Number : * ( _QWORD * ) ( Number * @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) == Number ) re_node_set_init_1 ( ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ ) , * ( _QWORD * ) ( Number * @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; break ; case Number : case Number : case Number : @@unsignedint@@ = re_node_set_init_1 ( ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ ) , * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) ) ; break ; case Number : case Number : * ( _BYTE * ) ( @@int64@@ + Number ) |= Number ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) @@unsignedint64@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) + Number L ) ; else @@unsignedint64@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) @@unsignedint64@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) + Number L ) ; else @@unsignedint64@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) ; if ( @@unsignedint64@@ > Number ) __assert_fail ( String , String , Number , String ) ; if ( @@unsignedint64@@ > Number ) __assert_fail ( String , String , Number , String ) ; @@unsignedint@@ = re_node_set_init_2 ( ( _QWORD * ) ( Number * @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) , @@unsignedint64@@ , @@unsignedint64@@ ) ; break ; case Number : return @@unsignedint@@ ; default : if ( ( * ( _BYTE * ) ( @@int64@@ + Number ) & Number ) != Number ) __assert_fail ( String , String , Number , String ) ; * ( _QWORD * ) ( Number * @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) ; break ; } return @@unsignedint@@ ; }
__int64 __fastcall bkm_scale_by_power_0 ( unsigned __int64 * @@unsignedint64@@ , int @@int@@ , int @@int@@ ) { unsigned int @@unsignedint@@ ; for ( @@unsignedint@@ = Number ; @@int@@ -- ; @@unsignedint@@ |= bkm_scale_0 ( @@unsignedint64@@ , @@int@@ ) ) { ; } return @@unsignedint@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
__int64 __fastcall hash_rehash ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; void * @@void@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@unsignedint64@@ = compute_bucket_size ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( ! @@unsignedint64@@ ) return Number L ; if ( @@unsignedint64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ) return Number L ; @@void@@ = calloc ( @@unsignedint64@@ , Number ) ; if ( ! @@void@@ ) return Number L ; @@unsignedint64@@ = @@unsignedint64@@ ; @@int64@@ = ( __int64 ) @@void@@ + Number * @@unsignedint64@@ ; @@int64@@ = Number L ; @@int64@@ = Number L ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( ( unsigned __int8 ) transfer_entries ( ( __int64 ) & @@void@@ , @@int64@@ , Number ) ) { free ( * ( void * * ) @@int64@@ ) ; * ( _QWORD * ) @@int64@@ = @@void@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@unsignedint64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; @@int64@@ = Number L ; } else { * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; if ( ( unsigned __int8 ) transfer_entries ( @@int64@@ , ( __int64 ) & @@void@@ , Number ) != Number || ( unsigned __int8 ) transfer_entries ( @@int64@@ , ( __int64 ) & @@void@@ , Number ) != Number ) { abort ( ) ; } free ( @@void@@ ) ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall peek_token_bracket ( _BYTE * @@BYTE@@ , __int64 @@int64@@ , char @@char@@ ) { char @@char@@ ; char @@char@@ ; unsigned int @@unsignedint@@ ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) <= * ( _QWORD * ) ( @@int64@@ + Number ) ) { @@BYTE@@ [ Number ] = Number ; return Number L ; } @@char@@ = * ( _BYTE * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; * @@BYTE@@ = @@char@@ ; if ( * ( int * ) ( @@int64@@ + Number ) > Number && * ( _QWORD * ) ( @@int64@@ + Number ) != * ( _QWORD * ) ( @@int64@@ + Number ) && * ( _DWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L * * ( _QWORD * ) ( @@int64@@ + Number ) ) == Number ) { @@BYTE@@ [ Number ] = Number ; return Number L ; } if ( @@char@@ == Number && ( @@char@@ & Number ) != Number && ( unsigned __int64 ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) < * ( _QWORD * ) ( @@int64@@ + Number ) ) { ++ * ( _QWORD * ) ( @@int64@@ + Number ) ; * @@BYTE@@ = * ( _BYTE * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; @@BYTE@@ [ Number ] = Number ; return Number L ; } switch ( @@char@@ ) { case String : if ( ( unsigned __int64 ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) >= * ( _QWORD * ) ( @@int64@@ + Number ) ) @@char@@ = Number ; else @@char@@ = * ( _BYTE * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) ; * @@BYTE@@ = @@char@@ ; @@unsignedint@@ = Number ; switch ( @@char@@ ) { case String : if ( ( @@char@@ & Number ) != Number ) { @@BYTE@@ [ Number ] = Number ; return @@unsignedint@@ ; } break ; case String : @@BYTE@@ [ Number ] = Number ; return @@unsignedint@@ ; case String : @@BYTE@@ [ Number ] = Number ; return @@unsignedint@@ ; } @@BYTE@@ [ Number ] = Number ; * @@BYTE@@ = Number ; return Number ; case String : @@BYTE@@ [ Number ] = Number ; break ; case String : @@BYTE@@ [ Number ] = Number ; break ; case String : @@BYTE@@ [ Number ] = Number ; break ; default : @@BYTE@@ [ Number ] = Number ; break ; } return Number L ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall parse_sub_exp ( __int64 @@int64@@ , __int64 * @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , _DWORD * @@DWORD@@ ) { unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int64@@ = * @@int64@@ ; @@unsignedint64@@ = @@int64@@ [ Number ] ; @@int64@@ [ Number ] = @@unsignedint64@@ + Number ; @@unsignedint64@@ = @@unsignedint64@@ ; fetch_token ( @@int64@@ , @@int64@@ , @@int64@@ | Number ) ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) == Number ) { @@int64@@ = Number L ; } else { @@int64@@ = parse_reg_exp ( @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@DWORD@@ ) ; if ( ! * @@DWORD@@ && * ( _BYTE * ) ( @@int64@@ + Number ) != Number ) * @@DWORD@@ = Number ; if ( * @@DWORD@@ ) return Number L ; } if ( @@unsignedint64@@ <= Number ) * ( _QWORD * ) ( @@int64@@ + Number ) |= Number << @@unsignedint64@@ ; @@int64@@ = create_tree ( @@int64@@ , @@int64@@ , Number L , Number L ) ; if ( @@int64@@ ) { * ( _QWORD * ) ( @@int64@@ + Number ) = @@unsignedint64@@ ; @@int64@@ = @@int64@@ ; } else { * @@DWORD@@ = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
__int64 __fastcall getgroup ( __gid_t @@gidt@@ ) { const char * @@constchar@@ ; size_t @@sizet@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; struct group * @@structgroup@@ ; char * @@char@@ ; @@int64@@ = Number L ; for ( @@int64@@ = group_alist ; @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ) { if ( @@gidt@@ == * ( _DWORD * ) @@int64@@ ) { @@int64@@ = @@int64@@ ; break ; } } if ( ! @@int64@@ ) { @@structgroup@@ = getgrgid ( @@gidt@@ ) ; if ( @@structgroup@@ ) @@constchar@@ = @@structgroup@@ -> gr_name ; else @@constchar@@ = ( const char * ) & unk_19CC0 ; @@char@@ = ( char * ) @@constchar@@ ; @@sizet@@ = strlen ( @@constchar@@ ) ; @@int64@@ = xmalloc ( @@sizet@@ + Number ) ; * ( _DWORD * ) @@int64@@ = @@gidt@@ ; strcpy ( ( char * ) ( @@int64@@ + Number ) , @@char@@ ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = group_alist ; group_alist = @@int64@@ ; } if ( * ( _BYTE * ) ( @@int64@@ + Number ) ) @@int64@@ = @@int64@@ + Number ; else @@int64@@ = Number L ; return @@int64@@ ; }
__int64 __fastcall create_tree ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , char @@char@@ ) { char @@char24@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@char24@@ [ Number ] = @@char@@ ; return create_token_tree ( @@int64@@ , @@int64@@ , @@int64@@ , @@char24@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
__int64 __fastcall memcpy_lowcase ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { while ( @@int64@@ -- ) * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) = tolower ( * ( unsigned __int8 * ) ( @@int64@@ + @@int64@@ ) ) ; return @@int64@@ ; }
__int64 __fastcall fetch_number ( __int64 @@int64@@ , unsigned __int8 * @@unsignedint8@@ , __int64 @@int64@@ ) { unsigned __int64 @@unsignedint64@@ ; unsigned __int8 @@unsignedint8@@ ; __int64 @@int64@@ ; for ( @@int64@@ = Number ; ; @@int64@@ = @@unsignedint64@@ ) { fetch_token ( ( __int64 ) @@unsignedint8@@ , @@int64@@ , @@int64@@ ) ; @@unsignedint8@@ = * @@unsignedint8@@ ; if ( @@unsignedint8@@ [ Number ] == Number ) return Number ; if ( @@unsignedint8@@ [ Number ] == Number || @@unsignedint8@@ == Number ) break ; if ( @@unsignedint8@@ [ Number ] != Number || @@unsignedint8@@ <= Number || @@unsignedint8@@ > Number || @@int64@@ == Number ) { @@unsignedint64@@ = Number ; } else if ( @@int64@@ == Number ) { @@unsignedint64@@ = @@unsignedint8@@ - Number ; } else { @@unsignedint64@@ = Number * @@int64@@ + @@unsignedint8@@ - Number ; } if ( @@unsignedint64@@ > Number ) @@unsignedint64@@ = Number ; } return @@int64@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
__int64 __fastcall create_token_tree ( __int64 @@int64@@ , __int64 * @@int64@@ , __int64 * @@int64@@ , _QWORD * @@QWORD@@ ) { __int64 @@int64@@ ; int @@int@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; if ( * ( _DWORD * ) ( @@int64@@ + Number ) == Number ) { @@QWORD@@ = malloc ( Number ) ; if ( ! @@QWORD@@ ) return Number L ; * @@QWORD@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@QWORD@@ ; * ( _DWORD * ) ( @@int64@@ + Number ) = Number ; } @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) ; * ( _DWORD * ) ( @@int64@@ + Number ) = @@int@@ + Number ; @@int64@@ = @@int64@@ + ( ( __int64 ) @@int@@ << Number ) + Number ; * ( _QWORD * ) @@int64@@ = Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; @@int64@@ = @@QWORD@@ [ Number ] ; * ( _QWORD * ) ( @@int64@@ + Number ) = * @@QWORD@@ ; * ( _QWORD * ) ( @@int64@@ + ( ( __int64 ) @@int@@ << Number ) + Number ) = @@int64@@ ; * ( _BYTE * ) ( @@int64@@ + Number ) &= Number ; * ( _BYTE * ) ( @@int64@@ + Number ) &= Number ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number ; if ( @@int64@@ ) * @@int64@@ = @@int64@@ ; if ( @@int64@@ ) * @@int64@@ = @@int64@@ ; return @@int64@@ + ( ( __int64 ) @@int@@ << Number ) + Number ; }
void __fastcall mpsort_with_tmp ( __int64 * @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 * @@int64@@ , __int64 ( __fastcall * @ @ VAR_1614 @ @ int64 ( fastcall ) ( int64 , int64 ) @ @ int64 ( fastcall ) ( int64 , int64 ) ) ( __int64 , __int64 ) ) { int @@int@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; if ( @@unsignedint64@@ > Number ) { @@int64@@ = Number L ; @@unsignedint64@@ = @@unsignedint64@@ >> Number ; @@unsignedint64@@ = @@unsignedint64@@ >> Number ; mpsort_with_tmp ( & @@int64@@ [ @@unsignedint64@@ >> Number ] , @@unsignedint64@@ - ( @@unsignedint64@@ >> Number ) , @@int64@@ , @ @ VAR_1614 @ @ int64 ( fastcall ) ( int64 , int64 ) @ @ int64 ( fastcall ) ( int64 , int64 ) ) ; if ( @@unsignedint64@@ >> Number > Number ) mpsort_into_tmp ( @@int64@@ , @@unsignedint64@@ >> Number , @@int64@@ , @ @ VAR_1614 @ @ int64 ( fastcall ) ( int64 , int64 ) @ @ int64 ( fastcall ) ( int64 , int64 ) ) ; else * @@int64@@ = * @@int64@@ ; @@int64@@ = * @@int64@@ ; @@int64@@ = @@int64@@ [ @@unsignedint64@@ ] ; @@int64@@ = Number L ; for ( @@int@@ = @ @ VAR_1614 @ @ int64 ( fastcall ) ( int64 , int64 ) @ @ int64 ( fastcall ) ( int64 , int64 ) ( * @@int64@@ , @@int64@@ ) ; ; @@int@@ = @ @ VAR_1614 @ @ int64 ( fastcall ) ( int64 , int64 ) @ @ int64 ( fastcall ) ( int64 , int64 ) ( @@int64@@ , @@int64@@ ) ) { while ( @@int@@ <= Number ) { @@int64@@ = @@int64@@ ++ ; @@int64@@ [ @@int64@@ ] = @@int64@@ ; if ( ++ @@int64@@ == @@unsignedint64@@ ) return ; @@int64@@ = @@int64@@ [ @@int64@@ ] ; @@int@@ = @ @ VAR_1614 @ @ int64 ( fastcall ) ( int64 , int64 ) @ @ int64 ( fastcall ) ( int64 , int64 ) ( @@int64@@ , @@int64@@ ) ; } @@int64@@ = @@int64@@ ++ ; @@int64@@ [ @@int64@@ ] = @@int64@@ ; if ( ++ @@unsignedint64@@ == @@unsignedint64@@ ) break ; @@int64@@ = @@int64@@ [ @@unsignedint64@@ ] ; } memcpy ( & @@int64@@ [ @@int64@@ ] , & @@int64@@ [ @@int64@@ ] , Number * ( @@unsignedint64@@ - @@int64@@ ) ) ; } else if ( @@unsignedint64@@ == Number ) { @@int64@@ = * @@int64@@ ; @@int64@@ = @@int64@@ [ Number ] ; if ( ( int ) @ @ VAR_1614 @ @ int64 ( fastcall ) ( int64 , int64 ) @ @ int64 ( fastcall ) ( int64 , int64 ) ( * @@int64@@ , @@int64@@ ) > Number ) { * @@int64@@ = @@int64@@ ; @@int64@@ [ Number ] = @@int64@@ ; } } }
__int64 __fastcall umaxtostr ( unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = @@int64@@ + Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = Number ; do { * ( _BYTE * ) -- @@int64@@ = @@unsignedint64@@ % Number + Number ; @@unsignedint64@@ /= Number ; } while ( @@unsignedint64@@ ) ; return @@int64@@ ; }
void __fastcall free_token ( __int64 @@int64@@ ) { if ( * ( _BYTE * ) ( @@int64@@ + Number ) != Number || ( * ( _BYTE * ) ( @@int64@@ + Number ) & Number ) != Number ) { if ( * ( _BYTE * ) ( @@int64@@ + Number ) == Number && ( * ( _BYTE * ) ( @@int64@@ + Number ) & Number ) == Number ) free ( * ( void * * ) @@int64@@ ) ; } else { free_charset ( * ( void * * * ) @@int64@@ ) ; } }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
_BOOL8 __fastcall check_halt_node_context ( _QWORD * @@QWORD@@ , __int64 @@int64@@ , char @@char@@ ) { if ( * ( _BYTE * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) != Number ) return Number L ; if ( ( ( * ( _DWORD * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) >> Number ) & Number ) == Number ) return Number L ; return ( ( * ( _DWORD * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) & Number ) == Number || ( @@char@@ & Number ) != Number ) && ( ( * ( _DWORD * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) & Number ) == Number || ( @@char@@ & Number ) == Number ) && ( ( * ( _DWORD * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) & Number ) == Number || ( @@char@@ & Number ) != Number ) && ( ( * ( _DWORD * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) & Number ) == Number || ( @@char@@ & Number ) != Number ) ; }
__int64 __fastcall c_tolower ( int @@int@@ ) { __int64 @@int64@@ ; if ( @@int@@ <= Number || @@int@@ > Number ) @@int64@@ = ( unsigned int ) @@int@@ ; else @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; return @@int64@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall rpl_re_search_2 ( int @@int@@ , int @@int@@ , int @@int@@ , int @@int@@ , int @@int@@ , int @@int@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return re_search_2_stub ( @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int64@@ , @@int64@@ , @@int64@@ , Number ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
_QWORD * __fastcall update_regs ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ , void * @@void@@ , __int64 @@int64@@ , _QWORD * @@QWORD@@ , unsigned __int64 @@unsignedint64@@ ) { _QWORD * @@QWORD@@ ; int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@QWORD@@ = ( _QWORD * ) * ( unsigned __int8 * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) ; @@int@@ = * ( unsigned __int8 * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) ; if ( @@int@@ == Number ) { @@unsignedint64@@ = * ( _QWORD * ) ( Number * @@int64@@ + * @@QWORD@@ ) + Number L ; @@QWORD@@ = ( _QWORD * ) @@unsignedint64@@ ; if ( @@unsignedint64@@ < @@unsignedint64@@ ) { @@QWORD@@ [ Number * @@unsignedint64@@ ] = @@QWORD@@ ; @@QWORD@@ = & @@QWORD@@ [ Number * @@unsignedint64@@ ] ; @@QWORD@@ [ Number ] = Number ; } } else if ( @@int@@ == Number ) { @@unsignedint64@@ = * ( _QWORD * ) ( Number * @@int64@@ + * @@QWORD@@ ) + Number L ; @@QWORD@@ = ( _QWORD * ) @@unsignedint64@@ ; if ( @@unsignedint64@@ < @@unsignedint64@@ ) { if ( ( unsigned __int64 ) @@QWORD@@ <= @@QWORD@@ [ Number * @@unsignedint64@@ ] ) { if ( ( * ( _BYTE * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) & Number ) == Number || * ( ( _QWORD * ) @@void@@ + Number * @@unsignedint64@@ ) == Number ) { @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ [ Number * @@unsignedint64@@ + Number ] = @@QWORD@@ ; } else { @@QWORD@@ = memcpy ( @@QWORD@@ , @@void@@ , Number * @@unsignedint64@@ ) ; } } else { @@QWORD@@ [ Number * @@unsignedint64@@ + Number ] = @@QWORD@@ ; @@QWORD@@ = memcpy ( @@void@@ , @@QWORD@@ , Number * @@unsignedint64@@ ) ; } } } return @@QWORD@@ ; }
__int64 __fastcall nstrftime ( char * @@char@@ , __int64 @@int64@@ , char * @@char@@ , __int64 @@int64@@ , int @@int@@ , int @@int@@ ) { return strftime_case_ ( Number , @@char@@ , @@int64@@ , @@char@@ , @@int64@@ , @@int@@ , @@int@@ ) ; }
__int64 __fastcall bkm_scale_0 ( unsigned __int64 * @@unsignedint64@@ , int @@int@@ ) { __int64 @@int64@@ ; if ( is_mul_ok ( @@int@@ , * @@unsignedint64@@ ) ) { * @@unsignedint64@@ *= @@int@@ ; @@int64@@ = Number L ; } else { * @@unsignedint64@@ = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
_QWORD * __fastcall rpl_re_set_registers ( __int64 @@int64@@ , _QWORD * @@QWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; if ( @@int64@@ ) { * ( _BYTE * ) ( @@int64@@ + Number ) = * ( _BYTE * ) ( @@int64@@ + Number ) & Number | Number ; * @@QWORD@@ = @@int64@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; } else { * ( _BYTE * ) ( @@int64@@ + Number ) &= Number ; * @@QWORD@@ = Number L ; @@QWORD@@ [ Number ] = Number L ; @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ [ Number ] = @@QWORD@@ [ Number ] ; } return @@QWORD@@ ; }
__int64 __fastcall x2nrealloc ( __int64 @@int64@@ , unsigned __int64 * @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = * @@unsignedint64@@ ; if ( @@int64@@ ) { if ( @@unsignedint64@@ >= Number / @@unsignedint64@@ ) xalloc_die ( ) ; @@unsignedint64@@ += ( @@unsignedint64@@ + Number ) >> Number ; } else if ( ! @@unsignedint64@@ ) { @@unsignedint64@@ = ( Number / @@unsignedint64@@ == Number ) + Number / @@unsignedint64@@ ; } * @@unsignedint64@@ = @@unsignedint64@@ ; return xrealloc ( @@int64@@ , @@unsignedint64@@ * @@unsignedint64@@ ) ; }
__int64 __fastcall add_epsilon_src_nodes ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { unsigned int @@unsignedint@@ ; unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@unsignedint@@ = Number ; @@QWORD@@ = re_acquire_state ( & @@unsignedint@@ , @@int64@@ , @@int64@@ ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; if ( ! @@QWORD@@ [ Number ] ) { @@unsignedint@@ = re_node_set_alloc ( @@QWORD@@ + Number , * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint@@ ) return Number L ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { re_node_set_merge ( ( __int64 ) ( @@QWORD@@ + Number ) , * ( _QWORD * ) ( @@int64@@ + Number ) + Number L * * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; } } return re_node_set_add_intersect ( @@int64@@ , @@int64@@ , ( __int64 ) ( @@QWORD@@ + Number ) ) ; }
__int64 __fastcall c_toupper ( int @@int@@ ) { __int64 @@int64@@ ; if ( @@int@@ <= Number || @@int@@ > Number ) @@int64@@ = ( unsigned int ) @@int@@ ; else @@int64@@ = ( unsigned int ) ( @@int@@ - Number ) ; return @@int64@@ ; }
__int64 __fastcall check_halt_state_context ( __int64 @@int64@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { char @@char@@ ; unsigned __int64 @@unsignedint64@@ ; @@char@@ = re_string_context_at ( @@int64@@ , @@unsignedint64@@ , * ( _DWORD * ) ( @@int64@@ + Number ) ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { if ( check_halt_node_context ( * ( _QWORD * * ) ( @@int64@@ + Number ) , * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) , @@char@@ ) ) { return * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; } } return Number L ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
__int64 __fastcall check_dst_limits_calc_pos ( __int64 @@int64@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ ; if ( @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ) return Number ; if ( @@unsignedint64@@ > * ( _QWORD * ) ( @@int64@@ + Number ) ) return Number L ; if ( @@unsignedint64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ) @@int@@ = Number ; else @@int@@ = Number ; @@int@@ = @@int@@ | ( @@unsignedint64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( @@int@@ ) @@int64@@ = check_dst_limits_calc_pos_1 ( @@int64@@ , @@int@@ , @@unsignedint64@@ , @@int64@@ , @@int64@@ ) ; else @@int64@@ = Number L ; return @@int64@@ ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
__int64 __fastcall free_fail_stack_return ( __int64 @@int64@@ ) { unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) { for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) @@int64@@ ; ++ @@unsignedint64@@ ) { free ( * ( void * * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@unsignedint64@@ + Number ) ) ; free ( * ( void * * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@unsignedint64@@ + Number ) ) ; } free ( * ( void * * ) ( @@int64@@ + Number ) ) ; } return Number L ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
__int64 __fastcall append_char_class ( __int64 @@int64@@ , const char * @@constchar@@ , size_t @@sizet@@ ) { int @@int@@ ; __int64 @@int64@@ ; @@int@@ = look_up_char_class ( @@constchar@@ , @@sizet@@ ) ; if ( @@int@@ == Number ) return Number L ; @@int64@@ = xmalloc ( Number L ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number L ; * ( _DWORD * ) @@int64@@ = Number ; * ( _DWORD * ) ( @@int64@@ + Number ) = @@int@@ ; if ( ! * ( _QWORD * ) ( @@int64@@ + Number ) ) __assert_fail ( String , String , Number , String ) ; * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; return Number L ; }
__int64 __fastcall find_recover_state ( _DWORD * @@DWORD@@ , _QWORD * @@QWORD@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; do { @@unsignedint64@@ = @@QWORD@@ [ Number ] ; @@int64@@ = @@QWORD@@ [ Number ] ; do { if ( ++ @@int64@@ > @@unsignedint64@@ ) return Number L ; ++ @@QWORD@@ [ Number ] ; } while ( ! * ( _QWORD * ) ( Number * @@int64@@ + @@QWORD@@ [ Number ] ) ) ; @@int64@@ = merge_state_with_log ( @@DWORD@@ , ( __int64 ) @@QWORD@@ , Number L ) ; } while ( ! * @@DWORD@@ && ! @@int64@@ ) ; return @@int64@@ ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall sift_states_backward ( __int64 @@int64@@ , __int64 @@int64@@ ) { int @@int@@ ; unsigned int @@unsignedint@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; __int64 @@int64@@ ; void * @@void@@ [ Number ] ; void * @@void@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int@@ = Number ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@unsignedint@@ = re_node_set_init_1 ( @@void@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; @@unsignedint@@ = update_cur_sifted_state ( @@int64@@ , @@int64@@ , @@int64@@ , @@void@@ ) ; if ( ! @@unsignedint@@ ) { while ( @@int64@@ ) { if ( * ( _QWORD * ) ( Number * @@int64@@ + * ( _QWORD * ) @@int64@@ ) ) @@int@@ = Number ; else @@int@@ = @@int@@ + Number ; @@int@@ = @@int@@ ; if ( @@int@@ > * ( _DWORD * ) ( @@int64@@ + Number ) ) { memset ( * ( void * * ) @@int64@@ , Number , Number * @@int64@@ ) ; free ( @@void@@ ) ; return Number L ; } @@void@@ [ Number ] = Number L ; -- @@int64@@ ; if ( ! * ( _QWORD * ) ( Number * @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) || ( @@unsignedint@@ = build_sifted_states ( @@int64@@ , @@int64@@ , @@int64@@ , @@void@@ ) ) == Number ) { @@unsignedint@@ = update_cur_sifted_state ( @@int64@@ , @@int64@@ , @@int64@@ , @@void@@ ) ; if ( ! @@unsignedint@@ ) continue ; } goto LABEL_15 ; } @@unsignedint@@ = Number ; } LABEL_15 : free ( @@void@@ ) ; return @@unsignedint@@ ; }
_BOOL8 __fastcall star_digits_closebracket ( _QWORD * @@QWORD@@ , __int64 @@int64@@ ) { unsigned __int64 @@unsignedint64@@ ; if ( ! es_match ( @@QWORD@@ , @@int64@@ , Number ) ) return Number L ; for ( @@unsignedint64@@ = @@int64@@ + Number ; @@unsignedint64@@ < @@QWORD@@ [ Number ] ; ++ @@unsignedint64@@ ) { if ( ( unsigned int ) ( unsigned __int8 ) to_uchar ( * ( _BYTE * ) ( * @@QWORD@@ + @@unsignedint64@@ ) ) - Number > Number || * ( _BYTE * ) ( @@QWORD@@ [ Number ] + @@unsignedint64@@ ) ) { return es_match ( @@QWORD@@ , @@unsignedint64@@ , Number ) ; } } return Number L ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
__int64 __fastcall check_arrival_expand_ecl ( _QWORD * @@QWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; unsigned int @@unsignedint@@ ; unsigned int @@unsignedint@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ [ Number ] ; void * @@void@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@unsignedint@@ = re_node_set_alloc ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { @@int64@@ = * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; @@int64@@ = @@QWORD@@ [ Number ] + Number * @@int64@@ ; if ( find_subexp_node ( @@QWORD@@ , @@int64@@ , @@int64@@ , @@unsignedint@@ ) == Number ) { @@unsignedint@@ = re_node_set_merge ( ( __int64 ) @@int64@@ , @@int64@@ ) ; if ( @@unsignedint@@ ) goto LABEL_6 ; } else { @@unsignedint@@ = check_arrival_expand_ecl_sub ( @@QWORD@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@unsignedint@@ ) ; if ( @@unsignedint@@ ) { LABEL_6 : free ( @@void@@ ) ; return @@unsignedint@@ ; } } } free ( * ( void * * ) ( @@int64@@ + Number ) ) ; @@int64@@ = @@int64@@ [ Number ] ; * ( _QWORD * ) @@int64@@ = @@int64@@ [ Number ] ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@void@@ ; return Number L ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_206028 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall merge_state_array ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { _QWORD * @@QWORD@@ ; unsigned int @@unsignedint@@ ; unsigned __int64 @@unsignedint64@@ ; void * @@void6@@ [ Number ] ; @@void6@@ [ Number ] = ( void * ) __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@unsignedint64@@ ; ++ @@unsignedint64@@ ) { if ( * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@int64@@ ) ) { if ( * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@int64@@ ) ) { @@unsignedint@@ = re_node_set_init_union ( @@void6@@ , * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@int64@@ ) + Number L , * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@int64@@ ) + Number L ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; @@QWORD@@ = ( _QWORD * ) ( Number * @@unsignedint64@@ + @@int64@@ ) ; * @@QWORD@@ = re_acquire_state ( & @@unsignedint@@ , @@int64@@ , ( __int64 ) @@void6@@ ) ; free ( @@void6@@ [ Number ] ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; } } else { * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@int64@@ ) = * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@int64@@ ) ; } } return Number L ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
_QWORD * __fastcall get_s2_spec_stats ( _QWORD * @@QWORD@@ , unsigned __int64 @@unsignedint64@@ ) { _QWORD * @@QWORD@@ ; get_spec_stats ( ( __int64 ) @@QWORD@@ ) ; @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; if ( @@unsignedint64@@ >= ( unsigned __int64 ) @@QWORD@@ ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; if ( @@QWORD@@ == ( _QWORD * ) ( ( char * ) & dword_0 + Number ) ) { * ( _QWORD * ) ( @@QWORD@@ [ Number ] + Number L ) = @@unsignedint64@@ - @@QWORD@@ [ Number ] ; @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ [ Number ] = @@unsignedint64@@ ; } } return @@QWORD@@ ; }
__int64 __fastcall match_ctx_init ( __int64 @@int64@@ , int @@int@@ , unsigned __int64 @@unsignedint64@@ ) { * ( _DWORD * ) ( @@int64@@ + Number ) = @@int@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number ; if ( ! @@unsignedint64@@ ) goto LABEL_7 ; if ( ! is_mul_ok ( Number , @@unsignedint64@@ ) ) return Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = malloc ( Number * @@unsignedint64@@ ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = malloc ( Number * @@unsignedint64@@ ) ; if ( ! * ( _QWORD * ) ( @@int64@@ + Number ) || ! * ( _QWORD * ) ( @@int64@@ + Number ) ) return Number L ; LABEL_7 : * ( _QWORD * ) ( @@int64@@ + Number ) = @@unsignedint64@@ ; * ( _DWORD * ) ( @@int64@@ + Number ) = Number ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@unsignedint64@@ ; return Number L ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return xmalloc ( @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall append_equiv_class ( __int64 @@int64@@ , _BYTE * @@BYTE@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; if ( @@int64@@ != Number ) return Number L ; @@int64@@ = xmalloc ( Number L ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number L ; * ( _DWORD * ) @@int64@@ = Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = * @@BYTE@@ ; if ( ! * ( _QWORD * ) ( @@int64@@ + Number ) ) __assert_fail ( String , String , Number , String ) ; * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; return Number L ; }
__int64 __fastcall string2_extend ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; int @@int@@ ; __int64 @@int64@@ ; if ( ! translating ) __assert_fail ( String , String , Number , String ) ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) <= * ( _QWORD * ) ( @@int64@@ + Number ) ) __assert_fail ( String , String , Number , String ) ; if ( ! * ( _QWORD * ) ( @@int64@@ + Number ) ) __assert_fail ( String , String , Number , String ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; switch ( * ( _DWORD * ) @@int64@@ ) { case Number : case Number : append_repeated_char ( @@int64@@ , * ( _BYTE * ) ( @@int64@@ + Number ) , * ( _QWORD * ) ( @@int64@@ + Number ) - * ( _QWORD * ) ( @@int64@@ + Number ) ) ; break ; case Number : append_repeated_char ( @@int64@@ , * ( _BYTE * ) ( @@int64@@ + Number ) , * ( _QWORD * ) ( @@int64@@ + Number ) - * ( _QWORD * ) ( @@int64@@ + Number ) ) ; break ; case Number : for ( @@int@@ = Number ; @@int@@ >= Number && ! is_char_class_member ( * ( _DWORD * ) ( @@int64@@ + Number ) , @@int@@ ) ; -- @@int@@ ) { ; } if ( @@int@@ < Number ) __assert_fail ( String , String , Number , String ) ; append_repeated_char ( @@int64@@ , @@int@@ , * ( _QWORD * ) ( @@int64@@ + Number ) - * ( _QWORD * ) ( @@int64@@ + Number ) ) ; break ; case Number : abort ( ) ; default : abort ( ) ; } @@int64@@ = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; return @@int64@@ ; }
__int64 __fastcall check_dst_limits_calc_pos_1 ( __int64 @@int64@@ , int @@int@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { int @@int@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; @@QWORD@@ = * ( _QWORD * * ) ( @@int64@@ + Number ) ; @@int64@@ = @@QWORD@@ [ Number ] + Number * @@int64@@ ; for ( @@unsignedint64@@ = Number L ; ; ++ @@unsignedint64@@ ) { if ( @@unsignedint64@@ >= * ( _QWORD * ) ( @@int64@@ + Number ) ) return ( @@int@@ >> Number ) & Number ; @@int64@@ = * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; @@int@@ = * ( unsigned __int8 * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) ; if ( @@int@@ == Number ) { if ( ( @@int@@ & Number ) != Number && @@unsignedint64@@ == * ( _QWORD * ) ( Number * @@int64@@ + * @@QWORD@@ ) ) { return Number ; } continue ; } if ( @@int@@ != Number ) break ; if ( ( @@int@@ & Number ) != Number && @@unsignedint64@@ == * ( _QWORD * ) ( Number * @@int64@@ + * @@QWORD@@ ) ) { return Number L ; } LABEL_29 : ; } if ( @@int@@ != Number || @@int64@@ == Number ) goto LABEL_29 ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ ; while ( Number ) { if ( @@int64@@ != * ( _QWORD * ) @@int64@@ || @@unsignedint64@@ <= Number && ( ( * ( unsigned __int16 * ) ( @@int64@@ + Number ) >> @@unsignedint64@@ ) & Number L ) == Number ) { goto LABEL_21 ; } @@int64@@ = * * ( _QWORD * * ) ( @@QWORD@@ [ Number ] + Number * @@int64@@ + Number ) ; if ( @@int64@@ == @@int64@@ ) break ; @@int@@ = check_dst_limits_calc_pos_1 ( @@int64@@ , @@int@@ , @@unsignedint64@@ , @@int64@@ , @@int64@@ ) ; if ( @@int@@ == Number ) return Number ; if ( ! @@int@@ && ( @@int@@ & Number ) != Number ) return Number L ; if ( @@unsignedint64@@ <= Number ) * ( _WORD * ) ( @@int64@@ + Number ) &= ~ ( unsigned __int16 ) ( Number L << @@unsignedint64@@ ) ; LABEL_21 : @@int64@@ = @@int64@@ ; @@int64@@ += Number L ; if ( ! * ( _BYTE * ) ( @@int64@@ + Number ) ) goto LABEL_29 ; } if ( ( @@int@@ & Number ) != Number ) @@int64@@ = Number ; else @@int64@@ = Number L ; return @@int64@@ ; }
_BOOL8 __fastcall es_match ( _QWORD * @@QWORD@@ , __int64 @@int64@@ , char @@char@@ ) { return @@char@@ == * ( _BYTE * ) ( * @@QWORD@@ + @@int64@@ ) && * ( _BYTE * ) ( @@QWORD@@ [ Number ] + @@int64@@ ) != Number ; }
__int64 __fastcall search_cur_bkref_entry ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@unsignedint64@@ = Number L ; while ( @@unsignedint64@@ < @@unsignedint64@@ ) { if ( @@unsignedint64@@ <= * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * ( ( @@unsignedint64@@ + @@unsignedint64@@ ) >> Number ) + Number ) ) @@unsignedint64@@ = ( @@unsignedint64@@ + @@unsignedint64@@ ) >> Number ; else @@unsignedint64@@ = ( ( @@unsignedint64@@ + @@unsignedint64@@ ) >> Number ) + Number ; } if ( @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) && @@unsignedint64@@ == * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@unsignedint64@@ + Number ) ) { @@int64@@ = @@unsignedint64@@ ; } else { @@int64@@ = Number ; } return @@int64@@ ; }
__int64 __fastcall bkm_scale_by_power ( unsigned __int64 * @@unsignedint64@@ , int @@int@@ , int @@int@@ ) { unsigned int @@unsignedint@@ ; for ( @@unsignedint@@ = Number ; @@int@@ -- ; @@unsignedint@@ |= bkm_scale ( @@unsignedint64@@ , @@int@@ ) ) { ; } return @@unsignedint@@ ; }
__int64 __fastcall get_spec_stats ( __int64 @@int64@@ ) { int @@int@@ ; char * @@char@@ ; __int64 @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; @@unsignedint64@@ = Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number L ; * ( _BYTE * ) ( @@int64@@ + Number ) = Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = Number ; for ( @@int64@@ = * ( _QWORD * ) ( * ( _QWORD * ) @@int64@@ + Number L ) ; @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ) { @@int64@@ = Number L ; switch ( * ( _DWORD * ) @@int64@@ ) { case Number : @@int64@@ = Number L ; break ; case Number : if ( * ( _BYTE * ) ( @@int64@@ + Number ) < * ( _BYTE * ) ( @@int64@@ + Number ) ) __assert_fail ( String , String , Number , String ) ; @@int64@@ = * ( unsigned __int8 * ) ( @@int64@@ + Number ) - * ( unsigned __int8 * ) ( @@int64@@ + Number ) + Number ; break ; case Number : * ( _BYTE * ) ( @@int64@@ + Number ) = Number ; for ( @@int@@ = Number ; @@int@@ <= Number ; ++ @@int@@ ) { if ( is_char_class_member ( * ( _DWORD * ) ( @@int64@@ + Number ) , @@int@@ ) ) ++ @@int64@@ ; } @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) ; if ( @@int@@ != Number && @@int@@ != Number ) * ( _BYTE * ) ( @@int64@@ + Number ) = Number ; break ; case Number : for ( @@int@@ = Number ; @@int@@ <= Number ; ++ @@int@@ ) { if ( is_equiv_class_member ( * ( _BYTE * ) ( @@int64@@ + Number ) , @@int@@ ) ) ++ @@int64@@ ; } * ( _BYTE * ) ( @@int64@@ + Number ) = Number ; break ; case Number : if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) { @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; } else { * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; ++ * ( _QWORD * ) ( @@int64@@ + Number ) ; } break ; default : abort ( ) ; } if ( @@unsignedint64@@ > @@unsignedint64@@ + @@int64@@ || @@unsignedint64@@ + @@int64@@ == Number ) { @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ ) ; } @@unsignedint64@@ += @@int64@@ ; } @@int64@@ = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@unsignedint64@@ ; return @@int64@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ ) { return xmalloc ( @@int64@@ ) ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
__int64 __fastcall get_subexp_sub ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; unsigned int @@unsignedint@@ ; unsigned int @@unsignedint@@ ; @@unsignedint@@ = check_arrival ( ( _DWORD ) @@QWORD@@ , ( int ) @@QWORD@@ + Number , * @@QWORD@@ , @@QWORD@@ [ Number ] , @@int64@@ , @@int64@@ , Number ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; @@unsignedint@@ = match_ctx_add_entry ( @@QWORD@@ , @@int64@@ , @@int64@@ , * @@QWORD@@ , @@QWORD@@ [ Number ] ) ; if ( @@unsignedint@@ ) @@int64@@ = @@unsignedint@@ ; else @@int64@@ = clean_state_log_if_needed ( @@QWORD@@ , @@int64@@ + @@QWORD@@ [ Number ] - * @@QWORD@@ ) ; return @@int64@@ ; }
__int64 __fastcall append_normal_char ( __int64 @@int64@@ , char @@char@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = xmalloc ( Number L ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number L ; * ( _DWORD * ) @@int64@@ = Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = @@char@@ ; if ( ! * ( _QWORD * ) ( @@int64@@ + Number ) ) __assert_fail ( String , String , Number , String ) ; * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) = @@int64@@ ; @@int64@@ = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; return @@int64@@ ; }
unsigned __int64 __fastcall read_and_xlate ( __int64 @@int64@@ , __int64 @@int64@@ ) { unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = plain_read ( @@int64@@ , @@int64@@ ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@unsignedint64@@ ; ++ @@unsignedint64@@ ) { * ( _BYTE * ) ( @@unsignedint64@@ + @@int64@@ ) = xlate [ ( unsigned __int8 ) to_uchar ( * ( _BYTE * ) ( @@int64@@ + @@unsignedint64@@ ) ) ] ; } return @@unsignedint64@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 __fastcall append_repeated_char ( __int64 @@int64@@ , char @@char@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = xmalloc ( Number L ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = Number L ; * ( _DWORD * ) @@int64@@ = Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = @@char@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; if ( ! * ( _QWORD * ) ( @@int64@@ + Number ) ) __assert_fail ( String , String , Number , String ) ; * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) = @@int64@@ ; @@int64@@ = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; return @@int64@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall check_arrival_expand_ecl_sub ( _QWORD * @@QWORD@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , unsigned int @@unsignedint@@ ) { unsigned __int64 @@unsignedint64@@ ; unsigned int @@unsignedint@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint64@@ ; for ( @@unsignedint64@@ = re_node_set_contains ( @@int64@@ , @@unsignedint64@@ ) ; ! @@unsignedint64@@ ; @@unsignedint64@@ = re_node_set_contains ( @@int64@@ , @@unsignedint64@@ ) ) { if ( @@unsignedint@@ == * ( unsigned __int8 * ) ( Number * @@unsignedint64@@ + * @@QWORD@@ + Number ) && @@int64@@ == * ( _QWORD * ) ( Number * @@unsignedint64@@ + * @@QWORD@@ ) ) { if ( @@unsignedint@@ == Number && ! re_node_set_insert ( @@int64@@ , @@unsignedint64@@ ) ) { return Number L ; } return Number L ; } if ( ! re_node_set_insert ( @@int64@@ , @@unsignedint64@@ ) ) return Number L ; if ( ! * ( _QWORD * ) ( @@QWORD@@ [ Number ] + Number * @@unsignedint64@@ + Number ) ) return Number L ; if ( * ( _QWORD * ) ( @@QWORD@@ [ Number ] + Number * @@unsignedint64@@ + Number ) == Number L ) { @@unsignedint@@ = check_arrival_expand_ecl_sub ( @@QWORD@@ , @@int64@@ , * ( _QWORD * ) ( * ( _QWORD * ) ( @@QWORD@@ [ Number ] + Number * @@unsignedint64@@ + Number ) + Number L ) , @@int64@@ , @@unsignedint@@ ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; } @@unsignedint64@@ = * * ( _QWORD * * ) ( @@QWORD@@ [ Number ] + Number * @@unsignedint64@@ + Number ) ; } return Number L ; }
__int64 __fastcall rpl_fcntl ( int @@int@@ , int @@int@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ , __m128 @@m128@@ ) { int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; __m128 @@m128@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; @@m128@@ = @@m128@@ ; if ( @@int@@ != Number ) return ( unsigned int ) fcntl ( @@int@@ , @@int@@ , @@int64@@ ) ; @@int@@ = @@int64@@ ; if ( have_dupfd_cloexec_2895 < Number ) { @@int@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@int@@ , Number , @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ ) ; } else { @@int@@ = fcntl ( @@int@@ , Number , ( unsigned int ) @@int64@@ ) ; if ( @@int@@ < Number && * __errno_location ( ) == Number ) { @@int@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@int@@ , Number , @@int@@ , @@int@@ , @@int@@ , @@int@@ ) ; if ( @@int@@ < Number ) return ( unsigned int ) @@int@@ ; have_dupfd_cloexec_2895 = Number ; } else { have_dupfd_cloexec_2895 = Number ; } } if ( @@int@@ >= Number && have_dupfd_cloexec_2895 == Number ) { @@int@@ = fcntl ( @@int@@ , Number ) ; if ( @@int@@ < Number || fcntl ( @@int@@ , Number , @@int@@ | Number ) == Number ) { @@int@@ = * __errno_location ( ) ; close ( @@int@@ ) ; * __errno_location ( ) = @@int@@ ; @@int@@ = Number ; } } return ( unsigned int ) @@int@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
__int64 __fastcall find_bracketed_repeat ( _QWORD * @@QWORD@@ , __int64 @@int64@@ , _BYTE * @@BYTE@@ , _QWORD * @@QWORD@@ , unsigned __int64 * @@unsignedint64@@ ) { unsigned int @@unsignedint@@ ; __int64 @@int64@@ ; char * @@char@@ ; _BYTE * @@BYTE@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; _BYTE * @@BYTE@@ ; void * @@void@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( ( unsigned __int64 ) ( @@int64@@ + Number ) >= @@QWORD@@ [ Number ] ) __assert_fail ( String , String , Number , String ) ; if ( ! es_match ( @@QWORD@@ , @@int64@@ + Number , Number ) ) return Number ; for ( @@unsignedint64@@ = @@int64@@ + Number ; ; ++ @@unsignedint64@@ ) { if ( @@unsignedint64@@ >= @@QWORD@@ [ Number ] || * ( _BYTE * ) ( @@QWORD@@ [ Number ] + @@unsignedint64@@ ) == Number ) { return Number ; } if ( * ( _BYTE * ) ( * @@QWORD@@ + @@unsignedint64@@ ) == Number ) break ; } @@unsignedint64@@ = @@unsignedint64@@ - @@int64@@ - Number ; * @@BYTE@@ = * ( _BYTE * ) ( * @@QWORD@@ + @@int64@@ ) ; if ( @@unsignedint64@@ ) { @@BYTE@@ = ( _BYTE * ) ( @@int64@@ + Number + * @@QWORD@@ ) ; if ( * @@BYTE@@ == Number ) @@unsignedint@@ = Number ; else @@unsignedint@@ = Number ; if ( ( unsigned int ) xstrtoumax ( @@BYTE@@ , & @@BYTE@@ , @@unsignedint@@ , @@QWORD@@ , Number L ) || * @@QWORD@@ == Number || & @@BYTE@@ [ @@unsignedint64@@ ] != @@BYTE@@ ) { @@void@@ = ( void * ) make_printable_str ( ( __int64 ) @@BYTE@@ , @@unsignedint64@@ ) ; @@int64@@ = quote ( @@void@@ ) ; @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ , @@int64@@ ) ; free ( @@void@@ ) ; return Number L ; } } else { * @@QWORD@@ = Number L ; } * @@unsignedint64@@ = @@unsignedint64@@ ; return Number L ; }
__int64 __fastcall xstr_cd_iconv ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = str_cd_iconv ( @@int64@@ , @@int64@@ ) ; if ( ! @@int64@@ && * __errno_location ( ) == Number ) xalloc_die ( ) ; return @@int64@@ ; }
__int64 __fastcall match_ctx_add_subtop ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; void * * @@void@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; void * @@void@@ ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) == * ( _QWORD * ) ( @@int64@@ + Number ) ) { @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = Number * @@int64@@ ; @@void@@ = realloc ( * ( void * * ) ( @@int64@@ + Number ) , Number * @@int64@@ ) ; if ( ! @@void@@ ) return Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@void@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; } @@void@@ = ( void * * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L * * ( _QWORD * ) ( @@int64@@ + Number ) ) ; * @@void@@ = calloc ( Number , Number ) ; if ( ! * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L * * ( _QWORD * ) ( @@int64@@ + Number ) ) ) return Number L ; * ( _QWORD * ) ( * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L * * ( _QWORD * ) ( @@int64@@ + Number ) ) + Number L ) = @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ + Number ; * * ( _QWORD * * ) ( @@int64@@ + Number * @@int64@@ ) = @@int64@@ ; return Number L ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
__int64 __fastcall plain_read ( __int64 @@int64@@ , __int64 @@int64@@ ) { char * @@char@@ ; int * @@int@@ ; __int64 @@int64@@ ; @@int64@@ = safe_read ( Number L , @@int64@@ , @@int64@@ ) ; if ( @@int64@@ == Number ) { @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ ) ; } return @@int64@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
char * next_line_num ( ) { char * @@char@@ ; _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; @@BYTE@@ = line_num_end ; while ( Number ) { @@char@@ = ( char * ) ( unsigned __int8 ) ( * @@BYTE@@ ) ++ ; if ( ( char ) @@char@@ <= Number ) break ; @@BYTE@@ = @@BYTE@@ -- ; * @@BYTE@@ = Number ; if ( @@BYTE@@ < line_num_start ) { if ( line_num_start <= line_buf ) { line_buf [ Number ] = Number ; } else { line_num_start = ( char * ) line_num_start - Number ; * ( _BYTE * ) line_num_start = Number ; } @@char@@ = line_num_print ; if ( line_num_start < line_num_print ) @@char@@ = -- line_num_print ; return @@char@@ ; } } return @@char@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
bool __fastcall is_basic_0 ( unsigned __int8 @@unsignedint8@@ ) { return ( ( * ( ( _DWORD * ) & is_basic_table + ( @@unsignedint8@@ >> Number ) ) >> ( @@unsignedint8@@ & Number ) ) & Number ) != Number ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
unsigned __int64 __fastcall read_and_delete ( __int64 @@int64@@ , __int64 @@int64@@ ) { unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; do { @@unsignedint64@@ = plain_read ( @@int64@@ , @@int64@@ ) ; if ( ! @@unsignedint64@@ ) return Number L ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@unsignedint64@@ && in_delete_set [ ( unsigned __int8 ) to_uchar ( * ( _BYTE * ) ( @@int64@@ + @@unsignedint64@@ ) ) ] != Number ; ++ @@unsignedint64@@ ) { ; } @@unsignedint64@@ = @@unsignedint64@@ ; for ( @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@unsignedint64@@ < @@unsignedint64@@ ; ++ @@unsignedint64@@ ) { if ( in_delete_set [ ( unsigned __int8 ) to_uchar ( * ( _BYTE * ) ( @@int64@@ + @@unsignedint64@@ ) ) ] != Number ) { @@unsignedint64@@ = @@unsignedint64@@ ++ ; * ( _BYTE * ) ( @@unsignedint64@@ + @@int64@@ ) = * ( _BYTE * ) ( @@int64@@ + @@unsignedint64@@ ) ; } } } while ( ! @@unsignedint64@@ ) ; return @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
__int64 __fastcall print_group_list ( __int64 @@int64@@ , __uid_t @@uidt@@ , unsigned int @@unsignedint@@ , unsigned int @@unsignedint@@ , unsigned __int8 @@unsignedint8@@ ) { unsigned int @@unsignedint@@ ; __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; char * @@char@@ ; int * @@int@@ ; __int64 @@int64@@ ; unsigned __int8 @@unsignedint8@@ ; int @@int@@ ; int @@int@@ ; void * @@void@@ ; struct passwd * @@structpasswd@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@unsignedint8@@ = Number ; @@structpasswd@@ = getpwuid ( @@uidt@@ ) ; if ( ! @@structpasswd@@ ) @@unsignedint8@@ = Number ; if ( ( unsigned __int8 ) print_group ( @@unsignedint@@ , @@unsignedint8@@ ) != Number ) @@unsignedint8@@ = Number ; if ( @@unsignedint@@ != @@unsignedint@@ ) { putchar_unlocked ( Number ) ; if ( ( unsigned __int8 ) print_group ( @@unsignedint@@ , @@unsignedint8@@ ) != Number ) @@unsignedint8@@ = Number ; } if ( @@structpasswd@@ ) @@unsignedint@@ = @@structpasswd@@ -> pw_gid ; else @@unsignedint@@ = Number ; @@int@@ = xgetgroups ( @@int64@@ , @@unsignedint@@ , & @@void@@ ) ; if ( @@int@@ >= Number ) { for ( @@int@@ = Number ; @@int@@ < @@int@@ ; ++ @@int@@ ) { if ( @@unsignedint@@ != * ( ( _DWORD * ) @@void@@ + @@int@@ ) && @@unsignedint@@ != * ( ( _DWORD * ) @@void@@ + @@int@@ ) ) { putchar_unlocked ( Number ) ; if ( ( unsigned __int8 ) print_group ( * ( ( unsigned int * ) @@void@@ + @@int@@ ) , @@unsignedint8@@ ) != Number ) @@unsignedint8@@ = Number ; } } free ( @@void@@ ) ; @@int64@@ = @@unsignedint8@@ ; } else { if ( @@int64@@ ) { @@int64@@ = quote ( @@int64@@ ) ; @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ , @@int64@@ ) ; } else { @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ ) ; } @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall set_initialize ( _QWORD * @@QWORD@@ , char @@char@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@QWORD@@ [ Number ] = Number ; for ( @@int64@@ = get_next ( @@QWORD@@ , Number L ) ; ( _DWORD ) @@int64@@ != Number ; @@int64@@ = get_next ( @@QWORD@@ , Number L ) ) { * ( _BYTE * ) ( ( int ) @@int64@@ + @@int64@@ ) = Number ; } if ( @@char@@ ) { for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { @@int64@@ = * ( unsigned __int8 * ) ( @@int64@@ + @@unsignedint64@@ ) == Number ; * ( _BYTE * ) ( @@int64@@ + @@unsignedint64@@ ) = @@int64@@ ; } } return @@int64@@ ; }
__int64 __fastcall xstr_iconv ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = str_iconv ( @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( ! @@int64@@ && * __errno_location ( ) == Number ) xalloc_die ( ) ; return @@int64@@ ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return xmalloc ( @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_20C058 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ ) { return xmalloc ( @@int64@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
int __fastcall print_user ( __uid_t @@uidt@@ ) { char * @@char@@ ; int @@int@@ ; struct passwd * @@structpasswd@@ ; @@structpasswd@@ = Number L ; if ( use_name ) { @@structpasswd@@ = getpwuid ( @@uidt@@ ) ; if ( ! @@structpasswd@@ ) { @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ , @@uidt@@ ) ; ok = Number ; } } if ( @@structpasswd@@ ) @@int@@ = printf ( String , @@structpasswd@@ -> pw_name ) ; else @@int@@ = printf ( String , @@uidt@@ ) ; return @@int@@ ; }
__int64 __fastcall x2nrealloc ( __int64 @@int64@@ , unsigned __int64 * @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = * @@unsignedint64@@ ; if ( @@int64@@ ) { if ( @@unsignedint64@@ >= Number / @@unsignedint64@@ ) xalloc_die ( ) ; @@unsignedint64@@ += ( @@unsignedint64@@ + Number ) >> Number ; } else if ( ! @@unsignedint64@@ ) { @@unsignedint64@@ = ( Number / @@unsignedint64@@ == Number ) + Number / @@unsignedint64@@ ; } * @@unsignedint64@@ = @@unsignedint64@@ ; return xrealloc ( @@int64@@ , @@unsignedint64@@ * @@unsignedint64@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_2080E8 ; @@int648@@ [ Number ] = qword_2080F0 ; @@int648@@ [ Number ] = qword_2080F8 ; @@int648@@ [ Number ] = qword_208100 ; @@int648@@ [ Number ] = qword_208108 ; @@int648@@ [ Number ] = qword_208110 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
bool __fastcall different ( const void * @@constvoid@@ , const void * @@constvoid@@ , unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { bool @@bool@@ ; bool @@bool@@ ; bool @@bool@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = @@unsignedint64@@ ; @@int64@@ = @@unsignedint64@@ ; if ( @@unsignedint64@@ > check_chars ) @@int64@@ = check_chars ; if ( @@unsignedint64@@ > check_chars ) @@int64@@ = check_chars ; if ( ignore_case ) { @@bool@@ = @@int64@@ != @@int64@@ || ( unsigned int ) memcasecmp ( @@constvoid@@ , @@constvoid@@ , @@int64@@ ) ; @@bool@@ = @@bool@@ ; } else if ( hard_LC_COLLATE ) { @@bool@@ = ( unsigned int ) xmemcoll ( @@constvoid@@ , @@int64@@ , @@constvoid@@ , @@int64@@ ) != Number ; } else { @@bool@@ = @@int64@@ != @@int64@@ || memcmp ( @@constvoid@@ , @@constvoid@@ , @@int64@@ ) ; @@bool@@ = @@bool@@ ; } return @@bool@@ ; }
char * __fastcall str_iconv ( char * @@char@@ , char * @@char@@ , char * @@char@@ ) { char * @@char@@ ; int @@int@@ ; int @@int@@ ; iconv_t @@iconvt@@ ; void * @@void@@ ; char * @@char@@ ; if ( * @@char@@ && ( unsigned int ) c_strcasecmp ( ( unsigned __int8 * ) @@char@@ , ( unsigned __int8 * ) @@char@@ ) ) { @@iconvt@@ = iconv_open ( @@char@@ , @@char@@ ) ; if ( @@iconvt@@ == ( iconv_t ) Number ) return Number L ; @@void@@ = str_cd_iconv ( @@char@@ , @@iconvt@@ ) ; if ( @@void@@ ) { if ( iconv_close ( @@iconvt@@ ) < Number ) { @@int@@ = * __errno_location ( ) ; free ( @@void@@ ) ; * __errno_location ( ) = @@int@@ ; return Number L ; } } else { @@int@@ = * __errno_location ( ) ; iconv_close ( @@iconvt@@ ) ; * __errno_location ( ) = @@int@@ ; } @@char@@ = ( char * ) @@void@@ ; } else { @@char@@ = strdup ( @@char@@ ) ; if ( ! @@char@@ ) * __errno_location ( ) = Number ; @@char@@ = @@char@@ ; } return @@char@@ ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
bool __fastcall is_basic_1 ( unsigned __int8 @@unsignedint8@@ ) { return ( ( * ( ( _DWORD * ) & is_basic_table + ( @@unsignedint8@@ >> Number ) ) >> ( @@unsignedint8@@ & Number ) ) & Number ) != Number ; }
unsigned __int64 __fastcall find_field ( __int64 @@int64@@ ) { const unsigned __int16 * @@constunsignedint16@@ ; const unsigned __int16 * @@constunsignedint16@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@unsignedint64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) - Number L ; @@unsignedint64@@ = Number L ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < skip_fields ; ++ @@unsignedint64@@ ) { while ( @@unsignedint64@@ < @@unsignedint64@@ ) { @@constunsignedint16@@ = * __ctype_b_loc ( ) ; if ( ( @@constunsignedint16@@ [ ( unsigned __int8 ) to_uchar ( * ( _BYTE * ) ( @@int64@@ + @@unsignedint64@@ ) ) ] & Number ) == Number ) break ; ++ @@unsignedint64@@ ; } while ( @@unsignedint64@@ < @@unsignedint64@@ ) { @@constunsignedint16@@ = * __ctype_b_loc ( ) ; if ( ( @@constunsignedint16@@ [ ( unsigned __int8 ) to_uchar ( * ( _BYTE * ) ( @@int64@@ + @@unsignedint64@@ ) ) ] & Number ) != Number ) break ; ++ @@unsignedint64@@ ; } } for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < skip_chars && @@unsignedint64@@ < @@unsignedint64@@ ; ++ @@unsignedint64@@ ) { ++ @@unsignedint64@@ ; } return * ( _QWORD * ) ( @@int64@@ + Number ) + @@unsignedint64@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
void __fastcall freea ( unsigned __int64 @@unsignedint64@@ ) { _QWORD * @@QWORD@@ ; if ( @@unsignedint64@@ && * ( _DWORD * ) ( @@unsignedint64@@ - Number ) == Number ) { for ( @@QWORD@@ = & mmalloca_results [ @@unsignedint64@@ % Number ] ; * @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) ( * @@QWORD@@ - Number L ) ) { if ( @@unsignedint64@@ == * @@QWORD@@ ) { * @@QWORD@@ = * ( _QWORD * ) ( @@unsignedint64@@ - Number ) ; free ( ( void * ) ( @@unsignedint64@@ - Number ) ) ; return ; } } } }
void __fastcall freebuffer ( __int64 @@int64@@ ) { free ( * ( void * * ) ( @@int64@@ + Number ) ) ; }
void __fastcall argmatch_invalid ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { char * @@char@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; char * @@char@@ ; if ( @@int64@@ == Number ) @@char@@ = gettext ( String ) ; else @@char@@ = gettext ( String ) ; @@char@@ = @@char@@ ; @@int64@@ = quote_n ( Number L , @@int64@@ ) ; @@int64@@ = quotearg_n_style ( Number L , Number L , @@int64@@ ) ; error ( Number , Number , @@char@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall knuth_morris_pratt_unibyte ( _BYTE * @@BYTE@@ , char * @@char@@ , _QWORD * @@QWORD@@ ) { void * @@void@@ ; unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; char * @@char@@ ; _BYTE * @@BYTE@@ ; char @@char@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; _BYTE * @@BYTE@@ ; _BYTE * @@BYTE@@ ; size_t @@sizet@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@BYTE@@ = @@BYTE@@ ; @@char@@ = @@char@@ ; @@QWORD@@ = @@QWORD@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@sizet@@ = strlen ( @@char@@ ) ; if ( @@sizet@@ > Number ) { @@unsignedint64@@ = Number L ; } else if ( Number * @@sizet@@ > Number ) { @@unsignedint64@@ = mmalloca ( Number * @@sizet@@ ) ; } else { @@void@@ = alloca ( Number * ( ( Number * ( @@sizet@@ + Number ) + Number ) / Number ) ) ; @@unsignedint64@@ = Number * ( ( ( unsigned __int64 ) & @@QWORD@@ + Number ) >> Number ) + Number ; } @@unsignedint64@@ = @@unsignedint64@@ ; if ( ! @@unsignedint64@@ ) return Number L ; * ( _QWORD * ) ( @@unsignedint64@@ + Number ) = Number L ; @@int64@@ = Number L ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@sizet@@ ; ++ @@unsignedint64@@ ) { @@char@@ = @@char@@ [ @@unsignedint64@@ - Number ] ; while ( Number ) { if ( @@char@@ == @@char@@ [ @@int64@@ ] ) { ++ @@int64@@ ; * ( _QWORD * ) ( @@unsignedint64@@ + Number * @@unsignedint64@@ ) = @@unsignedint64@@ - @@int64@@ ; goto LABEL_15 ; } if ( ! @@int64@@ ) break ; @@int64@@ -= * ( _QWORD * ) ( Number * @@int64@@ + @@unsignedint64@@ ) ; } * ( _QWORD * ) ( @@unsignedint64@@ + Number * @@unsignedint64@@ ) = @@unsignedint64@@ ; LABEL_15 : ; } * @@QWORD@@ = Number L ; @@int64@@ = Number L ; @@BYTE@@ = @@BYTE@@ ; @@BYTE@@ = @@BYTE@@ ; while ( * @@BYTE@@ ) { if ( @@char@@ [ @@int64@@ ] == * @@BYTE@@ ) { ++ @@int64@@ ; ++ @@BYTE@@ ; if ( @@int64@@ == @@sizet@@ ) { * @@QWORD@@ = @@BYTE@@ ; break ; } } else if ( @@int64@@ ) { @@BYTE@@ += * ( _QWORD * ) ( Number * @@int64@@ + @@unsignedint64@@ ) ; @@int64@@ -= * ( _QWORD * ) ( Number * @@int64@@ + @@unsignedint64@@ ) ; } else { ++ @@BYTE@@ ; ++ @@BYTE@@ ; } } freea ( @@unsignedint64@@ ) ; return Number L ; }
bool __fastcall is_basic_2 ( unsigned __int8 @@unsignedint8@@ ) { return ( ( * ( ( _DWORD * ) & is_basic_table + ( @@unsignedint8@@ >> Number ) ) >> ( @@unsignedint8@@ & Number ) ) & Number ) != Number ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
int __fastcall argmatch_valid ( __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { char * @@char@@ ; __int64 @@int64@@ ; void * @@void@@ ; @@void@@ = Number L ; @@char@@ = gettext ( String ) ; fprintf ( stderr , @@char@@ ) ; for ( @@int64@@ = Number L ; * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; ++ @@int64@@ ) { if ( @@int64@@ && ! memcmp ( @@void@@ , ( const void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) , @@sizet@@ ) ) { fprintf ( stderr , String , * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) ) ; } else { fprintf ( stderr , String , * ( const char * * ) ( Number * @@int64@@ + @@int64@@ ) ) ; @@void@@ = ( void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) ; } } return putc_unlocked ( Number , stderr ) ; }
__int64 __fastcall _xargmatch_internal ( __int64 @@int64@@ , const char * @@constchar@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ , void ( * @ @ VAR_367 @ @ void ( ) ( void ) @ @ argmatchexitfn ) ( void ) ) { __int64 @@int64@@ ; @@int64@@ = argmatch ( @@constchar@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; if ( @@int64@@ >= Number ) return @@int64@@ ; argmatch_invalid ( @@int64@@ , ( __int64 ) @@constchar@@ , @@int64@@ ) ; argmatch_valid ( @@int64@@ , @@int64@@ , @@sizet@@ ) ; @ @ VAR_367 @ @ void ( ) ( void ) @ @ argmatchexitfn ( ) ; return Number ; }
size_t __fastcall mbslen ( const char * @@constchar@@ ) { __int64 @@int64@@ ; char @@char4@@ [ Number ] ; int @@int@@ ; char @@char@@ ; const char * @@constchar@@ ; __int64 @@int64@@ ; char @@char@@ ; int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; if ( __ctype_get_mb_cur_max ( ) <= Number ) return strlen ( @@constchar@@ ) ; @@int64@@ = Number L ; @@constchar@@ = @@constchar@@ ; @@char4@@ [ Number ] = Number ; memset ( & @@int@@ , Number , Number ) ; for ( @@char@@ = Number ; ; @@char@@ = Number ) { mbuiter_multi_next_1 ( ( __int64 ) @@char4@@ ) ; if ( @@char@@ == Number && ! @@int@@ ) break ; ++ @@int64@@ ; @@constchar@@ += @@int64@@ ; } return @@int64@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 __fastcall hard_locale ( int @@int@@ ) { unsigned __int8 @@unsignedint8@@ ; const char * @@constchar@@ ; @@unsignedint8@@ = Number ; @@constchar@@ = setlocale ( @@int@@ , Number L ) ; if ( @@constchar@@ && ( ! strcmp ( @@constchar@@ , String ) || ! strcmp ( @@constchar@@ , String ) ) ) { @@unsignedint8@@ = Number ; } return @@unsignedint8@@ ; }
__int64 __fastcall memcoll ( const char * @@constchar@@ , size_t @@sizet@@ , const char * @@constchar@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; const char * @@constchar@@ ; size_t @@sizet@@ ; const char * @@constchar@@ ; char @@char@@ ; char @@char@@ ; unsigned int @@unsignedint@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; @@constchar@@ = @@constchar@@ ; @@constchar@@ = @@constchar@@ ; if ( @@sizet@@ == @@int64@@ && ! memcmp ( @@constchar@@ , @@constchar@@ , @@sizet@@ ) ) { * __errno_location ( ) = Number ; @@unsignedint@@ = Number ; } else { @@char@@ = @@constchar@@ [ @@sizet@@ ] ; @@char@@ = @@constchar@@ [ @@int64@@ ] ; @@sizet@@ = @@sizet@@ + Number ; @@constchar@@ [ @@sizet@@ ] = Number ; @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ + Number ; @@constchar@@ [ @@int64@@ ] = Number ; while ( Number ) { * __errno_location ( ) = Number ; @@unsignedint@@ = strcoll ( @@constchar@@ , @@constchar@@ ) ; if ( @@unsignedint@@ || * __errno_location ( ) ) break ; @@sizet@@ = strlen ( @@constchar@@ ) + Number ; @@sizet@@ = strlen ( @@constchar@@ ) + Number ; @@constchar@@ += @@sizet@@ ; @@constchar@@ += @@sizet@@ ; @@sizet@@ -= @@sizet@@ ; @@int64@@ -= @@sizet@@ ; if ( ! @@sizet@@ ) { if ( @@int64@@ ) @@unsignedint@@ = Number ; break ; } if ( ! @@int64@@ ) { @@unsignedint@@ = Number ; break ; } } @@constchar@@ [ @@sizet@@ - Number ] = @@char@@ ; @@constchar@@ [ @@int64@@ - Number ] = @@char@@ ; } return @@unsignedint@@ ; }
__int64 __fastcall size_opt ( const char * @@constchar@@ , const char * @@constchar@@ ) { char * @@char@@ ; __int64 @@int642@@ [ Number ] ; @@int642@@ [ Number ] = __readfsqword ( Number ) ; if ( ( unsigned int ) xstrtoul ( @@constchar@@ , Number L , Number L , @@int642@@ , & locale ) > Number ) { @@char@@ = gettext ( @@constchar@@ ) ; error ( Number , Number , String , @@constchar@@ , @@char@@ ) ; } return @@int642@@ [ Number ] ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
size_t __fastcall writeline ( __int64 @@int64@@ , char @@char@@ , __int64 @@int64@@ ) { size_t @@sizet@@ ; if ( @@int64@@ ) { if ( @@char@@ != Number ) @@sizet@@ = ( unsigned __int8 ) output_first_repeated ^ Number ; else @@sizet@@ = ( unsigned __int8 ) output_later_repeated ^ Number ; } else { @@sizet@@ = ( unsigned __int8 ) output_unique ^ Number ; } if ( ! ( _BYTE ) @@sizet@@ ) { if ( ! countmode ) printf ( String , @@int64@@ + Number ) ; @@sizet@@ = fwrite_unlocked ( * ( const void * * ) ( @@int64@@ + Number ) , Number , * ( _QWORD * ) ( @@int64@@ + Number ) , stdout ) ; } return @@sizet@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 __fastcall xmemcoll ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { char * @@char@@ ; char * @@char@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; char * @@char@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; @@unsignedint@@ = memcoll ( @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ ) ; @@int@@ = * __errno_location ( ) ; if ( @@int@@ ) { @@char@@ = gettext ( String ) ; error ( Number , @@int@@ , @@char@@ ) ; @@char@@ = gettext ( String ) ; error ( Number , Number , @@char@@ ) ; @@int64@@ = quotearg_n_style_mem ( Number L , Number L , @@int64@@ , @@int64@@ ) ; @@int64@@ = quotearg_n_style_mem ( Number L , Number L , @@int64@@ , @@int64@@ ) ; @@char@@ = gettext ( String ) ; error ( exit_failure , Number , @@char@@ , @@int64@@ , @@int64@@ ) ; } return @@unsignedint@@ ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
__int64 __fastcall argmatch_to_argument ( const void * @@constvoid@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; ++ @@int64@@ ) { if ( ! memcmp ( @@constvoid@@ , ( const void * ) ( @@int64@@ * @@sizet@@ + @@int64@@ ) , @@sizet@@ ) ) return * ( _QWORD * ) ( Number * @@int64@@ + @@int64@@ ) ; } return Number L ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
__int64 __fastcall memcasecmp ( __int64 @@int64@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int8 @@unsignedint8@@ ; int @@int@@ ; unsigned int @@unsignedint@@ ; unsigned __int64 @@unsignedint64@@ ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@unsignedint64@@ ; ++ @@unsignedint64@@ ) { @@unsignedint8@@ = * ( _BYTE * ) ( @@int64@@ + @@unsignedint64@@ ) ; @@int@@ = toupper ( * ( unsigned __int8 * ) ( @@int64@@ + @@unsignedint64@@ ) ) ; @@unsignedint@@ = @@int@@ - toupper ( @@unsignedint8@@ ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; } return Number L ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , @@sizet@@ , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@unsignedint64@@ , int @@int@@ ) { __int64 @@int64@@ ; if ( is_mul_ok ( @@int@@ , * @@unsignedint64@@ ) ) { * @@unsignedint64@@ *= @@int@@ ; @@int64@@ = Number L ; } else { * @@unsignedint64@@ = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@int64@@ ) { return quotearg_n ( Number , @@int64@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_209108 ; @@int648@@ [ Number ] = qword_209110 ; @@int648@@ [ Number ] = qword_209118 ; @@int648@@ [ Number ] = qword_209120 ; @@int648@@ [ Number ] = qword_209128 ; @@int648@@ [ Number ] = qword_209130 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return quotearg_n_custom ( Number , @@int64@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return xmalloc ( @@int64@@ , @@int64@@ , @@int64@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@int@@ , unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { _QWORD @@QWORD8@@ [ Number ] ; @@QWORD8@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@QWORD8@@ , @@unsignedint@@ ) ; return quotearg_n_options ( @@int@@ , @@int64@@ , Number , ( __int64 ) @@QWORD8@@ ) ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { return quotearg_char_mem ( @@int64@@ , Number , @@unsignedint8@@ ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_2080E8 ; @@int648@@ [ Number ] = qword_2080F0 ; @@int648@@ [ Number ] = qword_2080F8 ; @@int648@@ [ Number ] = qword_208100 ; @@int648@@ [ Number ] = qword_208108 ; @@int648@@ [ Number ] = qword_208110 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@QWORD@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int647@@ [ Number ] ; @@int647@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@int647@@ , Number , Number ) ; @@int64@@ = @@int647@@ [ Number ] ; * @@QWORD@@ = @@unsignedint@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int647@@ [ Number ] ; return @@QWORD@@ ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
size_t __fastcall output ( char * @@char@@ , __int64 @@int64@@ ) { size_t @@sizet@@ ; char * @@char@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; @@char@@ = @@char@@ ; @@sizet@@ = @@int64@@ - ( _QWORD ) @@char@@ ; @@sizet@@ = Number - bytes_in_buffer_5723 ; if ( @@char@@ ) { while ( @@sizet@@ >= @@sizet@@ ) { memcpy ( ( char * ) & buffer_5722 + bytes_in_buffer_5723 , @@char@@ , @@sizet@@ ) ; @@sizet@@ -= @@sizet@@ ; @@char@@ += @@sizet@@ ; fwrite_unlocked ( & buffer_5722 , Number , Number , stdout ) ; bytes_in_buffer_5723 = Number L ; @@sizet@@ = Number ; } memcpy ( ( char * ) & buffer_5722 + bytes_in_buffer_5723 , @@char@@ , @@sizet@@ ) ; @@sizet@@ = bytes_in_buffer_5723 + @@sizet@@ ; bytes_in_buffer_5723 += @@sizet@@ ; } else { @@sizet@@ = fwrite_unlocked ( & buffer_5722 , Number , bytes_in_buffer_5723 , stdout ) ; bytes_in_buffer_5723 = Number L ; } return @@sizet@@ ; }
__int64 __fastcall getugroups ( int @@int@@ , _DWORD * @@DWORD@@ , const char * @@constchar@@ , int @@int@@ ) { int @@int@@ ; int @@int@@ ; int @@int@@ ; const char * * @@constchar@@ ; struct group * @@structgroup@@ ; @@int@@ = Number ; if ( @@int@@ != Number ) { if ( @@int@@ ) * @@DWORD@@ = @@int@@ ; @@int@@ = Number ; } setgrent ( ) ; while ( Number ) { * __errno_location ( ) = Number ; @@structgroup@@ = getgrent ( ) ; if ( ! @@structgroup@@ ) break ; for ( @@constchar@@ = ( const char * * ) @@structgroup@@ -> gr_mem ; * @@constchar@@ ; ++ @@constchar@@ ) { if ( ! strcmp ( @@constchar@@ , * @@constchar@@ ) ) { for ( @@int@@ = Number ; @@int@@ < @@int@@ && ( ! @@DWORD@@ || @@DWORD@@ [ @@int@@ ] != @@structgroup@@ -> gr_gid ) ; ++ @@int@@ ) { ; } if ( @@int@@ == @@int@@ ) { if ( @@int@@ ) { if ( @@int@@ >= @@int@@ ) goto LABEL_26 ; @@DWORD@@ [ @@int@@ ] = @@structgroup@@ -> gr_gid ; } if ( @@int@@ == Number ) { * __errno_location ( ) = Number ; goto LABEL_26 ; } ++ @@int@@ ; } } } } if ( * __errno_location ( ) ) @@int@@ = Number ; LABEL_26 : @@int@@ = * __errno_location ( ) ; endgrent ( ) ; * __errno_location ( ) = @@int@@ ; return ( unsigned int ) @@int@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@BYTE@@ ) { char @@char@@ ; _BYTE * @@BYTE@@ ; @@char@@ = Number ; while ( * @@BYTE@@ == Number ) ++ @@BYTE@@ ; for ( @@BYTE@@ = @@BYTE@@ ; * @@BYTE@@ ; ++ @@BYTE@@ ) { if ( * @@BYTE@@ == Number ) { @@char@@ = Number ; } else if ( @@char@@ ) { @@BYTE@@ = @@BYTE@@ ; @@char@@ = Number ; } } return @@BYTE@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_208028 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
int __fastcall version_etc_ar ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , __int64 * @@int64@@ ) { __int64 @@int64@@ ; for ( @@int64@@ = Number L ; @@int64@@ [ @@int64@@ ] ; ++ @@int64@@ ) ; return version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int64@@ , @@int64@@ ) ; }
__int64 __fastcall set_char_quoting ( __int64 * @@int64@@ , unsigned __int8 @@unsignedint8@@ , char @@char@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@unsignedint@@ = ( * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) >> ( @@unsignedint8@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@int64@@ + ( @@unsignedint8@@ >> Number ) + Number ) ^= ( @@unsignedint@@ ^ @@char@@ & Number ) << ( @@unsignedint8@@ & Number ) ; return @@unsignedint@@ ; }
__int64 __fastcall quote_n ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( @@unsignedint@@ , Number L , @@int64@@ ) ; }
__int64 __fastcall quote ( __int64 @@int64@@ ) { return quote_n ( Number , @@int64@@ ) ; }
_BOOL8 __fastcall tac_nonseekable ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { char * @@char@@ ; int @@int@@ ; bool @@bool@@ ; FILE * @@FILE@@ ; char * @@char4@@ [ Number ] ; @@char4@@ [ Number ] = ( char * ) __readfsqword ( Number ) ; @@bool@@ = Number ; if ( ( unsigned __int8 ) copy_to_temp ( & @@FILE@@ , @@char4@@ , @@unsignedint@@ , @@int64@@ ) ) { @@char@@ = @@char4@@ [ Number ] ; @@int@@ = fileno ( @@FILE@@ ) ; if ( ( unsigned __int8 ) tac_seekable ( @@int@@ , ( __int64 ) @@char@@ ) ) @@bool@@ = Number ; } return @@bool@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; * ( _DWORD * ) @@int64@@ = @@int@@ ; return @@int64@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , * ( ( _DWORD * ) @@int64@@ + Number ) , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; return @@unsignedint64@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_mem ( Number , @@int64@@ , @@sizet@@ ) ; }
_BOOL8 __fastcall tac_file ( const char * @@constchar@@ ) { int @@int@@ ; __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; bool @@bool@@ ; __int64 @@int64@@ ; char * @@char@@ ; int * @@int@@ ; char * @@char@@ ; bool @@bool@@ ; bool @@bool@@ ; int @@int@@ ; @@char@@ = ( char * ) @@constchar@@ ; @@int@@ = strcmp ( @@constchar@@ , String ) ; @@bool@@ = @@int@@ == Number ; if ( @@int@@ ) { @@int@@ = open ( @@constchar@@ , Number ) ; if ( @@int@@ < Number ) { @@int64@@ = quote ( @@constchar@@ ) ; @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ , @@int64@@ ) ; return Number L ; } } else { have_read_stdin = Number ; @@int@@ = Number ; @@char@@ = gettext ( String ) ; } if ( lseek ( @@int@@ , Number L , Number ) < Number || isatty ( @@int@@ ) ) @@bool@@ = tac_nonseekable ( @@int@@ , ( __int64 ) @@char@@ ) ; else @@bool@@ = ( unsigned __int8 ) tac_seekable ( @@int@@ , ( __int64 ) @@char@@ ) != Number ; @@bool@@ = @@bool@@ ; if ( ! @@bool@@ ) { if ( close ( @@int@@ ) ) { @@int64@@ = quotearg_colon ( @@char@@ ) ; @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ , @@int64@@ ) ; @@bool@@ = Number ; } } return @@bool@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@int64@@ ) { return quotearg_char ( @@int64@@ , Number ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_custom_mem ( Number , @@int64@@ , @@int64@@ , @@int64@@ , @@sizet@@ ) ; }
bool __fastcall bitset_contain ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { return ( ( * ( _QWORD * ) ( Number * ( @@unsignedint64@@ >> Number ) + @@int64@@ ) >> ( @@unsignedint64@@ & Number ) ) & Number L ) != Number ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 __fastcall re_string_wchar_at ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; if ( * ( _DWORD * ) ( @@int64@@ + Number ) == Number ) @@int64@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + @@int64@@ ) ; else @@int64@@ = * ( unsigned int * ) ( Number * @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; return @@int64@@ ; }
_QWORD * __fastcall bitset_set ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { _QWORD * @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) ( Number * ( @@unsignedint64@@ >> Number ) + @@int64@@ ) ; * @@QWORD@@ |= Number L << ( @@unsignedint64@@ & Number ) ; return @@QWORD@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@int@@ , __int64 @@int64@@ , size_t @@sizet@@ , __int64 @@int64@@ ) { __int64 * * @@int64@@ ; __int64 * @@int64@@ ; bool @@bool@@ ; int @@int@@ ; int @@int@@ ; __int64 * * @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@int@@ = * __errno_location ( ) ; @@int64@@ = slotvec ; if ( @@int@@ < Number ) abort ( ) ; if ( @@int@@ >= ( unsigned int ) nslots ) { @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; @@bool@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@int64@@ = Number L ; else @@int64@@ = slotvec ; @@int64@@ = ( __int64 * * ) xrealloc ( @@int64@@ , Number * @@int64@@ ) ; slotvec = @@int64@@ ; if ( @@bool@@ ) { @@int64@@ = ( __int64 * ) off_220028 ; * @@int64@@ = slotvec0 ; @@int64@@ [ Number ] = @@int64@@ ; } memset ( & @@int64@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@int64@@ - ( unsigned int ) nslots ) ) ; nslots = @@int@@ + Number ; } @@unsignedint64@@ = ( unsigned __int64 ) @@int64@@ [ Number * @@int@@ ] ; @@int64@@ = @@int64@@ [ Number * @@int@@ + Number ] ; @@int@@ = * ( _DWORD * ) ( @@int64@@ + Number ) | Number ; @@unsignedint64@@ = quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint64@@ <= @@unsignedint64@@ ) { @@unsignedint64@@ = @@unsignedint64@@ + Number ; @@int64@@ [ Number * @@int@@ ] = ( __int64 * ) ( @@unsignedint64@@ + Number ) ; if ( @@int64@@ != ( __int64 * ) & slot0 ) free ( @@int64@@ ) ; @@int64@@ = ( __int64 * ) xcharalloc ( @@unsignedint64@@ ) ; @@int64@@ [ Number * @@int@@ + Number ] = @@int64@@ ; quotearg_buffer_restyled ( ( __int64 ) @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , @@int64@@ + Number , * ( char * * ) ( @@int64@@ + Number ) , * ( char * * ) ( @@int64@@ + Number ) ) ; } * __errno_location ( ) = @@int@@ ; return @@int64@@ ; }
_QWORD * __fastcall bitset_merge ( __int64 @@int64@@ , __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; int @@int@@ ; for ( @@int@@ = Number ; @@int@@ <= Number ; ++ @@int@@ ) { @@QWORD@@ = ( _QWORD * ) ( Number L * @@int@@ + @@int64@@ ) ; * @@QWORD@@ |= * ( _QWORD * ) ( Number L * @@int@@ + @@int64@@ ) ; } return @@QWORD@@ ; }
__int64 __fastcall re_string_realloc_buffers ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { void * @@void@@ ; void * @@void@@ ; void * @@void@@ ; if ( * ( int * ) ( @@int64@@ + Number ) > Number ) { if ( ! is_mul_ok ( Number , @@unsignedint64@@ ) ) return Number L ; @@void@@ = realloc ( * ( void * * ) ( @@int64@@ + Number ) , Number * @@unsignedint64@@ ) ; if ( ! @@void@@ ) return Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@void@@ ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) { @@void@@ = realloc ( * ( void * * ) ( @@int64@@ + Number ) , Number * @@unsignedint64@@ ) ; if ( ! @@void@@ ) return Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@void@@ ; } } if ( * ( _BYTE * ) ( @@int64@@ + Number ) ) { @@void@@ = realloc ( * ( void * * ) ( @@int64@@ + Number ) , @@unsignedint64@@ ) ; if ( ! @@void@@ ) return Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@void@@ ; } * ( _QWORD * ) ( @@int64@@ + Number ) = @@unsignedint64@@ ; return Number L ; }
unsigned __int64 __fastcall re_string_skip_chars ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , wchar_t * @@wchart@@ ) { _BOOL4 @@BOOL4@@ ; wchar_t @@wchart@@ ; wchar_t @@wchart@@ ; unsigned __int64 @@unsignedint64@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@wchart@@ = Number ; for ( @@unsignedint64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) + * ( _QWORD * ) ( @@int64@@ + Number ) ; @@unsignedint64@@ < @@unsignedint64@@ ; @@unsignedint64@@ += @@sizet@@ ) { @@sizet@@ = * ( _QWORD * ) ( @@int64@@ + Number ) - @@unsignedint64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@sizet@@ = mbrtowc ( & @@wchart@@ , ( const char * ) ( * ( _QWORD * ) @@int64@@ + @@unsignedint64@@ ) , @@sizet@@ , ( mbstate_t * ) ( @@int64@@ + Number ) ) ; @@BOOL4@@ = @@sizet@@ == Number || @@sizet@@ == Number ; if ( ! @@BOOL4@@ && @@sizet@@ ) { @@wchart@@ = @@wchart@@ ; } else { if ( @@sizet@@ && @@sizet@@ ) @@wchart@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) @@int64@@ + @@unsignedint64@@ ) ; else @@wchart@@ = Number ; @@sizet@@ = Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; } } * @@wchart@@ = @@wchart@@ ; return @@unsignedint64@@ ; }
__int64 __fastcall re_string_allocate ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ , __int64 @@int64@@ ) { unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned int @@unsignedint@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint64@@ ; if ( @@unsignedint64@@ < * ( int * ) ( @@int64@@ + Number ) ) @@unsignedint64@@ = * ( int * ) ( @@int64@@ + Number ) ; @@unsignedint64@@ = @@int64@@ + Number ; if ( @@unsignedint64@@ <= @@int64@@ + Number ) @@unsignedint64@@ = @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint64@@ ; re_string_construct_common ( @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@unsignedint8@@ , @@int64@@ ) ; @@unsignedint@@ = re_string_realloc_buffers ( @@int64@@ , @@unsignedint64@@ ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ + Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = ( * ( _BYTE * ) ( @@int64@@ + Number ) & Number ) != Number ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) ) @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; else @@int64@@ = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) || * ( int * ) ( @@int64@@ + Number ) > Number ) @@int64@@ = Number L ; else @@int64@@ = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; return Number L ; }
__int64 __fastcall re_string_peek_byte_case ( __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; if ( ! * ( _BYTE * ) ( @@int64@@ + Number ) ) return * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + * ( _QWORD * ) ( @@int64@@ + Number ) + @@int64@@ ) ; if ( * ( int * ) ( @@int64@@ + Number ) > Number && ( * ( _DWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * ( * ( _QWORD * ) ( @@int64@@ + Number ) + @@int64@@ ) ) == Number || * ( _QWORD * ) ( @@int64@@ + Number ) != * ( _QWORD * ) ( @@int64@@ + Number ) + @@int64@@ + Number && * ( _DWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * ( * ( _QWORD * ) ( @@int64@@ + Number ) + @@int64@@ + Number ) ) == Number ) ) { return * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + * ( _QWORD * ) ( @@int64@@ + Number ) + @@int64@@ ) ; } @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) + @@int64@@ ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) ) @@int64@@ = * ( _QWORD * ) ( Number * @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) && ( * ( _BYTE * ) ( * ( _QWORD * ) @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) + @@int64@@ ) & Number ) != Number ) { @@int64@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + * ( _QWORD * ) ( @@int64@@ + Number ) + @@int64@@ ) ; } else { @@int64@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) + @@int64@@ ) ; } return @@int64@@ ; }
__int64 __fastcall re_node_set_init_1 ( _QWORD * @@QWORD@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; * @@QWORD@@ = Number L ; @@QWORD@@ [ Number ] = Number L ; @@QWORD@@ [ Number ] = malloc ( Number ) ; if ( @@QWORD@@ [ Number ] ) { * ( _QWORD * ) @@QWORD@@ [ Number ] = @@int64@@ ; @@int64@@ = Number L ; } else { @@QWORD@@ [ Number ] = Number L ; * @@QWORD@@ = @@QWORD@@ [ Number ] ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall re_node_set_alloc ( _QWORD * @@QWORD@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; * @@QWORD@@ = @@int64@@ ; @@QWORD@@ [ Number ] = Number L ; @@QWORD@@ [ Number ] = malloc ( Number * @@int64@@ ) ; if ( @@QWORD@@ [ Number ] ) @@int64@@ = Number L ; else @@int64@@ = Number L ; return @@int64@@ ; }
bool __fastcall re_node_set_insert ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; void * @@void@@ ; if ( ! * ( _QWORD * ) @@int64@@ ) return ( unsigned int ) re_node_set_init_1 ( ( _QWORD * ) @@int64@@ , @@unsignedint64@@ ) == Number ; if ( ! * ( _QWORD * ) ( @@int64@@ + Number ) ) { * * ( _QWORD * * ) ( @@int64@@ + Number ) = @@unsignedint64@@ ; ++ * ( _QWORD * ) ( @@int64@@ + Number ) ; return Number ; } if ( * ( _QWORD * ) @@int64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ) { * ( _QWORD * ) @@int64@@ *= Number L ; @@void@@ = realloc ( * ( void * * ) ( @@int64@@ + Number ) , Number L * * ( _QWORD * ) @@int64@@ ) ; if ( ! @@void@@ ) return Number ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@void@@ ; } if ( @@unsignedint64@@ >= * * ( _QWORD * * ) ( @@int64@@ + Number ) ) { for ( @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@unsignedint64@@ < * ( _QWORD * ) ( Number * @@int64@@ - Number + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; -- @@int64@@ ) { * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ - Number ) ; } } else { for ( @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ ; -- @@int64@@ ) { * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ - Number ) ; } } * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ ) = @@unsignedint64@@ ; ++ * ( _QWORD * ) ( @@int64@@ + Number ) ; return Number ; }
__int64 __fastcall re_node_set_init_2 ( _QWORD * @@QWORD@@ , unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { * @@QWORD@@ = Number L ; @@QWORD@@ [ Number ] = malloc ( Number ) ; if ( ! @@QWORD@@ [ Number ] ) return Number L ; if ( @@unsignedint64@@ == @@unsignedint64@@ ) { @@QWORD@@ [ Number ] = Number L ; * ( _QWORD * ) @@QWORD@@ [ Number ] = @@unsignedint64@@ ; } else { @@QWORD@@ [ Number ] = Number L ; if ( @@unsignedint64@@ >= @@unsignedint64@@ ) { * ( _QWORD * ) @@QWORD@@ [ Number ] = @@unsignedint64@@ ; * ( _QWORD * ) ( @@QWORD@@ [ Number ] + Number L ) = @@unsignedint64@@ ; } else { * ( _QWORD * ) @@QWORD@@ [ Number ] = @@unsignedint64@@ ; * ( _QWORD * ) ( @@QWORD@@ [ Number ] + Number L ) = @@unsignedint64@@ ; } } return Number L ; }
char * __fastcall rpl_re_compile_pattern ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { char * @@char@@ ; int @@int@@ ; * ( _BYTE * ) ( @@int64@@ + Number ) = ( Number * ( ( rpl_re_syntax_options & Number ) != Number ) ) | * ( _BYTE * ) ( @@int64@@ + Number ) & Number ; * ( _BYTE * ) ( @@int64@@ + Number ) |= Number ; @@int@@ = re_compile_internal ( @@int64@@ , @@int64@@ , @@int64@@ , rpl_re_syntax_options ) ; if ( @@int@@ ) @@char@@ = gettext ( & _re_error_msgid [ _re_error_msgid_idx [ @@int@@ ] ] ) ; else @@char@@ = Number L ; return @@char@@ ; }
__int64 __fastcall re_node_set_init_copy ( void * @@void@@ , __int64 @@int64@@ ) { * ( ( _QWORD * ) @@void@@ + Number ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) { * ( _QWORD * ) @@void@@ = * ( ( _QWORD * ) @@void@@ + Number ) ; * ( ( _QWORD * ) @@void@@ + Number ) = malloc ( Number L * * ( _QWORD * ) @@void@@ ) ; if ( ! * ( ( _QWORD * ) @@void@@ + Number ) ) { * ( ( _QWORD * ) @@void@@ + Number ) = Number L ; * ( _QWORD * ) @@void@@ = * ( ( _QWORD * ) @@void@@ + Number ) ; return Number L ; } memcpy ( * ( ( void * * ) @@void@@ + Number ) , * ( const void * * ) ( @@int64@@ + Number ) , Number L * * ( _QWORD * ) ( @@int64@@ + Number ) ) ; } else { memset ( @@void@@ , Number , Number ) ; } return Number L ; }
__int64 __fastcall rpl_re_set_syntax ( __int64 @@int64@@ ) { __int64 @@int64@@ ; @@int64@@ = rpl_re_syntax_options ; rpl_re_syntax_options = @@int64@@ ; return @@int64@@ ; }
unsigned __int64 __fastcall re_node_set_contains ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; if ( ( unsigned __int64 ) ( * ( _QWORD * ) ( @@int64@@ + Number ) - Number L ) > Number ) return Number L ; @@unsignedint64@@ = Number L ; @@unsignedint64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) - Number L ; while ( @@unsignedint64@@ < @@unsignedint64@@ ) { if ( @@unsignedint64@@ <= * ( _QWORD * ) ( Number * ( ( @@unsignedint64@@ + @@unsignedint64@@ ) >> Number ) + * ( _QWORD * ) ( @@int64@@ + Number ) ) ) @@unsignedint64@@ = ( @@unsignedint64@@ + @@unsignedint64@@ ) >> Number ; else @@unsignedint64@@ = ( ( @@unsignedint64@@ + @@unsignedint64@@ ) >> Number ) + Number ; } if ( @@unsignedint64@@ == * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ) @@unsignedint64@@ = @@unsignedint64@@ + Number ; else @@unsignedint64@@ = Number L ; return @@unsignedint64@@ ; }
unsigned __int64 __fastcall re_node_set_remove_at ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = @@unsignedint64@@ ; @@unsignedint64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( @@unsignedint64@@ < @@unsignedint64@@ ) { -- * ( _QWORD * ) ( @@int64@@ + Number ) ; while ( Number ) { @@unsignedint64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( @@unsignedint64@@ >= @@unsignedint64@@ ) break ; * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@unsignedint64@@ ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * ( @@unsignedint64@@ + Number ) ) ; ++ @@unsignedint64@@ ; } } return @@unsignedint64@@ ; }
size_t __fastcall rpl_regerror ( int @@int@@ , __int64 a2 , _BYTE * @@BYTE@@ , size_t @@sizet@@ ) { size_t @@sizet@@ ; const char * @@constchar@@ ; size_t @@sizet@@ ; if ( @@int@@ < Number || @@int@@ > Number ) abort ( ) ; @@constchar@@ = gettext ( & _re_error_msgid [ _re_error_msgid_idx [ @@int@@ ] ] ) ; @@sizet@@ = strlen ( @@constchar@@ ) + Number ; if ( @@sizet@@ ) { @@sizet@@ = @@sizet@@ ; if ( @@sizet@@ > @@sizet@@ ) { @@sizet@@ = @@sizet@@ - Number ; @@BYTE@@ [ @@sizet@@ - Number ] = Number ; } memcpy ( @@BYTE@@ , @@constchar@@ , @@sizet@@ ) ; } return @@sizet@@ ; }
char * __fastcall create_ci_newstate ( _QWORD * @@QWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { char * @@char@@ ; int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; char * @@char@@ ; __int64 @@int64@@ ; @@char@@ = ( char * ) calloc ( Number , Number ) ; if ( ! @@char@@ ) return Number L ; if ( ( unsigned int ) re_node_set_init_copy ( @@char@@ + Number , @@int64@@ ) ) { free ( @@char@@ ) ; @@char@@ = Number L ; } else { * ( ( _QWORD * ) @@char@@ + Number ) = @@char@@ + Number ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { @@int64@@ = * @@QWORD@@ + Number L * * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; @@int@@ = * ( unsigned __int8 * ) ( @@int64@@ + Number ) ; if ( @@int@@ != Number || ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number ) { @@char@@ [ Number ] = ( Number * ( ( * ( _BYTE * ) ( @@int64@@ + Number ) & Number ) != Number || ( @@char@@ [ Number ] & Number ) != Number ) ) | @@char@@ [ Number ] & Number ; if ( @@int@@ == Number ) { @@char@@ [ Number ] |= Number ; } else if ( @@int@@ == Number ) { @@char@@ [ Number ] |= Number ; } else if ( @@int@@ == Number || ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number ) { @@char@@ [ Number ] |= Number ; } } } if ( ( unsigned int ) register_state ( @@QWORD@@ , @@char@@ , @@int64@@ ) ) { free_state ( ( void * * ) @@char@@ ) ; @@char@@ = Number L ; } @@char@@ = @@char@@ ; } return @@char@@ ; }
__int64 __fastcall re_acquire_state_context ( _DWORD * @@DWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ , unsigned int @@unsignedint@@ ) { __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; unsigned __int64 * @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) { @@int64@@ = calc_state_hash ( @@int64@@ , @@unsignedint@@ ) ; @@unsignedint64@@ = ( unsigned __int64 * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * ( @@int64@@ & * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * @@unsignedint64@@ ; ++ @@unsignedint64@@ ) { @@int64@@ = * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@unsignedint64@@ [ Number ] ) ; if ( @@int64@@ == * ( _QWORD * ) @@int64@@ && @@unsignedint@@ == ( * ( _BYTE * ) ( @@int64@@ + Number ) & Number ) && ( unsigned __int8 ) re_node_set_compare ( * ( _QWORD * ) ( @@int64@@ + Number ) , @@int64@@ ) ) { return @@int64@@ ; } } @@int64@@ = create_cd_newstate ( @@int64@@ , @@int64@@ , @@unsignedint@@ , @@int64@@ ) ; if ( ! @@int64@@ ) * @@DWORD@@ = Number ; @@int64@@ = @@int64@@ ; } else { * @@DWORD@@ = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall init_dfa ( void * * @@void@@ , unsigned __int64 @@unsignedint64@@ ) { __int64 @@int64@@ ; int @@int@@ ; int @@int@@ ; int @@int@@ ; wint_t @@wintt@@ ; size_t @@sizet@@ ; const char * @@constchar@@ ; memset ( @@void@@ , Number , Number ) ; * ( ( _DWORD * ) @@void@@ + Number ) = Number ; if ( @@unsignedint64@@ >= Number ) return Number L ; @@void@@ [ Number ] = ( void * ) ( @@unsignedint64@@ + Number ) ; * @@void@@ = malloc ( Number L * ( _QWORD ) @@void@@ [ Number ] ) ; for ( @@sizet@@ = Number L ; @@sizet@@ <= @@unsignedint64@@ ; @@sizet@@ *= Number L ) { ; } @@void@@ [ Number ] = calloc ( Number , @@sizet@@ ) ; @@void@@ [ Number ] = ( void * ) ( @@sizet@@ - Number ) ; * ( ( _DWORD * ) @@void@@ + Number ) = __ctype_get_mb_cur_max ( ) ; @@constchar@@ = nl_langinfo ( Number ) ; if ( ! strcasecmp ( @@constchar@@ , String ) || ! strcasecmp ( @@constchar@@ , String ) ) * ( ( _BYTE * ) @@void@@ + Number ) |= Number ; * ( ( _BYTE * ) @@void@@ + Number ) &= Number ; if ( * ( ( int * ) @@void@@ + Number ) > Number ) { if ( ( ( _BYTE ) @@void@@ [ Number ] & Number ) != Number ) { @@void@@ [ Number ] = & utf8_sb_map ; } else { @@void@@ [ Number ] = calloc ( Number , Number ) ; if ( ! @@void@@ [ Number ] ) return Number L ; @@int@@ = Number ; @@int@@ = Number ; while ( @@int@@ <= Number ) { for ( @@int@@ = Number ; @@int@@ <= Number ; ++ @@int@@ ) { @@wintt@@ = btowc ( @@int@@ ) ; if ( @@wintt@@ != Number ) * ( ( _QWORD * ) @@void@@ [ Number ] + @@int@@ ) |= Number L << @@int@@ ; if ( ( @@int@@ & Number ) == Number && @@wintt@@ != @@int@@ ) * ( ( _BYTE * ) @@void@@ + Number ) |= Number ; ++ @@int@@ ; } ++ @@int@@ ; } } } if ( * @@void@@ && @@void@@ [ Number ] ) @@int64@@ = Number L ; else @@int64@@ = Number L ; return @@int64@@ ; }
__int64 __fastcall postorder ( _QWORD * @@QWORD@@ , __int64 ( __fastcall * @ @ VAR_985 @ @ int64 ( fastcall ) ( int64 , QWORD ) @ @ regerrcodet ( ) ( void , bintreet0 ) ) ( __int64 , _QWORD * ) , __int64 @@int64@@ ) { unsigned int @@unsignedint@@ ; _QWORD * @@QWORD@@ ; LABEL_5 : while ( @@QWORD@@ [ Number ] || @@QWORD@@ [ Number ] ) { if ( @@QWORD@@ [ Number ] ) @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; else @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; } while ( Number ) { @@unsignedint@@ = @ @ VAR_985 @ @ int64 ( fastcall ) ( int64 , QWORD ) @ @ regerrcodet ( ) ( void , bintreet0 ) ( @@int64@@ , @@QWORD@@ ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; if ( ! * @@QWORD@@ ) return Number L ; @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ = ( _QWORD * ) * @@QWORD@@ ; if ( @@QWORD@@ != ( _QWORD * ) @@QWORD@@ [ Number ] && @@QWORD@@ [ Number ] ) { @@QWORD@@ = ( _QWORD * ) @@QWORD@@ [ Number ] ; goto LABEL_5 ; } } }
void __fastcall free_dfa_content ( __int64 @@int64@@ ) { unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( * ( _QWORD * ) @@int64@@ ) { for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { free_token ( Number * @@unsignedint64@@ + * ( _QWORD * ) @@int64@@ ) ; } } free ( * ( void * * ) ( @@int64@@ + Number ) ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) free ( * ( void * * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@unsignedint64@@ + Number ) ) ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) free ( * ( void * * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@unsignedint64@@ + Number ) ) ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) free ( * ( void * * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@unsignedint64@@ + Number ) ) ; } free ( * ( void * * ) ( @@int64@@ + Number ) ) ; free ( * ( void * * ) ( @@int64@@ + Number ) ) ; free ( * ( void * * ) ( @@int64@@ + Number ) ) ; free ( * ( void * * ) @@int64@@ ) ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) { for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@unsignedint64@@ ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) @@int64@@ ; ++ @@unsignedint64@@ ) { free_state ( * ( void * * * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ; } free ( * ( void * * ) ( @@int64@@ + Number ) ) ; } } free ( * ( void * * ) ( @@int64@@ + Number ) ) ; if ( * ( _UNKNOWN * * ) ( @@int64@@ + Number ) != & utf8_sb_map ) free ( * ( void * * ) ( @@int64@@ + Number ) ) ; free ( * ( void * * ) ( @@int64@@ + Number ) ) ; free ( ( void * ) @@int64@@ ) ; }
__int64 __fastcall calc_inveclosure ( _QWORD * @@QWORD@@ ) { unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@QWORD@@ [ Number ] ; ++ @@unsignedint64@@ ) { memset ( ( void * ) ( @@QWORD@@ [ Number ] + Number * @@unsignedint64@@ ) , Number , Number ) ; } for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@QWORD@@ [ Number ] ; ++ @@unsignedint64@@ ) { @@int64@@ = * ( _QWORD * ) ( @@QWORD@@ [ Number ] + Number * @@unsignedint64@@ + Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@QWORD@@ [ Number ] + Number * @@unsignedint64@@ + Number ) ; ++ @@unsignedint64@@ ) { if ( ( unsigned __int8 ) re_node_set_insert_last ( @@QWORD@@ [ Number ] + Number L * * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@int64@@ ) , @@unsignedint64@@ ) != Number ) return Number L ; } } return Number L ; }
__int64 __fastcall lower_subexp ( _DWORD * @@DWORD@@ , __int64 * @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; _BOOL4 @@BOOL4@@ ; _BOOL4 @@BOOL4@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = * @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( ( @@int64@@ [ Number ] & Number ) != Number && * ( _QWORD * ) ( @@int64@@ + Number ) && ( * ( _QWORD * ) ( @@int64@@ + Number ) > Number || ( ( * ( _QWORD * ) ( @@int64@@ + Number ) >> * ( _QWORD * ) ( @@int64@@ + Number ) ) & Number L ) == Number ) ) { return * ( _QWORD * ) ( @@int64@@ + Number ) ; } @@int64@@ = create_tree ( @@int64@@ , Number L , Number L , Number L ) ; @@int64@@ = create_tree ( @@int64@@ , Number L , Number L , Number L ) ; if ( @@int64@@ ) @@int64@@ = create_tree ( @@int64@@ , @@int64@@ , @@int64@@ , Number L ) ; else @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; @@int64@@ = create_tree ( @@int64@@ , @@int64@@ , @@int64@@ , Number L ) ; @@BOOL4@@ = ! @@int64@@ || ! @@int64@@ ; @@BOOL4@@ = @@BOOL4@@ || ! @@int64@@ ; if ( ! @@BOOL4@@ && @@int64@@ ) { * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _BYTE * ) ( @@int64@@ + Number ) = ( Number * ( ( * ( _BYTE * ) ( @@int64@@ + Number ) & Number ) != Number ) ) | * ( _BYTE * ) ( @@int64@@ + Number ) & Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = ( Number * ( ( * ( _BYTE * ) ( @@int64@@ + Number ) & Number ) != Number ) ) | * ( _BYTE * ) ( @@int64@@ + Number ) & Number ; @@int64@@ = @@int64@@ ; } else { * @@DWORD@@ = Number ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall parse ( __int64 @@int64@@ , __int64 * @@int64@@ , __int64 @@int64@@ , _DWORD * @@DWORD@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = * @@int64@@ ; * ( _QWORD * ) ( * @@int64@@ + Number ) = @@int64@@ ; fetch_token ( ( __int64 ) @@char@@ , @@int64@@ , @@int64@@ | Number ) ; @@int64@@ = parse_reg_exp ( @@int64@@ , @@int64@@ , @@char@@ , @@int64@@ , Number L , @@DWORD@@ ) ; if ( * @@DWORD@@ && ! @@int64@@ ) return Number L ; @@int64@@ = create_tree ( @@int64@@ , Number L , Number L , Number L ) ; if ( @@int64@@ ) @@int64@@ = create_tree ( @@int64@@ , @@int64@@ , @@int64@@ , Number L ) ; else @@int64@@ = @@int64@@ ; if ( @@int64@@ && @@int64@@ ) return @@int64@@ ; * @@DWORD@@ = Number ; return Number L ; }
__int64 __fastcall calc_next ( __int64 a1 , __int64 @@int64@@ ) { int @@int@@ ; @@int@@ = * ( unsigned __int8 * ) ( @@int64@@ + Number ) ; if ( @@int@@ == Number ) { * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) = @@int64@@ ; } else if ( @@int@@ == Number ) { * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) ; * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; } else { if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) = * ( _QWORD * ) ( @@int64@@ + Number ) ; } return Number L ; }
__int64 __fastcall calc_eclosure ( __int64 @@int64@@ ) { char @@char@@ ; unsigned int @@unsignedint@@ ; __int64 @@int64@@ ; char @@char@@ [ Number ] ; void * @@void@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@char@@ = Number ; for ( @@int64@@ = Number L ; ; ++ @@int64@@ ) { if ( @@int64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ) { if ( @@char@@ != Number ) return Number L ; @@char@@ = Number ; @@int64@@ = Number L ; } if ( ! * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ + Number ) ) break ; LABEL_11 : ; } @@unsignedint@@ = calc_eclosure_iter ( @@char@@ , @@int64@@ , @@int64@@ , Number L ) ; if ( ! @@unsignedint@@ ) { if ( ! * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ + Number ) ) { @@char@@ = Number ; free ( @@void@@ ) ; } goto LABEL_11 ; } return @@unsignedint@@ ; }
__int64 __fastcall build_collating_symbol ( __int64 @@int64@@ , __int64 a2 , __int64 a3 , const char * @@constchar@@ ) { if ( strlen ( @@constchar@@ ) != Number ) return Number L ; bitset_set ( @@int64@@ , * ( unsigned __int8 * ) @@constchar@@ ) ; return Number L ; }
__int64 __fastcall duplicate_node ( _QWORD * @@QWORD@@ , __int64 @@int64@@ , __int16 @@int16@@ ) { __int64 @@int64@@ ; @@int64@@ = re_dfa_add_node ( ( __int64 ) @@QWORD@@ , * ( _QWORD * ) ( Number * @@int64@@ + * @@QWORD@@ ) , * ( _QWORD * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) ) ; if ( @@int64@@ != Number ) { * ( _DWORD * ) ( * @@QWORD@@ + Number * @@int64@@ + Number ) = ( ( @@int16@@ & Number ) << Number ) | * ( _DWORD * ) ( * @@QWORD@@ + Number * @@int64@@ + Number ) & Number ; * ( _DWORD * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) = ( ( ( ( * ( _DWORD * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) >> Number ) & Number | ( * ( _DWORD * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) >> Number ) & Number ) & Number ) << Number ) | * ( _DWORD * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) & Number ; * ( _BYTE * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) |= Number ; * ( _QWORD * ) ( @@QWORD@@ [ Number ] + Number * @@int64@@ ) = @@int64@@ ; } return @@int64@@ ; }
__int64 __fastcall parse_reg_exp ( __int64 @@int64@@ , __int64 * @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , _DWORD * @@DWORD@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = * @@int64@@ ; @@int64@@ = parse_branch ( @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@DWORD@@ ) ; if ( * @@DWORD@@ && ! @@int64@@ ) return Number L ; while ( * ( _BYTE * ) ( @@int64@@ + Number ) == Number ) { fetch_token ( @@int64@@ , @@int64@@ , @@int64@@ | Number ) ; if ( * ( _BYTE * ) ( @@int64@@ + Number ) == Number || * ( _BYTE * ) ( @@int64@@ + Number ) == Number || @@int64@@ && * ( _BYTE * ) ( @@int64@@ + Number ) == Number ) { @@int64@@ = Number L ; } else { @@int64@@ = parse_branch ( @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@DWORD@@ ) ; if ( * @@DWORD@@ && ! @@int64@@ ) return Number L ; } @@int64@@ = create_tree ( @@int64@@ , @@int64@@ , @@int64@@ , Number L ) ; if ( ! @@int64@@ ) { * @@DWORD@@ = Number ; return Number L ; } } return @@int64@@ ; }
__int64 __fastcall parse_bracket_element ( __int64 @@int64@@ , __int64 @@int64@@ , _BYTE * @@BYTE@@ , int @@int@@ , __int64 a5 , char @@char@@ , char @@char@@ ) { __int64 @@int64@@ ; int @@int@@ ; char @@char@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int@@ = re_string_char_size_at ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( @@int@@ <= Number ) { * ( _QWORD * ) ( @@int64@@ + Number ) += @@int@@ ; if ( @@BYTE@@ [ Number ] == Number || @@BYTE@@ [ Number ] == Number || @@BYTE@@ [ Number ] == Number ) { @@int64@@ = parse_bracket_symbol ( @@int64@@ , @@int64@@ , @@BYTE@@ ) ; } else if ( @@BYTE@@ [ Number ] == Number && @@char@@ != Number && ( peek_token_bracket ( @@char@@ , @@int64@@ , @@char@@ ) , @@char@@ [ Number ] != Number ) ) { @@int64@@ = Number L ; } else { * ( _DWORD * ) @@int64@@ = Number ; * ( _BYTE * ) ( @@int64@@ + Number ) = * @@BYTE@@ ; @@int64@@ = Number L ; } } else { * ( _DWORD * ) @@int64@@ = Number ; * ( _DWORD * ) ( @@int64@@ + Number ) = re_string_wchar_at ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ; * ( _QWORD * ) ( @@int64@@ + Number ) += @@int@@ ; @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall parse_branch ( __int64 @@int64@@ , __int64 * @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , _DWORD * @@DWORD@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = * @@int64@@ ; @@int64@@ = parse_expression ( @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@DWORD@@ ) ; if ( * @@DWORD@@ && ! @@int64@@ ) return Number L ; while ( * ( _BYTE * ) ( @@int64@@ + Number ) != Number && * ( _BYTE * ) ( @@int64@@ + Number ) != Number && ( ! @@int64@@ || * ( _BYTE * ) ( @@int64@@ + Number ) != Number ) ) { @@int64@@ = parse_expression ( @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@DWORD@@ ) ; if ( * @@DWORD@@ && ! @@int64@@ ) return Number L ; if ( @@int64@@ && @@int64@@ ) { @@int64@@ = create_tree ( @@int64@@ , @@int64@@ , @@int64@@ , Number L ) ; if ( ! @@int64@@ ) { * @@DWORD@@ = Number ; return Number L ; } } else if ( ! @@int64@@ ) { @@int64@@ = @@int64@@ ; } } return @@int64@@ ; }
__int64 __fastcall parse_bracket_symbol ( __int64 @@int64@@ , _QWORD * @@QWORD@@ , char * @@char@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; int @@int@@ ; char @@char@@ ; char @@char@@ ; int @@int@@ ; @@char@@ = * @@char@@ ; @@int@@ = Number ; if ( @@QWORD@@ [ Number ] <= @@QWORD@@ [ Number ] ) return Number L ; while ( Number ) { if ( @@int@@ > Number ) return Number L ; if ( @@char@@ [ Number ] == Number ) { @@char@@ = re_string_fetch_byte_case ( ( __int64 ) @@QWORD@@ ) ; } else { @@int64@@ = @@QWORD@@ [ Number ] ; @@int64@@ = @@QWORD@@ [ Number ] ; @@QWORD@@ [ Number ] = @@int64@@ + Number ; @@char@@ = * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) ; } if ( @@QWORD@@ [ Number ] <= @@QWORD@@ [ Number ] ) return Number L ; if ( @@char@@ == @@char@@ && * ( _BYTE * ) ( @@QWORD@@ [ Number ] + @@QWORD@@ [ Number ] ) == Number ) { break ; } * ( _BYTE * ) ( @@int@@ ++ + * ( _QWORD * ) ( @@int64@@ + Number ) ) = @@char@@ ; } ++ @@QWORD@@ [ Number ] ; * ( _BYTE * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + @@int@@ ) = Number ; @@int@@ = ( unsigned __int8 ) @@char@@ [ Number ] ; switch ( @@int@@ ) { case Number : * ( _DWORD * ) @@int64@@ = Number ; break ; case Number : * ( _DWORD * ) @@int64@@ = Number ; break ; case Number : * ( _DWORD * ) @@int64@@ = Number ; break ; } return Number L ; }
__int64 __fastcall mark_opt_subexp ( __int64 @@int64@@ , __int64 @@int64@@ ) { if ( * ( _BYTE * ) ( @@int64@@ + Number ) == Number && @@int64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ) { * ( _BYTE * ) ( @@int64@@ + Number ) |= Number ; } return Number L ; }
__int64 __fastcall build_equiv_class ( __int64 @@int64@@ , __int64 a2 , __int64 a3 , const char * @@constchar@@ ) { if ( strlen ( @@constchar@@ ) != Number ) return Number L ; bitset_set ( @@int64@@ , * ( unsigned __int8 * ) @@constchar@@ ) ; return Number L ; }
__int64 __fastcall rpl_re_match ( int @@int@@ , int @@int@@ , int @@int@@ , int @@int@@ , __int64 @@int64@@ ) { return re_search_stub ( @@int@@ , @@int@@ , @@int@@ , @@int@@ , Number , @@int@@ , @@int64@@ , Number ) ; }
__int64 __fastcall rpl_re_search ( int @@int@@ , int @@int@@ , int @@int@@ , int @@int@@ , int @@int@@ , __int64 @@int64@@ ) { return re_search_stub ( @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int64@@ , Number ) ; }
__int64 __fastcall rpl_re_match_2 ( int @@int@@ , int @@int@@ , int @@int@@ , int @@int@@ , int @@int@@ , int @@int@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { return re_search_2_stub ( @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int@@ , @@int@@ , Number L , @@int64@@ , @@int64@@ , Number ) ; }
__int64 __fastcall duplicate_tree ( __int64 * * @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 * @@int64@@ ; __int64 * @@int64@@ ; __int64 * @@int64@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = & @@int64@@ ; @@int64@@ = * @@int64@@ ; @@int64@@ = ( __int64 * ) @@int64@@ ; while ( Number ) { @@int64@@ = create_token_tree ( @@int64@@ , Number L , Number L , @@int64@@ + Number ) ; * @@int64@@ = @@int64@@ ; if ( ! * @@int64@@ ) break ; * ( _QWORD * ) * @@int64@@ = @@int64@@ ; * ( _BYTE * ) ( * @@int64@@ + Number ) |= Number ; @@int64@@ = ( __int64 * ) * @@int64@@ ; if ( @@int64@@ [ Number ] ) { @@int64@@ = ( __int64 * ) @@int64@@ [ Number ] ; @@int64@@ = @@int64@@ + Number ; } else { @@int64@@ = Number L ; while ( @@int64@@ == ( __int64 * ) @@int64@@ [ Number ] || ! @@int64@@ [ Number ] ) { @@int64@@ = @@int64@@ ; @@int64@@ = ( __int64 * ) * @@int64@@ ; @@int64@@ = ( __int64 * ) * @@int64@@ ; if ( ! @@int64@@ ) return @@int64@@ ; } @@int64@@ = ( __int64 * ) @@int64@@ [ Number ] ; @@int64@@ = @@int64@@ + Number ; } } return Number L ; }
__int64 __fastcall build_charclass_op ( __int64 @@int64@@ , __int64 @@int64@@ , const char * @@constchar@@ , _BYTE * @@BYTE@@ , char @@char@@ , _DWORD * @@DWORD@@ ) { int @@int@@ ; __int64 @@int64@@ ; void * @@void@@ ; _BYTE * @@BYTE@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; void * @@void@@ ; char @@char@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = Number L ; @@void@@ = calloc ( Number , Number ) ; @@BYTE@@ = calloc ( Number , Number ) ; if ( ! @@void@@ || ! @@BYTE@@ ) { * @@DWORD@@ = Number ; return Number L ; } if ( @@char@@ ) @@BYTE@@ [ Number ] |= Number ; @@int@@ = build_charclass ( @@int64@@ , ( __int64 ) @@void@@ , ( __int64 ) @@BYTE@@ , & @@int64@@ , @@constchar@@ , Number ) ; if ( @@int@@ ) { free ( @@void@@ ) ; free_charset ( @@BYTE@@ ) ; * @@DWORD@@ = @@int@@ ; return Number L ; } while ( * @@BYTE@@ ) bitset_set ( ( __int64 ) @@void@@ , ( unsigned __int8 ) * @@BYTE@@ ++ ) ; if ( @@char@@ ) bitset_not ( ( __int64 ) @@void@@ ) ; if ( * ( int * ) ( @@int64@@ + Number ) > Number ) bitset_mask ( ( __int64 ) @@void@@ , * ( _QWORD * ) ( @@int64@@ + Number ) ) ; @@char@@ = Number ; @@void@@ = @@void@@ ; @@int64@@ = create_token_tree ( @@int64@@ , Number L , Number L , & @@void@@ ) ; if ( @@int64@@ ) { if ( * ( int * ) ( @@int64@@ + Number ) <= Number ) { free_charset ( @@BYTE@@ ) ; return @@int64@@ ; } @@char@@ = Number ; @@void@@ = @@BYTE@@ ; * ( _BYTE * ) ( @@int64@@ + Number ) |= Number ; @@int64@@ = create_token_tree ( @@int64@@ , Number L , Number L , & @@void@@ ) ; if ( @@int64@@ ) { @@int64@@ = create_tree ( @@int64@@ , @@int64@@ , @@int64@@ , Number L ) ; if ( @@int64@@ ) return @@int64@@ ; } } free ( @@void@@ ) ; free_charset ( @@BYTE@@ ) ; * @@DWORD@@ = Number ; return Number L ; }
__int64 __fastcall re_search_2_stub ( int @@int@@ , const void * @@constvoid@@ , size_t @@sizet@@ , const void * @@constvoid@@ , size_t @@sizet@@ , int @@int@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int64@@ ; char * @@char@@ ; size_t @@sizet@@ ; __int64 @@int64@@ ; @@sizet@@ = @@sizet@@ + @@sizet@@ ; @@char@@ = Number L ; if ( @@sizet@@ + @@sizet@@ < @@sizet@@ ) return Number ; if ( @@sizet@@ ) { if ( @@sizet@@ ) { @@char@@ = ( char * ) malloc ( @@sizet@@ ) ; if ( ! @@char@@ ) return Number ; memcpy ( @@char@@ , @@constvoid@@ , @@sizet@@ ) ; memcpy ( & @@char@@ [ @@sizet@@ ] , @@constvoid@@ , @@sizet@@ ) ; @@int64@@ = re_search_stub ( @@int@@ , ( _DWORD ) @@char@@ , @@sizet@@ , @@int@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@unsignedint8@@ ) ; } else { @@int64@@ = re_search_stub ( @@int@@ , ( _DWORD ) @@constvoid@@ , @@sizet@@ , @@int@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@unsignedint8@@ ) ; } } else { @@int64@@ = re_search_stub ( @@int@@ , ( _DWORD ) @@constvoid@@ , @@sizet@@ , @@int@@ , @@int64@@ , @@int64@@ , @@int64@@ , @@unsignedint8@@ ) ; } @@int64@@ = @@int64@@ ; free ( @@char@@ ) ; return @@int64@@ ; }
__int64 __fastcall prune_impossible_nodes ( __int64 @@int64@@ ) { unsigned int @@unsignedint@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; char @@char@@ [ Number ] ; void * @@void@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@QWORD@@ = Number L ; @@unsignedint64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( @@unsignedint64@@ > Number ) return Number L ; @@QWORD@@ = malloc ( Number * ( @@unsignedint64@@ + Number ) ) ; if ( @@QWORD@@ ) { if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) { @@QWORD@@ = malloc ( Number * ( @@unsignedint64@@ + Number ) ) ; if ( @@QWORD@@ ) { while ( Number ) { memset ( @@QWORD@@ , Number , Number * ( @@unsignedint64@@ + Number ) ) ; sift_ctx_init ( @@char@@ , @@QWORD@@ , @@QWORD@@ , @@int64@@ , @@unsignedint64@@ ) ; @@unsignedint@@ = sift_states_backward ( @@int64@@ , @@char@@ ) ; free ( @@void@@ ) ; if ( @@unsignedint@@ ) break ; if ( * @@QWORD@@ || * @@QWORD@@ ) { @@unsignedint@@ = merge_state_array ( @@int64@@ , @@QWORD@@ , @@QWORD@@ , @@unsignedint64@@ + Number ) ; free ( @@QWORD@@ ) ; @@QWORD@@ = Number L ; if ( ! @@unsignedint@@ ) goto LABEL_21 ; break ; } do { if ( -- @@unsignedint64@@ > Number ) { @@unsignedint@@ = Number ; goto LABEL_22 ; } } while ( ! * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) || ( * ( _BYTE * ) ( * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) + Number L ) & Number ) == Number ) ; @@int64@@ = check_halt_state_context ( @@int64@@ , * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) , @@unsignedint64@@ ) ; } } else { @@unsignedint@@ = Number ; } } else { sift_ctx_init ( @@char@@ , @@QWORD@@ , Number L , @@int64@@ , @@unsignedint64@@ ) ; @@unsignedint@@ = sift_states_backward ( @@int64@@ , @@char@@ ) ; free ( @@void@@ ) ; if ( ! @@unsignedint@@ ) { if ( * @@QWORD@@ ) { LABEL_21 : free ( * ( void * * ) ( @@int64@@ + Number ) ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@QWORD@@ ; @@QWORD@@ = Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@unsignedint64@@ ; @@unsignedint@@ = Number ; } else { @@unsignedint@@ = Number ; } } } } else { @@unsignedint@@ = Number ; } LABEL_22 : free ( @@QWORD@@ ) ; free ( @@QWORD@@ ) ; return @@unsignedint@@ ; }
__int64 __fastcall push_fail_stack ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , const void * @@constvoid@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; void * @@void@@ ; @@int64@@ = ( * ( _QWORD * ) @@int64@@ ) ++ ; @@int64@@ = @@int64@@ ; if ( * ( _QWORD * ) @@int64@@ == * ( _QWORD * ) ( @@int64@@ + Number ) ) { @@void@@ = realloc ( * ( void * * ) ( @@int64@@ + Number ) , Number L * * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( ! @@void@@ ) return Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) *= Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@void@@ ; } * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ ) = @@int64@@ ; * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ + Number ) = @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = malloc ( Number * @@int64@@ ) ; if ( ! * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ + Number ) ) return Number L ; memcpy ( * ( void * * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ + Number ) , @@constvoid@@ , Number * @@int64@@ ) ; return ( unsigned int ) re_node_set_init_copy ( ( void * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ + Number ) , @@int64@@ ) ; }
__int64 __fastcall pop_fail_stack ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ , __int64 @@int64@@ , void * @@void@@ , __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = -- * @@QWORD@@ ; if ( * @@QWORD@@ > Number ) __assert_fail ( String , String , Number , String ) ; * @@QWORD@@ = * ( _QWORD * ) ( @@QWORD@@ [ Number ] + Number * @@int64@@ ) ; memcpy ( @@void@@ , * ( const void * * ) ( @@QWORD@@ [ Number ] + Number * @@int64@@ + Number ) , Number * @@int64@@ ) ; free ( * ( void * * ) ( @@int64@@ + Number ) ) ; free ( * ( void * * ) ( @@QWORD@@ [ Number ] + Number * @@int64@@ + Number ) ) ; @@QWORD@@ = ( _QWORD * ) ( @@QWORD@@ [ Number ] + Number * @@int64@@ ) ; @@int64@@ = @@QWORD@@ [ Number ] ; * ( _QWORD * ) @@int64@@ = @@QWORD@@ [ Number ] ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@QWORD@@ [ Number ] ; return * ( _QWORD * ) ( @@QWORD@@ [ Number ] + Number * @@int64@@ + Number ) ; }
__int64 __fastcall update_cur_sifted_state ( _QWORD * @@QWORD@@ , _QWORD * @@QWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; _QWORD * @@QWORD@@ ; unsigned int @@unsignedint@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = @@QWORD@@ [ Number ] ; @@unsignedint@@ = Number ; if ( * ( _QWORD * ) ( Number * @@int64@@ + @@QWORD@@ [ Number ] ) ) @@int64@@ = * ( _QWORD * ) ( Number * @@int64@@ + @@QWORD@@ [ Number ] ) + Number L ; else @@int64@@ = Number L ; @@int64@@ = @@int64@@ ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) { if ( @@int64@@ ) { @@unsignedint@@ = add_epsilon_src_nodes ( @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; if ( @@QWORD@@ [ Number ] ) { @@unsignedint@@ = check_subexp_limits ( @@int64@@ , @@int64@@ , @@int64@@ , @@QWORD@@ + Number , @@QWORD@@ [ Number ] , @@int64@@ ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; } } @@QWORD@@ = ( _QWORD * ) ( * @@QWORD@@ + Number * @@int64@@ ) ; * @@QWORD@@ = re_acquire_state ( & @@unsignedint@@ , @@int64@@ , @@int64@@ ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; } else { * ( _QWORD * ) ( Number * @@int64@@ + * @@QWORD@@ ) = Number L ; } if ( @@int64@@ && ( * ( _BYTE * ) ( * ( _QWORD * ) ( Number * @@int64@@ + @@QWORD@@ [ Number ] ) + Number L ) & Number ) != Number && ( @@unsignedint@@ = sift_states_bkref ( @@QWORD@@ , @@QWORD@@ , @@int64@@ , @@int64@@ ) ) != Number ) { @@int64@@ = @@unsignedint@@ ; } else { @@int64@@ = Number L ; } return @@int64@@ ; }
__int64 __fastcall build_sifted_states ( __int64 @@int64@@ , _QWORD * @@QWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; @@QWORD@@ = * ( _QWORD * * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( Number * @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) + Number L ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { @@unsignedint64@@ = * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; @@int@@ = Number ; if ( ( * ( _BYTE * ) ( Number * @@unsignedint64@@ + * @@QWORD@@ + Number ) & Number ) != Number ) @@int@@ = sift_states_iter_mb ( @@int64@@ , @@QWORD@@ , @@unsignedint64@@ , @@int64@@ , @@QWORD@@ [ Number ] ) ; if ( ! @@int@@ && ( unsigned __int8 ) check_node_accept ( @@int64@@ , * @@QWORD@@ + Number * @@unsignedint64@@ , @@int64@@ ) && * ( _QWORD * ) ( Number * ( @@int64@@ + Number ) + * @@QWORD@@ ) && re_node_set_contains ( * ( _QWORD * ) ( Number * ( @@int64@@ + Number ) + * @@QWORD@@ ) + Number L , * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@QWORD@@ [ Number ] ) ) ) { @@int@@ = Number ; } if ( @@int@@ && ( ! @@QWORD@@ [ Number ] || ! ( unsigned __int8 ) check_dst_limits ( @@int64@@ , @@QWORD@@ + Number , * ( _QWORD * ) ( Number * @@unsignedint64@@ + @@QWORD@@ [ Number ] ) , @@int@@ + @@int64@@ , @@unsignedint64@@ , @@int64@@ ) ) && ! re_node_set_insert ( @@int64@@ , @@unsignedint64@@ ) ) { return Number L ; } } return Number L ; }
__int64 __fastcall clean_state_log_if_needed ( _QWORD * @@QWORD@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned int @@unsignedint@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = @@QWORD@@ [ Number ] ; if ( @@unsignedint64@@ >= @@QWORD@@ [ Number ] || @@unsignedint64@@ >= @@QWORD@@ [ Number ] && @@QWORD@@ [ Number ] < @@QWORD@@ [ Number ] ) { @@unsignedint@@ = extend_buffers ( @@QWORD@@ ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; } if ( @@unsignedint64@@ < @@unsignedint64@@ ) { memset ( ( void * ) ( Number * ( @@unsignedint64@@ + Number ) + @@QWORD@@ [ Number ] ) , Number , Number * ( @@unsignedint64@@ - @@unsignedint64@@ ) ) ; @@QWORD@@ [ Number ] = @@unsignedint64@@ ; } return Number L ; }
__int64 __fastcall sift_states_iter_mb ( __int64 @@int64@@ , _QWORD * @@QWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { int @@int@@ ; __int64 @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int@@ = check_node_accept_bytes ( @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( @@int@@ > Number && @@unsignedint64@@ >= @@int@@ + @@int64@@ && ( ! * ( _QWORD * ) ( Number * ( @@int@@ + @@int64@@ ) + * @@QWORD@@ ) || ! re_node_set_contains ( * ( _QWORD * ) ( Number * ( @@int@@ + @@int64@@ ) + * @@QWORD@@ ) + Number L , * ( _QWORD * ) ( Number * @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ) ) { @@int@@ = Number ; } return ( unsigned int ) @@int@@ ; }
__int64 __fastcall check_dst_limits ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; @@QWORD@@ = * ( _QWORD * * ) ( @@int64@@ + Number ) ; @@int64@@ = search_cur_bkref_entry ( @@int64@@ , @@int64@@ ) ; @@int64@@ = search_cur_bkref_entry ( @@int64@@ , @@int64@@ ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { @@int64@@ = * ( _QWORD * ) ( * @@QWORD@@ + Number L * * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L * * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ) ) ; @@int64@@ = ( int ) check_dst_limits_calc_pos ( @@int64@@ , * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) , @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( ( int ) check_dst_limits_calc_pos ( @@int64@@ , * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) , @@int64@@ , @@int64@@ , @@int64@@ , @@int64@@ ) != @@int64@@ ) return Number L ; } return Number L ; }
__int64 __fastcall check_subexp_matching_top ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { unsigned int @@unsignedint@@ ; unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; @@QWORD@@ = * ( _QWORD * * ) ( @@int64@@ + Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { @@int64@@ = * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( * ( _BYTE * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) == Number && * ( _QWORD * ) ( Number * @@int64@@ + * @@QWORD@@ ) <= Number && ( ( @@QWORD@@ [ Number ] >> * ( _QWORD * ) ( Number * @@int64@@ + * @@QWORD@@ ) ) & Number L ) != Number ) { @@unsignedint@@ = match_ctx_add_subtop ( @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; } } return Number L ; }
__int64 __fastcall sub_epsilon_src_nodes ( _QWORD * @@QWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; unsigned int @@unsignedint@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; char @@char@@ [ Number ] ; void * @@void@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = @@QWORD@@ [ Number ] + Number * @@int64@@ ; memset ( @@char@@ , Number , Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { @@int64@@ = * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( @@int64@@ != @@int64@@ && ( * ( _BYTE * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) & Number ) != Number ) { @@unsignedint64@@ = * * ( _QWORD * * ) ( @@QWORD@@ [ Number ] + Number * @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@QWORD@@ [ Number ] + Number * @@int64@@ + Number ) <= Number ? Number : * ( _QWORD * ) ( * ( _QWORD * ) ( @@QWORD@@ [ Number ] + Number * @@int64@@ + Number ) + Number L ) ; if ( ( @@unsignedint64@@ = @@int64@@ , ! re_node_set_contains ( @@int64@@ , @@unsignedint64@@ ) ) && re_node_set_contains ( @@int64@@ , @@unsignedint64@@ ) || @@unsignedint64@@ - Number <= Number && ! re_node_set_contains ( @@int64@@ , @@unsignedint64@@ ) && re_node_set_contains ( @@int64@@ , @@unsignedint64@@ ) ) { @@unsignedint@@ = re_node_set_add_intersect ( ( __int64 ) @@char@@ , @@int64@@ , @@QWORD@@ [ Number ] + Number * @@int64@@ ) ; if ( @@unsignedint@@ ) { free ( @@void@@ ) ; return @@unsignedint@@ ; } } } } for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { @@unsignedint64@@ = * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( ! re_node_set_contains ( ( __int64 ) @@char@@ , @@unsignedint64@@ ) ) { @@unsignedint64@@ = re_node_set_contains ( @@int64@@ , @@unsignedint64@@ ) - Number ; re_node_set_remove_at ( @@int64@@ , @@unsignedint64@@ ) ; } } free ( @@void@@ ) ; return Number L ; }
__int64 __fastcall transit_state ( _DWORD * @@DWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int8 @@unsignedint8@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; if ( ( * ( _BYTE * ) ( @@int64@@ + Number ) & Number ) != Number ) { * @@DWORD@@ = transit_state_mb ( @@int64@@ , @@int64@@ ) ; if ( * @@DWORD@@ ) return Number L ; } @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ + Number ; @@unsignedint8@@ = * ( _BYTE * ) ( @@int64@@ + @@int64@@ ) ; while ( Number ) { @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( @@int64@@ ) return * ( _QWORD * ) ( Number L * @@unsignedint8@@ + @@int64@@ ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( @@int64@@ ) break ; if ( ( unsigned __int8 ) build_trtable ( * ( _QWORD * ) ( @@int64@@ + Number ) , @@int64@@ ) != Number ) { * @@DWORD@@ = Number ; return Number L ; } } if ( ( re_string_context_at ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) - Number L , * ( _DWORD * ) ( @@int64@@ + Number ) ) & Number ) != Number ) @@int64@@ = Number * ( @@unsignedint8@@ + Number L ) ; else @@int64@@ = Number L * @@unsignedint8@@ ; return * ( _QWORD * ) ( @@int64@@ + @@int64@@ ) ; }
__int64 __fastcall check_arrival_add_next_nodes ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { _QWORD * @@QWORD@@ ; unsigned int @@unsignedint@@ ; int @@int@@ ; unsigned __int64 @@unsignedint64@@ ; _QWORD * @@QWORD@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; char @@char@@ [ Number ] ; __int64 @@int64@@ ; void * @@void@@ ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@QWORD@@ = * ( _QWORD * * ) ( @@int64@@ + Number ) ; @@unsignedint@@ = Number ; memset ( @@char@@ , Number , Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { @@int@@ = Number ; @@int64@@ = * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( ( * ( _BYTE * ) ( Number * @@int64@@ + * @@QWORD@@ + Number ) & Number ) != Number ) { @@int@@ = check_node_accept_bytes ( @@QWORD@@ , @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( @@int@@ > Number ) { @@unsignedint64@@ = * ( _QWORD * ) ( Number * @@int64@@ + @@QWORD@@ [ Number ] ) ; @@int64@@ = @@int@@ + @@int64@@ ; @@int64@@ = * ( _QWORD * ) ( Number * @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; @@int64@@ = Number L ; if ( @@int64@@ ) { @@unsignedint@@ = re_node_set_merge ( ( __int64 ) @@char@@ , @@int64@@ + Number ) ; if ( @@unsignedint@@ ) goto LABEL_6 ; } if ( ! re_node_set_insert ( ( __int64 ) @@char@@ , @@unsignedint64@@ ) ) goto LABEL_8 ; @@QWORD@@ = ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@int64@@ ) ; * @@QWORD@@ = re_acquire_state ( & @@unsignedint@@ , ( __int64 ) @@QWORD@@ , ( __int64 ) @@char@@ ) ; if ( ! * ( _QWORD * ) ( Number * @@int64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ) { if ( @@unsignedint@@ ) { LABEL_6 : free ( @@void@@ ) ; return @@unsignedint@@ ; } } } } if ( ( @@int@@ || ( unsigned __int8 ) check_node_accept ( @@int64@@ , * @@QWORD@@ + Number * @@int64@@ , @@int64@@ ) ) && ! re_node_set_insert ( @@int64@@ , * ( _QWORD * ) ( Number * @@int64@@ + @@QWORD@@ [ Number ] ) ) ) { LABEL_8 : free ( @@void@@ ) ; return Number L ; } } free ( @@void@@ ) ; return Number L ; }
__int64 __fastcall find_subexp_node ( _QWORD * @@QWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ , int @@int@@ ) { unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( _QWORD * ) ( @@int64@@ + Number ) ; ++ @@unsignedint64@@ ) { @@int64@@ = Number L * * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) + * @@QWORD@@ ; if ( @@int@@ == * ( unsigned __int8 * ) ( @@int64@@ + Number ) && @@int64@@ == * ( _QWORD * ) @@int64@@ ) { return * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; } } return Number ; }
__int64 __fastcall merge_state_with_log ( _DWORD * @@DWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 * @@int64@@ ; __int64 @@int64@@ ; unsigned int @@unsignedint@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; __int64 @@int64@@ [ Number ] ; void * @@void@@ ; unsigned __int64 @@unsignedint64@@ ; @@int64@@ = @@int64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@unsignedint64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; if ( @@unsignedint64@@ <= * ( _QWORD * ) ( @@int64@@ + Number ) ) { if ( * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ) { @@int64@@ = Number L ; @@int64@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) + Number L ) ; if ( @@int64@@ ) { @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; * @@DWORD@@ = re_node_set_init_union ( @@int64@@ , @@int64@@ , @@int64@@ ) ; if ( * @@DWORD@@ ) return Number L ; } else { @@int64@@ = * ( _QWORD * ) ( @@int64@@ + Number ) ; @@int64@@ [ Number ] = * ( _QWORD * ) @@int64@@ ; @@int64@@ [ Number ] = @@int64@@ ; @@void@@ = * ( void * * ) ( @@int64@@ + Number ) ; } @@unsignedint@@ = re_string_context_at ( @@int64@@ , * ( _QWORD * ) ( @@int64@@ + Number ) - Number L , * ( _DWORD * ) ( @@int64@@ + Number ) ) ; @@int64@@ = ( __int64 * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@unsignedint64@@ ) ; * @@int64@@ = re_acquire_state_context ( @@DWORD@@ , @@int64@@ , ( __int64 ) @@int64@@ , @@unsignedint@@ ) ; @@int64@@ = * @@int64@@ ; if ( @@int64@@ ) free ( @@void@@ ) ; } else { * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@unsignedint64@@ ) = @@int64@@ ; } } else { * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number * @@unsignedint64@@ ) = @@int64@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@unsignedint64@@ ; } if ( * ( _QWORD * ) ( @@int64@@ + Number ) && @@int64@@ ) { * @@DWORD@@ = check_subexp_matching_top ( @@int64@@ , @@int64@@ + Number , @@unsignedint64@@ ) ; if ( * @@DWORD@@ ) return Number L ; if ( ( * ( _BYTE * ) ( @@int64@@ + Number ) & Number ) != Number ) { * @@DWORD@@ = transit_state_bkref ( @@int64@@ , @@int64@@ + Number ) ; if ( * @@DWORD@@ ) return Number L ; @@int64@@ = * ( _QWORD * ) ( Number * @@unsignedint64@@ + * ( _QWORD * ) ( @@int64@@ + Number ) ) ; } } return @@int64@@ ; }
_QWORD * __fastcall match_ctx_clean ( _QWORD * @@QWORD@@ ) { _QWORD * @@QWORD@@ ; unsigned __int64 @@unsignedint64@@ ; unsigned __int64 @@unsignedint64@@ ; void * @@void@@ ; void * * @@void@@ ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < @@QWORD@@ [ Number ] ; ++ @@unsignedint64@@ ) { @@void@@ = * ( void * * ) ( Number * @@unsignedint64@@ + @@QWORD@@ [ Number ] ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ < * ( ( _QWORD * ) @@void@@ + Number ) ; ++ @@unsignedint64@@ ) { @@void@@ = * ( void * * * ) ( Number * @@unsignedint64@@ + * ( ( _QWORD * ) @@void@@ + Number ) ) ; free ( @@void@@ [ Number ] ) ; free ( @@void@@ ) ; } free ( * ( ( void * * ) @@void@@ + Number ) ) ; if ( * ( ( _QWORD * ) @@void@@ + Number ) ) { free ( * ( void * * ) ( * ( ( _QWORD * ) @@void@@ + Number ) + Number L ) ) ; free ( * ( ( void * * ) @@void@@ + Number ) ) ; } free ( @@void@@ ) ; } @@QWORD@@ [ Number ] = Number L ; @@QWORD@@ = @@QWORD@@ ; @@QWORD@@ [ Number ] = Number L ; return @@QWORD@@ ; }
_BOOL8 __fastcall check_node_accept ( __int64 @@int64@@ , __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ ) { int @@int@@ ; _BOOL8 @@BOOL8@@ ; char @@char@@ ; char @@char@@ ; @@char@@ = * ( _BYTE * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + @@unsignedint64@@ ) ; @@int@@ = * ( unsigned __int8 * ) ( @@int64@@ + Number ) ; if ( @@int@@ == Number ) { if ( ! bitset_contain ( * ( _QWORD * ) @@int64@@ , ( unsigned __int8 ) @@char@@ ) ) return Number L ; } else if ( * ( unsigned __int8 * ) ( @@int64@@ + Number ) > Number ) { if ( @@int@@ != Number ) { if ( @@int@@ != Number ) return Number L ; if ( @@char@@ < Number ) return Number L ; } if ( @@char@@ == Number && ( * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) & Number ) == Number || ! @@char@@ && ( * ( _QWORD * ) ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) & Number ) != Number ) { return Number L ; } } else { if ( @@int@@ != Number ) return Number L ; if ( @@char@@ != * ( _BYTE * ) @@int64@@ ) return Number L ; } @@BOOL8@@ = Number ; if ( ( * ( _DWORD * ) ( @@int64@@ + Number ) & Number ) != Number ) { if ( ( @@char@@ = re_string_context_at ( @@int64@@ , @@unsignedint64@@ , * ( _DWORD * ) ( @@int64@@ + Number ) ) , ( ( * ( _DWORD * ) ( @@int64@@ + Number ) >> Number ) & Number ) != Number ) && ( @@char@@ & Number ) == Number || ( ( * ( _DWORD * ) ( @@int64@@ + Number ) >> Number ) & Number ) != Number && ( @@char@@ & Number ) != Number || ( ( * ( _DWORD * ) ( @@int64@@ + Number ) >> Number ) & Number ) != Number && ( @@char@@ & Number ) == Number || ( ( * ( _DWORD * ) ( @@int64@@ + Number ) >> Number ) & Number ) != Number && ( @@char@@ & Number ) == Number ) { @@BOOL8@@ = Number ; } } return @@BOOL8@@ ; }
__int64 __fastcall full_write ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; __int64 @@int64@@ ; @@int64@@ = Number L ; while ( @@int64@@ ) { @@int64@@ = safe_write ( @@unsignedint@@ , @@int64@@ , @@int64@@ ) ; if ( @@int64@@ == Number ) break ; if ( ! @@int64@@ ) { * __errno_location ( ) = Number ; return @@int64@@ ; } @@int64@@ += @@int64@@ ; @@int64@@ += @@int64@@ ; @@int64@@ -= @@int64@@ ; } return @@int64@@ ; }
_QWORD * __fastcall match_ctx_add_sublast ( __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { __int64 @@int64@@ ; void * @@void@@ ; _QWORD * @@QWORD@@ ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) == * ( _QWORD * ) ( @@int64@@ + Number ) ) { @@int64@@ = Number L * * ( _QWORD * ) ( @@int64@@ + Number ) + Number ; @@void@@ = realloc ( * ( void * * ) ( @@int64@@ + Number ) , Number * @@int64@@ ) ; if ( ! @@void@@ ) return Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@void@@ ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@int64@@ ; } @@QWORD@@ = calloc ( Number , Number ) ; if ( @@QWORD@@ ) { * ( _QWORD * ) ( Number L * * ( _QWORD * ) ( @@int64@@ + Number ) + * ( _QWORD * ) ( @@int64@@ + Number ) ) = @@QWORD@@ ; * @@QWORD@@ = @@int64@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; ++ * ( _QWORD * ) ( @@int64@@ + Number ) ; } return @@QWORD@@ ; }
__int64 __fastcall extend_buffers ( __int64 @@int64@@ ) { unsigned int @@unsignedint@@ ; unsigned int @@unsignedint@@ ; void * @@void@@ ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) > Number ) return Number L ; @@unsignedint@@ = re_string_realloc_buffers ( @@int64@@ , Number L * * ( _QWORD * ) ( @@int64@@ + Number ) ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) { @@void@@ = realloc ( * ( void * * ) ( @@int64@@ + Number ) , Number * ( * ( _QWORD * ) ( @@int64@@ + Number ) + Number L ) ) ; if ( ! @@void@@ ) return Number L ; * ( _QWORD * ) ( @@int64@@ + Number ) = @@void@@ ; } if ( * ( _BYTE * ) ( @@int64@@ + Number ) ) { if ( * ( int * ) ( @@int64@@ + Number ) <= Number ) { build_upper_buffer ( ( _QWORD * ) @@int64@@ ) ; } else { @@unsignedint@@ = build_wcs_upper_buffer ( @@int64@@ ) ; if ( @@unsignedint@@ ) return @@unsignedint@@ ; } } else if ( * ( int * ) ( @@int64@@ + Number ) <= Number ) { if ( * ( _QWORD * ) ( @@int64@@ + Number ) ) re_string_translate_buffer ( ( _QWORD * ) @@int64@@ ) ; } else { build_wcs_buffer ( @@int64@@ ) ; } return Number L ; }
int emit_ancillary_info ( ) { __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; FILE * @@FILE@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; __int64 @@int64@@ ; char * @@char@@ ; const char * @@constchar@@ ; @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ , String ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , String , String ) ; @@FILE@@ = stdout ; @@char@@ = gettext ( String ) ; fputs_unlocked ( @@char@@ , @@FILE@@ ) ; @@constchar@@ = setlocale ( Number , Number L ) ; if ( @@constchar@@ && strncmp ( @@constchar@@ , String , Number ) ) { @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; printf ( @@char@@ , @@int64@@ ) ; } @@int64@@ = last_component ( program_name ) ; @@char@@ = gettext ( String ) ; return printf ( @@char@@ , @@int64@@ ) ; }
void __fastcall match_ctx_free ( __int64 @@int64@@ ) { match_ctx_clean ( ( _QWORD * ) @@int64@@ ) ; free ( * ( void * * ) ( @@int64@@ + Number ) ) ; free ( * ( void * * ) ( @@int64@@ + Number ) ) ; }
bool __fastcall is_basic ( unsigned __int8 @@unsignedint8@@ ) { return ( ( * ( ( _DWORD * ) & is_basic_table + ( @@unsignedint8@@ >> Number ) ) >> ( @@unsignedint8@@ & Number ) ) & Number ) != Number ; }
void * __fastcall sift_ctx_init ( _QWORD * @@QWORD@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ , __int64 @@int64@@ ) { * @@QWORD@@ = @@int64@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; @@QWORD@@ [ Number ] = @@int64@@ ; return memset ( @@QWORD@@ + Number , Number , Number ) ; }
__int64 __fastcall xnrealloc ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { if ( ! is_mul_ok ( @@unsignedint64@@ , @@unsignedint64@@ ) ) xalloc_die ( ) ; return xrealloc ( @@int64@@ , @@unsignedint64@@ * @@unsignedint64@@ ) ; }
__int64 __fastcall x2nrealloc ( __int64 @@int64@@ , unsigned __int64 * @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = * @@unsignedint64@@ ; if ( @@int64@@ ) { if ( @@unsignedint64@@ >= Number / @@unsignedint64@@ ) xalloc_die ( ) ; @@unsignedint64@@ += ( @@unsignedint64@@ + Number ) >> Number ; } else if ( ! @@unsignedint64@@ ) { @@unsignedint64@@ = ( Number / @@unsignedint64@@ == Number ) + Number / @@unsignedint64@@ ; } * @@unsignedint64@@ = @@unsignedint64@@ ; return xrealloc ( @@int64@@ , @@unsignedint64@@ * @@unsignedint64@@ ) ; }
__int64 __fastcall io_blksize ( __int64 a1 , __int64 a2 , __int64 a3 , __int64 a4 , __int64 a5 , __int64 a6 , int a7 , int a8 , int a9 , int a10 , int a11 , int a12 , int a13 , __int64 @@int64@@ ) { __int64 @@int64@@ ; if ( @@int64@@ <= Number || ( unsigned __int64 ) @@int64@@ > Number || @@int64@@ <= Number ) { @@int64@@ = Number ; } else { @@int64@@ = @@int64@@ ; } return @@int64@@ ; }
__int64 __fastcall simple_cat ( __int64 @@int64@@ , __int64 @@int64@@ ) { const char * @@constchar@@ ; int * @@int@@ ; char * @@char@@ ; int * @@int@@ ; __int64 @@int64@@ ; while ( Number ) { @@int64@@ = safe_read ( ( unsigned int ) input_desc , @@int64@@ , @@int64@@ ) ; if ( @@int64@@ == Number ) { @@constchar@@ = infile ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , String , @@constchar@@ ) ; return Number L ; } if ( ! @@int64@@ ) break ; if ( @@int64@@ != full_write ( Number L , @@int64@@ , @@int64@@ ) ) { @@char@@ = gettext ( String ) ; @@int@@ = __errno_location ( ) ; error ( Number , * @@int@@ , @@char@@ ) ; } } return Number L ; }
char * __fastcall proper_name_utf8 ( const char * @@constchar@@ , __int64 @@int64@@ ) { char * @@char@@ ; char * @@char@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; char * @@char@@ ; char * @@char@@ ; __int64 @@int64@@ ; __int64 @@int64@@ ; char * @@char@@ ; char * @@char@@ ; size_t @@sizet@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; @@char@@ = ( char * ) locale_charset ( ) ; @@char@@ = Number L ; @@char@@ = Number L ; @@int64@@ = Number L ; if ( ( unsigned int ) c_strcasecmp ( @@char@@ , String ) ) { @@char@@ = ( char * ) xstr_iconv ( @@int64@@ , String , @@char@@ ) ; @@int64@@ = ( __int64 ) @@char@@ ; @@sizet@@ = strlen ( @@char@@ ) ; @@char@@ = ( char * ) xmalloc ( @@sizet@@ + Number ) ; memcpy ( @@char@@ , @@char@@ , @@sizet@@ ) ; memcpy ( & @@char@@ [ @@sizet@@ ] , String , Number ) ; @@char@@ = ( char * ) xstr_iconv ( @@int64@@ , String , @@char@@ ) ; free ( @@char@@ ) ; if ( @@char@@ ) { if ( strchr ( @@char@@ , Number ) ) { free ( @@char@@ ) ; } else { @@char@@ = @@char@@ ; @@int64@@ = ( __int64 ) @@char@@ ; } } } else { @@int64@@ = @@int64@@ ; @@int64@@ = @@int64@@ ; } if ( @@int64@@ ) { @@char@@ = ( char * ) @@int64@@ ; } else if ( @@int64@@ ) { @@char@@ = ( char * ) @@int64@@ ; } else { @@char@@ = ( char * ) @@constchar@@ ; } @@char@@ = @@char@@ ; if ( ! strcmp ( @@char@@ , @@constchar@@ ) ) { if ( @@char@@ && @@char@@ != @@char@@ ) free ( @@char@@ ) ; if ( @@char@@ && @@char@@ != @@char@@ ) free ( @@char@@ ) ; @@char@@ = @@char@@ ; } else if ( ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@char@@ , ( __int64 ) @@constchar@@ ) || @@int64@@ && ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@char@@ , @@int64@@ ) || @@int64@@ && ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@char@@ , @@int64@@ ) ) { if ( @@char@@ ) free ( @@char@@ ) ; if ( @@char@@ ) free ( @@char@@ ) ; @@char@@ = @@char@@ ; } else { @@sizet@@ = strlen ( @@char@@ ) ; @@sizet@@ = strlen ( @@char@@ ) ; @@char@@ = ( char * ) xmalloc ( @@sizet@@ + @@sizet@@ + Number ) ; sprintf ( @@char@@ , String , @@char@@ , @@char@@ ) ; if ( @@char@@ ) free ( @@char@@ ) ; if ( @@char@@ ) free ( @@char@@ ) ; @@char@@ = @@char@@ ; } return @@char@@ ; }
__int64 __fastcall strnlen1 ( const void * @@constvoid@@ , size_t @@sizet@@ ) { __int64 @@int64@@ ; _BYTE * @@BYTE@@ ; @@BYTE@@ = memchr ( @@constvoid@@ , Number , @@sizet@@ ) ; if ( @@BYTE@@ ) @@int64@@ = @@BYTE@@ - ( _BYTE * ) @@constvoid@@ + Number ; else @@int64@@ = @@sizet@@ ; return @@int64@@ ; }
__int64 __fastcall xnrealloc ( __int64 @@int64@@ , unsigned __int64 @@unsignedint64@@ , unsigned __int64 @@unsignedint64@@ ) { if ( ! is_mul_ok ( @@unsignedint64@@ , @@unsignedint64@@ ) ) xalloc_die ( ) ; return xrealloc ( @@int64@@ , @@unsignedint64@@ * @@unsignedint64@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@FILE@@ , const char * @@constchar@@ , const char * @@constchar@@ , const char * @@constchar@@ , unsigned int * @@unsignedint@@ ) { __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int6411@@ [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; for ( @@unsignedint64@@ = Number L ; @@unsignedint64@@ <= Number ; ++ @@unsignedint64@@ ) { if ( * @@unsignedint@@ > Number ) { @@int64@@ = ( __int64 * ) * ( ( _QWORD * ) @@unsignedint@@ + Number ) ; * ( ( _QWORD * ) @@unsignedint@@ + Number ) = @@int64@@ + Number ; } else { @@int64@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@unsignedint@@ + Number ) + * @@unsignedint@@ ) ; * @@unsignedint@@ += Number ; } @@int6411@@ [ @@unsignedint64@@ ] = * @@int64@@ ; if ( ! @@int6411@@ [ @@unsignedint64@@ ] ) break ; } version_etc_arn ( @@FILE@@ , @@constchar@@ , @@constchar@@ , @@constchar@@ , @@int6411@@ , @@unsignedint64@@ ) ; return __readfsqword ( Number ) ^ @@unsignedint64@@ ; }
const char * locale_charset ( ) { const char * @@constchar@@ ; char * @@char@@ ; char * @@char@@ ; @@constchar@@ = nl_langinfo ( Number ) ; if ( ! @@constchar@@ ) @@constchar@@ = ( const char * ) & unk_A1D5 ; for ( @@char@@ = ( char * ) get_charset_aliases ( ) ; * @@char@@ ; @@char@@ = & @@char@@ [ strlen ( @@char@@ ) + Number ] ) { if ( ! strcmp ( @@constchar@@ , @@char@@ ) || * @@char@@ == Number && ! @@char@@ [ Number ] ) { @@constchar@@ = & @@char@@ [ strlen ( @@char@@ ) + Number ] ; break ; } @@char@@ = & @@char@@ [ strlen ( @@char@@ ) + Number ] ; } if ( ! * @@constchar@@ ) @@constchar@@ = String ; return @@constchar@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@int64@@ , int @@int@@ ) { __int64 * @@int64@@ ; unsigned int @@unsignedint@@ ; @@int64@@ = @@int64@@ ; if ( ! @@int64@@ ) @@int64@@ = & default_quoting_options ; @@unsignedint@@ = * ( ( _DWORD * ) @@int64@@ + Number ) ; * ( ( _DWORD * ) @@int64@@ + Number ) = @@int@@ ; return @@unsignedint@@ ; }
char * __fastcall gettext_quote ( const char * @@constchar@@ , int @@int@@ ) { char * @@char@@ ; @@char@@ = gettext ( @@constchar@@ ) ; if ( @@char@@ == @@constchar@@ && @@int@@ == Number ) @@char@@ = ( char * ) String ; return @@char@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@int64@@ , size_t @@sizet@@ , _QWORD * @@QWORD@@ , __int64 * @@int64@@ ) { __int64 * @@int64@@ ; int @@int@@ ; int @@int@@ ; __int64 * @@int64@@ ; unsigned __int64 @@unsignedint64@@ ; __int64 @@int64@@ ; if ( @@int64@@ ) @@int64@@ = @@int64@@ ; else @@int64@@ = & default_quoting_options ; @@int64@@ = @@int64@@ ; @@int@@ = * __errno_location ( ) ; @@int@@ = * ( ( _DWORD * ) @@int64@@ + Number ) | ( @@QWORD@@ == Number L ) ; @@unsignedint64@@ = quotearg_buffer_restyled ( Number L , Number L , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) + Number ; @@int64@@ = xcharalloc ( @@unsignedint64@@ ) ; quotearg_buffer_restyled ( @@int64@@ , @@unsignedint64@@ , @@int64@@ , @@sizet@@ , * ( _DWORD * ) @@int64@@ , @@int@@ , ( __int64 ) ( @@int64@@ + Number ) , ( char * ) @@int64@@ [ Number ] , ( char * ) @@int64@@ [ Number ] ) ; * __errno_location ( ) = @@int@@ ; if ( @@QWORD@@ ) * @@QWORD@@ = @@unsignedint64@@ - Number ; return @@int64@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@unsignedint@@ , __int64 @@int64@@ ) { return quotearg_n_style ( Number , @@unsignedint@@ , @@int64@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@unsignedint@@ , __int64 @@int64@@ , size_t @@sizet@@ ) { return quotearg_n_style_mem ( Number , @@unsignedint@@ , @@int64@@ , @@sizet@@ ) ; }
__int64 __fastcall mem_cd_iconv ( char * @@char@@ , size_t @@sizet@@ , void * @@void@@ , void * * @@void@@ , size_t * @@sizet@@ ) { int @@int@@ ; char * @@char@@ ; size_t @@sizet@@ ; char * @@char@@ ; size_t @@sizet@@ ; void * @@void@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; size_t @@sizet@@ ; char @@char@@ $D1F1B2789FC85C59BE59CF61C76BFA1E [ Number ] ; unsigned __int64 @@unsignedint64@@ ; @@unsignedint64@@ = __readfsqword ( Number ) ; iconv ( @@void@@ , Number L , Number L , Number L , Number L ) ; @@sizet@@ = Number L ; @@char@@ = @@char@@ ; @@sizet@@ = @@sizet@@ ; while ( @@sizet@@ ) { @@char@@ = @@char@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; @@sizet@@ = Number L ; @@sizet@@ = iconv ( @@void@@ , & @@char@@ , & @@sizet@@ , & @@char@@ , & @@sizet@@ ) ; if ( @@sizet@@ == Number && * __errno_location ( ) != Number ) { if ( * __errno_location ( ) != Number ) return Number ; break ; } @@sizet@@ += @@char@@ - @@char@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; } @@char@@ = @@char@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; @@sizet@@ = Number L ; @@sizet@@ = iconv ( @@void@@ , Number L , Number L , & @@char@@ , & @@sizet@@ ) ; if ( @@sizet@@ == Number ) return Number ; @@sizet@@ += @@char@@ - @@char@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; @@sizet@@ = @@sizet@@ ; if ( ! @@sizet@@ ) { * @@sizet@@ = Number L ; return Number L ; } if ( * @@void@@ && @@sizet@@ <= * @@sizet@@ ) { @@void@@ = * @@void@@ ; } else { @@void@@ = malloc ( @@sizet@@ ) ; if ( ! @@void@@ ) { * __errno_location ( ) = Number ; return Number ; } } iconv ( @@void@@ , Number L , Number L , Number L , Number L ) ; @@char@@ = @@char@@ ; @@sizet@@ = @@sizet@@ ; @@char@@ = ( char * ) @@void@@ ; @@sizet@@ = @@sizet@@ ; while ( @@sizet@@ ) { @@sizet@@ = iconv ( @@void@@ , & @@char@@ , & @@sizet@@ , & @@char@@ , & @@sizet@@ ) ; if ( @@sizet@@ == Number ) { if ( * __errno_location ( ) != Number ) goto LABEL_26 ; break ; } } @@sizet@@ = iconv ( @@void@@ , Number L , Number L , & @@char@@ , & @@sizet@@ ) ; if ( @@sizet@@ != Number ) { if ( @@sizet@@ ) abort ( ) ; * @@void@@ = @@void@@ ; * @@sizet@@ = @@sizet@@ ; return Number L ; } LABEL_26 : if ( @@void@@ != * @@void@@ ) { @@int@@ = * __errno_location ( ) ; free ( @@void@@ ) ; * __errno_location ( ) = @@int@@ ; } return Number ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@int64@@ , size_t @@sizet@@ , unsigned __int8 @@unsignedint8@@ ) { __int64 @@int648@@ [ Number ] ; @@int648@@ [ Number ] = __readfsqword ( Number ) ; @@int648@@ [ Number ] = default_quoting_options ; @@int648@@ [ Number ] = qword_20C0E8 ; @@int648@@ [ Number ] = qword_20C0F0 ; @@int648@@ [ Number ] = qword_20C0F8 ; @@int648@@ [ Number ] = qword_20C100 ; @@int648@@ [ Number ] = qword_20C108 ; @@int648@@ [ Number ] = qword_20C110 ; set_char_quoting ( @@int648@@ , @@unsignedint8@@ , Number ) ; return quotearg_n_options ( Number , @@int64@@ , @@sizet@@ , ( __int64 ) @@int648@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@int64@@ ) { return xmalloc ( @@int64@@ ) ; }
__int64 __fastcall c_tolower ( int @@int@@ ) { __int64 @@int64@@ ; if ( @@int@@ <= Number || @@int@@ > Number ) @@int64@@ = ( unsigned int ) @@int@@ ; else @@int64@@ = ( unsigned int ) ( @@int@@ + Number ) ; return @@int64@@ ; }
__int64 __fastcall c_toupper ( int @@int@@ ) { __int64 @@int64@@ ; if ( @@int@@ <= Number || @@int@@ > Number ) @@int64@@ = ( unsigned int ) @@int@@ ; else @@int64@@ = ( unsigned int ) ( @@int@@ - Number ) ; return @@int64@@ ; }
unsigned __int64 __fastcall mmalloca ( unsigned __int64 @@unsignedint64@@ ) { char * @@char@@ ; unsigned __int64 @@unsignedint64@@ ; if ( @@unsignedint64@@ + Number < @@unsignedint64@@ ) return Number L ; @@char@@ = ( char * ) malloc ( @@unsignedint64@@ + Number ) ; if ( ! @@char@@ ) return Number L ; @@unsignedint64@@ = ( unsigned __int64 ) ( @@char@@ + Number ) ; * ( _DWORD * ) ( @@unsignedint64@@ - Number ) = Number ; * ( _QWORD * ) ( @@unsignedint64@@ - Number ) = mmalloca_results [ @@unsignedint64@@ % Number ] ; mmalloca_results [ @@unsignedint64@@ % Number ] = @@unsignedint64@@ ; return @@unsignedint64@@ ; }
