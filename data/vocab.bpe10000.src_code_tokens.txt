void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
int puts ( const char * @@s@@ ) { return puts ( @@s@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; char * @@v3@@ ; FILE * @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; @@v1@@ = program_name ; if ( @@a1@@ ) { @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = gettext ( String ) ; printf ( @@v3@@ , @@v1@@ ) ; @@v4@@ = stdout ; @@v5@@ = gettext ( String ) ; fputs_unlocked ( @@v5@@ , @@v4@@ ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; @@v8@@ = stdout ; @@v9@@ = gettext ( String ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
int __cdecl __noreturn main ( int @@argc@@ , const char * * @@argv@@ , const char * * @@envp@@ ) { __int64 @@v3@@ ; char * @@v4@@ ; char * @@v5@@ ; const char * @@s@@ ; set_program_name ( * @@argv@@ , @@argv@@ , @@envp@@ ) ; setlocale ( Number , & shortopts ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; parse_long_options ( @@argc@@ , ( _DWORD ) @@argv@@ , ( unsigned int ) String , ( unsigned int ) String , ( _DWORD ) Version , ( unsigned int ) usage , String , Number L ) ; if ( getopt_long ( @@argc@@ , ( char * const * ) @@argv@@ , & shortopts , Number L , Number L ) != Number ) usage ( Number ) ; if ( @@argc@@ > optind ) { @@v3@@ = quote ( @@argv@@ [ optind ] ) ; @@v4@@ = gettext ( String ) ; error ( Number , Number , @@v4@@ , @@v3@@ ) ; usage ( Number ) ; } @@s@@ = getlogin ( ) ; if ( @@s@@ ) { puts ( @@s@@ ) ; exit ( Number ) ; } @@v5@@ = gettext ( String ) ; error ( Number , Number , @@v5@@ ) ; exit ( Number ) ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_206028 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_206028 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_2060C8 ; @@v8@@ [ Number ] = qword_2060D0 ; @@v8@@ [ Number ] = qword_2060D8 ; @@v8@@ [ Number ] = qword_2060E0 ; @@v8@@ [ Number ] = qword_2060E8 ; @@v8@@ [ Number ] = qword_2060F0 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_2060C8 ; @@v4@@ [ Number ] = qword_2060D0 ; @@v4@@ [ Number ] = qword_2060D8 ; @@v4@@ [ Number ] = qword_2060E0 ; @@v4@@ [ Number ] = qword_2060E8 ; @@v4@@ [ Number ] = qword_2060F0 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
int rpmatch ( const char * @@response@@ ) { return rpmatch ( @@response@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return xmalloc ( @@a1@@ , @@a2@@ , @@a3@@ ) ; }
int fflush ( FILE * @@stream@@ ) { return fflush ( @@stream@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
_BOOL8 __fastcall target_directory_operand ( char * @@a1@@ ) { bool @@v1@@ ; int @@v2@@ ; int @@v3@@ ; bool @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; bool @@v10@@ ; bool @@v11@@ ; int @@errnum@@ ; char * @@s@@ ; size_t @@v14@@ ; struct stat @@v15@@ ; unsigned __int64 @@v16@@ ; @@v16@@ = __readfsqword ( Number ) ; @@s@@ = ( char * ) last_component ( @@a1@@ ) ; @@v14@@ = strlen ( @@s@@ ) ; @@v1@@ = ! @@v14@@ || @@s@@ [ @@v14@@ - Number ] == Number ; @@v10@@ = @@v1@@ ; if ( dereference_dest_dir_symlinks ) @@v2@@ = stat ( @@a1@@ , & @@v15@@ ) ; else @@v2@@ = lstat ( @@a1@@ , & @@v15@@ ) ; if ( @@v2@@ ) @@v3@@ = * __errno_location ( ) ; else @@v3@@ = Number ; @@errnum@@ = @@v3@@ ; @@v4@@ = ! @@v3@@ && ( @@v15@@ . st_mode & Number ) == Number ; @@v11@@ = @@v4@@ ; if ( @@errnum@@ && @@errnum@@ != Number ) { @@v5@@ = quote ( @@a1@@ ) ; @@v6@@ = gettext ( String ) ; error ( Number , @@errnum@@ , @@v6@@ , @@v5@@ ) ; } if ( ( unsigned __int8 ) @@v11@@ < ( unsigned __int8 ) @@v10@@ ) { @@v7@@ = quote ( @@a1@@ ) ; @@v8@@ = gettext ( String ) ; error ( Number , @@errnum@@ , @@v8@@ , @@v7@@ ) ; } return @@v11@@ ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
int __xstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _xstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
unsigned __int64 __fastcall check_extension ( const char * @@a1@@ , __int64 @@a2@@ , char @@a3@@ ) { unsigned __int64 @@v5@@ ; unsigned __int64 @@v6@@ ; char * @@v7@@ ; unsigned __int64 @@v8@@ ; __int64 @@v9@@ ; __int16 @@v10@@ ; unsigned __int64 @@v11@@ ; @@v11@@ = __readfsqword ( Number ) ; @@v7@@ = ( char * ) last_component ( @@a1@@ ) ; @@v5@@ = base_len ( @@v7@@ ) ; @@v8@@ = Number L ; if ( @@v5@@ > Number ) { @@v10@@ = * ( _WORD * ) @@v7@@ ; * ( _WORD * ) @@v7@@ = Number ; * __errno_location ( ) = Number ; @@v9@@ = pathconf ( @@a1@@ , Number ) ; if ( @@v9@@ >= Number || ! * __errno_location ( ) ) @@v8@@ = @@v9@@ ; * ( _WORD * ) @@v7@@ = @@v10@@ ; } if ( @@v8@@ < @@v5@@ ) { @@v6@@ = & @@a1@@ [ @@a2@@ ] - @@v7@@ ; if ( @@v8@@ <= @@v6@@ ) @@v6@@ = @@v8@@ - Number ; @@v7@@ [ @@v6@@ ] = @@a3@@ ; @@v7@@ [ @@v6@@ + Number ] = Number ; } return __readfsqword ( Number ) ^ @@v11@@ ; }
DIR * fdopendir ( int @@fd@@ ) { return fdopendir ( @@fd@@ ) ; }
int unlink ( const char * @@name@@ ) { return unlink ( @@name@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
int __fastcall rpl_fflush ( FILE * @@a1@@ ) { if ( ! @@a1@@ || ! __freading ( @@a1@@ ) ) return fflush ( @@a1@@ ) ; clear_ungetc_buffer_preserving_position ( @@a1@@ ) ; return fflush ( @@a1@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
int __lxstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _lxstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
DIR * opendir ( const char * @@name@@ ) { return opendir ( @@name@@ ) ; }
int __fastcall rpl_fseeko ( FILE * @@a1@@ , __off_t @@a2@@ , int @@a3@@ ) { __off_t @@v3@@ ; int @@v4@@ ; int @@result@@ ; if ( @@a1@@ -> _IO_read_end != @@a1@@ -> _IO_read_ptr || @@a1@@ -> _IO_write_ptr != @@a1@@ -> _IO_write_base || @@a1@@ -> _IO_save_base ) { goto LABEL_13 ; } if ( @@a3@@ == Number && @@a2@@ > Number ) @@v3@@ = Number L ; else @@v3@@ = @@a2@@ ; @@v4@@ = fileno ( @@a1@@ ) ; if ( lseek ( @@v4@@ , @@v3@@ , @@a3@@ ) == Number ) return Number ; @@a1@@ -> _flags &= Number ; if ( @@a3@@ == Number && @@a2@@ > Number ) LABEL_13 : @@result@@ = fseeko ( @@a1@@ , @@a2@@ , @@a3@@ ) ; else @@result@@ = Number ; return @@result@@ ; }
int dirfd ( DIR * @@dirp@@ ) { return dirfd ( @@dirp@@ ) ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
int closedir ( DIR * @@dirp@@ ) { return closedir ( @@dirp@@ ) ; }
int fileno ( FILE * @@stream@@ ) { return fileno ( @@stream@@ ) ; }
struct dirent * readdir ( DIR * @@dirp@@ ) { return readdir ( @@dirp@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
int __freading ( FILE * @@fp@@ ) { return _freading ( @@fp@@ ) ; }
int rename ( const char * @@old@@ , const char * @@a2@@ ) { return rename ( @@old@@ , @@a2@@ ) ; }
__int64 __fastcall hash_get_first ( unsigned __int64 * @@a1@@ ) { unsigned __int64 @@i@@ ; if ( ! @@a1@@ [ Number ] ) return Number L ; for ( @@i@@ = * @@a1@@ ; ; @@i@@ += Number L ) { if ( @@i@@ >= @@a1@@ [ Number ] ) abort ( ) ; if ( * ( _QWORD * ) @@i@@ ) break ; } return * ( _QWORD * ) @@i@@ ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 __fastcall hash_do_for_each ( __int64 @@a1@@ , unsigned __int8 ( __fastcall * @@a2@@ ) ( _QWORD , __int64 ) , __int64 @@a3@@ ) { __int64 @@v5@@ ; _QWORD * @@i@@ ; _QWORD * @@j@@ ; @@v5@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = @@i@@ ; @@j@@ ; @@j@@ = ( _QWORD * ) @@j@@ [ Number ] ) { if ( @@a2@@ ( * @@j@@ , @@a3@@ ) != Number ) return @@v5@@ ; ++ @@v5@@ ; } } } return @@v5@@ ; }
bool __fastcall seen_file ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 * @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; if ( ! @@a1@@ ) return Number ; @@v4@@ [ Number ] = @@a2@@ ; @@v4@@ [ Number ] = @@a3@@ [ Number ] ; @@v4@@ [ Number ] = * @@a3@@ ; return hash_lookup ( @@a1@@ , @@v4@@ ) != Number ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; FILE * @@v10@@ ; char * @@v11@@ ; FILE * @@v12@@ ; char * @@v13@@ ; FILE * @@v14@@ ; char * @@v15@@ ; FILE * @@v16@@ ; char * @@v17@@ ; FILE * @@v18@@ ; char * @@v19@@ ; FILE * @@v20@@ ; char * @@v21@@ ; FILE * @@v22@@ ; char * @@v23@@ ; char * @@v24@@ ; FILE * @@v25@@ ; char * @@v26@@ ; if ( @@a1@@ ) { @@v1@@ = program_name ; @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = program_name ; @@v4@@ = program_name ; @@v5@@ = program_name ; @@v6@@ = program_name ; @@v7@@ = gettext ( String String String String ) ; printf ( @@v7@@ , @@v6@@ , @@v5@@ , @@v4@@ , @@v3@@ ) ; @@v8@@ = stdout ; @@v9@@ = gettext ( String String String String String String String String ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = stdout ; @@v11@@ = gettext ( String ) ; fputs_unlocked ( @@v11@@ , @@v10@@ ) ; @@v12@@ = stdout ; @@v13@@ = gettext ( String String String String String String ) ; fputs_unlocked ( @@v13@@ , @@v12@@ ) ; @@v14@@ = stdout ; @@v15@@ = gettext ( String String String String String String ) ; fputs_unlocked ( @@v15@@ , @@v14@@ ) ; @@v16@@ = stdout ; @@v17@@ = gettext ( String String String String String ) ; fputs_unlocked ( @@v17@@ , @@v16@@ ) ; @@v18@@ = stdout ; @@v19@@ = gettext ( String ) ; fputs_unlocked ( @@v19@@ , @@v18@@ ) ; @@v20@@ = stdout ; @@v21@@ = gettext ( String ) ; fputs_unlocked ( @@v21@@ , @@v20@@ ) ; @@v22@@ = stdout ; @@v23@@ = gettext ( String String String String String ) ; fputs_unlocked ( @@v23@@ , @@v22@@ ) ; @@v24@@ = gettext ( String String String ) ; printf ( @@v24@@ , & off_A004 ) ; @@v25@@ = stdout ; @@v26@@ = gettext ( String String String String ) ; fputs_unlocked ( @@v26@@ , @@v25@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
void __fastcall record_file ( __int64 @@a1@@ , __int64 @@a2@@ , _QWORD * @@a3@@ ) { _QWORD * @@v4@@ ; __int64 @@v5@@ ; if ( @@a1@@ ) { @@v4@@ = ( _QWORD * ) xmalloc ( Number L ) ; * @@v4@@ = xstrdup ( @@a2@@ ) ; @@v4@@ [ Number ] = @@a3@@ [ Number ] ; @@v4@@ [ Number ] = * @@a3@@ ; @@v5@@ = hash_insert ( @@a1@@ , @@v4@@ ) ; if ( ! @@v5@@ ) xalloc_die ( ) ; if ( ( _QWORD * ) @@v5@@ != @@v4@@ ) triple_free ( @@v4@@ ) ; } }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
unsigned __int64 __fastcall triple_hash ( _QWORD * @@a1@@ , unsigned __int64 @@a2@@ ) { return ( ( unsigned __int64 ) hash_pjw ( * @@a1@@ , @@a2@@ ) ^ @@a1@@ [ Number ] ) % @@a2@@ ; }
void __fastcall hash_free ( __int64 @@a1@@ ) { _QWORD * @@i@@ ; _QWORD * @@j@@ ; _QWORD * @@ptr@@ ; _QWORD * @@ptra@@ ; _QWORD * @@ptrb@@ ; _QWORD * @@v6@@ ; _QWORD * @@v7@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) && * ( _QWORD * ) ( @@a1@@ + Number ) ) { for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@ptr@@ = @@i@@ ; @@ptr@@ ; @@ptr@@ = ( _QWORD * ) @@ptr@@ [ Number ] ) { ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@ptr@@ ) ; } } } } for ( @@j@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@j@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@j@@ += Number ) { for ( @@ptra@@ = ( _QWORD * ) @@j@@ [ Number ] ; @@ptra@@ ; @@ptra@@ = @@v6@@ ) { @@v6@@ = ( _QWORD * ) @@ptra@@ [ Number ] ; free ( @@ptra@@ ) ; } } for ( @@ptrb@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; @@ptrb@@ ; @@ptrb@@ = @@v7@@ ) { @@v7@@ = ( _QWORD * ) @@ptrb@@ [ Number ] ; free ( @@ptrb@@ ) ; } free ( * ( void * * ) @@a1@@ ) ; free ( ( void * ) @@a1@@ ) ; }
void __fastcall triple_free ( void * * @@a1@@ ) { free ( * @@a1@@ ) ; free ( @@a1@@ ) ; }
unsigned __int64 __fastcall triple_hash_no_name ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) % @@a2@@ ; }
__int64 __fastcall get_version ( __int64 @@a1@@ , _BYTE * @@a2@@ ) { __int64 @@result@@ ; if ( @@a2@@ && * @@a2@@ ) @@result@@ = backup_types [ _xargmatch_internal ( @@a1@@ , @@a2@@ , backup_args , backup_types , Number L , argmatch_die ) ] ; else @@result@@ = Number L ; return @@result@@ ; }
_BOOL8 __fastcall triple_compare ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { return @@a1@@ [ Number ] == @@a2@@ [ Number ] && @@a1@@ [ Number ] == @@a2@@ [ Number ] && ( unsigned __int8 ) same_name ( * @@a1@@ , * @@a2@@ ) ; }
_BOOL8 __fastcall triple_compare_ino_str ( __int64 @@a1@@ , __int64 @@a2@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) == * ( _QWORD * ) ( @@a2@@ + Number ) && * ( _QWORD * ) ( @@a1@@ + Number ) == * ( _QWORD * ) ( @@a2@@ + Number ) && ! strcmp ( * ( const char * * ) @@a1@@ , * ( const char * * ) @@a2@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
int __fastcall rpl_linkat ( unsigned int @@a1@@ , char * @@a2@@ , int @@a3@@ , const char * @@a4@@ , int @@a5@@ ) { int @@v6@@ ; int @@v9@@ ; if ( ! @@a5@@ ) return linkat ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , Number ) ; @@v6@@ = @@a5@@ ; BYTE1 ( @@v6@@ ) = BYTE1 ( @@a5@@ ) & Number ; if ( @@v6@@ ) { * __errno_location ( ) = Number ; return Number ; } if ( have_follow_really_4385 >= Number ) { @@v9@@ = linkat ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; if ( @@v9@@ != Number || * __errno_location ( ) != Number ) { have_follow_really_4385 = Number ; return @@v9@@ ; } have_follow_really_4385 = Number ; } return linkat_follow ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__int64 __fastcall file_name_concat ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v4@@ ; @@v4@@ = mfile_name_concat ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( ! @@v4@@ ) xalloc_die ( ) ; return @@v4@@ ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
__int64 __fastcall xget_version ( __int64 @@a1@@ , _BYTE * @@a2@@ ) { char * @@v3@@ ; if ( @@a2@@ && * @@a2@@ ) return get_version ( @@a1@@ , @@a2@@ ) ; @@v3@@ = getenv ( String ) ; return get_version ( ( __int64 ) String , @@v3@@ ) ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
void * __fastcall mfile_name_concat ( _BYTE * @@a1@@ , _BYTE * @@a2@@ , _QWORD * @@a3@@ ) { _BOOL4 @@v3@@ ; const char * @@v6@@ ; size_t @@v7@@ ; size_t @@n@@ ; _BOOL8 @@v9@@ ; char * @@s@@ ; size_t @@v11@@ ; void * @@dest@@ ; _BYTE * @@v13@@ ; char * @@v14@@ ; @@v6@@ = last_component ( @@a1@@ ) ; @@v7@@ = base_len ( @@v6@@ ) ; @@n@@ = @@v6@@ - @@a1@@ + @@v7@@ ; @@v3@@ = @@v7@@ && @@v6@@ [ @@v7@@ - Number ] != Number ; @@v9@@ = @@v3@@ ; @@s@@ = longest_relative_suffix ( @@a2@@ ) ; @@v11@@ = strlen ( @@s@@ ) ; @@dest@@ = malloc ( @@v9@@ + @@n@@ + @@v11@@ + Number ) ; if ( ! @@dest@@ ) return Number L ; @@v13@@ = mempcpy ( @@dest@@ , @@a1@@ , @@n@@ ) ; * @@v13@@ = Number ; @@v14@@ = & @@v13@@ [ @@v9@@ ] ; if ( @@a3@@ ) * @@a3@@ = & @@v14@@ [ - ( * @@a2@@ == Number ) ] ; * ( _BYTE * ) mempcpy ( @@v14@@ , @@s@@ , @@v11@@ ) = Number ; return @@dest@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
void * __fastcall find_backup_file_name ( const char * @@a1@@ , int @@a2@@ ) { int @@v2@@ ; bool @@v4@@ ; void * @@dest@@ ; size_t @@v6@@ ; __int64 @@v7@@ ; size_t @@n@@ ; unsigned __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; @@v10@@ = __readfsqword ( Number ) ; @@v7@@ = strlen ( @@a1@@ ) ; @@v4@@ = Number ; @@n@@ = strlen ( simple_backup_suffix ) + Number ; @@v6@@ = @@n@@ ; if ( @@n@@ <= Number ) @@v6@@ = Number L ; @@v9@@ = @@v7@@ + @@v6@@ + Number ; @@dest@@ = ( void * ) xmalloc ( @@v9@@ ) ; memcpy ( @@dest@@ , @@a1@@ , @@v7@@ + Number ) ; if ( @@a2@@ != Number ) { @@v2@@ = numbered_backup ( ( __int64 * ) & @@dest@@ , @@v9@@ , @@v7@@ ) ; switch ( @@v2@@ ) { case Number : @@v4@@ = Number ; break ; case Number : return @@dest@@ ; case Number : @@v4@@ = @@a2@@ == Number ; break ; } } if ( @@v4@@ ) memcpy ( ( char * ) @@dest@@ + @@v7@@ , simple_backup_suffix , @@n@@ ) ; check_extension ( ( const char * ) @@dest@@ , @@v7@@ , Number ) ; return @@dest@@ ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
__int64 close_stdin ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char @@v4@@ ; char * @@v5@@ ; @@v4@@ = Number ; if ( freadahead ( stdin ) && ! ( unsigned int ) rpl_fseeko ( stdin , Number L , Number L ) && ( unsigned int ) rpl_fflush ( stdin ) ) @@v4@@ = Number ; if ( ( unsigned int ) close_stream ( stdin ) ) @@v4@@ = Number ; if ( @@v4@@ ) { @@v5@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v5@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v5@@ ) ; } } @@result@@ = close_stdout ( ) ; if ( @@v4@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
unsigned __int64 __fastcall hash_get_entries ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; _QWORD * @@i@@ ; _QWORD * @@j@@ ; @@v5@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = @@i@@ ; @@j@@ ; @@j@@ = ( _QWORD * ) @@j@@ [ Number ] ) { if ( @@v5@@ >= @@a3@@ ) return @@v5@@ ; @@v4@@ = @@v5@@ ++ ; * ( _QWORD * ) ( @@a2@@ + Number * @@v4@@ ) = * @@j@@ ; } } } return @@v5@@ ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name_0 ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name_0 ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , off_A6D1 , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
__int64 __fastcall clear_ungetc_buffer_preserving_position ( _DWORD * @@a1@@ ) { __int64 @@result@@ ; @@result@@ = * @@a1@@ & Number ; if ( ( _DWORD ) @@result@@ ) @@result@@ = rpl_fseeko ( @@a1@@ , Number L , Number L ) ; return @@result@@ ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
unsigned __int64 __fastcall hash_get_max_bucket_length ( __int64 @@a1@@ ) { _QWORD * @@i@@ ; unsigned __int64 @@v3@@ ; _QWORD * @@v4@@ ; unsigned __int64 @@j@@ ; @@v3@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { @@v4@@ = @@i@@ ; for ( @@j@@ = Number L ; ; ++ @@j@@ ) { @@v4@@ = ( _QWORD * ) @@v4@@ [ Number ] ; if ( ! @@v4@@ ) break ; } if ( @@j@@ > @@v3@@ ) @@v3@@ = @@j@@ ; } } return @@v3@@ ; }
__int64 __fastcall hash_get_n_entries ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int64 __fastcall hash_clear ( __int64 @@a1@@ ) { __int64 @@result@@ ; _QWORD * @@i@@ ; _QWORD * @@j@@ ; _QWORD * @@v4@@ ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = ( _QWORD * ) @@i@@ [ Number ] ; @@j@@ ; @@j@@ = @@v4@@ ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@j@@ ) ; * @@j@@ = Number L ; @@v4@@ = ( _QWORD * ) @@j@@ [ Number ] ; @@j@@ [ Number ] = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@j@@ ; } if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@i@@ ) ; * @@i@@ = Number L ; @@i@@ [ Number ] = Number L ; } } * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; @@result@@ = @@a1@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; return @@result@@ ; }
_BYTE * __fastcall longest_relative_suffix ( _BYTE * @@a1@@ ) { while ( * @@a1@@ == Number ) ++ @@a1@@ ; return @@a1@@ ; }
_BOOL8 __fastcall hash_table_ok ( __int64 @@a1@@ ) { _QWORD * @@i@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; _QWORD * @@v5@@ ; @@v3@@ = Number L ; @@v4@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { @@v5@@ = @@i@@ ; ++ @@v3@@ ; ++ @@v4@@ ; while ( Number ) { @@v5@@ = ( _QWORD * ) @@v5@@ [ Number ] ; if ( ! @@v5@@ ) break ; ++ @@v4@@ ; } } } return @@v3@@ == * ( _QWORD * ) ( @@a1@@ + Number ) && @@v4@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int64 __fastcall hash_lookup ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; _QWORD * @@i@@ ; _QWORD * @@v5@@ ; @@v2@@ = * @@a1@@ ; @@v5@@ = ( _QWORD * ) ( @@v2@@ + Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) ) ; if ( ( unsigned __int64 ) @@v5@@ >= @@a1@@ [ Number ] ) abort ( ) ; if ( ! * @@v5@@ ) return Number L ; for ( @@i@@ = @@v5@@ ; @@i@@ ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { if ( @@a2@@ == * @@i@@ || ( ( unsigned __int8 ( __fastcall * ) ( __int64 , _QWORD ) ) @@a1@@ [ Number ] ) ( @@a2@@ , * @@i@@ ) ) { return * @@i@@ ; } } return Number L ; }
void * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * @@v4@@ ; void * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * @@v12@@ ; void * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == ( __int64 * ) & slotvec0 ; if ( slotvec == ( __int64 * ) & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = off_20D038 ; * @@v12@@ = ( __int64 ) slotvec0 ; @@v12@@ [ Number ] = ( __int64 ) @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = ( void * ) @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = @@v17@@ + Number ; if ( @@ptr@@ != & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( void * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = ( __int64 ) @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
__int64 __fastcall hash_get_n_buckets ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int64 __fastcall hash_get_next ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; _QWORD * @@v4@@ ; _QWORD * @@i@@ ; @@v2@@ = * @@a1@@ ; @@v4@@ = ( _QWORD * ) ( @@v2@@ + Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) ) ; if ( ( unsigned __int64 ) @@v4@@ >= @@a1@@ [ Number ] ) abort ( ) ; for ( @@i@@ = @@v4@@ ; @@i@@ ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { if ( @@a2@@ == * @@i@@ && @@i@@ [ Number ] ) return * ( _QWORD * ) @@i@@ [ Number ] ; } while ( Number ) { @@v4@@ += Number ; if ( ( unsigned __int64 ) @@v4@@ >= @@a1@@ [ Number ] ) break ; if ( * @@v4@@ ) return * @@v4@@ ; } return Number L ; }
__int64 __fastcall transfer_entries ( __int64 @@a1@@ , __int64 @@a2@@ , char @@a3@@ ) { __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 * @@i@@ ; _QWORD * @@j@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; _QWORD * @@v11@@ ; _QWORD * @@v12@@ ; _QWORD * @@v13@@ ; _QWORD * @@v14@@ ; for ( @@i@@ = * ( __int64 * * ) @@a2@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a2@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = ( _QWORD * ) @@i@@ [ Number ] ; @@j@@ ; @@j@@ = @@v14@@ ) { @@v9@@ = * @@j@@ ; @@v3@@ = * ( _QWORD * ) @@a1@@ ; @@v11@@ = ( _QWORD * ) ( @@v3@@ + Number * ( * ( __int64 ( __fastcall * * ) ( _QWORD , _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@j@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@v11@@ >= * ( _QWORD * ) ( @@a1@@ + Number ) ) abort ( ) ; @@v14@@ = ( _QWORD * ) @@j@@ [ Number ] ; if ( * @@v11@@ ) { @@j@@ [ Number ] = @@v11@@ [ Number ] ; @@v11@@ [ Number ] = @@j@@ ; } else { * @@v11@@ = @@v9@@ ; ++ * ( _QWORD * ) ( @@a1@@ + Number ) ; free_entry ( @@a1@@ , @@j@@ ) ; } } @@v10@@ = * @@i@@ ; @@i@@ [ Number ] = Number L ; if ( ! @@a3@@ ) { @@v4@@ = * ( _QWORD * ) @@a1@@ ; @@v12@@ = ( _QWORD * ) ( @@v4@@ + Number * ( * ( __int64 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@v10@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@v12@@ >= * ( _QWORD * ) ( @@a1@@ + Number ) ) abort ( ) ; if ( * @@v12@@ ) { @@v13@@ = allocate_entry ( @@a1@@ ) ; if ( ! @@v13@@ ) return Number L ; * @@v13@@ = @@v10@@ ; @@v13@@ [ Number ] = @@v12@@ [ Number ] ; @@v12@@ [ Number ] = @@v13@@ ; } else { * @@v12@@ = @@v10@@ ; ++ * ( _QWORD * ) ( @@a1@@ + Number ) ; } * @@i@@ = Number L ; -- * ( _QWORD * ) ( @@a2@@ + Number ) ; } } } return Number L ; }
bool __fastcall is_prime ( unsigned __int64 @@a1@@ ) { unsigned __int64 @@v2@@ ; unsigned __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; @@v2@@ = Number L ; @@v4@@ = Number L ; while ( @@v4@@ < @@a1@@ && @@a1@@ % @@v2@@ ) { @@v3@@ = @@v2@@ + Number ; @@v4@@ += Number * @@v3@@ ; @@v2@@ = @@v3@@ + Number ; } return @@a1@@ % @@v2@@ != Number ; }
__int64 __fastcall next_prime ( unsigned __int64 @@a1@@ ) { __int64 @@v2@@ ; __int64 @@i@@ ; @@v2@@ = @@a1@@ ; if ( @@a1@@ <= Number ) @@v2@@ = Number L ; for ( @@i@@ = @@v2@@ | Number ; @@i@@ != Number && ! is_prime ( @@i@@ ) ; @@i@@ += Number L ) { ; } return @@i@@ ; }
__int64 __fastcall hash_get_n_buckets_used ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int64 __fastcall _xargmatch_internal ( __int64 @@a1@@ , const char * @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ , void ( * @@a6@@ ) ( void ) ) { __int64 @@v11@@ ; @@v11@@ = argmatch ( @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; if ( @@v11@@ >= Number ) return @@v11@@ ; argmatch_invalid ( @@a1@@ , ( __int64 ) @@a2@@ , @@v11@@ ) ; argmatch_valid ( @@a3@@ , @@a4@@ , @@a5@@ ) ; @@a6@@ ( ) ; return Number ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
unsigned __int64 __fastcall compute_bucket_size ( __int64 @@a1@@ , __int64 @@a2@@ ) { float @@v2@@ ; unsigned __int64 @@result@@ ; unsigned __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; float @@v6@@ ; @@v4@@ = @@a1@@ ; if ( * ( _BYTE * ) ( @@a2@@ + Number ) != Number ) { if ( @@a1@@ < Number ) @@v2@@ = ( float ) ( @@a1@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@a1@@ >> Number ) ) + ( float ) ( @@a1@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@a1@@ >> Number ) ) ; else @@v2@@ = ( float ) ( int ) @@a1@@ ; @@v6@@ = @@v2@@ / * ( float * ) ( @@a2@@ + Number ) ; if ( @@v6@@ >= Number ) return Number L ; if ( @@v6@@ >= Number ) @@v4@@ = ( unsigned int ) ( int ) ( float ) ( @@v6@@ - Number ) ^ Number ; else @@v4@@ = ( unsigned int ) ( int ) @@v6@@ ; } @@v5@@ = next_prime ( @@v4@@ ) ; if ( @@v5@@ <= Number ) @@result@@ = @@v5@@ ; else @@result@@ = Number L ; return @@result@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
int __fastcall hash_print_statistics ( __int64 @@a1@@ , FILE * @@a2@@ ) { double @@v2@@ ; double @@v3@@ ; double @@v4@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v6@@ = hash_get_n_entries ( @@a1@@ ) ; @@v7@@ = hash_get_n_buckets ( @@a1@@ ) ; @@v8@@ = hash_get_n_buckets_used ( @@a1@@ ) ; @@v9@@ = hash_get_max_bucket_length ( @@a1@@ ) ; fprintf ( @@a2@@ , String , @@v6@@ ) ; fprintf ( @@a2@@ , String , @@v7@@ ) ; if ( @@v8@@ < Number ) @@v2@@ = ( double ) ( int ) ( @@v8@@ & Number | ( ( unsigned __int64 ) @@v8@@ >> Number ) ) + ( double ) ( int ) ( @@v8@@ & Number | ( ( unsigned __int64 ) @@v8@@ >> Number ) ) ; else @@v2@@ = ( double ) ( int ) @@v8@@ ; @@v3@@ = Number * @@v2@@ ; if ( @@v7@@ < Number ) @@v4@@ = ( double ) ( int ) ( @@v7@@ & Number | ( ( unsigned __int64 ) @@v7@@ >> Number ) ) + ( double ) ( int ) ( @@v7@@ & Number | ( ( unsigned __int64 ) @@v7@@ >> Number ) ) ; else @@v4@@ = ( double ) ( int ) @@v7@@ ; fprintf ( @@a2@@ , String , @@v8@@ , @@v3@@ / @@v4@@ ) ; return fprintf ( @@a2@@ , String , @@v9@@ ) ; }
size_t * __fastcall hash_initialize ( __int64 @@a1@@ , void * @@a2@@ , unsigned __int64 ( __fastcall * @@a3@@ ) ( __int64 a1 , unsigned __int64 a2 ) , bool ( __fastcall * @@a4@@ ) ( __int64 a1 , __int64 a2 ) , size_t @@a5@@ ) { size_t * @@result@@ ; bool ( __fastcall * @@v7@@ ) ( __int64 , __int64 ) ; unsigned __int64 ( __fastcall * @@v8@@ ) ( __int64 , unsigned __int64 ) ; void * @@v9@@ ; size_t * @@ptr@@ ; @@v9@@ = @@a2@@ ; @@v8@@ = @@a3@@ ; @@v7@@ = @@a4@@ ; if ( ! @@a3@@ ) @@v8@@ = raw_hasher ; if ( ! @@a4@@ ) @@v7@@ = raw_comparator ; @@ptr@@ = ( size_t * ) malloc ( Number ) ; if ( ! @@ptr@@ ) return Number L ; if ( ! @@a2@@ ) @@v9@@ = & default_tuning ; @@ptr@@ [ Number ] = ( size_t ) @@v9@@ ; if ( ( unsigned __int8 ) check_tuning ( ( __int64 ) @@ptr@@ ) == Number && ( @@ptr@@ [ Number ] = compute_bucket_size ( @@a1@@ , ( __int64 ) @@v9@@ ) ) != Number && ( * @@ptr@@ = ( size_t ) calloc ( @@ptr@@ [ Number ] , Number ) ) != Number ) { @@ptr@@ [ Number ] = Number * @@ptr@@ [ Number ] + * @@ptr@@ ; @@ptr@@ [ Number ] = Number L ; @@ptr@@ [ Number ] = Number L ; @@ptr@@ [ Number ] = ( size_t ) @@v8@@ ; @@ptr@@ [ Number ] = ( size_t ) @@v7@@ ; @@ptr@@ [ Number ] = @@a5@@ ; @@ptr@@ [ Number ] = Number L ; @@result@@ = @@ptr@@ ; } else { free ( @@ptr@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
unsigned __int64 __fastcall hash_string ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ ) { unsigned __int64 @@v4@@ ; @@v4@@ = Number L ; while ( * @@a1@@ ) @@v4@@ = ( Number * @@v4@@ + ( unsigned __int8 ) * @@a1@@ ++ ) % @@a2@@ ; return @@v4@@ ; }
__int64 __fastcall free_entry ( __int64 @@a1@@ , _QWORD * @@a2@@ ) { __int64 @@result@@ ; * @@a2@@ = Number L ; @@a2@@ [ Number ] = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@result@@ = @@a1@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
void * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
unsigned __int64 __fastcall raw_hasher ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return rotr_sz ( @@a1@@ , Number ) % @@a2@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
_BOOL8 __fastcall strip_trailing_slashes ( char * @@a1@@ ) { char @@v1@@ ; const char * @@v3@@ ; const char * @@v4@@ ; @@v3@@ = last_component ( @@a1@@ ) ; if ( ! * @@v3@@ ) @@v3@@ = @@a1@@ ; @@v4@@ = & @@v3@@ [ base_len ( @@v3@@ ) ] ; @@v1@@ = * @@v4@@ ; * @@v4@@ = Number ; return @@v1@@ != Number ; }
__int64 __fastcall hash_rehash ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; unsigned __int64 @@nmemb@@ ; void * @@v4@@ ; __int64 @@v5@@ ; unsigned __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; __int64 @@v12@@ ; __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; @@v14@@ = __readfsqword ( Number ) ; @@nmemb@@ = compute_bucket_size ( @@a2@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ; if ( ! @@nmemb@@ ) return Number L ; if ( @@nmemb@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; @@v4@@ = calloc ( @@nmemb@@ , Number ) ; if ( ! @@v4@@ ) return Number L ; @@v6@@ = @@nmemb@@ ; @@v5@@ = ( __int64 ) @@v4@@ + Number * @@nmemb@@ ; @@v7@@ = Number L ; @@v8@@ = Number L ; @@v9@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v10@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v11@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v12@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v13@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( ( unsigned __int8 ) transfer_entries ( ( __int64 ) & @@v4@@ , @@a1@@ , Number ) ) { free ( * ( void * * ) @@a1@@ ) ; * ( _QWORD * ) @@a1@@ = @@v4@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v5@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v6@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v7@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v13@@ ; @@result@@ = Number L ; } else { * ( _QWORD * ) ( @@a1@@ + Number ) = @@v13@@ ; if ( ( unsigned __int8 ) transfer_entries ( @@a1@@ , ( __int64 ) & @@v4@@ , Number ) != Number || ( unsigned __int8 ) transfer_entries ( @@a1@@ , ( __int64 ) & @@v4@@ , Number ) != Number ) { abort ( ) ; } free ( @@v4@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@v2@@ ; @@v2@@ = malloc ( @@a1@@ ) ; if ( ! @@v2@@ && @@a1@@ ) xalloc_die ( ) ; return @@v2@@ ; }
__int64 __fastcall hash_find_entry ( __int64 @@a1@@ , __int64 @@a2@@ , _QWORD * @@a3@@ , char @@a4@@ ) { __int64 @@v4@@ ; __int64 @@result@@ ; __int64 @@v6@@ ; _QWORD * @@i@@ ; _QWORD * @@v10@@ ; __int64 @@v11@@ ; _QWORD * @@v12@@ ; __int64 @@v13@@ ; _QWORD * @@v14@@ ; @@v4@@ = * ( _QWORD * ) @@a1@@ ; @@v10@@ = ( _QWORD * ) ( @@v4@@ + Number * ( * ( __int64 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@a2@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@v10@@ >= * ( _QWORD * ) ( @@a1@@ + Number ) ) abort ( ) ; * @@a3@@ = @@v10@@ ; if ( ! * @@v10@@ ) return Number L ; if ( @@a2@@ == * @@v10@@ || ( * ( unsigned __int8 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@a2@@ , * @@v10@@ ) ) { @@v13@@ = * @@v10@@ ; if ( @@a4@@ ) { if ( @@v10@@ [ Number ] ) { @@v14@@ = ( _QWORD * ) @@v10@@ [ Number ] ; @@v6@@ = @@v14@@ [ Number ] ; * @@v10@@ = * @@v14@@ ; @@v10@@ [ Number ] = @@v6@@ ; free_entry ( @@a1@@ , @@v14@@ ) ; } else { * @@v10@@ = Number L ; } } @@result@@ = @@v13@@ ; } else { for ( @@i@@ = @@v10@@ ; ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { if ( ! @@i@@ [ Number ] ) return Number L ; if ( @@a2@@ == * ( _QWORD * ) @@i@@ [ Number ] || ( * ( unsigned __int8 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@a2@@ , * ( _QWORD * ) @@i@@ [ Number ] ) ) { break ; } } @@v11@@ = * ( _QWORD * ) @@i@@ [ Number ] ; if ( @@a4@@ ) { @@v12@@ = ( _QWORD * ) @@i@@ [ Number ] ; @@i@@ [ Number ] = @@v12@@ [ Number ] ; free_entry ( @@a1@@ , @@v12@@ ) ; } @@result@@ = @@v11@@ ; } return @@result@@ ; }
__int64 __fastcall check_tuning ( __int64 @@a1@@ ) { __int64 @@v2@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( ( _UNKNOWN * ) @@v2@@ == & default_tuning ) return Number L ; if ( * ( float * ) ( @@v2@@ + Number ) > Number && ( float ) ( Number - Number ) > * ( float * ) ( @@v2@@ + Number ) && * ( float * ) ( @@v2@@ + Number ) > ( float ) ( Number + Number ) && * ( float * ) @@v2@@ >= Number && * ( float * ) ( @@v2@@ + Number ) > ( float ) ( * ( float * ) @@v2@@ + Number ) && * ( float * ) ( @@v2@@ + Number ) <= Number && * ( float * ) ( @@v2@@ + Number ) > ( float ) ( * ( float * ) @@v2@@ + Number ) ) { return Number L ; } * ( _QWORD * ) ( @@a1@@ + Number ) = & default_tuning ; return Number L ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
void * __fastcall xzalloc ( size_t @@a1@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@a1@@ ) ; return memset ( @@v1@@ , Number , @@a1@@ ) ; }
__int64 __fastcall paste_serial ( __int64 @@a1@@ , const char * * @@a2@@ ) { int @@v2@@ ; const char * @@v3@@ ; int * @@v4@@ ; unsigned __int8 @@v8@@ ; bool @@v9@@ ; int @@v10@@ ; int @@errnum@@ ; int @@v12@@ ; char * @@v13@@ ; FILE * @@stream@@ ; @@v8@@ = Number ; while ( @@a1@@ ) { @@v2@@ = strcmp ( * @@a2@@ , String ) ; @@v9@@ = @@v2@@ == Number ; if ( @@v2@@ ) { @@stream@@ = fopen ( * @@a2@@ , String ) ; if ( ! @@stream@@ ) goto LABEL_23 ; } else { have_read_stdin = Number ; @@stream@@ = stdin ; } @@v13@@ = ( char * ) delims ; @@v10@@ = getc_unlocked ( @@stream@@ ) ; @@errnum@@ = * __errno_location ( ) ; if ( @@v10@@ != Number ) { while ( Number ) { @@v12@@ = getc_unlocked ( @@stream@@ ) ; if ( @@v12@@ == Number ) break ; if ( @@v10@@ == Number ) { if ( * @@v13@@ ) xputchar ( * @@v13@@ ) ; if ( ++ @@v13@@ == ( char * ) delim_end ) @@v13@@ = ( char * ) delims ; } else { xputchar ( @@v10@@ ) ; } @@v10@@ = @@v12@@ ; } @@errnum@@ = * __errno_location ( ) ; xputchar ( @@v10@@ ) ; } if ( @@v10@@ != Number ) xputchar ( Number ) ; if ( ferror_unlocked ( @@stream@@ ) ) { error ( Number , @@errnum@@ , String , * @@a2@@ ) ; @@v8@@ = Number ; } if ( @@v9@@ ) { clearerr_unlocked ( @@stream@@ ) ; goto LABEL_24 ; } if ( fclose ( @@stream@@ ) == Number ) { LABEL_23 : @@v3@@ = * @@a2@@ ; @@v4@@ = __errno_location ( ) ; error ( Number , * @@v4@@ , String , @@v3@@ ) ; @@v8@@ = Number ; } LABEL_24 : -- @@a1@@ ; ++ @@a2@@ ; } return @@v8@@ ; }
DIR * __fastcall opendir_safer ( const char * @@a1@@ ) { int @@v2@@ ; int @@fd@@ ; int @@v4@@ ; DIR * @@dirp@@ ; DIR * @@v6@@ ; @@dirp@@ = opendir ( @@a1@@ ) ; if ( @@dirp@@ ) { @@v2@@ = dirfd ( @@dirp@@ ) ; if ( @@v2@@ >= Number && @@v2@@ <= Number ) { @@fd@@ = dup_safer ( ( unsigned int ) @@v2@@ ) ; @@v6@@ = fdopendir ( @@fd@@ ) ; @@v4@@ = * __errno_location ( ) ; if ( ! @@v6@@ ) close ( @@fd@@ ) ; closedir ( @@dirp@@ ) ; * __errno_location ( ) = @@v4@@ ; @@dirp@@ = @@v6@@ ; } } return @@dirp@@ ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
void * __fastcall allocate_entry ( __int64 @@a1@@ ) { __int64 @@v2@@ ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return malloc ( Number ) ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = * ( _QWORD * ) ( @@v2@@ + Number ) ; return ( void * ) @@v2@@ ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
__int64 __fastcall linkat_follow ( unsigned int @@a1@@ , void * @@a2@@ , int @@a3@@ , const char * @@a4@@ ) { __int64 @@result@@ ; int @@v8@@ ; int @@v9@@ ; unsigned int @@v10@@ ; int @@v11@@ ; void * @@ptr@@ ; _BYTE * @@v13@@ ; _BYTE * @@v14@@ ; @@ptr@@ = @@a2@@ ; @@v8@@ = Number ; while ( @@v8@@ -- ) { @@v13@@ = ( _BYTE * ) areadlinkat ( @@a1@@ , @@ptr@@ ) ; if ( ! @@v13@@ ) break ; if ( * @@v13@@ == Number ) { if ( @@ptr@@ != @@a2@@ ) free ( @@ptr@@ ) ; @@ptr@@ = @@v13@@ ; } else { @@v14@@ = ( _BYTE * ) mdir_name ( @@ptr@@ ) ; if ( @@ptr@@ != @@a2@@ ) free ( @@ptr@@ ) ; if ( ! @@v14@@ ) { free ( @@v13@@ ) ; * __errno_location ( ) = Number ; return Number ; } @@ptr@@ = mfile_name_concat ( @@v14@@ , @@v13@@ , Number L ) ; free ( @@v14@@ ) ; free ( @@v13@@ ) ; if ( ! @@ptr@@ ) { * __errno_location ( ) = Number ; return Number ; } } } if ( @@v8@@ < Number ) { @@v13@@ = Number L ; * __errno_location ( ) = Number ; } if ( @@v13@@ || * __errno_location ( ) == Number ) { @@v10@@ = linkat ( @@a1@@ , ( const char * ) @@ptr@@ , @@a3@@ , @@a4@@ , Number ) ; if ( @@ptr@@ != @@a2@@ ) { @@v11@@ = * __errno_location ( ) ; free ( @@ptr@@ ) ; * __errno_location ( ) = @@v11@@ ; } @@result@@ = @@v10@@ ; } else { if ( @@ptr@@ != @@a2@@ ) { @@v9@@ = * __errno_location ( ) ; free ( @@ptr@@ ) ; * __errno_location ( ) = @@v9@@ ; } @@result@@ = Number ; } return @@result@@ ; }
__int64 __fastcall freadahead ( __int64 @@a1@@ ) { __int64 @@v2@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) > * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; if ( ( * ( _DWORD * ) @@a1@@ & Number ) != Number ) @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) - * ( _QWORD * ) ( @@a1@@ + Number ) ; else @@v2@@ = Number L ; return * ( _QWORD * ) ( @@a1@@ + Number ) - * ( _QWORD * ) ( @@a1@@ + Number ) + @@v2@@ ; }
void * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
void __fastcall argmatch_invalid ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { char * @@v3@@ ; __int64 @@v4@@ ; void * @@v5@@ ; char * @@format@@ ; if ( @@a3@@ == Number ) @@v3@@ = gettext ( String ) ; else @@v3@@ = gettext ( String ) ; @@format@@ = @@v3@@ ; @@v4@@ = quote_n ( Number , @@a1@@ ) ; @@v5@@ = quotearg_n_style ( Number , Number , @@a2@@ ) ; error ( Number , Number , @@format@@ , @@v5@@ , @@v4@@ ) ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_20D038 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = ( __int64 * ) & slotvec0 ; } nslots = Number ; return @@result@@ ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
void * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall argmatch_to_argument ( const void * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; ++ @@i@@ ) { if ( ! memcmp ( @@a1@@ , ( const void * ) ( @@i@@ * @@a4@@ + @@a3@@ ) , @@a4@@ ) ) return * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; } return Number L ; }
void * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
void * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_20D108 ; @@v4@@ [ Number ] = qword_20D110 ; @@v4@@ [ Number ] = qword_20D118 ; @@v4@@ [ Number ] = qword_20D120 ; @@v4@@ [ Number ] = qword_20D128 ; @@v4@@ [ Number ] = qword_20D130 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
__int64 __fastcall dir_name ( __int64 @@a1@@ ) { __int64 @@v2@@ ; @@v2@@ = mdir_name ( @@a1@@ ) ; if ( ! @@v2@@ ) xalloc_die ( ) ; return @@v2@@ ; }
void * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
void * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
__int64 __fastcall xnrealloc ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { if ( ! is_mul_ok ( @@a3@@ , @@a2@@ ) ) xalloc_die ( ) ; return xrealloc ( @@a1@@ , @@a3@@ * @@a2@@ ) ; }
__int64 __fastcall dup_safer ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
void * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_2070C8 ; @@v4@@ [ Number ] = qword_2070D0 ; @@v4@@ [ Number ] = qword_2070D8 ; @@v4@@ [ Number ] = qword_2070E0 ; @@v4@@ [ Number ] = qword_2070E8 ; @@v4@@ [ Number ] = qword_2070F0 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v4@@ ; @@v4@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v4@@ >= Number / @@a3@@ ) xalloc_die ( ) ; @@v4@@ += ( @@v4@@ + Number ) >> Number ; } else if ( ! @@v4@@ ) { @@v4@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v4@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v4@@ ) ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
void * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall rpl_fcntl ( int @@a1@@ , int @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , __m128 @@a7@@ , __m128 @@a8@@ , __m128 @@a9@@ , __m128 @@a10@@ , __m128 @@a11@@ , __m128 @@a12@@ , __m128 @@a13@@ , __m128 @@a14@@ ) { int @@v14@@ ; int @@v15@@ ; int @@v16@@ ; int @@v18@@ ; int @@v19@@ ; int @@v20@@ ; int @@v21@@ ; __int64 @@v22@@ ; __int64 @@v23@@ ; __int64 @@v24@@ ; __int64 @@v25@@ ; __m128 @@v26@@ ; __m128 @@v27@@ ; __m128 @@v28@@ ; __m128 @@v29@@ ; __m128 @@v30@@ ; __m128 @@v31@@ ; __m128 @@v32@@ ; __m128 @@v33@@ ; @@v22@@ = @@a3@@ ; @@v23@@ = @@a4@@ ; @@v24@@ = @@a5@@ ; @@v25@@ = @@a6@@ ; @@v26@@ = @@a7@@ ; @@v27@@ = @@a8@@ ; @@v28@@ = @@a9@@ ; @@v29@@ = @@a10@@ ; @@v30@@ = @@a11@@ ; @@v31@@ = @@a12@@ ; @@v32@@ = @@a13@@ ; @@v33@@ = @@a14@@ ; if ( @@a2@@ != Number ) return ( unsigned int ) fcntl ( @@a1@@ , @@a2@@ , @@v22@@ ) ; @@v19@@ = @@v22@@ ; if ( have_dupfd_cloexec_2895 < Number ) { @@v18@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v22@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; } else { @@v18@@ = fcntl ( @@a1@@ , Number , ( unsigned int ) @@v22@@ ) ; if ( @@v18@@ < Number && * __errno_location ( ) == Number ) { @@v18@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v19@@ , @@v14@@ , @@v15@@ , @@v16@@ ) ; if ( @@v18@@ < Number ) return ( unsigned int ) @@v18@@ ; have_dupfd_cloexec_2895 = Number ; } else { have_dupfd_cloexec_2895 = Number ; } } if ( @@v18@@ >= Number && have_dupfd_cloexec_2895 == Number ) { @@v20@@ = fcntl ( @@v18@@ , Number ) ; if ( @@v20@@ < Number || fcntl ( @@v18@@ , Number , @@v20@@ | Number ) == Number ) { @@v21@@ = * __errno_location ( ) ; close ( @@v18@@ ) ; * __errno_location ( ) = @@v21@@ ; @@v18@@ = Number ; } } return ( unsigned int ) @@v18@@ ; }
_BOOL8 yesno ( ) { bool @@v1@@ ; char * @@lineptr@@ ; size_t @@n@@ ; __ssize_t @@v4@@ ; unsigned __int64 @@v5@@ ; @@v5@@ = __readfsqword ( Number ) ; @@lineptr@@ = Number L ; @@n@@ = Number L ; @@v4@@ = getline ( & @@lineptr@@ , & @@n@@ , stdin ) ; if ( @@v4@@ > Number ) { @@lineptr@@ [ @@v4@@ - Number ] = Number ; @@v1@@ = rpmatch ( @@lineptr@@ ) > Number ; } else { @@v1@@ = Number ; } free ( @@lineptr@@ ) ; return @@v1@@ ; }
_BOOL8 __fastcall same_name ( _BYTE * @@a1@@ , _BYTE * @@a2@@ ) { bool @@v2@@ ; int * @@v3@@ ; int * @@v4@@ ; bool @@v5@@ ; bool @@v7@@ ; const char * @@s1@@ ; const char * @@s2@@ ; size_t @@v10@@ ; size_t @@n@@ ; char * @@ptr@@ ; char * @@filename@@ ; struct stat @@v14@@ ; struct stat @@v15@@ ; unsigned __int64 @@v16@@ ; @@v16@@ = __readfsqword ( Number ) ; @@s1@@ = last_component ( @@a1@@ ) ; @@s2@@ = last_component ( @@a2@@ ) ; @@v10@@ = base_len ( @@s1@@ ) ; @@n@@ = base_len ( @@s2@@ ) ; @@v2@@ = @@v10@@ == @@n@@ && ! memcmp ( @@s1@@ , @@s2@@ , @@n@@ ) ; @@v7@@ = Number ; if ( @@v2@@ ) { @@ptr@@ = ( char * ) dir_name ( @@a1@@ ) ; @@filename@@ = ( char * ) dir_name ( @@a2@@ ) ; if ( ( unsigned int ) stat ( @@ptr@@ , & @@v14@@ ) ) { @@v3@@ = __errno_location ( ) ; error ( Number , * @@v3@@ , String , @@ptr@@ ) ; } if ( ( unsigned int ) stat ( @@filename@@ , & @@v15@@ ) ) { @@v4@@ = __errno_location ( ) ; error ( Number , * @@v4@@ , String , @@filename@@ ) ; } @@v5@@ = @@v14@@ . st_ino == @@v15@@ . st_ino && @@v14@@ . st_dev == @@v15@@ . st_dev ; @@v7@@ = @@v5@@ ; free ( @@ptr@@ ) ; free ( @@filename@@ ) ; } return @@v7@@ ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
void * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
unsigned __int64 __fastcall hash_pjw ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ ) { unsigned __int64 @@v4@@ ; @@v4@@ = Number L ; while ( * @@a1@@ ) @@v4@@ = __ROL8__ ( @@v4@@ , Number ) + ( char ) * @@a1@@ ++ ; return @@v4@@ % @@a2@@ ; }
__int64 __fastcall argmatch ( const char * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { __int64 @@result@@ ; char @@v7@@ ; __int64 @@i@@ ; __int64 @@v9@@ ; size_t @@n@@ ; @@v9@@ = Number ; @@v7@@ = Number ; @@n@@ = strlen ( @@a1@@ ) ; for ( @@i@@ = Number L ; * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; ++ @@i@@ ) { if ( ! strncmp ( * ( const char * * ) ( Number * @@i@@ + @@a2@@ ) , @@a1@@ , @@n@@ ) ) { if ( @@n@@ == strlen ( * ( const char * * ) ( Number * @@i@@ + @@a2@@ ) ) ) return @@i@@ ; if ( @@v9@@ == Number ) { @@v9@@ = @@i@@ ; } else if ( ! @@a3@@ || memcmp ( ( const void * ) ( @@a4@@ * @@v9@@ + @@a3@@ ) , ( const void * ) ( @@i@@ * @@a4@@ + @@a3@@ ) , @@a4@@ ) ) { @@v7@@ = Number ; } } } if ( @@v7@@ ) @@result@@ = Number ; else @@result@@ = @@v9@@ ; return @@result@@ ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
void * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_20D108 ; @@v8@@ [ Number ] = qword_20D110 ; @@v8@@ [ Number ] = qword_20D118 ; @@v8@@ [ Number ] = qword_20D120 ; @@v8@@ [ Number ] = qword_20D128 ; @@v8@@ [ Number ] = qword_20D130 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
void * __fastcall mdir_name ( _BYTE * @@a1@@ ) { _BYTE * @@n@@ ; void * @@dest@@ ; @@n@@ = dir_len ( @@a1@@ ) ; @@dest@@ = malloc ( ( size_t ) & @@n@@ [ ( @@n@@ == Number L ) + Number ] ) ; if ( ! @@dest@@ ) return Number L ; memcpy ( @@dest@@ , @@a1@@ , ( size_t ) @@n@@ ) ; if ( ! @@n@@ ) { @@n@@ = ( _BYTE * ) ( & dword_0 + Number ) ; * ( _BYTE * ) @@dest@@ = Number ; } @@n@@ [ ( _QWORD ) @@dest@@ ] = Number ; return @@dest@@ ; }
int __fastcall argmatch_valid ( __int64 @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { char * @@v3@@ ; __int64 @@i@@ ; void * @@s1@@ ; @@s1@@ = Number L ; @@v3@@ = gettext ( String ) ; fprintf ( stderr , @@v3@@ ) ; for ( @@i@@ = Number L ; * ( _QWORD * ) ( Number * @@i@@ + @@a1@@ ) ; ++ @@i@@ ) { if ( @@i@@ && ! memcmp ( @@s1@@ , ( const void * ) ( @@i@@ * @@a3@@ + @@a2@@ ) , @@a3@@ ) ) { fprintf ( stderr , String , * ( const char * * ) ( Number * @@i@@ + @@a1@@ ) ) ; } else { fprintf ( stderr , String , * ( const char * * ) ( Number * @@i@@ + @@a1@@ ) ) ; @@s1@@ = ( void * ) ( @@i@@ * @@a3@@ + @@a2@@ ) ; } } return putc_unlocked ( Number , stderr ) ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ ) { return xmalloc ( @@a1@@ ) ; }
_BYTE * __fastcall dir_len ( _BYTE * @@a1@@ ) { _BYTE * @@i@@ ; unsigned __int64 @@v3@@ ; @@v3@@ = * @@a1@@ == Number ; for ( @@i@@ = ( _BYTE * ) ( last_component ( @@a1@@ ) - @@a1@@ ) ; @@v3@@ < ( unsigned __int64 ) @@i@@ && @@a1@@ [ ( _QWORD ) ( @@i@@ - Number ) ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
unsigned __int64 __fastcall do_decode ( FILE * @@a1@@ , FILE * @@a2@@ , char @@a3@@ ) { char * @@v3@@ ; int * @@v4@@ ; unsigned __int64 @@v5@@ ; size_t @@v6@@ ; char * @@v7@@ ; int * @@v8@@ ; char * @@v9@@ ; unsigned int @@v10@@ ; char @@v13@@ ; unsigned int @@i@@ ; size_t @@n@@ ; unsigned __int64 @@v16@@ ; size_t @@v17@@ ; int @@v18@@ ; char @@ptr@@ [ Number ] ; char @@v20@@ [ Number ] ; unsigned __int64 @@v21@@ ; @@v21@@ = __readfsqword ( Number ) ; base64_decode_ctx_init ( & @@v18@@ ) ; do { @@v16@@ = Number L ; do { @@n@@ = fread_unlocked ( & @@v20@@ [ @@v16@@ ] , Number , Number - @@v16@@ , @@a1@@ ) ; if ( @@a3@@ ) { @@v17@@ = Number L ; while ( @@n@@ && @@v17@@ < @@n@@ ) { if ( ( unsigned __int8 ) isbase64 ( ( unsigned int ) @@v20@@ [ @@v16@@ + @@v17@@ ] ) || @@v20@@ [ @@v16@@ + @@v17@@ ] == Number ) { ++ @@v17@@ ; } else { memmove ( & @@v20@@ [ @@v17@@ + @@v16@@ ] , & @@v20@@ [ @@v16@@ + Number + @@v17@@ ] , -- @@n@@ - @@v17@@ ) ; } } } @@v16@@ += @@n@@ ; if ( ferror_unlocked ( @@a1@@ ) ) { @@v3@@ = gettext ( String ) ; @@v4@@ = __errno_location ( ) ; error ( Number , * @@v4@@ , @@v3@@ ) ; } } while ( @@v16@@ <= Number && ! feof_unlocked ( @@a1@@ ) ) ; for ( @@i@@ = Number ; ; ++ @@i@@ ) { @@v10@@ = feof_unlocked ( @@a1@@ ) ? Number : Number ; if ( @@v10@@ <= @@i@@ || @@i@@ == Number && ! @@v18@@ ) { break ; } @@n@@ = Number L ; if ( @@i@@ ) @@v5@@ = Number L ; else @@v5@@ = @@v16@@ ; @@v13@@ = base64_decode_ctx ( & @@v18@@ , @@v20@@ , @@v5@@ , @@ptr@@ , & @@n@@ ) ; @@v6@@ = fwrite_unlocked ( @@ptr@@ , Number , @@n@@ , @@a2@@ ) ; if ( @@v6@@ < @@n@@ ) { @@v7@@ = gettext ( String ) ; @@v8@@ = __errno_location ( ) ; error ( Number , * @@v8@@ , @@v7@@ ) ; } if ( @@v13@@ != Number ) { @@v9@@ = gettext ( String ) ; error ( Number , Number , @@v9@@ ) ; } } } while ( ! feof_unlocked ( @@a1@@ ) ) ; return __readfsqword ( Number ) ^ @@v21@@ ; }
int __fastcall lstat ( char * @@filename@@ , struct stat * @@stat_buf@@ ) { return __lxstat ( Number , @@filename@@ , @@stat_buf@@ ) ; }
int getc_unlocked ( FILE * @@stream@@ ) { return getc_unlocked ( @@stream@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( ) ; return @@ptr@@ ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
__int64 __fastcall base64_decode_alloc_ctx ( int * @@a1@@ , char * @@a2@@ , unsigned __int64 @@a3@@ , void * * @@a4@@ , _QWORD * @@a5@@ ) { __int64 @@result@@ ; size_t @@size@@ [ Number ] ; @@size@@ [ Number ] = __readfsqword ( Number ) ; @@size@@ [ Number ] = Number * ( @@a3@@ >> Number ) + Number ; * @@a4@@ = malloc ( @@size@@ [ Number ] ) ; if ( ! * @@a4@@ ) return Number L ; if ( ! base64_decode_ctx ( @@a1@@ , @@a2@@ , @@a3@@ , ( __int64 ) * @@a4@@ , ( __int64 * ) @@size@@ ) ) { free ( * @@a4@@ ) ; * @@a4@@ = Number L ; @@result@@ = Number L ; } else { if ( @@a5@@ ) * @@a5@@ = @@size@@ [ Number ] ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@v3@@ ; @@v3@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v3@@ ) xalloc_die ( ) ; return @@v3@@ ; }
int putchar_unlocked ( int @@c@@ ) { return putchar_unlocked ( @@c@@ ) ; }
void clearerr_unlocked ( FILE * @@stream@@ ) { clearerr_unlocked ( @@stream@@ ) ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( is_mul_ok ( @@a2@@ , * @@a1@@ ) ) { * @@a1@@ *= @@a2@@ ; @@result@@ = Number L ; } else { * @@a1@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_207028 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
__int64 __fastcall bad_cast ( __int64 @@a1@@ ) { return @@a1@@ ; }
int fileno ( FILE * @@stream@@ ) { return fileno ( @@stream@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
char * __fastcall areadlinkat ( int @@a1@@ , const char * @@a2@@ ) { signed __int64 @@v3@@ ; int @@v4@@ ; char * @@buf@@ ; __int64 @@len@@ ; signed __int64 @@size@@ ; size_t @@sizea@@ ; char * @@v9@@ ; char @@src@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v11@@ = __readfsqword ( Number ) ; @@buf@@ = @@src@@ ; @@len@@ = Number L ; while ( Number ) { @@size@@ = readlinkat ( @@a1@@ , @@a2@@ , @@buf@@ , @@len@@ ) ; if ( @@size@@ < Number && * __errno_location ( ) != Number ) { if ( @@buf@@ != @@src@@ ) { @@v4@@ = * __errno_location ( ) ; free ( @@buf@@ ) ; * __errno_location ( ) = @@v4@@ ; } return Number L ; } if ( @@len@@ > ( unsigned __int64 ) @@size@@ ) break ; if ( @@buf@@ != @@src@@ ) free ( @@buf@@ ) ; @@len@@ *= Number L ; if ( @@len@@ < Number ) { * __errno_location ( ) = Number ; return Number L ; } @@buf@@ = ( char * ) malloc ( @@len@@ ) ; if ( ! @@buf@@ ) return Number L ; } @@v3@@ = @@size@@ ; @@sizea@@ = @@size@@ + Number ; @@buf@@ [ @@v3@@ ] = Number ; if ( @@buf@@ == @@src@@ ) { @@buf@@ = ( char * ) malloc ( @@sizea@@ ) ; if ( ! @@buf@@ ) return Number L ; memcpy ( @@buf@@ , @@src@@ , @@sizea@@ ) ; } else if ( @@len@@ > @@sizea@@ ) { @@v9@@ = ( char * ) realloc ( @@buf@@ , @@sizea@@ ) ; if ( @@v9@@ ) @@buf@@ = @@v9@@ ; } return @@buf@@ ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
__int64 __fastcall collapse_escapes ( char * @@a1@@ ) { char * @@v1@@ ; char * @@v2@@ ; int @@v3@@ ; char * @@v4@@ ; char * @@v5@@ ; char * @@v6@@ ; char * @@v7@@ ; char * @@v8@@ ; char * @@v9@@ ; char * @@v10@@ ; char * @@v11@@ ; char * @@v12@@ ; char * @@v14@@ ; char * @@v15@@ ; unsigned __int8 @@v16@@ ; char * @@v17@@ ; @@v14@@ = @@a1@@ ; @@v17@@ = ( char * ) xstrdup ( @@a1@@ ) ; @@v16@@ = Number ; delims = @@v17@@ ; while ( * @@v14@@ ) { if ( * @@v14@@ == Number ) { @@v15@@ = @@v14@@ + Number ; @@v3@@ = * @@v15@@ ; if ( @@v3@@ == Number ) { @@v6@@ = @@v17@@ ++ ; * @@v6@@ = Number ; goto LABEL_30 ; } if ( @@v3@@ > Number ) { if ( @@v3@@ == Number ) { @@v8@@ = @@v17@@ ++ ; * @@v8@@ = Number ; goto LABEL_30 ; } if ( @@v3@@ > Number ) { if ( @@v3@@ == Number ) { @@v9@@ = @@v17@@ ++ ; * @@v9@@ = Number ; goto LABEL_30 ; } if ( @@v3@@ == Number ) { @@v10@@ = @@v17@@ ++ ; * @@v10@@ = Number ; goto LABEL_30 ; } } else if ( @@v3@@ == Number ) { @@v7@@ = @@v17@@ ++ ; * @@v7@@ = Number ; goto LABEL_30 ; } } else { if ( @@v3@@ == Number ) { @@v4@@ = @@v17@@ ++ ; * @@v4@@ = Number ; goto LABEL_30 ; } if ( @@v3@@ > Number ) { if ( @@v3@@ == Number ) { @@v11@@ = @@v17@@ ++ ; * @@v11@@ = Number ; goto LABEL_30 ; } if ( @@v3@@ == Number ) { @@v5@@ = @@v17@@ ++ ; * @@v5@@ = Number ; goto LABEL_30 ; } } else if ( ! * @@v15@@ ) { @@v16@@ = Number ; break ; } } @@v12@@ = @@v17@@ ++ ; * @@v12@@ = * @@v15@@ ; LABEL_30 : @@v14@@ = @@v15@@ + Number ; } else { @@v1@@ = @@v14@@ ++ ; @@v2@@ = @@v17@@ ++ ; * @@v2@@ = * @@v1@@ ; } } delim_end = ( __int64 ) @@v17@@ ; return @@v16@@ ; }
int __fastcall stat ( char * @@filename@@ , struct stat * @@stat_buf@@ ) { return __xstat ( Number , @@filename@@ , @@stat_buf@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
int __cdecl __noreturn main ( int @@argc@@ , const char * * @@argv@@ , const char * * @@envp@@ ) { const char * @@v3@@ ; __int64 @@v4@@ ; char * @@v5@@ ; int * @@v6@@ ; int @@argca@@ ; unsigned __int8 @@v8@@ ; int @@v9@@ ; char * @@v10@@ ; @@argca@@ = @@argc@@ ; @@v10@@ = String ; set_program_name ( * @@argv@@ , @@argv@@ , @@envp@@ ) ; setlocale ( Number , & locale ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; have_read_stdin = Number ; serial_merge = Number ; while ( Number ) { @@v9@@ = getopt_long ( @@argc@@ , ( char * const * ) @@argv@@ , String , & longopts , Number L ) ; if ( @@v9@@ == Number ) { if ( @@argc@@ == optind ) { @@argca@@ = @@argc@@ + Number ; @@argv@@ [ @@argc@@ ] = ( const char * ) bad_cast ( ( __int64 ) String ) ; } if ( ( unsigned int ) collapse_escapes ( @@v10@@ ) ) { set_quoting_style ( Number L , Number L ) ; @@v4@@ = quotearg_colon ( @@v10@@ ) ; @@v5@@ = gettext ( String ) ; error ( Number , Number , @@v5@@ , @@v4@@ ) ; } if ( serial_merge != Number ) @@v8@@ = paste_parallel ( @@argca@@ - optind , ( __int64 ) & @@argv@@ [ optind ] ) ; else @@v8@@ = paste_serial ( @@argca@@ - optind , & @@argv@@ [ optind ] ) ; free ( delims ) ; if ( have_read_stdin ) { if ( fclose ( stdin ) == Number ) { @@v6@@ = __errno_location ( ) ; error ( Number , * @@v6@@ , String ) ; } } exit ( @@v8@@ ^ Number ) ; } if ( @@v9@@ == Number ) usage ( Number ) ; if ( @@v9@@ <= Number ) break ; if ( @@v9@@ == Number ) { if ( * ( _BYTE * ) optarg ) @@v3@@ = ( const char * ) optarg ; else @@v3@@ = String ; @@v10@@ = ( char * ) @@v3@@ ; } else { if ( @@v9@@ != Number ) goto LABEL_16 ; serial_merge = Number ; } } if ( @@v9@@ == Number ) { version_etc ( ( _DWORD ) stdout , ( unsigned int ) String , ( unsigned int ) String , ( _DWORD ) Version , ( unsigned int ) String , ( unsigned int ) String , Number ) ; exit ( Number ) ; } LABEL_16 : usage ( Number ) ; }
void __fastcall base64_encode ( unsigned __int8 * @@a1@@ , __int64 @@a2@@ , char * @@a3@@ , __int64 @@a4@@ ) { int @@v4@@ ; char * @@v5@@ ; char @@v6@@ ; char @@v7@@ ; int @@v8@@ ; char * @@v9@@ ; char @@v10@@ ; char @@v11@@ ; char @@v12@@ ; char * @@v13@@ ; char @@v14@@ ; char * @@v15@@ ; while ( @@a2@@ ) { if ( ! @@a4@@ ) break ; @@v4@@ = ( unsigned __int8 ) to_uchar ( * @@a1@@ ) >> Number ; @@v5@@ = @@a3@@ ++ ; * @@v5@@ = b64str_2796 [ @@v4@@ ] ; if ( ! -- @@a4@@ ) break ; @@v6@@ = Number * to_uchar ( * @@a1@@ ) ; @@v7@@ = -- @@a2@@ ? ( unsigned __int8 ) to_uchar ( @@a1@@ [ Number ] ) >> Number : Number ; @@v8@@ = ( @@v6@@ + @@v7@@ ) & Number ; @@v9@@ = @@a3@@ ++ ; * @@v9@@ = b64str_2796 [ @@v8@@ ] ; if ( ! -- @@a4@@ ) break ; if ( @@a2@@ ) { @@v10@@ = Number * to_uchar ( @@a1@@ [ Number ] ) ; @@v11@@ = -- @@a2@@ ? ( unsigned __int8 ) to_uchar ( @@a1@@ [ Number ] ) >> Number : Number ; @@v12@@ = b64str_2796 [ ( @@v10@@ + @@v11@@ ) & Number ] ; } else { @@v12@@ = Number ; } @@v13@@ = @@a3@@ ++ ; * @@v13@@ = @@v12@@ ; if ( ! -- @@a4@@ ) break ; @@v14@@ = @@a2@@ ? b64str_2796 [ to_uchar ( @@a1@@ [ Number ] ) & Number ] : Number ; @@v15@@ = @@a3@@ ++ ; * @@v15@@ = @@v14@@ ; if ( ! -- @@a4@@ ) break ; if ( @@a2@@ ) -- @@a2@@ ; if ( @@a2@@ ) @@a1@@ += Number ; } if ( @@a4@@ ) * @@a3@@ = Number ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_2080C8 ; @@v4@@ [ Number ] = qword_2080D0 ; @@v4@@ [ Number ] = qword_2080D8 ; @@v4@@ [ Number ] = qword_2080E0 ; @@v4@@ [ Number ] = qword_2080E8 ; @@v4@@ [ Number ] = qword_2080F0 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ ) { return xmalloc ( @@a1@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
int __lxstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _lxstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
int __fastcall xputchar ( char @@a1@@ ) { int @@result@@ ; @@result@@ = putchar_unlocked ( @@a1@@ ) ; if ( @@result@@ < Number ) write_error ( ) ; return @@result@@ ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return xmalloc ( @@a1@@ , @@a2@@ , @@a3@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
int __cdecl __noreturn main ( int @@argc@@ , const char * * @@argv@@ , const char * * @@envp@@ ) { char * @@v3@@ ; bool @@v4@@ ; unsigned __int8 @@v5@@ ; unsigned __int8 @@v6@@ ; int @@v7@@ ; @@v4@@ = Number ; @@v5@@ = Number ; @@v6@@ = Number ; set_program_name ( * @@argv@@ , @@argv@@ , @@envp@@ ) ; setlocale ( Number , & locale ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; while ( Number ) { while ( Number ) { @@v7@@ = getopt_long ( @@argc@@ , ( char * const * ) @@argv@@ , String , & longopts , Number L ) ; if ( @@v7@@ == Number ) { if ( @@argc@@ == optind ) { @@v3@@ = gettext ( String ) ; error ( Number , Number , @@v3@@ ) ; usage ( Number ) ; } while ( @@argc@@ > optind ) { @@v4@@ = ( @@v4@@ & ( unsigned __int8 ) validate_file_name ( @@argv@@ [ optind ] , @@v5@@ , @@v6@@ ) ) != Number ; ++ optind ; } exit ( ! @@v4@@ ) ; } if ( @@v7@@ != Number ) break ; @@v6@@ = Number ; } if ( @@v7@@ <= Number ) break ; if ( @@v7@@ == Number ) { @@v5@@ = Number ; } else { if ( @@v7@@ != Number ) goto LABEL_14 ; @@v5@@ = Number ; @@v6@@ = Number ; } } if ( @@v7@@ == Number ) { version_etc ( ( _DWORD ) stdout , ( unsigned int ) String , ( unsigned int ) String , ( _DWORD ) Version , ( unsigned int ) String , ( unsigned int ) String , String , Number L ) ; exit ( Number ) ; } if ( @@v7@@ == Number ) usage ( Number ) ; LABEL_14 : usage ( Number ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; char * @@v3@@ ; FILE * @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; FILE * @@v10@@ ; char * @@v11@@ ; FILE * @@v12@@ ; char * @@v13@@ ; @@v1@@ = program_name ; if ( @@a1@@ ) { @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = gettext ( String ) ; printf ( @@v3@@ , @@v1@@ ) ; @@v4@@ = stdout ; @@v5@@ = gettext ( String String String String ) ; fputs_unlocked ( @@v5@@ , @@v4@@ ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; @@v8@@ = stdout ; @@v9@@ = gettext ( String String ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = stdout ; @@v11@@ = gettext ( String ) ; fputs_unlocked ( @@v11@@ , @@v10@@ ) ; @@v12@@ = stdout ; @@v13@@ = gettext ( String ) ; fputs_unlocked ( @@v13@@ , @@v12@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; char * @@v3@@ ; FILE * @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; FILE * @@v10@@ ; char * @@v11@@ ; FILE * @@v12@@ ; char * @@v13@@ ; @@v1@@ = program_name ; if ( @@a1@@ ) { @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = gettext ( String String String ) ; printf ( @@v3@@ , @@v1@@ ) ; @@v4@@ = stdout ; @@v5@@ = gettext ( String String String String String String ) ; fputs_unlocked ( @@v5@@ , @@v4@@ ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; @@v8@@ = stdout ; @@v9@@ = gettext ( String ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = stdout ; @@v11@@ = gettext ( String ) ; fputs_unlocked ( @@v11@@ , @@v10@@ ) ; @@v12@@ = stdout ; @@v13@@ = gettext ( String String String String String ) ; fputs_unlocked ( @@v13@@ , @@v12@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
unsigned __int64 __fastcall do_encode ( FILE * @@a1@@ , FILE * @@a2@@ , __int64 @@a3@@ ) { char * @@v3@@ ; int * @@v4@@ ; char * @@v5@@ ; int * @@v6@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; size_t @@v11@@ ; char @@v12@@ [ Number ] ; char @@v13@@ [ Number ] ; unsigned __int64 @@v14@@ ; @@v14@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; do { @@v10@@ = Number L ; do { @@v11@@ = fread_unlocked ( & @@v12@@ [ @@v10@@ ] , Number , Number - @@v10@@ , @@a1@@ ) ; @@v10@@ += @@v11@@ ; } while ( ! feof_unlocked ( @@a1@@ ) && ! ferror_unlocked ( @@a1@@ ) && @@v10@@ <= Number ) ; if ( @@v10@@ ) { base64_encode ( @@v12@@ , @@v10@@ , @@v13@@ , Number * ( ( @@v10@@ + Number ) / Number ) ) ; wrap_write ( @@v13@@ , Number * ( ( @@v10@@ + Number ) / Number ) , @@a3@@ , & @@v9@@ , @@a2@@ ) ; } } while ( ! feof_unlocked ( @@a1@@ ) && ! ferror_unlocked ( @@a1@@ ) && @@v10@@ == Number ) ; if ( @@a3@@ && @@v9@@ && fputs_unlocked ( String , @@a2@@ ) < Number ) { @@v3@@ = gettext ( String ) ; @@v4@@ = __errno_location ( ) ; error ( Number , * @@v4@@ , @@v3@@ ) ; } if ( ferror_unlocked ( @@a1@@ ) ) { @@v5@@ = gettext ( String ) ; @@v6@@ = __errno_location ( ) ; error ( Number , * @@v6@@ , @@v5@@ ) ; } return __readfsqword ( Number ) ^ @@v14@@ ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
unsigned __int64 __fastcall base64_encode_alloc ( unsigned __int8 * @@a1@@ , unsigned __int64 @@a2@@ , char * * @@a3@@ ) { unsigned __int64 @@result@@ ; unsigned __int64 @@size@@ ; @@size@@ = Number * ( ( @@a2@@ + Number ) / Number ) + Number ; if ( @@a2@@ <= @@size@@ ) { * @@a3@@ = ( char * ) malloc ( @@size@@ ) ; if ( * @@a3@@ ) { base64_encode ( @@a1@@ , @@a2@@ , * @@a3@@ , @@size@@ ) ; @@result@@ = Number * ( ( @@a2@@ + Number ) / Number ) ; } else { @@result@@ = Number * ( ( @@a2@@ + Number ) / Number ) + Number ; } } else { * @@a3@@ = Number L ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
char * __fastcall get_4 ( _DWORD * @@a1@@ , char * * @@a2@@ , unsigned __int64 @@a3@@ , _QWORD * @@a4@@ ) { char * @@result@@ ; char * @@v5@@ ; unsigned int @@v6@@ ; char @@v9@@ ; char * @@v10@@ ; char * @@s@@ ; if ( * @@a1@@ == Number ) * @@a1@@ = Number ; if ( * @@a1@@ || ( @@s@@ = * @@a2@@ , ( __int64 ) ( @@a3@@ - ( _QWORD ) * @@a2@@ ) <= Number ) || memchr ( @@s@@ , Number , Number ) ) { @@v10@@ = * @@a2@@ ; while ( ( unsigned __int64 ) @@v10@@ < @@a3@@ ) { @@v5@@ = @@v10@@ ++ ; @@v9@@ = * @@v5@@ ; if ( * @@v5@@ != Number ) { @@v6@@ = ( * @@a1@@ ) ++ ; * ( ( _BYTE * ) @@a1@@ + @@v6@@ + Number ) = @@v9@@ ; if ( * @@a1@@ == Number ) break ; } } * @@a2@@ = @@v10@@ ; * @@a4@@ = ( unsigned int ) * @@a1@@ ; @@result@@ = ( char * ) ( @@a1@@ + Number ) ; } else { * @@a2@@ += Number ; * @@a4@@ = Number L ; @@result@@ = @@s@@ ; } return @@result@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
bool __fastcall base64_decode_ctx ( int * @@a1@@ , char * @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ , __int64 * @@a5@@ ) { __int64 @@v7@@ ; unsigned __int64 @@v8@@ ; char * @@v9@@ ; int * @@v10@@ ; bool @@v11@@ ; bool @@v12@@ ; int @@v13@@ ; __int64 @@v14@@ ; __int64 @@v15@@ ; unsigned __int8 * @@v16@@ ; char * @@v17@@ ; unsigned __int64 @@v18@@ ; @@v10@@ = @@a1@@ ; @@v9@@ = @@a2@@ ; @@v8@@ = @@a3@@ ; @@v7@@ = @@a4@@ ; @@v18@@ = __readfsqword ( Number ) ; @@v14@@ = * @@a5@@ ; @@v12@@ = @@a1@@ != Number L ; @@v11@@ = Number ; @@v13@@ = Number ; if ( @@a1@@ ) { @@v13@@ = * @@v10@@ ; @@v11@@ = @@v8@@ == Number ; } while ( Number ) { @@v15@@ = @@v14@@ ; if ( ! @@v13@@ && ! @@v11@@ ) { while ( Number ) { @@v15@@ = @@v14@@ ; if ( ( unsigned __int8 ) decode_4 ( ( unsigned __int8 * ) @@v9@@ , @@v8@@ , & @@v7@@ , & @@v14@@ ) != Number ) break ; @@v9@@ += Number ; @@v8@@ -= Number L ; } } if ( ! @@v8@@ && ! @@v11@@ ) break ; if ( @@v8@@ && * @@v9@@ == Number && @@v12@@ ) { ++ @@v9@@ ; -- @@v8@@ ; } else { @@v7@@ += @@v14@@ - @@v15@@ ; @@v14@@ = @@v15@@ ; @@v17@@ = & @@v9@@ [ @@v8@@ ] ; if ( @@v12@@ ) @@v16@@ = ( unsigned __int8 * ) get_4 ( @@v10@@ , & @@v9@@ , ( unsigned __int64 ) @@v17@@ , & @@v8@@ ) ; else @@v16@@ = ( unsigned __int8 * ) @@v9@@ ; if ( ! @@v8@@ || @@v8@@ <= Number && ! @@v11@@ && @@v12@@ ) { @@v8@@ = Number L ; break ; } if ( ( unsigned __int8 ) decode_4 ( @@v16@@ , @@v8@@ , & @@v7@@ , & @@v14@@ ) != Number ) break ; @@v8@@ = @@v17@@ - @@v9@@ ; } } * @@a5@@ -= @@v14@@ ; return @@v8@@ == Number ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
__int64 __fastcall component_len ( __int64 @@a1@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; * ( _BYTE * ) ( @@a1@@ + @@i@@ ) != Number && * ( _BYTE * ) ( @@a1@@ + @@i@@ ) ; ++ @@i@@ ) { ; } return @@i@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall bkm_scale_by_power ( unsigned __int64 * @@a1@@ , int @@a2@@ , int @@a3@@ ) { unsigned int @@i@@ ; for ( @@i@@ = Number ; @@a3@@ -- ; @@i@@ |= bkm_scale ( @@a1@@ , @@a2@@ ) ) ; return @@i@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , off_651E , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return xmalloc ( @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_207028 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_2070C8 ; @@v8@@ [ Number ] = qword_2070D0 ; @@v8@@ [ Number ] = qword_2070D8 ; @@v8@@ [ Number ] = qword_2070E0 ; @@v8@@ [ Number ] = qword_2070E8 ; @@v8@@ [ Number ] = qword_2070F0 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
wctype_t wctype ( const char * @@property@@ ) { return wctype ( @@property@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
int fileno ( FILE * @@stream@@ ) { return fileno ( @@stream@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
int __fxstat ( int @@ver@@ , int @@fildes@@ , struct stat * @@stat_buf@@ ) { return _fxstat ( @@ver@@ , @@fildes@@ , @@stat_buf@@ ) ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
wint_t btowc ( int @@c@@ ) { return btowc ( @@c@@ ) ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
char * strdup ( const char * @@s@@ ) { return strdup ( @@s@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_208028 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
int feof_unlocked ( FILE * @@stream@@ ) { return feof_unlocked ( @@stream@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
void __fastcall wrap_write ( char * @@a1@@ , size_t @@a2@@ , __int64 @@a3@@ , _QWORD * @@a4@@ , FILE * @@a5@@ ) { char * @@v5@@ ; int * @@v6@@ ; size_t @@v7@@ ; char * @@v8@@ ; int * @@v9@@ ; char * @@v10@@ ; int * @@v11@@ ; size_t @@v15@@ ; size_t @@v16@@ ; if ( @@a3@@ ) { @@v15@@ = Number L ; while ( @@v15@@ < @@a2@@ ) { @@v7@@ = @@a2@@ - @@v15@@ ; if ( @@a3@@ - * @@a4@@ <= @@a2@@ - @@v15@@ ) @@v7@@ = @@a3@@ - * @@a4@@ ; @@v16@@ = @@v7@@ ; if ( @@v7@@ ) { if ( @@v7@@ > fwrite_unlocked ( & @@a1@@ [ @@v15@@ ] , Number , @@v7@@ , stdout ) ) { @@v10@@ = gettext ( String ) ; @@v11@@ = __errno_location ( ) ; error ( Number , * @@v11@@ , @@v10@@ ) ; } * @@a4@@ += @@v16@@ ; @@v15@@ += @@v16@@ ; } else { if ( fputs_unlocked ( String , @@a5@@ ) < Number ) { @@v8@@ = gettext ( String ) ; @@v9@@ = __errno_location ( ) ; error ( Number , * @@v9@@ , @@v8@@ ) ; } * @@a4@@ = Number L ; } } } else if ( @@a2@@ > fwrite_unlocked ( @@a1@@ , Number , @@a2@@ , stdout ) ) { @@v5@@ = gettext ( String ) ; @@v6@@ = __errno_location ( ) ; error ( Number , * @@v6@@ , @@v5@@ ) ; } }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall search_table ( const void * @@a1@@ , _QWORD * @@a2@@ ) { int @@v3@@ ; int @@v4@@ ; int @@v5@@ ; int @@v6@@ ; @@v3@@ = Number ; @@v4@@ = @@a2@@ [ Number ] - Number ; while ( @@v3@@ <= @@v4@@ ) { @@v5@@ = ( @@v3@@ + @@v4@@ ) / Number ; @@v6@@ = compare_words ( @@a1@@ , ( const void * ) ( * @@a2@@ + Number L * @@v5@@ ) ) ; if ( @@v6@@ >= Number ) { if ( @@v6@@ <= Number ) return Number L ; @@v3@@ = @@v5@@ + Number ; } else { @@v4@@ = @@v5@@ - Number ; } } return Number L ; }
__int64 __fastcall portable_chars_only ( const char * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; char * @@v5@@ ; size_t @@v7@@ ; char * @@v8@@ ; size_t @@v9@@ ; mbstate_t @@ps@@ ; unsigned __int64 @@v11@@ ; @@v11@@ = __readfsqword ( Number ) ; @@v7@@ = strspn ( @@a1@@ , String ) ; @@v8@@ = ( char * ) & @@a1@@ [ @@v7@@ ] ; if ( ! @@a1@@ [ @@v7@@ ] ) return Number L ; @@ps@@ = Number L ; @@v9@@ = mbrlen ( @@v8@@ , @@a2@@ - @@v7@@ , & @@ps@@ ) ; @@v2@@ = quote_n ( Number L , @@a1@@ ) ; if ( @@v9@@ > Number ) @@v3@@ = Number L ; else @@v3@@ = @@v9@@ ; @@v4@@ = quotearg_n_style_mem ( Number L , Number L , @@v8@@ , @@v3@@ ) ; @@v5@@ = gettext ( String ) ; error ( Number , Number , @@v5@@ , @@v4@@ , @@v2@@ ) ; return Number L ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 __fastcall isbase64 ( unsigned __int8 @@a1@@ ) { return ( unsigned int ) ~ b64 [ ( unsigned __int8 ) to_uchar ( @@a1@@ ) ] >> Number ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_2070A8 ; @@v4@@ [ Number ] = qword_2070B0 ; @@v4@@ [ Number ] = qword_2070B8 ; @@v4@@ [ Number ] = qword_2070C0 ; @@v4@@ [ Number ] = qword_2070C8 ; @@v4@@ [ Number ] = qword_2070D0 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
int output_one_tex_line ( ) { __int64 @@v0@@ ; unsigned __int8 * @@v2@@ ; __int64 @@v3@@ ; unsigned __int8 * @@v4@@ ; unsigned __int64 @@v5@@ ; printf ( String , macro_name [ Number ] ) ; putchar_unlocked ( Number ) ; print_field ( ( unsigned __int8 * ) tail , qword_2297D8 ) ; fwrite_unlocked ( & off_23078 , Number , Number , stdout ) ; print_field ( ( unsigned __int8 * ) before , qword_2297F8 ) ; fwrite_unlocked ( & off_23078 , Number , Number , stdout ) ; @@v4@@ = ( unsigned __int8 * ) keyafter ; @@v5@@ = qword_229818 ; @@v2@@ = ( unsigned __int8 * ) keyafter ; if ( word_regex ) { @@v3@@ = rpl_re_match ( & unk_229288 , keyafter , qword_229818 - keyafter , Number L , Number L ) ; if ( @@v3@@ == Number ) matcher_error ( ) ; if ( @@v3@@ == Number ) @@v0@@ = Number L ; else @@v0@@ = @@v3@@ ; @@v2@@ += @@v0@@ ; } else if ( word_fastmap [ ( unsigned __int8 ) to_uchar ( * ( _BYTE * ) keyafter ) ] ) { while ( ( unsigned __int64 ) @@v2@@ < qword_229818 && word_fastmap [ ( unsigned __int8 ) to_uchar ( * @@v2@@ ) ] ) ++ @@v2@@ ; } else { ++ @@v2@@ ; } print_field ( @@v4@@ , ( unsigned __int64 ) @@v2@@ ) ; fwrite_unlocked ( & off_23078 , Number , Number , stdout ) ; print_field ( @@v2@@ , @@v5@@ ) ; fwrite_unlocked ( & off_23078 , Number , Number , stdout ) ; print_field ( ( unsigned __int8 * ) head , qword_229838 ) ; putchar_unlocked ( Number ) ; if ( auto_reference || input_reference ) { putchar_unlocked ( Number ) ; print_field ( ( unsigned __int8 * ) reference , qword_229858 ) ; putchar_unlocked ( Number ) ; } return putchar_unlocked ( Number ) ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
const char * __fastcall proper_name ( const char * @@a1@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; char * @@s@@ ; char * @@v5@@ ; @@s@@ = gettext ( @@a1@@ ) ; if ( @@s@@ == @@a1@@ ) return @@a1@@ ; if ( ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@s@@ , ( __int64 ) @@a1@@ ) ) return @@s@@ ; @@v2@@ = strlen ( @@s@@ ) ; @@v3@@ = strlen ( @@a1@@ ) ; @@v5@@ = ( char * ) xmalloc ( @@v2@@ + @@v3@@ + Number ) ; sprintf ( @@v5@@ , String , @@s@@ , @@a1@@ ) ; return @@v5@@ ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
__int64 __fastcall decode_4 ( unsigned __int8 * @@a1@@ , unsigned __int64 @@a2@@ , _QWORD * @@a3@@ , _QWORD * @@a4@@ ) { int @@v5@@ ; char @@v6@@ ; _BYTE * @@v7@@ ; int @@v8@@ ; char @@v9@@ ; _BYTE * @@v10@@ ; int @@v11@@ ; unsigned __int8 @@v12@@ ; _BYTE * @@v13@@ ; _BYTE * @@v16@@ ; @@v16@@ = ( _BYTE * ) * @@a3@@ ; if ( @@a2@@ <= Number ) return Number L ; if ( ( unsigned __int8 ) isbase64 ( * @@a1@@ ) != Number || ( unsigned __int8 ) isbase64 ( @@a1@@ [ Number ] ) != Number ) { return Number L ; } if ( * @@a4@@ ) { @@v5@@ = Number * ( char ) b64 [ ( unsigned __int8 ) to_uchar ( * @@a1@@ ) ] ; @@v6@@ = ( char ) b64 [ ( unsigned __int8 ) to_uchar ( @@a1@@ [ Number ] ) ] >> Number ; @@v7@@ = @@v16@@ ++ ; * @@v7@@ = @@v6@@ | @@v5@@ ; -- * @@a4@@ ; } if ( @@a2@@ == Number ) { * @@a3@@ = @@v16@@ ; return Number L ; } if ( @@a1@@ [ Number ] == Number ) { if ( @@a2@@ != Number ) { * @@a3@@ = @@v16@@ ; return Number L ; } if ( @@a1@@ [ Number ] != Number ) { * @@a3@@ = @@v16@@ ; return Number L ; } } else { if ( ( unsigned __int8 ) isbase64 ( @@a1@@ [ Number ] ) != Number ) { * @@a3@@ = @@v16@@ ; return Number L ; } if ( * @@a4@@ ) { @@v8@@ = Number * ( char ) b64 [ ( unsigned __int8 ) to_uchar ( @@a1@@ [ Number ] ) ] ; @@v9@@ = ( char ) b64 [ ( unsigned __int8 ) to_uchar ( @@a1@@ [ Number ] ) ] >> Number ; @@v10@@ = @@v16@@ ++ ; * @@v10@@ = @@v9@@ | @@v8@@ ; -- * @@a4@@ ; } if ( @@a2@@ == Number ) { * @@a3@@ = @@v16@@ ; return Number L ; } if ( @@a1@@ [ Number ] == Number ) { if ( @@a2@@ != Number ) { * @@a3@@ = @@v16@@ ; return Number L ; } } else { if ( ( unsigned __int8 ) isbase64 ( @@a1@@ [ Number ] ) != Number ) { * @@a3@@ = @@v16@@ ; return Number L ; } if ( * @@a4@@ ) { @@v11@@ = ( char ) b64 [ ( unsigned __int8 ) to_uchar ( @@a1@@ [ Number ] ) ] << Number ; @@v12@@ = b64 [ ( unsigned __int8 ) to_uchar ( @@a1@@ [ Number ] ) ] ; @@v13@@ = @@v16@@ ++ ; * @@v13@@ = @@v12@@ | @@v11@@ ; -- * @@a4@@ ; } } } * @@a3@@ = @@v16@@ ; return Number L ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
bool __fastcall is_basic_0 ( unsigned __int8 @@a1@@ ) { return ( ( is_basic_table [ @@a1@@ >> Number ] >> ( @@a1@@ & Number ) ) & Number ) != Number ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
__int64 __fastcall no_leading_hyphen ( char * @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; char * @@s@@ ; char * @@sa@@ ; for ( @@s@@ = @@a1@@ ; ; @@s@@ = @@sa@@ + Number ) { @@sa@@ = strchr ( @@s@@ , Number ) ; if ( ! @@sa@@ ) break ; if ( @@sa@@ == @@a1@@ || * ( @@sa@@ - Number ) == Number ) { @@v1@@ = quote ( @@a1@@ ) ; @@v2@@ = gettext ( String ) ; error ( Number , Number , @@v2@@ , @@v1@@ ) ; return Number L ; } } return Number L ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_207028 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 __fastcall argmatch ( const char * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { __int64 @@result@@ ; char @@v7@@ ; __int64 @@i@@ ; __int64 @@v9@@ ; size_t @@n@@ ; @@v9@@ = Number ; @@v7@@ = Number ; @@n@@ = strlen ( @@a1@@ ) ; for ( @@i@@ = Number L ; * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; ++ @@i@@ ) { if ( ! strncmp ( * ( const char * * ) ( Number * @@i@@ + @@a2@@ ) , @@a1@@ , @@n@@ ) ) { if ( @@n@@ == strlen ( * ( const char * * ) ( Number * @@i@@ + @@a2@@ ) ) ) return @@i@@ ; if ( @@v9@@ == Number ) { @@v9@@ = @@i@@ ; } else if ( ! @@a3@@ || memcmp ( ( const void * ) ( @@a4@@ * @@v9@@ + @@a3@@ ) , ( const void * ) ( @@i@@ * @@a4@@ + @@a3@@ ) , @@a4@@ ) ) { @@v7@@ = Number ; } } } if ( @@v7@@ ) @@result@@ = Number ; else @@result@@ = @@v9@@ ; return @@result@@ ; }
_BYTE * __fastcall component_start ( _BYTE * @@a1@@ ) { while ( * @@a1@@ == Number ) ++ @@a1@@ ; return @@a1@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
unsigned __int64 __fastcall swallow_file_in_memory ( const char * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v2@@ ; int @@v3@@ ; int * @@v4@@ ; int * @@v5@@ ; int * @@v6@@ ; int * @@v7@@ ; int * @@v8@@ ; bool @@v10@@ ; int @@fd@@ ; int @@v12@@ ; __int64 @@v13@@ ; __int64 @@v14@@ ; ssize_t @@v15@@ ; struct stat @@stat_buf@@ ; unsigned __int64 @@v17@@ ; @@v17@@ = __readfsqword ( Number ) ; @@v2@@ = ! @@a1@@ || ! * @@a1@@ || ! strcmp ( @@a1@@ , String ) ; @@v10@@ = @@v2@@ ; if ( @@v2@@ ) { @@fd@@ = Number ; @@v3@@ = fstat ( Number , & @@stat_buf@@ ) ; } else { @@fd@@ = open ( @@a1@@ , Number ) ; if ( @@fd@@ < Number ) { @@v4@@ = __errno_location ( ) ; error ( Number , * @@v4@@ , String , @@a1@@ ) ; } @@v3@@ = fstat ( @@fd@@ , & @@stat_buf@@ ) ; } if ( @@v3@@ < Number ) { @@v5@@ = __errno_location ( ) ; error ( Number , * @@v5@@ , String , @@a1@@ ) ; } if ( ( @@stat_buf@@ . st_mode & Number ) == Number ) { * @@a2@@ = xmalloc ( @@stat_buf@@ . st_size ) ; @@v15@@ = read ( @@fd@@ , ( void * ) * @@a2@@ , @@stat_buf@@ . st_size ) ; if ( @@v15@@ != @@stat_buf@@ . st_size ) { @@v6@@ = __errno_location ( ) ; error ( Number , * @@v6@@ , String , @@a1@@ ) ; } @@a2@@ [ Number ] = @@v15@@ + * @@a2@@ ; } else { * @@a2@@ = xmalloc ( Number L ) ; @@v14@@ = Number L ; @@v13@@ = Number L ; while ( Number ) { @@v12@@ = read ( @@fd@@ , ( void * ) ( @@v14@@ + * @@a2@@ ) , @@v13@@ - @@v14@@ ) ; if ( @@v12@@ <= Number ) break ; @@v14@@ += @@v12@@ ; if ( @@v14@@ == @@v13@@ ) { @@v13@@ += Number L ; * @@a2@@ = xrealloc ( * @@a2@@ , @@v13@@ ) ; } } if ( @@v12@@ < Number ) { @@v7@@ = __errno_location ( ) ; error ( Number , * @@v7@@ , String , @@a1@@ ) ; } @@a2@@ [ Number ] = @@v14@@ + * @@a2@@ ; } if ( ! @@v10@@ && close ( @@fd@@ ) ) { @@v8@@ = __errno_location ( ) ; error ( Number , * @@v8@@ , String , @@a1@@ ) ; } return __readfsqword ( Number ) ^ @@v17@@ ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
FILE * __fastcall freopen_safer ( const char * @@a1@@ , const char * @@a2@@ , FILE * @@a3@@ ) { int @@v3@@ ; FILE * @@streama@@ ; char @@v7@@ ; char @@v8@@ ; char @@v9@@ ; int @@v10@@ ; @@v7@@ = Number ; @@v8@@ = Number ; @@v9@@ = Number ; @@v3@@ = fileno ( @@a3@@ ) ; if ( @@v3@@ != Number ) { if ( @@v3@@ != Number ) { if ( ! @@v3@@ ) goto LABEL_10 ; if ( dup2 ( Number , Number ) != Number ) @@v9@@ = Number ; } if ( dup2 ( Number , Number ) != Number ) @@v8@@ = Number ; } if ( dup2 ( Number , Number ) ) @@v7@@ = Number ; LABEL_10 : if ( @@v7@@ && ( unsigned __int8 ) protect_fd ( Number ) != Number ) { @@streama@@ = Number L ; } else if ( @@v8@@ && ( unsigned __int8 ) protect_fd ( Number ) != Number ) { @@streama@@ = Number L ; } else if ( @@v9@@ && ( unsigned __int8 ) protect_fd ( Number ) != Number ) { @@streama@@ = Number L ; } else { @@streama@@ = freopen ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } @@v10@@ = * __errno_location ( ) ; if ( @@v9@@ ) close ( Number ) ; if ( @@v8@@ ) close ( Number ) ; if ( @@v7@@ ) close ( Number ) ; if ( ! @@streama@@ ) * __errno_location ( ) = @@v10@@ ; return @@streama@@ ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_208028 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_2080C8 ; @@v8@@ [ Number ] = qword_2080D0 ; @@v8@@ [ Number ] = qword_2080D8 ; @@v8@@ [ Number ] = qword_2080E0 ; @@v8@@ [ Number ] = qword_2080E8 ; @@v8@@ [ Number ] = qword_2080F0 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
__int64 __fastcall xstr_cd_iconv ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v3@@ ; @@v3@@ = str_cd_iconv ( @@a1@@ , @@a2@@ ) ; if ( ! @@v3@@ && * __errno_location ( ) == Number ) xalloc_die ( ) ; return @@v3@@ ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
int __fastcall argmatch_valid ( __int64 @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { char * @@v3@@ ; __int64 @@i@@ ; void * @@s1@@ ; @@s1@@ = Number L ; @@v3@@ = gettext ( String ) ; fprintf ( stderr , @@v3@@ ) ; for ( @@i@@ = Number L ; * ( _QWORD * ) ( Number * @@i@@ + @@a1@@ ) ; ++ @@i@@ ) { if ( @@i@@ && ! memcmp ( @@s1@@ , ( const void * ) ( @@i@@ * @@a3@@ + @@a2@@ ) , @@a3@@ ) ) { fprintf ( stderr , String , * ( const char * * ) ( Number * @@i@@ + @@a1@@ ) ) ; } else { fprintf ( stderr , String , * ( const char * * ) ( Number * @@i@@ + @@a1@@ ) ) ; @@s1@@ = ( void * ) ( @@i@@ * @@a3@@ + @@a2@@ ) ; } } return putc_unlocked ( Number , stderr ) ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
int iswlower ( wint_t @@wc@@ ) { return iswlower ( @@wc@@ ) ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_207028 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
int toupper ( int @@c@@ ) { return toupper ( @@c@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
_QWORD * __fastcall bitset_set ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { _QWORD * @@result@@ ; @@result@@ = ( _QWORD * ) ( Number * ( @@a2@@ >> Number ) + @@a1@@ ) ; * @@result@@ |= Number L << ( @@a2@@ & Number ) ; return @@result@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
bool __fastcall bitset_contain ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return ( ( * ( _QWORD * ) ( Number * ( @@a2@@ >> Number ) + @@a1@@ ) >> ( @@a2@@ & Number ) ) & Number L ) != Number ; }
int putchar_unlocked ( int @@c@@ ) { return putchar_unlocked ( @@c@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
char * nl_langinfo ( nl_item @@item@@ ) { return nl_langinfo ( @@item@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
wint_t towupper ( wint_t @@wc@@ ) { return towupper ( @@wc@@ ) ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int64 __fastcall re_string_wchar_at ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; if ( * ( _DWORD * ) ( @@a1@@ + Number ) == Number ) @@result@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ ) ; else @@result@@ = * ( unsigned int * ) ( Number * @@a2@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) ; return @@result@@ ; }
int iswalnum ( wint_t @@wc@@ ) { return iswalnum ( @@wc@@ ) ; }
int iswspace ( wint_t @@wc@@ ) { return iswspace ( @@wc@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
__int64 __fastcall compile_regex ( __int64 @@a1@@ ) { void * @@v1@@ ; size_t @@v2@@ ; __int64 @@v3@@ ; char * @@v4@@ ; __int64 @@v6@@ ; char * @@s@@ ; __int64 @@v8@@ ; @@v6@@ = @@a1@@ + Number ; @@s@@ = * ( char * * ) @@a1@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@a1@@ + Number ; if ( ignore_case ) @@v1@@ = & folded_chars ; else @@v1@@ = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v1@@ ; @@v2@@ = strlen ( @@s@@ ) ; @@v8@@ = rpl_re_compile_pattern ( @@s@@ , @@v2@@ , @@v6@@ ) ; if ( @@v8@@ ) { @@v3@@ = quote ( @@s@@ ) ; @@v4@@ = gettext ( String ) ; error ( Number , Number , @@v4@@ , @@v8@@ , @@v3@@ ) ; } return rpl_re_compile_fastmap ( @@v6@@ ) ; }
unsigned __int64 __fastcall re_string_skip_chars ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ ) { _BOOL4 @@v3@@ ; wchar_t @@pwc@@ ; wchar_t @@v7@@ ; unsigned __int64 @@i@@ ; size_t @@v9@@ ; size_t @@n@@ ; __int64 @@v11@@ ; unsigned __int64 @@v12@@ ; @@v12@@ = __readfsqword ( Number ) ; @@v7@@ = Number ; for ( @@i@@ = * ( _QWORD * ) ( @@a1@@ + Number ) + * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ < @@a2@@ ; @@i@@ += @@v9@@ ) { @@n@@ = * ( _QWORD * ) ( @@a1@@ + Number ) - @@i@@ ; @@v11@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v9@@ = mbrtowc ( & @@pwc@@ , ( const char * ) ( * ( _QWORD * ) @@a1@@ + @@i@@ ) , @@n@@ , ( mbstate_t * ) ( @@a1@@ + Number ) ) ; @@v3@@ = @@v9@@ == Number || @@v9@@ == Number ; if ( ! @@v3@@ && @@v9@@ ) { @@v7@@ = @@pwc@@ ; } else { if ( @@v9@@ && @@n@@ ) @@v7@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) @@a1@@ + @@i@@ ) ; else @@v7@@ = Number ; @@v9@@ = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v11@@ ; } } * @@a3@@ = @@v7@@ ; return @@i@@ ; }
__int64 initialize_regex ( ) { __int64 @@result@@ ; bool @@v1@@ ; int @@c@@ ; int @@ca@@ ; if ( ignore_case ) { for ( @@c@@ = Number ; @@c@@ <= Number ; ++ @@c@@ ) folded_chars [ @@c@@ ] = toupper ( @@c@@ ) ; } if ( context_regex ) { if ( ! * ( _BYTE * ) context_regex ) context_regex = Number L ; } else if ( gnu_extensions && input_reference != Number ) { context_regex = ( __int64 ) String ; } else { context_regex = ( __int64 ) String ; } if ( context_regex ) compile_regex ( ( __int64 ) & context_regex ) ; if ( word_regex ) return compile_regex ( ( __int64 ) & word_regex ) ; @@result@@ = break_file ; if ( ! break_file ) { @@result@@ = ( unsigned __int8 ) gnu_extensions ; if ( gnu_extensions ) { for ( @@ca@@ = Number ; @@ca@@ <= Number ; ++ @@ca@@ ) { @@v1@@ = ( ( * __ctype_b_loc ( ) ) [ @@ca@@ ] & Number ) != Number ; @@result@@ = ( __int64 ) word_fastmap ; word_fastmap [ @@ca@@ ] = @@v1@@ ; } } else { @@result@@ = ( __int64 ) memset ( word_fastmap , Number , Number ) ; byte_229540 = Number ; byte_229529 = Number ; byte_22952A = Number ; } } return @@result@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_229058 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
__int64 __fastcall compare_occurs ( const void * @@a1@@ , const void * @@a2@@ ) { __int64 @@result@@ ; unsigned int @@v3@@ ; @@v3@@ = compare_words ( @@a1@@ , @@a2@@ ) ; if ( @@v3@@ ) @@result@@ = @@v3@@ ; else @@result@@ = * ( _QWORD * ) @@a1@@ - * ( _QWORD * ) @@a2@@ ; return @@result@@ ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; char * @@v3@@ ; FILE * @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; @@v1@@ = program_name ; if ( @@a1@@ ) { @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = gettext ( String ) ; printf ( @@v3@@ , @@v1@@ ) ; @@v4@@ = stdout ; @@v5@@ = gettext ( String String String String String ) ; fputs_unlocked ( @@v5@@ , @@v4@@ ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; @@v8@@ = stdout ; @@v9@@ = gettext ( String ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
void __fastcall re_string_destruct ( __int64 @@a1@@ ) { free ( * ( void * * ) ( @@a1@@ + Number ) ) ; free ( * ( void * * ) ( @@a1@@ + Number ) ) ; if ( * ( _BYTE * ) ( @@a1@@ + Number ) ) free ( * ( void * * ) ( @@a1@@ + Number ) ) ; }
unsigned __int64 __fastcall digest_word_file ( const char * @@a1@@ , _QWORD * @@a2@@ ) { _BYTE * @@v3@@ ; _BYTE * @@v4@@ ; _BYTE * @@v5@@ ; unsigned __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; swallow_file_in_memory ( @@a1@@ , & @@v5@@ ) ; * @@a2@@ = Number L ; @@a2@@ [ Number ] = Number L ; @@a2@@ [ Number ] = Number L ; @@v3@@ = @@v5@@ ; while ( ( unsigned __int64 ) @@v3@@ < @@v6@@ ) { @@v4@@ = @@v3@@ ; while ( ( unsigned __int64 ) @@v3@@ < @@v6@@ && * @@v3@@ != Number ) ++ @@v3@@ ; if ( @@v3@@ > @@v4@@ ) { if ( @@a2@@ [ Number ] == @@a2@@ [ Number ] ) { if ( @@a2@@ [ Number ] > Number ) xalloc_die ( ) ; @@a2@@ [ Number ] = Number L * @@a2@@ [ Number ] + Number ; * @@a2@@ = xrealloc ( * @@a2@@ , Number L * @@a2@@ [ Number ] ) ; } * ( _QWORD * ) ( Number L * @@a2@@ [ Number ] + * @@a2@@ ) = @@v4@@ ; * ( _WORD * ) ( * @@a2@@ + Number L * @@a2@@ [ Number ] ++ + Number ) = ( _WORD ) @@v3@@ - ( _WORD ) @@v4@@ ; } if ( ( unsigned __int64 ) @@v3@@ < @@v6@@ ) ++ @@v3@@ ; } qsort ( ( void * ) * @@a2@@ , @@a2@@ [ Number ] , Number , ( __compar_fn_t ) compare_words ) ; return __readfsqword ( Number ) ^ @@v7@@ ; }
unsigned __int64 __fastcall digest_break_file ( const char * @@a1@@ ) { unsigned __int8 * @@i@@ ; void * @@ptr@@ [ Number ] ; unsigned __int64 @@v4@@ ; @@v4@@ = __readfsqword ( Number ) ; swallow_file_in_memory ( @@a1@@ , @@ptr@@ ) ; memset ( word_fastmap , Number , Number ) ; for ( @@i@@ = ( unsigned __int8 * ) @@ptr@@ [ Number ] ; @@i@@ < @@ptr@@ [ Number ] ; ++ @@i@@ ) { word_fastmap [ ( unsigned __int8 ) to_uchar ( * @@i@@ ) ] = Number ; } if ( gnu_extensions != Number ) { byte_229540 = Number ; byte_229529 = Number ; byte_22952A = Number ; } free ( @@ptr@@ [ Number ] ) ; return __readfsqword ( Number ) ^ @@v4@@ ; }
__int64 __fastcall re_string_realloc_buffers ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { void * @@v3@@ ; void * @@v4@@ ; void * @@v5@@ ; if ( * ( int * ) ( @@a1@@ + Number ) > Number ) { if ( ! is_mul_ok ( Number , @@a2@@ ) ) return Number L ; @@v3@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number * @@a2@@ ) ; if ( ! @@v3@@ ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v3@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) { @@v4@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number * @@a2@@ ) ; if ( ! @@v4@@ ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v4@@ ; } } if ( * ( _BYTE * ) ( @@a1@@ + Number ) ) { @@v5@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , @@a2@@ ) ; if ( ! @@v5@@ ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v5@@ ; } * ( _QWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; return Number L ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
_QWORD * __fastcall build_upper_buffer ( _QWORD * @@a1@@ ) { unsigned __int64 @@v1@@ ; _QWORD * @@result@@ ; int @@c@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@v5@@ ; @@v1@@ = @@a1@@ [ Number ] ; if ( @@a1@@ [ Number ] <= @@v1@@ ) @@v1@@ = @@a1@@ [ Number ] ; @@v5@@ = @@v1@@ ; for ( @@i@@ = @@a1@@ [ Number ] ; @@i@@ < @@v5@@ ; ++ @@i@@ ) { @@c@@ = * ( unsigned __int8 * ) ( * @@a1@@ + @@a1@@ [ Number ] + @@i@@ ) ; if ( @@a1@@ [ Number ] ) @@c@@ = * ( unsigned __int8 * ) ( @@a1@@ [ Number ] + * ( unsigned __int8 * ) ( * @@a1@@ + @@a1@@ [ Number ] + @@i@@ ) ) ; if ( ( ( * __ctype_b_loc ( ) ) [ @@c@@ ] & Number ) != Number ) * ( _BYTE * ) ( @@a1@@ [ Number ] + @@i@@ ) = toupper ( @@c@@ ) ; else * ( _BYTE * ) ( @@a1@@ [ Number ] + @@i@@ ) = @@c@@ ; } @@a1@@ [ Number ] = @@i@@ ; @@result@@ = @@a1@@ ; @@a1@@ [ Number ] = @@i@@ ; return @@result@@ ; }
bool __fastcall is_basic ( unsigned __int8 @@a1@@ ) { return ( ( is_basic_table [ @@a1@@ >> Number ] >> ( @@a1@@ & Number ) ) & Number ) != Number ; }
size_t generate_all_output ( ) { size_t @@result@@ ; size_t @@i@@ ; char * @@v2@@ ; tail = Number L ; qword_2297D8 = Number L ; tail_truncation = Number ; head = Number L ; qword_229838 = Number L ; head_truncation = Number ; @@v2@@ = ( char * ) occurs_table ; for ( @@i@@ = Number L ; ; ++ @@i@@ ) { @@result@@ = number_of_occurs ; if ( @@i@@ >= number_of_occurs ) break ; define_all_fields ( ( __int64 ) @@v2@@ ) ; if ( output_format == Number ) { output_one_roff_line ( ) ; } else if ( ( unsigned int ) output_format < Number ) { output_one_dumb_line ( ) ; } else if ( output_format == Number ) { output_one_tex_line ( ) ; } @@v2@@ += Number ; } return @@result@@ ; }
__int64 __fastcall re_node_set_alloc ( _QWORD * @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = Number L ; @@a1@@ [ Number ] = malloc ( Number * @@a2@@ ) ; if ( @@a1@@ [ Number ] ) @@result@@ = Number L ; else @@result@@ = Number L ; return @@result@@ ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
__int64 __fastcall re_node_set_init_1 ( _QWORD * @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; * @@a1@@ = Number L ; @@a1@@ [ Number ] = Number L ; @@a1@@ [ Number ] = malloc ( Number ) ; if ( @@a1@@ [ Number ] ) { * ( _QWORD * ) @@a1@@ [ Number ] = @@a2@@ ; @@result@@ = Number L ; } else { @@a1@@ [ Number ] = Number L ; * @@a1@@ = @@a1@@ [ Number ] ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; FILE * @@v10@@ ; char * @@v11@@ ; FILE * @@v12@@ ; char * @@v13@@ ; FILE * @@v14@@ ; char * @@v15@@ ; FILE * @@v16@@ ; char * @@v17@@ ; FILE * @@v18@@ ; char * @@v19@@ ; FILE * @@v20@@ ; char * @@v21@@ ; FILE * @@v22@@ ; char * @@v23@@ ; if ( @@a1@@ ) { @@v1@@ = program_name ; @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = program_name ; @@v4@@ = program_name ; @@v5@@ = gettext ( String ) ; printf ( @@v5@@ , @@v4@@ , @@v3@@ ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; @@v8@@ = stdout ; @@v9@@ = gettext ( String ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = stdout ; @@v11@@ = gettext ( String String String ) ; fputs_unlocked ( @@v11@@ , @@v10@@ ) ; @@v12@@ = stdout ; @@v13@@ = gettext ( String String String String String ) ; fputs_unlocked ( @@v13@@ , @@v12@@ ) ; @@v14@@ = stdout ; @@v15@@ = gettext ( String String String String String String ) ; fputs_unlocked ( @@v15@@ , @@v14@@ ) ; @@v16@@ = stdout ; @@v17@@ = gettext ( String String String ) ; fputs_unlocked ( @@v17@@ , @@v16@@ ) ; @@v18@@ = stdout ; @@v19@@ = gettext ( String ) ; fputs_unlocked ( @@v19@@ , @@v18@@ ) ; @@v20@@ = stdout ; @@v21@@ = gettext ( String ) ; fputs_unlocked ( @@v21@@ , @@v20@@ ) ; @@v22@@ = stdout ; @@v23@@ = gettext ( String ) ; fputs_unlocked ( @@v23@@ , @@v22@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
__int64 __fastcall re_node_set_init_2 ( _QWORD * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { * @@a1@@ = Number L ; @@a1@@ [ Number ] = malloc ( Number ) ; if ( ! @@a1@@ [ Number ] ) return Number L ; if ( @@a2@@ == @@a3@@ ) { @@a1@@ [ Number ] = Number L ; * ( _QWORD * ) @@a1@@ [ Number ] = @@a2@@ ; } else { @@a1@@ [ Number ] = Number L ; if ( @@a2@@ >= @@a3@@ ) { * ( _QWORD * ) @@a1@@ [ Number ] = @@a3@@ ; * ( _QWORD * ) ( @@a1@@ [ Number ] + Number L ) = @@a2@@ ; } else { * ( _QWORD * ) @@a1@@ [ Number ] = @@a2@@ ; * ( _QWORD * ) ( @@a1@@ [ Number ] + Number L ) = @@a3@@ ; } } return Number L ; }
__int64 __fastcall re_node_set_init_copy ( void * @@a1@@ , __int64 @@a2@@ ) { * ( ( _QWORD * ) @@a1@@ + Number ) = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) ) { * ( _QWORD * ) @@a1@@ = * ( ( _QWORD * ) @@a1@@ + Number ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = malloc ( Number L * * ( _QWORD * ) @@a1@@ ) ; if ( ! * ( ( _QWORD * ) @@a1@@ + Number ) ) { * ( ( _QWORD * ) @@a1@@ + Number ) = Number L ; * ( _QWORD * ) @@a1@@ = * ( ( _QWORD * ) @@a1@@ + Number ) ; return Number L ; } memcpy ( * ( ( void * * ) @@a1@@ + Number ) , * ( const void * * ) ( @@a2@@ + Number ) , Number L * * ( _QWORD * ) ( @@a2@@ + Number ) ) ; } else { memset ( @@a1@@ , Number , Number ) ; } return Number L ; }
char * __fastcall proper_name_utf8 ( const char * @@a1@@ , __int64 @@a2@@ ) { char * @@v2@@ ; char * @@result@@ ; size_t @@v4@@ ; size_t @@v5@@ ; char * @@ptr@@ ; char * @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; char * @@s1@@ ; char * @@s@@ ; size_t @@n@@ ; char * @@dest@@ ; char * @@v14@@ ; char * @@v15@@ ; char * @@v16@@ ; @@s1@@ = gettext ( @@a1@@ ) ; @@s@@ = ( char * ) locale_charset ( ) ; @@ptr@@ = Number L ; @@v7@@ = Number L ; @@v9@@ = Number L ; if ( ( unsigned int ) c_strcasecmp ( @@s@@ , String ) ) { @@ptr@@ = ( char * ) xstr_iconv ( @@a2@@ , String , @@s@@ ) ; @@v8@@ = ( __int64 ) @@ptr@@ ; @@n@@ = strlen ( @@s@@ ) ; @@dest@@ = ( char * ) xmalloc ( @@n@@ + Number ) ; memcpy ( @@dest@@ , @@s@@ , @@n@@ ) ; memcpy ( & @@dest@@ [ @@n@@ ] , String , Number ) ; @@v14@@ = ( char * ) xstr_iconv ( @@a2@@ , String , @@dest@@ ) ; free ( @@dest@@ ) ; if ( @@v14@@ ) { if ( strchr ( @@v14@@ , Number ) ) { free ( @@v14@@ ) ; } else { @@v7@@ = @@v14@@ ; @@v9@@ = ( __int64 ) @@v14@@ ; } } } else { @@v8@@ = @@a2@@ ; @@v9@@ = @@a2@@ ; } if ( @@v8@@ ) { @@v2@@ = ( char * ) @@v8@@ ; } else if ( @@v9@@ ) { @@v2@@ = ( char * ) @@v9@@ ; } else { @@v2@@ = ( char * ) @@a1@@ ; } @@v15@@ = @@v2@@ ; if ( ! strcmp ( @@s1@@ , @@a1@@ ) ) { if ( @@ptr@@ && @@ptr@@ != @@v15@@ ) free ( @@ptr@@ ) ; if ( @@v7@@ && @@v7@@ != @@v15@@ ) free ( @@v7@@ ) ; @@result@@ = @@v15@@ ; } else if ( ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@s1@@ , ( __int64 ) @@a1@@ ) || @@v8@@ && ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@s1@@ , @@v8@@ ) || @@v9@@ && ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@s1@@ , @@v9@@ ) ) { if ( @@ptr@@ ) free ( @@ptr@@ ) ; if ( @@v7@@ ) free ( @@v7@@ ) ; @@result@@ = @@s1@@ ; } else { @@v4@@ = strlen ( @@s1@@ ) ; @@v5@@ = strlen ( @@v15@@ ) ; @@v16@@ = ( char * ) xmalloc ( @@v4@@ + @@v5@@ + Number ) ; sprintf ( @@v16@@ , String , @@s1@@ , @@v15@@ ) ; if ( @@ptr@@ ) free ( @@ptr@@ ) ; if ( @@v7@@ ) free ( @@v7@@ ) ; @@result@@ = @@v16@@ ; } return @@result@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
__int64 __fastcall re_node_set_compare ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v3@@ ; if ( ! @@a1@@ || ! @@a2@@ || * ( _QWORD * ) ( @@a1@@ + Number ) != * ( _QWORD * ) ( @@a2@@ + Number ) ) { return Number L ; } @@v3@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; while ( ( unsigned __int64 ) -- @@v3@@ <= Number ) { if ( * ( _QWORD * ) ( Number * @@v3@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) != * ( _QWORD * ) ( Number * @@v3@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) ) return Number L ; } return Number L ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
unsigned __int64 __fastcall re_node_set_remove_at ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { unsigned __int64 @@result@@ ; unsigned __int64 @@v3@@ ; @@v3@@ = @@a2@@ ; @@result@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( @@a2@@ < @@result@@ ) { -- * ( _QWORD * ) ( @@a1@@ + Number ) ; while ( Number ) { @@result@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( @@v3@@ >= @@result@@ ) break ; * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@v3@@ ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * ( @@v3@@ + Number ) ) ; ++ @@v3@@ ; } } return @@result@@ ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 __fastcall argmatch_to_argument ( const void * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; ++ @@i@@ ) { if ( ! memcmp ( @@a1@@ , ( const void * ) ( @@i@@ * @@a4@@ + @@a3@@ ) , @@a4@@ ) ) return * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; } return Number L ; }
char * __fastcall create_ci_newstate ( _QWORD * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { char * @@result@@ ; int @@v5@@ ; unsigned __int64 @@i@@ ; char * @@ptr@@ ; __int64 @@v8@@ ; @@ptr@@ = ( char * ) calloc ( Number , Number ) ; if ( ! @@ptr@@ ) return Number L ; if ( ( unsigned int ) re_node_set_init_copy ( @@ptr@@ + Number , @@a2@@ ) ) { free ( @@ptr@@ ) ; @@result@@ = Number L ; } else { * ( ( _QWORD * ) @@ptr@@ + Number ) = @@ptr@@ + Number ; for ( @@i@@ = Number L ; @@i@@ < * ( _QWORD * ) ( @@a2@@ + Number ) ; ++ @@i@@ ) { @@v8@@ = * @@a1@@ + Number L * * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) ; @@v5@@ = * ( unsigned __int8 * ) ( @@v8@@ + Number ) ; if ( @@v5@@ != Number || ( * ( _DWORD * ) ( @@v8@@ + Number ) & Number ) != Number ) { @@ptr@@ [ Number ] = ( Number * ( ( * ( _BYTE * ) ( @@v8@@ + Number ) & Number ) != Number || ( @@ptr@@ [ Number ] & Number ) != Number ) ) | @@ptr@@ [ Number ] & Number ; if ( @@v5@@ == Number ) { @@ptr@@ [ Number ] |= Number ; } else if ( @@v5@@ == Number ) { @@ptr@@ [ Number ] |= Number ; } else if ( @@v5@@ == Number || ( * ( _DWORD * ) ( @@v8@@ + Number ) & Number ) != Number ) { @@ptr@@ [ Number ] |= Number ; } } } if ( ( unsigned int ) register_state ( @@a1@@ , @@ptr@@ , @@a3@@ ) ) { free_state ( ( void * * ) @@ptr@@ ) ; @@ptr@@ = Number L ; } @@result@@ = @@ptr@@ ; } return @@result@@ ; }
__int64 __fastcall register_state ( _QWORD * @@a1@@ , _QWORD * @@a2@@ , __int64 @@a3@@ ) { __int64 @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; unsigned __int64 @@i@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; void * @@v12@@ ; __int64 @@v13@@ ; * @@a2@@ = @@a3@@ ; if ( ( unsigned int ) re_node_set_alloc ( @@a2@@ + Number , @@a2@@ [ Number ] ) ) return Number L ; for ( @@i@@ = Number L ; @@i@@ < @@a2@@ [ Number ] ; ++ @@i@@ ) { @@v13@@ = * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ [ Number ] ) ; if ( ( * ( _BYTE * ) ( Number * @@v13@@ + * @@a1@@ + Number ) & Number ) == Number && ( unsigned __int8 ) re_node_set_insert_last ( ( __int64 ) ( @@a2@@ + Number ) , @@v13@@ ) != Number ) { return Number L ; } } @@v10@@ = @@a1@@ [ Number ] + Number * ( @@a3@@ & @@a1@@ [ Number ] ) ; if ( * ( _QWORD * ) ( @@v10@@ + Number ) <= * ( _QWORD * ) @@v10@@ ) { @@v4@@ = * ( _QWORD * ) @@v10@@ + Number L ; @@v11@@ = Number * @@v4@@ ; @@v12@@ = realloc ( * ( void * * ) ( @@v10@@ + Number ) , Number * @@v4@@ ) ; if ( ! @@v12@@ ) return Number L ; * ( _QWORD * ) ( @@v10@@ + Number ) = @@v12@@ ; * ( _QWORD * ) ( @@v10@@ + Number ) = @@v11@@ ; } @@v5@@ = * ( _QWORD * ) ( @@v10@@ + Number ) ; @@v6@@ = ( * ( _QWORD * ) @@v10@@ ) ++ ; * ( _QWORD * ) ( @@v5@@ + Number * @@v6@@ ) = @@a2@@ ; return Number L ; }
__int64 __fastcall free_workarea_compile ( __int64 * @@a1@@ ) { __int64 @@result@@ ; _QWORD * @@ptr@@ ; __int64 @@v3@@ ; _QWORD * @@v4@@ ; @@v3@@ = * @@a1@@ ; for ( @@ptr@@ = * ( _QWORD * * ) ( * @@a1@@ + Number ) ; @@ptr@@ ; @@ptr@@ = @@v4@@ ) { @@v4@@ = ( _QWORD * ) * @@ptr@@ ; free ( @@ptr@@ ) ; } * ( _QWORD * ) ( @@v3@@ + Number ) = Number L ; * ( _DWORD * ) ( @@v3@@ + Number ) = Number ; * ( _QWORD * ) ( @@v3@@ + Number ) = Number L ; free ( * ( void * * ) ( @@v3@@ + Number ) ) ; @@result@@ = @@v3@@ ; * ( _QWORD * ) ( @@v3@@ + Number ) = Number L ; return @@result@@ ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_2070A8 ; @@v8@@ [ Number ] = qword_2070B0 ; @@v8@@ [ Number ] = qword_2070B8 ; @@v8@@ [ Number ] = qword_2070C0 ; @@v8@@ [ Number ] = qword_2070C8 ; @@v8@@ [ Number ] = qword_2070D0 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
void __fastcall free_dfa_content ( __int64 @@a1@@ ) { unsigned __int64 @@i@@ ; unsigned __int64 @@j@@ ; unsigned __int64 @@k@@ ; unsigned __int64 @@l@@ ; __int64 @@v5@@ ; if ( * ( _QWORD * ) @@a1@@ ) { for ( @@i@@ = Number L ; @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; ++ @@i@@ ) free_token ( Number * @@i@@ + * ( _QWORD * ) @@a1@@ ) ; } free ( * ( void * * ) ( @@a1@@ + Number ) ) ; for ( @@j@@ = Number L ; @@j@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; ++ @@j@@ ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) free ( * ( void * * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@j@@ + Number ) ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) free ( * ( void * * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@j@@ + Number ) ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) free ( * ( void * * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@j@@ + Number ) ) ; } free ( * ( void * * ) ( @@a1@@ + Number ) ) ; free ( * ( void * * ) ( @@a1@@ + Number ) ) ; free ( * ( void * * ) ( @@a1@@ + Number ) ) ; free ( * ( void * * ) @@a1@@ ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) { for ( @@k@@ = Number L ; @@k@@ <= * ( _QWORD * ) ( @@a1@@ + Number ) ; ++ @@k@@ ) { @@v5@@ = * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@k@@ ; for ( @@l@@ = Number L ; @@l@@ < * ( _QWORD * ) @@v5@@ ; ++ @@l@@ ) free_state ( * ( void * * * ) ( Number * @@l@@ + * ( _QWORD * ) ( @@v5@@ + Number ) ) ) ; free ( * ( void * * ) ( @@v5@@ + Number ) ) ; } } free ( * ( void * * ) ( @@a1@@ + Number ) ) ; if ( * ( _UNKNOWN * * ) ( @@a1@@ + Number ) != & utf8_sb_map ) free ( * ( void * * ) ( @@a1@@ + Number ) ) ; free ( * ( void * * ) ( @@a1@@ + Number ) ) ; free ( ( void * ) @@a1@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
__int64 __fastcall optimize_subexps ( __int64 @@a1@@ , __int64 @@a2@@ ) { unsigned __int64 @@v3@@ ; if ( * ( _BYTE * ) ( @@a2@@ + Number ) == Number && * ( _QWORD * ) ( @@a1@@ + Number ) ) { * ( _QWORD * ) ( @@a2@@ + Number ) = * ( _QWORD * ) ( Number L * ( int ) * ( _QWORD * ) ( @@a2@@ + Number ) + * ( _QWORD * ) ( @@a1@@ + Number ) ) ; * ( _QWORD * ) ( @@a1@@ + Number ) |= Number << * ( _QWORD * ) ( @@a2@@ + Number ) ; } else if ( * ( _BYTE * ) ( @@a2@@ + Number ) == Number && * ( _QWORD * ) ( @@a2@@ + Number ) && * ( _BYTE * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) == Number ) { @@v3@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) ; * ( _QWORD * ) ( @@a2@@ + Number ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) ) * * ( _QWORD * * ) ( @@a2@@ + Number ) = @@a2@@ ; * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@v3@@ ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L * * ( _QWORD * ) ( @@a2@@ + Number ) ) ; if ( @@v3@@ <= Number ) * ( _QWORD * ) ( @@a1@@ + Number ) &= ~ ( Number L << @@v3@@ ) ; } return Number L ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 __fastcall search_duplicated_node ( _QWORD * @@a1@@ , __int64 @@a2@@ , int @@a3@@ ) { __int64 @@i@@ ; for ( @@i@@ = @@a1@@ [ Number ] - Number L ; ( * ( _BYTE * ) ( Number * @@i@@ + * @@a1@@ + Number ) & Number ) != Number && @@i@@ ; -- @@i@@ ) { if ( @@a2@@ == * ( _QWORD * ) ( Number * @@i@@ + @@a1@@ [ Number ] ) && @@a3@@ == ( ( * ( _DWORD * ) ( Number * @@i@@ + * @@a1@@ + Number ) >> Number ) & Number ) ) { return @@i@@ ; } } return Number ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__int64 __fastcall calc_first ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { __int64 @@v3@@ ; if ( * ( ( _BYTE * ) @@a2@@ + Number ) == Number ) { @@a2@@ [ Number ] = * ( _QWORD * ) ( @@a2@@ [ Number ] + Number L ) ; @@a2@@ [ Number ] = * ( _QWORD * ) ( @@a2@@ [ Number ] + Number L ) ; } else { @@a2@@ [ Number ] = @@a2@@ ; @@a2@@ [ Number ] = re_dfa_add_node ( ( __int64 ) @@a1@@ , @@a2@@ [ Number ] , @@a2@@ [ Number ] ) ; if ( @@a2@@ [ Number ] == Number ) return Number L ; if ( * ( ( _BYTE * ) @@a2@@ + Number ) == Number ) { @@v3@@ = Number L * @@a2@@ [ Number ] + * @@a1@@ ; * ( _DWORD * ) ( @@v3@@ + Number ) = ( ( @@a2@@ [ Number ] & Number ) << Number ) | * ( _DWORD * ) ( @@v3@@ + Number ) & Number ; } } return Number L ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
int __fastcall lstat ( char * @@filename@@ , struct stat * @@stat_buf@@ ) { return __lxstat ( Number , @@filename@@ , @@stat_buf@@ ) ; }
_QWORD * __fastcall bitset_clear ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { _QWORD * @@result@@ ; @@result@@ = ( _QWORD * ) ( Number * ( @@a2@@ >> Number ) + @@a1@@ ) ; * @@result@@ &= ~ ( Number L << ( @@a2@@ & Number ) ) ; return @@result@@ ; }
__int64 __fastcall calc_eclosure ( __int64 @@a1@@ ) { char @@v2@@ ; unsigned int @@v3@@ ; __int64 @@i@@ ; char @@v5@@ [ Number ] ; void * @@ptr@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v2@@ = Number ; for ( @@i@@ = Number L ; ; ++ @@i@@ ) { if ( @@i@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ) { if ( @@v2@@ != Number ) return Number L ; @@v2@@ = Number ; @@i@@ = Number L ; } if ( ! * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@i@@ + Number ) ) break ; LABEL_11 : ; } @@v3@@ = calc_eclosure_iter ( @@v5@@ , @@a1@@ , @@i@@ , Number L ) ; if ( ! @@v3@@ ) { if ( ! * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@i@@ + Number ) ) { @@v2@@ = Number ; free ( @@ptr@@ ) ; } goto LABEL_11 ; } return @@v3@@ ; }
__int64 __fastcall duplicate_node ( _QWORD * @@a1@@ , __int64 @@a2@@ , __int16 @@a3@@ ) { __int64 @@v5@@ ; @@v5@@ = re_dfa_add_node ( ( __int64 ) @@a1@@ , * ( _QWORD * ) ( Number * @@a2@@ + * @@a1@@ ) , * ( _QWORD * ) ( Number * @@a2@@ + * @@a1@@ + Number ) ) ; if ( @@v5@@ != Number ) { * ( _DWORD * ) ( * @@a1@@ + Number * @@v5@@ + Number ) = ( ( @@a3@@ & Number ) << Number ) | * ( _DWORD * ) ( * @@a1@@ + Number * @@v5@@ + Number ) & Number ; * ( _DWORD * ) ( Number * @@v5@@ + * @@a1@@ + Number ) = ( ( ( ( * ( _DWORD * ) ( Number * @@a2@@ + * @@a1@@ + Number ) >> Number ) & Number | ( * ( _DWORD * ) ( Number * @@v5@@ + * @@a1@@ + Number ) >> Number ) & Number ) & Number ) << Number ) | * ( _DWORD * ) ( Number * @@v5@@ + * @@a1@@ + Number ) & Number ; * ( _BYTE * ) ( Number * @@v5@@ + * @@a1@@ + Number ) |= Number ; * ( _QWORD * ) ( @@a1@@ [ Number ] + Number * @@v5@@ ) = @@a2@@ ; } return @@v5@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
void * __fastcall bitset_empty ( void * @@a1@@ ) { return memset ( @@a1@@ , Number , Number ) ; }
__int64 __fastcall parse ( __int64 @@a1@@ , __int64 * @@a2@@ , __int64 @@a3@@ , _DWORD * @@a4@@ ) { __int64 @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; char @@v11@@ [ Number ] ; unsigned __int64 @@v12@@ ; @@v12@@ = __readfsqword ( Number ) ; @@v8@@ = * @@a2@@ ; * ( _QWORD * ) ( * @@a2@@ + Number ) = @@a3@@ ; fetch_token ( ( __int64 ) @@v11@@ , @@a1@@ , @@a3@@ | Number ) ; @@v9@@ = parse_reg_exp ( @@a1@@ , @@a2@@ , @@v11@@ , @@a3@@ , Number L , @@a4@@ ) ; if ( * @@a4@@ && ! @@v9@@ ) return Number L ; @@v10@@ = create_tree ( @@v8@@ , Number L , Number L , Number L ) ; if ( @@v9@@ ) @@v7@@ = create_tree ( @@v8@@ , @@v9@@ , @@v10@@ , Number L ) ; else @@v7@@ = @@v10@@ ; if ( @@v10@@ && @@v7@@ ) return @@v7@@ ; * @@a4@@ = Number ; return Number L ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall parse_branch ( __int64 @@a1@@ , __int64 * @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , _DWORD * @@a6@@ ) { __int64 @@v11@@ ; __int64 @@v12@@ ; __int64 @@v13@@ ; @@v12@@ = * @@a2@@ ; @@v11@@ = parse_expression ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( * @@a6@@ && ! @@v11@@ ) return Number L ; while ( * ( _BYTE * ) ( @@a3@@ + Number ) != Number && * ( _BYTE * ) ( @@a3@@ + Number ) != Number && ( ! @@a5@@ || * ( _BYTE * ) ( @@a3@@ + Number ) != Number ) ) { @@v13@@ = parse_expression ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( * @@a6@@ && ! @@v13@@ ) return Number L ; if ( @@v11@@ && @@v13@@ ) { @@v11@@ = create_tree ( @@v12@@ , @@v11@@ , @@v13@@ , Number L ) ; if ( ! @@v11@@ ) { * @@a6@@ = Number ; return Number L ; } } else if ( ! @@v11@@ ) { @@v11@@ = @@v13@@ ; } } return @@v11@@ ; }
_QWORD * __fastcall bitset_merge ( __int64 @@a1@@ , __int64 @@a2@@ ) { _QWORD * @@result@@ ; int @@i@@ ; for ( @@i@@ = Number ; @@i@@ <= Number ; ++ @@i@@ ) { @@result@@ = ( _QWORD * ) ( Number L * @@i@@ + @@a1@@ ) ; * @@result@@ |= * ( _QWORD * ) ( Number L * @@i@@ + @@a2@@ ) ; } return @@result@@ ; }
__int64 __fastcall parse_sub_exp ( __int64 @@a1@@ , __int64 * @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , _DWORD * @@a6@@ ) { unsigned __int64 @@v6@@ ; __int64 @@result@@ ; __int64 @@v12@@ ; __int64 @@v13@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; @@v14@@ = * @@a2@@ ; @@v6@@ = @@a2@@ [ Number ] ; @@a2@@ [ Number ] = @@v6@@ + Number ; @@v15@@ = @@v6@@ ; fetch_token ( @@a3@@ , @@a1@@ , @@a4@@ | Number ) ; if ( * ( _BYTE * ) ( @@a3@@ + Number ) == Number ) { @@v12@@ = Number L ; } else { @@v12@@ = parse_reg_exp ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( ! * @@a6@@ && * ( _BYTE * ) ( @@a3@@ + Number ) != Number ) * @@a6@@ = Number ; if ( * @@a6@@ ) return Number L ; } if ( @@v15@@ <= Number ) * ( _QWORD * ) ( @@v14@@ + Number ) |= Number << @@v15@@ ; @@v13@@ = create_tree ( @@v14@@ , @@v12@@ , Number L , Number L ) ; if ( @@v13@@ ) { * ( _QWORD * ) ( @@v13@@ + Number ) = @@v15@@ ; @@result@@ = @@v13@@ ; } else { * @@a6@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
int getc_unlocked ( FILE * @@stream@@ ) { return getc_unlocked ( @@stream@@ ) ; }
__int64 __fastcall build_equiv_class ( __int64 @@a1@@ , __int64 a2 , __int64 a3 , const char * @@a4@@ ) { if ( strlen ( @@a4@@ ) != Number ) return Number L ; bitset_set ( @@a1@@ , * ( unsigned __int8 * ) @@a4@@ ) ; return Number L ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_229888 ; @@v4@@ [ Number ] = qword_229890 ; @@v4@@ [ Number ] = qword_229898 ; @@v4@@ [ Number ] = qword_2298A0 ; @@v4@@ [ Number ] = qword_2298A8 ; @@v4@@ [ Number ] = qword_2298B0 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
__int64 __fastcall re_string_allocate ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , unsigned __int64 @@a4@@ , __int64 @@a5@@ , unsigned __int8 @@a6@@ , __int64 @@a7@@ ) { unsigned __int64 @@v7@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; unsigned int @@v13@@ ; unsigned __int64 @@v14@@ ; @@v11@@ = @@a4@@ ; if ( @@a4@@ < * ( int * ) ( @@a7@@ + Number ) ) @@v11@@ = * ( int * ) ( @@a7@@ + Number ) ; @@v7@@ = @@a3@@ + Number ; if ( @@v11@@ <= @@a3@@ + Number ) @@v7@@ = @@v11@@ ; @@v14@@ = @@v7@@ ; re_string_construct_common ( @@a2@@ , @@a3@@ , @@a1@@ , @@a5@@ , @@a6@@ , @@a7@@ ) ; @@v13@@ = re_string_realloc_buffers ( @@a1@@ , @@v14@@ ) ; if ( @@v13@@ ) return @@v13@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@a7@@ + Number ; * ( _BYTE * ) ( @@a1@@ + Number ) = ( * ( _BYTE * ) ( @@a7@@ + Number ) & Number ) != Number ; if ( * ( _BYTE * ) ( @@a1@@ + Number ) ) @@v9@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; else @@v9@@ = @@a2@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v9@@ ; if ( * ( _BYTE * ) ( @@a1@@ + Number ) || * ( int * ) ( @@a7@@ + Number ) > Number ) @@v10@@ = Number L ; else @@v10@@ = @@a3@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v10@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = * ( _QWORD * ) ( @@a1@@ + Number ) ; return Number L ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 __fastcall fetch_number ( __int64 @@a1@@ , unsigned __int8 * @@a2@@ , __int64 @@a3@@ ) { unsigned __int64 @@v4@@ ; unsigned __int8 @@v6@@ ; __int64 @@i@@ ; for ( @@i@@ = Number ; ; @@i@@ = @@v4@@ ) { fetch_token ( ( __int64 ) @@a2@@ , @@a1@@ , @@a3@@ ) ; @@v6@@ = * @@a2@@ ; if ( @@a2@@ [ Number ] == Number ) return Number ; if ( @@a2@@ [ Number ] == Number || @@v6@@ == Number ) break ; if ( @@a2@@ [ Number ] != Number || @@v6@@ <= Number || @@v6@@ > Number || @@i@@ == Number ) { @@v4@@ = Number ; } else if ( @@i@@ == Number ) { @@v4@@ = @@v6@@ - Number ; } else { @@v4@@ = Number * @@i@@ + @@v6@@ - Number ; } if ( @@v4@@ > Number ) @@v4@@ = Number ; } return @@i@@ ; }
void * __fastcall bitset_set_all ( void * @@a1@@ ) { return memset ( @@a1@@ , Number , Number ) ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
int tolower ( int @@c@@ ) { return tolower ( @@c@@ ) ; }
int iconv_close ( iconv_t @@cd@@ ) { return iconv_close ( @@cd@@ ) ; }
_QWORD * __fastcall bitset_mask ( __int64 @@a1@@ , __int64 @@a2@@ ) { _QWORD * @@result@@ ; int @@i@@ ; for ( @@i@@ = Number ; @@i@@ <= Number ; ++ @@i@@ ) { @@result@@ = ( _QWORD * ) ( Number L * @@i@@ + @@a1@@ ) ; * @@result@@ &= * ( _QWORD * ) ( Number L * @@i@@ + @@a2@@ ) ; } return @@result@@ ; }
wint_t towlower ( wint_t @@wc@@ ) { return towlower ( @@wc@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 __fastcall build_charclass_op ( __int64 @@a1@@ , __int64 @@a2@@ , const char * @@a3@@ , _BYTE * @@a4@@ , char @@a5@@ , _DWORD * @@a6@@ ) { int @@v11@@ ; __int64 @@v12@@ ; void * @@ptr@@ ; _BYTE * @@v14@@ ; __int64 @@v15@@ ; __int64 @@v16@@ ; void * @@v17@@ ; char @@v18@@ ; unsigned __int64 @@v19@@ ; @@v19@@ = __readfsqword ( Number ) ; @@v12@@ = Number L ; @@ptr@@ = calloc ( Number , Number ) ; @@v14@@ = calloc ( Number , Number ) ; if ( ! @@ptr@@ || ! @@v14@@ ) { * @@a6@@ = Number ; return Number L ; } if ( @@a5@@ ) @@v14@@ [ Number ] |= Number ; @@v11@@ = build_charclass ( @@a2@@ , ( __int64 ) @@ptr@@ , ( __int64 ) @@v14@@ , & @@v12@@ , @@a3@@ , Number ) ; if ( @@v11@@ ) { free ( @@ptr@@ ) ; free_charset ( @@v14@@ ) ; * @@a6@@ = @@v11@@ ; return Number L ; } while ( * @@a4@@ ) bitset_set ( ( __int64 ) @@ptr@@ , ( unsigned __int8 ) * @@a4@@ ++ ) ; if ( @@a5@@ ) bitset_not ( ( __int64 ) @@ptr@@ ) ; if ( * ( int * ) ( @@a1@@ + Number ) > Number ) bitset_mask ( ( __int64 ) @@ptr@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ; @@v18@@ = Number ; @@v17@@ = @@ptr@@ ; @@v15@@ = create_token_tree ( @@a1@@ , Number L , Number L , & @@v17@@ ) ; if ( @@v15@@ ) { if ( * ( int * ) ( @@a1@@ + Number ) <= Number ) { free_charset ( @@v14@@ ) ; return @@v15@@ ; } @@v18@@ = Number ; @@v17@@ = @@v14@@ ; * ( _BYTE * ) ( @@a1@@ + Number ) |= Number ; @@v16@@ = create_token_tree ( @@a1@@ , Number L , Number L , & @@v17@@ ) ; if ( @@v16@@ ) { @@v15@@ = create_tree ( @@a1@@ , @@v15@@ , @@v16@@ , Number L ) ; if ( @@v16@@ ) return @@v15@@ ; } } free ( @@ptr@@ ) ; free_charset ( @@v14@@ ) ; * @@a6@@ = Number ; return Number L ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
__int64 __fastcall re_string_peek_byte_case ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; __int64 @@v3@@ ; if ( ! * ( _BYTE * ) ( @@a1@@ + Number ) ) return * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ ) ; if ( * ( int * ) ( @@a1@@ + Number ) > Number && ( * ( _DWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ ) ) == Number || * ( _QWORD * ) ( @@a1@@ + Number ) != * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ + Number && * ( _DWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ + Number ) ) == Number ) ) { return * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ ) ; } @@v3@@ = * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ ; if ( * ( _BYTE * ) ( @@a1@@ + Number ) ) @@v3@@ = * ( _QWORD * ) ( Number * @@v3@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) ; if ( * ( _BYTE * ) ( @@a1@@ + Number ) && ( * ( _BYTE * ) ( * ( _QWORD * ) @@a1@@ + * ( _QWORD * ) ( @@a1@@ + Number ) + @@v3@@ ) & Number ) != Number ) { @@result@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ ) ; } else { @@result@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) @@a1@@ + * ( _QWORD * ) ( @@a1@@ + Number ) + @@v3@@ ) ; } return @@result@@ ; }
__int64 __fastcall duplicate_tree ( __int64 * * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v4@@ ; __int64 * @@v5@@ ; __int64 * @@v6@@ ; __int64 * @@v7@@ ; __int64 * @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ = & @@v4@@ ; @@v7@@ = * @@a1@@ ; @@v5@@ = ( __int64 * ) @@a1@@ ; while ( Number ) { @@v2@@ = create_token_tree ( @@a2@@ , Number L , Number L , @@v5@@ + Number ) ; * @@v6@@ = @@v2@@ ; if ( ! * @@v6@@ ) break ; * ( _QWORD * ) * @@v6@@ = @@v7@@ ; * ( _BYTE * ) ( * @@v6@@ + Number ) |= Number ; @@v7@@ = ( __int64 * ) * @@v6@@ ; if ( @@v5@@ [ Number ] ) { @@v5@@ = ( __int64 * ) @@v5@@ [ Number ] ; @@v6@@ = @@v7@@ + Number ; } else { @@v8@@ = Number L ; while ( @@v8@@ == ( __int64 * ) @@v5@@ [ Number ] || ! @@v5@@ [ Number ] ) { @@v8@@ = @@v5@@ ; @@v5@@ = ( __int64 * ) * @@v5@@ ; @@v7@@ = ( __int64 * ) * @@v7@@ ; if ( ! @@v5@@ ) return @@v4@@ ; } @@v5@@ = ( __int64 * ) @@v5@@ [ Number ] ; @@v6@@ = @@v7@@ + Number ; } } return Number L ; }
__int64 __fastcall re_string_construct ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ , unsigned __int8 @@a5@@ , __int64 @@a6@@ ) { __int64 @@v7@@ ; unsigned int @@v12@@ ; unsigned int @@v13@@ ; unsigned int @@v14@@ ; memset ( ( void * ) @@a1@@ , Number , Number ) ; re_string_construct_common ( @@a2@@ , @@a3@@ , @@a1@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( @@a3@@ ) { @@v12@@ = re_string_realloc_buffers ( @@a1@@ , @@a3@@ + Number ) ; if ( @@v12@@ ) return @@v12@@ ; } if ( * ( _BYTE * ) ( @@a1@@ + Number ) ) @@v7@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; else @@v7@@ = @@a2@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v7@@ ; if ( ! @@a5@@ ) { if ( * ( int * ) ( @@a6@@ + Number ) <= Number ) { if ( @@a4@@ ) { re_string_translate_buffer ( @@a1@@ ) ; } else { * ( _QWORD * ) ( @@a1@@ + Number ) = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = * ( _QWORD * ) ( @@a1@@ + Number ) ; } } else { build_wcs_buffer ( @@a1@@ ) ; } return Number L ; } if ( * ( int * ) ( @@a6@@ + Number ) <= Number ) { build_upper_buffer ( @@a1@@ ) ; return Number L ; } do { @@v13@@ = build_wcs_upper_buffer ( @@a1@@ ) ; if ( @@v13@@ ) return @@v13@@ ; if ( @@a3@@ <= * ( _QWORD * ) ( @@a1@@ + Number ) || * ( _QWORD * ) ( @@a1@@ + Number ) > ( unsigned __int64 ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + * ( int * ) ( @@a6@@ + Number ) ) ) { return Number L ; } @@v14@@ = re_string_realloc_buffers ( @@a1@@ , Number L * * ( _QWORD * ) ( @@a1@@ + Number ) ) ; } while ( ! @@v14@@ ) ; return @@v14@@ ; }
__int64 __fastcall rpl_re_search_2 ( int @@a1@@ , int @@a2@@ , int @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ , __int64 @@a7@@ , __int64 @@a8@@ , __int64 @@a9@@ ) { return re_search_2_stub ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ , @@a7@@ , @@a8@@ , @@a9@@ , Number ) ; }
__int64 __fastcall compare_words ( const void * @@a1@@ , const void * @@a2@@ ) { __int16 @@v2@@ ; int @@v3@@ ; int @@v5@@ ; int @@i@@ ; int @@j@@ ; int @@v8@@ ; unsigned int @@v9@@ ; unsigned int @@v10@@ ; @@v2@@ = * ( ( _WORD * ) @@a1@@ + Number ) ; if ( * ( ( __int16 * ) @@a2@@ + Number ) <= @@v2@@ ) @@v2@@ = * ( ( _WORD * ) @@a2@@ + Number ) ; @@v8@@ = @@v2@@ ; if ( ignore_case ) { for ( @@i@@ = Number ; @@i@@ < @@v8@@ ; ++ @@i@@ ) { @@v3@@ = ( unsigned __int8 ) folded_chars [ ( unsigned __int8 ) to_uchar ( * ( _BYTE * ) ( * ( _QWORD * ) @@a1@@ + @@i@@ ) ) ] ; @@v9@@ = @@v3@@ - ( unsigned __int8 ) folded_chars [ ( unsigned __int8 ) to_uchar ( * ( _BYTE * ) ( * ( _QWORD * ) @@a2@@ + @@i@@ ) ) ] ; if ( @@v9@@ ) return @@v9@@ ; } } else { for ( @@j@@ = Number ; @@j@@ < @@v8@@ ; ++ @@j@@ ) { @@v5@@ = ( unsigned __int8 ) to_uchar ( * ( _BYTE * ) ( * ( _QWORD * ) @@a1@@ + @@j@@ ) ) ; @@v10@@ = @@v5@@ - ( unsigned __int8 ) to_uchar ( * ( _BYTE * ) ( * ( _QWORD * ) @@a2@@ + @@j@@ ) ) ; if ( @@v10@@ ) return @@v10@@ ; } } return ( unsigned int ) ( * ( ( __int16 * ) @@a1@@ + Number ) - * ( ( __int16 * ) @@a2@@ + Number ) ) ; }
bool __fastcall re_node_set_insert ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { __int64 @@i@@ ; void * @@v4@@ ; if ( ! * ( _QWORD * ) @@a1@@ ) return ( unsigned int ) re_node_set_init_1 ( ( _QWORD * ) @@a1@@ , @@a2@@ ) == Number ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) { * * ( _QWORD * * ) ( @@a1@@ + Number ) = @@a2@@ ; ++ * ( _QWORD * ) ( @@a1@@ + Number ) ; return Number ; } if ( * ( _QWORD * ) @@a1@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ) { * ( _QWORD * ) @@a1@@ *= Number L ; @@v4@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number L * * ( _QWORD * ) @@a1@@ ) ; if ( ! @@v4@@ ) return Number ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v4@@ ; } if ( @@a2@@ >= * * ( _QWORD * * ) ( @@a1@@ + Number ) ) { for ( @@i@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@a2@@ < * ( _QWORD * ) ( Number * @@i@@ - Number + * ( _QWORD * ) ( @@a1@@ + Number ) ) ; -- @@i@@ ) { * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@i@@ ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@i@@ - Number ) ; } } else { for ( @@i@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ ; -- @@i@@ ) * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@i@@ ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@i@@ - Number ) ; } * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@i@@ ) = @@a2@@ ; ++ * ( _QWORD * ) ( @@a1@@ + Number ) ; return Number ; }
_BOOL8 __fastcall check_halt_node_context ( _QWORD * @@a1@@ , __int64 @@a2@@ , char @@a3@@ ) { if ( * ( _BYTE * ) ( Number * @@a2@@ + * @@a1@@ + Number ) != Number ) return Number L ; if ( ( ( * ( _DWORD * ) ( Number * @@a2@@ + * @@a1@@ + Number ) >> Number ) & Number ) == Number ) return Number L ; return ( ( * ( _DWORD * ) ( Number * @@a2@@ + * @@a1@@ + Number ) & Number ) == Number || ( @@a3@@ & Number ) != Number ) && ( ( * ( _DWORD * ) ( Number * @@a2@@ + * @@a1@@ + Number ) & Number ) == Number || ( @@a3@@ & Number ) == Number ) && ( ( * ( _DWORD * ) ( Number * @@a2@@ + * @@a1@@ + Number ) & Number ) == Number || ( @@a3@@ & Number ) != Number ) && ( ( * ( _DWORD * ) ( Number * @@a2@@ + * @@a1@@ + Number ) & Number ) == Number || ( @@a3@@ & Number ) != Number ) ; }
__int64 __fastcall re_string_context_at ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , char @@a3@@ ) { __int64 @@result@@ ; int @@v4@@ ; wint_t @@wc@@ ; unsigned __int64 @@v6@@ ; if ( @@a2@@ > Number ) return * ( unsigned int * ) ( @@a1@@ + Number ) ; if ( @@a2@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ) { if ( ( @@a3@@ & Number ) != Number ) @@result@@ = Number L ; else @@result@@ = Number L ; } else if ( * ( int * ) ( @@a1@@ + Number ) <= Number ) { @@v4@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ ) ; if ( bitset_contain ( * ( _QWORD * ) ( @@a1@@ + Number ) , * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ ) ) ) { @@result@@ = Number L ; } else if ( @@v4@@ == Number && * ( _BYTE * ) ( @@a1@@ + Number ) ) { @@result@@ = Number L ; } else { @@result@@ = Number L ; } } else { @@v6@@ = @@a2@@ ; while ( * ( _DWORD * ) ( Number * @@v6@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) == Number ) { if ( -- @@v6@@ > Number ) return * ( unsigned int * ) ( @@a1@@ + Number ) ; } @@wc@@ = * ( _DWORD * ) ( Number * @@v6@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) ; if ( * ( _BYTE * ) ( @@a1@@ + Number ) && ( iswalnum ( @@wc@@ ) || @@wc@@ == Number ) ) { @@result@@ = Number L ; } else if ( @@wc@@ == Number && * ( _BYTE * ) ( @@a1@@ + Number ) ) { @@result@@ = Number L ; } else { @@result@@ = Number L ; } } return @@result@@ ; }
_QWORD * __fastcall rpl_re_set_registers ( __int64 @@a1@@ , _QWORD * @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ ) { _QWORD * @@result@@ ; if ( @@a3@@ ) { * ( _BYTE * ) ( @@a1@@ + Number ) = * ( _BYTE * ) ( @@a1@@ + Number ) & Number | Number ; * @@a2@@ = @@a3@@ ; @@a2@@ [ Number ] = @@a4@@ ; @@result@@ = @@a2@@ ; @@a2@@ [ Number ] = @@a5@@ ; } else { * ( _BYTE * ) ( @@a1@@ + Number ) &= Number ; * @@a2@@ = Number L ; @@a2@@ [ Number ] = Number L ; @@result@@ = @@a2@@ ; @@a2@@ [ Number ] = @@a2@@ [ Number ] ; } return @@result@@ ; }
char * __fastcall rpl_re_compile_pattern ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { char * @@result@@ ; int @@v4@@ ; * ( _BYTE * ) ( @@a3@@ + Number ) = ( Number * ( ( rpl_re_syntax_options & Number ) != Number ) ) | * ( _BYTE * ) ( @@a3@@ + Number ) & Number ; * ( _BYTE * ) ( @@a3@@ + Number ) |= Number ; @@v4@@ = re_compile_internal ( @@a3@@ , @@a1@@ , @@a2@@ , rpl_re_syntax_options ) ; if ( @@v4@@ ) @@result@@ = gettext ( & _re_error_msgid [ _re_error_msgid_idx [ @@v4@@ ] ] ) ; else @@result@@ = Number L ; return @@result@@ ; }
__int64 __fastcall free_fail_stack_return ( __int64 @@a1@@ ) { unsigned __int64 @@i@@ ; if ( @@a1@@ ) { for ( @@i@@ = Number L ; @@i@@ < * ( _QWORD * ) @@a1@@ ; ++ @@i@@ ) { free ( * ( void * * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@i@@ + Number ) ) ; free ( * ( void * * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@i@@ + Number ) ) ; } free ( * ( void * * ) ( @@a1@@ + Number ) ) ; } return Number L ; }
unsigned __int64 fix_output_parameters ( ) { int @@i@@ ; unsigned int @@v2@@ ; int @@v3@@ ; int @@j@@ ; int @@l@@ ; unsigned __int8 * @@k@@ ; char @@s@@ [ Number ] ; unsigned __int64 @@v8@@ ; @@v8@@ = __readfsqword ( Number ) ; if ( auto_reference ) { reference_max_width = Number ; for ( @@i@@ = Number ; @@i@@ < number_input_files ; ++ @@i@@ ) { @@v2@@ = * ( _DWORD * ) ( Number L * @@i@@ + file_line_count ) + Number ; if ( @@i@@ > Number ) @@v2@@ -= * ( _DWORD * ) ( Number L * @@i@@ - Number + file_line_count ) ; sprintf ( @@s@@ , String , @@v2@@ ) ; @@v3@@ = strlen ( @@s@@ ) ; if ( * ( _QWORD * ) ( Number L * @@i@@ + input_file_name ) ) @@v3@@ += strlen ( * ( const char * * ) ( Number L * @@i@@ + input_file_name ) ) ; if ( @@v3@@ > reference_max_width ) reference_max_width = @@v3@@ ; } reference = ( char * ) xmalloc ( ++ reference_max_width + Number L ) ; } if ( ( auto_reference || input_reference ) && right_reference != Number ) line_width -= reference_max_width + gap_size ; half_line_width = line_width / Number ; before_max_width = line_width / Number - gap_size ; keyafter_max_width = line_width / Number ; if ( truncation_string && * truncation_string ) truncation_string_length = strlen ( truncation_string ) ; else truncation_string = Number L ; if ( gnu_extensions ) { before_max_width -= Number * truncation_string_length ; if ( before_max_width < Number ) before_max_width = Number ; keyafter_max_width -= Number * truncation_string_length ; } else { keyafter_max_width -= Number * truncation_string_length + Number ; } for ( @@j@@ = Number ; @@j@@ <= Number ; ++ @@j@@ ) edited_flag [ @@j@@ ] = ( ( * __ctype_b_loc ( ) ) [ @@j@@ ] & Number ) != Number ; byte_2296CC = Number ; if ( output_format == Number ) { byte_2296E2 = Number ; } else if ( ( unsigned int ) output_format >= Number && output_format == Number ) { for ( @@k@@ = String ; * @@k@@ ; ++ @@k@@ ) edited_flag [ ( unsigned __int8 ) to_uchar ( * @@k@@ ) ] = Number ; for ( @@l@@ = Number ; @@l@@ <= Number ; ++ @@l@@ ) edited_flag [ @@l@@ ] = diacrit_diac [ ( unsigned __int8 ) @@l@@ ] != Number ; } return __readfsqword ( Number ) ^ @@v8@@ ; }
__int64 __fastcall re_node_set_insert_last ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v3@@ ; __int64 @@v4@@ ; void * @@v6@@ ; if ( * ( _QWORD * ) @@a1@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ) { * ( _QWORD * ) @@a1@@ = Number * ( * ( _QWORD * ) @@a1@@ + Number L ) ; @@v6@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number L * * ( _QWORD * ) @@a1@@ ) ; if ( ! @@v6@@ ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v6@@ ; } @@v3@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v4@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v4@@ + Number ; * ( _QWORD * ) ( @@v3@@ + Number * @@v4@@ ) = @@a2@@ ; return Number L ; }
__int64 __fastcall check_halt_state_context ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { char @@v4@@ ; unsigned __int64 @@i@@ ; @@v4@@ = re_string_context_at ( @@a1@@ , @@a3@@ , * ( _DWORD * ) ( @@a1@@ + Number ) ) ; for ( @@i@@ = Number L ; @@i@@ < * ( _QWORD * ) ( @@a2@@ + Number ) ; ++ @@i@@ ) { if ( check_halt_node_context ( * ( _QWORD * * ) ( @@a1@@ + Number ) , * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) , @@v4@@ ) ) { return * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) ; } } return Number L ; }
__int64 __fastcall rpl_regcomp ( __int64 @@a1@@ , const char * @@a2@@ , int @@a3@@ ) { __int64 @@v3@@ ; size_t @@v5@@ ; unsigned int @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; if ( ( @@a3@@ & Number ) != Number ) @@v3@@ = Number L ; else @@v3@@ = Number L ; @@v8@@ = @@v3@@ ; * ( _QWORD * ) @@a1@@ = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = malloc ( Number ) ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; @@v9@@ = ( @@a3@@ << Number ) & Number | ( unsigned __int64 ) @@v8@@ ; if ( ( @@a3@@ & Number ) != Number ) { @@v9@@ = @@v9@@ & Number | Number ; * ( _BYTE * ) ( @@a1@@ + Number ) |= Number ; } else { * ( _BYTE * ) ( @@a1@@ + Number ) &= Number ; } * ( _BYTE * ) ( @@a1@@ + Number ) = ( Number * ( ( @@a3@@ & Number ) != Number ) ) | * ( _BYTE * ) ( @@a1@@ + Number ) & Number ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; @@v5@@ = strlen ( @@a2@@ ) ; @@v7@@ = re_compile_internal ( @@a1@@ , @@a2@@ , @@v5@@ , @@v9@@ ) ; if ( @@v7@@ == Number ) @@v7@@ = Number ; if ( @@v7@@ ) { free ( * ( void * * ) ( @@a1@@ + Number ) ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; } else { rpl_re_compile_fastmap ( @@a1@@ ) ; } return @@v7@@ ; }
_QWORD * __fastcall update_regs ( _QWORD * @@a1@@ , _QWORD * @@a2@@ , void * @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ , unsigned __int64 @@a6@@ ) { _QWORD * @@result@@ ; int @@v7@@ ; unsigned __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@result@@ = ( _QWORD * ) * ( unsigned __int8 * ) ( Number * @@a4@@ + * @@a1@@ + Number ) ; @@v7@@ = * ( unsigned __int8 * ) ( Number * @@a4@@ + * @@a1@@ + Number ) ; if ( @@v7@@ == Number ) { @@v9@@ = * ( _QWORD * ) ( Number * @@a4@@ + * @@a1@@ ) + Number L ; @@result@@ = ( _QWORD * ) @@v9@@ ; if ( @@v9@@ < @@a6@@ ) { @@a2@@ [ Number * @@v9@@ ] = @@a5@@ ; @@result@@ = & @@a2@@ [ Number * @@v9@@ ] ; @@result@@ [ Number ] = Number ; } } else if ( @@v7@@ == Number ) { @@v8@@ = * ( _QWORD * ) ( Number * @@a4@@ + * @@a1@@ ) + Number L ; @@result@@ = ( _QWORD * ) @@v8@@ ; if ( @@v8@@ < @@a6@@ ) { if ( ( unsigned __int64 ) @@a5@@ <= @@a2@@ [ Number * @@v8@@ ] ) { if ( ( * ( _BYTE * ) ( Number * @@a4@@ + * @@a1@@ + Number ) & Number ) == Number || * ( ( _QWORD * ) @@a3@@ + Number * @@v8@@ ) == Number ) { @@result@@ = @@a5@@ ; @@a2@@ [ Number * @@v8@@ + Number ] = @@a5@@ ; } else { @@result@@ = memcpy ( @@a2@@ , @@a3@@ , Number * @@a6@@ ) ; } } else { @@a2@@ [ Number * @@v8@@ + Number ] = @@a5@@ ; @@result@@ = memcpy ( @@a3@@ , @@a2@@ , Number * @@a6@@ ) ; } } } return @@result@@ ; }
__int64 __fastcall strnlen1 ( const void * @@a1@@ , size_t @@a2@@ ) { __int64 @@result@@ ; _BYTE * @@v3@@ ; @@v3@@ = memchr ( @@a1@@ , Number , @@a2@@ ) ; if ( @@v3@@ ) @@result@@ = @@v3@@ - ( _BYTE * ) @@a1@@ + Number ; else @@result@@ = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall calc_state_hash ( __int64 @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v3@@ ; unsigned __int64 @@i@@ ; @@v3@@ = * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ ; for ( @@i@@ = Number L ; @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; ++ @@i@@ ) @@v3@@ += * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) ; return @@v3@@ ; }
__int64 __fastcall pop_fail_stack ( _QWORD * @@a1@@ , _QWORD * @@a2@@ , __int64 @@a3@@ , void * @@a4@@ , __int64 @@a5@@ ) { _QWORD * @@v5@@ ; __int64 @@v6@@ ; __int64 @@v9@@ ; @@v9@@ = -- * @@a1@@ ; if ( * @@a1@@ > Number ) __assert_fail ( String , String , Number , String ) ; * @@a2@@ = * ( _QWORD * ) ( @@a1@@ [ Number ] + Number * @@v9@@ ) ; memcpy ( @@a4@@ , * ( const void * * ) ( @@a1@@ [ Number ] + Number * @@v9@@ + Number ) , Number * @@a3@@ ) ; free ( * ( void * * ) ( @@a5@@ + Number ) ) ; free ( * ( void * * ) ( @@a1@@ [ Number ] + Number * @@v9@@ + Number ) ) ; @@v5@@ = ( _QWORD * ) ( @@a1@@ [ Number ] + Number * @@v9@@ ) ; @@v6@@ = @@v5@@ [ Number ] ; * ( _QWORD * ) @@a5@@ = @@v5@@ [ Number ] ; * ( _QWORD * ) ( @@a5@@ + Number ) = @@v6@@ ; * ( _QWORD * ) ( @@a5@@ + Number ) = @@v5@@ [ Number ] ; return * ( _QWORD * ) ( @@a1@@ [ Number ] + Number * @@v9@@ + Number ) ; }
__int64 __fastcall preorder ( _QWORD * @@a1@@ , __int64 ( __fastcall * @@a2@@ ) ( __int64 , _QWORD * ) , __int64 @@a3@@ ) { __int64 @@result@@ ; _QWORD * @@v5@@ ; _QWORD * @@v6@@ ; @@v5@@ = @@a1@@ ; LODWORD ( @@result@@ ) = @@a2@@ ( @@a3@@ , @@a1@@ ) ; while ( ! ( _DWORD ) @@result@@ ) { if ( @@v5@@ [ Number ] ) { @@v5@@ = ( _QWORD * ) @@v5@@ [ Number ] ; LODWORD ( @@result@@ ) = @@a2@@ ( @@a3@@ , @@v5@@ ) ; } else { @@v6@@ = Number L ; while ( @@v6@@ == ( _QWORD * ) @@v5@@ [ Number ] || ! @@v5@@ [ Number ] ) { @@v6@@ = @@v5@@ ; @@v5@@ = ( _QWORD * ) * @@v5@@ ; if ( ! @@v5@@ ) return Number L ; } @@v5@@ = ( _QWORD * ) @@v5@@ [ Number ] ; LODWORD ( @@result@@ ) = @@a2@@ ( @@a3@@ , @@v5@@ ) ; } } return ( unsigned int ) @@result@@ ; }
__int64 __fastcall xstr_iconv ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v4@@ ; @@v4@@ = str_iconv ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( ! @@v4@@ && * __errno_location ( ) == Number ) xalloc_die ( ) ; return @@v4@@ ; }
__int64 __fastcall re_acquire_state_context ( _DWORD * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , unsigned int @@a4@@ ) { __int64 @@result@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ ; unsigned __int64 * @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; if ( * ( _QWORD * ) ( @@a3@@ + Number ) ) { @@v8@@ = calc_state_hash ( @@a3@@ , @@a4@@ ) ; @@v9@@ = ( unsigned __int64 * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number * ( @@v8@@ & * ( _QWORD * ) ( @@a2@@ + Number ) ) ) ; for ( @@i@@ = Number L ; @@i@@ < * @@v9@@ ; ++ @@i@@ ) { @@v11@@ = * ( _QWORD * ) ( Number * @@i@@ + @@v9@@ [ Number ] ) ; if ( @@v8@@ == * ( _QWORD * ) @@v11@@ && @@a4@@ == ( * ( _BYTE * ) ( @@v11@@ + Number ) & Number ) && ( unsigned __int8 ) re_node_set_compare ( * ( _QWORD * ) ( @@v11@@ + Number ) , @@a3@@ ) ) { return @@v11@@ ; } } @@v10@@ = create_cd_newstate ( @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ ) ; if ( ! @@v10@@ ) * @@a1@@ = Number ; @@result@@ = @@v10@@ ; } else { * @@a1@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall check_dst_limits_calc_pos_1 ( __int64 @@a1@@ , int @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ ) { int @@v5@@ ; __int64 @@result@@ ; __int64 @@v7@@ ; int @@v11@@ ; unsigned __int64 @@i@@ ; __int64 @@v13@@ ; _QWORD * @@v14@@ ; __int64 @@v15@@ ; __int64 @@v16@@ ; __int64 @@v17@@ ; @@v14@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; @@v15@@ = @@v14@@ [ Number ] + Number * @@a4@@ ; for ( @@i@@ = Number L ; ; ++ @@i@@ ) { if ( @@i@@ >= * ( _QWORD * ) ( @@v15@@ + Number ) ) return ( @@a2@@ >> Number ) & Number ; @@v16@@ = * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@v15@@ + Number ) ) ; @@v5@@ = * ( unsigned __int8 * ) ( Number * @@v16@@ + * @@v14@@ + Number ) ; if ( @@v5@@ == Number ) { if ( ( @@a2@@ & Number ) != Number && @@a3@@ == * ( _QWORD * ) ( Number * @@v16@@ + * @@v14@@ ) ) { return Number ; } continue ; } if ( @@v5@@ != Number ) break ; if ( ( @@a2@@ & Number ) != Number && @@a3@@ == * ( _QWORD * ) ( Number * @@v16@@ + * @@v14@@ ) ) { return Number L ; } LABEL_29 : ; } if ( @@v5@@ != Number || @@a5@@ == Number ) goto LABEL_29 ; @@v13@@ = * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@a5@@ ; while ( Number ) { if ( @@v16@@ != * ( _QWORD * ) @@v13@@ || @@a3@@ <= Number && ( ( * ( unsigned __int16 * ) ( @@v13@@ + Number ) >> @@a3@@ ) & Number L ) == Number ) { goto LABEL_21 ; } @@v17@@ = * * ( _QWORD * * ) ( @@v14@@ [ Number ] + Number * @@v16@@ + Number ) ; if ( @@v17@@ == @@a4@@ ) break ; @@v11@@ = check_dst_limits_calc_pos_1 ( @@a1@@ , @@a2@@ , @@a3@@ , @@v17@@ , @@a5@@ ) ; if ( @@v11@@ == Number ) return Number ; if ( ! @@v11@@ && ( @@a2@@ & Number ) != Number ) return Number L ; if ( @@a3@@ <= Number ) * ( _WORD * ) ( @@v13@@ + Number ) &= ~ ( unsigned __int16 ) ( Number L << @@a3@@ ) ; LABEL_21 : @@v7@@ = @@v13@@ ; @@v13@@ += Number L ; if ( ! * ( _BYTE * ) ( @@v7@@ + Number ) ) goto LABEL_29 ; } if ( ( @@a2@@ & Number ) != Number ) @@result@@ = Number ; else @@result@@ = Number L ; return @@result@@ ; }
__int64 __fastcall build_sifted_states ( __int64 @@a1@@ , _QWORD * @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ ) { int @@v7@@ ; unsigned __int64 @@i@@ ; _QWORD * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; @@v9@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; @@v10@@ = * ( _QWORD * ) ( Number * @@a3@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) + Number L ; for ( @@i@@ = Number L ; @@i@@ < * ( _QWORD * ) ( @@v10@@ + Number ) ; ++ @@i@@ ) { @@v11@@ = * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@v10@@ + Number ) ) ; @@v7@@ = Number ; if ( ( * ( _BYTE * ) ( Number * @@v11@@ + * @@v9@@ + Number ) & Number ) != Number ) @@v7@@ = sift_states_iter_mb ( @@a1@@ , @@a2@@ , @@v11@@ , @@a3@@ , @@a2@@ [ Number ] ) ; if ( ! @@v7@@ && ( unsigned __int8 ) check_node_accept ( @@a1@@ , * @@v9@@ + Number * @@v11@@ , @@a3@@ ) && * ( _QWORD * ) ( Number * ( @@a3@@ + Number ) + * @@a2@@ ) && re_node_set_contains ( * ( _QWORD * ) ( Number * ( @@a3@@ + Number ) + * @@a2@@ ) + Number L , * ( _QWORD * ) ( Number * @@v11@@ + @@v9@@ [ Number ] ) ) ) { @@v7@@ = Number ; } if ( @@v7@@ && ( ! @@a2@@ [ Number ] || ! ( unsigned __int8 ) check_dst_limits ( @@a1@@ , @@a2@@ + Number , * ( _QWORD * ) ( Number * @@v11@@ + @@v9@@ [ Number ] ) , @@v7@@ + @@a3@@ , @@v11@@ , @@a3@@ ) ) && ! re_node_set_insert ( @@a4@@ , @@v11@@ ) ) { return Number L ; } } return Number L ; }
size_t __fastcall rpl_regerror ( int @@a1@@ , __int64 a2 , _BYTE * @@a3@@ , size_t @@a4@@ ) { size_t @@n@@ ; const char * @@s@@ ; size_t @@v9@@ ; if ( @@a1@@ < Number || @@a1@@ > Number ) abort ( ) ; @@s@@ = gettext ( & _re_error_msgid [ _re_error_msgid_idx [ @@a1@@ ] ] ) ; @@v9@@ = strlen ( @@s@@ ) + Number ; if ( @@a4@@ ) { @@n@@ = @@v9@@ ; if ( @@v9@@ > @@a4@@ ) { @@n@@ = @@a4@@ - Number ; @@a3@@ [ @@a4@@ - Number ] = Number ; } memcpy ( @@a3@@ , @@s@@ , @@n@@ ) ; } return @@v9@@ ; }
void __fastcall argmatch_invalid ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { char * @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; char * @@format@@ ; if ( @@a3@@ == Number ) @@v3@@ = gettext ( String ) ; else @@v3@@ = gettext ( String ) ; @@format@@ = @@v3@@ ; @@v4@@ = quote_n ( Number L , @@a1@@ ) ; @@v5@@ = quotearg_n_style ( Number L , Number L , @@a2@@ ) ; error ( Number , Number , @@format@@ , @@v5@@ , @@v4@@ ) ; }
__int64 __fastcall lower_subexp ( _DWORD * @@a1@@ , __int64 * @@a2@@ , __int64 @@a3@@ ) { __int64 @@result@@ ; __int64 @@v4@@ ; _BOOL4 @@v5@@ ; _BOOL4 @@v6@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; __int64 @@v12@@ ; __int64 @@v13@@ ; @@v8@@ = * @@a2@@ ; @@v9@@ = * ( _QWORD * ) ( @@a3@@ + Number ) ; if ( ( @@a2@@ [ Number ] & Number ) != Number && * ( _QWORD * ) ( @@a3@@ + Number ) && ( * ( _QWORD * ) ( @@a3@@ + Number ) > Number || ( ( * ( _QWORD * ) ( @@v8@@ + Number ) >> * ( _QWORD * ) ( @@a3@@ + Number ) ) & Number L ) == Number ) ) { return * ( _QWORD * ) ( @@a3@@ + Number ) ; } @@v10@@ = create_tree ( @@v8@@ , Number L , Number L , Number L ) ; @@v11@@ = create_tree ( @@v8@@ , Number L , Number L , Number L ) ; if ( @@v9@@ ) @@v4@@ = create_tree ( @@v8@@ , @@v9@@ , @@v11@@ , Number L ) ; else @@v4@@ = @@v11@@ ; @@v12@@ = @@v4@@ ; @@v13@@ = create_tree ( @@v8@@ , @@v10@@ , @@v4@@ , Number L ) ; @@v5@@ = ! @@v13@@ || ! @@v12@@ ; @@v6@@ = @@v5@@ || ! @@v10@@ ; if ( ! @@v6@@ && @@v11@@ ) { * ( _QWORD * ) ( @@v11@@ + Number ) = * ( _QWORD * ) ( @@a3@@ + Number ) ; * ( _QWORD * ) ( @@v10@@ + Number ) = * ( _QWORD * ) ( @@v11@@ + Number ) ; * ( _BYTE * ) ( @@v11@@ + Number ) = ( Number * ( ( * ( _BYTE * ) ( @@a3@@ + Number ) & Number ) != Number ) ) | * ( _BYTE * ) ( @@v11@@ + Number ) & Number ; * ( _BYTE * ) ( @@v10@@ + Number ) = ( Number * ( ( * ( _BYTE * ) ( @@v11@@ + Number ) & Number ) != Number ) ) | * ( _BYTE * ) ( @@v10@@ + Number ) & Number ; @@result@@ = @@v13@@ ; } else { * @@a1@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall check_arrival_expand_ecl ( _QWORD * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , unsigned int @@a4@@ ) { __int64 @@v5@@ ; unsigned int @@v8@@ ; unsigned int @@v9@@ ; unsigned __int64 @@i@@ ; __int64 @@v11@@ ; __int64 @@v12@@ ; __int64 @@v13@@ [ Number ] ; void * @@ptr@@ ; unsigned __int64 @@v15@@ ; @@v15@@ = __readfsqword ( Number ) ; @@v8@@ = re_node_set_alloc ( @@v13@@ , * ( _QWORD * ) ( @@a2@@ + Number ) ) ; if ( @@v8@@ ) return @@v8@@ ; for ( @@i@@ = Number L ; @@i@@ < * ( _QWORD * ) ( @@a2@@ + Number ) ; ++ @@i@@ ) { @@v11@@ = * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) ; @@v12@@ = @@a1@@ [ Number ] + Number * @@v11@@ ; if ( find_subexp_node ( @@a1@@ , @@v12@@ , @@a3@@ , @@a4@@ ) == Number ) { @@v9@@ = re_node_set_merge ( ( __int64 ) @@v13@@ , @@v12@@ ) ; if ( @@v9@@ ) goto LABEL_6 ; } else { @@v9@@ = check_arrival_expand_ecl_sub ( @@a1@@ , @@v13@@ , @@v11@@ , @@a3@@ , @@a4@@ ) ; if ( @@v9@@ ) { LABEL_6 : free ( @@ptr@@ ) ; return @@v9@@ ; } } } free ( * ( void * * ) ( @@a2@@ + Number ) ) ; @@v5@@ = @@v13@@ [ Number ] ; * ( _QWORD * ) @@a2@@ = @@v13@@ [ Number ] ; * ( _QWORD * ) ( @@a2@@ + Number ) = @@v5@@ ; * ( _QWORD * ) ( @@a2@@ + Number ) = @@ptr@@ ; return Number L ; }
__int64 __fastcall check_dst_limits ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ ) { unsigned __int64 @@i@@ ; _QWORD * @@v12@@ ; __int64 @@v13@@ ; __int64 @@v14@@ ; __int64 @@v15@@ ; __int64 @@v16@@ ; @@v12@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; @@v13@@ = search_cur_bkref_entry ( @@a1@@ , @@a4@@ ) ; @@v14@@ = search_cur_bkref_entry ( @@a1@@ , @@a6@@ ) ; for ( @@i@@ = Number L ; @@i@@ < * ( _QWORD * ) ( @@a2@@ + Number ) ; ++ @@i@@ ) { @@v15@@ = * ( _QWORD * ) ( * @@v12@@ + Number L * * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L * * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) ) ) ; @@v16@@ = ( int ) check_dst_limits_calc_pos ( @@a1@@ , * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) , @@v15@@ , @@a3@@ , @@a4@@ , @@v13@@ ) ; if ( ( int ) check_dst_limits_calc_pos ( @@a1@@ , * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) , @@v15@@ , @@a5@@ , @@a6@@ , @@v14@@ ) != @@v16@@ ) return Number L ; } return Number L ; }
__int64 __fastcall _xargmatch_internal ( __int64 @@a1@@ , const char * @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ , void ( * @@a6@@ ) ( void ) ) { __int64 @@v11@@ ; @@v11@@ = argmatch ( @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; if ( @@v11@@ >= Number ) return @@v11@@ ; argmatch_invalid ( @@a1@@ , ( __int64 ) @@a2@@ , @@v11@@ ) ; argmatch_valid ( @@a3@@ , @@a4@@ , @@a5@@ ) ; @@a6@@ ( ) ; return Number ; }
__int64 __fastcall init_dfa ( void * * @@a1@@ , unsigned __int64 @@a2@@ ) { __int64 @@result@@ ; int @@v3@@ ; int @@i@@ ; int @@c@@ ; wint_t @@v6@@ ; size_t @@size@@ ; const char * @@s1@@ ; memset ( @@a1@@ , Number , Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = Number ; if ( @@a2@@ >= Number ) return Number L ; @@a1@@ [ Number ] = ( void * ) ( @@a2@@ + Number ) ; * @@a1@@ = malloc ( Number L * ( _QWORD ) @@a1@@ [ Number ] ) ; for ( @@size@@ = Number L ; @@size@@ <= @@a2@@ ; @@size@@ *= Number L ) ; @@a1@@ [ Number ] = calloc ( Number , @@size@@ ) ; @@a1@@ [ Number ] = ( void * ) ( @@size@@ - Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = __ctype_get_mb_cur_max ( ) ; @@s1@@ = nl_langinfo ( Number ) ; if ( ! strcasecmp ( @@s1@@ , String ) || ! strcasecmp ( @@s1@@ , String ) ) * ( ( _BYTE * ) @@a1@@ + Number ) |= Number ; * ( ( _BYTE * ) @@a1@@ + Number ) &= Number ; if ( * ( ( int * ) @@a1@@ + Number ) > Number ) { if ( ( ( _BYTE ) @@a1@@ [ Number ] & Number ) != Number ) { @@a1@@ [ Number ] = & utf8_sb_map ; } else { @@a1@@ [ Number ] = calloc ( Number , Number ) ; if ( ! @@a1@@ [ Number ] ) return Number L ; @@v3@@ = Number ; @@c@@ = Number ; while ( @@v3@@ <= Number ) { for ( @@i@@ = Number ; @@i@@ <= Number ; ++ @@i@@ ) { @@v6@@ = btowc ( @@c@@ ) ; if ( @@v6@@ != Number ) * ( ( _QWORD * ) @@a1@@ [ Number ] + @@v3@@ ) |= Number L << @@i@@ ; if ( ( @@c@@ & Number ) == Number && @@v6@@ != @@c@@ ) * ( ( _BYTE * ) @@a1@@ + Number ) |= Number ; ++ @@c@@ ; } ++ @@v3@@ ; } } } if ( * @@a1@@ && @@a1@@ [ Number ] ) @@result@@ = Number L ; else @@result@@ = Number L ; return @@result@@ ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
__int64 __fastcall extend_buffers ( __int64 @@a1@@ ) { unsigned int @@v2@@ ; unsigned int @@v3@@ ; void * @@v4@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) > Number ) return Number L ; @@v2@@ = re_string_realloc_buffers ( @@a1@@ , Number L * * ( _QWORD * ) ( @@a1@@ + Number ) ) ; if ( @@v2@@ ) return @@v2@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) { @@v4@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number * ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L ) ) ; if ( ! @@v4@@ ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v4@@ ; } if ( * ( _BYTE * ) ( @@a1@@ + Number ) ) { if ( * ( int * ) ( @@a1@@ + Number ) <= Number ) { build_upper_buffer ( ( _QWORD * ) @@a1@@ ) ; } else { @@v3@@ = build_wcs_upper_buffer ( @@a1@@ ) ; if ( @@v3@@ ) return @@v3@@ ; } } else if ( * ( int * ) ( @@a1@@ + Number ) <= Number ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) re_string_translate_buffer ( ( _QWORD * ) @@a1@@ ) ; } else { build_wcs_buffer ( @@a1@@ ) ; } return Number L ; }
__int64 __fastcall peek_token_bracket ( _BYTE * @@a1@@ , __int64 @@a2@@ , char @@a3@@ ) { char @@v4@@ ; char @@v5@@ ; unsigned int @@v6@@ ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) <= * ( _QWORD * ) ( @@a2@@ + Number ) ) { @@a1@@ [ Number ] = Number ; return Number L ; } @@v5@@ = * ( _BYTE * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + * ( _QWORD * ) ( @@a2@@ + Number ) ) ; * @@a1@@ = @@v5@@ ; if ( * ( int * ) ( @@a2@@ + Number ) > Number && * ( _QWORD * ) ( @@a2@@ + Number ) != * ( _QWORD * ) ( @@a2@@ + Number ) && * ( _DWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L * * ( _QWORD * ) ( @@a2@@ + Number ) ) == Number ) { @@a1@@ [ Number ] = Number ; return Number L ; } if ( @@v5@@ == Number && ( @@a3@@ & Number ) != Number && ( unsigned __int64 ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) < * ( _QWORD * ) ( @@a2@@ + Number ) ) { ++ * ( _QWORD * ) ( @@a2@@ + Number ) ; * @@a1@@ = * ( _BYTE * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + * ( _QWORD * ) ( @@a2@@ + Number ) ) ; @@a1@@ [ Number ] = Number ; return Number L ; } switch ( @@v5@@ ) { case String : if ( ( unsigned __int64 ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) >= * ( _QWORD * ) ( @@a2@@ + Number ) ) @@v4@@ = Number ; else @@v4@@ = * ( _BYTE * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) ; * @@a1@@ = @@v4@@ ; @@v6@@ = Number ; switch ( @@v4@@ ) { case String : if ( ( @@a3@@ & Number ) != Number ) { @@a1@@ [ Number ] = Number ; return @@v6@@ ; } break ; case String : @@a1@@ [ Number ] = Number ; return @@v6@@ ; case String : @@a1@@ [ Number ] = Number ; return @@v6@@ ; } @@a1@@ [ Number ] = Number ; * @@a1@@ = Number ; return Number ; case String : @@a1@@ [ Number ] = Number ; break ; case String : @@a1@@ [ Number ] = Number ; break ; case String : @@a1@@ [ Number ] = Number ; break ; default : @@a1@@ [ Number ] = Number ; break ; } return Number L ; }
__int64 __fastcall transit_state ( _DWORD * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; unsigned __int8 @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; if ( ( * ( _BYTE * ) ( @@a3@@ + Number ) & Number ) != Number ) { * @@a1@@ = transit_state_mb ( @@a2@@ , @@a3@@ ) ; if ( * @@a1@@ ) return Number L ; } @@v4@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@v5@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; * ( _QWORD * ) ( @@a2@@ + Number ) = @@v5@@ + Number ; @@v9@@ = * ( _BYTE * ) ( @@v4@@ + @@v5@@ ) ; while ( Number ) { @@v10@@ = * ( _QWORD * ) ( @@a3@@ + Number ) ; if ( @@v10@@ ) return * ( _QWORD * ) ( Number L * @@v9@@ + @@v10@@ ) ; @@v11@@ = * ( _QWORD * ) ( @@a3@@ + Number ) ; if ( @@v11@@ ) break ; if ( ( unsigned __int8 ) build_trtable ( * ( _QWORD * ) ( @@a2@@ + Number ) , @@a3@@ ) != Number ) { * @@a1@@ = Number ; return Number L ; } } if ( ( re_string_context_at ( @@a2@@ , * ( _QWORD * ) ( @@a2@@ + Number ) - Number L , * ( _DWORD * ) ( @@a2@@ + Number ) ) & Number ) != Number ) @@v6@@ = Number * ( @@v9@@ + Number L ) ; else @@v6@@ = Number L * @@v9@@ ; return * ( _QWORD * ) ( @@v6@@ + @@v11@@ ) ; }
__int64 __fastcall protect_fd ( int @@a1@@ ) { int @@fd@@ ; @@fd@@ = open ( String , Number ) ; if ( @@fd@@ == @@a1@@ ) return Number L ; if ( @@fd@@ >= Number ) { close ( @@fd@@ ) ; * __errno_location ( ) = Number ; } return Number L ; }
__int64 __fastcall calc_next ( __int64 a1 , __int64 @@a2@@ ) { int @@v2@@ ; @@v2@@ = * ( unsigned __int8 * ) ( @@a2@@ + Number ) ; if ( @@v2@@ == Number ) { * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) = @@a2@@ ; } else if ( @@v2@@ == Number ) { * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) ; * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) = * ( _QWORD * ) ( @@a2@@ + Number ) ; } else { if ( * ( _QWORD * ) ( @@a2@@ + Number ) ) * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) ) * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) = * ( _QWORD * ) ( @@a2@@ + Number ) ; } return Number L ; }
__int64 __fastcall match_ctx_add_subtop ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v3@@ ; void * * @@v5@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@v9@@ ; void * @@v10@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) == * ( _QWORD * ) ( @@a1@@ + Number ) ) { @@v3@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v9@@ = Number * @@v3@@ ; @@v10@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number * @@v3@@ ) ; if ( ! @@v10@@ ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v10@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v9@@ ; } @@v5@@ = ( void * * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L * * ( _QWORD * ) ( @@a1@@ + Number ) ) ; * @@v5@@ = calloc ( Number , Number ) ; if ( ! * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L * * ( _QWORD * ) ( @@a1@@ + Number ) ) ) return Number L ; * ( _QWORD * ) ( * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L * * ( _QWORD * ) ( @@a1@@ + Number ) ) + Number L ) = @@a2@@ ; @@v6@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v7@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v7@@ + Number ; * * ( _QWORD * * ) ( @@v6@@ + Number * @@v7@@ ) = @@a3@@ ; return Number L ; }
__int64 __fastcall create_tree ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , char @@a4@@ ) { char @@v5@@ [ Number ] ; unsigned __int64 @@v6@@ ; @@v6@@ = __readfsqword ( Number ) ; @@v5@@ [ Number ] = @@a4@@ ; return create_token_tree ( @@a1@@ , @@a2@@ , @@a3@@ , @@v5@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
__int64 __fastcall check_arrival_add_next_nodes ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ ) { _QWORD * @@v5@@ ; unsigned int @@v8@@ ; int @@v9@@ ; unsigned __int64 @@i@@ ; _QWORD * @@v11@@ ; __int64 @@v12@@ ; unsigned __int64 @@v13@@ ; __int64 @@v14@@ ; __int64 @@v15@@ ; char @@s@@ [ Number ] ; __int64 @@v17@@ ; void * @@ptr@@ ; unsigned __int64 @@v19@@ ; @@v19@@ = __readfsqword ( Number ) ; @@v11@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; @@v8@@ = Number ; memset ( @@s@@ , Number , Number ) ; for ( @@i@@ = Number L ; @@i@@ < * ( _QWORD * ) ( @@a3@@ + Number ) ; ++ @@i@@ ) { @@v9@@ = Number ; @@v12@@ = * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a3@@ + Number ) ) ; if ( ( * ( _BYTE * ) ( Number * @@v12@@ + * @@v11@@ + Number ) & Number ) != Number ) { @@v9@@ = check_node_accept_bytes ( @@v11@@ , @@v12@@ , @@a1@@ , @@a2@@ ) ; if ( @@v9@@ > Number ) { @@v13@@ = * ( _QWORD * ) ( Number * @@v12@@ + @@v11@@ [ Number ] ) ; @@v14@@ = @@v9@@ + @@a2@@ ; @@v15@@ = * ( _QWORD * ) ( Number * @@v14@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) ; @@v17@@ = Number L ; if ( @@v15@@ ) { @@v8@@ = re_node_set_merge ( ( __int64 ) @@s@@ , @@v15@@ + Number ) ; if ( @@v8@@ ) goto LABEL_6 ; } if ( ! re_node_set_insert ( ( __int64 ) @@s@@ , @@v13@@ ) ) goto LABEL_8 ; @@v5@@ = ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@v14@@ ) ; * @@v5@@ = re_acquire_state ( & @@v8@@ , ( __int64 ) @@v11@@ , ( __int64 ) @@s@@ ) ; if ( ! * ( _QWORD * ) ( Number * @@v14@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) ) { if ( @@v8@@ ) { LABEL_6 : free ( @@ptr@@ ) ; return @@v8@@ ; } } } } if ( ( @@v9@@ || ( unsigned __int8 ) check_node_accept ( @@a1@@ , * @@v11@@ + Number * @@v12@@ , @@a2@@ ) ) && ! re_node_set_insert ( @@a4@@ , * ( _QWORD * ) ( Number * @@v12@@ + @@v11@@ [ Number ] ) ) ) { LABEL_8 : free ( @@ptr@@ ) ; return Number L ; } } free ( @@ptr@@ ) ; return Number L ; }
__int64 __fastcall calc_inveclosure ( _QWORD * @@a1@@ ) { unsigned __int64 @@j@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@k@@ ; __int64 @@v5@@ ; for ( @@i@@ = Number L ; @@i@@ < @@a1@@ [ Number ] ; ++ @@i@@ ) memset ( ( void * ) ( @@a1@@ [ Number ] + Number * @@i@@ ) , Number , Number ) ; for ( @@j@@ = Number L ; @@j@@ < @@a1@@ [ Number ] ; ++ @@j@@ ) { @@v5@@ = * ( _QWORD * ) ( @@a1@@ [ Number ] + Number * @@j@@ + Number ) ; for ( @@k@@ = Number L ; @@k@@ < * ( _QWORD * ) ( @@a1@@ [ Number ] + Number * @@j@@ + Number ) ; ++ @@k@@ ) { if ( ( unsigned __int8 ) re_node_set_insert_last ( @@a1@@ [ Number ] + Number L * * ( _QWORD * ) ( Number * @@k@@ + @@v5@@ ) , @@j@@ ) != Number ) return Number L ; } } return Number L ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
__int64 __fastcall mem_cd_iconv ( char * @@a1@@ , size_t @@a2@@ , void * @@a3@@ , void * * @@a4@@ , size_t * @@a5@@ ) { int @@v9@@ ; char * @@inbuf@@ ; size_t @@inbytesleft@@ ; char * @@outbuf@@ ; size_t @@outbytesleft@@ ; void * @@ptr@@ ; size_t @@v15@@ ; size_t @@v16@@ ; size_t @@v17@@ ; size_t @@size@@ ; size_t @@v19@@ ; size_t @@v20@@ ; char @@v21@@ $D1F1B2789FC85C59BE59CF61C76BFA1E [ Number ] ; unsigned __int64 @@v22@@ ; @@v22@@ = __readfsqword ( Number ) ; iconv ( @@a3@@ , Number L , Number L , Number L , Number L ) ; @@v15@@ = Number L ; @@inbuf@@ = @@a1@@ ; @@inbytesleft@@ = @@a2@@ ; while ( @@inbytesleft@@ ) { @@outbuf@@ = @@v21@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; @@outbytesleft@@ = Number L ; @@v16@@ = iconv ( @@a3@@ , & @@inbuf@@ , & @@inbytesleft@@ , & @@outbuf@@ , & @@outbytesleft@@ ) ; if ( @@v16@@ == Number && * __errno_location ( ) != Number ) { if ( * __errno_location ( ) != Number ) return Number ; break ; } @@v15@@ += @@outbuf@@ - @@v21@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; } @@outbuf@@ = @@v21@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; @@outbytesleft@@ = Number L ; @@v17@@ = iconv ( @@a3@@ , Number L , Number L , & @@outbuf@@ , & @@outbytesleft@@ ) ; if ( @@v17@@ == Number ) return Number ; @@v15@@ += @@outbuf@@ - @@v21@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; @@size@@ = @@v15@@ ; if ( ! @@v15@@ ) { * @@a5@@ = Number L ; return Number L ; } if ( * @@a4@@ && @@size@@ <= * @@a5@@ ) { @@ptr@@ = * @@a4@@ ; } else { @@ptr@@ = malloc ( @@size@@ ) ; if ( ! @@ptr@@ ) { * __errno_location ( ) = Number ; return Number ; } } iconv ( @@a3@@ , Number L , Number L , Number L , Number L ) ; @@inbuf@@ = @@a1@@ ; @@inbytesleft@@ = @@a2@@ ; @@outbuf@@ = ( char * ) @@ptr@@ ; @@outbytesleft@@ = @@size@@ ; while ( @@inbytesleft@@ ) { @@v19@@ = iconv ( @@a3@@ , & @@inbuf@@ , & @@inbytesleft@@ , & @@outbuf@@ , & @@outbytesleft@@ ) ; if ( @@v19@@ == Number ) { if ( * __errno_location ( ) != Number ) goto LABEL_26 ; break ; } } @@v20@@ = iconv ( @@a3@@ , Number L , Number L , & @@outbuf@@ , & @@outbytesleft@@ ) ; if ( @@v20@@ != Number ) { if ( @@outbytesleft@@ ) abort ( ) ; * @@a4@@ = @@ptr@@ ; * @@a5@@ = @@size@@ ; return Number L ; } LABEL_26 : if ( @@ptr@@ != * @@a4@@ ) { @@v9@@ = * __errno_location ( ) ; free ( @@ptr@@ ) ; * __errno_location ( ) = @@v9@@ ; } return Number ; }
__int64 __fastcall create_token_tree ( __int64 @@a1@@ , __int64 * @@a2@@ , __int64 * @@a3@@ , _QWORD * @@a4@@ ) { __int64 @@v5@@ ; int @@v6@@ ; __int64 @@v7@@ ; _QWORD * @@v11@@ ; __int64 @@v12@@ ; if ( * ( _DWORD * ) ( @@a1@@ + Number ) == Number ) { @@v11@@ = malloc ( Number ) ; if ( ! @@v11@@ ) return Number L ; * @@v11@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v11@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = Number ; } @@v5@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v6@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@v6@@ + Number ; @@v12@@ = @@v5@@ + ( ( __int64 ) @@v6@@ << Number ) + Number ; * ( _QWORD * ) @@v12@@ = Number L ; * ( _QWORD * ) ( @@v12@@ + Number ) = @@a2@@ ; * ( _QWORD * ) ( @@v12@@ + Number ) = @@a3@@ ; @@v7@@ = @@a4@@ [ Number ] ; * ( _QWORD * ) ( @@v12@@ + Number ) = * @@a4@@ ; * ( _QWORD * ) ( @@v5@@ + ( ( __int64 ) @@v6@@ << Number ) + Number ) = @@v7@@ ; * ( _BYTE * ) ( @@v12@@ + Number ) &= Number ; * ( _BYTE * ) ( @@v12@@ + Number ) &= Number ; * ( _QWORD * ) ( @@v12@@ + Number ) = Number L ; * ( _QWORD * ) ( @@v12@@ + Number ) = Number L ; * ( _QWORD * ) ( @@v12@@ + Number ) = Number ; if ( @@a2@@ ) * @@a2@@ = @@v12@@ ; if ( @@a3@@ ) * @@a3@@ = @@v12@@ ; return @@v5@@ + ( ( __int64 ) @@v6@@ << Number ) + Number ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall parse_reg_exp ( __int64 @@a1@@ , __int64 * @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , _DWORD * @@a6@@ ) { __int64 @@v11@@ ; __int64 @@v12@@ ; __int64 @@v13@@ ; @@v13@@ = * @@a2@@ ; @@v11@@ = parse_branch ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( * @@a6@@ && ! @@v11@@ ) return Number L ; while ( * ( _BYTE * ) ( @@a3@@ + Number ) == Number ) { fetch_token ( @@a3@@ , @@a1@@ , @@a4@@ | Number ) ; if ( * ( _BYTE * ) ( @@a3@@ + Number ) == Number || * ( _BYTE * ) ( @@a3@@ + Number ) == Number || @@a5@@ && * ( _BYTE * ) ( @@a3@@ + Number ) == Number ) { @@v12@@ = Number L ; } else { @@v12@@ = parse_branch ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( * @@a6@@ && ! @@v12@@ ) return Number L ; } @@v11@@ = create_tree ( @@v13@@ , @@v11@@ , @@v12@@ , Number L ) ; if ( ! @@v11@@ ) { * @@a6@@ = Number ; return Number L ; } } return @@v11@@ ; }
_QWORD * __fastcall match_ctx_clean ( _QWORD * @@a1@@ ) { _QWORD * @@result@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@j@@ ; void * @@v4@@ ; void * * @@ptr@@ ; for ( @@i@@ = Number L ; @@i@@ < @@a1@@ [ Number ] ; ++ @@i@@ ) { @@v4@@ = * ( void * * ) ( Number * @@i@@ + @@a1@@ [ Number ] ) ; for ( @@j@@ = Number L ; @@j@@ < * ( ( _QWORD * ) @@v4@@ + Number ) ; ++ @@j@@ ) { @@ptr@@ = * ( void * * * ) ( Number * @@j@@ + * ( ( _QWORD * ) @@v4@@ + Number ) ) ; free ( @@ptr@@ [ Number ] ) ; free ( @@ptr@@ ) ; } free ( * ( ( void * * ) @@v4@@ + Number ) ) ; if ( * ( ( _QWORD * ) @@v4@@ + Number ) ) { free ( * ( void * * ) ( * ( ( _QWORD * ) @@v4@@ + Number ) + Number L ) ) ; free ( * ( ( void * * ) @@v4@@ + Number ) ) ; } free ( @@v4@@ ) ; } @@a1@@ [ Number ] = Number L ; @@result@@ = @@a1@@ ; @@a1@@ [ Number ] = Number L ; return @@result@@ ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
__int64 __fastcall parse_bracket_symbol ( __int64 @@a1@@ , _QWORD * @@a2@@ , char * @@a3@@ ) { __int64 @@v4@@ ; __int64 @@v5@@ ; int @@v6@@ ; char @@v9@@ ; char @@v10@@ ; int @@v11@@ ; @@v10@@ = * @@a3@@ ; @@v11@@ = Number ; if ( @@a2@@ [ Number ] <= @@a2@@ [ Number ] ) return Number L ; while ( Number ) { if ( @@v11@@ > Number ) return Number L ; if ( @@a3@@ [ Number ] == Number ) { @@v9@@ = re_string_fetch_byte_case ( ( __int64 ) @@a2@@ ) ; } else { @@v4@@ = @@a2@@ [ Number ] ; @@v5@@ = @@a2@@ [ Number ] ; @@a2@@ [ Number ] = @@v5@@ + Number ; @@v9@@ = * ( _BYTE * ) ( @@v4@@ + @@v5@@ ) ; } if ( @@a2@@ [ Number ] <= @@a2@@ [ Number ] ) return Number L ; if ( @@v9@@ == @@v10@@ && * ( _BYTE * ) ( @@a2@@ [ Number ] + @@a2@@ [ Number ] ) == Number ) { break ; } * ( _BYTE * ) ( @@v11@@ ++ + * ( _QWORD * ) ( @@a1@@ + Number ) ) = @@v9@@ ; } ++ @@a2@@ [ Number ] ; * ( _BYTE * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@v11@@ ) = Number ; @@v6@@ = ( unsigned __int8 ) @@a3@@ [ Number ] ; switch ( @@v6@@ ) { case Number : * ( _DWORD * ) @@a1@@ = Number ; break ; case Number : * ( _DWORD * ) @@a1@@ = Number ; break ; case Number : * ( _DWORD * ) @@a1@@ = Number ; break ; } return Number L ; }
__int64 __fastcall prune_impossible_nodes ( __int64 @@a1@@ ) { unsigned int @@v2@@ ; __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; _QWORD * @@v5@@ ; _QWORD * @@s@@ ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; void * @@ptr@@ ; unsigned __int64 @@v10@@ ; @@v10@@ = __readfsqword ( Number ) ; @@v7@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@s@@ = Number L ; @@v4@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v3@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( @@v4@@ > Number ) return Number L ; @@v5@@ = malloc ( Number * ( @@v4@@ + Number ) ) ; if ( @@v5@@ ) { if ( * ( _QWORD * ) ( @@v7@@ + Number ) ) { @@s@@ = malloc ( Number * ( @@v4@@ + Number ) ) ; if ( @@s@@ ) { while ( Number ) { memset ( @@s@@ , Number , Number * ( @@v4@@ + Number ) ) ; sift_ctx_init ( @@v8@@ , @@v5@@ , @@s@@ , @@v3@@ , @@v4@@ ) ; @@v2@@ = sift_states_backward ( @@a1@@ , @@v8@@ ) ; free ( @@ptr@@ ) ; if ( @@v2@@ ) break ; if ( * @@v5@@ || * @@s@@ ) { @@v2@@ = merge_state_array ( @@v7@@ , @@v5@@ , @@s@@ , @@v4@@ + Number ) ; free ( @@s@@ ) ; @@s@@ = Number L ; if ( ! @@v2@@ ) goto LABEL_21 ; break ; } do { if ( -- @@v4@@ > Number ) { @@v2@@ = Number ; goto LABEL_22 ; } } while ( ! * ( _QWORD * ) ( Number * @@v4@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) || ( * ( _BYTE * ) ( * ( _QWORD * ) ( Number * @@v4@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) + Number L ) & Number ) == Number ) ; @@v3@@ = check_halt_state_context ( @@a1@@ , * ( _QWORD * ) ( Number * @@v4@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) , @@v4@@ ) ; } } else { @@v2@@ = Number ; } } else { sift_ctx_init ( @@v8@@ , @@v5@@ , Number L , @@v3@@ , @@v4@@ ) ; @@v2@@ = sift_states_backward ( @@a1@@ , @@v8@@ ) ; free ( @@ptr@@ ) ; if ( ! @@v2@@ ) { if ( * @@v5@@ ) { LABEL_21 : free ( * ( void * * ) ( @@a1@@ + Number ) ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v5@@ ; @@v5@@ = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v3@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v4@@ ; @@v2@@ = Number ; } else { @@v2@@ = Number ; } } } } else { @@v2@@ = Number ; } LABEL_22 : free ( @@v5@@ ) ; free ( @@s@@ ) ; return @@v2@@ ; }
void * __fastcall xzalloc ( size_t @@a1@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@a1@@ ) ; return memset ( @@v1@@ , Number , @@a1@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_229058 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
__int64 __fastcall rpl_regexec ( __int64 @@a1@@ , const char * @@a2@@ , __int64 @@a3@@ , __int64 * @@a4@@ , int @@a5@@ ) { int @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; if ( ( @@a5@@ & Number ) != Number ) return Number L ; if ( ( @@a5@@ & Number ) != Number ) { @@v10@@ = * @@a4@@ ; @@v11@@ = @@a4@@ [ Number ] ; } else { LODWORD ( @@v10@@ ) = Number ; LODWORD ( @@v11@@ ) = strlen ( @@a2@@ ) ; } if ( ( * ( _BYTE * ) ( @@a1@@ + Number ) & Number ) != Number ) @@v9@@ = re_search_internal ( @@a1@@ , ( _DWORD ) @@a2@@ , @@v11@@ , @@v10@@ , @@v11@@ , @@v11@@ , Number L , Number L , @@a5@@ ) ; else @@v9@@ = re_search_internal ( @@a1@@ , ( _DWORD ) @@a2@@ , @@v11@@ , @@v10@@ , @@v11@@ , @@v11@@ , @@a3@@ , ( __int64 ) @@a4@@ , @@a5@@ ) ; return @@v9@@ != Number ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( is_mul_ok ( @@a2@@ , * @@a1@@ ) ) { * @@a1@@ *= @@a2@@ ; @@result@@ = Number L ; } else { * @@a1@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
__int64 __fastcall merge_state_array ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , unsigned __int64 @@a4@@ ) { _QWORD * @@v5@@ ; unsigned int @@v8@@ ; unsigned __int64 @@i@@ ; void * @@v10@@ [ Number ] ; @@v10@@ [ Number ] = ( void * ) __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ < @@a4@@ ; ++ @@i@@ ) { if ( * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ) { if ( * ( _QWORD * ) ( Number * @@i@@ + @@a3@@ ) ) { @@v8@@ = re_node_set_init_union ( @@v10@@ , * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) + Number L , * ( _QWORD * ) ( Number * @@i@@ + @@a3@@ ) + Number L ) ; if ( @@v8@@ ) return @@v8@@ ; @@v5@@ = ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; * @@v5@@ = re_acquire_state ( & @@v8@@ , @@a1@@ , ( __int64 ) @@v10@@ ) ; free ( @@v10@@ [ Number ] ) ; if ( @@v8@@ ) return @@v8@@ ; } } else { * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) = * ( _QWORD * ) ( Number * @@i@@ + @@a3@@ ) ; } } return Number L ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall mb_copy ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; if ( * ( _QWORD * ) @@a2@@ == @@a2@@ + Number ) { memcpy ( ( void * ) ( @@a1@@ + Number ) , ( const void * ) ( @@a2@@ + Number ) , * ( _QWORD * ) ( @@a2@@ + Number ) ) ; * ( _QWORD * ) @@a1@@ = @@a1@@ + Number ; } else { * ( _QWORD * ) @@a1@@ = * ( _QWORD * ) @@a2@@ ; } * ( _QWORD * ) ( @@a1@@ + Number ) = * ( _QWORD * ) ( @@a2@@ + Number ) ; * ( _BYTE * ) ( @@a1@@ + Number ) = * ( _BYTE * ) ( @@a2@@ + Number ) ; @@result@@ = * ( unsigned __int8 * ) ( @@a1@@ + Number ) ; if ( ( _BYTE ) @@result@@ ) { @@result@@ = @@a1@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = * ( _DWORD * ) ( @@a2@@ + Number ) ; } return @@result@@ ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
__int64 __fastcall re_search_2_stub ( int @@a1@@ , const void * @@a2@@ , size_t @@a3@@ , const void * @@a4@@ , size_t @@a5@@ , int @@a6@@ , __int64 @@a7@@ , __int64 @@a8@@ , __int64 @@a9@@ , unsigned __int8 @@a10@@ ) { __int64 @@v11@@ ; char * @@dest@@ ; size_t @@size@@ ; __int64 @@v18@@ ; @@size@@ = @@a3@@ + @@a5@@ ; @@dest@@ = Number L ; if ( @@a3@@ + @@a5@@ < @@a3@@ ) return Number ; if ( @@a5@@ ) { if ( @@a3@@ ) { @@dest@@ = ( char * ) malloc ( @@size@@ ) ; if ( ! @@dest@@ ) return Number ; memcpy ( @@dest@@ , @@a2@@ , @@a3@@ ) ; memcpy ( & @@dest@@ [ @@a3@@ ] , @@a4@@ , @@a5@@ ) ; @@v11@@ = re_search_stub ( @@a1@@ , ( _DWORD ) @@dest@@ , @@size@@ , @@a6@@ , @@a7@@ , @@a9@@ , @@a8@@ , @@a10@@ ) ; } else { @@v11@@ = re_search_stub ( @@a1@@ , ( _DWORD ) @@a4@@ , @@size@@ , @@a6@@ , @@a7@@ , @@a9@@ , @@a8@@ , @@a10@@ ) ; } } else { @@v11@@ = re_search_stub ( @@a1@@ , ( _DWORD ) @@a2@@ , @@size@@ , @@a6@@ , @@a7@@ , @@a9@@ , @@a8@@ , @@a10@@ ) ; } @@v18@@ = @@v11@@ ; free ( @@dest@@ ) ; return @@v18@@ ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
__int64 __fastcall add_epsilon_src_nodes ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { unsigned int @@v5@@ ; unsigned __int64 @@i@@ ; _QWORD * @@v7@@ ; unsigned __int64 @@v8@@ ; @@v8@@ = __readfsqword ( Number ) ; @@v5@@ = Number ; @@v7@@ = re_acquire_state ( & @@v5@@ , @@a1@@ , @@a2@@ ) ; if ( @@v5@@ ) return @@v5@@ ; if ( ! @@v7@@ [ Number ] ) { @@v5@@ = re_node_set_alloc ( @@v7@@ + Number , * ( _QWORD * ) ( @@a2@@ + Number ) ) ; if ( @@v5@@ ) return Number L ; for ( @@i@@ = Number L ; @@i@@ < * ( _QWORD * ) ( @@a2@@ + Number ) ; ++ @@i@@ ) re_node_set_merge ( ( __int64 ) ( @@v7@@ + Number ) , * ( _QWORD * ) ( @@a1@@ + Number ) + Number L * * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) ) ; } return re_node_set_add_intersect ( @@a2@@ , @@a3@@ , ( __int64 ) ( @@v7@@ + Number ) ) ; }
_BOOL8 __fastcall c_isascii ( int @@a1@@ ) { return @@a1@@ >= Number && @@a1@@ <= Number ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_229888 ; @@v8@@ [ Number ] = qword_229890 ; @@v8@@ [ Number ] = qword_229898 ; @@v8@@ [ Number ] = qword_2298A0 ; @@v8@@ [ Number ] = qword_2298A8 ; @@v8@@ [ Number ] = qword_2298B0 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
__int64 __fastcall push_fail_stack ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , const void * @@a5@@ , __int64 @@a6@@ ) { __int64 @@v6@@ ; __int64 @@v8@@ ; __int64 @@v13@@ ; void * @@v14@@ ; @@v6@@ = ( * ( _QWORD * ) @@a1@@ ) ++ ; @@v13@@ = @@v6@@ ; if ( * ( _QWORD * ) @@a1@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ) { @@v14@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number L * * ( _QWORD * ) ( @@a1@@ + Number ) ) ; if ( ! @@v14@@ ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) *= Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v14@@ ; } * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@v13@@ ) = @@a2@@ ; * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@v13@@ + Number ) = @@a3@@ ; @@v8@@ = * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@v13@@ ; * ( _QWORD * ) ( @@v8@@ + Number ) = malloc ( Number * @@a4@@ ) ; if ( ! * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@v13@@ + Number ) ) return Number L ; memcpy ( * ( void * * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@v13@@ + Number ) , @@a5@@ , Number * @@a4@@ ) ; return ( unsigned int ) re_node_set_init_copy ( ( void * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@v13@@ + Number ) , @@a6@@ ) ; }
_BOOL8 __fastcall c_isalnum ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number || ( int ) ( @@a1@@ & Number ) > Number && ( int ) ( @@a1@@ & Number ) <= Number ; }
__int64 __fastcall check_dst_limits_calc_pos ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ , unsigned __int64 @@a5@@ , __int64 @@a6@@ ) { __int64 @@result@@ ; int @@v7@@ ; int @@v8@@ ; __int64 @@v9@@ ; @@v9@@ = * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@a2@@ ; if ( @@a5@@ < * ( _QWORD * ) ( @@v9@@ + Number ) ) return Number ; if ( @@a5@@ > * ( _QWORD * ) ( @@v9@@ + Number ) ) return Number L ; if ( @@a5@@ == * ( _QWORD * ) ( @@v9@@ + Number ) ) @@v7@@ = Number ; else @@v7@@ = Number ; @@v8@@ = @@v7@@ | ( @@a5@@ == * ( _QWORD * ) ( @@v9@@ + Number ) ) ; if ( @@v8@@ ) @@result@@ = check_dst_limits_calc_pos_1 ( @@a1@@ , @@v8@@ , @@a3@@ , @@a4@@ , @@a6@@ ) ; else @@result@@ = Number L ; return @@result@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
__int64 __fastcall re_string_char_size_at ( __int64 @@a1@@ , __int64 @@a2@@ ) { int @@i@@ ; if ( * ( _DWORD * ) ( @@a1@@ + Number ) == Number ) return Number L ; for ( @@i@@ = Number ; ( unsigned __int64 ) ( @@a2@@ + @@i@@ ) < * ( _QWORD * ) ( @@a1@@ + Number ) && * ( _DWORD * ) ( Number * ( @@i@@ + @@a2@@ ) + * ( _QWORD * ) ( @@a1@@ + Number ) ) == Number ; ++ @@i@@ ) { ; } return ( unsigned int ) @@i@@ ; }
_BOOL8 __fastcall c_isblank ( int @@a1@@ ) { return @@a1@@ == Number || @@a1@@ == Number ; }
__int64 __fastcall clean_state_log_if_needed ( _QWORD * @@a1@@ , unsigned __int64 @@a2@@ ) { unsigned int @@v3@@ ; unsigned __int64 @@v4@@ ; @@v4@@ = @@a1@@ [ Number ] ; if ( @@a2@@ >= @@a1@@ [ Number ] || @@a2@@ >= @@a1@@ [ Number ] && @@a1@@ [ Number ] < @@a1@@ [ Number ] ) { @@v3@@ = extend_buffers ( @@a1@@ ) ; if ( @@v3@@ ) return @@v3@@ ; } if ( @@v4@@ < @@a2@@ ) { memset ( ( void * ) ( Number * ( @@v4@@ + Number ) + @@a1@@ [ Number ] ) , Number , Number * ( @@a2@@ - @@v4@@ ) ) ; @@a1@@ [ Number ] = @@a2@@ ; } return Number L ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
__int64 __fastcall find_recover_state ( _DWORD * @@a1@@ , _QWORD * @@a2@@ ) { __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; __int64 @@v5@@ ; do { @@v4@@ = @@a2@@ [ Number ] ; @@v3@@ = @@a2@@ [ Number ] ; do { if ( ++ @@v3@@ > @@v4@@ ) return Number L ; ++ @@a2@@ [ Number ] ; } while ( ! * ( _QWORD * ) ( Number * @@v3@@ + @@a2@@ [ Number ] ) ) ; @@v5@@ = merge_state_with_log ( @@a1@@ , ( __int64 ) @@a2@@ , Number L ) ; } while ( ! * @@a1@@ && ! @@v5@@ ) ; return @@v5@@ ; }
__int64 __fastcall re_string_construct_common ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , char @@a5@@ , __int64 @@a6@@ ) { bool @@v6@@ ; __int64 @@result@@ ; * ( _QWORD * ) @@a3@@ = @@a1@@ ; * ( _QWORD * ) ( @@a3@@ + Number ) = @@a2@@ ; * ( _QWORD * ) ( @@a3@@ + Number ) = @@a2@@ ; * ( _QWORD * ) ( @@a3@@ + Number ) = @@a4@@ ; * ( _BYTE * ) ( @@a3@@ + Number ) = @@a5@@ ; @@v6@@ = @@a4@@ || @@a5@@ ; * ( _BYTE * ) ( @@a3@@ + Number ) = @@v6@@ ; * ( _DWORD * ) ( @@a3@@ + Number ) = * ( _DWORD * ) ( @@a6@@ + Number ) ; * ( _BYTE * ) ( @@a3@@ + Number ) = ( * ( _BYTE * ) ( @@a6@@ + Number ) & Number ) != Number ; * ( _BYTE * ) ( @@a3@@ + Number ) = ( * ( _BYTE * ) ( @@a6@@ + Number ) & Number ) != Number ; * ( _QWORD * ) ( @@a3@@ + Number ) = * ( _QWORD * ) ( @@a3@@ + Number ) ; @@result@@ = @@a3@@ ; * ( _QWORD * ) ( @@a3@@ + Number ) = * ( _QWORD * ) ( @@a3@@ + Number ) ; return @@result@@ ; }
_BOOL8 __fastcall c_iscntrl ( int @@a1@@ ) { return ( @@a1@@ & Number ) == Number || @@a1@@ == Number ; }
__int64 __fastcall update_cur_sifted_state ( _QWORD * @@a1@@ , _QWORD * @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ ) { __int64 @@v4@@ ; __int64 @@result@@ ; _QWORD * @@v6@@ ; unsigned int @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; unsigned __int64 @@v12@@ ; @@v12@@ = __readfsqword ( Number ) ; @@v10@@ = @@a1@@ [ Number ] ; @@v9@@ = Number ; if ( * ( _QWORD * ) ( Number * @@a3@@ + @@a1@@ [ Number ] ) ) @@v4@@ = * ( _QWORD * ) ( Number * @@a3@@ + @@a1@@ [ Number ] ) + Number L ; else @@v4@@ = Number L ; @@v11@@ = @@v4@@ ; if ( * ( _QWORD * ) ( @@a4@@ + Number ) ) { if ( @@v11@@ ) { @@v9@@ = add_epsilon_src_nodes ( @@v10@@ , @@a4@@ , @@v11@@ ) ; if ( @@v9@@ ) return @@v9@@ ; if ( @@a2@@ [ Number ] ) { @@v9@@ = check_subexp_limits ( @@v10@@ , @@a4@@ , @@v11@@ , @@a2@@ + Number , @@a1@@ [ Number ] , @@a3@@ ) ; if ( @@v9@@ ) return @@v9@@ ; } } @@v6@@ = ( _QWORD * ) ( * @@a2@@ + Number * @@a3@@ ) ; * @@v6@@ = re_acquire_state ( & @@v9@@ , @@v10@@ , @@a4@@ ) ; if ( @@v9@@ ) return @@v9@@ ; } else { * ( _QWORD * ) ( Number * @@a3@@ + * @@a2@@ ) = Number L ; } if ( @@v11@@ && ( * ( _BYTE * ) ( * ( _QWORD * ) ( Number * @@a3@@ + @@a1@@ [ Number ] ) + Number L ) & Number ) != Number && ( @@v9@@ = sift_states_bkref ( @@a1@@ , @@a2@@ , @@a3@@ , @@v11@@ ) ) != Number ) { @@result@@ = @@v9@@ ; } else { @@result@@ = Number L ; } return @@result@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_2060A8 ; @@v4@@ [ Number ] = qword_2060B0 ; @@v4@@ [ Number ] = qword_2060B8 ; @@v4@@ [ Number ] = qword_2060C0 ; @@v4@@ [ Number ] = qword_2060C8 ; @@v4@@ [ Number ] = qword_2060D0 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
__int64 __fastcall get_subexp_sub ( _QWORD * @@a1@@ , _QWORD * @@a2@@ , _QWORD * @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ ) { __int64 @@result@@ ; unsigned int @@v9@@ ; unsigned int @@v10@@ ; @@v9@@ = check_arrival ( ( _DWORD ) @@a1@@ , ( int ) @@a3@@ + Number , * @@a3@@ , @@a3@@ [ Number ] , @@a4@@ , @@a5@@ , Number ) ; if ( @@v9@@ ) return @@v9@@ ; @@v10@@ = match_ctx_add_entry ( @@a1@@ , @@a4@@ , @@a5@@ , * @@a2@@ , @@a3@@ [ Number ] ) ; if ( @@v10@@ ) @@result@@ = @@v10@@ ; else @@result@@ = clean_state_log_if_needed ( @@a1@@ , @@a5@@ + @@a3@@ [ Number ] - * @@a2@@ ) ; return @@result@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
_BOOL8 __fastcall c_islower ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
__int64 __fastcall sift_states_iter_mb ( __int64 @@a1@@ , _QWORD * @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned __int64 @@a5@@ ) { int @@v9@@ ; __int64 @@v10@@ ; @@v10@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v9@@ = check_node_accept_bytes ( @@v10@@ , @@a3@@ , @@a1@@ , @@a4@@ ) ; if ( @@v9@@ > Number && @@a5@@ >= @@v9@@ + @@a4@@ && ( ! * ( _QWORD * ) ( Number * ( @@v9@@ + @@a4@@ ) + * @@a2@@ ) || ! re_node_set_contains ( * ( _QWORD * ) ( Number * ( @@v9@@ + @@a4@@ ) + * @@a2@@ ) + Number L , * ( _QWORD * ) ( Number * @@a3@@ + * ( _QWORD * ) ( @@v10@@ + Number ) ) ) ) ) { @@v9@@ = Number ; } return ( unsigned int ) @@v9@@ ; }
__int64 __fastcall re_string_fetch_byte_case ( __int64 @@a1@@ ) { __int64 @@v1@@ ; __int64 @@v2@@ ; __int64 @@result@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; unsigned int @@v13@@ ; if ( * ( _BYTE * ) ( @@a1@@ + Number ) ) { if ( * ( _BYTE * ) ( @@a1@@ + Number ) ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) == * ( _QWORD * ) ( @@a1@@ + Number ) || * ( _DWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L * * ( _QWORD * ) ( @@a1@@ + Number ) ) != Number ) { @@v13@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) @@a1@@ + * ( _QWORD * ) ( @@a1@@ + Number ) + * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L * * ( _QWORD * ) ( @@a1@@ + Number ) ) ) ; if ( ( @@v13@@ & Number ) != Number ) { @@v6@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v7@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v7@@ + Number ; @@result@@ = * ( unsigned __int8 * ) ( @@v6@@ + @@v7@@ ) ; } else { @@v8@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v8@@ + ( int ) re_string_char_size_at ( @@a1@@ , @@v8@@ ) ; @@result@@ = @@v13@@ ; } } else { @@v4@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v5@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v5@@ + Number ; @@result@@ = * ( unsigned __int8 * ) ( @@v4@@ + @@v5@@ ) ; } } else { @@v9@@ = * ( _QWORD * ) @@a1@@ ; @@v10@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v11@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v11@@ + Number ; @@result@@ = * ( unsigned __int8 * ) ( @@v9@@ + @@v10@@ + @@v11@@ ) ; } } else { @@v1@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v2@@ + Number ; @@result@@ = * ( unsigned __int8 * ) ( @@v1@@ + @@v2@@ ) ; } return @@result@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) _frame_dummy_init_array_entry [ @@i@@ ] ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
_BOOL8 __fastcall c_ispunct ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number && ( @@a1@@ <= Number || @@a1@@ > Number ) && ( ( int ) ( @@a1@@ & Number ) <= Number || ( int ) ( @@a1@@ & Number ) > Number ) ; }
_BOOL8 __fastcall check_node_accept ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { int @@v3@@ ; _BOOL8 @@result@@ ; char @@v6@@ ; char @@v7@@ ; @@v6@@ = * ( _BYTE * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@a3@@ ) ; @@v3@@ = * ( unsigned __int8 * ) ( @@a2@@ + Number ) ; if ( @@v3@@ == Number ) { if ( ! bitset_contain ( * ( _QWORD * ) @@a2@@ , ( unsigned __int8 ) @@v6@@ ) ) return Number L ; } else if ( * ( unsigned __int8 * ) ( @@a2@@ + Number ) > Number ) { if ( @@v3@@ != Number ) { if ( @@v3@@ != Number ) return Number L ; if ( @@v6@@ < Number ) return Number L ; } if ( @@v6@@ == Number && ( * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L ) & Number ) == Number || ! @@v6@@ && ( * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L ) & Number ) != Number ) { return Number L ; } } else { if ( @@v3@@ != Number ) return Number L ; if ( @@v6@@ != * ( _BYTE * ) @@a2@@ ) return Number L ; } @@result@@ = Number ; if ( ( * ( _DWORD * ) ( @@a2@@ + Number ) & Number ) != Number ) { if ( ( @@v7@@ = re_string_context_at ( @@a1@@ , @@a3@@ , * ( _DWORD * ) ( @@a1@@ + Number ) ) , ( ( * ( _DWORD * ) ( @@a2@@ + Number ) >> Number ) & Number ) != Number ) && ( @@v7@@ & Number ) == Number || ( ( * ( _DWORD * ) ( @@a2@@ + Number ) >> Number ) & Number ) != Number && ( @@v7@@ & Number ) != Number || ( ( * ( _DWORD * ) ( @@a2@@ + Number ) >> Number ) & Number ) != Number && ( @@v7@@ & Number ) == Number || ( ( * ( _DWORD * ) ( @@a2@@ + Number ) >> Number ) & Number ) != Number && ( @@v7@@ & Number ) == Number ) { @@result@@ = Number ; } } return @@result@@ ; }
__int64 __fastcall check_subexp_matching_top ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { unsigned int @@v5@@ ; unsigned __int64 @@i@@ ; _QWORD * @@v7@@ ; __int64 @@v8@@ ; @@v7@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; for ( @@i@@ = Number L ; @@i@@ < * ( _QWORD * ) ( @@a2@@ + Number ) ; ++ @@i@@ ) { @@v8@@ = * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) ; if ( * ( _BYTE * ) ( Number * @@v8@@ + * @@v7@@ + Number ) == Number && * ( _QWORD * ) ( Number * @@v8@@ + * @@v7@@ ) <= Number && ( ( @@v7@@ [ Number ] >> * ( _QWORD * ) ( Number * @@v8@@ + * @@v7@@ ) ) & Number L ) != Number ) { @@v5@@ = match_ctx_add_subtop ( @@a1@@ , @@v8@@ , @@a3@@ ) ; if ( @@v5@@ ) return @@v5@@ ; } } return Number L ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall c_toupper ( int @@a1@@ ) { __int64 @@result@@ ; if ( @@a1@@ <= Number || @@a1@@ > Number ) @@result@@ = ( unsigned int ) @@a1@@ ; else @@result@@ = ( unsigned int ) ( @@a1@@ - Number ) ; return @@result@@ ; }
unsigned __int64 __fastcall re_node_set_contains ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { unsigned __int64 @@result@@ ; unsigned __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; if ( ( unsigned __int64 ) ( * ( _QWORD * ) ( @@a1@@ + Number ) - Number L ) > Number ) return Number L ; @@v3@@ = Number L ; @@v4@@ = * ( _QWORD * ) ( @@a1@@ + Number ) - Number L ; while ( @@v3@@ < @@v4@@ ) { if ( @@a2@@ <= * ( _QWORD * ) ( Number * ( ( @@v3@@ + @@v4@@ ) >> Number ) + * ( _QWORD * ) ( @@a1@@ + Number ) ) ) @@v4@@ = ( @@v3@@ + @@v4@@ ) >> Number ; else @@v3@@ = ( ( @@v3@@ + @@v4@@ ) >> Number ) + Number ; } if ( @@a2@@ == * ( _QWORD * ) ( Number * @@v3@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) ) @@result@@ = @@v3@@ + Number ; else @@result@@ = Number L ; return @@result@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
bool __fastcall is_basic_2 ( unsigned __int8 @@a1@@ ) { return ( ( is_basic_table [ @@a1@@ >> Number ] >> ( @@a1@@ & Number ) ) & Number ) != Number ; }
_QWORD * __fastcall match_ctx_add_sublast ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v5@@ ; void * @@v6@@ ; _QWORD * @@v7@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) == * ( _QWORD * ) ( @@a1@@ + Number ) ) { @@v5@@ = Number L * * ( _QWORD * ) ( @@a1@@ + Number ) + Number ; @@v6@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number * @@v5@@ ) ; if ( ! @@v6@@ ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v6@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v5@@ ; } @@v7@@ = calloc ( Number , Number ) ; if ( @@v7@@ ) { * ( _QWORD * ) ( Number L * * ( _QWORD * ) ( @@a1@@ + Number ) + * ( _QWORD * ) ( @@a1@@ + Number ) ) = @@v7@@ ; * @@v7@@ = @@a2@@ ; @@v7@@ [ Number ] = @@a3@@ ; ++ * ( _QWORD * ) ( @@a1@@ + Number ) ; } return @@v7@@ ; }
__int64 __fastcall find_subexp_node ( _QWORD * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , int @@a4@@ ) { unsigned __int64 @@i@@ ; __int64 @@v6@@ ; for ( @@i@@ = Number L ; @@i@@ < * ( _QWORD * ) ( @@a2@@ + Number ) ; ++ @@i@@ ) { @@v6@@ = Number L * * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) + * @@a1@@ ; if ( @@a4@@ == * ( unsigned __int8 * ) ( @@v6@@ + Number ) && @@a3@@ == * ( _QWORD * ) @@v6@@ ) { return * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) ; } } return Number ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
size_t __fastcall mbslen ( const char * @@a1@@ ) { __int64 @@v3@@ ; char @@v4@@ [ Number ] ; int @@v5@@ ; char @@i@@ ; const char * @@v7@@ ; __int64 @@v8@@ ; char @@v9@@ ; int @@v10@@ ; unsigned __int64 @@v11@@ ; @@v11@@ = __readfsqword ( Number ) ; if ( __ctype_get_mb_cur_max ( ) <= Number ) return strlen ( @@a1@@ ) ; @@v3@@ = Number L ; @@v7@@ = @@a1@@ ; @@v4@@ [ Number ] = Number ; memset ( & @@v5@@ , Number , Number ) ; for ( @@i@@ = Number ; ; @@i@@ = Number ) { mbuiter_multi_next_1 ( ( __int64 ) @@v4@@ ) ; if ( @@v9@@ == Number && ! @@v10@@ ) break ; ++ @@v3@@ ; @@v7@@ += @@v8@@ ; } return @@v3@@ ; }
_QWORD * __fastcall re_acquire_state ( _DWORD * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { _QWORD * @@result@@ ; unsigned __int64 @@i@@ ; __int64 @@v6@@ ; unsigned __int64 * @@v7@@ ; __int64 @@v8@@ ; _QWORD * @@v9@@ ; if ( * ( _QWORD * ) ( @@a3@@ + Number ) ) { @@v6@@ = calc_state_hash ( @@a3@@ , Number ) ; @@v7@@ = ( unsigned __int64 * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number * ( @@v6@@ & * ( _QWORD * ) ( @@a2@@ + Number ) ) ) ; for ( @@i@@ = Number L ; @@i@@ < * @@v7@@ ; ++ @@i@@ ) { @@v9@@ = * ( _QWORD * * ) ( Number * @@i@@ + @@v7@@ [ Number ] ) ; if ( @@v6@@ == * @@v9@@ && ( unsigned __int8 ) re_node_set_compare ( ( __int64 ) ( @@v9@@ + Number ) , @@a3@@ ) ) { return @@v9@@ ; } } @@v8@@ = create_ci_newstate ( @@a2@@ , @@a3@@ , @@v6@@ ) ; if ( ! @@v8@@ ) * @@a1@@ = Number ; @@result@@ = ( _QWORD * ) @@v8@@ ; } else { * @@a1@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 __fastcall check_arrival_expand_ecl_sub ( _QWORD * @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ , unsigned int @@a5@@ ) { unsigned __int64 @@i@@ ; unsigned int @@v9@@ ; unsigned __int64 @@v10@@ ; @@v10@@ = @@a3@@ ; for ( @@i@@ = re_node_set_contains ( @@a2@@ , @@a3@@ ) ; ! @@i@@ ; @@i@@ = re_node_set_contains ( @@a2@@ , @@v10@@ ) ) { if ( @@a5@@ == * ( unsigned __int8 * ) ( Number * @@v10@@ + * @@a1@@ + Number ) && @@a4@@ == * ( _QWORD * ) ( Number * @@v10@@ + * @@a1@@ ) ) { if ( @@a5@@ == Number && ! re_node_set_insert ( @@a2@@ , @@v10@@ ) ) return Number L ; return Number L ; } if ( ! re_node_set_insert ( @@a2@@ , @@v10@@ ) ) return Number L ; if ( ! * ( _QWORD * ) ( @@a1@@ [ Number ] + Number * @@v10@@ + Number ) ) return Number L ; if ( * ( _QWORD * ) ( @@a1@@ [ Number ] + Number * @@v10@@ + Number ) == Number L ) { @@v9@@ = check_arrival_expand_ecl_sub ( @@a1@@ , @@a2@@ , * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ [ Number ] + Number * @@v10@@ + Number ) + Number L ) , @@a4@@ , @@a5@@ ) ; if ( @@v9@@ ) return @@v9@@ ; } @@v10@@ = * * ( _QWORD * * ) ( @@a1@@ [ Number ] + Number * @@v10@@ + Number ) ; } return Number L ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
__int64 __fastcall rpl_re_set_syntax ( __int64 @@a1@@ ) { __int64 @@v2@@ ; @@v2@@ = rpl_re_syntax_options ; rpl_re_syntax_options = @@a1@@ ; return @@v2@@ ; }
const char * locale_charset ( ) { const char * @@s1@@ ; char * @@s2@@ ; char * @@s2a@@ ; @@s1@@ = nl_langinfo ( Number ) ; if ( ! @@s1@@ ) @@s1@@ = ( const char * ) & unk_24D6E ; for ( @@s2@@ = ( char * ) get_charset_aliases ( ) ; * @@s2@@ ; @@s2@@ = & @@s2a@@ [ strlen ( @@s2a@@ ) + Number ] ) { if ( ! strcmp ( @@s1@@ , @@s2@@ ) || * @@s2@@ == Number && ! @@s2@@ [ Number ] ) { @@s1@@ = & @@s2@@ [ strlen ( @@s2@@ ) + Number ] ; break ; } @@s2a@@ = & @@s2@@ [ strlen ( @@s2@@ ) + Number ] ; } if ( ! * @@s1@@ ) @@s1@@ = String ; return @@s1@@ ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
__int64 __fastcall rpl_re_compile_fastmap ( __int64 @@a1@@ ) { _QWORD * @@v2@@ ; void * @@s@@ ; @@v2@@ = * ( _QWORD * * ) @@a1@@ ; @@s@@ = * ( void * * ) ( @@a1@@ + Number ) ; memset ( @@s@@ , Number , Number ) ; re_compile_fastmap_iter ( @@a1@@ , @@v2@@ [ Number ] , @@s@@ ) ; if ( @@v2@@ [ Number ] != @@v2@@ [ Number ] ) re_compile_fastmap_iter ( @@a1@@ , @@v2@@ [ Number ] , @@s@@ ) ; if ( @@v2@@ [ Number ] != @@v2@@ [ Number ] ) re_compile_fastmap_iter ( @@a1@@ , @@v2@@ [ Number ] , @@s@@ ) ; if ( @@v2@@ [ Number ] != @@v2@@ [ Number ] ) re_compile_fastmap_iter ( @@a1@@ , @@v2@@ [ Number ] , @@s@@ ) ; * ( _BYTE * ) ( @@a1@@ + Number ) |= Number ; return Number L ; }
__int64 __fastcall match_ctx_init ( __int64 @@a1@@ , int @@a2@@ , unsigned __int64 @@a3@@ ) { * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number ; if ( ! @@a3@@ ) goto LABEL_7 ; if ( ! is_mul_ok ( Number , @@a3@@ ) ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = malloc ( Number * @@a3@@ ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = malloc ( Number * @@a3@@ ) ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) || ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; LABEL_7 : * ( _QWORD * ) ( @@a1@@ + Number ) = @@a3@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = Number ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@a3@@ ; return Number L ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
__int64 __fastcall init_word_char ( __int64 @@a1@@ ) { __int64 @@result@@ ; int @@v2@@ ; int @@i@@ ; int @@v4@@ ; @@result@@ = @@a1@@ ; * ( _BYTE * ) ( @@a1@@ + Number ) |= Number ; @@v2@@ = Number ; @@v4@@ = Number ; while ( @@v2@@ <= Number ) { for ( @@i@@ = Number ; @@i@@ <= Number ; ++ @@i@@ ) { @@result@@ = ( * __ctype_b_loc ( ) ) [ @@v4@@ ] & Number ; if ( ( _DWORD ) @@result@@ || @@v4@@ == Number ) { @@result@@ = @@a1@@ ; * ( _QWORD * ) ( @@a1@@ + Number * ( @@v2@@ + Number L ) + Number ) |= Number L << @@i@@ ; } ++ @@v4@@ ; } ++ @@v2@@ ; } return @@result@@ ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
__int64 __fastcall xnrealloc ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { if ( ! is_mul_ok ( @@a3@@ , @@a2@@ ) ) xalloc_die ( ) ; return xrealloc ( @@a1@@ , @@a3@@ * @@a2@@ ) ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
_BOOL8 __fastcall c_isalpha ( int @@a1@@ ) { return ( int ) ( @@a1@@ & Number ) > Number && ( int ) ( @@a1@@ & Number ) <= Number ; }
__int64 __fastcall postorder ( _QWORD * @@a1@@ , __int64 ( __fastcall * @@a2@@ ( ) ( void , bintreet0 ) ) ( __int64 , _QWORD * ) , __int64 @@a3@@ ) { unsigned int @@v5@@ ; _QWORD * @@v7@@ ; LABEL_5 : while ( @@a1@@ [ Number ] || @@a1@@ [ Number ] ) { if ( @@a1@@ [ Number ] ) @@a1@@ = ( _QWORD * ) @@a1@@ [ Number ] ; else @@a1@@ = ( _QWORD * ) @@a1@@ [ Number ] ; } while ( Number ) { @@v5@@ = @@a2@@ ( ) ( void , bintreet0 ) ( @@a3@@ , @@a1@@ ) ; if ( @@v5@@ ) return @@v5@@ ; if ( ! * @@a1@@ ) return Number L ; @@v7@@ = @@a1@@ ; @@a1@@ = ( _QWORD * ) * @@a1@@ ; if ( @@v7@@ != ( _QWORD * ) @@a1@@ [ Number ] && @@a1@@ [ Number ] ) { @@a1@@ = ( _QWORD * ) @@a1@@ [ Number ] ; goto LABEL_5 ; } } }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ ) { return xmalloc ( @@a1@@ ) ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
_BOOL8 __fastcall c_isdigit ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@v2@@ ; @@v2@@ = malloc ( @@a1@@ ) ; if ( ! @@v2@@ && @@a1@@ ) xalloc_die ( ) ; return @@v2@@ ; }
_BOOL8 __fastcall c_isgraph ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
__int64 __fastcall lower_subexps ( __int64 @@a1@@ , __int64 @@a2@@ ) { unsigned int @@v3@@ ; __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; @@v5@@ = __readfsqword ( Number ) ; @@v4@@ = @@a1@@ ; @@v3@@ = Number ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) ) { if ( * ( _BYTE * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) == Number ) { * ( _QWORD * ) ( @@a2@@ + Number ) = lower_subexp ( & @@v3@@ , @@v4@@ , * ( _QWORD * ) ( @@a2@@ + Number ) ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) ) * * ( _QWORD * * ) ( @@a2@@ + Number ) = @@a2@@ ; } } if ( * ( _QWORD * ) ( @@a2@@ + Number ) ) { if ( * ( _BYTE * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) == Number ) { * ( _QWORD * ) ( @@a2@@ + Number ) = lower_subexp ( & @@v3@@ , @@v4@@ , * ( _QWORD * ) ( @@a2@@ + Number ) ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) ) * * ( _QWORD * * ) ( @@a2@@ + Number ) = @@a2@@ ; } } return @@v3@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( ) ; return @@ptr@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
_BOOL8 __fastcall c_isspace ( int @@a1@@ ) { return @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
__int64 __fastcall c_tolower ( int @@a1@@ ) { __int64 @@result@@ ; if ( @@a1@@ <= Number || @@a1@@ > Number ) @@result@@ = ( unsigned int ) @@a1@@ ; else @@result@@ = ( unsigned int ) ( @@a1@@ + Number ) ; return @@result@@ ; }
__int64 __fastcall bkm_scale_by_power ( unsigned __int64 * @@a1@@ , int @@a2@@ , int @@a3@@ ) { unsigned int @@i@@ ; for ( @@i@@ = Number ; @@a3@@ -- ; @@i@@ |= bkm_scale ( @@a1@@ , @@a2@@ ) ) { ; } return @@i@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_2070C8 ; @@v8@@ [ Number ] = qword_2070D0 ; @@v8@@ [ Number ] = qword_2070D8 ; @@v8@@ [ Number ] = qword_2070E0 ; @@v8@@ [ Number ] = qword_2070E8 ; @@v8@@ [ Number ] = qword_2070F0 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
__int64 __fastcall link_nfa_nodes ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; unsigned int @@v3@@ ; unsigned __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; __int64 @@v6@@ ; @@v6@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@v3@@ = Number ; switch ( * ( _BYTE * ) ( @@a2@@ + Number ) ) { case Number : if ( * ( _QWORD * ) ( @@a2@@ + Number ) ) __assert_fail ( String , String , Number , String ) ; return @@result@@ ; case Number : * ( _QWORD * ) ( Number * @@v6@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) ; if ( * ( _BYTE * ) ( @@a2@@ + Number ) == Number ) re_node_set_init_1 ( ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@v6@@ ) , * ( _QWORD * ) ( Number * @@v6@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) ) ; break ; case Number : case Number : case Number : @@v3@@ = re_node_set_init_1 ( ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@v6@@ ) , * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) ) ; break ; case Number : case Number : * ( _BYTE * ) ( @@a1@@ + Number ) |= Number ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) ) @@v4@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) + Number L ) ; else @@v4@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) ) @@v5@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) + Number L ) ; else @@v5@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) ; if ( @@v4@@ > Number ) __assert_fail ( String , String , Number , String ) ; if ( @@v5@@ > Number ) __assert_fail ( String , String , Number , String ) ; @@v3@@ = re_node_set_init_2 ( ( _QWORD * ) ( Number * @@v6@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) , @@v4@@ , @@v5@@ ) ; break ; case Number : return @@v3@@ ; default : if ( ( * ( _BYTE * ) ( @@a2@@ + Number ) & Number ) != Number ) __assert_fail ( String , String , Number , String ) ; * ( _QWORD * ) ( Number * @@v6@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) ; break ; } return @@v3@@ ; }
void __fastcall freea ( unsigned __int64 @@a1@@ ) { _QWORD * @@i@@ ; if ( @@a1@@ && * ( _DWORD * ) ( @@a1@@ - Number ) == Number ) { for ( @@i@@ = & mmalloca_results [ @@a1@@ % Number ] ; * @@i@@ ; @@i@@ = ( _QWORD * ) ( * @@i@@ - Number L ) ) { if ( @@a1@@ == * @@i@@ ) { * @@i@@ = * ( _QWORD * ) ( @@a1@@ - Number ) ; free ( ( void * ) ( @@a1@@ - Number ) ) ; return ; } } } }
bool __fastcall is_basic_1 ( unsigned __int8 @@a1@@ ) { return ( ( is_basic_table [ @@a1@@ >> Number ] >> ( @@a1@@ & Number ) ) & Number ) != Number ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
__int64 __fastcall build_collating_symbol ( __int64 @@a1@@ , __int64 a2 , __int64 a3 , const char * @@a4@@ ) { if ( strlen ( @@a4@@ ) != Number ) return Number L ; bitset_set ( @@a1@@ , * ( unsigned __int8 * ) @@a4@@ ) ; return Number L ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
__int64 __fastcall parse_bracket_element ( __int64 @@a1@@ , __int64 @@a2@@ , _BYTE * @@a3@@ , int @@a4@@ , __int64 a5 , char @@a6@@ , char @@a7@@ ) { __int64 @@result@@ ; int @@v11@@ ; char @@v12@@ [ Number ] ; unsigned __int64 @@v13@@ ; @@v13@@ = __readfsqword ( Number ) ; @@v11@@ = re_string_char_size_at ( @@a2@@ , * ( _QWORD * ) ( @@a2@@ + Number ) ) ; if ( @@v11@@ <= Number ) { * ( _QWORD * ) ( @@a2@@ + Number ) += @@a4@@ ; if ( @@a3@@ [ Number ] == Number || @@a3@@ [ Number ] == Number || @@a3@@ [ Number ] == Number ) { @@result@@ = parse_bracket_symbol ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } else if ( @@a3@@ [ Number ] == Number && @@a7@@ != Number && ( peek_token_bracket ( @@v12@@ , @@a2@@ , @@a6@@ ) , @@v12@@ [ Number ] != Number ) ) { @@result@@ = Number L ; } else { * ( _DWORD * ) @@a1@@ = Number ; * ( _BYTE * ) ( @@a1@@ + Number ) = * @@a3@@ ; @@result@@ = Number L ; } } else { * ( _DWORD * ) @@a1@@ = Number ; * ( _DWORD * ) ( @@a1@@ + Number ) = re_string_wchar_at ( @@a2@@ , * ( _QWORD * ) ( @@a2@@ + Number ) ) ; * ( _QWORD * ) ( @@a2@@ + Number ) += @@v11@@ ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall knuth_morris_pratt_unibyte ( _BYTE * @@a1@@ , char * @@a2@@ , _QWORD * @@a3@@ ) { void * @@v3@@ ; unsigned __int64 @@v4@@ ; _QWORD * @@v6@@ ; char * @@s@@ ; _BYTE * @@v8@@ ; char @@v9@@ ; unsigned __int64 @@i@@ ; __int64 @@v11@@ ; __int64 @@v12@@ ; _BYTE * @@v13@@ ; _BYTE * @@v14@@ ; size_t @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v8@@ = @@a1@@ ; @@s@@ = @@a2@@ ; @@v6@@ = @@a3@@ ; @@v17@@ = __readfsqword ( Number ) ; @@v15@@ = strlen ( @@a2@@ ) ; if ( @@v15@@ > Number ) { @@v4@@ = Number L ; } else if ( Number * @@v15@@ > Number ) { @@v4@@ = mmalloca ( Number * @@v15@@ ) ; } else { @@v3@@ = alloca ( Number * ( ( Number * ( @@v15@@ + Number ) + Number ) / Number ) ) ; @@v4@@ = Number * ( ( ( unsigned __int64 ) & @@v6@@ + Number ) >> Number ) + Number ; } @@v16@@ = @@v4@@ ; if ( ! @@v4@@ ) return Number L ; * ( _QWORD * ) ( @@v16@@ + Number ) = Number L ; @@v11@@ = Number L ; for ( @@i@@ = Number L ; @@i@@ < @@v15@@ ; ++ @@i@@ ) { @@v9@@ = @@s@@ [ @@i@@ - Number ] ; while ( Number ) { if ( @@v9@@ == @@s@@ [ @@v11@@ ] ) { ++ @@v11@@ ; * ( _QWORD * ) ( @@v16@@ + Number * @@i@@ ) = @@i@@ - @@v11@@ ; goto LABEL_15 ; } if ( ! @@v11@@ ) break ; @@v11@@ -= * ( _QWORD * ) ( Number * @@v11@@ + @@v16@@ ) ; } * ( _QWORD * ) ( @@v16@@ + Number * @@i@@ ) = @@i@@ ; LABEL_15 : ; } * @@v6@@ = Number L ; @@v12@@ = Number L ; @@v13@@ = @@v8@@ ; @@v14@@ = @@v8@@ ; while ( * @@v14@@ ) { if ( @@s@@ [ @@v12@@ ] == * @@v14@@ ) { ++ @@v12@@ ; ++ @@v14@@ ; if ( @@v12@@ == @@v15@@ ) { * @@v6@@ = @@v13@@ ; break ; } } else if ( @@v12@@ ) { @@v13@@ += * ( _QWORD * ) ( Number * @@v12@@ + @@v16@@ ) ; @@v12@@ -= * ( _QWORD * ) ( Number * @@v12@@ + @@v16@@ ) ; } else { ++ @@v13@@ ; ++ @@v14@@ ; } } freea ( @@v16@@ ) ; return Number L ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
int raise ( int @@sig@@ ) { return raise ( @@sig@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
__int64 __fastcall mark_opt_subexp ( __int64 @@a1@@ , __int64 @@a2@@ ) { if ( * ( _BYTE * ) ( @@a2@@ + Number ) == Number && @@a1@@ == * ( _QWORD * ) ( @@a2@@ + Number ) ) { * ( _BYTE * ) ( @@a2@@ + Number ) |= Number ; } return Number L ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
struct passwd * getpwnam ( const char * @@name@@ ) { return getpwnam ( @@name@@ ) ; }
void __fastcall free_token ( __int64 @@a1@@ ) { if ( * ( _BYTE * ) ( @@a1@@ + Number ) != Number || ( * ( _BYTE * ) ( @@a1@@ + Number ) & Number ) != Number ) { if ( * ( _BYTE * ) ( @@a1@@ + Number ) == Number && ( * ( _BYTE * ) ( @@a1@@ + Number ) & Number ) == Number ) free ( * ( void * * ) @@a1@@ ) ; } else { free_charset ( * ( void * * * ) @@a1@@ ) ; } }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
int putchar_unlocked ( int @@c@@ ) { return putchar_unlocked ( @@c@@ ) ; }
int fflush ( FILE * @@stream@@ ) { return fflush ( @@stream@@ ) ; }
__int64 __fastcall rpl_re_match ( int @@a1@@ , int @@a2@@ , int @@a3@@ , int @@a4@@ , __int64 @@a5@@ ) { return re_search_stub ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , Number , @@a3@@ , @@a5@@ , Number ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
int fchdir ( int @@fd@@ ) { return fchdir ( @@fd@@ ) ; }
int __cdecl __noreturn main ( int @@argc@@ , const char * * @@argv@@ , const char * * @@envp@@ ) { if ( @@argc@@ == Number ) { set_program_name ( * @@argv@@ , @@argv@@ , @@envp@@ ) ; setlocale ( Number , & locale ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; if ( ! strcmp ( @@argv@@ [ Number ] , String ) ) usage ( Number ) ; if ( ! strcmp ( @@argv@@ [ Number ] , String ) ) version_etc ( ( _DWORD ) stdout , ( unsigned int ) String , ( unsigned int ) String , ( _DWORD ) Version , ( unsigned int ) String , Number , ( char ) @@argv@@ ) ; } exit ( Number ) ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; __int64 @@v2@@ ; char * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; char * @@v9@@ ; @@v1@@ = program_name ; @@v2@@ = program_name ; @@v3@@ = gettext ( String ) ; printf ( @@v3@@ , @@v2@@ , @@v1@@ ) ; @@v4@@ = gettext ( String ) ; printf ( String , @@v4@@ ) ; @@v5@@ = stdout ; @@v6@@ = gettext ( String ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = stdout ; @@v8@@ = gettext ( String ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = gettext ( String String String String ) ; printf ( @@v9@@ , String ) ; emit_ancillary_info ( ) ; exit ( @@a1@@ ) ; }
__int64 __fastcall rpl_re_search ( int @@a1@@ , int @@a2@@ , int @@a3@@ , int @@a4@@ , int @@a5@@ , __int64 @@a6@@ ) { return re_search_stub ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a3@@ , @@a6@@ , Number ) ; }
DIR * fdopendir ( int @@fd@@ ) { return fdopendir ( @@fd@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
__int64 __fastcall rpl_re_match_2 ( int @@a1@@ , int @@a2@@ , int @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ , __int64 @@a7@@ , __int64 @@a8@@ ) { return re_search_2_stub ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ , Number L , @@a7@@ , @@a8@@ , Number ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall dup_cloexec ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 __fastcall have_same_content ( unsigned int @@a1@@ , unsigned int @@a2@@ ) { __int64 @@n@@ ; while ( Number ) { @@n@@ = full_read ( @@a1@@ , & a_buff_6164 , Number L ) ; if ( ! @@n@@ ) break ; if ( @@n@@ != full_read ( @@a2@@ , & b_buff_6165 , Number L ) ) return Number L ; if ( memcmp ( & a_buff_6164 , & b_buff_6165 , @@n@@ ) ) return Number L ; } return Number L ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_206028 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
__int64 __fastcall re_copy_regs ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ , int @@a4@@ ) { _QWORD * @@v5@@ ; unsigned int @@v7@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@v9@@ ; void * @@ptr@@ ; void * @@v11@@ ; @@v7@@ = Number ; @@v9@@ = @@a3@@ + Number ; if ( @@a4@@ ) { if ( @@a4@@ == Number ) { if ( @@v9@@ > * ( _QWORD * ) @@a1@@ ) { @@ptr@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number * @@v9@@ ) ; if ( ! @@ptr@@ ) return Number L ; @@v11@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number * @@v9@@ ) ; if ( ! @@v11@@ ) { free ( @@ptr@@ ) ; return Number L ; } * ( _QWORD * ) ( @@a1@@ + Number ) = @@ptr@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v11@@ ; * ( _QWORD * ) @@a1@@ = @@v9@@ ; } } else { if ( @@a4@@ != Number ) __assert_fail ( String , String , Number , String ) ; if ( @@a3@@ > * ( _QWORD * ) @@a1@@ ) __assert_fail ( String , String , Number , String ) ; @@v7@@ = Number ; } } else { * ( _QWORD * ) ( @@a1@@ + Number ) = malloc ( Number * @@v9@@ ) ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = malloc ( Number * @@v9@@ ) ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) { free ( * ( void * * ) ( @@a1@@ + Number ) ) ; return Number L ; } * ( _QWORD * ) @@a1@@ = @@v9@@ ; } for ( @@i@@ = Number L ; @@i@@ < @@a3@@ ; ++ @@i@@ ) { * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@i@@ ) = * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@i@@ ) = * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ + Number ) ; } while ( @@i@@ < * ( _QWORD * ) @@a1@@ ) { @@v5@@ = ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) ; * @@v5@@ = Number ; * ( _QWORD * ) ( Number * @@i@@ ++ + * ( _QWORD * ) ( @@a1@@ + Number ) ) = * @@v5@@ ; } return @@v7@@ ; }
unsigned __int64 __fastcall setdefaultfilecon ( char * @@a1@@ ) { char * @@v1@@ ; __int64 @@v2@@ ; char * @@v3@@ ; int * @@v4@@ ; char * @@s1@@ ; _BYTE * @@i@@ ; char * @@src@@ ; char * @@dest@@ ; struct stat @@v10@@ ; unsigned __int64 @@v11@@ ; @@v11@@ = __readfsqword ( Number ) ; @@s1@@ = Number L ; if ( selinux_enabled == Number && ! ( unsigned int ) lstat ( @@a1@@ , & @@v10@@ ) ) { if ( first_call_6195 ) { if ( * @@a1@@ == Number ) { for ( @@i@@ = @@a1@@ + Number ; * @@i@@ == Number ; ++ @@i@@ ) { ; } @@src@@ = @@i@@ - Number ; if ( * @@i@@ ) { do ++ @@i@@ ; while ( * @@i@@ && * @@i@@ != Number ) ; @@dest@@ = ( char * ) malloc ( @@i@@ - @@src@@ + Number ) ; if ( @@dest@@ ) { * ( _WORD * ) stpncpy ( @@dest@@ , @@src@@ , @@i@@ - @@src@@ ) = Number ; free ( @@dest@@ ) ; } } } } first_call_6195 = Number ; if ( ! ( unsigned int ) matchpathcon ( @@a1@@ , @@v10@@ . st_mode , & @@s1@@ ) && strcmp ( @@s1@@ , String ) ) { if ( ( int ) lsetfilecon ( @@a1@@ , @@s1@@ ) < Number && * __errno_location ( ) != Number ) { @@v1@@ = @@s1@@ ; @@v2@@ = quotearg_colon ( @@a1@@ ) ; @@v3@@ = gettext ( String ) ; @@v4@@ = __errno_location ( ) ; error ( Number , * @@v4@@ , @@v3@@ , @@v2@@ , @@v1@@ ) ; } goto LABEL_20 ; } if ( @@s1@@ ) { LABEL_20 : freecon ( ) ; return __readfsqword ( Number ) ^ @@v11@@ ; } } return __readfsqword ( Number ) ^ @@v11@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_206028 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 __fastcall copy_file ( char * @@a1@@ , char * @@a2@@ , __int64 @@a3@@ ) { __int64 @@result@@ ; char @@v5@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = __readfsqword ( Number ) ; if ( copy_only_if_needed && ! need_copy ( @@a1@@ , @@a2@@ , @@a3@@ ) ) { @@result@@ = Number L ; } else { @@result@@ = copy ( @@a1@@ , @@a2@@ , Number L , @@a3@@ , & @@v5@@ , Number L ) ; } return @@result@@ ; }
__int64 __fastcall sift_states_backward ( __int64 @@a1@@ , __int64 @@a2@@ ) { int @@v3@@ ; unsigned int @@v4@@ ; unsigned int @@v5@@ ; int @@v6@@ ; __int64 @@v7@@ ; void * @@v8@@ [ Number ] ; void * @@ptr@@ ; unsigned __int64 @@v10@@ ; @@v10@@ = __readfsqword ( Number ) ; @@v6@@ = Number ; @@v7@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@v4@@ = re_node_set_init_1 ( @@v8@@ , * ( _QWORD * ) ( @@a2@@ + Number ) ) ; if ( @@v4@@ ) return @@v4@@ ; @@v5@@ = update_cur_sifted_state ( @@a1@@ , @@a2@@ , @@v7@@ , @@v8@@ ) ; if ( ! @@v5@@ ) { while ( @@v7@@ ) { if ( * ( _QWORD * ) ( Number * @@v7@@ + * ( _QWORD * ) @@a2@@ ) ) @@v3@@ = Number ; else @@v3@@ = @@v6@@ + Number ; @@v6@@ = @@v3@@ ; if ( @@v3@@ > * ( _DWORD * ) ( @@a1@@ + Number ) ) { memset ( * ( void * * ) @@a2@@ , Number , Number * @@v7@@ ) ; free ( @@ptr@@ ) ; return Number L ; } @@v8@@ [ Number ] = Number L ; -- @@v7@@ ; if ( ! * ( _QWORD * ) ( Number * @@v7@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) || ( @@v5@@ = build_sifted_states ( @@a1@@ , @@a2@@ , @@v7@@ , @@v8@@ ) ) == Number ) { @@v5@@ = update_cur_sifted_state ( @@a1@@ , @@a2@@ , @@v7@@ , @@v8@@ ) ; if ( ! @@v5@@ ) continue ; } goto LABEL_15 ; } @@v5@@ = Number ; } LABEL_15 : free ( @@ptr@@ ) ; return @@v5@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_2060A8 ; @@v8@@ [ Number ] = qword_2060B0 ; @@v8@@ [ Number ] = qword_2060B8 ; @@v8@@ [ Number ] = qword_2060C0 ; @@v8@@ [ Number ] = qword_2060C8 ; @@v8@@ [ Number ] = qword_2060D0 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
unsigned __int64 get_ids ( ) { __int64 @@v0@@ ; char * @@v1@@ ; __int64 @@v2@@ ; char * @@v3@@ ; unsigned __int64 @@v5@@ ; struct passwd * @@v6@@ ; struct group * @@v7@@ ; unsigned __int64 @@v8@@ ; @@v8@@ = __readfsqword ( Number ) ; if ( owner_name ) { @@v6@@ = getpwnam ( owner_name ) ; if ( @@v6@@ ) { owner_id = @@v6@@ -> pw_uid ; } else { if ( ( unsigned int ) xstrtoul ( owner_name , Number L , Number L , & @@v5@@ , Number L ) || @@v5@@ > Number ) { @@v0@@ = quote ( owner_name ) ; @@v1@@ = gettext ( String ) ; error ( Number , Number , @@v1@@ , @@v0@@ ) ; } owner_id = @@v5@@ ; } endpwent ( ) ; } else { owner_id = Number ; } if ( group_name ) { @@v7@@ = getgrnam ( group_name ) ; if ( @@v7@@ ) { group_id = @@v7@@ -> gr_gid ; } else { if ( ( unsigned int ) xstrtoul ( group_name , Number L , Number L , & @@v5@@ , Number L ) || @@v5@@ > Number ) { @@v2@@ = quote ( group_name ) ; @@v3@@ = gettext ( String ) ; error ( Number , Number , @@v3@@ , @@v2@@ ) ; } group_id = @@v5@@ ; } endgrent ( ) ; } else { group_id = Number ; } return __readfsqword ( Number ) ^ @@v8@@ ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 __fastcall sub_epsilon_src_nodes ( _QWORD * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ ) { __int64 @@v4@@ ; unsigned int @@v8@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@j@@ ; __int64 @@v11@@ ; unsigned __int64 @@v12@@ ; unsigned __int64 @@v13@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; char @@s@@ [ Number ] ; void * @@ptr@@ ; unsigned __int64 @@v19@@ ; @@v19@@ = __readfsqword ( Number ) ; @@v11@@ = @@a1@@ [ Number ] + Number * @@a2@@ ; memset ( @@s@@ , Number , Number ) ; for ( @@i@@ = Number L ; @@i@@ < * ( _QWORD * ) ( @@v11@@ + Number ) ; ++ @@i@@ ) { @@v14@@ = * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@v11@@ + Number ) ) ; if ( @@v14@@ != @@a2@@ && ( * ( _BYTE * ) ( Number * @@v14@@ + * @@a1@@ + Number ) & Number ) != Number ) { @@v15@@ = * * ( _QWORD * * ) ( @@a1@@ [ Number ] + Number * @@v14@@ + Number ) ; @@v4@@ = * ( _QWORD * ) ( @@a1@@ [ Number ] + Number * @@v14@@ + Number ) <= Number ? Number : * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ [ Number ] + Number * @@v14@@ + Number ) + Number L ) ; if ( ( @@v16@@ = @@v4@@ , ! re_node_set_contains ( @@v11@@ , @@v15@@ ) ) && re_node_set_contains ( @@a3@@ , @@v15@@ ) || @@v16@@ - Number <= Number && ! re_node_set_contains ( @@v11@@ , @@v16@@ ) && re_node_set_contains ( @@a3@@ , @@v16@@ ) ) { @@v8@@ = re_node_set_add_intersect ( ( __int64 ) @@s@@ , @@a4@@ , @@a1@@ [ Number ] + Number * @@v14@@ ) ; if ( @@v8@@ ) { free ( @@ptr@@ ) ; return @@v8@@ ; } } } } for ( @@j@@ = Number L ; @@j@@ < * ( _QWORD * ) ( @@v11@@ + Number ) ; ++ @@j@@ ) { @@v12@@ = * ( _QWORD * ) ( Number * @@j@@ + * ( _QWORD * ) ( @@v11@@ + Number ) ) ; if ( ! re_node_set_contains ( ( __int64 ) @@s@@ , @@v12@@ ) ) { @@v13@@ = re_node_set_contains ( @@a3@@ , @@v12@@ ) - Number ; re_node_set_remove_at ( @@a3@@ , @@v13@@ ) ; } } free ( @@ptr@@ ) ; return Number L ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
unsigned __int64 __fastcall lcm ( unsigned __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return @@a1@@ * ( @@a2@@ / gcd ( @@a1@@ , @@a2@@ ) ) ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; FILE * @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; char * @@v13@@ ; char * @@v14@@ ; if ( @@a1@@ ) { @@v1@@ = program_name ; @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = program_name ; @@v4@@ = program_name ; @@v5@@ = gettext ( String ) ; printf ( @@v5@@ , @@v4@@ , @@v3@@ ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; @@v8@@ = stdout ; @@v9@@ = gettext ( String ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = stdout ; @@v11@@ = gettext ( String ) ; fputs_unlocked ( @@v11@@ , @@v10@@ ) ; @@v12@@ = program_name ; @@v13@@ = gettext ( String String String String String String ) ; printf ( @@v13@@ , @@v12@@ ) ; @@v14@@ = gettext ( String String String String ) ; printf ( @@v14@@ , String ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
__int64 __fastcall get_stat_atime_0 ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int64 __fastcall merge_state_with_log ( _DWORD * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v4@@ ; __int64 * @@v5@@ ; __int64 @@v6@@ ; unsigned int @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; __int64 @@v12@@ [ Number ] ; void * @@ptr@@ ; unsigned __int64 @@v14@@ ; @@v6@@ = @@a3@@ ; @@v14@@ = __readfsqword ( Number ) ; @@v9@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@v10@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( @@v10@@ <= * ( _QWORD * ) ( @@a2@@ + Number ) ) { if ( * ( _QWORD * ) ( Number * @@v10@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) ) { @@v8@@ = Number L ; @@v11@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( Number * @@v10@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) + Number L ) ; if ( @@a3@@ ) { @@v8@@ = * ( _QWORD * ) ( @@a3@@ + Number ) ; * @@a1@@ = re_node_set_init_union ( @@v12@@ , @@v8@@ , @@v11@@ ) ; if ( * @@a1@@ ) return Number L ; } else { @@v4@@ = * ( _QWORD * ) ( @@v11@@ + Number ) ; @@v12@@ [ Number ] = * ( _QWORD * ) @@v11@@ ; @@v12@@ [ Number ] = @@v4@@ ; @@ptr@@ = * ( void * * ) ( @@v11@@ + Number ) ; } @@v7@@ = re_string_context_at ( @@a2@@ , * ( _QWORD * ) ( @@a2@@ + Number ) - Number L , * ( _DWORD * ) ( @@a2@@ + Number ) ) ; @@v5@@ = ( __int64 * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number * @@v10@@ ) ; * @@v5@@ = re_acquire_state_context ( @@a1@@ , @@v9@@ , ( __int64 ) @@v12@@ , @@v7@@ ) ; @@v6@@ = * @@v5@@ ; if ( @@v8@@ ) free ( @@ptr@@ ) ; } else { * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number * @@v10@@ ) = @@a3@@ ; } } else { * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number * @@v10@@ ) = @@a3@@ ; * ( _QWORD * ) ( @@a2@@ + Number ) = @@v10@@ ; } if ( * ( _QWORD * ) ( @@v9@@ + Number ) && @@v6@@ ) { * @@a1@@ = check_subexp_matching_top ( @@a2@@ , @@v6@@ + Number , @@v10@@ ) ; if ( * @@a1@@ ) return Number L ; if ( ( * ( _BYTE * ) ( @@v6@@ + Number ) & Number ) != Number ) { * @@a1@@ = transit_state_bkref ( @@a2@@ , @@v6@@ + Number ) ; if ( * @@a1@@ ) return Number L ; @@v6@@ = * ( _QWORD * ) ( Number * @@v10@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) ; } } return @@v6@@ ; }
int isatty ( int @@fd@@ ) { return isatty ( @@fd@@ ) ; }
__int64 __fastcall file_name_concat ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v4@@ ; @@v4@@ = mfile_name_concat ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( ! @@v4@@ ) xalloc_die ( ) ; return @@v4@@ ; }
__int64 __fastcall utimens_symlink ( __int64 @@a1@@ , __int64 @@a2@@ ) { unsigned int @@v3@@ ; @@v3@@ = lutimens ( @@a1@@ , @@a2@@ ) ; if ( @@v3@@ && * __errno_location ( ) == Number ) @@v3@@ = Number ; return @@v3@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_207028 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
void __fastcall match_ctx_free ( __int64 @@a1@@ ) { match_ctx_clean ( ( _QWORD * ) @@a1@@ ) ; free ( * ( void * * ) ( @@a1@@ + Number ) ) ; free ( * ( void * * ) ( @@a1@@ + Number ) ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
int __fastcall fchmod_or_lchmod ( int @@a1@@ , const char * @@a2@@ , __mode_t @@a3@@ ) { int @@result@@ ; if ( @@a1@@ < Number ) @@result@@ = chmod ( @@a2@@ , @@a3@@ ) ; else @@result@@ = fchmod ( @@a1@@ , @@a3@@ ) ; return @@result@@ ; }
__mode_t umask ( __mode_t @@mask@@ ) { return umask ( @@mask@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int64 __fastcall search_cur_bkref_entry ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { __int64 @@result@@ ; unsigned __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; @@v4@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v3@@ = Number L ; while ( @@v3@@ < @@v4@@ ) { if ( @@a2@@ <= * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * ( ( @@v3@@ + @@v4@@ ) >> Number ) + Number ) ) @@v4@@ = ( @@v3@@ + @@v4@@ ) >> Number ; else @@v3@@ = ( ( @@v3@@ + @@v4@@ ) >> Number ) + Number ; } if ( @@v3@@ < * ( _QWORD * ) ( @@a1@@ + Number ) && @@a2@@ == * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@v3@@ + Number ) ) { @@result@@ = @@v3@@ ; } else { @@result@@ = Number ; } return @@result@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
unsigned __int64 __fastcall overwrite_prompt ( const char * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; char * @@v4@@ ; char * @@v5@@ ; __int64 @@v6@@ ; char * @@v7@@ ; char * @@v8@@ ; char @@v10@@ ; _BYTE @@v11@@ [ Number ] ; unsigned __int64 @@v12@@ ; @@v12@@ = __readfsqword ( Number ) ; if ( ! writable_destination ( @@a1@@ , * ( _DWORD * ) ( @@a2@@ + Number ) ) ) { strmode ( * ( unsigned int * ) ( @@a2@@ + Number ) , & @@v10@@ ) ; @@v11@@ [ Number ] = Number ; @@v2@@ = * ( _DWORD * ) ( @@a2@@ + Number ) & Number ; @@v3@@ = quote ( @@a1@@ ) ; @@v4@@ = program_name ; @@v5@@ = gettext ( String ) ; fprintf ( stderr , @@v5@@ , @@v4@@ , @@v3@@ , @@v2@@ , @@v11@@ ) ; } else { @@v6@@ = quote ( @@a1@@ ) ; @@v7@@ = program_name ; @@v8@@ = gettext ( String ) ; fprintf ( stderr , @@v8@@ , @@v7@@ , @@v6@@ ) ; } return __readfsqword ( Number ) ^ @@v12@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
void * __fastcall sift_ctx_init ( _QWORD * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ ) { * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@a3@@ ; @@a1@@ [ Number ] = @@a4@@ ; @@a1@@ [ Number ] = @@a5@@ ; return memset ( @@a1@@ + Number , Number , Number ) ; }
DIR * opendir ( const char * @@name@@ ) { return opendir ( @@name@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
__int64 __fastcall dup_safer ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
__int64 __fastcall valid_options ( __int64 @@a1@@ ) { if ( ! @@a1@@ ) __assert_fail ( String , String , Number , String ) ; if ( * ( _DWORD * ) @@a1@@ > Number ) __assert_fail ( String , String , Number , String ) ; if ( * ( _DWORD * ) ( @@a1@@ + Number ) != Number && * ( _DWORD * ) ( @@a1@@ + Number ) != Number && * ( _DWORD * ) ( @@a1@@ + Number ) != Number ) { __assert_fail ( String , String , Number , String ) ; } if ( * ( _DWORD * ) ( @@a1@@ + Number ) && * ( _DWORD * ) ( @@a1@@ + Number ) != Number && * ( _DWORD * ) ( @@a1@@ + Number ) != Number ) { __assert_fail ( String , String , Number , String ) ; } if ( * ( _BYTE * ) ( @@a1@@ + Number ) == Number && * ( _BYTE * ) ( @@a1@@ + Number ) == Number ) __assert_fail ( String , String , Number , String ) ; if ( * ( _DWORD * ) ( @@a1@@ + Number ) == Number && * ( _DWORD * ) ( @@a1@@ + Number ) != Number ) __assert_fail ( String , String , Number , String ) ; return Number L ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v4@@ ; @@v4@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v4@@ >= Number / @@a3@@ ) xalloc_die ( ) ; @@v4@@ += ( @@v4@@ + Number ) >> Number ; } else if ( ! @@v4@@ ) { @@v4@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v4@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v4@@ ) ; }
_BYTE * __fastcall longest_relative_suffix ( _BYTE * @@a1@@ ) { while ( * @@a1@@ == Number ) ++ @@a1@@ ; return @@a1@@ ; }
struct group * getgrnam ( const char * @@name@@ ) { return getgrnam ( @@name@@ ) ; }
__int64 __fastcall remember_copied ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v5@@ ; __int64 @@v6@@ ; @@v5@@ = xmalloc ( Number L ) ; * ( _QWORD * ) ( @@v5@@ + Number ) = xstrdup ( @@a1@@ ) ; * ( _QWORD * ) @@v5@@ = @@a2@@ ; * ( _QWORD * ) ( @@v5@@ + Number ) = @@a3@@ ; @@v6@@ = hash_insert ( src_to_dest , @@v5@@ ) ; if ( ! @@v6@@ ) xalloc_die ( ) ; if ( @@v6@@ == @@v5@@ ) return Number L ; src_to_dest_free ( ( void * * ) @@v5@@ ) ; return * ( _QWORD * ) ( @@v6@@ + Number ) ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_207028 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@v3@@ ; @@v3@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v3@@ ) xalloc_die ( ) ; return @@v3@@ ; }
char * nl_langinfo ( nl_item @@item@@ ) { return nl_langinfo ( @@item@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__pid_t waitpid ( __pid_t @@pid@@ , int * @@stat_loc@@ , int @@options@@ ) { return waitpid ( @@pid@@ , @@stat_loc@@ , @@options@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall full_read ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v5@@ ; __int64 @@v7@@ ; @@v5@@ = Number L ; while ( @@a3@@ ) { @@v7@@ = safe_read ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( @@v7@@ == Number ) break ; if ( ! @@v7@@ ) { * __errno_location ( ) = Number ; return @@v5@@ ; } @@v5@@ += @@v7@@ ; @@a2@@ += @@v7@@ ; @@a3@@ -= @@v7@@ ; } return @@v5@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 __fastcall c_strcasecmp ( unsigned __int8 * @@a1@@ , unsigned __int8 * @@a2@@ ) { unsigned __int8 * @@v2@@ ; unsigned __int8 * @@v3@@ ; unsigned __int8 @@v5@@ ; unsigned __int8 @@v6@@ ; @@v2@@ = @@a1@@ ; @@v3@@ = @@a2@@ ; if ( @@a1@@ == @@a2@@ ) return Number L ; do { @@v5@@ = c_tolower ( * @@v2@@ ) ; @@v6@@ = c_tolower ( * @@v3@@ ) ; if ( ! @@v5@@ ) break ; ++ @@v2@@ ; ++ @@v3@@ ; } while ( @@v5@@ == @@v6@@ ) ; return @@v5@@ - ( unsigned int ) @@v6@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
void * __fastcall mfile_name_concat ( _BYTE * @@a1@@ , _BYTE * @@a2@@ , _QWORD * @@a3@@ ) { _BOOL4 @@v3@@ ; const char * @@v6@@ ; size_t @@v7@@ ; size_t @@n@@ ; _BOOL8 @@v9@@ ; char * @@s@@ ; size_t @@v11@@ ; void * @@dest@@ ; _BYTE * @@v13@@ ; char * @@v14@@ ; @@v6@@ = last_component ( @@a1@@ ) ; @@v7@@ = base_len ( @@v6@@ ) ; @@n@@ = @@v6@@ - @@a1@@ + @@v7@@ ; @@v3@@ = @@v7@@ && @@v6@@ [ @@v7@@ - Number ] != Number ; @@v9@@ = @@v3@@ ; @@s@@ = longest_relative_suffix ( @@a2@@ ) ; @@v11@@ = strlen ( @@s@@ ) ; @@dest@@ = malloc ( @@v9@@ + @@n@@ + @@v11@@ + Number ) ; if ( ! @@dest@@ ) return Number L ; @@v13@@ = mempcpy ( @@dest@@ , @@a1@@ , @@n@@ ) ; * @@v13@@ = Number ; @@v14@@ = & @@v13@@ [ @@v9@@ ] ; if ( @@a3@@ ) * @@a3@@ = & @@v14@@ [ - ( * @@a2@@ == Number ) ] ; * ( _BYTE * ) mempcpy ( @@v14@@ , @@s@@ , @@v11@@ ) = Number ; return @@dest@@ ; }
__int64 __fastcall process_dir ( int @@a1@@ , int @@a2@@ , int @@a3@@ ) { return ( unsigned __int8 ) make_dir_parents ( @@a1@@ , @@a2@@ , ( unsigned int ) make_ancestor , @@a3@@ , dir_mode , ( unsigned int ) announce_mkdir , dir_mode_bits , owner_id , group_id , Number ) ^ Number ; }
_BOOL8 __fastcall triple_compare_ino_str ( __int64 @@a1@@ , __int64 @@a2@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) == * ( _QWORD * ) ( @@a2@@ + Number ) && * ( _QWORD * ) ( @@a1@@ + Number ) == * ( _QWORD * ) ( @@a2@@ + Number ) && ! strcmp ( * ( const char * * ) @@a1@@ , * ( const char * * ) @@a2@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return xmalloc ( @@a1@@ , @@a2@@ , @@a3@@ ) ; }
char * __fastcall str_iconv ( char * @@a1@@ , char * @@a2@@ , char * @@a3@@ ) { char * @@result@@ ; int @@v5@@ ; int @@v6@@ ; iconv_t @@cd@@ ; void * @@ptr@@ ; char * @@v9@@ ; if ( * @@a1@@ && ( unsigned int ) c_strcasecmp ( ( unsigned __int8 * ) @@a2@@ , ( unsigned __int8 * ) @@a3@@ ) ) { @@cd@@ = iconv_open ( @@a3@@ , @@a2@@ ) ; if ( @@cd@@ == ( iconv_t ) Number ) return Number L ; @@ptr@@ = str_cd_iconv ( @@a1@@ , @@cd@@ ) ; if ( @@ptr@@ ) { if ( iconv_close ( @@cd@@ ) < Number ) { @@v5@@ = * __errno_location ( ) ; free ( @@ptr@@ ) ; * __errno_location ( ) = @@v5@@ ; return Number L ; } } else { @@v6@@ = * __errno_location ( ) ; iconv_close ( @@cd@@ ) ; * __errno_location ( ) = @@v6@@ ; } @@result@@ = ( char * ) @@ptr@@ ; } else { @@v9@@ = strdup ( @@a1@@ ) ; if ( ! @@v9@@ ) * __errno_location ( ) = Number ; @@result@@ = @@v9@@ ; } return @@result@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
_BOOL8 __fastcall c_isprint ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
_BOOL8 __fastcall c_isupper ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall install_file_in_file ( char * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v3@@ ; char * @@v4@@ ; int * @@v5@@ ; __int64 @@result@@ ; struct stat @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; if ( * ( _BYTE * ) ( @@a3@@ + Number ) && ( unsigned int ) stat ( @@a1@@ , & @@v8@@ ) ) { @@v3@@ = quote ( @@a1@@ ) ; @@v4@@ = gettext ( String ) ; @@v5@@ = __errno_location ( ) ; error ( Number , * @@v5@@ , @@v4@@ , @@v3@@ ) ; @@result@@ = Number L ; } else if ( ( unsigned __int8 ) copy_file ( @@a1@@ , @@a2@@ , @@a3@@ ) != Number ) { @@result@@ = Number L ; } else { if ( strip_files ) strip ( @@a2@@ ) ; if ( * ( _BYTE * ) ( @@a3@@ + Number ) && ( strip_files || ( @@v8@@ . st_mode & Number ) != Number ) && ( unsigned __int8 ) change_timestamps ( & @@v8@@ , @@a2@@ ) != Number ) { @@result@@ = Number L ; } else { @@result@@ = change_attributes ( @@a2@@ ) ; } } return @@result@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 __fastcall change_attributes ( char * @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; int * @@v3@@ ; __int64 @@v4@@ ; char * @@v5@@ ; int * @@v6@@ ; unsigned __int8 @@v8@@ ; @@v8@@ = Number ; if ( owner_id == Number && group_id == Number || ! lchown ( @@a1@@ , owner_id , group_id ) ) { if ( chmod ( @@a1@@ , mode ) ) { @@v4@@ = quote ( @@a1@@ ) ; @@v5@@ = gettext ( String ) ; @@v6@@ = __errno_location ( ) ; error ( Number , * @@v6@@ , @@v5@@ , @@v4@@ ) ; } else { @@v8@@ = Number ; } } else { @@v1@@ = quote ( @@a1@@ ) ; @@v2@@ = gettext ( String ) ; @@v3@@ = __errno_location ( ) ; error ( Number , * @@v3@@ , @@v2@@ , @@v1@@ ) ; } if ( use_default_selinux_context ) setdefaultfilecon ( @@a1@@ ) ; return @@v8@@ ; }
_BOOL8 __fastcall c_isxdigit ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number || ( int ) ( @@a1@@ & Number ) > Number && ( int ) ( @@a1@@ & Number ) <= Number ; }
__int64 __fastcall savewd_restore ( _DWORD * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; int @@stat_loc@@ ; __pid_t @@pid@@ ; int @@v5@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = __readfsqword ( Number ) ; switch ( * @@a1@@ ) { case Number : case Number : goto LABEL_17 ; case Number : if ( fchdir ( @@a1@@ [ Number ] ) ) { @@v5@@ = * __errno_location ( ) ; close ( @@a1@@ [ Number ] ) ; * @@a1@@ = Number ; @@a1@@ [ Number ] = @@v5@@ ; LABEL_5 : * __errno_location ( ) = @@a1@@ [ Number ] ; @@result@@ = Number ; } else { * @@a1@@ = Number ; LABEL_17 : @@result@@ = Number L ; } break ; case Number : @@pid@@ = @@a1@@ [ Number ] ; if ( ! @@pid@@ ) _exit ( @@a2@@ ) ; if ( @@pid@@ <= Number ) goto LABEL_17 ; while ( waitpid ( @@pid@@ , & @@stat_loc@@ , Number ) < Number ) { if ( * __errno_location ( ) != Number ) __assert_fail ( String , String , Number , String ) ; } @@a1@@ [ Number ] = Number ; if ( ( @@stat_loc@@ & Number ) != Number ) raise ( @@stat_loc@@ & Number ) ; @@result@@ = BYTE1 ( @@stat_loc@@ ) ; break ; case Number : goto LABEL_5 ; default : __assert_fail ( String , String , Number , String ) ; } return @@result@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
__int64 __fastcall make_ancestor ( __int64 @@a1@@ , const char * @@a2@@ , __int64 @@a3@@ ) { unsigned int @@v5@@ ; @@v5@@ = mkdir ( @@a2@@ , Number ) ; if ( ! @@v5@@ ) announce_mkdir ( @@a1@@ , @@a3@@ ) ; return @@v5@@ ; }
unsigned __int64 __fastcall mmalloca ( unsigned __int64 @@a1@@ ) { char * @@v2@@ ; unsigned __int64 @@v3@@ ; if ( @@a1@@ + Number < @@a1@@ ) return Number L ; @@v2@@ = ( char * ) malloc ( @@a1@@ + Number ) ; if ( ! @@v2@@ ) return Number L ; @@v3@@ = ( unsigned __int64 ) ( @@v2@@ + Number ) ; * ( _DWORD * ) ( @@v3@@ - Number ) = Number ; * ( _QWORD * ) ( @@v3@@ - Number ) = mmalloca_results [ @@v3@@ % Number ] ; mmalloca_results [ @@v3@@ % Number ] = @@v3@@ ; return @@v3@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_2070C8 ; @@v4@@ [ Number ] = qword_2070D0 ; @@v4@@ [ Number ] = qword_2070D8 ; @@v4@@ [ Number ] = qword_2070E0 ; @@v4@@ [ Number ] = qword_2070E8 ; @@v4@@ [ Number ] = qword_2070F0 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
__int64 __fastcall dir_name ( __int64 @@a1@@ ) { __int64 @@v2@@ ; @@v2@@ = mdir_name ( @@a1@@ ) ; if ( ! @@v2@@ ) xalloc_die ( ) ; return @@v2@@ ; }
__int64 __fastcall io_blksize ( __int64 a1 , __int64 a2 , __int64 a3 , __int64 a4 , __int64 a5 , __int64 a6 , int a7 , int a8 , int a9 , int a10 , int a11 , int a12 , int a13 , __int64 @@a14@@ ) { __int64 @@result@@ ; if ( @@a14@@ <= Number || ( unsigned __int64 ) @@a14@@ > Number || @@a14@@ <= Number ) { @@result@@ = Number ; } else { @@result@@ = @@a14@@ ; } return @@result@@ ; }
int __fastcall fstat ( int @@fildes@@ , struct stat * @@stat_buf@@ ) { return __fxstat ( Number , @@fildes@@ , @@stat_buf@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
_BOOL8 __fastcall errno_unsupported ( int @@a1@@ ) { return @@a1@@ == Number || @@a1@@ == Number ; }
int unlink ( const char * @@name@@ ) { return unlink ( @@name@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
_BYTE * __fastcall dir_len ( _BYTE * @@a1@@ ) { _BYTE * @@i@@ ; unsigned __int64 @@v3@@ ; @@v3@@ = * @@a1@@ == Number ; for ( @@i@@ = ( _BYTE * ) ( last_component ( @@a1@@ ) - @@a1@@ ) ; @@v3@@ < ( unsigned __int64 ) @@i@@ && @@a1@@ [ ( _QWORD ) ( @@i@@ - Number ) ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
int chdir ( const char * @@path@@ ) { return chdir ( @@path@@ ) ; }
int __fastcall rpl_fflush ( FILE * @@a1@@ ) { if ( ! @@a1@@ || ! __freading ( @@a1@@ ) ) return fflush ( @@a1@@ ) ; clear_ungetc_buffer_preserving_position ( @@a1@@ ) ; return fflush ( @@a1@@ ) ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__mode_t umask ( __mode_t @@mask@@ ) { return umask ( @@mask@@ ) ; }
_BYTE * __fastcall filemodestring ( __int64 @@a1@@ , _BYTE * @@a2@@ ) { return strmode ( * ( _DWORD * ) ( @@a1@@ + Number ) , @@a2@@ ) ; }
struct dirent * readdir ( DIR * @@dirp@@ ) { return readdir ( @@dirp@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
int rename ( const char * @@old@@ , const char * @@a2@@ ) { return rename ( @@old@@ , @@a2@@ ) ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
void free ( void * @@ptr@@ ) { __imp_free ( @@ptr@@ ) ; }
void * __fastcall mfile_name_concat ( _BYTE * @@a1@@ , _BYTE * @@a2@@ , _QWORD * @@a3@@ ) { _BOOL4 @@v3@@ ; const char * @@v6@@ ; size_t @@v7@@ ; size_t @@n@@ ; _BOOL8 @@v9@@ ; char * @@s@@ ; size_t @@v11@@ ; void * @@dest@@ ; _BYTE * @@v13@@ ; char * @@v14@@ ; @@v6@@ = last_component ( @@a1@@ ) ; @@v7@@ = base_len ( @@v6@@ ) ; @@n@@ = @@v6@@ - @@a1@@ + @@v7@@ ; @@v3@@ = @@v7@@ && @@v6@@ [ @@v7@@ - Number ] != Number ; @@v9@@ = @@v3@@ ; @@s@@ = longest_relative_suffix ( @@a2@@ ) ; @@v11@@ = strlen ( @@s@@ ) ; @@dest@@ = malloc ( @@v9@@ + @@n@@ + @@v11@@ + Number ) ; if ( ! @@dest@@ ) return Number L ; @@v13@@ = mempcpy ( @@dest@@ , @@a1@@ , @@n@@ ) ; * @@v13@@ = Number ; @@v14@@ = & @@v13@@ [ @@v9@@ ] ; if ( @@a3@@ ) * @@a3@@ = & @@v14@@ [ - ( * @@a2@@ == Number ) ] ; * ( _BYTE * ) mempcpy ( @@v14@@ , @@s@@ , @@v11@@ ) = Number ; return @@dest@@ ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
__int64 __fastcall set_owner ( __int64 @@a1@@ , const char * @@a2@@ , unsigned int @@a3@@ , _DWORD * @@a4@@ , char @@a5@@ , __int64 @@a6@@ ) { int @@v6@@ ; unsigned __int16 @@v7@@ ; __int64 @@v8@@ ; char * @@v9@@ ; int * @@v10@@ ; __int64 @@result@@ ; __int64 @@v12@@ ; char * @@v13@@ ; int * @@v14@@ ; __uid_t @@owner@@ ; __gid_t @@group@@ ; int @@v18@@ ; unsigned int @@v19@@ ; int @@v20@@ ; int @@v21@@ ; @@owner@@ = @@a4@@ [ Number ] ; @@group@@ = @@a4@@ [ Number ] ; if ( @@a5@@ != Number && ( * ( _BYTE * ) ( @@a1@@ + Number ) || * ( _BYTE * ) ( @@a1@@ + Number ) || * ( _BYTE * ) ( @@a1@@ + Number ) ) && ( ( @@v18@@ = * ( _DWORD * ) ( @@a6@@ + Number ) , ! * ( _BYTE * ) ( @@a1@@ + Number ) ) && ! * ( _BYTE * ) ( @@a1@@ + Number ) ? ( @@v6@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ) : ( @@v6@@ = @@a4@@ [ Number ] ) , ( @@v19@@ = ( unsigned __int16 ) @@v6@@ & ( unsigned __int16 ) @@v18@@ & Number , @@v7@@ = ~ ( _WORD ) @@v6@@ , HIBYTE ( @@v7@@ ) |= Number , ( ( unsigned __int16 ) @@v18@@ & @@v7@@ & Number ) != Number ) && ( unsigned int ) qset_acl ( @@a2@@ , @@a3@@ , @@v19@@ ) ) ) { if ( ( unsigned __int8 ) owner_failure_ok ( @@a1@@ ) != Number ) { @@v8@@ = quote ( @@a2@@ ) ; @@v9@@ = gettext ( String ) ; @@v10@@ = __errno_location ( ) ; error ( Number , * @@v10@@ , @@v9@@ , @@v8@@ ) ; } @@result@@ = ( unsigned int ) - * ( unsigned __int8 * ) ( @@a1@@ + Number ) ; } else { if ( @@a3@@ == Number ) { if ( ! lchown ( @@a2@@ , @@owner@@ , @@group@@ ) ) return Number L ; if ( * __errno_location ( ) == Number || * __errno_location ( ) == Number ) { @@v20@@ = * __errno_location ( ) ; lchown ( @@a2@@ , Number , @@group@@ ) ; ignore_value ( ) ; * __errno_location ( ) = @@v20@@ ; } } else { if ( ! fchown ( @@a3@@ , @@owner@@ , @@group@@ ) ) return Number L ; if ( * __errno_location ( ) == Number || * __errno_location ( ) == Number ) { @@v21@@ = * __errno_location ( ) ; fchown ( @@a3@@ , Number , @@group@@ ) ; ignore_value ( ) ; * __errno_location ( ) = @@v21@@ ; } } if ( ( unsigned __int8 ) chown_failure_ok ( @@a1@@ ) != Number && ( @@v12@@ = quote ( @@a2@@ ) , @@v13@@ = gettext ( String ) , @@v14@@ = __errno_location ( ) , error ( Number , * @@v14@@ , @@v13@@ , @@v12@@ ) , * ( _BYTE * ) ( @@a1@@ + Number ) ) ) { @@result@@ = Number ; } else { @@result@@ = Number L ; } } return @@result@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 __fastcall get_stat_atime ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 __fastcall hash_get_first ( unsigned __int64 * @@a1@@ ) { unsigned __int64 @@i@@ ; if ( ! @@a1@@ [ Number ] ) return Number L ; for ( @@i@@ = * @@a1@@ ; ; @@i@@ += Number L ) { if ( @@i@@ >= @@a1@@ [ Number ] ) abort ( ) ; if ( * ( _QWORD * ) @@i@@ ) break ; } return * ( _QWORD * ) @@i@@ ; }
__int64 __fastcall get_stat_mtime ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
int closedir ( DIR * @@dirp@@ ) { return closedir ( @@dirp@@ ) ; }
__int64 __fastcall copy_acl ( __int64 @@a1@@ , unsigned int @@a2@@ , const char * @@a3@@ , int @@a4@@ , __mode_t @@a5@@ ) { int @@v5@@ ; const char * @@v6@@ ; int * @@v7@@ ; __int64 @@v8@@ ; char * @@v9@@ ; int * @@v10@@ ; __int64 @@result@@ ; @@v5@@ = qcopy_acl ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; if ( @@v5@@ == Number ) { @@v6@@ = ( const char * ) quote ( @@a1@@ ) ; @@v7@@ = __errno_location ( ) ; error ( Number , * @@v7@@ , String , @@v6@@ ) ; @@result@@ = Number ; } else if ( @@v5@@ == Number ) { @@v8@@ = quote ( @@a3@@ ) ; @@v9@@ = gettext ( String ) ; @@v10@@ = __errno_location ( ) ; error ( Number , * @@v10@@ , @@v9@@ , @@v8@@ ) ; @@result@@ = Number ; } else { @@result@@ = Number L ; } return @@result@@ ; }
int rpmatch ( const char * @@response@@ ) { return rpmatch ( @@response@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
unsigned __int64 __fastcall triple_hash_no_name ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) % @@a2@@ ; }
int fileno ( FILE * @@stream@@ ) { return fileno ( @@stream@@ ) ; }
__int64 __fastcall hash_get_next ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; _QWORD * @@v4@@ ; _QWORD * @@i@@ ; @@v2@@ = * @@a1@@ ; @@v4@@ = ( _QWORD * ) ( @@v2@@ + Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) ) ; if ( ( unsigned __int64 ) @@v4@@ >= @@a1@@ [ Number ] ) abort ( ) ; for ( @@i@@ = @@v4@@ ; @@i@@ ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { if ( @@a2@@ == * @@i@@ && @@i@@ [ Number ] ) return * ( _QWORD * ) @@i@@ [ Number ] ; } while ( Number ) { @@v4@@ += Number ; if ( ( unsigned __int64 ) @@v4@@ >= @@a1@@ [ Number ] ) break ; if ( * @@v4@@ ) return * @@v4@@ ; } return Number L ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
void __fastcall triple_free ( void * * @@a1@@ ) { free ( * @@a1@@ ) ; free ( @@a1@@ ) ; }
_BOOL8 __fastcall install_file_in_file_parents ( _BYTE * @@a1@@ , _BYTE * @@a2@@ , __int64 @@a3@@ ) { bool @@v3@@ ; char * @@v4@@ ; int * @@v5@@ ; _BOOL8 @@result@@ ; char * @@v7@@ ; bool @@v8@@ ; bool @@v10@@ ; unsigned int @@v11@@ ; int @@v12@@ ; int @@errnum@@ ; int @@v14@@ ; unsigned __int64 @@v15@@ ; @@v15@@ = __readfsqword ( Number ) ; @@v3@@ = * @@a1@@ != Number || * @@a2@@ != Number ; @@v10@@ = @@v3@@ ; @@v11@@ = Number ; savewd_init ( & @@v14@@ ) ; if ( ! @@v10@@ ) savewd_finish ( & @@v14@@ ) ; if ( mkancesdirs ( @@a2@@ , & @@v14@@ , make_ancestor , @@a3@@ ) == Number ) { @@v4@@ = gettext ( String ) ; @@v5@@ = __errno_location ( ) ; error ( Number , * @@v5@@ , @@v4@@ , @@a2@@ ) ; @@v11@@ = Number ; } if ( ! @@v10@@ ) goto LABEL_22 ; @@v12@@ = savewd_restore ( & @@v14@@ , @@v11@@ ) ; @@errnum@@ = * __errno_location ( ) ; savewd_finish ( & @@v14@@ ) ; if ( @@v12@@ > Number ) return Number L ; if ( @@v12@@ >= Number || @@v11@@ ) { LABEL_22 : @@v8@@ = ! @@v11@@ && ( unsigned __int8 ) install_file_in_file ( @@a1@@ , @@a2@@ , @@a3@@ ) ; @@result@@ = @@v8@@ ; } else { @@v7@@ = gettext ( String ) ; error ( Number , @@errnum@@ , @@v7@@ , @@a2@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
__int64 __fastcall check_tuning ( __int64 @@a1@@ ) { __int64 @@v2@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( ( _UNKNOWN * ) @@v2@@ == & default_tuning ) return Number L ; if ( * ( float * ) ( @@v2@@ + Number ) > Number && ( float ) ( Number - Number ) > * ( float * ) ( @@v2@@ + Number ) && * ( float * ) ( @@v2@@ + Number ) > ( float ) ( Number + Number ) && * ( float * ) @@v2@@ >= Number && * ( float * ) ( @@v2@@ + Number ) > ( float ) ( * ( float * ) @@v2@@ + Number ) && * ( float * ) ( @@v2@@ + Number ) <= Number && * ( float * ) ( @@v2@@ + Number ) > ( float ) ( * ( float * ) @@v2@@ + Number ) ) { return Number L ; } * ( _QWORD * ) ( @@a1@@ + Number ) = & default_tuning ; return Number L ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
unsigned __int64 __fastcall strip ( __int64 @@a1@@ ) { __pid_t @@v1@@ ; char * @@v2@@ ; int * @@v3@@ ; char * @@v4@@ ; char * @@v5@@ ; int * @@v6@@ ; char * @@v7@@ ; int * @@v8@@ ; char * @@v9@@ ; int @@stat_loc@@ ; __pid_t @@pid@@ ; unsigned __int64 @@v13@@ ; @@v13@@ = __readfsqword ( Number ) ; @@v1@@ = fork ( ) ; @@pid@@ = @@v1@@ ; if ( @@v1@@ == Number ) { @@v2@@ = gettext ( String ) ; @@v3@@ = __errno_location ( ) ; error ( Number , * @@v3@@ , @@v2@@ ) ; } else if ( @@v1@@ ) { if ( waitpid ( @@pid@@ , & @@stat_loc@@ , Number ) >= Number ) { if ( ( @@stat_loc@@ & Number ) != Number || BYTE1 ( @@stat_loc@@ ) ) { @@v9@@ = gettext ( String ) ; error ( Number , Number , @@v9@@ ) ; } } else { @@v7@@ = gettext ( String ) ; @@v8@@ = __errno_location ( ) ; error ( Number , * @@v8@@ , @@v7@@ ) ; } } else { execlp ( strip_program , strip_program , @@a1@@ , Number L ) ; @@v4@@ = strip_program ; @@v5@@ = gettext ( String ) ; @@v6@@ = __errno_location ( ) ; error ( Number , * @@v6@@ , @@v5@@ , @@v4@@ ) ; } return __readfsqword ( Number ) ^ @@v13@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
int __freading ( FILE * @@fp@@ ) { return _freading ( @@fp@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
__int64 __fastcall hash_clear ( __int64 @@a1@@ ) { __int64 @@result@@ ; _QWORD * @@i@@ ; _QWORD * @@j@@ ; _QWORD * @@v4@@ ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = ( _QWORD * ) @@i@@ [ Number ] ; @@j@@ ; @@j@@ = @@v4@@ ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@j@@ ) ; * @@j@@ = Number L ; @@v4@@ = ( _QWORD * ) @@j@@ [ Number ] ; @@j@@ [ Number ] = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@j@@ ; } if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@i@@ ) ; * @@i@@ = Number L ; @@i@@ [ Number ] = Number L ; } } * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; @@result@@ = @@a1@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; return @@result@@ ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
unsigned __int64 __fastcall gcd ( unsigned __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { unsigned __int64 @@v5@@ ; do { @@v5@@ = @@a1@@ % @@a2@@ ; @@a1@@ = @@a2@@ ; @@a2@@ = @@v5@@ ; } while ( @@v5@@ ) ; return @@a1@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
unsigned __int64 __fastcall buffer_lcm ( unsigned __int64 @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { __int64 @@v3@@ ; unsigned __int64 @@result@@ ; unsigned __int64 @@v5@@ ; unsigned __int64 @@v6@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@v8@@ ; if ( @@a1@@ ) { if ( @@a2@@ ) { @@v6@@ = @@a1@@ ; for ( @@i@@ = @@a2@@ ; ; @@i@@ = @@v8@@ ) { @@v8@@ = @@v6@@ % @@i@@ ; if ( ! ( @@v6@@ % @@i@@ ) ) break ; @@v6@@ = @@i@@ ; } if ( @@a2@@ * ( @@a1@@ / @@i@@ ) <= @@a3@@ && @@a1@@ / @@i@@ == @@a2@@ * ( @@a1@@ / @@i@@ ) / @@a2@@ ) { return @@a2@@ * ( @@a1@@ / @@i@@ ) ; } } @@v5@@ = @@a1@@ ; } else { if ( @@a2@@ ) @@v3@@ = @@a2@@ ; else @@v3@@ = Number ; @@v5@@ = @@v3@@ ; } @@result@@ = @@a3@@ ; if ( @@v5@@ <= @@a3@@ ) @@result@@ = @@v5@@ ; return @@result@@ ; }
__int64 __fastcall get_stat_mtime_0 ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall get_version ( __int64 @@a1@@ , _BYTE * @@a2@@ ) { __int64 @@result@@ ; if ( @@a2@@ && * @@a2@@ ) @@result@@ = backup_types [ _xargmatch_internal ( @@a1@@ , @@a2@@ , backup_args , backup_types , Number L , argmatch_die ) ] ; else @@result@@ = Number L ; return @@result@@ ; }
void __fastcall hash_free ( __int64 @@a1@@ ) { _QWORD * @@i@@ ; _QWORD * @@j@@ ; _QWORD * @@ptr@@ ; _QWORD * @@ptra@@ ; _QWORD * @@ptrb@@ ; _QWORD * @@v6@@ ; _QWORD * @@v7@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) && * ( _QWORD * ) ( @@a1@@ + Number ) ) { for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@ptr@@ = @@i@@ ; @@ptr@@ ; @@ptr@@ = ( _QWORD * ) @@ptr@@ [ Number ] ) { ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@ptr@@ ) ; } } } } for ( @@j@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@j@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@j@@ += Number ) { for ( @@ptra@@ = ( _QWORD * ) @@j@@ [ Number ] ; @@ptra@@ ; @@ptra@@ = @@v6@@ ) { @@v6@@ = ( _QWORD * ) @@ptra@@ [ Number ] ; free ( @@ptra@@ ) ; } } for ( @@ptrb@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; @@ptrb@@ ; @@ptrb@@ = @@v7@@ ) { @@v7@@ = ( _QWORD * ) @@ptrb@@ [ Number ] ; free ( @@ptrb@@ ) ; } free ( * ( void * * ) @@a1@@ ) ; free ( ( void * ) @@a1@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall is_ancestor ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { while ( @@a2@@ ) { if ( @@a2@@ [ Number ] == @@a1@@ [ Number ] && @@a2@@ [ Number ] == * @@a1@@ ) return Number L ; @@a2@@ = ( _QWORD * ) * @@a2@@ ; } return Number L ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
__int64 __fastcall hash_find_entry ( __int64 @@a1@@ , __int64 @@a2@@ , _QWORD * @@a3@@ , char @@a4@@ ) { __int64 @@v4@@ ; __int64 @@result@@ ; __int64 @@v6@@ ; _QWORD * @@i@@ ; _QWORD * @@v10@@ ; __int64 @@v11@@ ; _QWORD * @@v12@@ ; __int64 @@v13@@ ; _QWORD * @@v14@@ ; @@v4@@ = * ( _QWORD * ) @@a1@@ ; @@v10@@ = ( _QWORD * ) ( @@v4@@ + Number * ( * ( __int64 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@a2@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@v10@@ >= * ( _QWORD * ) ( @@a1@@ + Number ) ) abort ( ) ; * @@a3@@ = @@v10@@ ; if ( ! * @@v10@@ ) return Number L ; if ( @@a2@@ == * @@v10@@ || ( * ( unsigned __int8 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@a2@@ , * @@v10@@ ) ) { @@v13@@ = * @@v10@@ ; if ( @@a4@@ ) { if ( @@v10@@ [ Number ] ) { @@v14@@ = ( _QWORD * ) @@v10@@ [ Number ] ; @@v6@@ = @@v14@@ [ Number ] ; * @@v10@@ = * @@v14@@ ; @@v10@@ [ Number ] = @@v6@@ ; free_entry ( @@a1@@ , @@v14@@ ) ; } else { * @@v10@@ = Number L ; } } @@result@@ = @@v13@@ ; } else { for ( @@i@@ = @@v10@@ ; ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { if ( ! @@i@@ [ Number ] ) return Number L ; if ( @@a2@@ == * ( _QWORD * ) @@i@@ [ Number ] || ( * ( unsigned __int8 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@a2@@ , * ( _QWORD * ) @@i@@ [ Number ] ) ) { break ; } } @@v11@@ = * ( _QWORD * ) @@i@@ [ Number ] ; if ( @@a4@@ ) { @@v12@@ = ( _QWORD * ) @@i@@ [ Number ] ; @@i@@ [ Number ] = @@v12@@ [ Number ] ; free_entry ( @@a1@@ , @@v12@@ ) ; } @@result@@ = @@v11@@ ; } return @@result@@ ; }
__int64 close_stdin ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char @@v4@@ ; char * @@v5@@ ; @@v4@@ = Number ; if ( freadahead ( stdin ) && ! ( unsigned int ) rpl_fseeko ( stdin , Number L , Number L ) && ( unsigned int ) rpl_fflush ( stdin ) ) @@v4@@ = Number ; if ( ( unsigned int ) close_stream ( stdin ) ) @@v4@@ = Number ; if ( @@v4@@ ) { @@v5@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v5@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v5@@ ) ; } } @@result@@ = close_stdout ( ) ; if ( @@v4@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
_BOOL8 __fastcall writable_destination ( const char * @@a1@@ , __int16 @@a2@@ ) { return ( @@a2@@ & Number ) == Number || ( unsigned __int8 ) can_write_any_file ( ) || ! euidaccess ( @@a1@@ , Number ) ; }
_BOOL8 __fastcall target_directory_operand ( char * @@a1@@ ) { bool @@v1@@ ; int @@v2@@ ; bool @@v3@@ ; __int64 @@v4@@ ; char * @@v5@@ ; __int64 @@v6@@ ; char * @@v7@@ ; bool @@v9@@ ; bool @@v10@@ ; int @@errnum@@ ; char * @@s@@ ; size_t @@v13@@ ; struct stat @@v14@@ ; unsigned __int64 @@v15@@ ; @@v15@@ = __readfsqword ( Number ) ; @@s@@ = ( char * ) last_component ( @@a1@@ ) ; @@v13@@ = strlen ( @@s@@ ) ; @@v1@@ = ! @@v13@@ || @@s@@ [ @@v13@@ - Number ] == Number ; @@v9@@ = @@v1@@ ; if ( ( unsigned int ) stat ( @@a1@@ , & @@v14@@ ) ) @@v2@@ = * __errno_location ( ) ; else @@v2@@ = Number ; @@errnum@@ = @@v2@@ ; @@v3@@ = ! @@v2@@ && ( @@v14@@ . st_mode & Number ) == Number ; @@v10@@ = @@v3@@ ; if ( @@errnum@@ && @@errnum@@ != Number ) { @@v4@@ = quote ( @@a1@@ ) ; @@v5@@ = gettext ( String ) ; error ( Number , @@errnum@@ , @@v5@@ , @@v4@@ ) ; } if ( ( unsigned __int8 ) @@v10@@ < ( unsigned __int8 ) @@v9@@ ) { @@v6@@ = quote ( @@a1@@ ) ; @@v7@@ = gettext ( String ) ; error ( Number , @@errnum@@ , @@v7@@ , @@v6@@ ) ; } return @@v10@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return xmalloc ( @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall ftypelet ( __int16 @@a1@@ ) { switch ( @@a1@@ & Number ) { case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; } return Number L ; }
_BOOL8 __fastcall abandon_move ( __int64 @@a1@@ , const char * @@a2@@ , __int64 @@a3@@ ) { bool @@v3@@ ; if ( ! * ( _BYTE * ) ( @@a1@@ + Number ) ) __assert_fail ( String , String , Number , String ) ; @@v3@@ = Number ; if ( * ( _DWORD * ) ( @@a1@@ + Number ) != Number ) { if ( * ( _DWORD * ) ( @@a1@@ + Number ) != Number && ( * ( _DWORD * ) ( @@a1@@ + Number ) != Number || ! * ( _BYTE * ) ( @@a1@@ + Number ) || writable_destination ( @@a2@@ , * ( _DWORD * ) ( @@a3@@ + Number ) ) ) || ( overwrite_prompt ( @@a2@@ , @@a3@@ ) , ( unsigned __int8 ) yesno ( ) == Number ) ) { @@v3@@ = Number ; } } return @@v3@@ ; }
__int64 __fastcall transfer_entries ( __int64 @@a1@@ , __int64 @@a2@@ , char @@a3@@ ) { __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 * @@i@@ ; _QWORD * @@j@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; _QWORD * @@v11@@ ; _QWORD * @@v12@@ ; _QWORD * @@v13@@ ; _QWORD * @@v14@@ ; for ( @@i@@ = * ( __int64 * * ) @@a2@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a2@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = ( _QWORD * ) @@i@@ [ Number ] ; @@j@@ ; @@j@@ = @@v14@@ ) { @@v9@@ = * @@j@@ ; @@v3@@ = * ( _QWORD * ) @@a1@@ ; @@v11@@ = ( _QWORD * ) ( @@v3@@ + Number * ( * ( __int64 ( __fastcall * * ) ( _QWORD , _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@j@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@v11@@ >= * ( _QWORD * ) ( @@a1@@ + Number ) ) abort ( ) ; @@v14@@ = ( _QWORD * ) @@j@@ [ Number ] ; if ( * @@v11@@ ) { @@j@@ [ Number ] = @@v11@@ [ Number ] ; @@v11@@ [ Number ] = @@j@@ ; } else { * @@v11@@ = @@v9@@ ; ++ * ( _QWORD * ) ( @@a1@@ + Number ) ; free_entry ( @@a1@@ , @@j@@ ) ; } } @@v10@@ = * @@i@@ ; @@i@@ [ Number ] = Number L ; if ( ! @@a3@@ ) { @@v4@@ = * ( _QWORD * ) @@a1@@ ; @@v12@@ = ( _QWORD * ) ( @@v4@@ + Number * ( * ( __int64 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@v10@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@v12@@ >= * ( _QWORD * ) ( @@a1@@ + Number ) ) abort ( ) ; if ( * @@v12@@ ) { @@v13@@ = allocate_entry ( @@a1@@ ) ; if ( ! @@v13@@ ) return Number L ; * @@v13@@ = @@v10@@ ; @@v13@@ [ Number ] = @@v12@@ [ Number ] ; @@v12@@ [ Number ] = @@v13@@ ; } else { * @@v12@@ = @@v10@@ ; ++ * ( _QWORD * ) ( @@a1@@ + Number ) ; } * @@i@@ = Number L ; -- * ( _QWORD * ) ( @@a2@@ + Number ) ; } } } return Number L ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 __fastcall install_file_in_dir ( char * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { unsigned __int8 @@v5@@ ; __int64 @@v6@@ ; void * @@ptr@@ ; @@v6@@ = last_component ( @@a1@@ ) ; @@ptr@@ = ( void * ) file_name_concat ( @@a2@@ , @@v6@@ , Number L ) ; @@v5@@ = install_file_in_file ( @@a1@@ , ( __int64 ) @@ptr@@ , @@a3@@ ) ; free ( @@ptr@@ ) ; return @@v5@@ ; }
int __fastcall rpl_fseeko ( FILE * @@a1@@ , __off_t @@a2@@ , int @@a3@@ ) { __off_t @@v3@@ ; int @@v4@@ ; int @@result@@ ; if ( @@a1@@ -> _IO_read_end != @@a1@@ -> _IO_read_ptr || @@a1@@ -> _IO_write_ptr != @@a1@@ -> _IO_write_base || @@a1@@ -> _IO_save_base ) { goto LABEL_13 ; } if ( @@a3@@ == Number && @@a2@@ > Number ) @@v3@@ = Number L ; else @@v3@@ = @@a2@@ ; @@v4@@ = fileno ( @@a1@@ ) ; if ( lseek ( @@v4@@ , @@v3@@ , @@a3@@ ) == Number ) return Number ; @@a1@@ -> _flags &= Number ; if ( @@a3@@ == Number && @@a2@@ > Number ) LABEL_13 : @@result@@ = fseeko ( @@a1@@ , @@a2@@ , @@a3@@ ) ; else @@result@@ = Number ; return @@result@@ ; }
int __fastcall emit_verbose ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { const char * @@v3@@ ; const char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; @@v3@@ = ( const char * ) quote_n ( Number L , @@a2@@ ) ; @@v4@@ = ( const char * ) quote_n ( Number L , @@a1@@ ) ; printf ( String , @@v4@@ , @@v3@@ ) ; if ( @@a3@@ ) { @@v5@@ = quote ( @@a3@@ ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } return putchar_unlocked ( Number ) ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
_BOOL8 __fastcall chown_failure_ok ( __int64 @@a1@@ ) { return ( * __errno_location ( ) == Number || * __errno_location ( ) == Number ) && * ( _BYTE * ) ( @@a1@@ + Number ) != Number ; }
__int64 __fastcall change_timestamps ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; char * @@v5@@ ; int * @@v6@@ ; __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = get_stat_atime ( @@a1@@ ) ; @@v8@@ [ Number ] = @@v2@@ ; @@v8@@ [ Number ] = get_stat_mtime ( @@a1@@ ) ; @@v8@@ [ Number ] = @@v3@@ ; if ( ! ( unsigned int ) utimens ( @@a2@@ , @@v8@@ ) ) return Number L ; @@v4@@ = quote ( @@a2@@ ) ; @@v5@@ = gettext ( String ) ; @@v6@@ = __errno_location ( ) ; error ( Number , * @@v6@@ , @@v5@@ , @@v4@@ ) ; return Number L ; }
__int64 __fastcall hash_lookup ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; _QWORD * @@i@@ ; _QWORD * @@v5@@ ; @@v2@@ = * @@a1@@ ; @@v5@@ = ( _QWORD * ) ( @@v2@@ + Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) ) ; if ( ( unsigned __int64 ) @@v5@@ >= @@a1@@ [ Number ] ) abort ( ) ; if ( ! * @@v5@@ ) return Number L ; for ( @@i@@ = @@v5@@ ; @@i@@ ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { if ( @@a2@@ == * @@i@@ || ( ( unsigned __int8 ( __fastcall * ) ( __int64 , _QWORD ) ) @@a1@@ [ Number ] ) ( @@a2@@ , * @@i@@ ) ) { return * @@i@@ ; } } return Number L ; }
__int64 __fastcall hash_rehash ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; unsigned __int64 @@nmemb@@ ; void * @@v4@@ ; __int64 @@v5@@ ; unsigned __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; __int64 @@v12@@ ; __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; @@v14@@ = __readfsqword ( Number ) ; @@nmemb@@ = compute_bucket_size ( @@a2@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ; if ( ! @@nmemb@@ ) return Number L ; if ( @@nmemb@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; @@v4@@ = calloc ( @@nmemb@@ , Number ) ; if ( ! @@v4@@ ) return Number L ; @@v6@@ = @@nmemb@@ ; @@v5@@ = ( __int64 ) @@v4@@ + Number * @@nmemb@@ ; @@v7@@ = Number L ; @@v8@@ = Number L ; @@v9@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v10@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v11@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v12@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v13@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( ( unsigned __int8 ) transfer_entries ( ( __int64 ) & @@v4@@ , @@a1@@ , Number ) ) { free ( * ( void * * ) @@a1@@ ) ; * ( _QWORD * ) @@a1@@ = @@v4@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v5@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v6@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v7@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v13@@ ; @@result@@ = Number L ; } else { * ( _QWORD * ) ( @@a1@@ + Number ) = @@v13@@ ; if ( ( unsigned __int8 ) transfer_entries ( @@a1@@ , ( __int64 ) & @@v4@@ , Number ) != Number || ( unsigned __int8 ) transfer_entries ( @@a1@@ , ( __int64 ) & @@v4@@ , Number ) != Number ) { abort ( ) ; } free ( @@v4@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
_BOOL8 __fastcall owner_failure_ok ( __int64 @@a1@@ ) { return ( * __errno_location ( ) == Number || * __errno_location ( ) == Number ) && * ( _BYTE * ) ( @@a1@@ + Number ) != Number ; }
__int64 __fastcall announce_mkdir ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; int @@v3@@ ; unsigned int @@v4@@ ; int @@v5@@ ; int @@v6@@ ; @@result@@ = * ( unsigned __int8 * ) ( @@a2@@ + Number ) ; if ( ( _BYTE ) @@result@@ ) { @@v3@@ = quote ( @@a1@@ ) ; @@v4@@ = ( unsigned int ) gettext ( String ) ; @@result@@ = prog_fprintf ( ( _DWORD ) stdout , @@v4@@ , @@v3@@ , @@v4@@ , @@v5@@ , @@v6@@ , @@a2@@ ) ; } return @@result@@ ; }
unsigned __int64 __fastcall src_to_dest_hash ( _QWORD * @@a1@@ , unsigned __int64 @@a2@@ ) { return * @@a1@@ % @@a2@@ ; }
unsigned __int64 __fastcall hash_get_entries ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; _QWORD * @@i@@ ; _QWORD * @@j@@ ; @@v5@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = @@i@@ ; @@j@@ ; @@j@@ = ( _QWORD * ) @@j@@ [ Number ] ) { if ( @@v5@@ >= @@a3@@ ) return @@v5@@ ; @@v4@@ = @@v5@@ ++ ; * ( _QWORD * ) ( @@a2@@ + Number * @@v4@@ ) = * @@j@@ ; } } } return @@v5@@ ; }
unsigned __int64 __fastcall dev_info_hash ( _QWORD * @@a1@@ , unsigned __int64 @@a2@@ ) { return * @@a1@@ % @@a2@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
_BOOL8 __fastcall src_to_dest_compare ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { return * @@a1@@ == * @@a2@@ && @@a1@@ [ Number ] == @@a2@@ [ Number ] ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
__int64 __fastcall get_stat_mtime_1 ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
_BOOL8 __fastcall dot_or_dotdot ( _BYTE * @@a1@@ ) { __int64 @@v1@@ ; char @@v4@@ ; if ( * @@a1@@ != Number ) return Number L ; if ( @@a1@@ [ Number ] == Number ) @@v1@@ = Number L ; else @@v1@@ = Number L ; @@v4@@ = @@a1@@ [ @@v1@@ ] ; return ! @@v4@@ || @@v4@@ == Number ; }
int __fastcall gl_futimens ( int @@a1@@ , char * @@a2@@ , __int64 * @@a3@@ ) { return fdutimens ( @@a2@@ , @@a1@@ , @@a3@@ ) ; }
__int64 __fastcall next_prime ( unsigned __int64 @@a1@@ ) { __int64 @@v2@@ ; __int64 @@i@@ ; @@v2@@ = @@a1@@ ; if ( @@a1@@ <= Number ) @@v2@@ = Number L ; for ( @@i@@ = @@v2@@ | Number ; @@i@@ != Number && ! is_prime ( @@i@@ ) ; @@i@@ += Number L ) { ; } return @@i@@ ; }
__int64 __fastcall src_to_dest_lookup ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; __int64 @@v3@@ ; __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = @@a1@@ ; @@v4@@ [ Number ] = @@a2@@ ; @@v3@@ = hash_lookup ( src_to_dest , @@v4@@ ) ; if ( @@v3@@ ) @@result@@ = * ( _QWORD * ) ( @@v3@@ + Number ) ; else @@result@@ = Number L ; return @@result@@ ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
int __fastcall clone_file ( int @@a1@@ , unsigned int @@a2@@ ) { return ioctl ( @@a1@@ , Number , @@a2@@ ) ; }
int __fastcall utimens ( char * @@a1@@ , __int64 * @@a2@@ ) { return fdutimens ( @@a1@@ , Number , @@a2@@ ) ; }
int __fastcall qcopy_acl ( __int64 a1 , __int64 a2 , const char * @@a3@@ , int @@a4@@ , __mode_t @@a5@@ ) { return qset_acl ( @@a3@@ , @@a4@@ , @@a5@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
size_t * __fastcall hash_initialize ( __int64 @@a1@@ , void * @@a2@@ , unsigned __int64 ( __fastcall * @@a3@@ ) ( __int64 a1 , unsigned __int64 a2 ) , bool ( __fastcall * @@a4@@ ) ( __int64 a1 , __int64 a2 ) , size_t @@a5@@ ) { size_t * @@result@@ ; bool ( __fastcall * @@v7@@ ) ( __int64 , __int64 ) ; unsigned __int64 ( __fastcall * @@v8@@ ) ( __int64 , unsigned __int64 ) ; void * @@v9@@ ; size_t * @@ptr@@ ; @@v9@@ = @@a2@@ ; @@v8@@ = @@a3@@ ; @@v7@@ = @@a4@@ ; if ( ! @@a3@@ ) @@v8@@ = raw_hasher ; if ( ! @@a4@@ ) @@v7@@ = raw_comparator ; @@ptr@@ = ( size_t * ) malloc ( Number ) ; if ( ! @@ptr@@ ) return Number L ; if ( ! @@a2@@ ) @@v9@@ = & default_tuning ; @@ptr@@ [ Number ] = ( size_t ) @@v9@@ ; if ( ( unsigned __int8 ) check_tuning ( ( __int64 ) @@ptr@@ ) == Number && ( @@ptr@@ [ Number ] = compute_bucket_size ( @@a1@@ , ( __int64 ) @@v9@@ ) ) != Number && ( * @@ptr@@ = ( size_t ) calloc ( @@ptr@@ [ Number ] , Number ) ) != Number ) { @@ptr@@ [ Number ] = Number * @@ptr@@ [ Number ] + * @@ptr@@ ; @@ptr@@ [ Number ] = Number L ; @@ptr@@ [ Number ] = Number L ; @@ptr@@ [ Number ] = ( size_t ) @@v8@@ ; @@ptr@@ [ Number ] = ( size_t ) @@v7@@ ; @@ptr@@ [ Number ] = @@a5@@ ; @@ptr@@ [ Number ] = Number L ; @@result@@ = @@ptr@@ ; } else { free ( @@ptr@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
void __fastcall record_file ( __int64 @@a1@@ , __int64 @@a2@@ , _QWORD * @@a3@@ ) { _QWORD * @@v4@@ ; __int64 @@v5@@ ; if ( @@a1@@ ) { @@v4@@ = ( _QWORD * ) xmalloc ( Number L ) ; * @@v4@@ = xstrdup ( @@a2@@ ) ; @@v4@@ [ Number ] = @@a3@@ [ Number ] ; @@v4@@ [ Number ] = * @@a3@@ ; @@v5@@ = hash_insert ( @@a1@@ , @@v4@@ ) ; if ( ! @@v5@@ ) xalloc_die ( ) ; if ( ( _QWORD * ) @@v5@@ != @@v4@@ ) triple_free ( @@v4@@ ) ; } }
__int64 __fastcall set_cloexec_flag ( int @@a1@@ , char @@a2@@ , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { int @@v6@@ ; int @@v7@@ ; int @@v8@@ ; unsigned int @@v9@@ ; __int64 @@result@@ ; int @@v11@@ ; @@v11@@ = rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( @@v11@@ < Number || ( ! @@a2@@ ? ( @@v9@@ = @@v11@@ & Number ) : ( @@v9@@ = @@v11@@ | Number ) , @@v11@@ != @@v9@@ && ( unsigned int ) rpl_fcntl ( @@a1@@ , Number , @@v9@@ , @@v6@@ , @@v7@@ , @@v8@@ ) == Number ) ) { @@result@@ = Number ; } else { @@result@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall free_entry ( __int64 @@a1@@ , _QWORD * @@a2@@ ) { __int64 @@result@@ ; * @@a2@@ = Number L ; @@a2@@ [ Number ] = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@result@@ = @@a1@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall full_write ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v5@@ ; __int64 @@v7@@ ; @@v5@@ = Number L ; while ( @@a3@@ ) { @@v7@@ = safe_write ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( @@v7@@ == Number ) break ; if ( ! @@v7@@ ) { * __errno_location ( ) = Number ; return @@v5@@ ; } @@v5@@ += @@v7@@ ; @@a2@@ += @@v7@@ ; @@a3@@ -= @@v7@@ ; } return @@v5@@ ; }
__int64 __fastcall open_safer ( const char * @@a1@@ , char @@a2@@ , unsigned int @@a3@@ ) { unsigned int @@v3@@ ; unsigned int @@v5@@ ; @@v5@@ = Number ; if ( ( @@a2@@ & Number ) != Number ) @@v5@@ = @@a3@@ ; @@v3@@ = open ( @@a1@@ , @@a2@@ , @@v5@@ ) ; return fd_safer ( @@v3@@ ) ; }
_BOOL8 __fastcall copy_dir ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int8 @@a3@@ , _QWORD * @@a4@@ , int @@a5@@ , __int64 @@a6@@ , __int64 @@a7@@ , bool * @@a8@@ ) { __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; __int64 @@v12@@ ; char * @@v13@@ ; int * @@v14@@ ; _BOOL8 @@result@@ ; unsigned __int8 @@v16@@ ; size_t @@v17@@ ; char @@v22@@ ; bool @@v23@@ ; char * @@s@@ ; void * @@v25@@ ; void * @@v26@@ ; void * @@ptr@@ ; __int64 @@v28@@ [ Number ] ; @@v28@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ = * ( _QWORD * ) ( @@a6@@ + Number ) ; @@v28@@ [ Number ] = * ( _QWORD * ) @@a6@@ ; @@v28@@ [ Number ] = @@v8@@ ; @@v9@@ = * ( _QWORD * ) ( @@a6@@ + Number ) ; @@v28@@ [ Number ] = * ( _QWORD * ) ( @@a6@@ + Number ) ; @@v28@@ [ Number ] = @@v9@@ ; @@v10@@ = * ( _QWORD * ) ( @@a6@@ + Number ) ; @@v28@@ [ Number ] = * ( _QWORD * ) ( @@a6@@ + Number ) ; @@v28@@ [ Number ] = @@v10@@ ; @@v11@@ = * ( _QWORD * ) ( @@a6@@ + Number ) ; @@v28@@ [ Number ] = * ( _QWORD * ) ( @@a6@@ + Number ) ; @@v28@@ [ Number ] = @@v11@@ ; @@v28@@ [ Number ] = * ( _QWORD * ) ( @@a6@@ + Number ) ; @@v23@@ = Number ; @@v25@@ = ( void * ) savedir ( @@a1@@ ) ; if ( @@v25@@ ) { if ( * ( _DWORD * ) ( @@a6@@ + Number ) == Number ) HIDWORD ( @@v28@@ [ Number ] ) = Number ; for ( @@s@@ = ( char * ) @@v25@@ ; * @@s@@ ; @@s@@ += @@v17@@ + Number ) { @@v26@@ = ( void * ) file_name_concat ( @@a1@@ , @@s@@ , Number L ) ; @@ptr@@ = ( void * ) file_name_concat ( @@a2@@ , @@s@@ , Number L ) ; @@v16@@ = copy_internal ( ( _DWORD ) @@v26@@ , ( _DWORD ) @@ptr@@ , @@a3@@ , * @@a4@@ , @@a5@@ , ( unsigned int ) @@v28@@ , Number , @@a7@@ , ( __int64 ) & @@v22@@ , Number L ) ; @@v23@@ = ( @@v23@@ & @@v16@@ ) != Number ; * @@a8@@ = ( unsigned __int8 ) ( * @@a8@@ | @@v22@@ ) != Number ; free ( @@ptr@@ ) ; free ( @@v26@@ ) ; if ( @@v22@@ ) break ; @@v17@@ = strlen ( @@s@@ ) ; } free ( @@v25@@ ) ; @@result@@ = @@v23@@ ; } else { @@v12@@ = quote ( @@a1@@ ) ; @@v13@@ = gettext ( String ) ; @@v14@@ = __errno_location ( ) ; error ( Number , * @@v14@@ , @@v13@@ , @@v12@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
int __fastcall lutimens ( char * @@a1@@ , __int64 * @@a2@@ ) { struct timespec * @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; struct timespec * @@v6@@ ; __syscall_slong_t @@v7@@ ; struct timespec * @@v8@@ ; __syscall_slong_t @@v9@@ ; int @@v10@@ ; int @@v11@@ ; struct timespec * @@times@@ ; __int64 @@v13@@ [ Number ] ; struct stat @@v14@@ ; unsigned __int64 @@v15@@ ; @@v15@@ = __readfsqword ( Number ) ; if ( @@a2@@ ) @@v2@@ = ( struct timespec * ) @@v13@@ ; else @@v2@@ = Number L ; @@times@@ = @@v2@@ ; @@v10@@ = Number ; if ( @@v2@@ ) { @@v3@@ = @@a2@@ [ Number ] ; @@v13@@ [ Number ] = * @@a2@@ ; @@v13@@ [ Number ] = @@v3@@ ; @@v4@@ = @@a2@@ [ Number ] ; @@v13@@ [ Number ] = @@a2@@ [ Number ] ; @@v13@@ [ Number ] = @@v4@@ ; @@v10@@ = validate_timespec ( @@times@@ ) ; } if ( @@v10@@ < Number ) return Number ; if ( lutimensat_works_really >= Number ) { if ( @@v10@@ == Number ) { if ( ( unsigned int ) lstat ( @@a1@@ , & @@v14@@ ) ) return Number ; if ( @@times@@ -> tv_nsec == Number ) { @@v6@@ = @@times@@ ; @@times@@ -> tv_sec = get_stat_atime_1 ( ( __int64 ) & @@v14@@ ) ; @@v6@@ -> tv_nsec = @@v7@@ ; } else if ( @@times@@ [ Number ] . tv_nsec == Number ) { @@v8@@ = @@times@@ + Number ; @@times@@ [ Number ] . tv_sec = get_stat_mtime_1 ( ( __int64 ) & @@v14@@ ) ; @@v8@@ -> tv_nsec = @@v9@@ ; } @@v10@@ = Number ; } @@v11@@ = utimensat ( Number , @@a1@@ , @@times@@ , Number ) ; if ( @@v11@@ > Number ) * __errno_location ( ) = Number ; if ( ! @@v11@@ || * __errno_location ( ) != Number ) { utimensat_works_really = Number ; lutimensat_works_really = Number ; return @@v11@@ ; } } lutimensat_works_really = Number ; if ( ! @@v10@@ ) goto LABEL_37 ; if ( @@v10@@ != Number && ( unsigned int ) lstat ( @@a1@@ , & @@v14@@ ) ) return Number ; if ( @@times@@ && ( unsigned __int8 ) update_timespec ( ( __int64 ) & @@v14@@ , ( __int64 * * ) & @@times@@ ) ) { return Number ; } LABEL_37 : if ( ! @@v10@@ && ( unsigned int ) lstat ( @@a1@@ , & @@v14@@ ) ) return Number ; if ( ( @@v14@@ . st_mode & Number ) != Number ) return fdutimens ( @@a1@@ , Number , & @@times@@ -> tv_sec ) ; * __errno_location ( ) = Number ; return Number ; }
__int64 __fastcall rpl_fcntl ( int @@a1@@ , int @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , __m128 @@a7@@ , __m128 @@a8@@ , __m128 @@a9@@ , __m128 @@a10@@ , __m128 @@a11@@ , __m128 @@a12@@ , __m128 @@a13@@ , __m128 @@a14@@ ) { int @@v14@@ ; int @@v15@@ ; int @@v16@@ ; int @@v18@@ ; int @@v19@@ ; int @@v20@@ ; int @@v21@@ ; __int64 @@v22@@ ; __int64 @@v23@@ ; __int64 @@v24@@ ; __int64 @@v25@@ ; __m128 @@v26@@ ; __m128 @@v27@@ ; __m128 @@v28@@ ; __m128 @@v29@@ ; __m128 @@v30@@ ; __m128 @@v31@@ ; __m128 @@v32@@ ; __m128 @@v33@@ ; @@v22@@ = @@a3@@ ; @@v23@@ = @@a4@@ ; @@v24@@ = @@a5@@ ; @@v25@@ = @@a6@@ ; @@v26@@ = @@a7@@ ; @@v27@@ = @@a8@@ ; @@v28@@ = @@a9@@ ; @@v29@@ = @@a10@@ ; @@v30@@ = @@a11@@ ; @@v31@@ = @@a12@@ ; @@v32@@ = @@a13@@ ; @@v33@@ = @@a14@@ ; if ( @@a2@@ != Number ) return ( unsigned int ) fcntl ( @@a1@@ , @@a2@@ , @@v22@@ ) ; @@v19@@ = @@v22@@ ; if ( have_dupfd_cloexec_2895 < Number ) { @@v18@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v22@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; } else { @@v18@@ = fcntl ( @@a1@@ , Number , ( unsigned int ) @@v22@@ ) ; if ( @@v18@@ < Number && * __errno_location ( ) == Number ) { @@v18@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v19@@ , @@v14@@ , @@v15@@ , @@v16@@ ) ; if ( @@v18@@ < Number ) return ( unsigned int ) @@v18@@ ; have_dupfd_cloexec_2895 = Number ; } else { have_dupfd_cloexec_2895 = Number ; } } if ( @@v18@@ >= Number && have_dupfd_cloexec_2895 == Number ) { @@v20@@ = fcntl ( @@v18@@ , Number ) ; if ( @@v20@@ < Number || fcntl ( @@v18@@ , Number , @@v20@@ | Number ) == Number ) { @@v21@@ = * __errno_location ( ) ; close ( @@v18@@ ) ; * __errno_location ( ) = @@v21@@ ; @@v18@@ = Number ; } } return ( unsigned int ) @@v18@@ ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
__int64 __fastcall savewd_chdir ( _DWORD * @@a1@@ , __int64 @@a2@@ , int @@a3@@ , int * @@a4@@ , int @@a5@@ , int @@a6@@ ) { int * @@v6@@ ; int @@v7@@ ; __int64 @@result@@ ; int * @@v9@@ ; char @@v10@@ ; char * @@file@@ ; int @@fd@@ ; unsigned int @@v13@@ ; int @@v14@@ ; @@file@@ = ( char * ) @@a2@@ ; @@v10@@ = @@a3@@ ; @@v9@@ = @@a4@@ ; @@fd@@ = Number ; @@v13@@ = Number ; if ( @@a4@@ || ( @@a3@@ & Number ) != Number ) { @@a2@@ = ( @@a3@@ << Number ) & Number | Number ; @@fd@@ = open ( @@file@@ , @@a2@@ ) ; if ( @@v9@@ ) { * @@v9@@ = @@fd@@ ; @@v6@@ = __errno_location ( ) ; LODWORD ( @@a4@@ ) = ( _DWORD ) @@v6@@ ; @@a3@@ = ( _DWORD ) @@v9@@ + Number ; @@v9@@ [ Number ] = * @@v6@@ ; } if ( @@fd@@ < Number && ( * __errno_location ( ) != Number || ( @@v10@@ & Number ) != Number ) ) @@v13@@ = Number ; } if ( ! @@v13@@ && ( @@fd@@ < Number || ( @@v10@@ & Number ) == Number ) ) { if ( ( unsigned __int8 ) savewd_save ( @@a1@@ , @@a2@@ , @@a3@@ , ( int ) @@a4@@ , @@a5@@ , @@a6@@ ) ) { @@v9@@ = Number L ; @@v13@@ = Number ; } else { if ( @@fd@@ >= Number ) @@v7@@ = fchdir ( @@fd@@ ) ; else @@v7@@ = chdir ( @@file@@ ) ; @@v13@@ = @@v7@@ ; if ( ! @@v7@@ ) { switch ( * @@a1@@ ) { case Number : * @@a1@@ = Number ; break ; case Number : case Number : case Number : break ; case Number : if ( @@a1@@ [ Number ] ) __assert_fail ( String , String , Number , String ) ; return @@result@@ ; default : __assert_fail ( String , String , Number , String ) ; } } } } if ( @@fd@@ >= Number && ! @@v9@@ ) { @@v14@@ = * __errno_location ( ) ; close ( @@fd@@ ) ; * __errno_location ( ) = @@v14@@ ; } return @@v13@@ ; }
int __fastcall chmod_or_fchmod ( const char * @@a1@@ , int @@a2@@ , __mode_t @@a3@@ ) { int @@result@@ ; if ( @@a2@@ == Number ) @@result@@ = chmod ( @@a1@@ , @@a3@@ ) ; else @@result@@ = fchmod ( @@a2@@ , @@a3@@ ) ; return @@result@@ ; }
__int64 __fastcall _xargmatch_internal ( __int64 @@a1@@ , const char * @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ , void ( * @@a6@@ ) ( void ) ) { __int64 @@v11@@ ; @@v11@@ = argmatch ( @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; if ( @@v11@@ >= Number ) return @@v11@@ ; argmatch_invalid ( @@a1@@ , ( __int64 ) @@a2@@ , @@v11@@ ) ; argmatch_valid ( @@a3@@ , @@a4@@ , @@a5@@ ) ; @@a6@@ ( ) ; return Number ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
__int64 __fastcall xget_version ( __int64 @@a1@@ , _BYTE * @@a2@@ ) { char * @@v3@@ ; if ( @@a2@@ && * @@a2@@ ) return get_version ( @@a1@@ , @@a2@@ ) ; @@v3@@ = getenv ( String ) ; return get_version ( ( __int64 ) String , @@v3@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
char * __fastcall areadlink_with_size ( const char * @@a1@@ , unsigned __int64 @@a2@@ ) { __int64 @@v2@@ ; char * @@i@@ ; int @@v5@@ ; size_t @@size@@ ; char * @@buf@@ ; ssize_t @@v8@@ ; if ( @@a2@@ >= Number ) @@v2@@ = Number L ; else @@v2@@ = @@a2@@ + Number ; @@size@@ = @@v2@@ ; LABEL_5 : for ( @@i@@ = ( char * ) malloc ( @@size@@ ) ; ; @@i@@ = ( char * ) malloc ( Number ) ) { @@buf@@ = @@i@@ ; if ( ! @@i@@ ) return Number L ; @@v8@@ = readlink ( @@a1@@ , @@i@@ , @@size@@ ) ; if ( @@v8@@ < Number && * __errno_location ( ) != Number ) { @@v5@@ = * __errno_location ( ) ; free ( @@buf@@ ) ; * __errno_location ( ) = @@v5@@ ; return Number L ; } if ( @@v8@@ < @@size@@ ) { @@buf@@ [ @@v8@@ ] = Number ; return @@buf@@ ; } free ( @@buf@@ ) ; if ( @@size@@ <= Number ) { @@size@@ *= Number L ; goto LABEL_5 ; } if ( @@size@@ > Number ) break ; @@size@@ = Number ; } * __errno_location ( ) = Number ; return Number L ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name_0 ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name_0 ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
__int64 __fastcall xsum4 ( unsigned __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ ) { __int64 @@v4@@ ; __int64 @@v5@@ ; @@v4@@ = xsum ( @@a1@@ , @@a2@@ ) ; @@v5@@ = xsum ( @@v4@@ , @@a3@@ ) ; return xsum ( @@v5@@ , @@a4@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
_BOOL8 __fastcall rpl_isnanl ( __int64 a1 , __int64 a2 , __int64 a3 , __int64 a4 , __int64 a5 , __int64 a6 , __int128 @@a7@@ ) { if ( ( WORD4 ( @@a7@@ ) & Number ) == Number ) return DWORD1 ( @@a7@@ ) >> Number ; if ( ( WORD4 ( @@a7@@ ) & Number ) == Number ) return ( DWORD1 ( @@a7@@ ) ^ Number | ( unsigned int ) @@a7@@ ) != Number ; return ( DWORD1 ( @@a7@@ ) & Number ) == Number ; }
_BOOL8 __fastcall savewd_delegating ( _DWORD * @@a1@@ ) { return * @@a1@@ == Number && ( int ) @@a1@@ [ Number ] > Number ; }
__int64 __fastcall file_name_concat ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v4@@ ; @@v4@@ = mfile_name_concat ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( ! @@v4@@ ) xalloc_die ( ) ; return @@v4@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
int __fastcall fstat ( int @@fildes@@ , struct stat * @@stat_buf@@ ) { return __fxstat ( Number , @@fildes@@ , @@stat_buf@@ ) ; }
__int64 __fastcall hash_get_n_buckets_used ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int64 __fastcall savewd_process_files ( int @@a1@@ , __int64 @@a2@@ , __int64 ( __fastcall * @@a3@@ ( ) ( char , savewd , void ) ) ( _QWORD , int * , __int64 ) , __int64 @@a4@@ ) { int @@v7@@ ; int @@i@@ ; int @@v9@@ ; int @@v10@@ ; int @@v11@@ ; int @@v12@@ ; int @@v13@@ ; unsigned __int64 @@v14@@ ; @@v14@@ = __readfsqword ( Number ) ; @@v7@@ = Number ; @@v9@@ = Number ; savewd_init_0 ( & @@v13@@ ) ; for ( @@i@@ = @@a1@@ - Number ; @@i@@ >= Number && * * ( _BYTE * * ) ( Number L * @@i@@ + @@a2@@ ) == Number ; -- @@i@@ ) { ; } while ( @@v7@@ < @@i@@ ) { if ( ! savewd_delegating ( & @@v13@@ ) ) { @@v11@@ = @@a3@@ ( ) ( char , savewd , void ) ( * ( _QWORD * ) ( Number L * @@v7@@ + @@a2@@ ) , & @@v13@@ , @@a4@@ ) ; if ( @@v9@@ < @@v11@@ ) @@v9@@ = @@v11@@ ; } if ( * * ( _BYTE * * ) ( Number * ( @@v7@@ + Number L ) + @@a2@@ ) != Number ) { @@v12@@ = savewd_restore ( & @@v13@@ , @@v9@@ ) ; if ( @@v9@@ < @@v12@@ ) @@v9@@ = @@v12@@ ; } ++ @@v7@@ ; } savewd_finish ( & @@v13@@ ) ; while ( @@v7@@ < @@a1@@ ) { @@v10@@ = @@a3@@ ( ) ( char , savewd , void ) ( * ( _QWORD * ) ( Number L * @@v7@@ + @@a2@@ ) , & @@v13@@ , @@a4@@ ) ; if ( @@v9@@ < @@v10@@ ) @@v9@@ = @@v10@@ ; ++ @@v7@@ ; } return ( unsigned int ) @@v9@@ ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_220058 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = ( __int64 * ) & slotvec0 ; } nslots = Number ; return @@result@@ ; }
__int64 __fastcall fd_reopen ( int @@a1@@ , const char * @@a2@@ , int @@a3@@ , unsigned int @@a4@@ ) { int @@fd@@ ; unsigned int @@v6@@ ; int @@v7@@ ; @@fd@@ = open ( @@a2@@ , @@a3@@ , @@a4@@ ) ; if ( @@fd@@ == @@a1@@ || @@fd@@ < Number ) return ( unsigned int ) @@fd@@ ; @@v6@@ = dup2 ( @@fd@@ , @@a1@@ ) ; @@v7@@ = * __errno_location ( ) ; close ( @@fd@@ ) ; * __errno_location ( ) = @@v7@@ ; return @@v6@@ ; }
int __fastcall mknod ( char * @@path@@ , __mode_t @@mode@@ , __dev_t @@a3@@ ) { __dev_t @@dev@@ [ Number ] ; @@dev@@ [ Number ] = @@a3@@ ; return __xmknod ( Number , @@path@@ , @@mode@@ , @@dev@@ ) ; }
unsigned __int64 __fastcall hash_get_max_bucket_length ( __int64 @@a1@@ ) { _QWORD * @@i@@ ; unsigned __int64 @@v3@@ ; _QWORD * @@v4@@ ; unsigned __int64 @@j@@ ; @@v3@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { @@v4@@ = @@i@@ ; for ( @@j@@ = Number L ; ; ++ @@j@@ ) { @@v4@@ = ( _QWORD * ) @@v4@@ [ Number ] ; if ( ! @@v4@@ ) break ; } if ( @@j@@ > @@v3@@ ) @@v3@@ = @@j@@ ; } } return @@v3@@ ; }
unsigned __int64 __fastcall check_extension ( const char * @@a1@@ , __int64 @@a2@@ , char @@a3@@ ) { unsigned __int64 @@v5@@ ; unsigned __int64 @@v6@@ ; char * @@v7@@ ; unsigned __int64 @@v8@@ ; __int64 @@v9@@ ; __int16 @@v10@@ ; unsigned __int64 @@v11@@ ; @@v11@@ = __readfsqword ( Number ) ; @@v7@@ = ( char * ) last_component ( @@a1@@ ) ; @@v5@@ = base_len ( @@v7@@ ) ; @@v8@@ = Number L ; if ( @@v5@@ > Number ) { @@v10@@ = * ( _WORD * ) @@v7@@ ; * ( _WORD * ) @@v7@@ = Number ; * __errno_location ( ) = Number ; @@v9@@ = pathconf ( @@a1@@ , Number ) ; if ( @@v9@@ >= Number || ! * __errno_location ( ) ) @@v8@@ = @@v9@@ ; * ( _WORD * ) @@v7@@ = @@v10@@ ; } if ( @@v8@@ < @@v5@@ ) { @@v6@@ = & @@a1@@ [ @@a2@@ ] - @@v7@@ ; if ( @@v8@@ <= @@v6@@ ) @@v6@@ = @@v8@@ - Number ; @@v7@@ [ @@v6@@ ] = @@a3@@ ; @@v7@@ [ @@v6@@ + Number ] = Number ; } return __readfsqword ( Number ) ^ @@v11@@ ; }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
void * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
int __fastcall hash_print_statistics ( __int64 @@a1@@ , FILE * @@a2@@ ) { double @@v2@@ ; double @@v3@@ ; double @@v4@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v6@@ = hash_get_n_entries ( @@a1@@ ) ; @@v7@@ = hash_get_n_buckets ( @@a1@@ ) ; @@v8@@ = hash_get_n_buckets_used ( @@a1@@ ) ; @@v9@@ = hash_get_max_bucket_length ( @@a1@@ ) ; fprintf ( @@a2@@ , String , @@v6@@ ) ; fprintf ( @@a2@@ , String , @@v7@@ ) ; if ( @@v8@@ < Number ) @@v2@@ = ( double ) ( int ) ( @@v8@@ & Number | ( ( unsigned __int64 ) @@v8@@ >> Number ) ) + ( double ) ( int ) ( @@v8@@ & Number | ( ( unsigned __int64 ) @@v8@@ >> Number ) ) ; else @@v2@@ = ( double ) ( int ) @@v8@@ ; @@v3@@ = Number * @@v2@@ ; if ( @@v7@@ < Number ) @@v4@@ = ( double ) ( int ) ( @@v7@@ & Number | ( ( unsigned __int64 ) @@v7@@ >> Number ) ) + ( double ) ( int ) ( @@v7@@ & Number | ( ( unsigned __int64 ) @@v7@@ >> Number ) ) ; else @@v4@@ = ( double ) ( int ) @@v7@@ ; fprintf ( @@a2@@ , String , @@v8@@ , @@v3@@ / @@v4@@ ) ; return fprintf ( @@a2@@ , String , @@v9@@ ) ; }
int clock_gettime ( clockid_t @@clock_id@@ , struct timespec * @@tp@@ ) { return clock_gettime ( @@clock_id@@ , @@tp@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
void * __fastcall mdir_name ( _BYTE * @@a1@@ ) { _BYTE * @@n@@ ; void * @@dest@@ ; @@n@@ = dir_len ( @@a1@@ ) ; @@dest@@ = malloc ( ( size_t ) & @@n@@ [ ( @@n@@ == Number L ) + Number ] ) ; if ( ! @@dest@@ ) return Number L ; memcpy ( @@dest@@ , @@a1@@ , ( size_t ) @@n@@ ) ; if ( ! @@n@@ ) { @@n@@ = ( _BYTE * ) ( & dword_0 + Number ) ; * ( _BYTE * ) @@dest@@ = Number ; } @@n@@ [ ( _QWORD ) @@dest@@ ] = Number ; return @@dest@@ ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
void * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
int __lxstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _lxstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
int dirfd ( DIR * @@dirp@@ ) { return dirfd ( @@dirp@@ ) ; }
_BYTE * __fastcall longest_relative_suffix ( _BYTE * @@a1@@ ) { while ( * @@a1@@ == Number ) ++ @@a1@@ ; return @@a1@@ ; }
unsigned __int64 __fastcall hash_string ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ ) { unsigned __int64 @@v4@@ ; @@v4@@ = Number L ; while ( * @@a1@@ ) @@v4@@ = ( Number * @@v4@@ + ( unsigned __int8 ) * @@a1@@ ++ ) % @@a2@@ ; return @@v4@@ ; }
int __xstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _xstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
void * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
int putchar_unlocked ( int @@c@@ ) { return putchar_unlocked ( @@c@@ ) ; }
__int64 __fastcall hash_get_n_buckets ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
int __fxstat ( int @@ver@@ , int @@fildes@@ , struct stat * @@stat_buf@@ ) { return _fxstat ( @@ver@@ , @@fildes@@ , @@stat_buf@@ ) ; }
ssize_t __fastcall safe_read ( int @@a1@@ , void * @@a2@@ , size_t @@a3@@ ) { ssize_t @@result@@ ; ssize_t @@v5@@ ; LABEL_1 : for ( @@result@@ = read ( @@a1@@ , @@a2@@ , @@a3@@ ) ; ; @@result@@ = read ( @@a1@@ , @@a2@@ , Number ) ) { @@v5@@ = @@result@@ ; if ( @@result@@ >= Number ) break ; if ( * __errno_location ( ) == Number ) goto LABEL_1 ; if ( * __errno_location ( ) != Number || @@a3@@ <= Number ) return @@v5@@ ; @@a3@@ = Number L ; } return @@result@@ ; }
unsigned __int64 __fastcall raw_hasher ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return rotr_sz ( @@a1@@ , Number ) % @@a2@@ ; }
unsigned int gnu_dev_minor ( unsigned __int64 @@dev@@ ) { return gnu_dev_minor ( @@dev@@ ) ; }
__int64 __fastcall hash_get_n_entries ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
unsigned __int64 __fastcall compute_bucket_size ( __int64 @@a1@@ , __int64 @@a2@@ ) { float @@v2@@ ; unsigned __int64 @@result@@ ; unsigned __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; float @@v6@@ ; @@v4@@ = @@a1@@ ; if ( * ( _BYTE * ) ( @@a2@@ + Number ) != Number ) { if ( @@a1@@ < Number ) @@v2@@ = ( float ) ( @@a1@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@a1@@ >> Number ) ) + ( float ) ( @@a1@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@a1@@ >> Number ) ) ; else @@v2@@ = ( float ) ( int ) @@a1@@ ; @@v6@@ = @@v2@@ / * ( float * ) ( @@a2@@ + Number ) ; if ( @@v6@@ >= Number ) return Number L ; if ( @@v6@@ >= Number ) @@v4@@ = ( unsigned int ) ( int ) ( float ) ( @@v6@@ - Number ) ^ Number ; else @@v4@@ = ( unsigned int ) ( int ) @@v6@@ ; } @@v5@@ = next_prime ( @@v4@@ ) ; if ( @@v5@@ <= Number ) @@result@@ = @@v5@@ ; else @@result@@ = Number L ; return @@result@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
_BYTE * __fastcall savedirstream ( DIR * @@a1@@ ) { __int64 @@v2@@ ; int @@v3@@ ; _BYTE * @@ptr@@ ; unsigned __int64 @@v5@@ ; size_t @@v6@@ ; struct dirent * @@v7@@ ; char * @@src@@ ; size_t @@n@@ ; @@v5@@ = Number L ; @@v6@@ = Number L ; if ( ! @@a1@@ ) return Number L ; @@ptr@@ = ( _BYTE * ) xmalloc ( Number L ) ; while ( Number ) { * __errno_location ( ) = Number ; @@v7@@ = readdir ( @@a1@@ ) ; if ( ! @@v7@@ ) break ; @@src@@ = @@v7@@ -> d_name ; if ( @@v7@@ -> d_name [ Number ] == Number ) { if ( @@v7@@ -> d_name [ Number ] == Number ) @@v2@@ = Number L ; else @@v2@@ = Number L ; } else { @@v2@@ = Number L ; } if ( @@src@@ [ @@v2@@ ] ) { @@n@@ = strlen ( @@v7@@ -> d_name ) + Number ; if ( @@v6@@ > @@v6@@ + @@n@@ ) xalloc_die ( ) ; if ( @@v5@@ <= @@v6@@ + @@n@@ ) { do { if ( @@v5@@ > Number * @@v5@@ ) xalloc_die ( ) ; @@v5@@ *= Number L ; } while ( @@v5@@ <= @@v6@@ + @@n@@ ) ; @@ptr@@ = ( _BYTE * ) xrealloc ( @@ptr@@ , @@v5@@ ) ; } memcpy ( & @@ptr@@ [ @@v6@@ ] , @@src@@ , @@n@@ ) ; @@v6@@ += @@n@@ ; } } @@ptr@@ [ @@v6@@ ] = Number ; @@v3@@ = * __errno_location ( ) ; if ( closedir ( @@a1@@ ) ) @@v3@@ = * __errno_location ( ) ; if ( ! @@v3@@ ) return @@ptr@@ ; free ( @@ptr@@ ) ; * __errno_location ( ) = @@v3@@ ; return Number L ; }
__int64 __fastcall get_stat_ctime ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
void * __fastcall allocate_entry ( __int64 @@a1@@ ) { __int64 @@v2@@ ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return malloc ( Number ) ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = * ( _QWORD * ) ( @@v2@@ + Number ) ; return ( void * ) @@v2@@ ; }
bool __fastcall extra_mode ( int @@a1@@ ) { return ( @@a1@@ & Number ) != Number ; }
__int64 __fastcall xnrealloc ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { if ( ! is_mul_ok ( @@a3@@ , @@a2@@ ) ) xalloc_die ( ) ; return xrealloc ( @@a1@@ , @@a3@@ * @@a2@@ ) ; }
_BOOL8 __fastcall hash_table_ok ( __int64 @@a1@@ ) { _QWORD * @@i@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; _QWORD * @@v5@@ ; @@v3@@ = Number L ; @@v4@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { @@v5@@ = @@i@@ ; ++ @@v3@@ ; ++ @@v4@@ ; while ( Number ) { @@v5@@ = ( _QWORD * ) @@v5@@ [ Number ] ; if ( ! @@v5@@ ) break ; ++ @@v4@@ ; } } } return @@v3@@ == * ( _QWORD * ) ( @@a1@@ + Number ) && @@v4@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ; }
void * __fastcall human_access ( __int64 @@a1@@ ) { filemodestring ( @@a1@@ , & modebuf_5918 ) ; byte_20D0FA = Number ; return & modebuf_5918 ; }
int __fastcall out_uint ( const char * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { strcpy ( ( char * ) & @@a1@@ [ @@a2@@ ] , String ) ; return printf ( @@a1@@ , @@a3@@ ) ; }
DIR * __fastcall opendir_safer ( const char * @@a1@@ ) { int @@v2@@ ; int @@fd@@ ; int @@v4@@ ; DIR * @@dirp@@ ; DIR * @@v6@@ ; @@dirp@@ = opendir ( @@a1@@ ) ; if ( @@dirp@@ ) { @@v2@@ = dirfd ( @@dirp@@ ) ; if ( @@v2@@ >= Number && @@v2@@ <= Number ) { @@fd@@ = dup_safer ( ( unsigned int ) @@v2@@ ) ; @@v6@@ = fdopendir ( @@fd@@ ) ; @@v4@@ = * __errno_location ( ) ; if ( ! @@v6@@ ) close ( @@fd@@ ) ; closedir ( @@dirp@@ ) ; * __errno_location ( ) = @@v4@@ ; @@dirp@@ = @@v6@@ ; } } return @@dirp@@ ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v4@@ ; @@v4@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v4@@ >= Number / @@a3@@ ) xalloc_die ( ) ; @@v4@@ += ( @@v4@@ + Number ) >> Number ; } else if ( ! @@v4@@ ) { @@v4@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v4@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v4@@ ) ; }
__int64 __fastcall hash_do_for_each ( __int64 @@a1@@ , unsigned __int8 ( __fastcall * @@a2@@ ) ( _QWORD , __int64 ) , __int64 @@a3@@ ) { __int64 @@v5@@ ; _QWORD * @@i@@ ; _QWORD * @@j@@ ; @@v5@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = @@i@@ ; @@j@@ ; @@j@@ = ( _QWORD * ) @@j@@ [ Number ] ) { if ( @@a2@@ ( * @@j@@ , @@a3@@ ) != Number ) return @@v5@@ ; ++ @@v5@@ ; } } } return @@v5@@ ; }
unsigned __int64 __fastcall out_file_context ( __int64 @@a1@@ , const char * @@a2@@ , __int64 @@a3@@ ) { unsigned int @@v3@@ ; __int64 @@v4@@ ; char * @@v5@@ ; int * @@v6@@ ; const char * @@v7@@ ; const char * @@v10@@ ; unsigned __int64 @@v11@@ ; @@v11@@ = __readfsqword ( Number ) ; if ( follow_links ) @@v3@@ = ( unsigned int ) getfilecon ( @@a1@@ , & @@v10@@ ) >> Number ; else @@v3@@ = ( unsigned int ) lgetfilecon ( @@a1@@ , & @@v10@@ ) >> Number ; if ( ( _BYTE ) @@v3@@ ) { @@v4@@ = quote ( @@a1@@ ) ; @@v5@@ = gettext ( String ) ; @@v6@@ = __errno_location ( ) ; error ( Number , * @@v6@@ , @@v5@@ , @@v4@@ ) ; @@v10@@ = Number L ; } * ( _WORD * ) & @@a2@@ [ @@a3@@ ] = Number ; if ( @@v10@@ ) @@v7@@ = @@v10@@ ; else @@v7@@ = String ; printf ( @@a2@@ , @@v7@@ ) ; if ( @@v10@@ ) freecon ( ) ; return __readfsqword ( Number ) ^ @@v11@@ ; }
_BOOL8 __fastcall need_copy ( char * @@a1@@ , char * @@a2@@ , __int64 @@a3@@ ) { _BOOL8 @@result@@ ; __uid_t @@v4@@ ; __uid_t @@v5@@ ; __gid_t @@v6@@ ; __gid_t @@v7@@ ; bool @@v9@@ ; char @@v10@@ ; int @@fd@@ ; int @@v12@@ ; char * @@s1@@ ; char * @@s2@@ ; struct stat @@v15@@ ; struct stat @@v16@@ ; unsigned __int64 @@v17@@ ; @@v17@@ = __readfsqword ( Number ) ; if ( extra_mode ( mode ) ) return Number L ; if ( ( unsigned int ) lstat ( @@a1@@ , & @@v15@@ ) ) return Number L ; if ( ( unsigned int ) lstat ( @@a2@@ , & @@v16@@ ) ) return Number L ; if ( ( @@v15@@ . st_mode & Number ) != Number || ( @@v16@@ . st_mode & Number ) != Number || extra_mode ( @@v15@@ . st_mode ) || extra_mode ( @@v16@@ . st_mode ) ) { return Number L ; } if ( @@v15@@ . st_size != @@v16@@ . st_size || ( @@v16@@ . st_mode & Number ) != mode ) return Number L ; @@v4@@ = @@v16@@ . st_uid ; @@v5@@ = owner_id == Number ? getuid ( ) : owner_id ; if ( @@v5@@ != @@v4@@ ) return Number L ; @@v6@@ = @@v16@@ . st_gid ; @@v7@@ = group_id == Number ? getgid ( ) : group_id ; if ( @@v7@@ != @@v6@@ ) return Number L ; if ( ! selinux_enabled || ! * ( _BYTE * ) ( @@a3@@ + Number ) ) goto LABEL_31 ; @@s1@@ = Number L ; @@s2@@ = Number L ; if ( ( unsigned int ) getfilecon ( @@a1@@ , & @@s1@@ ) == Number ) return Number L ; if ( ( unsigned int ) getfilecon ( @@a2@@ , & @@s2@@ ) == Number ) { freecon ( ) ; return Number L ; } @@v9@@ = strcmp ( @@s1@@ , @@s2@@ ) == Number ; freecon ( ) ; freecon ( ) ; if ( ! @@v9@@ ) return Number L ; LABEL_31 : @@fd@@ = open ( @@a1@@ , Number ) ; if ( @@fd@@ < Number ) return Number L ; @@v12@@ = open ( @@a2@@ , Number ) ; if ( @@v12@@ >= Number ) { @@v10@@ = have_same_content ( @@fd@@ , @@v12@@ ) ; close ( @@fd@@ ) ; close ( @@v12@@ ) ; @@result@@ = @@v10@@ == Number ; } else { close ( @@fd@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
bool __fastcall is_prime ( unsigned __int64 @@a1@@ ) { unsigned __int64 @@v2@@ ; unsigned __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; @@v2@@ = Number L ; @@v4@@ = Number L ; while ( @@v4@@ < @@a1@@ && @@a1@@ % @@v2@@ ) { @@v3@@ = @@v2@@ + Number ; @@v4@@ += Number * @@v3@@ ; @@v2@@ = @@v3@@ + Number ; } return @@a1@@ % @@v2@@ != Number ; }
int __cdecl __noreturn main ( int @@argc@@ , const char * * @@argv@@ , const char * * @@envp@@ ) { char * @@v3@@ ; char * @@v4@@ ; unsigned __int8 @@v5@@ ; char @@v6@@ ; char @@v7@@ ; bool @@v8@@ ; int @@i@@ ; int @@v10@@ ; const char * @@v11@@ ; @@v6@@ = Number ; @@v7@@ = Number ; @@v11@@ = Number L ; @@v8@@ = Number ; set_program_name ( * @@argv@@ , @@argv@@ , @@envp@@ ) ; setlocale ( Number , & locale ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; while ( Number ) { while ( Number ) { while ( Number ) { @@v10@@ = getopt_long ( @@argc@@ , ( char * const * ) @@argv@@ , String , & long_options , Number L ) ; if ( @@v10@@ == Number ) { if ( @@argc@@ == optind ) { @@v4@@ = gettext ( String ) ; error ( Number , Number , @@v4@@ ) ; usage ( Number ) ; } for ( @@i@@ = optind ; @@i@@ < @@argc@@ ; ++ @@i@@ ) { if ( @@v6@@ ) @@v5@@ = do_statfs ( @@argv@@ [ @@i@@ ] , @@v7@@ , @@v11@@ ) ; else @@v5@@ = do_stat ( ( char * ) @@argv@@ [ @@i@@ ] , @@v7@@ , @@v11@@ ) ; @@v8@@ = ( @@v8@@ & @@v5@@ ) != Number ; } exit ( ! @@v8@@ ) ; } if ( @@v10@@ != Number ) break ; @@v3@@ = gettext ( String ) ; error ( Number , Number , @@v3@@ ) ; } if ( @@v10@@ <= Number ) break ; if ( @@v10@@ == Number ) { @@v6@@ = Number ; } else if ( @@v10@@ > Number ) { if ( @@v10@@ == Number ) { @@v7@@ = Number ; } else { if ( @@v10@@ != Number ) goto LABEL_22 ; @@v11@@ = ( const char * ) optarg ; interpret_backslash_escapes = Number ; trailing_delim = ( char * ) & locale ; } } else { if ( @@v10@@ != Number ) goto LABEL_22 ; @@v11@@ = ( const char * ) optarg ; interpret_backslash_escapes = Number ; trailing_delim = String ; } } if ( @@v10@@ == Number ) usage ( Number ) ; if ( @@v10@@ != Number ) { if ( @@v10@@ == Number ) { version_etc ( ( _DWORD ) stdout , ( unsigned int ) String , ( unsigned int ) String , ( _DWORD ) Version , ( unsigned int ) String , Number , ( char ) @@argv@@ ) ; exit ( Number ) ; } LABEL_22 : usage ( Number ) ; } follow_links = Number ; } }
__int64 __fastcall bkm_scale_by_power ( unsigned __int64 * @@a1@@ , int @@a2@@ , int @@a3@@ ) { unsigned int @@i@@ ; for ( @@i@@ = Number ; @@a3@@ -- ; @@i@@ |= bkm_scale ( @@a1@@ , @@a2@@ ) ) { ; } return @@i@@ ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { char * @@v1@@ ; char * @@v2@@ ; char * @@v3@@ ; char * @@v4@@ ; char * @@v5@@ ; char * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; FILE * @@v10@@ ; char * @@v11@@ ; FILE * @@v12@@ ; char * @@v13@@ ; FILE * @@v14@@ ; char * @@v15@@ ; FILE * @@v16@@ ; char * @@v17@@ ; FILE * @@v18@@ ; char * @@v19@@ ; FILE * @@v20@@ ; char * @@v21@@ ; FILE * @@v22@@ ; char * @@v23@@ ; FILE * @@v24@@ ; char * @@v25@@ ; FILE * @@v26@@ ; char * @@v27@@ ; if ( @@a1@@ ) { @@v1@@ = program_name ; @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = program_name ; @@v4@@ = program_name ; @@v5@@ = program_name ; @@v6@@ = program_name ; @@v7@@ = gettext ( String String String String ) ; printf ( @@v7@@ , @@v6@@ , @@v5@@ , @@v4@@ , @@v3@@ ) ; @@v8@@ = stdout ; @@v9@@ = gettext ( String String String String String String String String String String ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = stdout ; @@v11@@ = gettext ( String ) ; fputs_unlocked ( @@v11@@ , @@v10@@ ) ; @@v12@@ = stdout ; @@v13@@ = gettext ( String String String String String String String ) ; fputs_unlocked ( @@v13@@ , @@v12@@ ) ; @@v14@@ = stdout ; @@v15@@ = gettext ( String String String String String ) ; fputs_unlocked ( @@v15@@ , @@v14@@ ) ; @@v16@@ = stdout ; @@v17@@ = gettext ( String String String String String String String String ) ; fputs_unlocked ( @@v17@@ , @@v16@@ ) ; @@v18@@ = stdout ; @@v19@@ = gettext ( String String ) ; fputs_unlocked ( @@v19@@ , @@v18@@ ) ; @@v20@@ = stdout ; @@v21@@ = gettext ( String ) ; fputs_unlocked ( @@v21@@ , @@v20@@ ) ; @@v22@@ = stdout ; @@v23@@ = gettext ( String ) ; fputs_unlocked ( @@v23@@ , @@v22@@ ) ; @@v24@@ = stdout ; @@v25@@ = gettext ( String String String String String ) ; fputs_unlocked ( @@v25@@ , @@v24@@ ) ; @@v26@@ = stdout ; @@v27@@ = gettext ( String String String String ) ; fputs_unlocked ( @@v27@@ , @@v26@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
__int64 __fastcall linkat_follow ( unsigned int @@a1@@ , _BYTE * @@a2@@ , int @@a3@@ , const char * @@a4@@ ) { __int64 @@result@@ ; int @@v8@@ ; int @@v9@@ ; unsigned int @@v10@@ ; int @@v11@@ ; _BYTE * @@ptr@@ ; _BYTE * @@v13@@ ; _BYTE * @@v14@@ ; @@ptr@@ = @@a2@@ ; @@v8@@ = Number ; while ( @@v8@@ -- ) { @@v13@@ = ( _BYTE * ) areadlinkat ( @@a1@@ , @@ptr@@ ) ; if ( ! @@v13@@ ) break ; if ( * @@v13@@ == Number ) { if ( @@ptr@@ != @@a2@@ ) free ( @@ptr@@ ) ; @@ptr@@ = @@v13@@ ; } else { @@v14@@ = mdir_name ( @@ptr@@ ) ; if ( @@ptr@@ != @@a2@@ ) free ( @@ptr@@ ) ; if ( ! @@v14@@ ) { free ( @@v13@@ ) ; * __errno_location ( ) = Number ; return Number ; } @@ptr@@ = mfile_name_concat ( @@v14@@ , @@v13@@ , Number L ) ; free ( @@v14@@ ) ; free ( @@v13@@ ) ; if ( ! @@ptr@@ ) { * __errno_location ( ) = Number ; return Number ; } } } if ( @@v8@@ < Number ) { @@v13@@ = Number L ; * __errno_location ( ) = Number ; } if ( @@v13@@ || * __errno_location ( ) == Number ) { @@v10@@ = linkat ( @@a1@@ , @@ptr@@ , @@a3@@ , @@a4@@ , Number ) ; if ( @@ptr@@ != @@a2@@ ) { @@v11@@ = * __errno_location ( ) ; free ( @@ptr@@ ) ; * __errno_location ( ) = @@v11@@ ; } @@result@@ = @@v10@@ ; } else { if ( @@ptr@@ != @@a2@@ ) { @@v9@@ = * __errno_location ( ) ; free ( @@ptr@@ ) ; * __errno_location ( ) = @@v9@@ ; } @@result@@ = Number ; } return @@result@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
unsigned __int64 __fastcall hash_pjw ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ ) { unsigned __int64 @@v4@@ ; @@v4@@ = Number L ; while ( * @@a1@@ ) @@v4@@ = __ROL8__ ( @@v4@@ , Number ) + ( char ) * @@a1@@ ++ ; return @@v4@@ % @@a2@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
__int64 __fastcall copy ( char * @@a1@@ , char * @@a2@@ , char @@a3@@ , unsigned int * @@a4@@ , bool * @@a5@@ , _BYTE * @@a6@@ ) { char @@v11@@ ; unsigned __int64 @@v12@@ ; @@v12@@ = __readfsqword ( Number ) ; if ( ! ( unsigned __int8 ) valid_options ( ( __int64 ) @@a4@@ ) ) __assert_fail ( String , String , Number , String ) ; top_level_src_name = ( __int64 ) @@a1@@ ; top_level_dst_name = ( __int64 ) @@a2@@ ; @@v11@@ = Number ; return copy_internal ( @@a1@@ , @@a2@@ , @@a3@@ , Number L , Number L , @@a4@@ , Number , & @@v11@@ , @@a5@@ , @@a6@@ ) ; }
_BYTE * __fastcall filemodestring ( __int64 @@a1@@ , _BYTE * @@a2@@ ) { return strmode ( * ( _DWORD * ) ( @@a1@@ + Number ) , @@a2@@ ) ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
unsigned __int64 __fastcall forget_created ( __int64 @@a1@@ , __int64 @@a2@@ ) { void * * @@v3@@ ; __int64 @@v4@@ [ Number ] ; unsigned __int64 @@v5@@ ; @@v5@@ = __readfsqword ( Number ) ; @@v4@@ [ Number ] = @@a1@@ ; @@v4@@ [ Number ] = @@a2@@ ; @@v4@@ [ Number ] = Number L ; @@v3@@ = ( void * * ) hash_delete ( src_to_dest , @@v4@@ ) ; if ( @@v3@@ ) src_to_dest_free ( @@v3@@ ) ; return __readfsqword ( Number ) ^ @@v5@@ ; }
__int64 __fastcall argmatch ( const char * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { __int64 @@result@@ ; char @@v7@@ ; __int64 @@i@@ ; __int64 @@v9@@ ; size_t @@n@@ ; @@v9@@ = Number ; @@v7@@ = Number ; @@n@@ = strlen ( @@a1@@ ) ; for ( @@i@@ = Number L ; * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; ++ @@i@@ ) { if ( ! strncmp ( * ( const char * * ) ( Number * @@i@@ + @@a2@@ ) , @@a1@@ , @@n@@ ) ) { if ( @@n@@ == strlen ( * ( const char * * ) ( Number * @@i@@ + @@a2@@ ) ) ) return @@i@@ ; if ( @@v9@@ == Number ) { @@v9@@ = @@i@@ ; } else if ( ! @@a3@@ || memcmp ( ( const void * ) ( @@a4@@ * @@v9@@ + @@a3@@ ) , ( const void * ) ( @@i@@ * @@a4@@ + @@a3@@ ) , @@a4@@ ) ) { @@v7@@ = Number ; } } } if ( @@v7@@ ) @@result@@ = Number ; else @@result@@ = @@v9@@ ; return @@result@@ ; }
_BYTE * __fastcall mkancesdirs ( char * @@a1@@ , _DWORD * @@a2@@ , __int64 ( __fastcall * @@a3@@ ( ) ( constchar , constchar , void ) ) ( char * , char * , __int64 ) , __int64 @@a4@@ , int @@a5@@ , int @@a6@@ ) { int @@v6@@ ; char * @@v8@@ ; char @@v11@@ ; char @@v12@@ ; int @@v13@@ ; int @@v14@@ ; int @@v15@@ ; char * @@v16@@ ; char * @@v17@@ ; char * @@v18@@ ; @@v16@@ = Number L ; @@v17@@ = @@a1@@ ; @@v18@@ = @@a1@@ ; @@v11@@ = Number ; while ( Number ) { do { while ( Number ) { @@v8@@ = @@v18@@ ++ ; @@v12@@ = * @@v8@@ ; if ( ! * @@v8@@ ) return ( _BYTE * ) ( @@v17@@ - @@a1@@ ) ; if ( * @@v18@@ != Number ) break ; if ( @@v12@@ != Number ) @@v16@@ = @@v18@@ ; } } while ( @@v12@@ != Number || ! * @@v18@@ || ! @@v16@@ ) ; if ( @@v16@@ - @@v17@@ != Number || * @@v17@@ != Number ) break ; LABEL_29 : @@v17@@ = @@v18@@ ; } @@v13@@ = Number ; @@v14@@ = Number ; * @@v16@@ = Number ; if ( @@v16@@ - @@v17@@ == Number && * @@v17@@ == Number && @@v17@@ [ Number ] == Number ) { @@v11@@ = Number ; goto LABEL_20 ; } @@v6@@ = @@a3@@ ( ) ( constchar , constchar , void ) ( @@a1@@ , @@v17@@ , @@a4@@ ) ; switch ( @@v6@@ ) { case Number : @@v14@@ = Number ; goto LABEL_19 ; case Number : LABEL_19 : @@v11@@ = Number ; break ; case Number : @@v13@@ = * __errno_location ( ) ; break ; } LABEL_20 : if ( @@v11@@ ) @@v14@@ |= Number ; @@v15@@ = savewd_chdir ( @@a2@@ , ( __int64 ) @@v17@@ , @@v14@@ , Number L , @@a5@@ , @@a6@@ ) ; if ( @@v15@@ != Number ) * @@v16@@ = Number ; if ( ! @@v15@@ ) goto LABEL_29 ; if ( @@v13@@ && * __errno_location ( ) == Number ) * __errno_location ( ) = @@v13@@ ; return ( _BYTE * ) @@v15@@ ; }
void * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * @@v4@@ ; void * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * @@v12@@ ; void * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == ( __int64 * ) & slotvec0 ; if ( slotvec == ( __int64 * ) & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = off_220058 ; * @@v12@@ = ( __int64 ) slotvec0 ; @@v12@@ [ Number ] = ( __int64 ) @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = ( void * ) @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = @@v17@@ + Number ; if ( @@ptr@@ != & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( void * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = ( __int64 ) @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
__int64 __fastcall get_stat_mtime_ns ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int64 __fastcall set_acl ( const char * @@a1@@ , int @@a2@@ , __mode_t @@a3@@ ) { __int64 @@v3@@ ; char * @@v4@@ ; int * @@v5@@ ; unsigned int @@v7@@ ; @@v7@@ = qset_acl ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( @@v7@@ ) { @@v3@@ = quote ( @@a1@@ ) ; @@v4@@ = gettext ( String ) ; @@v5@@ = __errno_location ( ) ; error ( Number , * @@v5@@ , @@v4@@ , @@v3@@ ) ; } return @@v7@@ ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
__int64 __fastcall dup_safer ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
bool __fastcall dev_info_compare ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { return * @@a1@@ == * @@a2@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
bool __fastcall seen_file ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 * @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; if ( ! @@a1@@ ) return Number ; @@v4@@ [ Number ] = @@a2@@ ; @@v4@@ [ Number ] = @@a3@@ [ Number ] ; @@v4@@ [ Number ] = * @@a3@@ ; return hash_lookup ( @@a1@@ , @@v4@@ ) != Number ; }
unsigned __int64 __fastcall triple_hash ( _QWORD * @@a1@@ , unsigned __int64 @@a2@@ ) { return ( ( unsigned __int64 ) hash_pjw ( * @@a1@@ , @@a2@@ ) ^ @@a1@@ [ Number ] ) % @@a2@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
__int64 __fastcall fd_safer ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { unsigned int @@fd@@ ; unsigned int @@v8@@ ; int @@v9@@ ; @@fd@@ = @@a1@@ ; if ( @@a1@@ >= Number && @@a1@@ <= Number ) { @@v8@@ = dup_safer ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; @@v9@@ = * __errno_location ( ) ; close ( @@a1@@ ) ; * __errno_location ( ) = @@v9@@ ; @@fd@@ = @@v8@@ ; } return @@fd@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
__int64 __fastcall validate_timespec ( _QWORD * @@a1@@ ) { __int64 @@result@@ ; int @@v2@@ ; int @@v3@@ ; @@v2@@ = Number ; @@v3@@ = Number ; if ( ! @@a1@@ ) __assert_fail ( String , String , Number , String ) ; if ( ( @@a1@@ [ Number ] == Number || @@a1@@ [ Number ] == Number L || ( __int64 ) @@a1@@ [ Number ] >= Number && ( __int64 ) @@a1@@ [ Number ] <= Number ) && ( @@a1@@ [ Number ] == Number || @@a1@@ [ Number ] == Number L || ( __int64 ) @@a1@@ [ Number ] >= Number && ( __int64 ) @@a1@@ [ Number ] <= Number ) ) { if ( @@a1@@ [ Number ] == Number || @@a1@@ [ Number ] == Number L ) { * @@a1@@ = Number L ; @@v2@@ = Number ; if ( @@a1@@ [ Number ] == Number L ) @@v3@@ = Number ; } if ( @@a1@@ [ Number ] == Number || @@a1@@ [ Number ] == Number L ) { @@a1@@ [ Number ] = Number L ; @@v2@@ = Number ; if ( @@a1@@ [ Number ] == Number L ) ++ @@v3@@ ; } @@result@@ = ( unsigned int ) ( @@v3@@ == Number ) + @@v2@@ ; } else { * __errno_location ( ) = Number ; @@result@@ = Number ; } return @@result@@ ; }
_BOOL8 __fastcall triple_compare ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { return @@a1@@ [ Number ] == @@a2@@ [ Number ] && @@a1@@ [ Number ] == @@a2@@ [ Number ] && ( unsigned __int8 ) same_name ( * @@a1@@ , * @@a2@@ ) ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
__int64 decimal_point_char ( ) { __int64 @@result@@ ; char * @@v1@@ ; @@v1@@ = nl_langinfo ( Number ) ; if ( * @@v1@@ ) @@result@@ = ( unsigned __int8 ) * @@v1@@ ; else @@result@@ = Number L ; return @@result@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( ) ; return @@ptr@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_20D038 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 __fastcall savewd_save ( _DWORD * @@a1@@ , __int64 a2 , int @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { int @@v7@@ ; switch ( * @@a1@@ ) { case Number : @@v7@@ = open_safer ( ( unsigned int ) String , Number , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( @@v7@@ >= Number ) { * @@a1@@ = Number ; @@a1@@ [ Number ] = @@v7@@ ; return Number L ; } if ( * __errno_location ( ) != Number && * __errno_location ( ) != Number ) goto LABEL_6 ; * @@a1@@ = Number ; @@a1@@ [ Number ] = Number ; LABEL_8 : if ( ( int ) @@a1@@ [ Number ] < Number ) { @@a1@@ [ Number ] = fork ( ) ; if ( @@a1@@ [ Number ] ) { if ( ( int ) @@a1@@ [ Number ] > Number ) return Number L ; LABEL_6 : * @@a1@@ = Number ; @@a1@@ [ Number ] = * __errno_location ( ) ; } } return Number L ; case Number : case Number : case Number : case Number : return Number L ; case Number : goto LABEL_8 ; default : __assert_fail ( String , String , Number , String ) ; } }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
__int64 __fastcall get_stat_mtime ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
struct tm * localtime ( const time_t * @@timer@@ ) { return localtime ( @@timer@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
char * __fastcall separator_string ( const char * @@a1@@ ) { col_sep_length = strlen ( @@a1@@ ) ; col_sep_string = ( char * ) xmalloc ( col_sep_length + Number ) ; return strcpy ( col_sep_string , @@a1@@ ) ; }
int toupper ( int @@c@@ ) { return toupper ( @@c@@ ) ; }
_BOOL8 yesno ( ) { bool @@v1@@ ; char * @@lineptr@@ ; size_t @@n@@ ; __ssize_t @@v4@@ ; unsigned __int64 @@v5@@ ; @@v5@@ = __readfsqword ( Number ) ; @@lineptr@@ = Number L ; @@n@@ = Number L ; @@v4@@ = getline ( & @@lineptr@@ , & @@n@@ , stdin ) ; if ( @@v4@@ > Number ) { @@lineptr@@ [ @@v4@@ - Number ] = Number ; @@v1@@ = rpmatch ( @@lineptr@@ ) > Number ; } else { @@v1@@ = Number ; } free ( @@lineptr@@ ) ; return @@v1@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
struct passwd * getpwuid ( __uid_t @@uid@@ ) { return getpwuid ( @@uid@@ ) ; }
void __fastcall argmatch_invalid ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { char * @@v3@@ ; __int64 @@v4@@ ; void * @@v5@@ ; char * @@format@@ ; if ( @@a3@@ == Number ) @@v3@@ = gettext ( String ) ; else @@v3@@ = gettext ( String ) ; @@format@@ = @@v3@@ ; @@v4@@ = quote_n ( Number , @@a1@@ ) ; @@v5@@ = quotearg_n_style ( Number , Number , @@a2@@ ) ; error ( Number , Number , @@format@@ , @@v5@@ , @@v4@@ ) ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
void * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
_QWORD * init_funcs ( ) { bool @@v0@@ ; bool @@v1@@ ; _QWORD * @@result@@ ; int @@i@@ ; int @@v4@@ ; int @@v5@@ ; _QWORD * @@v6@@ ; if ( truncate_lines != Number ) { @@v5@@ = Number ; } else if ( parallel_files && numbered_lines ) { @@v5@@ = chars_per_margin + chars_per_column + number_width ; } else { @@v5@@ = chars_per_column + chars_per_margin ; } @@v4@@ = col_sep_length + chars_per_margin ; @@v6@@ = column_vector ; for ( @@i@@ = Number ; @@i@@ < columns ; ++ @@i@@ ) { if ( storing_columns ) { @@v6@@ [ Number ] = store_char ; @@v6@@ [ Number ] = print_stored ; } else { @@v6@@ [ Number ] = print_char ; @@v6@@ [ Number ] = read_line ; } @@v0@@ = numbered_lines && ( parallel_files != Number || @@i@@ == Number ) ; * ( ( _BYTE * ) @@v6@@ + Number ) = @@v0@@ ; * ( ( _DWORD * ) @@v6@@ + Number ) = @@v4@@ ; if ( truncate_lines != Number ) { @@v4@@ = Number ; @@v5@@ = Number ; } else { @@v4@@ = col_sep_length + @@v5@@ ; @@v5@@ += chars_per_column + col_sep_length ; } @@v6@@ += Number ; } if ( storing_columns && balance_columns ) { @@v6@@ [ Number ] = store_char ; @@v6@@ [ Number ] = print_stored ; } else { @@v6@@ [ Number ] = print_char ; @@v6@@ [ Number ] = read_line ; } @@v1@@ = numbered_lines && ( parallel_files != Number || @@i@@ == Number ) ; * ( ( _BYTE * ) @@v6@@ + Number ) = @@v1@@ ; @@result@@ = @@v6@@ ; * ( ( _DWORD * ) @@v6@@ + Number ) = @@v4@@ ; return @@result@@ ; }
struct group * getgrgid ( __gid_t @@gid@@ ) { return getgrgid ( @@gid@@ ) ; }
__int64 __fastcall argmatch_to_argument ( const void * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; ++ @@i@@ ) { if ( ! memcmp ( @@a1@@ , ( const void * ) ( @@i@@ * @@a4@@ + @@a3@@ ) , @@a4@@ ) ) return * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; } return Number L ; }
void * __fastcall find_backup_file_name ( const char * @@a1@@ , int @@a2@@ ) { int @@v2@@ ; bool @@v4@@ ; void * @@dest@@ ; size_t @@v6@@ ; __int64 @@v7@@ ; size_t @@n@@ ; unsigned __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; @@v10@@ = __readfsqword ( Number ) ; @@v7@@ = strlen ( @@a1@@ ) ; @@v4@@ = Number ; @@n@@ = strlen ( simple_backup_suffix ) + Number ; @@v6@@ = @@n@@ ; if ( @@n@@ <= Number ) @@v6@@ = Number L ; @@v9@@ = @@v7@@ + @@v6@@ + Number ; @@dest@@ = ( void * ) xmalloc ( @@v9@@ ) ; memcpy ( @@dest@@ , @@a1@@ , @@v7@@ + Number ) ; if ( @@a2@@ != Number ) { @@v2@@ = numbered_backup ( ( __int64 * ) & @@dest@@ , @@v9@@ , @@v7@@ ) ; switch ( @@v2@@ ) { case Number : @@v4@@ = Number ; break ; case Number : return @@dest@@ ; case Number : @@v4@@ = @@a2@@ == Number ; break ; } } if ( @@v4@@ ) memcpy ( ( char * ) @@dest@@ + @@v7@@ , simple_backup_suffix , @@n@@ ) ; check_extension ( ( const char * ) @@dest@@ , @@v7@@ , Number ) ; return @@dest@@ ; }
void * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_222168 ; @@v4@@ [ Number ] = qword_222170 ; @@v4@@ [ Number ] = qword_222178 ; @@v4@@ [ Number ] = qword_222180 ; @@v4@@ [ Number ] = qword_222188 ; @@v4@@ [ Number ] = qword_222190 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
int __xstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _xstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
__int64 reset_status ( ) { __int64 @@result@@ ; int @@v1@@ ; _DWORD * @@v2@@ ; @@v1@@ = columns ; @@v2@@ = column_vector ; while ( @@v1@@ ) { if ( @@v2@@ [ Number ] == Number ) { @@v2@@ [ Number ] = Number ; ++ files_ready_to_read ; } -- @@v1@@ ; @@v2@@ += Number ; } @@result@@ = ( unsigned __int8 ) storing_columns ; if ( storing_columns ) { @@result@@ = * ( ( unsigned int * ) column_vector + Number ) ; files_ready_to_read = @@result@@ != Number ; } return @@result@@ ; }
__int64 __fastcall dirchownmod ( int @@a1@@ , char * @@a2@@ , int @@a3@@ , __uid_t @@a4@@ , __gid_t @@a5@@ , int @@a6@@ , int @@a7@@ ) { unsigned int @@v7@@ ; int @@v8@@ ; int @@v9@@ ; unsigned int @@v15@@ ; int @@v16@@ ; __mode_t @@v17@@ ; int @@mode@@ ; int @@v19@@ ; struct stat @@v20@@ ; unsigned __int64 @@v21@@ ; @@v21@@ = __readfsqword ( Number ) ; if ( @@a1@@ >= Number ) @@v7@@ = fstat ( @@a1@@ , & @@v20@@ ) ; else @@v7@@ = stat ( @@a2@@ , & @@v20@@ ) ; @@v15@@ = @@v7@@ ; if ( ! @@v7@@ ) { @@v17@@ = @@v20@@ . st_mode ; if ( ( @@v20@@ . st_mode & Number ) == Number ) { @@v16@@ = Number ; if ( @@a4@@ != Number && @@a4@@ != @@v20@@ . st_uid || @@a5@@ != Number && @@a5@@ != @@v20@@ . st_gid ) { if ( @@a1@@ < Number ) @@v8@@ = @@a3@@ == Number ? chown ( @@a2@@ , @@a4@@ , @@a5@@ ) : lchown ( @@a2@@ , @@a4@@ , @@a5@@ ) ; else @@v8@@ = fchown ( @@a1@@ , @@a4@@ , @@a5@@ ) ; @@v15@@ = @@v8@@ ; if ( ! @@v8@@ && ( @@v17@@ & Number ) != Number ) @@v16@@ = @@v17@@ & Number ; } if ( ! @@v15@@ && ( @@a7@@ & ( @@v16@@ | @@a6@@ ^ @@v17@@ ) ) != Number ) { @@mode@@ = @@a6@@ | ( unsigned __int16 ) @@v17@@ & ( unsigned __int16 ) ~ ( _WORD ) @@a7@@ & Number ; if ( @@a1@@ < Number ) @@v9@@ = chmod ( @@a2@@ , @@mode@@ ) ; else @@v9@@ = fchmod ( @@a1@@ , @@mode@@ ) ; @@v15@@ = @@v9@@ ; } } else { * __errno_location ( ) = Number ; @@v15@@ = Number ; } } if ( @@a1@@ >= Number ) { if ( @@v15@@ ) { @@v19@@ = * __errno_location ( ) ; close ( @@a1@@ ) ; * __errno_location ( ) = @@v19@@ ; } else { @@v15@@ = close ( @@a1@@ ) ; } } return @@v15@@ ; }
__int64 __fastcall clear_ungetc_buffer_preserving_position ( _DWORD * @@a1@@ ) { __int64 @@result@@ ; @@result@@ = * @@a1@@ & Number ; if ( ( _DWORD ) @@result@@ ) @@result@@ = rpl_fseeko ( @@a1@@ , Number L , Number L ) ; return @@result@@ ; }
time_t mktime ( struct tm * @@tp@@ ) { return mktime ( @@tp@@ ) ; }
ssize_t __fastcall safe_write ( int @@a1@@ , const void * @@a2@@ , size_t @@a3@@ ) { ssize_t @@result@@ ; ssize_t @@v5@@ ; LABEL_1 : for ( @@result@@ = write ( @@a1@@ , @@a2@@ , @@a3@@ ) ; ; @@result@@ = write ( @@a1@@ , @@a2@@ , Number ) ) { @@v5@@ = @@result@@ ; if ( @@result@@ >= Number ) break ; if ( * __errno_location ( ) == Number ) goto LABEL_1 ; if ( * __errno_location ( ) != Number || @@a3@@ <= Number ) return @@v5@@ ; @@a3@@ = Number L ; } return @@result@@ ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void * init_page ( ) { void * @@result@@ ; int @@v1@@ ; int @@v2@@ ; _DWORD * @@v3@@ ; char * @@v4@@ ; if ( storing_columns ) { store_columns ( ) ; @@v1@@ = columns - Number ; @@v3@@ = column_vector ; while ( @@v1@@ ) { @@v3@@ [ Number ] = @@v3@@ [ Number ] ; -- @@v1@@ ; @@v3@@ += Number ; } if ( balance_columns ) { @@result@@ = @@v3@@ ; @@v3@@ [ Number ] = @@v3@@ [ Number ] ; } else { @@result@@ = @@v3@@ ; if ( @@v3@@ [ Number ] ) @@v3@@ [ Number ] = Number ; else @@v3@@ [ Number ] = lines_per_body ; } } else { @@v2@@ = columns ; @@result@@ = column_vector ; @@v4@@ = ( char * ) column_vector ; while ( @@v2@@ ) { @@result@@ = @@v4@@ ; if ( * ( ( _DWORD * ) @@v4@@ + Number ) ) * ( ( _DWORD * ) @@v4@@ + Number ) = Number ; else * ( ( _DWORD * ) @@v4@@ + Number ) = lines_per_body ; -- @@v2@@ ; @@v4@@ += Number ; } } return @@result@@ ; }
unsigned int gnu_dev_major ( unsigned __int64 @@dev@@ ) { return gnu_dev_major ( @@dev@@ ) ; }
_BYTE * __fastcall savedir ( const char * @@a1@@ ) { DIR * @@v1@@ ; @@v1@@ = opendir_safer ( @@a1@@ ) ; return savedirstream ( @@v1@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int64 __fastcall add_line_number ( __int64 @@a1@@ ) { char * @@v1@@ ; int @@v2@@ ; __int64 @@result@@ ; int @@i@@ ; int @@v5@@ ; char * @@v6@@ ; if ( line_number >= power_10 ) sprintf ( number_buff , String , chars_per_number , ( unsigned int ) ( line_number % power_10 ) ) ; else sprintf ( number_buff , String , chars_per_number , ( unsigned int ) line_number ) ; ++ line_number ; @@v6@@ = number_buff ; for ( @@i@@ = chars_per_number ; @@i@@ > Number ; -- @@i@@ ) { @@v1@@ = @@v6@@ ++ ; ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@a1@@ + Number ) ) ( ( unsigned int ) * @@v1@@ ) ; } if ( columns <= Number ) { ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@a1@@ + Number ) ) ( ( unsigned int ) number_separator ) ; if ( number_separator == Number ) output_position += chars_per_output_tab - output_position % chars_per_output_tab ; } else if ( number_separator == Number ) { @@v5@@ = number_width - chars_per_number ; while ( Number ) { @@v2@@ = @@v5@@ -- ; if ( @@v2@@ <= Number ) break ; ( * ( void ( __fastcall * * ) ( __int64 ) ) ( @@a1@@ + Number ) ) ( Number L ) ; } } else { ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@a1@@ + Number ) ) ( ( unsigned int ) number_separator ) ; } @@result@@ = ( unsigned __int8 ) truncate_lines ; if ( truncate_lines ) { @@result@@ = ( unsigned __int8 ) parallel_files ^ Number ; if ( parallel_files != Number ) { @@result@@ = ( unsigned int ) ( input_position + number_width ) ; input_position += number_width ; } } return @@result@@ ; }
_BYTE * __fastcall fdsavedir ( int @@a1@@ ) { DIR * @@v1@@ ; @@v1@@ = fdopendir ( @@a1@@ ) ; return savedirstream ( @@v1@@ ) ; }
_BYTE * __fastcall strmode ( __int16 @@a1@@ , _BYTE * @@a2@@ ) { char @@v2@@ ; char @@v3@@ ; char @@v4@@ ; char @@v5@@ ; char @@v6@@ ; char @@v7@@ ; char @@v8@@ ; char @@v9@@ ; char @@v10@@ ; _BYTE * @@result@@ ; * @@a2@@ = ftypelet ( @@a1@@ ) ; if ( ( @@a1@@ & Number ) != Number ) @@v2@@ = Number ; else @@v2@@ = Number ; @@a2@@ [ Number ] = @@v2@@ ; if ( ( @@a1@@ & Number ) != Number ) @@v3@@ = Number ; else @@v3@@ = Number ; @@a2@@ [ Number ] = @@v3@@ ; if ( ( @@a1@@ & Number ) != Number ) { if ( ( @@a1@@ & Number ) != Number ) @@v4@@ = Number ; else @@v4@@ = Number ; } else if ( ( @@a1@@ & Number ) != Number ) { @@v4@@ = Number ; } else { @@v4@@ = Number ; } @@a2@@ [ Number ] = @@v4@@ ; if ( ( @@a1@@ & Number ) != Number ) @@v5@@ = Number ; else @@v5@@ = Number ; @@a2@@ [ Number ] = @@v5@@ ; if ( ( @@a1@@ & Number ) != Number ) @@v6@@ = Number ; else @@v6@@ = Number ; @@a2@@ [ Number ] = @@v6@@ ; if ( ( @@a1@@ & Number ) != Number ) { if ( ( @@a1@@ & Number ) != Number ) @@v7@@ = Number ; else @@v7@@ = Number ; } else if ( ( @@a1@@ & Number ) != Number ) { @@v7@@ = Number ; } else { @@v7@@ = Number ; } @@a2@@ [ Number ] = @@v7@@ ; if ( ( @@a1@@ & Number ) != Number ) @@v8@@ = Number ; else @@v8@@ = Number ; @@a2@@ [ Number ] = @@v8@@ ; if ( ( @@a1@@ & Number ) != Number ) @@v9@@ = Number ; else @@v9@@ = Number ; @@a2@@ [ Number ] = @@v9@@ ; if ( ( @@a1@@ & Number ) != Number ) { if ( ( @@a1@@ & Number ) != Number ) @@v10@@ = Number ; else @@v10@@ = Number ; } else if ( ( @@a1@@ & Number ) != Number ) { @@v10@@ = Number ; } else { @@v10@@ = Number ; } @@a2@@ [ Number ] = @@v10@@ ; @@a2@@ [ Number ] = Number ; @@result@@ = @@a2@@ + Number ; @@a2@@ [ Number ] = Number ; return @@result@@ ; }
__int64 __fastcall get_stat_atime ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int64 __fastcall do_statfs ( const char * @@a1@@ , char @@a2@@ , const char * @@a3@@ ) { __int64 @@v3@@ ; char * @@v4@@ ; __int64 @@result@@ ; __int64 @@v6@@ ; char * @@v7@@ ; int * @@v8@@ ; const char * @@v9@@ ; struct statfs @@v11@@ ; unsigned __int64 @@v12@@ ; @@v12@@ = __readfsqword ( Number ) ; if ( ! strcmp ( @@a1@@ , String ) ) { @@v3@@ = quote ( @@a1@@ ) ; @@v4@@ = gettext ( String ) ; error ( Number , Number , @@v4@@ , @@v3@@ ) ; @@result@@ = Number L ; } else if ( statfs ( @@a1@@ , & @@v11@@ ) ) { @@v6@@ = quote ( @@a1@@ ) ; @@v7@@ = gettext ( String ) ; @@v8@@ = __errno_location ( ) ; error ( Number , * @@v8@@ , @@v7@@ , @@v6@@ ) ; @@result@@ = Number L ; } else { if ( ! @@a3@@ ) { if ( @@a2@@ ) @@v9@@ = String ; else @@v9@@ = String String String String String ; @@a3@@ = @@v9@@ ; } print_it ( @@a3@@ , ( __int64 ) @@a1@@ , ( void ( __fastcall * ) ( void * , size_t , _QWORD , __int64 , __int64 ) ) print_statfs , ( __int64 ) & @@v11@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
int __fastcall print_char ( signed __int8 @@a1@@ ) { const unsigned __int16 * @@v2@@ ; if ( tabify_output ) { if ( @@a1@@ == Number ) return ++ spaces_not_printed ; if ( spaces_not_printed > Number ) print_white_space ( ) ; @@v2@@ = * __ctype_b_loc ( ) ; if ( ( @@v2@@ [ ( unsigned __int8 ) to_uchar ( @@a1@@ ) ] & Number ) != Number ) { ++ output_position ; } else if ( @@a1@@ == Number ) { -- output_position ; } } return putchar_unlocked ( @@a1@@ ) ; }
__int64 __fastcall get_stat_atime_ns ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int64 __fastcall get_stat_mtime ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int64 __fastcall get_stat_ctime_ns ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int64 __fastcall get_stat_atime_1 ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
int __fastcall out_string ( const char * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { * ( _WORD * ) & @@a1@@ [ @@a2@@ ] = Number ; return printf ( @@a1@@ , @@a3@@ ) ; }
int __fastcall rpl_linkat ( unsigned int @@a1@@ , char * @@a2@@ , int @@a3@@ , const char * @@a4@@ , int @@a5@@ ) { int @@v6@@ ; int @@v9@@ ; if ( ! @@a5@@ ) return linkat ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , Number ) ; @@v6@@ = @@a5@@ ; BYTE1 ( @@v6@@ ) = BYTE1 ( @@a5@@ ) & Number ; if ( @@v6@@ ) { * __errno_location ( ) = Number ; return Number ; } if ( have_follow_really_4385 >= Number ) { @@v9@@ = linkat ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; if ( @@v9@@ != Number || * __errno_location ( ) != Number ) { have_follow_really_4385 = Number ; return @@v9@@ ; } have_follow_really_4385 = Number ; } return linkat_follow ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
char * __fastcall areadlink_with_size ( const char * @@a1@@ , unsigned __int64 @@a2@@ ) { __int64 @@v2@@ ; char * @@i@@ ; int @@v5@@ ; size_t @@size@@ ; char * @@buf@@ ; ssize_t @@v8@@ ; if ( @@a2@@ >= Number ) @@v2@@ = Number L ; else @@v2@@ = @@a2@@ + Number ; @@size@@ = @@v2@@ ; LABEL_5 : for ( @@i@@ = ( char * ) malloc ( @@size@@ ) ; ; @@i@@ = ( char * ) malloc ( Number ) ) { @@buf@@ = @@i@@ ; if ( ! @@i@@ ) return Number L ; @@v8@@ = readlink ( @@a1@@ , @@i@@ , @@size@@ ) ; if ( @@v8@@ < Number && * __errno_location ( ) != Number ) { @@v5@@ = * __errno_location ( ) ; free ( @@buf@@ ) ; * __errno_location ( ) = @@v5@@ ; return Number L ; } if ( @@v8@@ < @@size@@ ) { @@buf@@ [ @@v8@@ ] = Number ; return @@buf@@ ; } free ( @@buf@@ ) ; if ( @@size@@ <= Number ) { @@size@@ *= Number L ; goto LABEL_5 ; } if ( @@size@@ > Number ) break ; @@size@@ = Number ; } * __errno_location ( ) = Number ; return Number L ; }
__int64 __fastcall print_stored ( _DWORD * @@a1@@ ) { int @@v1@@ ; __int64 @@result@@ ; signed __int8 * @@v3@@ ; int @@v4@@ ; int @@v5@@ ; _DWORD * @@v6@@ ; signed __int8 * @@v7@@ ; signed __int8 * @@v8@@ ; @@v1@@ = @@a1@@ [ Number ] ; @@a1@@ [ Number ] = @@v1@@ + Number ; @@v5@@ = @@v1@@ ; @@v7@@ = ( char * ) buff + * ( ( int * ) line_vector + @@v1@@ ) ; @@v8@@ = ( char * ) buff + * ( ( int * ) line_vector + @@v1@@ + Number ) ; pad_vertically = Number ; if ( print_a_header ) print_header ( ) ; if ( @@a1@@ [ Number ] != Number ) goto LABEL_11 ; @@v4@@ = Number ; @@v6@@ = column_vector ; while ( @@v4@@ <= columns ) { @@v6@@ [ Number ] = Number ; ++ @@v4@@ ; @@v6@@ += Number ; } if ( * ( ( int * ) column_vector + Number ) <= Number ) { if ( extremities != Number ) pad_vertically = Number ; @@result@@ = Number L ; } else { LABEL_11 : if ( padding_not_printed - col_sep_length > Number ) { pad_across_to ( padding_not_printed - col_sep_length ) ; padding_not_printed = Number ; } if ( use_col_separator ) print_sep_string ( ) ; while ( @@v7@@ != @@v8@@ ) { @@v3@@ = @@v7@@ ++ ; print_char ( * @@v3@@ ) ; } if ( ! spaces_not_printed ) { output_position = @@a1@@ [ Number ] + * ( ( _DWORD * ) end_vector + @@v5@@ ) ; if ( @@a1@@ [ Number ] - col_sep_length == chars_per_margin ) output_position -= col_sep_length ; } @@result@@ = Number L ; } return @@result@@ ; }
int __fastcall out_uint_o ( const char * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { strcpy ( ( char * ) & @@a1@@ [ @@a2@@ ] , String ) ; return printf ( @@a1@@ , @@a3@@ ) ; }
__int64 __fastcall savewd_errno ( _DWORD * @@a1@@ ) { __int64 @@result@@ ; if ( * @@a1@@ == Number ) @@result@@ = ( unsigned int ) @@a1@@ [ Number ] ; else @@result@@ = Number L ; return @@result@@ ; }
__int64 __fastcall update_timespec ( __int64 @@a1@@ , __int64 * * @@a2@@ ) { __int64 @@result@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 * @@v5@@ ; @@v5@@ = * @@a2@@ ; if ( ( * @@a2@@ ) [ Number ] == Number && @@v5@@ [ Number ] == Number ) return Number L ; if ( @@v5@@ [ Number ] == Number && @@v5@@ [ Number ] == Number ) { * @@a2@@ = Number L ; @@result@@ = Number L ; } else { if ( @@v5@@ [ Number ] == Number ) { * @@v5@@ = get_stat_atime_1 ( @@a1@@ ) ; @@v5@@ [ Number ] = @@v3@@ ; } else if ( @@v5@@ [ Number ] == Number ) { gettime ( @@v5@@ ) ; } if ( @@v5@@ [ Number ] == Number ) { @@v5@@ [ Number ] = get_stat_mtime_1 ( @@a1@@ ) ; @@v5@@ [ Number ] = @@v4@@ ; } else if ( @@v5@@ [ Number ] == Number ) { gettime ( @@v5@@ + Number ) ; } @@result@@ = Number L ; } return @@result@@ ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ ) { return xmalloc ( @@a1@@ ) ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( is_mul_ok ( @@a2@@ , * @@a1@@ ) ) { * @@a1@@ *= @@a2@@ ; @@result@@ = Number L ; } else { * @@a1@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall make_node_op_equals ( int @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; @@result@@ = xmalloc ( Number L ) ; * ( _BYTE * ) @@result@@ = Number ; * ( _BYTE * ) ( @@result@@ + Number ) = Number ; * ( _DWORD * ) ( @@result@@ + Number ) = Number ; * ( _DWORD * ) ( @@result@@ + Number ) = @@a1@@ ; * ( _DWORD * ) ( @@result@@ + Number ) = @@a2@@ ; * ( _BYTE * ) ( @@result@@ + Number ) = Number ; return @@result@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@v2@@ ; @@v2@@ = malloc ( @@a1@@ ) ; if ( ! @@v2@@ && @@a1@@ ) xalloc_die ( ) ; return @@v2@@ ; }
int __fastcall print_statfs ( const char * @@a1@@ , __int64 @@a2@@ , char @@a3@@ , __int64 @@a4@@ , __int64 * @@a5@@ ) { int @@result@@ ; const char * @@v6@@ ; int @@i@@ ; __int64 @@v8@@ ; switch ( @@a3@@ ) { case String : @@result@@ = out_file_context ( @@a4@@ , @@a1@@ , @@a2@@ ) ; break ; case String : case String : @@result@@ = out_uint ( @@a1@@ , @@a2@@ , @@a5@@ [ Number ] ) ; break ; case String : @@v6@@ = human_fstype ( @@a5@@ ) ; @@result@@ = out_string ( @@a1@@ , @@a2@@ , ( __int64 ) @@v6@@ ) ; break ; case String : @@result@@ = out_int ( @@a1@@ , @@a2@@ , @@a5@@ [ Number ] ) ; break ; case String : @@result@@ = out_int ( @@a1@@ , @@a2@@ , @@a5@@ [ Number ] ) ; break ; case String : @@result@@ = out_uint ( @@a1@@ , @@a2@@ , @@a5@@ [ Number ] ) ; break ; case String : @@result@@ = out_int ( @@a1@@ , @@a2@@ , @@a5@@ [ Number ] ) ; break ; case String : @@result@@ = out_int ( @@a1@@ , @@a2@@ , @@a5@@ [ Number ] ) ; break ; case String : @@v8@@ = Number L ; for ( @@i@@ = Number ; @@i@@ < Number && ( unsigned __int64 ) ( Number L * @@i@@ ) <= Number ; ++ @@i@@ ) { @@v8@@ |= ( unsigned __int64 ) * ( ( unsigned int * ) @@a5@@ + Number - @@i@@ + Number ) << ( Number * ( unsigned __int8 ) @@i@@ ) ; } @@result@@ = out_uint_x ( @@a1@@ , @@a2@@ , @@v8@@ ) ; break ; case String : @@result@@ = out_uint ( @@a1@@ , @@a2@@ , @@a5@@ [ Number ] ) ; break ; case String : @@result@@ = out_string ( @@a1@@ , @@a2@@ , @@a4@@ ) ; break ; case String : @@result@@ = out_uint_x ( @@a1@@ , @@a2@@ , * @@a5@@ ) ; break ; default : @@result@@ = fputc_unlocked ( Number , stdout ) ; break ; } return @@result@@ ; }
void * __fastcall xzalloc ( size_t @@a1@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@a1@@ ) ; return memset ( @@v1@@ , Number , @@a1@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
__int64 __fastcall mode_create_from_ref ( char * @@a1@@ ) { __int64 @@result@@ ; struct stat @@v2@@ ; unsigned __int64 @@v3@@ ; @@v3@@ = __readfsqword ( Number ) ; if ( ( unsigned int ) stat ( @@a1@@ , & @@v2@@ ) ) @@result@@ = Number L ; else @@result@@ = make_node_op_equals ( @@v2@@ . st_mode , Number ) ; return @@result@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@v3@@ ; @@v3@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v3@@ ) xalloc_die ( ) ; return @@v3@@ ; }
char * __fastcall file_type ( __int64 @@a1@@ ) { char * @@result@@ ; switch ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) { case Number : if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) @@result@@ = gettext ( String ) ; else @@result@@ = gettext ( String ) ; break ; case Number : @@result@@ = gettext ( String ) ; break ; case Number : @@result@@ = gettext ( String ) ; break ; case Number : @@result@@ = gettext ( String ) ; break ; case Number : @@result@@ = gettext ( String ) ; break ; case Number : @@result@@ = gettext ( String ) ; break ; case Number : @@result@@ = gettext ( String ) ; break ; default : @@result@@ = gettext ( String ) ; break ; } return @@result@@ ; }
__int64 __fastcall hard_locale ( int @@a1@@ ) { unsigned __int8 @@v2@@ ; const char * @@s1@@ ; @@v2@@ = Number ; @@s1@@ = setlocale ( @@a1@@ , Number L ) ; if ( @@s1@@ && ( ! strcmp ( @@s1@@ , String ) || ! strcmp ( @@s1@@ , String ) ) ) @@v2@@ = Number ; return @@v2@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
char * __fastcall areadlinkat ( int @@a1@@ , const char * @@a2@@ ) { signed __int64 @@v3@@ ; int @@v4@@ ; char * @@buf@@ ; __int64 @@len@@ ; signed __int64 @@size@@ ; size_t @@sizea@@ ; char * @@v9@@ ; char @@src@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v11@@ = __readfsqword ( Number ) ; @@buf@@ = @@src@@ ; @@len@@ = Number L ; while ( Number ) { @@size@@ = readlinkat ( @@a1@@ , @@a2@@ , @@buf@@ , @@len@@ ) ; if ( @@size@@ < Number && * __errno_location ( ) != Number ) { if ( @@buf@@ != @@src@@ ) { @@v4@@ = * __errno_location ( ) ; free ( @@buf@@ ) ; * __errno_location ( ) = @@v4@@ ; } return Number L ; } if ( @@len@@ > ( unsigned __int64 ) @@size@@ ) break ; if ( @@buf@@ != @@src@@ ) free ( @@buf@@ ) ; @@len@@ *= Number L ; if ( @@len@@ < Number ) { * __errno_location ( ) = Number ; return Number L ; } @@buf@@ = ( char * ) malloc ( @@len@@ ) ; if ( ! @@buf@@ ) return Number L ; } @@v3@@ = @@size@@ ; @@sizea@@ = @@size@@ + Number ; @@buf@@ [ @@v3@@ ] = Number ; if ( @@buf@@ == @@src@@ ) { @@buf@@ = ( char * ) malloc ( @@sizea@@ ) ; if ( ! @@buf@@ ) return Number L ; memcpy ( @@buf@@ , @@src@@ , @@sizea@@ ) ; } else if ( @@len@@ > @@sizea@@ ) { @@v9@@ = ( char * ) realloc ( @@buf@@ , @@sizea@@ ) ; if ( @@v9@@ ) @@buf@@ = @@v9@@ ; } return @@buf@@ ; }
__int64 __fastcall mode_adjust ( __int16 @@a1@@ , unsigned __int8 @@a2@@ , int @@a3@@ , char * @@a4@@ , _DWORD * @@a5@@ ) { int @@v5@@ ; int @@v6@@ ; int @@v7@@ ; int @@v8@@ ; int @@v9@@ ; int @@v10@@ ; int @@v11@@ ; int @@v12@@ ; int @@v13@@ ; unsigned int @@v17@@ ; int @@v18@@ ; int @@v19@@ ; int @@v20@@ ; int @@v21@@ ; int @@v22@@ ; int @@v23@@ ; @@v17@@ = @@a1@@ & Number ; @@v18@@ = Number ; while ( @@a4@@ [ Number ] ) { @@v22@@ = * ( ( _DWORD * ) @@a4@@ + Number ) ; if ( @@a2@@ ) @@v5@@ = Number ; else @@v5@@ = Number ; @@v23@@ = @@v5@@ & ~ * ( ( _DWORD * ) @@a4@@ + Number ) ; @@v19@@ = * ( ( _DWORD * ) @@a4@@ + Number ) ; @@v6@@ = @@a4@@ [ Number ] ; if ( @@v6@@ == Number ) { if ( @@v17@@ & Number | @@a2@@ ) @@v19@@ |= Number ; } else if ( @@v6@@ == Number ) { @@v20@@ = @@v17@@ & @@v19@@ ; if ( ( @@v20@@ & Number ) != Number ) @@v7@@ = Number ; else @@v7@@ = Number ; if ( ( @@v20@@ & Number ) != Number ) @@v8@@ = Number ; else @@v8@@ = Number ; @@v9@@ = @@v8@@ | @@v7@@ ; if ( ( @@v20@@ & Number ) != Number ) @@v10@@ = Number ; else @@v10@@ = Number ; @@v19@@ = @@v9@@ | @@v10@@ | @@v20@@ ; } if ( @@v22@@ ) @@v11@@ = * ( ( _DWORD * ) @@a4@@ + Number ) ; else @@v11@@ = ~ @@a3@@ ; @@v21@@ = ~ @@v23@@ & @@v11@@ & @@v19@@ ; @@v12@@ = * @@a4@@ ; switch ( @@v12@@ ) { case String : @@v18@@ |= @@v21@@ ; @@v17@@ &= ~ @@v21@@ ; break ; case String : if ( @@v22@@ ) @@v13@@ = ~ @@v22@@ ; else @@v13@@ = Number ; @@v18@@ |= ~ ( ( unsigned __int16 ) @@v23@@ | ( unsigned __int16 ) @@v13@@ ) & Number ; @@v17@@ = @@v21@@ | ( @@v23@@ | @@v13@@ ) & @@v17@@ ; break ; case String : @@v18@@ |= @@v21@@ ; @@v17@@ |= @@v21@@ ; break ; } @@a4@@ += Number ; } if ( @@a5@@ ) * @@a5@@ = @@v18@@ ; return @@v17@@ ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
__int64 __fastcall xsum ( unsigned __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; if ( @@a1@@ + @@a2@@ < @@a1@@ ) @@result@@ = Number ; else @@result@@ = @@a1@@ + @@a2@@ ; return @@result@@ ; }
_BYTE * __fastcall strmode ( __int16 @@a1@@ , _BYTE * @@a2@@ ) { char @@v2@@ ; char @@v3@@ ; char @@v4@@ ; char @@v5@@ ; char @@v6@@ ; char @@v7@@ ; char @@v8@@ ; char @@v9@@ ; char @@v10@@ ; _BYTE * @@result@@ ; * @@a2@@ = ftypelet ( @@a1@@ ) ; if ( ( @@a1@@ & Number ) != Number ) @@v2@@ = Number ; else @@v2@@ = Number ; @@a2@@ [ Number ] = @@v2@@ ; if ( ( @@a1@@ & Number ) != Number ) @@v3@@ = Number ; else @@v3@@ = Number ; @@a2@@ [ Number ] = @@v3@@ ; if ( ( @@a1@@ & Number ) != Number ) { if ( ( @@a1@@ & Number ) != Number ) @@v4@@ = Number ; else @@v4@@ = Number ; } else if ( ( @@a1@@ & Number ) != Number ) { @@v4@@ = Number ; } else { @@v4@@ = Number ; } @@a2@@ [ Number ] = @@v4@@ ; if ( ( @@a1@@ & Number ) != Number ) @@v5@@ = Number ; else @@v5@@ = Number ; @@a2@@ [ Number ] = @@v5@@ ; if ( ( @@a1@@ & Number ) != Number ) @@v6@@ = Number ; else @@v6@@ = Number ; @@a2@@ [ Number ] = @@v6@@ ; if ( ( @@a1@@ & Number ) != Number ) { if ( ( @@a1@@ & Number ) != Number ) @@v7@@ = Number ; else @@v7@@ = Number ; } else if ( ( @@a1@@ & Number ) != Number ) { @@v7@@ = Number ; } else { @@v7@@ = Number ; } @@a2@@ [ Number ] = @@v7@@ ; if ( ( @@a1@@ & Number ) != Number ) @@v8@@ = Number ; else @@v8@@ = Number ; @@a2@@ [ Number ] = @@v8@@ ; if ( ( @@a1@@ & Number ) != Number ) @@v9@@ = Number ; else @@v9@@ = Number ; @@a2@@ [ Number ] = @@v9@@ ; if ( ( @@a1@@ & Number ) != Number ) { if ( ( @@a1@@ & Number ) != Number ) @@v10@@ = Number ; else @@v10@@ = Number ; } else if ( ( @@a1@@ & Number ) != Number ) { @@v10@@ = Number ; } else { @@v10@@ = Number ; } @@a2@@ [ Number ] = @@v10@@ ; @@a2@@ [ Number ] = Number ; @@result@@ = @@a2@@ + Number ; @@a2@@ [ Number ] = Number ; return @@result@@ ; }
void * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
void * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
unsigned __int64 __fastcall xmax ( unsigned __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { unsigned __int64 @@result@@ ; @@result@@ = @@a2@@ ; if ( @@a1@@ >= @@a2@@ ) @@result@@ = @@a1@@ ; return @@result@@ ; }
__int64 __fastcall memcpy_uppcase ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { while ( @@a3@@ -- ) * ( _BYTE * ) ( @@a1@@ + @@a3@@ ) = toupper ( * ( unsigned __int8 * ) ( @@a2@@ + @@a3@@ ) ) ; return @@a1@@ ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
void * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
_BOOL8 __fastcall is_infinite_or_zerol ( long double @@a1@@ ) { return ( unsigned int ) rpl_isnanl ( * ( _TBYTE * ) & @@a1@@ ) || @@a1@@ == @@a1@@ + @@a1@@ ; }
__int64 __fastcall nstrftime ( char * @@a1@@ , __int64 @@a2@@ , const char * @@a3@@ , __int64 @@a4@@ , int @@a5@@ , int @@a6@@ ) { return strftime_case_ ( Number , @@a1@@ , @@a2@@ , ( char * ) @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
void * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
void * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 __fastcall xsum_0 ( unsigned __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; if ( @@a1@@ + @@a2@@ < @@a1@@ ) @@result@@ = Number ; else @@result@@ = @@a1@@ + @@a2@@ ; return @@result@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_20D038 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
void * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_222168 ; @@v8@@ [ Number ] = qword_222170 ; @@v8@@ [ Number ] = qword_222178 ; @@v8@@ [ Number ] = qword_222180 ; @@v8@@ [ Number ] = qword_222188 ; @@v8@@ [ Number ] = qword_222190 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
int __fastcall stat ( char * @@filename@@ , struct stat * @@stat_buf@@ ) { return __xstat ( Number , @@filename@@ , @@stat_buf@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
int __fastcall stat ( char * @@filename@@ , struct stat * @@stat_buf@@ ) { return __xstat ( Number , @@filename@@ , @@stat_buf@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
int __fastcall lstat ( char * @@filename@@ , struct stat * @@stat_buf@@ ) { return __lxstat ( Number , @@filename@@ , @@stat_buf@@ ) ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
_BOOL8 __fastcall same_name ( _BYTE * @@a1@@ , _BYTE * @@a2@@ ) { bool @@v2@@ ; int * @@v3@@ ; int * @@v4@@ ; bool @@v5@@ ; bool @@v7@@ ; const char * @@s1@@ ; const char * @@s2@@ ; size_t @@v10@@ ; size_t @@n@@ ; char * @@ptr@@ ; char * @@filename@@ ; struct stat @@v14@@ ; struct stat @@v15@@ ; unsigned __int64 @@v16@@ ; @@v16@@ = __readfsqword ( Number ) ; @@s1@@ = last_component ( @@a1@@ ) ; @@s2@@ = last_component ( @@a2@@ ) ; @@v10@@ = base_len ( @@s1@@ ) ; @@n@@ = base_len ( @@s2@@ ) ; @@v2@@ = @@v10@@ == @@n@@ && ! memcmp ( @@s1@@ , @@s2@@ , @@n@@ ) ; @@v7@@ = Number ; if ( @@v2@@ ) { @@ptr@@ = ( char * ) dir_name ( ( __int64 ) @@a1@@ ) ; @@filename@@ = ( char * ) dir_name ( ( __int64 ) @@a2@@ ) ; if ( ( unsigned int ) stat ( @@ptr@@ , & @@v14@@ ) ) { @@v3@@ = __errno_location ( ) ; error ( Number , * @@v3@@ , String , @@ptr@@ ) ; } if ( ( unsigned int ) stat ( @@filename@@ , & @@v15@@ ) ) { @@v4@@ = __errno_location ( ) ; error ( Number , * @@v4@@ , String , @@filename@@ ) ; } @@v5@@ = @@v14@@ . st_ino == @@v15@@ . st_ino && @@v14@@ . st_dev == @@v15@@ . st_dev ; @@v7@@ = @@v5@@ ; free ( @@ptr@@ ) ; free ( @@filename@@ ) ; } return @@v7@@ ; }
int __fastcall fstat ( int @@fildes@@ , struct stat * @@stat_buf@@ ) { return __fxstat ( Number , @@fildes@@ , @@stat_buf@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_20D168 ; @@v8@@ [ Number ] = qword_20D170 ; @@v8@@ [ Number ] = qword_20D178 ; @@v8@@ [ Number ] = qword_20D180 ; @@v8@@ [ Number ] = qword_20D188 ; @@v8@@ [ Number ] = qword_20D190 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_210088 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
int __fastcall fstat ( int @@fildes@@ , struct stat * @@stat_buf@@ ) { return __fxstat ( Number , @@fildes@@ , @@stat_buf@@ ) ; }
size_t __fastcall rpl_vfprintf ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { size_t @@result@@ ; size_t @@v4@@ ; int @@v5@@ ; size_t @@v6@@ ; void * @@ptr@@ ; size_t @@n@@ ; char @@v9@@ [ Number ] ; unsigned __int64 @@v10@@ ; @@v10@@ = __readfsqword ( Number ) ; @@v6@@ = Number L ; @@ptr@@ = ( void * ) vasnprintf ( @@v9@@ , & @@v6@@ , @@a2@@ , @@a3@@ ) ; @@n@@ = @@v6@@ ; if ( @@ptr@@ ) { @@v4@@ = fwrite ( @@ptr@@ , Number , @@n@@ , @@a1@@ ) ; if ( @@n@@ <= @@v4@@ ) { if ( @@ptr@@ != @@v9@@ ) free ( @@ptr@@ ) ; if ( @@n@@ <= Number ) { @@result@@ = @@n@@ ; } else { * __errno_location ( ) = Number ; fseterr ( @@a1@@ ) ; @@result@@ = Number ; } } else { if ( @@ptr@@ != @@v9@@ ) { @@v5@@ = * __errno_location ( ) ; free ( @@ptr@@ ) ; * __errno_location ( ) = @@v5@@ ; } @@result@@ = Number ; } } else { fseterr ( @@a1@@ ) ; @@result@@ = Number ; } return @@result@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
int __lxstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _lxstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( is_mul_ok ( @@a2@@ , * @@a1@@ ) ) { * @@a1@@ *= @@a2@@ ; @@result@@ = Number L ; } else { * @@a1@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
int tolower ( int @@c@@ ) { return tolower ( @@c@@ ) ; }
DIR * opendir ( const char * @@name@@ ) { return opendir ( @@name@@ ) ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
__int64 __fastcall freadahead ( __int64 @@a1@@ ) { __int64 @@v2@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) > * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; if ( ( * ( _DWORD * ) @@a1@@ & Number ) != Number ) @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) - * ( _QWORD * ) ( @@a1@@ + Number ) ; else @@v2@@ = Number L ; return * ( _QWORD * ) ( @@a1@@ + Number ) - * ( _QWORD * ) ( @@a1@@ + Number ) + @@v2@@ ; }
int __lxstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _lxstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
int __fxstat ( int @@ver@@ , int @@fildes@@ , struct stat * @@stat_buf@@ ) { return _fxstat ( @@ver@@ , @@fildes@@ , @@stat_buf@@ ) ; }
int getc_unlocked ( FILE * @@stream@@ ) { return getc_unlocked ( @@stream@@ ) ; }
int tolower ( int @@c@@ ) { return tolower ( @@c@@ ) ; }
int dirfd ( DIR * @@dirp@@ ) { return dirfd ( @@dirp@@ ) ; }
int __fastcall argmatch_valid ( __int64 @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { char * @@v3@@ ; __int64 @@i@@ ; void * @@s1@@ ; @@s1@@ = Number L ; @@v3@@ = gettext ( String ) ; fprintf ( stderr , @@v3@@ ) ; for ( @@i@@ = Number L ; * ( _QWORD * ) ( Number * @@i@@ + @@a1@@ ) ; ++ @@i@@ ) { if ( @@i@@ && ! memcmp ( @@s1@@ , ( const void * ) ( @@i@@ * @@a3@@ + @@a2@@ ) , @@a3@@ ) ) { fprintf ( stderr , String , * ( const char * * ) ( Number * @@i@@ + @@a1@@ ) ) ; } else { fprintf ( stderr , String , * ( const char * * ) ( Number * @@i@@ + @@a1@@ ) ) ; @@s1@@ = ( void * ) ( @@i@@ * @@a3@@ + @@a2@@ ) ; } } return putc_unlocked ( Number , stderr ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
int __fxstat ( int @@ver@@ , int @@fildes@@ , struct stat * @@stat_buf@@ ) { return _fxstat ( @@ver@@ , @@fildes@@ , @@stat_buf@@ ) ; }
__int64 __fastcall rpl_fcntl ( int @@a1@@ , int @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , __m128 @@a7@@ , __m128 @@a8@@ , __m128 @@a9@@ , __m128 @@a10@@ , __m128 @@a11@@ , __m128 @@a12@@ , __m128 @@a13@@ , __m128 @@a14@@ ) { int @@v14@@ ; int @@v15@@ ; int @@v16@@ ; int @@v18@@ ; int @@v19@@ ; int @@v20@@ ; int @@v21@@ ; __int64 @@v22@@ ; __int64 @@v23@@ ; __int64 @@v24@@ ; __int64 @@v25@@ ; __m128 @@v26@@ ; __m128 @@v27@@ ; __m128 @@v28@@ ; __m128 @@v29@@ ; __m128 @@v30@@ ; __m128 @@v31@@ ; __m128 @@v32@@ ; __m128 @@v33@@ ; @@v22@@ = @@a3@@ ; @@v23@@ = @@a4@@ ; @@v24@@ = @@a5@@ ; @@v25@@ = @@a6@@ ; @@v26@@ = @@a7@@ ; @@v27@@ = @@a8@@ ; @@v28@@ = @@a9@@ ; @@v29@@ = @@a10@@ ; @@v30@@ = @@a11@@ ; @@v31@@ = @@a12@@ ; @@v32@@ = @@a13@@ ; @@v33@@ = @@a14@@ ; if ( @@a2@@ != Number ) return ( unsigned int ) fcntl ( @@a1@@ , @@a2@@ , @@v22@@ ) ; @@v19@@ = @@v22@@ ; if ( have_dupfd_cloexec_2895 < Number ) { @@v18@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v22@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; } else { @@v18@@ = fcntl ( @@a1@@ , Number , ( unsigned int ) @@v22@@ ) ; if ( @@v18@@ < Number && * __errno_location ( ) == Number ) { @@v18@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v19@@ , @@v14@@ , @@v15@@ , @@v16@@ ) ; if ( @@v18@@ < Number ) return ( unsigned int ) @@v18@@ ; have_dupfd_cloexec_2895 = Number ; } else { have_dupfd_cloexec_2895 = Number ; } } if ( @@v18@@ >= Number && have_dupfd_cloexec_2895 == Number ) { @@v20@@ = fcntl ( @@v18@@ , Number ) ; if ( @@v20@@ < Number || fcntl ( @@v18@@ , Number , @@v20@@ | Number ) == Number ) { @@v21@@ = * __errno_location ( ) ; close ( @@v18@@ ) ; * __errno_location ( ) = @@v21@@ ; @@v18@@ = Number ; } } return ( unsigned int ) @@v18@@ ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
int putchar_unlocked ( int @@c@@ ) { return putchar_unlocked ( @@c@@ ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
int __fastcall out_int ( const char * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { strcpy ( ( char * ) & @@a1@@ [ @@a2@@ ] , String ) ; return printf ( @@a1@@ , @@a3@@ ) ; }
void * __fastcall human_time ( time_t @@a1@@ , __int64 @@a2@@ ) { time_t @@timer@@ ; __int64 @@v4@@ ; struct tm * @@v5@@ ; @@timer@@ = @@a1@@ ; @@v4@@ = @@a2@@ ; @@v5@@ = localtime ( & @@timer@@ ) ; if ( ! @@v5@@ ) return ( void * ) timetostr ( @@timer@@ , ( __int64 ) & str_5922 ) ; nstrftime ( & str_5922 , Number L , String , @@v5@@ , Number L , ( unsigned int ) @@v4@@ ) ; return & str_5922 ; }
__int64 __fastcall parse_group ( const char * @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; unsigned int @@v4@@ ; unsigned __int64 @@v5@@ ; struct group * @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v4@@ = Number ; if ( * @@a1@@ ) { @@v6@@ = getgrnam ( @@a1@@ ) ; if ( @@v6@@ ) { @@v4@@ = @@v6@@ -> gr_gid ; } else { if ( ( unsigned int ) xstrtoul ( @@a1@@ , Number L , Number L , & @@v5@@ , & locale ) || @@v5@@ > Number ) { @@v1@@ = quote ( @@a1@@ ) ; @@v2@@ = gettext ( String ) ; error ( Number , Number , @@v2@@ , @@v1@@ ) ; } @@v4@@ = @@v5@@ ; } endgrent ( ) ; } return @@v4@@ ; }
int __fastcall out_uint_x ( const char * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { strcpy ( ( char * ) & @@a1@@ [ @@a2@@ ] , String ) ; return printf ( @@a1@@ , @@a3@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 __fastcall first_last_page ( unsigned int @@a1@@ , char @@a2@@ , _BYTE * @@a3@@ ) { unsigned int @@v5@@ ; unsigned int @@v6@@ ; _BYTE * @@v7@@ ; unsigned __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; _BYTE * @@v10@@ ; unsigned __int64 @@v11@@ ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number ; @@v5@@ = xstrtoumax ( @@a3@@ , & @@v7@@ , Number L , & @@v8@@ , & locale ) ; if ( @@v5@@ && @@v5@@ != Number ) xstrtol_fatal ( @@v5@@ , @@a1@@ , ( unsigned int ) @@a2@@ , & long_options , @@a3@@ ) ; if ( @@a3@@ == @@v7@@ || ! @@v8@@ ) return Number L ; if ( * @@v7@@ == Number ) { @@v10@@ = @@v7@@ + Number ; @@v6@@ = xstrtoumax ( @@v7@@ + Number , & @@v7@@ , Number L , & @@v9@@ , & locale ) ; if ( @@v6@@ ) xstrtol_fatal ( @@v6@@ , @@a1@@ , ( unsigned int ) @@a2@@ , & long_options , @@a3@@ ) ; if ( @@v10@@ == @@v7@@ || @@v9@@ < @@v8@@ ) return Number L ; } if ( * @@v7@@ ) return Number L ; first_page_number = @@v8@@ ; last_page_number = @@v9@@ ; return Number L ; }
__int64 __fastcall do_stat ( char * @@a1@@ , char @@a2@@ , const char * @@a3@@ ) { char * @@v3@@ ; int * @@v4@@ ; bool @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; int * @@v9@@ ; struct stat @@v11@@ ; unsigned __int64 @@v12@@ ; @@v12@@ = __readfsqword ( Number ) ; if ( ! strcmp ( @@a1@@ , String ) ) { if ( ( unsigned int ) fstat ( Number , & @@v11@@ ) ) { @@v3@@ = gettext ( String ) ; @@v4@@ = __errno_location ( ) ; error ( Number , * @@v4@@ , @@v3@@ ) ; return Number L ; } } else { if ( follow_links ) @@v6@@ = ( unsigned int ) stat ( @@a1@@ , & @@v11@@ ) != Number ; else @@v6@@ = ( unsigned int ) lstat ( @@a1@@ , & @@v11@@ ) != Number ; if ( @@v6@@ ) { @@v7@@ = quote ( @@a1@@ ) ; @@v8@@ = gettext ( String ) ; @@v9@@ = __errno_location ( ) ; error ( Number , * @@v9@@ , @@v8@@ , @@v7@@ ) ; return Number L ; } } if ( @@a3@@ ) goto LABEL_16 ; if ( ! @@a2@@ ) { if ( ( @@v11@@ . st_mode & Number ) == Number || ( @@v11@@ . st_mode & Number ) == Number ) { print_it ( String String String String String String String , ( __int64 ) @@a1@@ , ( void ( __fastcall * ) ( void * , size_t , _QWORD , __int64 , __int64 ) ) print_stat , ( __int64 ) & @@v11@@ ) ; return Number L ; } @@a3@@ = String String String String String String String ; LABEL_16 : print_it ( @@a3@@ , ( __int64 ) @@a1@@ , ( void ( __fastcall * ) ( void * , size_t , _QWORD , __int64 , __int64 ) ) print_stat , ( __int64 ) & @@v11@@ ) ; return Number L ; } print_it ( String , ( __int64 ) @@a1@@ , ( void ( __fastcall * ) ( void * , size_t , _QWORD , __int64 , __int64 ) ) print_stat , ( __int64 ) & @@v11@@ ) ; return Number L ; }
int __fastcall print_esc_char ( char @@a1@@ ) { char * @@v1@@ ; char @@v3@@ ; @@v3@@ = @@a1@@ ; switch ( @@a1@@ ) { case String : case String : return putchar_unlocked ( @@v3@@ ) ; case String : @@v3@@ = Number ; break ; case String : @@v3@@ = Number ; break ; case String : @@v3@@ = Number ; break ; case String : @@v3@@ = Number ; break ; case String : @@v3@@ = Number ; break ; case String : @@v3@@ = Number ; break ; case String : @@v3@@ = Number ; break ; case String : @@v3@@ = Number ; break ; default : @@v1@@ = gettext ( String ) ; error ( Number , Number , @@v1@@ , ( unsigned int ) @@a1@@ ) ; break ; } return putchar_unlocked ( @@v3@@ ) ; }
__int64 __fastcall restricted_chown ( int @@a1@@ , const char * @@a2@@ , __int64 @@a3@@ , __uid_t @@a4@@ , __gid_t @@a5@@ , int @@a6@@ , int @@a7@@ ) { __int64 @@result@@ ; unsigned int @@v12@@ ; int @@oflag@@ ; int @@fildes@@ ; int @@v15@@ ; struct stat @@v16@@ ; unsigned __int64 @@v17@@ ; @@v17@@ = __readfsqword ( Number ) ; @@v12@@ = Number ; @@oflag@@ = Number ; if ( @@a6@@ == Number && @@a7@@ == Number ) return Number L ; if ( ( * ( _DWORD * ) ( @@a3@@ + Number ) & Number ) != Number ) { if ( ( * ( _DWORD * ) ( @@a3@@ + Number ) & Number ) != Number ) return Number L ; @@oflag@@ = Number ; } @@fildes@@ = openat ( @@a1@@ , @@a2@@ , @@oflag@@ ) ; if ( @@fildes@@ < Number ) { if ( * __errno_location ( ) != Number || ( * ( _DWORD * ) ( @@a3@@ + Number ) & Number ) != Number || ( @@fildes@@ = openat ( @@a1@@ , @@a2@@ , @@oflag@@ | Number ) , @@fildes@@ < Number ) ) { if ( * __errno_location ( ) == Number ) @@result@@ = Number L ; else @@result@@ = Number L ; return @@result@@ ; } } if ( ( unsigned int ) fstat ( @@fildes@@ , & @@v16@@ ) ) { @@v12@@ = Number ; LABEL_30 : @@v15@@ = * __errno_location ( ) ; close ( @@fildes@@ ) ; * __errno_location ( ) = @@v15@@ ; return @@v12@@ ; } if ( * ( _QWORD * ) ( @@a3@@ + Number ) != @@v16@@ . st_ino || * ( _QWORD * ) @@a3@@ != @@v16@@ . st_dev ) { @@v12@@ = Number ; goto LABEL_30 ; } if ( @@a6@@ != Number && @@a6@@ != @@v16@@ . st_uid || @@a7@@ != Number && @@a7@@ != @@v16@@ . st_gid ) { goto LABEL_30 ; } if ( fchown ( @@fildes@@ , @@a4@@ , @@a5@@ ) ) { @@v12@@ = Number ; goto LABEL_30 ; } if ( close ( @@fildes@@ ) ) LODWORD ( @@result@@ ) = Number ; else LODWORD ( @@result@@ ) = Number ; return ( unsigned int ) @@result@@ ; }
unsigned __int64 __fastcall parse_column_count ( __int64 @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; @@v5@@ = __readfsqword ( Number ) ; if ( ( unsigned int ) xstrtol ( @@a1@@ , Number L , Number L , & @@v4@@ , & locale ) || @@v4@@ <= Number || @@v4@@ > Number ) { @@v1@@ = quote ( @@a1@@ ) ; @@v2@@ = gettext ( String ) ; error ( Number , Number , @@v2@@ , @@v1@@ ) ; } columns = @@v4@@ ; explicit_columns = Number ; return __readfsqword ( Number ) ^ @@v5@@ ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
__int64 __fastcall init_fps ( int @@a1@@ , _QWORD * @@a2@@ ) { unsigned int @@v4@@ ; _QWORD * @@v5@@ ; int @@v6@@ ; int @@v7@@ ; char * @@i@@ ; _QWORD * @@v9@@ ; char * @@v10@@ ; __int64 @@v11@@ ; FILE * @@v12@@ ; @@v5@@ = @@a2@@ ; total_files = Number ; free ( column_vector ) ; column_vector = ( void * ) xnmalloc ( columns , Number L ) ; if ( parallel_files ) { @@v7@@ = @@a1@@ ; for ( @@i@@ = ( char * ) column_vector ; @@v7@@ -- ; @@i@@ += Number ) { if ( ( unsigned __int8 ) open_file ( * @@v5@@ , @@i@@ ) != Number ) { @@i@@ -= Number ; -- columns ; } ++ @@v5@@ ; } if ( ! columns ) return Number L ; init_header ( & locale , Number ) ; } else { @@v9@@ = column_vector ; if ( @@a1@@ <= Number ) { @@v9@@ [ Number ] = gettext ( String ) ; * @@v9@@ = stdin ; have_read_stdin = Number ; * ( ( _DWORD * ) @@v9@@ + Number ) = Number ; * ( ( _BYTE * ) @@v9@@ + Number ) = Number ; ++ total_files ; init_header ( & locale , Number ) ; * ( ( _DWORD * ) @@v9@@ + Number ) = Number ; } else { if ( ( unsigned __int8 ) open_file ( * @@a2@@ , column_vector ) != Number ) return Number L ; @@v4@@ = fileno ( ( FILE * ) * @@v9@@ ) ; init_header ( * @@a2@@ , @@v4@@ ) ; * ( ( _DWORD * ) @@v9@@ + Number ) = Number ; } @@v11@@ = @@v9@@ [ Number ] ; @@v12@@ = ( FILE * ) * @@v9@@ ; @@v6@@ = columns - Number ; @@v10@@ = ( char * ) ( @@v9@@ + Number ) ; while ( @@v6@@ ) { * ( ( _QWORD * ) @@v10@@ + Number ) = @@v11@@ ; * ( _QWORD * ) @@v10@@ = @@v12@@ ; * ( ( _DWORD * ) @@v10@@ + Number ) = Number ; @@v10@@ [ Number ] = Number ; * ( ( _DWORD * ) @@v10@@ + Number ) = Number ; -- @@v6@@ ; @@v10@@ += Number ; } } files_ready_to_read = total_files ; return Number L ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; char * @@v3@@ ; FILE * @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; FILE * @@v10@@ ; char * @@v11@@ ; FILE * @@v12@@ ; char * @@v13@@ ; FILE * @@v14@@ ; char * @@v15@@ ; FILE * @@v16@@ ; char * @@v17@@ ; FILE * @@v18@@ ; char * @@v19@@ ; FILE * @@v20@@ ; char * @@v21@@ ; FILE * @@v22@@ ; char * @@v23@@ ; char * @@v24@@ ; @@v1@@ = program_name ; if ( @@a1@@ ) { @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = gettext ( String ) ; printf ( @@v3@@ , @@v1@@ ) ; @@v4@@ = stdout ; @@v5@@ = gettext ( String String String String ) ; fputs_unlocked ( @@v5@@ , @@v4@@ ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String String String String String String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; @@v8@@ = stdout ; @@v9@@ = gettext ( String ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = stdout ; @@v11@@ = gettext ( String ) ; fputs_unlocked ( @@v11@@ , @@v10@@ ) ; @@v12@@ = stdout ; @@v13@@ = gettext ( String String String String String String String String ) ; fputs_unlocked ( @@v13@@ , @@v12@@ ) ; @@v14@@ = stdout ; @@v15@@ = gettext ( String String String String String String ) ; fputs_unlocked ( @@v15@@ , @@v14@@ ) ; @@v16@@ = stdout ; @@v17@@ = gettext ( String String String String String String String String ) ; fputs_unlocked ( @@v17@@ , @@v16@@ ) ; @@v18@@ = stdout ; @@v19@@ = gettext ( String String String String String String String String String ) ; fputs_unlocked ( @@v19@@ , @@v18@@ ) ; @@v20@@ = stdout ; @@v21@@ = gettext ( String String String String String String String String ) ; fputs_unlocked ( @@v21@@ , @@v20@@ ) ; @@v22@@ = stdout ; @@v23@@ = gettext ( String String String String String String String ) ; fputs_unlocked ( @@v23@@ , @@v22@@ ) ; @@v24@@ = gettext ( String String String String ) ; printf ( @@v24@@ , String ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
__int64 __fastcall setup_dir ( __int64 @@a1@@ ) { if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { * ( _QWORD * ) ( @@a1@@ + Number ) = hash_initialize ( Number L , Number L , AD_hash , AD_compare , & free ) ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; } else { * ( _QWORD * ) ( @@a1@@ + Number ) = malloc ( Number ) ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; cycle_check_init ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ; } return Number L ; }
__int64 __fastcall open_file ( const char * @@a1@@ , __int64 @@a2@@ ) { int * @@v2@@ ; __int64 @@result@@ ; if ( ! strcmp ( @@a1@@ , String ) ) { * ( _QWORD * ) ( @@a2@@ + Number ) = gettext ( String ) ; * ( _QWORD * ) @@a2@@ = stdin ; have_read_stdin = Number ; } else { * ( _QWORD * ) ( @@a2@@ + Number ) = @@a1@@ ; * ( _QWORD * ) @@a2@@ = fopen_safer ( @@a1@@ , String ) ; } if ( * ( _QWORD * ) @@a2@@ ) { * ( _DWORD * ) ( @@a2@@ + Number ) = Number ; * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; ++ total_files ; @@result@@ = Number L ; } else { failed_opens = Number ; if ( ignore_failed_opens != Number ) { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@a1@@ ) ; } @@result@@ = Number L ; } return @@result@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
__int64 __fastcall print_files ( int @@a1@@ , _QWORD * @@a2@@ ) { __int64 @@result@@ ; init_parameters ( @@a1@@ ) ; @@result@@ = ( unsigned int ) init_fps ( @@a1@@ , @@a2@@ ) ^ Number ; if ( ! ( _BYTE ) @@result@@ ) { if ( storing_columns ) init_store_cols ( ) ; if ( ( unsigned __int64 ) first_page_number <= Number ) { page_number = Number L ; } else { @@result@@ = ( unsigned int ) skip_to_page ( first_page_number ) ^ Number ; if ( ( _BYTE ) @@result@@ ) return @@result@@ ; page_number = first_page_number ; } init_funcs ( ) ; line_number = line_count ; do @@result@@ = print_page ( ) ; while ( ( _BYTE ) @@result@@ ) ; } return @@result@@ ; }
__int64 __fastcall ftypelet ( __int16 @@a1@@ ) { switch ( @@a1@@ & Number ) { case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; } return Number L ; }
__int64 __fastcall opendirat ( int @@a1@@ , int @@a2@@ , __int64 a3 , __int64 a4 , int @@a5@@ , int @@a6@@ ) { int @@fd@@ ; _BYTE @@v8@@ [ Number ] ; @@fd@@ = openat_safer ( @@a1@@ , @@a2@@ , Number , @@a2@@ , @@a5@@ , @@a6@@ , @@a2@@ ) ; if ( @@fd@@ < Number ) return Number L ; set_cloexec_flag ( ( unsigned int ) @@fd@@ , Number L ) ; * ( _QWORD * ) & @@v8@@ [ Number ] = fdopendir ( @@fd@@ ) ; if ( ! * ( _QWORD * ) & @@v8@@ [ Number ] ) { * ( _QWORD * ) @@v8@@ = ( unsigned int ) * __errno_location ( ) ; close ( @@fd@@ ) ; * __errno_location ( ) = * ( _DWORD * ) @@v8@@ ; } return * ( _QWORD * ) & @@v8@@ [ Number ] ; }
__int64 __fastcall hold_file ( __int64 @@a1@@ ) { int @@i@@ ; _DWORD * @@v3@@ ; if ( parallel_files != Number ) { @@v3@@ = column_vector ; for ( @@i@@ = columns ; @@i@@ ; -- @@i@@ ) { if ( storing_columns ) @@v3@@ [ Number ] = Number ; else @@v3@@ [ Number ] = Number ; @@v3@@ += Number ; } } else { * ( _DWORD * ) ( @@a1@@ + Number ) = Number ; } * ( _DWORD * ) ( @@a1@@ + Number ) = Number ; return ( unsigned int ) -- files_ready_to_read ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
__int64 __fastcall imaxtostr ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = @@a1@@ ; @@v4@@ = @@a2@@ + Number ; * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; if ( @@a1@@ >= Number ) { do { * ( _BYTE * ) -- @@v4@@ = ( char ) @@v3@@ % Number + Number ; @@v3@@ /= Number L ; } while ( @@v3@@ ) ; } else { do { * ( _BYTE * ) -- @@v4@@ = Number - ( char ) @@v3@@ % Number ; @@v3@@ /= Number L ; } while ( @@v3@@ ) ; * ( _BYTE * ) -- @@v4@@ = Number ; } return @@v4@@ ; }
__int64 store_columns ( ) { unsigned int @@v0@@ ; __int64 @@result@@ ; int @@v2@@ ; int @@v3@@ ; int @@i@@ ; unsigned int @@v5@@ ; int @@v6@@ ; int @@v7@@ ; _DWORD * @@v8@@ ; _DWORD * @@v9@@ ; @@v5@@ = Number ; buff_current = Number ; @@v6@@ = Number ; if ( balance_columns ) @@v7@@ = columns ; else @@v7@@ = columns - Number ; @@v2@@ = Number ; @@v8@@ = column_vector ; while ( @@v2@@ <= @@v7@@ ) { @@v8@@ [ Number ] = Number ; ++ @@v2@@ ; @@v8@@ += Number ; } @@v3@@ = Number ; @@v9@@ = column_vector ; while ( @@v3@@ <= @@v7@@ && files_ready_to_read ) { @@v9@@ [ Number ] = @@v5@@ ; for ( @@i@@ = lines_per_body ; @@i@@ && files_ready_to_read ; -- @@i@@ ) { if ( ! @@v9@@ [ Number ] ) { input_position = Number ; if ( ( unsigned __int8 ) read_line ( @@v9@@ ) != Number ) read_rest_of_line ( @@v9@@ ) ; if ( ! @@v9@@ [ Number ] || @@v6@@ != buff_current ) { ++ @@v9@@ [ Number ] ; * ( ( _DWORD * ) line_vector + @@v5@@ ) = @@v6@@ ; @@v0@@ = @@v5@@ ++ ; * ( ( _DWORD * ) end_vector + @@v0@@ ) = input_position ; @@v6@@ = buff_current ; } } } ++ @@v3@@ ; @@v9@@ += Number ; } * ( ( _DWORD * ) line_vector + @@v5@@ ) = @@v6@@ ; @@result@@ = ( unsigned __int8 ) balance_columns ; if ( balance_columns ) @@result@@ = balance ( @@v5@@ ) ; return @@result@@ ; }
unsigned __int64 __fastcall init_header ( const char * @@a1@@ , int @@a2@@ ) { __int64 @@v2@@ ; const char * @@v3@@ ; int @@v4@@ ; int @@v5@@ ; unsigned int @@v8@@ ; char * @@s@@ ; struct tm * @@v10@@ ; __int64 @@v11@@ ; time_t @@timer@@ ; __int64 @@v13@@ ; struct stat @@stat_buf@@ ; unsigned __int64 @@v15@@ ; @@v15@@ = __readfsqword ( Number ) ; if ( ! strcmp ( @@a1@@ , String ) ) @@a2@@ = Number ; if ( @@a2@@ < Number || ( unsigned int ) fstat ( @@a2@@ , & @@stat_buf@@ ) ) { if ( ! timespec_5887 ) gettime ( & timespec_5887 ) ; @@timer@@ = timespec_5887 ; @@v13@@ = qword_2101E8 ; } else { @@timer@@ = get_stat_mtime ( ( __int64 ) & @@stat_buf@@ ) ; @@v13@@ = @@v2@@ ; } @@v8@@ = @@v13@@ ; @@v10@@ = localtime ( & @@timer@@ ) ; if ( @@v10@@ ) { @@v11@@ = nstrftime ( Number L , Number , date_format , @@v10@@ , Number L , @@v8@@ ) + Number ; @@s@@ = ( char * ) xmalloc ( @@v11@@ ) ; nstrftime ( @@s@@ , @@v11@@ , date_format , @@v10@@ , Number L , @@v8@@ ) ; } else { @@s@@ = ( char * ) xmalloc ( Number L ) ; sprintf ( @@s@@ , String , @@timer@@ , @@v8@@ ) ; } free ( date_text ) ; date_text = @@s@@ ; if ( custom_header ) { @@v3@@ = ( const char * ) custom_header ; } else if ( @@a2@@ < Number ) { @@v3@@ = & locale ; } else { @@v3@@ = @@a1@@ ; } file_text = ( __int64 ) @@v3@@ ; @@v4@@ = chars_per_line ; @@v5@@ = @@v4@@ - gnu_mbswidth ( date_text , Number L ) ; header_width_available = @@v5@@ - gnu_mbswidth ( file_text , Number L ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
__int64 __fastcall fts_close ( __int64 @@a1@@ ) { _QWORD * @@v1@@ ; void * @@v2@@ ; _QWORD * @@v3@@ ; int @@v5@@ ; @@v5@@ = Number ; if ( * ( _QWORD * ) @@a1@@ ) { @@v1@@ = * ( _QWORD * * ) @@a1@@ ; while ( ( __int64 ) @@v1@@ [ Number ] >= Number ) { @@v2@@ = @@v1@@ ; if ( @@v1@@ [ Number ] ) @@v3@@ = ( _QWORD * ) @@v1@@ [ Number ] ; else @@v3@@ = ( _QWORD * ) @@v1@@ [ Number ] ; @@v1@@ = @@v3@@ ; free ( @@v2@@ ) ; } free ( @@v1@@ ) ; } if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) fts_lfree ( * ( void * * ) ( @@a1@@ + Number ) ) ; free ( * ( void * * ) ( @@a1@@ + Number ) ) ; free ( * ( void * * ) ( @@a1@@ + Number ) ) ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { if ( * ( int * ) ( @@a1@@ + Number ) >= Number && close ( * ( _DWORD * ) ( @@a1@@ + Number ) ) ) { LABEL_20 : @@v5@@ = * __errno_location ( ) ; goto LABEL_21 ; } } else if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) == Number ) { if ( fchdir ( * ( _DWORD * ) ( @@a1@@ + Number ) ) ) @@v5@@ = * __errno_location ( ) ; if ( close ( * ( _DWORD * ) ( @@a1@@ + Number ) ) && ! @@v5@@ ) goto LABEL_20 ; } LABEL_21 : fd_ring_clear ( @@a1@@ + Number ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) hash_free ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ; free_dir ( @@a1@@ ) ; free ( ( void * ) @@a1@@ ) ; if ( ! @@v5@@ ) return Number L ; * __errno_location ( ) = @@v5@@ ; return Number ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
__int64 __fastcall print_clump ( __int64 @@a1@@ , unsigned int @@a2@@ , char * @@a3@@ ) { char * @@v3@@ ; __int64 @@result@@ ; while ( Number ) { @@result@@ = @@a2@@ -- ; if ( ! ( _DWORD ) @@result@@ ) break ; @@v3@@ = @@a3@@ ++ ; ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@a1@@ + Number ) ) ( ( unsigned int ) * @@v3@@ ) ; } return @@result@@ ; }
__int64 __fastcall skip_read ( __int64 @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; unsigned __int8 @@v3@@ ; int @@c@@ ; int @@ca@@ ; int @@i@@ ; char * @@v7@@ ; FILE * @@stream@@ ; @@stream@@ = * ( FILE * * ) @@a1@@ ; @@v3@@ = Number ; @@c@@ = getc_unlocked ( * ( FILE * * ) @@a1@@ ) ; if ( @@c@@ == Number ) { if ( * ( _BYTE * ) ( @@a1@@ + Number ) ) { @@c@@ = getc_unlocked ( @@stream@@ ) ; if ( @@c@@ == Number ) @@c@@ = getc_unlocked ( @@stream@@ ) ; } } * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; if ( @@c@@ == Number ) @@v3@@ = Number ; if ( last_line ) * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; while ( @@c@@ != Number ) { if ( @@c@@ == Number ) { if ( last_line ) { if ( parallel_files != Number ) { @@v7@@ = ( char * ) column_vector ; for ( @@i@@ = columns ; @@i@@ ; -- @@i@@ ) { @@v7@@ [ Number ] = Number ; @@v7@@ += Number ; } } else { * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; } } @@ca@@ = getc_unlocked ( @@stream@@ ) ; if ( @@ca@@ != Number ) ungetc ( @@ca@@ , @@stream@@ ) ; hold_file ( @@a1@@ ) ; break ; } if ( @@c@@ == Number ) { close_file ( @@a1@@ ) ; break ; } @@c@@ = getc_unlocked ( @@stream@@ ) ; } @@result@@ = ( unsigned __int8 ) skip_count ; if ( skip_count ) { @@result@@ = ( unsigned __int8 ) parallel_files ^ Number ; if ( parallel_files != Number || @@a2@@ == Number ) { @@result@@ = @@v3@@ ^ Number ; if ( @@v3@@ != Number ) @@result@@ = ( unsigned int ) ++ line_count ; } } return @@result@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
__int64 __fastcall fts_padjust ( __int64 @@a1@@ , _QWORD * @@a2@@ ) { _QWORD * @@v2@@ ; __int64 @@result@@ ; _QWORD * @@i@@ ; __int64 @@v6@@ ; @@v6@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; for ( @@i@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; @@i@@ ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { if ( ( _QWORD * ) @@i@@ [ Number ] != @@i@@ + Number ) @@i@@ [ Number ] = @@v6@@ + @@i@@ [ Number ] - @@i@@ [ Number ] ; @@i@@ [ Number ] = @@v6@@ ; } while ( Number ) { @@result@@ = @@a2@@ [ Number ] ; if ( @@result@@ < Number ) break ; if ( ( _QWORD * ) @@a2@@ [ Number ] != @@a2@@ + Number ) @@a2@@ [ Number ] = @@v6@@ + @@a2@@ [ Number ] - @@a2@@ [ Number ] ; @@a2@@ [ Number ] = @@v6@@ ; if ( @@a2@@ [ Number ] ) @@v2@@ = ( _QWORD * ) @@a2@@ [ Number ] ; else @@v2@@ = ( _QWORD * ) @@a2@@ [ Number ] ; @@a2@@ = @@v2@@ ; } return @@result@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
unsigned __int64 print_header ( ) { char * @@v0@@ ; __int64 @@v1@@ ; char * @@v2@@ ; int @@v3@@ ; int @@v5@@ ; char @@s@@ [ Number ] ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; output_position = Number ; pad_across_to ( chars_per_margin ) ; print_white_space ( ) ; if ( ! page_number ) { @@v0@@ = gettext ( String ) ; error ( Number , Number , @@v0@@ ) ; } @@v1@@ = page_number ++ ; @@v2@@ = gettext ( String ) ; sprintf ( @@s@@ , @@v2@@ , @@v1@@ ) ; LODWORD ( @@v1@@ ) = header_width_available ; @@v5@@ = @@v1@@ - gnu_mbswidth ( @@s@@ , Number L ) ; @@v3@@ = Number ; if ( @@v5@@ >= Number ) @@v3@@ = @@v5@@ ; printf ( String , chars_per_margin , & locale , ( const char * ) date_text , @@v3@@ >> Number , String , ( const char * ) file_text , @@v3@@ - ( @@v3@@ >> Number ) , String , @@s@@ ) ; print_a_header = Number ; output_position = Number ; return __readfsqword ( Number ) ^ @@v7@@ ; }
__int64 __fastcall hash_get_n_buckets_used ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; char * @@v3@@ ; FILE * @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; FILE * @@v10@@ ; char * @@v11@@ ; FILE * @@v12@@ ; char * @@v13@@ ; FILE * @@v14@@ ; char * @@v15@@ ; FILE * @@v16@@ ; char * @@v17@@ ; FILE * @@v18@@ ; char * @@v19@@ ; FILE * @@v20@@ ; char * @@v21@@ ; FILE * @@v22@@ ; char * @@v23@@ ; FILE * @@v24@@ ; char * @@v25@@ ; FILE * @@v26@@ ; char * @@v27@@ ; FILE * @@v28@@ ; char * @@v29@@ ; FILE * @@v30@@ ; char * @@v31@@ ; FILE * @@v32@@ ; char * @@v33@@ ; FILE * @@v34@@ ; char * @@v35@@ ; @@v1@@ = program_name ; if ( @@a1@@ ) { @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = gettext ( String ) ; printf ( @@v3@@ , @@v1@@ ) ; @@v4@@ = stdout ; @@v5@@ = gettext ( String ) ; fputs_unlocked ( @@v5@@ , @@v4@@ ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; @@v8@@ = stdout ; @@v9@@ = gettext ( String String String String String String ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = stdout ; @@v11@@ = gettext ( String String String String String String ) ; fputs_unlocked ( @@v11@@ , @@v10@@ ) ; @@v12@@ = stdout ; @@v13@@ = gettext ( String String String String String String String String ) ; fputs_unlocked ( @@v13@@ , @@v12@@ ) ; @@v14@@ = stdout ; @@v15@@ = gettext ( String String String String String String String ) ; fputs_unlocked ( @@v15@@ , @@v14@@ ) ; @@v16@@ = stdout ; @@v17@@ = gettext ( String String String String String ) ; fputs_unlocked ( @@v17@@ , @@v16@@ ) ; @@v18@@ = stdout ; @@v19@@ = gettext ( String String String String String String ) ; fputs_unlocked ( @@v19@@ , @@v18@@ ) ; @@v20@@ = stdout ; @@v21@@ = gettext ( String String String String String ) ; fputs_unlocked ( @@v21@@ , @@v20@@ ) ; @@v22@@ = stdout ; @@v23@@ = gettext ( String String String String String ) ; fputs_unlocked ( @@v23@@ , @@v22@@ ) ; @@v24@@ = stdout ; @@v25@@ = gettext ( String String String String String ) ; fputs_unlocked ( @@v25@@ , @@v24@@ ) ; @@v26@@ = stdout ; @@v27@@ = gettext ( String String String String String String String String ) ; fputs_unlocked ( @@v27@@ , @@v26@@ ) ; @@v28@@ = stdout ; @@v29@@ = gettext ( String String String String ) ; fputs_unlocked ( @@v29@@ , @@v28@@ ) ; @@v30@@ = stdout ; @@v31@@ = gettext ( String ) ; fputs_unlocked ( @@v31@@ , @@v30@@ ) ; @@v32@@ = stdout ; @@v33@@ = gettext ( String ) ; fputs_unlocked ( @@v33@@ , @@v32@@ ) ; @@v34@@ = stdout ; @@v35@@ = gettext ( String String String ) ; fputs_unlocked ( @@v35@@ , @@v34@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_20D168 ; @@v4@@ [ Number ] = qword_20D170 ; @@v4@@ [ Number ] = qword_20D178 ; @@v4@@ [ Number ] = qword_20D180 ; @@v4@@ [ Number ] = qword_20D188 ; @@v4@@ [ Number ] = qword_20D190 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ ) { return xmalloc ( @@a1@@ ) ; }
unsigned __int64 __fastcall hash_get_max_bucket_length ( __int64 @@a1@@ ) { _QWORD * @@i@@ ; unsigned __int64 @@v3@@ ; _QWORD * @@v4@@ ; unsigned __int64 @@j@@ ; @@v3@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { @@v4@@ = @@i@@ ; for ( @@j@@ = Number L ; ; ++ @@j@@ ) { @@v4@@ = ( _QWORD * ) @@v4@@ [ Number ] ; if ( ! @@v4@@ ) break ; } if ( @@j@@ > @@v3@@ ) @@v3@@ = @@j@@ ; } } return @@v3@@ ; }
__int64 __fastcall mbsnwidth ( char * @@a1@@ , __int64 @@a2@@ , char @@a3@@ ) { int @@v3@@ ; char * @@v5@@ ; unsigned __int8 @@v7@@ ; wchar_t @@pwc@@ ; unsigned int @@v9@@ ; int @@v10@@ ; char * @@v11@@ ; size_t @@v12@@ ; char * @@v13@@ ; mbstate_t @@s@@ [ Number ] ; @@s@@ [ Number ] = ( mbstate_t ) __readfsqword ( Number ) ; @@v11@@ = @@a1@@ ; @@v13@@ = & @@a1@@ [ @@a2@@ ] ; @@v9@@ = Number ; if ( __ctype_get_mb_cur_max ( ) > Number ) { while ( Number ) { LABEL_28 : if ( @@v11@@ >= @@v13@@ ) return @@v9@@ ; @@v3@@ = * @@v11@@ ; if ( @@v3@@ > Number ) { if ( @@v3@@ < Number || @@v3@@ > Number && ( unsigned int ) ( @@v3@@ - Number ) > Number ) { LABEL_11 : memset ( @@s@@ , Number , Number ) ; while ( Number ) { @@v12@@ = mbrtowc ( & @@pwc@@ , @@v11@@ , @@v13@@ - @@v11@@ , @@s@@ ) ; if ( @@v12@@ == Number ) { if ( ( @@a3@@ & Number ) == Number ) { ++ @@v11@@ ; ++ @@v9@@ ; goto LABEL_28 ; } return Number ; } if ( @@v12@@ == Number ) break ; if ( ! @@v12@@ ) @@v12@@ = Number L ; @@v10@@ = wcwidth ( @@pwc@@ ) ; if ( @@v10@@ < Number ) { if ( ( @@a3@@ & Number ) != Number ) return Number ; @@v9@@ += iswcntrl ( @@pwc@@ ) == Number ; } else { @@v9@@ += @@v10@@ ; } @@v11@@ += @@v12@@ ; if ( mbsinit ( @@s@@ ) ) goto LABEL_28 ; } if ( ( @@a3@@ & Number ) == Number ) { @@v11@@ = @@v13@@ ; ++ @@v9@@ ; continue ; } return Number ; } } else if ( @@v3@@ < Number && ( unsigned int ) ( @@v3@@ - Number ) > Number ) { goto LABEL_11 ; } ++ @@v11@@ ; ++ @@v9@@ ; } } while ( @@v11@@ < @@v13@@ ) { @@v5@@ = @@v11@@ ++ ; @@v7@@ = * @@v5@@ ; if ( ( ( * __ctype_b_loc ( ) ) [ @@v7@@ ] & Number ) != Number ) { ++ @@v9@@ ; } else { if ( ( @@a3@@ & Number ) != Number ) return Number ; @@v9@@ += ( ( * __ctype_b_loc ( ) ) [ @@v7@@ ] & Number ) == Number ; } } return @@v9@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
int __fastcall hash_print_statistics ( __int64 @@a1@@ , FILE * @@a2@@ ) { double @@v2@@ ; double @@v3@@ ; double @@v4@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v6@@ = hash_get_n_entries ( @@a1@@ ) ; @@v7@@ = hash_get_n_buckets ( @@a1@@ ) ; @@v8@@ = hash_get_n_buckets_used ( @@a1@@ ) ; @@v9@@ = hash_get_max_bucket_length ( @@a1@@ ) ; fprintf ( @@a2@@ , String , @@v6@@ ) ; fprintf ( @@a2@@ , String , @@v7@@ ) ; if ( @@v8@@ < Number ) @@v2@@ = ( double ) ( int ) ( @@v8@@ & Number | ( ( unsigned __int64 ) @@v8@@ >> Number ) ) + ( double ) ( int ) ( @@v8@@ & Number | ( ( unsigned __int64 ) @@v8@@ >> Number ) ) ; else @@v2@@ = ( double ) ( int ) @@v8@@ ; @@v3@@ = Number * @@v2@@ ; if ( @@v7@@ < Number ) @@v4@@ = ( double ) ( int ) ( @@v7@@ & Number | ( ( unsigned __int64 ) @@v7@@ >> Number ) ) + ( double ) ( int ) ( @@v7@@ & Number | ( ( unsigned __int64 ) @@v7@@ >> Number ) ) ; else @@v4@@ = ( double ) ( int ) @@v7@@ ; fprintf ( @@a2@@ , String , @@v8@@ , @@v3@@ / @@v4@@ ) ; return fprintf ( @@a2@@ , String , @@v9@@ ) ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
unsigned __int64 __fastcall raw_hasher ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return rotr_sz ( @@a1@@ , Number ) % @@a2@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
struct tm * localtime ( const time_t * @@timer@@ ) { return localtime ( @@timer@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
int toupper ( int @@c@@ ) { return toupper ( @@c@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
int clock_gettime ( clockid_t @@clock_id@@ , struct timespec * @@tp@@ ) { return clock_gettime ( @@clock_id@@ , @@tp@@ ) ; }
unsigned __int64 __fastcall compute_bucket_size ( __int64 @@a1@@ , __int64 @@a2@@ ) { float @@v2@@ ; unsigned __int64 @@result@@ ; unsigned __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; float @@v6@@ ; @@v4@@ = @@a1@@ ; if ( * ( _BYTE * ) ( @@a2@@ + Number ) != Number ) { if ( @@a1@@ < Number ) @@v2@@ = ( float ) ( @@a1@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@a1@@ >> Number ) ) + ( float ) ( @@a1@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@a1@@ >> Number ) ) ; else @@v2@@ = ( float ) ( int ) @@a1@@ ; @@v6@@ = @@v2@@ / * ( float * ) ( @@a2@@ + Number ) ; if ( @@v6@@ >= Number ) return Number L ; if ( @@v6@@ >= Number ) @@v4@@ = ( unsigned int ) ( int ) ( float ) ( @@v6@@ - Number ) ^ Number ; else @@v4@@ = ( unsigned int ) ( int ) @@v6@@ ; } @@v5@@ = next_prime ( @@v4@@ ) ; if ( @@v5@@ <= Number ) @@result@@ = @@v5@@ ; else @@result@@ = Number L ; return @@result@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall memcpy_lowcase ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { while ( @@a3@@ -- ) * ( _BYTE * ) ( @@a1@@ + @@a3@@ ) = tolower ( * ( unsigned __int8 * ) ( @@a2@@ + @@a3@@ ) ) ; return @@a1@@ ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 __fastcall free_entry ( __int64 @@a1@@ , _QWORD * @@a2@@ ) { __int64 @@result@@ ; * @@a2@@ = Number L ; @@a2@@ [ Number ] = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@result@@ = @@a1@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall iso_week_days ( int @@a1@@ , int @@a2@@ ) { return ( unsigned int ) ( @@a1@@ - ( @@a1@@ - @@a2@@ + Number ) % Number + Number ) ; }
int wcwidth ( wchar_t @@c@@ ) { return wcwidth ( @@c@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_210228 ; @@v8@@ [ Number ] = qword_210230 ; @@v8@@ [ Number ] = qword_210238 ; @@v8@@ [ Number ] = qword_210240 ; @@v8@@ [ Number ] = qword_210248 ; @@v8@@ [ Number ] = qword_210250 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
time_t mktime ( struct tm * @@tp@@ ) { return mktime ( @@tp@@ ) ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
int __fastcall lstat ( char * @@filename@@ , struct stat * @@stat_buf@@ ) { return __lxstat ( Number , @@filename@@ , @@stat_buf@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 __fastcall bad_cast ( __int64 @@a1@@ ) { return @@a1@@ ; }
__int64 __fastcall hash_rehash ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; unsigned __int64 @@nmemb@@ ; void * @@v4@@ ; __int64 @@v5@@ ; unsigned __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; __int64 @@v12@@ ; __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; @@v14@@ = __readfsqword ( Number ) ; @@nmemb@@ = compute_bucket_size ( @@a2@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ; if ( ! @@nmemb@@ ) return Number L ; if ( @@nmemb@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; @@v4@@ = calloc ( @@nmemb@@ , Number ) ; if ( ! @@v4@@ ) return Number L ; @@v6@@ = @@nmemb@@ ; @@v5@@ = ( __int64 ) @@v4@@ + Number * @@nmemb@@ ; @@v7@@ = Number L ; @@v8@@ = Number L ; @@v9@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v10@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v11@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v12@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v13@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( ( unsigned __int8 ) transfer_entries ( ( __int64 ) & @@v4@@ , @@a1@@ , Number ) ) { free ( * ( void * * ) @@a1@@ ) ; * ( _QWORD * ) @@a1@@ = @@v4@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v5@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v6@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v7@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v13@@ ; @@result@@ = Number L ; } else { * ( _QWORD * ) ( @@a1@@ + Number ) = @@v13@@ ; if ( ( unsigned __int8 ) transfer_entries ( @@a1@@ , ( __int64 ) & @@v4@@ , Number ) != Number || ( unsigned __int8 ) transfer_entries ( @@a1@@ , ( __int64 ) & @@v4@@ , Number ) != Number ) { abort ( ) ; } free ( @@v4@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall memcpy_lowcase ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { while ( @@a3@@ -- ) * ( _BYTE * ) ( @@a1@@ + @@a3@@ ) = tolower ( * ( unsigned __int8 * ) ( @@a2@@ + @@a3@@ ) ) ; return @@a1@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 cols_ready_to_print ( ) { int @@i@@ ; unsigned int @@v2@@ ; _DWORD * @@v3@@ ; @@v2@@ = Number ; @@v3@@ = column_vector ; for ( @@i@@ = Number ; @@i@@ < columns ; ++ @@i@@ ) { if ( ! @@v3@@ [ Number ] || @@v3@@ [ Number ] == Number || storing_columns && ( int ) @@v3@@ [ Number ] > Number && ( int ) @@v3@@ [ Number ] > Number ) { ++ @@v2@@ ; } @@v3@@ += Number ; } return @@v2@@ ; }
DIR * __fastcall opendir_safer ( const char * @@a1@@ ) { int @@v2@@ ; int @@fd@@ ; int @@v4@@ ; DIR * @@dirp@@ ; DIR * @@v6@@ ; @@dirp@@ = opendir ( @@a1@@ ) ; if ( @@dirp@@ ) { @@v2@@ = dirfd ( @@dirp@@ ) ; if ( @@v2@@ >= Number && @@v2@@ <= Number ) { @@fd@@ = dup_safer ( ( unsigned int ) @@v2@@ ) ; @@v6@@ = fdopendir ( @@fd@@ ) ; @@v4@@ = * __errno_location ( ) ; if ( ! @@v6@@ ) close ( @@fd@@ ) ; closedir ( @@dirp@@ ) ; * __errno_location ( ) = @@v4@@ ; @@dirp@@ = @@v6@@ ; } } return @@dirp@@ ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
__int64 __fastcall iso_week_days ( int @@a1@@ , int @@a2@@ ) { return ( unsigned int ) ( @@a1@@ - ( @@a1@@ - @@a2@@ + Number ) % Number + Number ) ; }
int iswcntrl ( wint_t @@wc@@ ) { return iswcntrl ( @@wc@@ ) ; }
__int64 __fastcall bkm_scale_by_power_0 ( __int64 * @@a1@@ , int @@a2@@ , int @@a3@@ ) { unsigned int @@i@@ ; for ( @@i@@ = Number ; @@a3@@ -- ; @@i@@ |= bkm_scale_0 ( @@a1@@ , @@a2@@ ) ) ; return @@i@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ ) { return xmalloc ( @@a1@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 __fastcall dup_safer ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
int fileno ( FILE * @@stream@@ ) { return fileno ( @@stream@@ ) ; }
unsigned __int64 __fastcall getoptarg ( _BYTE * @@a1@@ , char @@a2@@ , _BYTE * @@a3@@ , _DWORD * @@a4@@ ) { __int64 @@v4@@ ; char * @@v5@@ ; _BYTE * @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; @@v8@@ = @@a1@@ ; @@v10@@ = __readfsqword ( Number ) ; if ( ( unsigned int ) ( ( char ) * @@a1@@ - Number ) > Number ) { @@v8@@ = @@a1@@ + Number ; * @@a3@@ = * @@a1@@ ; } if ( * @@v8@@ ) { if ( ( unsigned int ) xstrtol ( @@v8@@ , Number L , Number L , & @@v9@@ , & locale ) || @@v9@@ <= Number || @@v9@@ > Number ) { @@v4@@ = quote ( @@v8@@ ) ; @@v5@@ = gettext ( String ) ; error ( Number , Number , @@v5@@ , ( unsigned int ) @@a2@@ , @@v4@@ ) ; usage ( Number L ) ; } * @@a4@@ = @@v9@@ ; } return __readfsqword ( Number ) ^ @@v10@@ ; }
int __fxstat ( int @@ver@@ , int @@fildes@@ , struct stat * @@stat_buf@@ ) { return _fxstat ( @@ver@@ , @@fildes@@ , @@stat_buf@@ ) ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_20F028 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
__int64 __fastcall rpl_fcntl ( int @@a1@@ , int @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , __m128 @@a7@@ , __m128 @@a8@@ , __m128 @@a9@@ , __m128 @@a10@@ , __m128 @@a11@@ , __m128 @@a12@@ , __m128 @@a13@@ , __m128 @@a14@@ ) { int @@v14@@ ; int @@v15@@ ; int @@v16@@ ; int @@v18@@ ; int @@v19@@ ; int @@v20@@ ; int @@v21@@ ; __int64 @@v22@@ ; __int64 @@v23@@ ; __int64 @@v24@@ ; __int64 @@v25@@ ; __m128 @@v26@@ ; __m128 @@v27@@ ; __m128 @@v28@@ ; __m128 @@v29@@ ; __m128 @@v30@@ ; __m128 @@v31@@ ; __m128 @@v32@@ ; __m128 @@v33@@ ; @@v22@@ = @@a3@@ ; @@v23@@ = @@a4@@ ; @@v24@@ = @@a5@@ ; @@v25@@ = @@a6@@ ; @@v26@@ = @@a7@@ ; @@v27@@ = @@a8@@ ; @@v28@@ = @@a9@@ ; @@v29@@ = @@a10@@ ; @@v30@@ = @@a11@@ ; @@v31@@ = @@a12@@ ; @@v32@@ = @@a13@@ ; @@v33@@ = @@a14@@ ; if ( @@a2@@ != Number ) return ( unsigned int ) fcntl ( @@a1@@ , @@a2@@ , @@v22@@ ) ; @@v19@@ = @@v22@@ ; if ( have_dupfd_cloexec_2895 < Number ) { @@v18@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v22@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; } else { @@v18@@ = fcntl ( @@a1@@ , Number , ( unsigned int ) @@v22@@ ) ; if ( @@v18@@ < Number && * __errno_location ( ) == Number ) { @@v18@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v19@@ , @@v14@@ , @@v15@@ , @@v16@@ ) ; if ( @@v18@@ < Number ) return ( unsigned int ) @@v18@@ ; have_dupfd_cloexec_2895 = Number ; } else { have_dupfd_cloexec_2895 = Number ; } } if ( @@v18@@ >= Number && have_dupfd_cloexec_2895 == Number ) { @@v20@@ = fcntl ( @@v18@@ , Number ) ; if ( @@v20@@ < Number || fcntl ( @@v18@@ , Number , @@v20@@ | Number ) == Number ) { @@v21@@ = * __errno_location ( ) ; close ( @@v18@@ ) ; * __errno_location ( ) = @@v21@@ ; @@v18@@ = Number ; } } return ( unsigned int ) @@v18@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 __fastcall close_file ( __int64 @@a1@@ ) { __int64 @@result@@ ; const char * @@v2@@ ; int * @@v3@@ ; const char * @@v4@@ ; int * @@v5@@ ; int @@i@@ ; _DWORD * @@v7@@ ; @@result@@ = * ( unsigned int * ) ( @@a1@@ + Number ) ; if ( ( _DWORD ) @@result@@ != Number ) { if ( ferror_unlocked ( * ( FILE * * ) @@a1@@ ) ) { @@v2@@ = * ( const char * * ) ( @@a1@@ + Number ) ; @@v3@@ = __errno_location ( ) ; error ( Number , * @@v3@@ , String , @@v2@@ ) ; } if ( fileno ( * ( FILE * * ) @@a1@@ ) && fclose ( * ( FILE * * ) @@a1@@ ) ) { @@v4@@ = * ( const char * * ) ( @@a1@@ + Number ) ; @@v5@@ = __errno_location ( ) ; error ( Number , * @@v5@@ , String , @@v4@@ ) ; } if ( parallel_files != Number ) { @@v7@@ = column_vector ; for ( @@i@@ = columns ; @@i@@ ; -- @@i@@ ) { @@v7@@ [ Number ] = Number ; if ( ! @@v7@@ [ Number ] ) @@v7@@ [ Number ] = Number ; @@v7@@ += Number ; } } else { * ( _DWORD * ) ( @@a1@@ + Number ) = Number ; * ( _DWORD * ) ( @@a1@@ + Number ) = Number ; } @@result@@ = ( unsigned int ) -- files_ready_to_read ; } return @@result@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall bkm_scale_0 ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( * @@a1@@ >= ( __int64 ) Number / @@a2@@ ) { if ( Number / @@a2@@ >= * @@a1@@ ) { * @@a1@@ *= @@a2@@ ; @@result@@ = Number L ; } else { * @@a1@@ = Number ; @@result@@ = Number L ; } } else { * @@a1@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
void * init_store_cols ( ) { __int64 @@v0@@ ; void * @@result@@ ; int @@v2@@ ; int @@v3@@ ; @@v2@@ = lines_per_body * columns ; @@v3@@ = ( chars_per_column + Number ) * lines_per_body * columns ; free ( line_vector ) ; line_vector = ( void * ) xmalloc ( Number L * ( @@v2@@ + Number ) ) ; free ( end_vector ) ; end_vector = ( void * ) xmalloc ( Number L * @@v2@@ ) ; free ( buff ) ; if ( use_col_separator ) @@v0@@ = Number * @@v3@@ ; else @@v0@@ = @@v3@@ ; buff_allocated = @@v0@@ ; @@result@@ = ( void * ) xmalloc ( @@v0@@ ) ; buff = @@result@@ ; return @@result@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
int __fxstatat ( int @@ver@@ , int @@fildes@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ , int @@flag@@ ) { return _fxstatat ( @@ver@@ , @@fildes@@ , @@filename@@ , @@stat_buf@@ , @@flag@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
struct group * getgrnam ( const char * @@name@@ ) { return getgrnam ( @@name@@ ) ; }
void * __fastcall init_parameters ( int @@a1@@ ) { char * @@v1@@ ; int @@v2@@ ; void * @@result@@ ; int @@v4@@ ; int @@v5@@ ; @@v4@@ = Number ; lines_per_body = lines_per_page - Number ; if ( lines_per_page - Number <= Number ) { extremities = Number ; keep_FF = Number ; } if ( extremities != Number ) lines_per_body = lines_per_page ; if ( double_space ) lines_per_body /= Number ; if ( ! @@a1@@ ) parallel_files = Number ; if ( parallel_files ) columns = @@a1@@ ; if ( storing_columns ) balance_columns = Number ; if ( columns <= Number ) { storing_columns = Number ; } else { if ( use_col_separator != Number ) { if ( join_lines ) col_sep_string = line_separator [ Number ] ; else col_sep_string = column_separator [ Number ] ; col_sep_length = Number ; use_col_separator = Number ; } else if ( join_lines != Number && * col_sep_string == Number ) { col_sep_string = column_separator [ Number ] ; } truncate_lines = Number ; tabify_output = Number ; } if ( join_lines ) truncate_lines = Number ; if ( numbered_lines ) { line_count = start_line_num ; if ( number_separator == Number ) number_width = Number - chars_per_number % Number + chars_per_number ; else number_width = chars_per_number + Number ; if ( parallel_files ) @@v4@@ = number_width ; @@v5@@ = chars_per_number ; power_10 = Number ; while ( @@v5@@ > Number ) { power_10 *= Number ; -- @@v5@@ ; } } chars_per_column = ( chars_per_line - @@v4@@ - ( columns - Number ) * col_sep_length ) / columns ; if ( chars_per_column <= Number ) { @@v1@@ = gettext ( String ) ; error ( Number , Number , @@v1@@ ) ; } if ( numbered_lines ) { free ( number_buff ) ; number_buff = ( char * ) xmalloc ( Number * chars_per_number ) ; } free ( clump_buff ) ; @@v2@@ = chars_per_input_tab ; if ( chars_per_input_tab < Number ) @@v2@@ = Number ; @@result@@ = ( void * ) xmalloc ( @@v2@@ ) ; clump_buff = @@result@@ ; return @@result@@ ; }
__int64 __fastcall pad_across_to ( int @@a1@@ ) { __int64 @@result@@ ; int @@v2@@ ; @@v2@@ = output_position ; if ( tabify_output ) { @@result@@ = ( unsigned int ) ( @@a1@@ - output_position ) ; spaces_not_printed = @@a1@@ - output_position ; } else { while ( ++ @@v2@@ <= @@a1@@ ) putchar_unlocked ( Number ) ; @@result@@ = ( unsigned int ) @@a1@@ ; output_position = @@a1@@ ; } return @@result@@ ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
int fchdir ( int @@fd@@ ) { return fchdir ( @@fd@@ ) ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
__int64 __fastcall align_column ( __int64 @@a1@@ ) { __int64 @@result@@ ; padding_not_printed = * ( _DWORD * ) ( @@a1@@ + Number ) ; if ( padding_not_printed - col_sep_length > Number ) { pad_across_to ( ( unsigned int ) ( padding_not_printed - col_sep_length ) ) ; padding_not_printed = Number ; } if ( use_col_separator ) print_sep_string ( ) ; @@result@@ = * ( unsigned __int8 * ) ( @@a1@@ + Number ) ; if ( ( _BYTE ) @@result@@ ) @@result@@ = add_line_number ( @@a1@@ ) ; return @@result@@ ; }
struct dirent * readdir ( DIR * @@dirp@@ ) { return readdir ( @@dirp@@ ) ; }
__ino_t * __fastcall get_root_dev_ino ( __ino_t * @@a1@@ ) { struct stat @@v2@@ ; unsigned __int64 @@v3@@ ; @@v3@@ = __readfsqword ( Number ) ; if ( ( unsigned int ) lstat ( String , & @@v2@@ ) ) return Number L ; * @@a1@@ = @@v2@@ . st_ino ; @@a1@@ [ Number ] = @@v2@@ . st_dev ; return @@a1@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
DIR * fdopendir ( int @@fd@@ ) { return fdopendir ( @@fd@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ ) { return xmalloc ( @@a1@@ ) ; }
void free ( void * @@ptr@@ ) { __imp_free ( @@ptr@@ ) ; }
__int64 print_white_space ( ) { __int64 @@result@@ ; int @@v1@@ ; int @@v2@@ ; int @@v3@@ ; @@v1@@ = output_position ; @@v2@@ = spaces_not_printed + output_position ; while ( @@v2@@ - @@v1@@ > Number ) { @@v3@@ = chars_per_output_tab - @@v1@@ % chars_per_output_tab + @@v1@@ ; if ( @@v3@@ > @@v2@@ ) break ; putchar_unlocked ( output_tab_char ) ; @@v1@@ = @@v3@@ ; } while ( ++ @@v1@@ <= @@v2@@ ) putchar_unlocked ( Number ) ; @@result@@ = ( unsigned int ) @@v2@@ ; output_position = @@v2@@ ; spaces_not_printed = Number ; return @@result@@ ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 __fastcall balance ( int @@a1@@ ) { __int64 @@result@@ ; int @@v2@@ ; int @@v3@@ ; int @@v4@@ ; _DWORD * @@i@@ ; @@v4@@ = Number ; @@v2@@ = Number ; for ( @@i@@ = column_vector ; ; @@i@@ += Number ) { @@result@@ = ( unsigned int ) columns ; if ( @@v2@@ > columns ) break ; @@v3@@ = @@a1@@ / columns ; if ( @@v2@@ <= @@a1@@ % columns ) ++ @@v3@@ ; @@i@@ [ Number ] = @@v3@@ ; @@i@@ [ Number ] = @@v4@@ ; @@v4@@ += @@v3@@ ; ++ @@v2@@ ; } return @@result@@ ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; FILE * @@v10@@ ; char * @@v11@@ ; FILE * @@v12@@ ; char * @@v13@@ ; FILE * @@v14@@ ; char * @@v15@@ ; FILE * @@v16@@ ; char * @@v17@@ ; FILE * @@v18@@ ; char * @@v19@@ ; __int64 @@v20@@ ; __int64 @@v21@@ ; char * @@v22@@ ; if ( @@a1@@ ) { @@v1@@ = program_name ; @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = program_name ; @@v4@@ = program_name ; @@v5@@ = gettext ( String ) ; printf ( @@v5@@ , @@v4@@ , @@v3@@ ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String String String String String String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; @@v8@@ = stdout ; @@v9@@ = gettext ( String String String ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = stdout ; @@v11@@ = gettext ( String String ) ; fputs_unlocked ( @@v11@@ , @@v10@@ ) ; @@v12@@ = stdout ; @@v13@@ = gettext ( String String String String String String ) ; fputs_unlocked ( @@v13@@ , @@v12@@ ) ; @@v14@@ = stdout ; @@v15@@ = gettext ( String String String String String String String String String String ) ; fputs_unlocked ( @@v15@@ , @@v14@@ ) ; @@v16@@ = stdout ; @@v17@@ = gettext ( String ) ; fputs_unlocked ( @@v17@@ , @@v16@@ ) ; @@v18@@ = stdout ; @@v19@@ = gettext ( String ) ; fputs_unlocked ( @@v19@@ , @@v18@@ ) ; @@v20@@ = program_name ; @@v21@@ = program_name ; @@v22@@ = gettext ( String String String String ) ; printf ( @@v22@@ , @@v21@@ , @@v20@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall uid_to_name ( __uid_t @@a1@@ ) { __int64 @@v1@@ ; struct passwd * @@v3@@ ; char @@v4@@ [ Number ] ; unsigned __int64 @@v5@@ ; @@v5@@ = __readfsqword ( Number ) ; @@v3@@ = getpwuid ( @@a1@@ ) ; if ( @@v3@@ ) @@v1@@ = ( __int64 ) @@v3@@ -> pw_name ; else @@v1@@ = umaxtostr ( @@a1@@ , @@v4@@ ) ; return xstrdup ( @@v1@@ ) ; }
bool __fastcall skip_to_page ( unsigned __int64 @@a1@@ ) { char * @@v1@@ ; int @@j@@ ; int @@v4@@ ; int @@v5@@ ; int @@v6@@ ; unsigned __int64 @@i@@ ; _DWORD * @@v8@@ ; _DWORD * @@v9@@ ; _DWORD * @@v10@@ ; for ( @@i@@ = Number L ; @@i@@ < @@a1@@ ; ++ @@i@@ ) { for ( @@j@@ = Number ; @@j@@ < lines_per_body ; ++ @@j@@ ) { @@v4@@ = Number ; @@v8@@ = column_vector ; while ( @@v4@@ <= columns ) { if ( ! @@v8@@ [ Number ] ) skip_read ( ( __int64 ) @@v8@@ , @@v4@@ ) ; ++ @@v4@@ ; @@v8@@ += Number ; } } last_line = Number ; @@v5@@ = Number ; @@v9@@ = column_vector ; while ( @@v5@@ <= columns ) { if ( ! @@v9@@ [ Number ] ) skip_read ( ( __int64 ) @@v9@@ , @@v5@@ ) ; ++ @@v5@@ ; @@v9@@ += Number ; } if ( storing_columns ) { @@v6@@ = Number ; @@v10@@ = column_vector ; while ( @@v6@@ <= columns ) { if ( @@v10@@ [ Number ] != Number ) @@v10@@ [ Number ] = Number ; ++ @@v6@@ ; @@v10@@ += Number ; } } reset_status ( ) ; last_line = Number ; if ( files_ready_to_read <= Number ) { @@v1@@ = gettext ( String ) ; error ( Number , Number , @@v1@@ , @@a1@@ , @@i@@ ) ; return files_ready_to_read > Number ; } } return files_ready_to_read > Number ; }
int __fastcall read_rest_of_line ( FILE * * @@a1@@ ) { int @@result@@ ; int @@c@@ ; FILE * @@stream@@ ; @@stream@@ = * @@a1@@ ; for ( @@result@@ = getc_unlocked ( * @@a1@@ ) ; @@result@@ != Number ; @@result@@ = getc_unlocked ( @@stream@@ ) ) { if ( @@result@@ == Number ) { @@c@@ = getc_unlocked ( @@stream@@ ) ; if ( @@c@@ != Number ) ungetc ( @@c@@ , @@stream@@ ) ; if ( keep_FF ) print_a_FF = Number ; return hold_file ( ( __int64 ) @@a1@@ ) ; } if ( @@result@@ == Number ) return close_file ( ( __int64 ) @@a1@@ ) ; } return @@result@@ ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( is_mul_ok ( @@a2@@ , * @@a1@@ ) ) { * @@a1@@ *= @@a2@@ ; @@result@@ = Number L ; } else { * @@a1@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
__int64 print_sep_string ( ) { __int64 @@result@@ ; char * @@v1@@ ; int @@v2@@ ; int @@v3@@ ; char * @@v4@@ ; @@v3@@ = col_sep_length ; @@v4@@ = col_sep_string ; if ( separators_not_printed > Number ) { while ( Number ) { @@result@@ = ( unsigned int ) separators_not_printed ; if ( separators_not_printed <= Number ) break ; while ( Number ) { @@v2@@ = @@v3@@ -- ; if ( @@v2@@ <= Number ) break ; if ( * @@v4@@ == Number ) { ++ @@v4@@ ; ++ spaces_not_printed ; } else { if ( spaces_not_printed > Number ) print_white_space ( ) ; @@v1@@ = @@v4@@ ++ ; putchar_unlocked ( * @@v1@@ ) ; ++ output_position ; } } if ( spaces_not_printed > Number ) print_white_space ( ) ; -- separators_not_printed ; } } else { @@result@@ = ( unsigned int ) spaces_not_printed ; if ( spaces_not_printed > Number ) @@result@@ = print_white_space ( ) ; } return @@result@@ ; }
__int64 __fastcall dup_cloexec ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
void __fastcall describe_change ( __int64 @@a1@@ , int @@a2@@ , const char * @@a3@@ , const char * @@a4@@ ) { __int64 @@v4@@ ; char * @@v5@@ ; size_t @@v6@@ ; size_t @@v7@@ ; char * @@v8@@ ; char * @@v9@@ ; char * @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; char * @@format@@ ; void * @@v16@@ ; char * @@dest@@ ; @@dest@@ = Number L ; if ( @@a2@@ == Number ) { @@v4@@ = quote ( @@a1@@ ) ; @@v5@@ = gettext ( String ) ; printf ( @@v5@@ , @@v4@@ ) ; } else { if ( @@a3@@ ) { if ( @@a4@@ ) { @@v6@@ = strlen ( @@a3@@ ) ; @@v7@@ = strlen ( @@a4@@ ) ; @@dest@@ = ( char * ) xmalloc ( @@v6@@ + @@v7@@ + Number ) ; @@v8@@ = stpcpy ( @@dest@@ , @@a3@@ ) ; * ( _WORD * ) @@v8@@ = Number ; strcpy ( @@v8@@ + Number , @@a4@@ ) ; @@v16@@ = @@dest@@ ; } else { @@v16@@ = ( void * ) @@a3@@ ; } } else { @@v16@@ = ( void * ) @@a4@@ ; } switch ( @@a2@@ ) { case Number : if ( @@a3@@ ) { @@v10@@ = gettext ( String ) ; } else if ( @@a4@@ ) { @@v10@@ = gettext ( String ) ; } else { @@v10@@ = gettext ( String ) ; } @@format@@ = @@v10@@ ; break ; case Number : if ( @@a3@@ ) { @@v11@@ = gettext ( String ) ; } else if ( @@a4@@ ) { @@v11@@ = gettext ( String ) ; } else { @@v11@@ = gettext ( String ) ; } @@format@@ = @@v11@@ ; break ; case Number : if ( @@a3@@ ) { @@v9@@ = gettext ( String ) ; } else if ( @@a4@@ ) { @@v9@@ = gettext ( String ) ; } else { @@v9@@ = gettext ( String ) ; } @@format@@ = @@v9@@ ; break ; default : abort ( ) ; } @@v12@@ = quote ( @@a1@@ ) ; printf ( @@format@@ , @@v12@@ , @@v16@@ ) ; free ( @@dest@@ ) ; } }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
__int64 __fastcall gnu_mbswidth ( const char * @@a1@@ , unsigned int @@a2@@ ) { size_t @@v2@@ ; @@v2@@ = strlen ( @@a1@@ ) ; return mbsnwidth ( @@a1@@ , @@v2@@ , @@a2@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , off_C4A2 , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
int __fastcall stat ( char * @@filename@@ , struct stat * @@stat_buf@@ ) { return __xstat ( Number , @@filename@@ , @@stat_buf@@ ) ; }
__int64 __fastcall fd_ring_clear ( __int64 @@a1@@ ) { __int64 @@result@@ ; int @@fd@@ ; while ( Number ) { @@result@@ = ( unsigned int ) i_ring_empty ( @@a1@@ ) ^ Number ; if ( ! ( _BYTE ) @@result@@ ) break ; @@fd@@ = i_ring_pop ( @@a1@@ ) ; if ( @@fd@@ >= Number ) close ( @@fd@@ ) ; } return @@result@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
_BOOL8 __fastcall AD_compare ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { return @@a1@@ [ Number ] == @@a2@@ [ Number ] && * @@a1@@ == * @@a2@@ ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
int __fastcall fstat ( int @@fildes@@ , struct stat * @@stat_buf@@ ) { return __fxstat ( Number , @@fildes@@ , @@stat_buf@@ ) ; }
__int64 __fastcall bkm_scale_by_power ( unsigned __int64 * @@a1@@ , int @@a2@@ , int @@a3@@ ) { unsigned int @@i@@ ; for ( @@i@@ = Number ; @@a3@@ -- ; @@i@@ |= bkm_scale ( @@a1@@ , @@a2@@ ) ) ; return @@i@@ ; }
void __fastcall free_dir ( __int64 @@a1@@ ) { if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) hash_free ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ; } else { free ( * ( void * * ) ( @@a1@@ + Number ) ) ; } }
__int64 __fastcall cwd_advance_fd ( __int64 @@a1@@ , int @@a2@@ , char @@a3@@ ) { __int64 @@result@@ ; int @@v4@@ ; int @@fd@@ ; @@v4@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; if ( @@v4@@ == @@a2@@ && @@v4@@ != Number ) abort ( ) ; if ( @@a3@@ ) { @@fd@@ = i_ring_push ( @@a1@@ + Number , ( unsigned int ) @@v4@@ ) ; if ( @@fd@@ >= Number ) close ( @@fd@@ ) ; } else if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) == Number && @@v4@@ >= Number ) { close ( @@v4@@ ) ; } @@result@@ = @@a1@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
int __fastcall lstat ( char * @@filename@@ , struct stat * @@stat_buf@@ ) { return __lxstat ( Number , @@filename@@ , @@stat_buf@@ ) ; }
FILE * __fastcall fopen_safer ( const char * @@a1@@ , const char * @@a2@@ ) { int @@v3@@ ; int @@fd@@ ; int @@v5@@ ; int @@v6@@ ; FILE * @@stream@@ ; @@stream@@ = fopen ( @@a1@@ , @@a2@@ ) ; if ( ! @@stream@@ ) return @@stream@@ ; @@v3@@ = fileno ( @@stream@@ ) ; if ( @@v3@@ < Number || @@v3@@ > Number ) return @@stream@@ ; @@fd@@ = dup_safer ( ( unsigned int ) @@v3@@ ) ; if ( @@fd@@ < Number ) { @@v6@@ = * __errno_location ( ) ; fclose ( @@stream@@ ) ; * __errno_location ( ) = @@v6@@ ; return Number L ; } if ( ! fclose ( @@stream@@ ) ) { @@stream@@ = fdopen ( @@fd@@ , @@a2@@ ) ; if ( @@stream@@ ) return @@stream@@ ; } @@v5@@ = * __errno_location ( ) ; close ( @@fd@@ ) ; * __errno_location ( ) = @@v5@@ ; return Number L ; }
_BOOL8 __fastcall dirent_inode_sort_may_be_useful ( int @@a1@@ ) { struct statfs @@buf@@ ; unsigned __int64 @@v3@@ ; @@v3@@ = __readfsqword ( Number ) ; if ( fstatfs ( @@a1@@ , & @@buf@@ ) ) return Number L ; return @@buf@@ . f_type != Number && @@buf@@ . f_type != Number ; }
__int64 __fastcall fts_set_stat_required ( __int64 @@a1@@ , char @@a2@@ ) { __int64 @@v2@@ ; __int64 @@result@@ ; if ( * ( _WORD * ) ( @@a1@@ + Number ) != Number ) abort ( ) ; if ( @@a2@@ ) @@v2@@ = Number L ; else @@v2@@ = Number L ; @@result@@ = @@a1@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v2@@ ; return @@result@@ ; }
int __fastcall fstatat ( int @@fildes@@ , char * @@filename@@ , struct stat * @@stat_buf@@ , int @@flag@@ ) { return __fxstatat ( Number , @@fildes@@ , @@filename@@ , @@stat_buf@@ , @@flag@@ ) ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
__int64 __fastcall diropen ( __int64 @@a1@@ , int @@a2@@ , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { int @@v6@@ ; int @@v8@@ ; unsigned int @@v9@@ ; @@v8@@ = ( * ( _DWORD * ) ( @@a1@@ + Number ) << Number ) & Number | Number ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) @@v6@@ = openat_safer ( * ( _DWORD * ) ( @@a1@@ + Number ) , @@a2@@ , @@v8@@ , @@a2@@ , @@a5@@ , @@a6@@ , @@a2@@ ) ; else @@v6@@ = open_safer ( @@a2@@ , @@v8@@ , @@v8@@ , @@a4@@ , @@a5@@ , @@a6@@ , @@a2@@ ) ; @@v9@@ = @@v6@@ ; if ( @@v6@@ >= Number ) set_cloexec_flag ( ( unsigned int ) @@v6@@ , Number L ) ; return @@v9@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall memcpy_uppcase ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { while ( @@a3@@ -- ) * ( _BYTE * ) ( @@a1@@ + @@a3@@ ) = toupper ( * ( unsigned __int8 * ) ( @@a2@@ + @@a3@@ ) ) ; return @@a1@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
_BOOL8 __fastcall leaf_optimization_applies ( int @@a1@@ ) { _BOOL8 @@result@@ ; struct statfs @@buf@@ ; unsigned __int64 @@v3@@ ; @@v3@@ = __readfsqword ( Number ) ; if ( fstatfs ( @@a1@@ , & @@buf@@ ) ) @@result@@ = Number L ; else @@result@@ = @@buf@@ . f_type == Number ; return @@result@@ ; }
__int64 __fastcall fts_children ( __int64 @@a1@@ , int @@a2@@ ) { __int64 @@v3@@ ; __int64 @@v4@@ ; int @@v5@@ ; int @@v6@@ ; int @@v7@@ ; int @@v8@@ ; unsigned int @@v9@@ ; int @@fd@@ ; int @@v11@@ ; if ( @@a2@@ && @@a2@@ != Number ) { * __errno_location ( ) = Number ; return Number L ; } @@v3@@ = * ( _QWORD * ) @@a1@@ ; * __errno_location ( ) = Number ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) return Number L ; if ( * ( _WORD * ) ( @@v3@@ + Number ) == Number ) return * ( _QWORD * ) ( @@v3@@ + Number ) ; if ( * ( _WORD * ) ( @@v3@@ + Number ) != Number ) return Number L ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) fts_lfree ( * ( void * * ) ( @@a1@@ + Number ) ) ; if ( @@a2@@ == Number ) { @@v8@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; BYTE1 ( @@v8@@ ) |= Number ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@v8@@ ; @@v9@@ = Number ; } else { @@v9@@ = Number ; } if ( * ( _QWORD * ) ( @@v3@@ + Number ) || * * ( _BYTE * * ) ( @@v3@@ + Number ) == Number || ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { * ( _QWORD * ) ( @@a1@@ + Number ) = fts_build ( @@a1@@ , @@v9@@ ) ; return * ( _QWORD * ) ( @@a1@@ + Number ) ; } @@fd@@ = diropen ( @@a1@@ , ( int ) & unk_C4A9 , @@v4@@ , @@v5@@ , @@v6@@ , @@v7@@ ) ; if ( @@fd@@ < Number ) { * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; return Number L ; } * ( _QWORD * ) ( @@a1@@ + Number ) = fts_build ( @@a1@@ , @@v9@@ ) ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { cwd_advance_fd ( @@a1@@ , @@fd@@ , Number ) ; } else { if ( fchdir ( @@fd@@ ) ) { @@v11@@ = * __errno_location ( ) ; close ( @@fd@@ ) ; * __errno_location ( ) = @@v11@@ ; return Number L ; } close ( @@fd@@ ) ; } return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
__int64 __fastcall fts_compare_ino ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; if ( * ( _QWORD * ) ( * ( _QWORD * ) @@a1@@ + Number L ) < * ( _QWORD * ) ( * ( _QWORD * ) @@a2@@ + Number L ) ) @@result@@ = Number ; else @@result@@ = * ( _QWORD * ) ( * ( _QWORD * ) @@a2@@ + Number L ) < * ( _QWORD * ) ( * ( _QWORD * ) @@a1@@ + Number L ) ; return @@result@@ ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
size_t __fastcall fts_maxarglen ( const char * * @@a1@@ ) { size_t @@v3@@ ; size_t @@v4@@ ; @@v3@@ = Number L ; while ( * @@a1@@ ) { @@v4@@ = strlen ( * @@a1@@ ) ; if ( @@v4@@ > @@v3@@ ) @@v3@@ = @@v4@@ ; ++ @@a1@@ ; } return @@v3@@ + Number ; }
__int64 __fastcall hash_get_n_buckets ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int64 __fastcall hash_get_n_entries ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
__int64 __fastcall fts_stat ( __int64 @@a1@@ , __int64 @@a2@@ , char @@a3@@ ) { __int64 @@result@@ ; __int64 @@v4@@ ; int @@v6@@ ; struct stat * @@s@@ ; @@s@@ = ( struct stat * ) ( @@a2@@ + Number ) ; if ( ! * ( _QWORD * ) ( @@a2@@ + Number ) && ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) @@a3@@ = Number ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number || @@a3@@ ) { if ( ( unsigned int ) stat ( * ( char * * ) ( @@a2@@ + Number ) , @@s@@ ) ) { @@v6@@ = * __errno_location ( ) ; if ( * __errno_location ( ) == Number && ! ( unsigned int ) lstat ( * ( char * * ) ( @@a2@@ + Number ) , @@s@@ ) ) { * __errno_location ( ) = Number ; return Number L ; } * ( _DWORD * ) ( @@a2@@ + Number ) = @@v6@@ ; goto LABEL_13 ; } } else if ( ( unsigned int ) fstatat ( * ( _DWORD * ) ( @@a1@@ + Number ) , * ( char * * ) ( @@a2@@ + Number ) , @@s@@ , Number ) ) { * ( _DWORD * ) ( @@a2@@ + Number ) = * __errno_location ( ) ; LABEL_13 : memset ( @@s@@ , Number , sizeof ( struct stat ) ) ; return Number L ; } switch ( * ( _DWORD * ) ( @@a2@@ + Number ) & Number ) { case Number : if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) @@v4@@ = Number L ; else @@v4@@ = Number L ; * ( _QWORD * ) ( @@a2@@ + Number ) = * ( _QWORD * ) ( @@a2@@ + Number ) - @@v4@@ ; if ( * ( _BYTE * ) ( @@a2@@ + Number ) != Number || * ( _BYTE * ) ( @@a2@@ + Number ) && ( * ( _BYTE * ) ( @@a2@@ + Number ) != Number || * ( _BYTE * ) ( @@a2@@ + Number ) ) ) { @@result@@ = Number L ; } else if ( * ( _QWORD * ) ( @@a2@@ + Number ) ) { @@result@@ = Number L ; } else { @@result@@ = Number L ; } break ; case Number : @@result@@ = Number L ; break ; case Number : @@result@@ = Number L ; break ; default : @@result@@ = Number L ; break ; } return @@result@@ ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_210088 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
_BOOL8 __fastcall hash_table_ok ( __int64 @@a1@@ ) { _QWORD * @@i@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; _QWORD * @@v5@@ ; @@v3@@ = Number L ; @@v4@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { @@v5@@ = @@i@@ ; ++ @@v3@@ ; ++ @@v4@@ ; while ( Number ) { @@v5@@ = ( _QWORD * ) @@v5@@ [ Number ] ; if ( ! @@v5@@ ) break ; ++ @@v4@@ ; } } } return @@v3@@ == * ( _QWORD * ) ( @@a1@@ + Number ) && @@v4@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ; }
struct passwd * getpwuid ( __uid_t @@uid@@ ) { return getpwuid ( @@uid@@ ) ; }
_BYTE * __fastcall dir_len ( _BYTE * @@a1@@ ) { _BYTE * @@i@@ ; unsigned __int64 @@v3@@ ; @@v3@@ = * @@a1@@ == Number ; for ( @@i@@ = ( _BYTE * ) ( last_component ( @@a1@@ ) - @@a1@@ ) ; @@v3@@ < ( unsigned __int64 ) @@i@@ && @@a1@@ [ ( _QWORD ) ( @@i@@ - Number ) ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
__int64 __fastcall hash_lookup ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; _QWORD * @@i@@ ; _QWORD * @@v5@@ ; @@v2@@ = * @@a1@@ ; @@v5@@ = ( _QWORD * ) ( @@v2@@ + Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) ) ; if ( ( unsigned __int64 ) @@v5@@ >= @@a1@@ [ Number ] ) abort ( ) ; if ( ! * @@v5@@ ) return Number L ; for ( @@i@@ = @@v5@@ ; @@i@@ ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { if ( @@a2@@ == * @@i@@ || ( ( unsigned __int8 ( __fastcall * ) ( __int64 , _QWORD ) ) @@a1@@ [ Number ] ) ( @@a2@@ , * @@i@@ ) ) { return * @@i@@ ; } } return Number L ; }
struct group * getgrgid ( __gid_t @@gid@@ ) { return getgrgid ( @@gid@@ ) ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
__int64 __fastcall hash_get_first ( unsigned __int64 * @@a1@@ ) { unsigned __int64 @@i@@ ; if ( ! @@a1@@ [ Number ] ) return Number L ; for ( @@i@@ = * @@a1@@ ; ; @@i@@ += Number L ) { if ( @@i@@ >= @@a1@@ [ Number ] ) abort ( ) ; if ( * ( _QWORD * ) @@i@@ ) break ; } return * ( _QWORD * ) @@i@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_210228 ; @@v4@@ [ Number ] = qword_210230 ; @@v4@@ [ Number ] = qword_210238 ; @@v4@@ [ Number ] = qword_210240 ; @@v4@@ [ Number ] = qword_210248 ; @@v4@@ [ Number ] = qword_210250 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
__int64 __fastcall hash_do_for_each ( __int64 @@a1@@ , unsigned __int8 ( __fastcall * @@a2@@ ) ( _QWORD , __int64 ) , __int64 @@a3@@ ) { __int64 @@v5@@ ; _QWORD * @@i@@ ; _QWORD * @@j@@ ; @@v5@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = @@i@@ ; @@j@@ ; @@j@@ = ( _QWORD * ) @@j@@ [ Number ] ) { if ( @@a2@@ ( * @@j@@ , @@a3@@ ) != Number ) return @@v5@@ ; ++ @@v5@@ ; } } } return @@v5@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
unsigned __int64 __fastcall hash_get_entries ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; _QWORD * @@i@@ ; _QWORD * @@j@@ ; @@v5@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = @@i@@ ; @@j@@ ; @@j@@ = ( _QWORD * ) @@j@@ [ Number ] ) { if ( @@v5@@ >= @@a3@@ ) return @@v5@@ ; @@v4@@ = @@v5@@ ++ ; * ( _QWORD * ) ( @@a2@@ + Number * @@v4@@ ) = * @@j@@ ; } } } return @@v5@@ ; }
__int64 __fastcall nstrftime ( char * @@a1@@ , __int64 @@a2@@ , char * @@a3@@ , __int64 @@a4@@ , int @@a5@@ , int @@a6@@ ) { return strftime_case_ ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
int __xstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _xstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
__int64 __fastcall check_tuning ( __int64 @@a1@@ ) { __int64 @@v2@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( ( _UNKNOWN * ) @@v2@@ == & default_tuning ) return Number L ; if ( * ( float * ) ( @@v2@@ + Number ) > Number && ( float ) ( Number - Number ) > * ( float * ) ( @@v2@@ + Number ) && * ( float * ) ( @@v2@@ + Number ) > ( float ) ( Number + Number ) && * ( float * ) @@v2@@ >= Number && * ( float * ) ( @@v2@@ + Number ) > ( float ) ( * ( float * ) @@v2@@ + Number ) && * ( float * ) ( @@v2@@ + Number ) <= Number && * ( float * ) ( @@v2@@ + Number ) > ( float ) ( * ( float * ) @@v2@@ + Number ) ) { return Number L ; } * ( _QWORD * ) ( @@a1@@ + Number ) = & default_tuning ; return Number L ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
bool __fastcall is_prime ( unsigned __int64 @@a1@@ ) { unsigned __int64 @@v2@@ ; unsigned __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; @@v2@@ = Number L ; @@v4@@ = Number L ; while ( @@v4@@ < @@a1@@ && @@a1@@ % @@v2@@ ) { @@v3@@ = @@v2@@ + Number ; @@v4@@ += Number * @@v3@@ ; @@v2@@ = @@v3@@ + Number ; } return @@a1@@ % @@v2@@ != Number ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
void * __fastcall allocate_entry ( __int64 @@a1@@ ) { __int64 @@v2@@ ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return malloc ( Number ) ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = * ( _QWORD * ) ( @@v2@@ + Number ) ; return ( void * ) @@v2@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return xmalloc ( @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall gid_to_name ( __gid_t @@a1@@ ) { __int64 @@v1@@ ; struct group * @@v3@@ ; char @@v4@@ [ Number ] ; unsigned __int64 @@v5@@ ; @@v5@@ = __readfsqword ( Number ) ; @@v3@@ = getgrgid ( @@a1@@ ) ; if ( @@v3@@ ) @@v1@@ = ( __int64 ) @@v3@@ -> gr_name ; else @@v1@@ = umaxtostr ( @@a1@@ , @@v4@@ ) ; return xstrdup ( @@v1@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
unsigned __int64 __fastcall xstrtol_error ( unsigned int @@a1@@ , int @@a2@@ , char @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , int @@a6@@ ) { char * @@v6@@ ; char * @@v10@@ ; char * @@msgid@@ ; char * @@v12@@ ; char @@v13@@ [ Number ] ; unsigned __int64 @@v14@@ ; @@v14@@ = __readfsqword ( Number ) ; @@v10@@ = String ; if ( @@a1@@ > Number ) { if ( @@a1@@ != Number ) goto LABEL_6 ; @@msgid@@ = String ; } else if ( @@a1@@ >= Number ) { @@msgid@@ = String ; } else { if ( @@a1@@ != Number ) LABEL_6 : abort ( ) ; @@msgid@@ = String ; } if ( @@a2@@ >= Number ) { @@v12@@ = * ( char * * ) ( Number L * @@a2@@ + @@a4@@ ) ; } else { @@v10@@ = & asc_DD10 [ - @@a2@@ ] ; @@v13@@ [ Number ] = @@a3@@ ; @@v13@@ [ Number ] = Number ; @@v12@@ = @@v13@@ ; } @@v6@@ = gettext ( @@msgid@@ ) ; error ( @@a6@@ , Number , @@v6@@ , @@v10@@ , @@v12@@ , @@a5@@ ) ; return __readfsqword ( Number ) ^ @@v14@@ ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
size_t * __fastcall hash_initialize ( __int64 @@a1@@ , void * @@a2@@ , unsigned __int64 ( __fastcall * @@a3@@ ) ( __int64 a1 , unsigned __int64 a2 ) , bool ( __fastcall * @@a4@@ ) ( __int64 a1 , __int64 a2 ) , size_t @@a5@@ ) { size_t * @@result@@ ; bool ( __fastcall * @@v7@@ ) ( __int64 , __int64 ) ; unsigned __int64 ( __fastcall * @@v8@@ ) ( __int64 , unsigned __int64 ) ; void * @@v9@@ ; size_t * @@ptr@@ ; @@v9@@ = @@a2@@ ; @@v8@@ = @@a3@@ ; @@v7@@ = @@a4@@ ; if ( ! @@a3@@ ) @@v8@@ = raw_hasher ; if ( ! @@a4@@ ) @@v7@@ = raw_comparator ; @@ptr@@ = ( size_t * ) malloc ( Number ) ; if ( ! @@ptr@@ ) return Number L ; if ( ! @@a2@@ ) @@v9@@ = & default_tuning ; @@ptr@@ [ Number ] = ( size_t ) @@v9@@ ; if ( ( unsigned __int8 ) check_tuning ( ( __int64 ) @@ptr@@ ) == Number && ( @@ptr@@ [ Number ] = compute_bucket_size ( @@a1@@ , ( __int64 ) @@v9@@ ) ) != Number && ( * @@ptr@@ = ( size_t ) calloc ( @@ptr@@ [ Number ] , Number ) ) != Number ) { @@ptr@@ [ Number ] = Number * @@ptr@@ [ Number ] + * @@ptr@@ ; @@ptr@@ [ Number ] = Number L ; @@ptr@@ [ Number ] = Number L ; @@ptr@@ [ Number ] = ( size_t ) @@v8@@ ; @@ptr@@ [ Number ] = ( size_t ) @@v7@@ ; @@ptr@@ [ Number ] = @@a5@@ ; @@ptr@@ [ Number ] = Number L ; @@result@@ = @@ptr@@ ; } else { free ( @@ptr@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
_BOOL8 __fastcall chown_files ( __int64 @@a1@@ , unsigned int @@a2@@ , __uid_t @@a3@@ , __gid_t @@a4@@ , int @@a5@@ , int @@a6@@ , __int64 @@a7@@ ) { int @@v7@@ ; char * @@v8@@ ; int * @@v9@@ ; char * @@v10@@ ; int * @@v11@@ ; bool @@v17@@ ; __int64 @@i@@ ; __int64 @@v19@@ ; @@v17@@ = Number ; if ( @@a5@@ == Number && @@a6@@ == Number && ! * ( _BYTE * ) ( @@a7@@ + Number ) && * ( _DWORD * ) @@a7@@ == Number ) { @@v7@@ = Number ; } else { @@v7@@ = Number ; } for ( @@i@@ = xfts_open ( @@a1@@ , @@v7@@ | @@a2@@ , Number L ) ; ; @@v17@@ = ( @@v17@@ & ( unsigned __int8 ) change_file_owner ( @@i@@ , @@v19@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ , @@a7@@ ) ) != Number ) { @@v19@@ = fts_read ( @@i@@ ) ; if ( ! @@v19@@ ) break ; } if ( * __errno_location ( ) ) { if ( * ( _BYTE * ) ( @@a7@@ + Number ) != Number ) { @@v8@@ = gettext ( String ) ; @@v9@@ = __errno_location ( ) ; error ( Number , * @@v9@@ , @@v8@@ ) ; } @@v17@@ = Number ; } if ( ( unsigned int ) fts_close ( @@i@@ ) ) { @@v10@@ = gettext ( String ) ; @@v11@@ = __errno_location ( ) ; error ( Number , * @@v11@@ , @@v10@@ ) ; @@v17@@ = Number ; } return @@v17@@ ; }
__int64 __fastcall hash_find_entry ( __int64 @@a1@@ , __int64 @@a2@@ , _QWORD * @@a3@@ , char @@a4@@ ) { __int64 @@v4@@ ; __int64 @@result@@ ; __int64 @@v6@@ ; _QWORD * @@i@@ ; _QWORD * @@v10@@ ; __int64 @@v11@@ ; _QWORD * @@v12@@ ; __int64 @@v13@@ ; _QWORD * @@v14@@ ; @@v4@@ = * ( _QWORD * ) @@a1@@ ; @@v10@@ = ( _QWORD * ) ( @@v4@@ + Number * ( * ( __int64 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@a2@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@v10@@ >= * ( _QWORD * ) ( @@a1@@ + Number ) ) abort ( ) ; * @@a3@@ = @@v10@@ ; if ( ! * @@v10@@ ) return Number L ; if ( @@a2@@ == * @@v10@@ || ( * ( unsigned __int8 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@a2@@ , * @@v10@@ ) ) { @@v13@@ = * @@v10@@ ; if ( @@a4@@ ) { if ( @@v10@@ [ Number ] ) { @@v14@@ = ( _QWORD * ) @@v10@@ [ Number ] ; @@v6@@ = @@v14@@ [ Number ] ; * @@v10@@ = * @@v14@@ ; @@v10@@ [ Number ] = @@v6@@ ; free_entry ( @@a1@@ , @@v14@@ ) ; } else { * @@v10@@ = Number L ; } } @@result@@ = @@v13@@ ; } else { for ( @@i@@ = @@v10@@ ; ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { if ( ! @@i@@ [ Number ] ) return Number L ; if ( @@a2@@ == * ( _QWORD * ) @@i@@ [ Number ] || ( * ( unsigned __int8 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@a2@@ , * ( _QWORD * ) @@i@@ [ Number ] ) ) { break ; } } @@v11@@ = * ( _QWORD * ) @@i@@ [ Number ] ; if ( @@a4@@ ) { @@v12@@ = ( _QWORD * ) @@i@@ [ Number ] ; @@i@@ [ Number ] = @@v12@@ [ Number ] ; free_entry ( @@a1@@ , @@v12@@ ) ; } @@result@@ = @@v11@@ ; } return @@result@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
__int64 __fastcall i_ring_empty ( __int64 @@a1@@ ) { return * ( unsigned __int8 * ) ( @@a1@@ + Number ) ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
__int64 __fastcall openat_safer ( int @@a1@@ , const char * @@a2@@ , char @@a3@@ , unsigned int @@a4@@ ) { unsigned int @@v4@@ ; unsigned int @@v6@@ ; @@v6@@ = Number ; if ( ( @@a3@@ & Number ) != Number ) @@v6@@ = @@a4@@ ; @@v4@@ = openat ( @@a1@@ , @@a2@@ , @@a3@@ , @@v6@@ ) ; return fd_safer ( @@v4@@ ) ; }
int closedir ( DIR * @@dirp@@ ) { return closedir ( @@dirp@@ ) ; }
__int64 __fastcall enter_dir ( __int64 @@a1@@ , __int64 @@a2@@ ) { _QWORD * @@ptr@@ ; __int64 @@v4@@ ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { @@ptr@@ = malloc ( Number ) ; if ( ! @@ptr@@ ) return Number L ; * @@ptr@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@ptr@@ [ Number ] = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@ptr@@ [ Number ] = @@a2@@ ; @@v4@@ = hash_insert ( * ( _QWORD * ) ( @@a1@@ + Number ) , @@ptr@@ ) ; if ( ( _QWORD * ) @@v4@@ != @@ptr@@ ) { free ( @@ptr@@ ) ; if ( ! @@v4@@ ) return Number L ; * ( _QWORD * ) @@a2@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; * ( _WORD * ) ( @@a2@@ + Number ) = Number ; } } else if ( ( unsigned __int8 ) cycle_check ( * ( _QWORD * ) ( @@a1@@ + Number ) , @@a2@@ + Number ) ) { * ( _QWORD * ) @@a2@@ = @@a2@@ ; * ( _WORD * ) ( @@a2@@ + Number ) = Number ; } return Number L ; }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
unsigned __int64 __fastcall LCO_hash ( _QWORD * @@a1@@ , unsigned __int64 @@a2@@ ) { return * @@a1@@ % @@a2@@ ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
__int64 __fastcall i_ring_push ( __int64 @@a1@@ , int @@a2@@ ) { int @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = ( ( unsigned __int8 ) * ( _DWORD * ) ( @@a1@@ + Number ) + ( * ( _BYTE * ) ( @@a1@@ + Number ) ^ Number ) ) & Number ; @@v4@@ = * ( _DWORD * ) ( @@a1@@ + Number L * ( ( ( unsigned __int8 ) * ( _DWORD * ) ( @@a1@@ + Number ) + ( * ( _BYTE * ) ( @@a1@@ + Number ) ^ Number ) ) & Number ) ) ; * ( _DWORD * ) ( @@a1@@ + Number L * ( ( ( unsigned __int8 ) * ( _DWORD * ) ( @@a1@@ + Number ) + ( * ( _BYTE * ) ( @@a1@@ + Number ) ^ Number ) ) & Number ) ) = @@a2@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@v3@@ ; if ( @@v3@@ == * ( _DWORD * ) ( @@a1@@ + Number ) ) * ( _DWORD * ) ( @@a1@@ + Number ) = ( ( unsigned __int8 ) * ( _DWORD * ) ( @@a1@@ + Number ) + ( * ( _BYTE * ) ( @@a1@@ + Number ) ^ Number ) ) & Number ; * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; return @@v4@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
int __fxstat ( int @@ver@@ , int @@fildes@@ , struct stat * @@stat_buf@@ ) { return _fxstat ( @@ver@@ , @@fildes@@ , @@stat_buf@@ ) ; }
__int64 __fastcall link_count_optimize_ok ( __int64 @@a1@@ ) { __int64 @@result@@ ; bool @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; _BYTE * @@ptr@@ ; __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v3@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; if ( ( * ( _DWORD * ) ( @@v4@@ + Number ) & Number ) == Number ) return Number L ; if ( ! @@v3@@ ) { * ( _QWORD * ) ( @@v4@@ + Number ) = hash_initialize ( Number L , Number L , LCO_hash , LCO_compare , & free ) ; @@v3@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; if ( ! @@v3@@ ) return Number L ; } @@v8@@ [ Number ] = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v5@@ = hash_lookup ( @@v3@@ , @@v8@@ ) ; if ( @@v5@@ ) return * ( unsigned __int8 * ) ( @@v5@@ + Number ) ; @@ptr@@ = malloc ( Number ) ; if ( ! @@ptr@@ ) return Number L ; @@v2@@ = leaf_optimization_applies ( * ( _DWORD * ) ( @@v4@@ + Number ) ) ; @@ptr@@ [ Number ] = @@v2@@ ; * ( _QWORD * ) @@ptr@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v6@@ = hash_insert ( @@v3@@ , @@ptr@@ ) ; if ( @@v6@@ ) { if ( ( _BYTE * ) @@v6@@ != @@ptr@@ ) abort ( ) ; @@result@@ = @@v2@@ ; } else { free ( @@ptr@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
char * strdup ( const char * @@s@@ ) { return strdup ( @@s@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
__int64 __fastcall fts_palloc ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; unsigned __int64 @@v3@@ ; void * @@v4@@ ; @@v3@@ = * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ + Number ; if ( @@v3@@ >= * ( _QWORD * ) ( @@a1@@ + Number ) ) { * ( _QWORD * ) ( @@a1@@ + Number ) = @@v3@@ ; @@v4@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , * ( _QWORD * ) ( @@a1@@ + Number ) ) ; if ( @@v4@@ ) { * ( _QWORD * ) ( @@a1@@ + Number ) = @@v4@@ ; @@result@@ = Number L ; } else { free ( * ( void * * ) ( @@a1@@ + Number ) ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; @@result@@ = Number L ; } } else { free ( * ( void * * ) ( @@a1@@ + Number ) ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * __errno_location ( ) = Number ; @@result@@ = Number L ; } return @@result@@ ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_20F028 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall fts_safe_changedir ( __int64 @@a1@@ , __int64 @@a2@@ , int @@a3@@ , const char * @@a4@@ , int @@a5@@ , int @@a6@@ ) { bool @@v6@@ ; char * @@s1@@ ; char @@v10@@ ; unsigned int @@v11@@ ; int @@fildes@@ ; int @@v13@@ ; int @@v14@@ ; struct stat @@v15@@ ; unsigned __int64 @@v16@@ ; @@s1@@ = ( char * ) @@a4@@ ; @@v16@@ = __readfsqword ( Number ) ; @@v6@@ = @@a4@@ && ! strcmp ( @@a4@@ , String ) ; @@v10@@ = @@v6@@ ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number && @@a3@@ >= Number ) close ( @@a3@@ ) ; return Number L ; } if ( @@a3@@ < Number ) { if ( @@v10@@ ) { if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number && ( unsigned __int8 ) i_ring_empty ( @@a1@@ + Number ) != Number ) { @@v13@@ = i_ring_pop ( @@a1@@ + Number ) ; @@v10@@ = Number ; if ( @@v13@@ >= Number ) { @@a3@@ = @@v13@@ ; @@s1@@ = Number L ; } } } } @@fildes@@ = @@a3@@ ; if ( @@a3@@ < Number ) { @@fildes@@ = diropen ( @@a1@@ , ( int ) @@s1@@ , ( __int64 ) @@s1@@ , ( int ) @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( @@fildes@@ < Number ) return Number ; } if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) == Number && ( ! @@s1@@ || strcmp ( @@s1@@ , String ) ) ) goto LABEL_27 ; if ( ! ( unsigned int ) fstat ( @@fildes@@ , & @@v15@@ ) ) { if ( * ( _QWORD * ) ( @@a2@@ + Number ) != @@v15@@ . st_dev || * ( _QWORD * ) ( @@a2@@ + Number ) != @@v15@@ . st_ino ) { * __errno_location ( ) = Number ; @@v11@@ = Number ; goto LABEL_30 ; } LABEL_27 : if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { cwd_advance_fd ( @@a1@@ , @@fildes@@ , @@v10@@ == Number ) ; return Number L ; } @@v11@@ = fchdir ( @@fildes@@ ) ; goto LABEL_30 ; } @@v11@@ = Number ; LABEL_30 : if ( @@a3@@ < Number ) { @@v14@@ = * __errno_location ( ) ; close ( @@fildes@@ ) ; * __errno_location ( ) = @@v14@@ ; } return @@v11@@ ; }
void __fastcall cwrite ( char @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { const char * @@v3@@ ; int * @@v4@@ ; int @@v5@@ ; int @@v6@@ ; int @@v7@@ ; __int64 @@v8@@ ; char * @@v9@@ ; const char * @@v10@@ ; int * @@v11@@ ; const char * @@v12@@ ; int * @@v13@@ ; if ( @@a1@@ ) { if ( output_desc >= Number && close ( output_desc ) < Number ) { @@v3@@ = ( const char * ) outfile ; @@v4@@ = __errno_location ( ) ; error ( Number , * @@v4@@ , String , @@v3@@ ) ; } next_file_name ( ) ; if ( verbose ) { @@v8@@ = quote ( outfile ) ; @@v9@@ = gettext ( String ) ; fprintf ( stdout , @@v9@@ , @@v8@@ ) ; } output_desc = open_safer ( ( _DWORD ) outfile , Number , Number , @@v5@@ , @@v6@@ , @@v7@@ ) ; if ( output_desc < Number ) { @@v10@@ = ( const char * ) outfile ; @@v11@@ = __errno_location ( ) ; error ( Number , * @@v11@@ , String , @@v10@@ ) ; } } if ( @@a3@@ != full_write ( ( unsigned int ) output_desc , @@a2@@ , @@a3@@ ) ) { @@v12@@ = ( const char * ) outfile ; @@v13@@ = __errno_location ( ) ; error ( Number , * @@v13@@ , String , @@v12@@ ) ; } }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
bool __fastcall is_zero_or_power_of_two ( __int64 @@a1@@ ) { return ( @@a1@@ & ( @@a1@@ - Number ) ) == Number ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
unsigned __int64 __fastcall AD_hash ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) % @@a2@@ ; }
__int64 __fastcall full_read ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v5@@ ; __int64 @@v7@@ ; @@v5@@ = Number L ; while ( @@a3@@ ) { @@v7@@ = safe_read ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( @@v7@@ == Number ) break ; if ( ! @@v7@@ ) { * __errno_location ( ) = Number ; return @@v5@@ ; } @@v5@@ += @@v7@@ ; @@a2@@ += @@v7@@ ; @@a3@@ -= @@v7@@ ; } return @@v5@@ ; }
__int64 __fastcall hash_clear ( __int64 @@a1@@ ) { __int64 @@result@@ ; _QWORD * @@i@@ ; _QWORD * @@j@@ ; _QWORD * @@v4@@ ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = ( _QWORD * ) @@i@@ [ Number ] ; @@j@@ ; @@j@@ = @@v4@@ ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@j@@ ) ; * @@j@@ = Number L ; @@v4@@ = ( _QWORD * ) @@j@@ [ Number ] ; @@j@@ [ Number ] = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@j@@ ; } if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@i@@ ) ; * @@i@@ = Number L ; @@i@@ [ Number ] = Number L ; } } * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; @@result@@ = @@a1@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; return @@result@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 __fastcall rpl_fcntl ( int @@a1@@ , int @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , __m128 @@a7@@ , __m128 @@a8@@ , __m128 @@a9@@ , __m128 @@a10@@ , __m128 @@a11@@ , __m128 @@a12@@ , __m128 @@a13@@ , __m128 @@a14@@ ) { int @@v14@@ ; int @@v15@@ ; int @@v16@@ ; int @@v18@@ ; int @@v19@@ ; int @@v20@@ ; int @@v21@@ ; __int64 @@v22@@ ; __int64 @@v23@@ ; __int64 @@v24@@ ; __int64 @@v25@@ ; __m128 @@v26@@ ; __m128 @@v27@@ ; __m128 @@v28@@ ; __m128 @@v29@@ ; __m128 @@v30@@ ; __m128 @@v31@@ ; __m128 @@v32@@ ; __m128 @@v33@@ ; @@v22@@ = @@a3@@ ; @@v23@@ = @@a4@@ ; @@v24@@ = @@a5@@ ; @@v25@@ = @@a6@@ ; @@v26@@ = @@a7@@ ; @@v27@@ = @@a8@@ ; @@v28@@ = @@a9@@ ; @@v29@@ = @@a10@@ ; @@v30@@ = @@a11@@ ; @@v31@@ = @@a12@@ ; @@v32@@ = @@a13@@ ; @@v33@@ = @@a14@@ ; if ( @@a2@@ != Number ) return ( unsigned int ) fcntl ( @@a1@@ , @@a2@@ , @@v22@@ ) ; @@v19@@ = @@v22@@ ; if ( have_dupfd_cloexec_2895 < Number ) { @@v18@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v22@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; } else { @@v18@@ = fcntl ( @@a1@@ , Number , ( unsigned int ) @@v22@@ ) ; if ( @@v18@@ < Number && * __errno_location ( ) == Number ) { @@v18@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v19@@ , @@v14@@ , @@v15@@ , @@v16@@ ) ; if ( @@v18@@ < Number ) return ( unsigned int ) @@v18@@ ; have_dupfd_cloexec_2895 = Number ; } else { have_dupfd_cloexec_2895 = Number ; } } if ( @@v18@@ >= Number && have_dupfd_cloexec_2895 == Number ) { @@v20@@ = fcntl ( @@v18@@ , Number ) ; if ( @@v20@@ < Number || fcntl ( @@v18@@ , Number , @@v20@@ | Number ) == Number ) { @@v21@@ = * __errno_location ( ) ; close ( @@v18@@ ) ; * __errno_location ( ) = @@v21@@ ; @@v18@@ = Number ; } } return ( unsigned int ) @@v18@@ ; }
bool __fastcall is_basic ( unsigned __int8 @@a1@@ ) { return ( ( * ( ( _DWORD * ) & is_basic_table + ( @@a1@@ >> Number ) ) >> ( @@a1@@ & Number ) ) & Number ) != Number ; }
unsigned __int64 __fastcall leave_dir ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 * @@v3@@ ; __int64 * @@v4@@ ; void * @@ptr@@ ; __int64 @@v6@@ [ Number ] ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v3@@ = ( __int64 * ) ( @@a2@@ + Number ) ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { @@v6@@ [ Number ] = * @@v3@@ ; @@v6@@ [ Number ] = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@ptr@@ = ( void * ) hash_delete ( * ( _QWORD * ) ( @@a1@@ + Number ) , @@v6@@ ) ; if ( ! @@ptr@@ ) abort ( ) ; free ( @@ptr@@ ) ; } else { @@v4@@ = * ( __int64 * * ) ( @@a2@@ + Number ) ; if ( @@v4@@ && @@v4@@ [ Number ] >= Number ) { if ( ! * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L ) ) abort ( ) ; if ( * * ( _QWORD * * ) ( @@a1@@ + Number ) == * ( _QWORD * ) ( @@a2@@ + Number ) && * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L ) == * @@v3@@ ) { * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L ) = @@v4@@ [ Number ] ; * * ( _QWORD * * ) ( @@a1@@ + Number ) = @@v4@@ [ Number ] ; } } } return __readfsqword ( Number ) ^ @@v7@@ ; }
__int64 __fastcall i_ring_init ( __int64 @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; int @@i@@ ; * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; * ( _DWORD * ) ( @@a1@@ + Number ) = Number ; * ( _DWORD * ) ( @@a1@@ + Number ) = Number ; for ( @@i@@ = Number ; @@i@@ <= Number ; ++ @@i@@ ) * ( _DWORD * ) ( @@a1@@ + Number L * @@i@@ ) = @@a2@@ ; @@result@@ = @@a1@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_20F0E8 ; @@v8@@ [ Number ] = qword_20F0F0 ; @@v8@@ [ Number ] = qword_20F0F8 ; @@v8@@ [ Number ] = qword_20F100 ; @@v8@@ [ Number ] = qword_20F108 ; @@v8@@ [ Number ] = qword_20F110 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
bool __fastcall LCO_compare ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { return * @@a1@@ == * @@a2@@ ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
__int64 __fastcall i_ring_pop ( __int64 @@a1@@ ) { unsigned int @@v2@@ ; if ( ( unsigned __int8 ) i_ring_empty ( @@a1@@ ) ) abort ( ) ; @@v2@@ = * ( _DWORD * ) ( @@a1@@ + Number L * * ( unsigned int * ) ( @@a1@@ + Number ) ) ; * ( _DWORD * ) ( @@a1@@ + Number L * * ( unsigned int * ) ( @@a1@@ + Number ) ) = * ( _DWORD * ) ( @@a1@@ + Number ) ; if ( * ( _DWORD * ) ( @@a1@@ + Number ) == * ( _DWORD * ) ( @@a1@@ + Number ) ) * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; else * ( _DWORD * ) ( @@a1@@ + Number ) = ( ( unsigned __int8 ) * ( _DWORD * ) ( @@a1@@ + Number ) + Number ) & Number ; return @@v2@@ ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
char * __fastcall proper_name_utf8 ( const char * @@a1@@ , __int64 @@a2@@ ) { char * @@v2@@ ; char * @@result@@ ; size_t @@v4@@ ; size_t @@v5@@ ; char * @@ptr@@ ; char * @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; char * @@s1@@ ; char * @@s@@ ; size_t @@n@@ ; char * @@dest@@ ; char * @@v14@@ ; char * @@v15@@ ; char * @@v16@@ ; @@s1@@ = gettext ( @@a1@@ ) ; @@s@@ = ( char * ) locale_charset ( ) ; @@ptr@@ = Number L ; @@v7@@ = Number L ; @@v9@@ = Number L ; if ( ( unsigned int ) c_strcasecmp ( @@s@@ , String ) ) { @@ptr@@ = ( char * ) xstr_iconv ( @@a2@@ , String , @@s@@ ) ; @@v8@@ = ( __int64 ) @@ptr@@ ; @@n@@ = strlen ( @@s@@ ) ; @@dest@@ = ( char * ) xmalloc ( @@n@@ + Number ) ; memcpy ( @@dest@@ , @@s@@ , @@n@@ ) ; memcpy ( & @@dest@@ [ @@n@@ ] , String , Number ) ; @@v14@@ = ( char * ) xstr_iconv ( @@a2@@ , String , @@dest@@ ) ; free ( @@dest@@ ) ; if ( @@v14@@ ) { if ( strchr ( @@v14@@ , Number ) ) { free ( @@v14@@ ) ; } else { @@v7@@ = @@v14@@ ; @@v9@@ = ( __int64 ) @@v14@@ ; } } } else { @@v8@@ = @@a2@@ ; @@v9@@ = @@a2@@ ; } if ( @@v8@@ ) { @@v2@@ = ( char * ) @@v8@@ ; } else if ( @@v9@@ ) { @@v2@@ = ( char * ) @@v9@@ ; } else { @@v2@@ = ( char * ) @@a1@@ ; } @@v15@@ = @@v2@@ ; if ( ! strcmp ( @@s1@@ , @@a1@@ ) ) { if ( @@ptr@@ && @@ptr@@ != @@v15@@ ) free ( @@ptr@@ ) ; if ( @@v7@@ && @@v7@@ != @@v15@@ ) free ( @@v7@@ ) ; @@result@@ = @@v15@@ ; } else if ( ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@s1@@ , ( __int64 ) @@a1@@ ) || @@v8@@ && ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@s1@@ , @@v8@@ ) || @@v9@@ && ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@s1@@ , @@v9@@ ) ) { if ( @@ptr@@ ) free ( @@ptr@@ ) ; if ( @@v7@@ ) free ( @@v7@@ ) ; @@result@@ = @@s1@@ ; } else { @@v4@@ = strlen ( @@s1@@ ) ; @@v5@@ = strlen ( @@v15@@ ) ; @@v16@@ = ( char * ) xmalloc ( @@v4@@ + @@v5@@ + Number ) ; sprintf ( @@v16@@ , String , @@s1@@ , @@v15@@ ) ; if ( @@ptr@@ ) free ( @@ptr@@ ) ; if ( @@v7@@ ) free ( @@v7@@ ) ; @@result@@ = @@v16@@ ; } return @@result@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 __fastcall fts_set ( __int64 a1 , __int64 @@a2@@ , int @@a3@@ ) { __int64 @@result@@ ; if ( ! @@a3@@ || @@a3@@ == Number || @@a3@@ == Number || @@a3@@ == Number || @@a3@@ == Number ) { * ( _WORD * ) ( @@a2@@ + Number ) = @@a3@@ ; @@result@@ = Number L ; } else { * __errno_location ( ) = Number ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
__int64 __fastcall bkm_scale_by_power ( unsigned __int64 * @@a1@@ , int @@a2@@ , int @@a3@@ ) { unsigned int @@i@@ ; for ( @@i@@ = Number ; @@a3@@ -- ; @@i@@ |= bkm_scale ( @@a1@@ , @@a2@@ ) ) { ; } return @@i@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
__int64 __fastcall set_stat_type ( __int64 @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; int @@v3@@ ; switch ( @@a2@@ ) { case Number : @@v3@@ = Number ; break ; case Number : @@v3@@ = Number ; break ; case Number : @@v3@@ = Number ; break ; case Number : @@v3@@ = Number ; break ; case Number : @@v3@@ = Number ; break ; case Number : @@v3@@ = Number ; break ; case Number : @@v3@@ = Number ; break ; default : @@v3@@ = Number ; break ; } @@result@@ = @@a1@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@v3@@ ; return @@result@@ ; }
__int64 __fastcall set_cloexec_flag ( int @@a1@@ , char @@a2@@ , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { int @@v6@@ ; int @@v7@@ ; int @@v8@@ ; unsigned int @@v9@@ ; __int64 @@result@@ ; int @@v11@@ ; @@v11@@ = rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( @@v11@@ < Number || ( ! @@a2@@ ? ( @@v9@@ = @@v11@@ & Number ) : ( @@v9@@ = @@v11@@ | Number ) , @@v11@@ != @@v9@@ && ( unsigned int ) rpl_fcntl ( @@a1@@ , Number , @@v9@@ , @@v6@@ , @@v7@@ , @@v8@@ ) == Number ) ) { @@result@@ = Number ; } else { @@result@@ = Number L ; } return @@result@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_20E108 ; @@v4@@ [ Number ] = qword_20E110 ; @@v4@@ [ Number ] = qword_20E118 ; @@v4@@ [ Number ] = qword_20E120 ; @@v4@@ [ Number ] = qword_20E128 ; @@v4@@ [ Number ] = qword_20E130 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
__int64 __fastcall fts_compar ( __int64 @@a1@@ , __int64 @@a2@@ ) { return ( * ( __int64 ( __fastcall * * ) ( __int64 , __int64 ) ) ( * ( _QWORD * ) ( * ( _QWORD * ) @@a1@@ + Number L ) + Number L ) ) ( @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 __fastcall umaxtostr ( unsigned __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v4@@ ; @@v4@@ = @@a2@@ + Number ; * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; do { * ( _BYTE * ) -- @@v4@@ = @@a1@@ % Number + Number ; @@a1@@ /= Number ; } while ( @@a1@@ ) ; return @@v4@@ ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 __fastcall fts_sort ( __int64 @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { size_t @@v3@@ ; _QWORD * @@v5@@ ; __int64 @@i@@ ; _QWORD * @@v7@@ ; _QWORD * @@v8@@ ; __int64 @@v9@@ ; int ( * @@compar@@ ( ) ( constvoid , constvoid ) ) ( const void * , const void * ) ; void * @@v11@@ ; @@v3@@ = @@a3@@ ; @@compar@@ ( ) ( constvoid , constvoid ) = * ( int ( * * ) ( const void * , const void * ) ) ( @@a1@@ + Number ) ; if ( @@a3@@ > * ( _QWORD * ) ( @@a1@@ + Number ) ) { * ( _QWORD * ) ( @@a1@@ + Number ) = @@a3@@ + Number ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) > Number || ( @@v11@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number L * * ( _QWORD * ) ( @@a1@@ + Number ) ) ) == Number L ) { free ( * ( void * * ) ( @@a1@@ + Number ) ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; return @@a2@@ ; } * ( _QWORD * ) ( @@a1@@ + Number ) = @@v11@@ ; } @@v5@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; for ( @@i@@ = @@a2@@ ; @@i@@ ; @@i@@ = * ( _QWORD * ) ( @@i@@ + Number ) ) { @@v7@@ = @@v5@@ ++ ; * @@v7@@ = @@i@@ ; } qsort ( * ( void * * ) ( @@a1@@ + Number ) , @@v3@@ , Number , @@compar@@ ( ) ( constvoid , constvoid ) ) ; @@v8@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; @@v9@@ = * @@v8@@ ; while ( -- @@v3@@ ) { * ( _QWORD * ) ( * @@v8@@ + Number L ) = @@v8@@ [ Number ] ; ++ @@v8@@ ; } * ( _QWORD * ) ( * @@v8@@ + Number L ) = Number L ; return @@v9@@ ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
void * __fastcall xzalloc ( size_t @@a1@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@a1@@ ) ; return memset ( @@v1@@ , Number , @@a1@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_20F0E8 ; @@v4@@ [ Number ] = qword_20F0F0 ; @@v4@@ [ Number ] = qword_20F0F8 ; @@v4@@ [ Number ] = qword_20F100 ; @@v4@@ [ Number ] = qword_20F108 ; @@v4@@ [ Number ] = qword_20F110 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
__int64 __fastcall hash_get_next ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; _QWORD * @@v4@@ ; _QWORD * @@i@@ ; @@v2@@ = * @@a1@@ ; @@v4@@ = ( _QWORD * ) ( @@v2@@ + Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) ) ; if ( ( unsigned __int64 ) @@v4@@ >= @@a1@@ [ Number ] ) abort ( ) ; for ( @@i@@ = @@v4@@ ; @@i@@ ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { if ( @@a2@@ == * @@i@@ && @@i@@ [ Number ] ) return * ( _QWORD * ) @@i@@ [ Number ] ; } while ( Number ) { @@v4@@ += Number ; if ( ( unsigned __int64 ) @@v4@@ >= @@a1@@ [ Number ] ) break ; if ( * @@v4@@ ) return * @@v4@@ ; } return Number L ; }
__int64 __fastcall bkm_scale_0 ( unsigned __int64 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( is_mul_ok ( @@a2@@ , * @@a1@@ ) ) { * @@a1@@ *= @@a2@@ ; @@result@@ = Number L ; } else { * @@a1@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_206028 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
unsigned __int64 __fastcall hash_string ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ ) { unsigned __int64 @@v4@@ ; @@v4@@ = Number L ; while ( * @@a1@@ ) @@v4@@ = ( Number * @@v4@@ + ( unsigned __int8 ) * @@a1@@ ++ ) % @@a2@@ ; return @@v4@@ ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
__int64 __fastcall mb_copy ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; if ( * ( _QWORD * ) @@a2@@ == @@a2@@ + Number ) { memcpy ( ( void * ) ( @@a1@@ + Number ) , ( const void * ) ( @@a2@@ + Number ) , * ( _QWORD * ) ( @@a2@@ + Number ) ) ; * ( _QWORD * ) @@a1@@ = @@a1@@ + Number ; } else { * ( _QWORD * ) @@a1@@ = * ( _QWORD * ) @@a2@@ ; } * ( _QWORD * ) ( @@a1@@ + Number ) = * ( _QWORD * ) ( @@a2@@ + Number ) ; * ( _BYTE * ) ( @@a1@@ + Number ) = * ( _BYTE * ) ( @@a2@@ + Number ) ; @@result@@ = * ( unsigned __int8 * ) ( @@a1@@ + Number ) ; if ( ( _BYTE ) @@result@@ ) { @@result@@ = @@a1@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = * ( _DWORD * ) ( @@a2@@ + Number ) ; } return @@result@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
_BOOL8 __fastcall cycle_warning_required ( __int64 @@a1@@ , __int64 @@a2@@ ) { return ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number && ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) == Number || ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number && ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number && * ( _QWORD * ) ( @@a2@@ + Number ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
void * __fastcall mdir_name ( _BYTE * @@a1@@ ) { _BYTE * @@n@@ ; void * @@dest@@ ; @@n@@ = dir_len ( @@a1@@ ) ; @@dest@@ = malloc ( ( size_t ) & @@n@@ [ ( @@n@@ == Number L ) + Number ] ) ; if ( ! @@dest@@ ) return Number L ; memcpy ( @@dest@@ , @@a1@@ , ( size_t ) @@n@@ ) ; if ( ! @@n@@ ) { @@n@@ = ( _BYTE * ) ( & dword_0 + Number ) ; * ( _BYTE * ) @@dest@@ = Number ; } @@n@@ [ ( _QWORD ) @@dest@@ ] = Number ; return @@dest@@ ; }
__int64 __fastcall fd_safer ( int @@a1@@ ) { unsigned int @@fd@@ ; unsigned int @@v3@@ ; int @@v4@@ ; @@fd@@ = @@a1@@ ; if ( @@a1@@ >= Number && @@a1@@ <= Number ) { @@v3@@ = dup_safer ( ( unsigned int ) @@a1@@ ) ; @@v4@@ = * __errno_location ( ) ; close ( @@a1@@ ) ; * __errno_location ( ) = @@v4@@ ; @@fd@@ = @@v3@@ ; } return @@fd@@ ; }
__int64 __fastcall next_prime ( unsigned __int64 @@a1@@ ) { __int64 @@v2@@ ; __int64 @@i@@ ; @@v2@@ = @@a1@@ ; if ( @@a1@@ <= Number ) @@v2@@ = Number L ; for ( @@i@@ = @@v2@@ | Number ; @@i@@ != Number && ! is_prime ( @@i@@ ) ; @@i@@ += Number L ) { ; } return @@i@@ ; }
_BOOL8 __fastcall c_isascii ( int @@a1@@ ) { return @@a1@@ >= Number && @@a1@@ <= Number ; }
__int64 __fastcall cycle_check ( __int64 @@a1@@ , _QWORD * @@a2@@ ) { if ( * ( _DWORD * ) ( @@a1@@ + Number ) != Number ) __assert_fail ( String , String , Number , String ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) && @@a2@@ [ Number ] == * ( _QWORD * ) @@a1@@ && * @@a2@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ) { return Number L ; } if ( is_zero_or_power_of_two ( ++ * ( _QWORD * ) ( @@a1@@ + Number ) ) ) { if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = * @@a2@@ ; * ( _QWORD * ) @@a1@@ = @@a2@@ [ Number ] ; } return Number L ; }
int getc_unlocked ( FILE * @@stream@@ ) { return getc_unlocked ( @@stream@@ ) ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
_BOOL8 __fastcall c_isblank ( int @@a1@@ ) { return @@a1@@ == Number || @@a1@@ == Number ; }
void __fastcall hash_free ( __int64 @@a1@@ ) { _QWORD * @@i@@ ; _QWORD * @@j@@ ; _QWORD * @@ptr@@ ; _QWORD * @@ptra@@ ; _QWORD * @@ptrb@@ ; _QWORD * @@v6@@ ; _QWORD * @@v7@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) && * ( _QWORD * ) ( @@a1@@ + Number ) ) { for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@ptr@@ = @@i@@ ; @@ptr@@ ; @@ptr@@ = ( _QWORD * ) @@ptr@@ [ Number ] ) { ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@ptr@@ ) ; } } } } for ( @@j@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@j@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@j@@ += Number ) { for ( @@ptra@@ = ( _QWORD * ) @@j@@ [ Number ] ; @@ptra@@ ; @@ptra@@ = @@v6@@ ) { @@v6@@ = ( _QWORD * ) @@ptra@@ [ Number ] ; free ( @@ptra@@ ) ; } } for ( @@ptrb@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; @@ptrb@@ ; @@ptrb@@ = @@v7@@ ) { @@v7@@ = ( _QWORD * ) @@ptrb@@ [ Number ] ; free ( @@ptrb@@ ) ; } free ( * ( void * * ) @@a1@@ ) ; free ( ( void * ) @@a1@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_206028 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
_BOOL8 __fastcall c_islower ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
char * nl_langinfo ( nl_item @@item@@ ) { return nl_langinfo ( @@item@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
_BOOL8 __fastcall c_ispunct ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number && ( @@a1@@ <= Number || @@a1@@ > Number ) && ( ( int ) ( @@a1@@ & Number ) <= Number || ( int ) ( @@a1@@ & Number ) > Number ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
__int64 __fastcall transfer_entries ( __int64 @@a1@@ , __int64 @@a2@@ , char @@a3@@ ) { __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 * @@i@@ ; _QWORD * @@j@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; _QWORD * @@v11@@ ; _QWORD * @@v12@@ ; _QWORD * @@v13@@ ; _QWORD * @@v14@@ ; for ( @@i@@ = * ( __int64 * * ) @@a2@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a2@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = ( _QWORD * ) @@i@@ [ Number ] ; @@j@@ ; @@j@@ = @@v14@@ ) { @@v9@@ = * @@j@@ ; @@v3@@ = * ( _QWORD * ) @@a1@@ ; @@v11@@ = ( _QWORD * ) ( @@v3@@ + Number * ( * ( __int64 ( __fastcall * * ) ( _QWORD , _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@j@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@v11@@ >= * ( _QWORD * ) ( @@a1@@ + Number ) ) abort ( ) ; @@v14@@ = ( _QWORD * ) @@j@@ [ Number ] ; if ( * @@v11@@ ) { @@j@@ [ Number ] = @@v11@@ [ Number ] ; @@v11@@ [ Number ] = @@j@@ ; } else { * @@v11@@ = @@v9@@ ; ++ * ( _QWORD * ) ( @@a1@@ + Number ) ; free_entry ( @@a1@@ , @@j@@ ) ; } } @@v10@@ = * @@i@@ ; @@i@@ [ Number ] = Number L ; if ( ! @@a3@@ ) { @@v4@@ = * ( _QWORD * ) @@a1@@ ; @@v12@@ = ( _QWORD * ) ( @@v4@@ + Number * ( * ( __int64 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@v10@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@v12@@ >= * ( _QWORD * ) ( @@a1@@ + Number ) ) abort ( ) ; if ( * @@v12@@ ) { @@v13@@ = allocate_entry ( @@a1@@ ) ; if ( ! @@v13@@ ) return Number L ; * @@v13@@ = @@v10@@ ; @@v13@@ [ Number ] = @@v12@@ [ Number ] ; @@v12@@ [ Number ] = @@v13@@ ; } else { * @@v12@@ = @@v10@@ ; ++ * ( _QWORD * ) ( @@a1@@ + Number ) ; } * @@i@@ = Number L ; -- * ( _QWORD * ) ( @@a2@@ + Number ) ; } } } return Number L ; }
__int64 __fastcall c_tolower ( int @@a1@@ ) { __int64 @@result@@ ; if ( @@a1@@ <= Number || @@a1@@ > Number ) @@result@@ = ( unsigned int ) @@a1@@ ; else @@result@@ = ( unsigned int ) ( @@a1@@ + Number ) ; return @@result@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; FILE * @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; __int64 @@v13@@ ; char * @@v14@@ ; if ( @@a1@@ ) { @@v1@@ = program_name ; @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = program_name ; @@v4@@ = program_name ; @@v5@@ = gettext ( String ) ; printf ( @@v5@@ , @@v4@@ , @@v3@@ ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String String String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; @@v8@@ = stdout ; @@v9@@ = gettext ( String ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = stdout ; @@v11@@ = gettext ( String ) ; fputs_unlocked ( @@v11@@ , @@v10@@ ) ; @@v12@@ = program_name ; @@v13@@ = program_name ; @@v14@@ = gettext ( String ) ; printf ( @@v14@@ , @@v13@@ , @@v12@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
__int64 __fastcall open_safer ( const char * @@a1@@ , char @@a2@@ , unsigned int @@a3@@ ) { unsigned int @@v3@@ ; unsigned int @@v5@@ ; @@v5@@ = Number ; if ( ( @@a2@@ & Number ) != Number ) @@v5@@ = @@a3@@ ; @@v3@@ = open ( @@a1@@ , @@a2@@ , @@v5@@ ) ; return fd_safer ( @@v3@@ ) ; }
bool __fastcall is_basic_2 ( unsigned __int8 @@a1@@ ) { return ( ( * ( ( _DWORD * ) & is_basic_table + ( @@a1@@ >> Number ) ) >> ( @@a1@@ & Number ) ) & Number ) != Number ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
int iswalnum ( wint_t @@wc@@ ) { return iswalnum ( @@wc@@ ) ; }
__int64 __fastcall lines_split ( unsigned __int64 @@a1@@ , char * @@a2@@ , __int64 @@a3@@ ) { const char * @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; char @@v7@@ ; void * @@s@@ ; char * @@sa@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; __int64 @@v12@@ ; char * @@v13@@ ; @@v7@@ = Number ; @@v11@@ = Number L ; do { @@v12@@ = full_read ( Number L , @@a2@@ , @@a3@@ ) ; if ( @@v12@@ == Number ) { @@v3@@ = infile ; @@v4@@ = __errno_location ( ) ; error ( Number , * @@v4@@ , String , @@v3@@ ) ; } @@v10@@ = ( __int64 ) @@a2@@ ; @@s@@ = @@a2@@ ; @@v13@@ = & @@a2@@ [ @@v12@@ ] ; @@a2@@ [ @@v12@@ ] = Number ; while ( Number ) { @@sa@@ = ( char * ) memchr ( @@s@@ , Number , @@v13@@ - ( _BYTE * ) @@s@@ + Number ) ; if ( @@sa@@ == @@v13@@ ) break ; @@s@@ = @@sa@@ + Number ; if ( ++ @@v11@@ >= @@a1@@ ) { cwrite ( @@v7@@ , @@v10@@ , ( __int64 ) @@s@@ - @@v10@@ ) ; @@v10@@ = ( __int64 ) @@s@@ ; @@v7@@ = Number ; @@v11@@ = Number L ; } } if ( @@v13@@ != ( char * ) @@v10@@ ) { cwrite ( @@v7@@ , @@v10@@ , ( __int64 ) & @@v13@@ [ - @@v10@@ ] ) ; @@v7@@ = Number ; } @@result@@ = @@v12@@ ; } while ( @@v12@@ == @@a3@@ ) ; return @@result@@ ; }
size_t __fastcall mbslen ( const char * @@a1@@ ) { __int64 @@v3@@ ; char @@v4@@ [ Number ] ; int @@v5@@ ; char @@i@@ ; const char * @@v7@@ ; __int64 @@v8@@ ; char @@v9@@ ; int @@v10@@ ; unsigned __int64 @@v11@@ ; @@v11@@ = __readfsqword ( Number ) ; if ( __ctype_get_mb_cur_max ( ) <= Number ) return strlen ( @@a1@@ ) ; @@v3@@ = Number L ; @@v7@@ = @@a1@@ ; @@v4@@ [ Number ] = Number ; memset ( & @@v5@@ , Number , Number ) ; for ( @@i@@ = Number ; ; @@i@@ = Number ) { mbuiter_multi_next_1 ( ( __int64 ) @@v4@@ ) ; if ( @@v9@@ == Number && ! @@v10@@ ) break ; ++ @@v3@@ ; @@v7@@ += @@v8@@ ; } return @@v3@@ ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
__int64 __fastcall xstr_iconv ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v4@@ ; @@v4@@ = str_iconv ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( ! @@v4@@ && * __errno_location ( ) == Number ) xalloc_die ( ) ; return @@v4@@ ; }
int iconv_close ( iconv_t @@cd@@ ) { return iconv_close ( @@cd@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 __fastcall bkm_scale_by_power ( unsigned __int64 * @@a1@@ , int @@a2@@ , int @@a3@@ ) { unsigned int @@i@@ ; for ( @@i@@ = Number ; @@a3@@ -- ; @@i@@ |= bkm_scale ( @@a1@@ , @@a2@@ ) ) ; return @@i@@ ; }
__int64 __fastcall bad_cast ( __int64 @@a1@@ ) { return @@a1@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , off_B136 , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; char * @@v3@@ ; FILE * @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; FILE * @@v11@@ ; char * @@v12@@ ; FILE * @@v13@@ ; char * @@v14@@ ; @@v1@@ = program_name ; if ( @@a1@@ ) { @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = gettext ( String ) ; printf ( @@v3@@ , @@v1@@ ) ; @@v4@@ = stdout ; @@v5@@ = gettext ( String String String String ) ; fputs_unlocked ( @@v5@@ , @@v4@@ ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; @@v8@@ = gettext ( String String String String String ) ; fprintf ( stdout , @@v8@@ , Number L ) ; @@v9@@ = stdout ; @@v10@@ = gettext ( String String ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; @@v11@@ = stdout ; @@v12@@ = gettext ( String ) ; fputs_unlocked ( @@v12@@ , @@v11@@ ) ; @@v13@@ = stdout ; @@v14@@ = gettext ( String ) ; fputs_unlocked ( @@v14@@ , @@v13@@ ) ; emit_size_note ( ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
__int64 __fastcall bsd_sum_file ( const char * @@a1@@ , int @@a2@@ ) { int @@v2@@ ; int @@i@@ ; int * @@v4@@ ; int * @@v6@@ ; const char * @@v7@@ ; _BYTE @@v8@@ [ Number ] ; FILE * @@stream@@ ; __int64 @@v10@@ ; char @@v11@@ [ Number ] ; unsigned __int64 @@v12@@ ; @@v12@@ = __readfsqword ( Number ) ; @@v8@@ [ Number ] = Number ; @@v10@@ = Number L ; @@v2@@ = strcmp ( @@a1@@ , String ) ; * ( _DWORD * ) @@v8@@ = @@v2@@ == Number ; if ( @@v2@@ ) { @@stream@@ = fopen ( @@a1@@ , String ) ; if ( @@stream@@ ) goto LABEL_6 ; goto LABEL_4 ; } @@stream@@ = stdin ; have_read_stdin = Number ; for ( @@i@@ = getc_unlocked ( stdin ) ; @@i@@ != Number ; @@i@@ = getc_unlocked ( @@stream@@ ) ) { ++ @@v10@@ ; * ( _DWORD * ) & @@v8@@ [ Number ] = ( unsigned __int16 ) ( @@i@@ + ( * ( int * ) & @@v8@@ [ Number ] >> Number ) + ( * ( _WORD * ) & @@v8@@ [ Number ] << Number ) ) ; LABEL_6 : ; } if ( ferror_unlocked ( @@stream@@ ) ) { @@v6@@ = __errno_location ( ) ; error ( Number , * @@v6@@ , String , @@a1@@ ) ; if ( @@v8@@ [ Number ] != Number ) fclose ( @@stream@@ ) ; return Number L ; } if ( @@v8@@ [ Number ] != Number && fclose ( @@stream@@ ) ) { LABEL_4 : @@v4@@ = __errno_location ( ) ; error ( Number , * @@v4@@ , String , @@a1@@ ) ; return Number L ; } @@v7@@ = ( const char * ) human_readable ( @@v10@@ , @@v11@@ , Number L , Number L , Number L ) ; printf ( String , * ( unsigned int * ) & @@v8@@ [ Number ] , @@v7@@ ) ; if ( @@a2@@ > Number ) printf ( String , @@a1@@ ) ; putchar_unlocked ( Number ) ; return Number L ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
void __fastcall line_bytes_split ( __int64 @@a1@@ ) { const char * @@v1@@ ; int * @@v2@@ ; char @@v3@@ ; _BYTE * @@src@@ ; size_t @@n@@ ; size_t @@na@@ ; _BYTE * @@dest@@ ; __int64 @@v8@@ ; @@v3@@ = Number ; @@n@@ = Number L ; @@dest@@ = ( _BYTE * ) xmalloc ( @@a1@@ ) ; do { @@v8@@ = full_read ( Number L , & @@dest@@ [ @@n@@ ] , @@a1@@ - @@n@@ ) ; if ( @@v8@@ == Number ) { @@v1@@ = infile ; @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v1@@ ) ; } @@na@@ = @@v8@@ + @@n@@ ; if ( @@na@@ != @@a1@@ ) { if ( ! @@na@@ ) break ; @@v3@@ = Number ; } @@src@@ = & @@dest@@ [ @@na@@ ] ; if ( @@na@@ == @@a1@@ ) { while ( @@src@@ > @@dest@@ && * ( @@src@@ - Number ) != Number ) -- @@src@@ ; } if ( @@src@@ == @@dest@@ ) @@src@@ = & @@dest@@ [ @@na@@ ] ; cwrite ( Number , ( __int64 ) @@dest@@ , @@src@@ - @@dest@@ ) ; @@n@@ = @@na@@ - ( @@src@@ - @@dest@@ ) ; if ( @@n@@ ) memmove ( @@dest@@ , @@src@@ , @@n@@ ) ; } while ( @@v3@@ != Number ) ; free ( @@dest@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
__int64 __fastcall umaxtostr ( unsigned __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v4@@ ; @@v4@@ = @@a2@@ + Number ; * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; do { * ( _BYTE * ) -- @@v4@@ = @@a1@@ % Number + Number ; @@a1@@ /= Number ; } while ( @@a1@@ ) ; return @@v4@@ ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_2060C8 ; @@v4@@ [ Number ] = qword_2060D0 ; @@v4@@ [ Number ] = qword_2060D8 ; @@v4@@ [ Number ] = qword_2060E0 ; @@v4@@ [ Number ] = qword_2060E8 ; @@v4@@ [ Number ] = qword_2060F0 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_20E038 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
__int64 __fastcall xstr_cd_iconv ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v3@@ ; @@v3@@ = str_cd_iconv ( @@a1@@ , @@a2@@ ) ; if ( ! @@v3@@ && * __errno_location ( ) == Number ) xalloc_die ( ) ; return @@v3@@ ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , off_67E2 , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
bool __fastcall is_basic_1 ( unsigned __int8 @@a1@@ ) { return ( ( * ( ( _DWORD * ) & is_basic_table + ( @@a1@@ >> Number ) ) >> ( @@a1@@ & Number ) ) & Number ) != Number ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( is_mul_ok ( @@a2@@ , * @@a1@@ ) ) { * @@a1@@ *= @@a2@@ ; @@result@@ = Number L ; } else { * @@a1@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
__int64 __fastcall xfts_open ( const char * * @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { unsigned int @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; __int64 @@v7@@ ; @@v3@@ = @@a2@@ ; BYTE1 ( @@v3@@ ) = BYTE1 ( @@a2@@ ) | Number ; @@v4@@ = @@v3@@ ; @@v7@@ = fts_open ( @@a1@@ , @@v3@@ , @@a3@@ ) ; if ( ! @@v7@@ ) { if ( * __errno_location ( ) == Number ) __assert_fail ( String , String , Number , String ) ; xalloc_die ( @@a1@@ , @@v4@@ , @@v5@@ ) ; } return @@v7@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
char * __fastcall str_iconv ( char * @@a1@@ , char * @@a2@@ , char * @@a3@@ ) { char * @@result@@ ; int @@v5@@ ; int @@v6@@ ; iconv_t @@cd@@ ; void * @@ptr@@ ; char * @@v9@@ ; if ( * @@a1@@ && ( unsigned int ) c_strcasecmp ( ( unsigned __int8 * ) @@a2@@ , ( unsigned __int8 * ) @@a3@@ ) ) { @@cd@@ = iconv_open ( @@a3@@ , @@a2@@ ) ; if ( @@cd@@ == ( iconv_t ) Number ) return Number L ; @@ptr@@ = str_cd_iconv ( @@a1@@ , @@cd@@ ) ; if ( @@ptr@@ ) { if ( iconv_close ( @@cd@@ ) < Number ) { @@v5@@ = * __errno_location ( ) ; free ( @@ptr@@ ) ; * __errno_location ( ) = @@v5@@ ; return Number L ; } } else { @@v6@@ = * __errno_location ( ) ; iconv_close ( @@cd@@ ) ; * __errno_location ( ) = @@v6@@ ; } @@result@@ = ( char * ) @@ptr@@ ; } else { @@v9@@ = strdup ( @@a1@@ ) ; if ( ! @@v9@@ ) * __errno_location ( ) = Number ; @@result@@ = @@v9@@ ; } return @@result@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
__int64 __fastcall dup_safer ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
_BOOL8 __fastcall c_isalpha ( int @@a1@@ ) { return ( int ) ( @@a1@@ & Number ) > Number && ( int ) ( @@a1@@ & Number ) <= Number ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 __fastcall fd_safer ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { unsigned int @@fd@@ ; unsigned int @@v8@@ ; int @@v9@@ ; @@fd@@ = @@a1@@ ; if ( @@a1@@ >= Number && @@a1@@ <= Number ) { @@v8@@ = dup_safer ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; @@v9@@ = * __errno_location ( ) ; close ( @@a1@@ ) ; * __errno_location ( ) = @@v9@@ ; @@fd@@ = @@v8@@ ; } return @@fd@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
_BOOL8 __fastcall c_iscntrl ( int @@a1@@ ) { return ( @@a1@@ & Number ) == Number || @@a1@@ == Number ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
void * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
void next_file_name ( ) { char * @@v1@@ ; size_t @@i@@ ; size_t @@n@@ ; size_t @@v4@@ ; if ( outfile ) { for ( @@i@@ = suffix_length ; @@i@@ -- ; * ( ( _BYTE * ) outfile_mid + @@i@@ ) = suffix_alphabet [ Number ] [ * ( _QWORD * ) ( Number * @@i@@ + sufindex_5550 ) ] ) { * ( ( _BYTE * ) outfile_mid + @@i@@ ) = suffix_alphabet [ Number ] [ ++ * ( _QWORD * ) ( Number * @@i@@ + sufindex_5550 ) ] ; if ( * ( ( _BYTE * ) outfile_mid + @@i@@ ) ) return ; * ( _QWORD * ) ( Number * @@i@@ + sufindex_5550 ) = Number L ; } @@v1@@ = gettext ( String ) ; error ( Number , Number , @@v1@@ ) ; } else { @@n@@ = strlen ( outbase ) ; @@v4@@ = suffix_length + @@n@@ ; if ( @@n@@ > suffix_length + @@n@@ + Number ) xalloc_die ( ) ; outfile = ( void * ) xmalloc ( @@v4@@ + Number ) ; outfile_mid = ( char * ) outfile + @@n@@ ; memcpy ( outfile , outbase , @@n@@ ) ; memset ( outfile_mid , * suffix_alphabet [ Number ] , suffix_length ) ; * ( ( _BYTE * ) outfile + @@v4@@ ) = Number ; sufindex_5550 = xcalloc ( suffix_length , Number L ) ; } }
_BOOL8 __fastcall c_isgraph ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
void * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
void * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
void * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
int putchar_unlocked ( int @@c@@ ) { return putchar_unlocked ( @@c@@ ) ; }
_BOOL8 __fastcall c_isspace ( int @@a1@@ ) { return @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number ; }
bool __fastcall is_basic_0 ( unsigned __int8 @@a1@@ ) { return ( ( * ( ( _DWORD * ) & is_basic_table + ( @@a1@@ >> Number ) ) >> ( @@a1@@ & Number ) ) & Number ) != Number ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
__int64 __fastcall c_toupper ( int @@a1@@ ) { __int64 @@result@@ ; if ( @@a1@@ <= Number || @@a1@@ > Number ) @@result@@ = ( unsigned int ) @@a1@@ ; else @@result@@ = ( unsigned int ) ( @@a1@@ - Number ) ; return @@result@@ ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
ssize_t __fastcall safe_read ( int @@a1@@ , void * @@a2@@ , size_t @@a3@@ ) { ssize_t @@result@@ ; ssize_t @@v5@@ ; LABEL_1 : for ( @@result@@ = read ( @@a1@@ , @@a2@@ , @@a3@@ ) ; ; @@result@@ = read ( @@a1@@ , @@a2@@ , Number ) ) { @@v5@@ = @@result@@ ; if ( @@result@@ >= Number ) break ; if ( * __errno_location ( ) == Number ) goto LABEL_1 ; if ( * __errno_location ( ) != Number || @@a3@@ <= Number ) return @@v5@@ ; @@a3@@ = Number L ; } return @@result@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
void __fastcall freea ( unsigned __int64 @@a1@@ ) { _QWORD * @@i@@ ; if ( @@a1@@ && * ( _DWORD * ) ( @@a1@@ - Number ) == Number ) { for ( @@i@@ = & mmalloca_results [ @@a1@@ % Number ] ; * @@i@@ ; @@i@@ = ( _QWORD * ) ( * @@i@@ - Number L ) ) { if ( @@a1@@ == * @@i@@ ) { * @@i@@ = * ( _QWORD * ) ( @@a1@@ - Number ) ; free ( ( void * ) ( @@a1@@ - Number ) ) ; return ; } } } }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
int __cdecl __noreturn main ( int @@argc@@ , const char * * @@argv@@ , const char * * @@envp@@ ) { char * @@v3@@ ; __int64 @@v4@@ ; char * @@v5@@ ; const char * @@ptr@@ ; __int64 @@n@@ ; set_program_name ( * @@argv@@ , @@argv@@ , @@envp@@ ) ; setlocale ( Number , & locale ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; parse_long_options ( @@argc@@ , ( _DWORD ) @@argv@@ , ( unsigned int ) String , ( unsigned int ) String , ( _DWORD ) Version , ( unsigned int ) usage , String , String , Number L ) ; if ( getopt_long ( @@argc@@ , ( char * const * ) @@argv@@ , String , Number L , Number L ) != Number ) usage ( Number ) ; if ( @@argc@@ < optind + Number ) { @@v3@@ = gettext ( String ) ; error ( Number , Number , @@v3@@ ) ; usage ( Number ) ; } if ( @@argc@@ > optind + Number ) { @@v4@@ = quote ( @@argv@@ [ optind + Number ] ) ; @@v5@@ = gettext ( String ) ; error ( Number , Number , @@v5@@ , @@v4@@ ) ; usage ( Number ) ; } @@ptr@@ = @@argv@@ [ optind ] ; @@n@@ = dir_len ( @@ptr@@ ) ; if ( ! @@n@@ ) { @@ptr@@ = String ; @@n@@ = Number L ; } fwrite_unlocked ( @@ptr@@ , Number , @@n@@ , stdout ) ; putchar_unlocked ( Number ) ; exit ( Number ) ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return xmalloc ( @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
ssize_t __fastcall safe_read ( int @@a1@@ , void * @@a2@@ , size_t @@a3@@ ) { ssize_t @@result@@ ; ssize_t @@v5@@ ; LABEL_1 : for ( @@result@@ = read ( @@a1@@ , @@a2@@ , @@a3@@ ) ; ; @@result@@ = read ( @@a1@@ , @@a2@@ , Number ) ) { @@v5@@ = @@result@@ ; if ( @@result@@ >= Number ) break ; if ( * __errno_location ( ) == Number ) goto LABEL_1 ; if ( * __errno_location ( ) != Number || @@a3@@ <= Number ) return @@v5@@ ; @@a3@@ = Number L ; } return @@result@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
int getc_unlocked ( FILE * @@stream@@ ) { return getc_unlocked ( @@stream@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ ) { return xmalloc ( @@a1@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( is_mul_ok ( @@a2@@ , * @@a1@@ ) ) { * @@a1@@ *= @@a2@@ ; @@result@@ = Number L ; } else { * @@a1@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_2060C8 ; @@v8@@ [ Number ] = qword_2060D0 ; @@v8@@ [ Number ] = qword_2060D8 ; @@v8@@ [ Number ] = qword_2060E0 ; @@v8@@ [ Number ] = qword_2060E8 ; @@v8@@ [ Number ] = qword_2060F0 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( ) ; return @@ptr@@ ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
__int64 __fastcall _xargmatch_internal ( __int64 @@a1@@ , const char * @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ , void ( * @@a6@@ ) ( void ) ) { __int64 @@v11@@ ; @@v11@@ = argmatch ( @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; if ( @@v11@@ >= Number ) return @@v11@@ ; argmatch_invalid ( @@a1@@ , ( __int64 ) @@a2@@ , @@v11@@ ) ; argmatch_valid ( @@a3@@ , @@a4@@ , @@a5@@ ) ; @@a6@@ ( ) ; return Number ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_20E108 ; @@v8@@ [ Number ] = qword_20E110 ; @@v8@@ [ Number ] = qword_20E118 ; @@v8@@ [ Number ] = qword_20E120 ; @@v8@@ [ Number ] = qword_20E128 ; @@v8@@ [ Number ] = qword_20E130 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
void * __fastcall quote_n ( int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number , @@a2@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
__int64 __fastcall xnrealloc ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { if ( ! is_mul_ok ( @@a3@@ , @@a2@@ ) ) xalloc_die ( ) ; return xrealloc ( @@a1@@ , @@a3@@ * @@a2@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall bkm_scale_by_power_0 ( unsigned __int64 * @@a1@@ , int @@a2@@ , int @@a3@@ ) { unsigned int @@i@@ ; for ( @@i@@ = Number ; @@a3@@ -- ; @@i@@ |= bkm_scale_0 ( @@a1@@ , @@a2@@ ) ) { ; } return @@i@@ ; }
void * __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@v2@@ ; @@v2@@ = malloc ( @@a1@@ ) ; if ( ! @@v2@@ && @@a1@@ ) xalloc_die ( ) ; return @@v2@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
const char * locale_charset ( ) { const char * @@s1@@ ; char * @@s2@@ ; char * @@s2a@@ ; @@s1@@ = nl_langinfo ( Number ) ; if ( ! @@s1@@ ) @@s1@@ = ( const char * ) & unk_B60E ; for ( @@s2@@ = ( char * ) get_charset_aliases ( ) ; * @@s2@@ ; @@s2@@ = & @@s2a@@ [ strlen ( @@s2a@@ ) + Number ] ) { if ( ! strcmp ( @@s1@@ , @@s2@@ ) || * @@s2@@ == Number && ! @@s2@@ [ Number ] ) { @@s1@@ = & @@s2@@ [ strlen ( @@s2@@ ) + Number ] ; break ; } @@s2a@@ = & @@s2@@ [ strlen ( @@s2@@ ) + Number ] ; } if ( ! * @@s1@@ ) @@s1@@ = String ; return @@s1@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@v3@@ ; @@v3@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v3@@ ) xalloc_die ( ) ; return @@v3@@ ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
__int64 __fastcall fd_reopen ( int @@a1@@ , const char * @@a2@@ , int @@a3@@ , unsigned int @@a4@@ ) { int @@fd@@ ; unsigned int @@v6@@ ; int @@v7@@ ; @@fd@@ = open ( @@a2@@ , @@a3@@ , @@a4@@ ) ; if ( @@fd@@ == @@a1@@ || @@fd@@ < Number ) return ( unsigned int ) @@fd@@ ; @@v6@@ = dup2 ( @@fd@@ , @@a1@@ ) ; @@v7@@ = * __errno_location ( ) ; close ( @@fd@@ ) ; * __errno_location ( ) = @@v7@@ ; return @@v6@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 __fastcall create_fullname ( char * @@a1@@ , const char * @@a2@@ ) { const unsigned __int16 * @@v2@@ ; unsigned __int8 @@v3@@ ; char @@v4@@ ; char * @@v5@@ ; const char * @@v6@@ ; char * @@v7@@ ; char * @@v8@@ ; char * @@s@@ ; size_t @@v11@@ ; char * @@v12@@ ; const char * @@v13@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; __int64 @@v16@@ ; @@s@@ = @@a1@@ ; @@v11@@ = strlen ( @@a1@@ ) + Number ; @@v14@@ = count_ampersands ( @@a1@@ ) ; if ( @@v14@@ ) { @@v15@@ = strlen ( @@a2@@ ) ; @@v11@@ += @@v15@@ * @@v14@@ - @@v14@@ ; if ( ! is_mul_ok ( @@v14@@ , @@v15@@ ) || @@v11@@ < @@v15@@ * @@v14@@ ) { xalloc_die ( @@a2@@ , @@a2@@ , ( ( unsigned __int64 ) @@v14@@ * ( unsigned __int128 ) @@v15@@ ) >> Number ) ; } } @@v16@@ = xmalloc ( @@v11@@ ) ; @@v12@@ = ( char * ) @@v16@@ ; while ( * @@s@@ ) { if ( * @@s@@ == Number ) { @@v13@@ = @@a2@@ ; @@v2@@ = * __ctype_b_loc ( ) ; if ( ( @@v2@@ [ ( unsigned __int8 ) to_uchar ( * @@a2@@ ) ] & Number ) != Number ) { @@v13@@ = @@a2@@ + Number ; @@v3@@ = to_uchar ( * @@a2@@ ) ; @@v4@@ = toupper ( @@v3@@ ) ; @@v5@@ = @@v12@@ ++ ; * @@v5@@ = @@v4@@ ; } while ( * @@v13@@ ) { @@v6@@ = @@v13@@ ++ ; @@v7@@ = @@v12@@ ++ ; * @@v7@@ = * @@v6@@ ; } } else { @@v8@@ = @@v12@@ ++ ; * @@v8@@ = * @@s@@ ; } ++ @@s@@ ; } * @@v12@@ = Number ; return @@v16@@ ; }
_BOOL8 __fastcall c_isalnum ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number || ( int ) ( @@a1@@ & Number ) > Number && ( int ) ( @@a1@@ & Number ) <= Number ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
__int64 __fastcall sysv_sum_file ( const char * @@a1@@ , int @@a2@@ ) { int @@v2@@ ; int * @@v3@@ ; __int64 @@result@@ ; int * @@v5@@ ; int * @@v6@@ ; const char * @@v7@@ ; bool @@v8@@ ; unsigned int @@fd@@ ; unsigned int @@v10@@ ; __int64 @@v11@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@v13@@ ; char @@v14@@ [ Number ] ; char @@v15@@ [ Number ] ; unsigned __int64 @@v16@@ ; @@v16@@ = __readfsqword ( Number ) ; @@v11@@ = Number L ; @@v10@@ = Number ; @@v2@@ = strcmp ( @@a1@@ , String ) ; @@v8@@ = @@v2@@ == Number ; if ( ! @@v2@@ ) { @@fd@@ = Number ; have_read_stdin = Number ; goto LABEL_5 ; } @@fd@@ = open ( @@a1@@ , Number ) ; if ( @@fd@@ == Number ) { @@v3@@ = __errno_location ( ) ; error ( Number , * @@v3@@ , String , @@a1@@ ) ; @@result@@ = Number L ; } else { LABEL_5 : while ( Number ) { @@v13@@ = safe_read ( @@fd@@ , @@v15@@ , Number ) ; if ( ! @@v13@@ ) break ; if ( @@v13@@ == Number ) { @@v5@@ = __errno_location ( ) ; error ( Number , * @@v5@@ , String , @@a1@@ ) ; if ( ! @@v8@@ ) close ( @@fd@@ ) ; return Number L ; } for ( @@i@@ = Number L ; @@i@@ < @@v13@@ ; ++ @@i@@ ) @@v10@@ += ( unsigned __int8 ) @@v15@@ [ @@i@@ ] ; @@v11@@ += @@v13@@ ; } if ( ! @@v8@@ && close ( @@fd@@ ) ) { @@v6@@ = __errno_location ( ) ; error ( Number , * @@v6@@ , String , @@a1@@ ) ; @@result@@ = Number L ; } else { @@v7@@ = ( const char * ) human_readable ( @@v11@@ , @@v14@@ , Number L , Number L , Number L ) ; printf ( String , ( ( int ) ( HIWORD ( @@v10@@ ) + ( unsigned __int16 ) @@v10@@ ) >> Number ) + ( unsigned int ) ( unsigned __int16 ) ( HIWORD ( @@v10@@ ) + @@v10@@ ) , @@v7@@ ) ; if ( @@a2@@ ) printf ( String , @@a1@@ ) ; putchar_unlocked ( Number ) ; @@result@@ = Number L ; } } return @@result@@ ; }
__int64 __fastcall knuth_morris_pratt_unibyte ( _BYTE * @@a1@@ , char * @@a2@@ , _QWORD * @@a3@@ ) { void * @@v3@@ ; unsigned __int64 @@v4@@ ; _QWORD * @@v6@@ ; char * @@s@@ ; _BYTE * @@v8@@ ; char @@v9@@ ; unsigned __int64 @@i@@ ; __int64 @@v11@@ ; __int64 @@v12@@ ; _BYTE * @@v13@@ ; _BYTE * @@v14@@ ; size_t @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v8@@ = @@a1@@ ; @@s@@ = @@a2@@ ; @@v6@@ = @@a3@@ ; @@v17@@ = __readfsqword ( Number ) ; @@v15@@ = strlen ( @@a2@@ ) ; if ( @@v15@@ > Number ) { @@v4@@ = Number L ; } else if ( Number * @@v15@@ > Number ) { @@v4@@ = mmalloca ( Number * @@v15@@ ) ; } else { @@v3@@ = alloca ( Number * ( ( Number * ( @@v15@@ + Number ) + Number ) / Number ) ) ; @@v4@@ = Number * ( ( ( unsigned __int64 ) & @@v6@@ + Number ) >> Number ) + Number ; } @@v16@@ = @@v4@@ ; if ( ! @@v4@@ ) return Number L ; * ( _QWORD * ) ( @@v16@@ + Number ) = Number L ; @@v11@@ = Number L ; for ( @@i@@ = Number L ; @@i@@ < @@v15@@ ; ++ @@i@@ ) { @@v9@@ = @@s@@ [ @@i@@ - Number ] ; while ( Number ) { if ( @@v9@@ == @@s@@ [ @@v11@@ ] ) { ++ @@v11@@ ; * ( _QWORD * ) ( @@v16@@ + Number * @@i@@ ) = @@i@@ - @@v11@@ ; goto LABEL_15 ; } if ( ! @@v11@@ ) break ; @@v11@@ -= * ( _QWORD * ) ( Number * @@v11@@ + @@v16@@ ) ; } * ( _QWORD * ) ( @@v16@@ + Number * @@i@@ ) = @@i@@ ; LABEL_15 : ; } * @@v6@@ = Number L ; @@v12@@ = Number L ; @@v13@@ = @@v8@@ ; @@v14@@ = @@v8@@ ; while ( * @@v14@@ ) { if ( @@s@@ [ @@v12@@ ] == * @@v14@@ ) { ++ @@v12@@ ; ++ @@v14@@ ; if ( @@v12@@ == @@v15@@ ) { * @@v6@@ = @@v13@@ ; break ; } } else if ( @@v12@@ ) { @@v13@@ += * ( _QWORD * ) ( Number * @@v12@@ + @@v16@@ ) ; @@v12@@ -= * ( _QWORD * ) ( Number * @@v12@@ + @@v16@@ ) ; } else { ++ @@v13@@ ; ++ @@v14@@ ; } } freea ( @@v16@@ ) ; return Number L ; }
_BOOL8 __fastcall c_isdigit ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
int iswspace ( wint_t @@wc@@ ) { return iswspace ( @@wc@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
_BOOL8 __fastcall c_isprint ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
__int64 __fastcall rpl_fcntl ( int @@a1@@ , int @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , __m128 @@a7@@ , __m128 @@a8@@ , __m128 @@a9@@ , __m128 @@a10@@ , __m128 @@a11@@ , __m128 @@a12@@ , __m128 @@a13@@ , __m128 @@a14@@ ) { int @@v14@@ ; int @@v15@@ ; int @@v16@@ ; int @@v18@@ ; int @@v19@@ ; int @@v20@@ ; int @@v21@@ ; __int64 @@v22@@ ; __int64 @@v23@@ ; __int64 @@v24@@ ; __int64 @@v25@@ ; __m128 @@v26@@ ; __m128 @@v27@@ ; __m128 @@v28@@ ; __m128 @@v29@@ ; __m128 @@v30@@ ; __m128 @@v31@@ ; __m128 @@v32@@ ; __m128 @@v33@@ ; @@v22@@ = @@a3@@ ; @@v23@@ = @@a4@@ ; @@v24@@ = @@a5@@ ; @@v25@@ = @@a6@@ ; @@v26@@ = @@a7@@ ; @@v27@@ = @@a8@@ ; @@v28@@ = @@a9@@ ; @@v29@@ = @@a10@@ ; @@v30@@ = @@a11@@ ; @@v31@@ = @@a12@@ ; @@v32@@ = @@a13@@ ; @@v33@@ = @@a14@@ ; if ( @@a2@@ != Number ) return ( unsigned int ) fcntl ( @@a1@@ , @@a2@@ , @@v22@@ ) ; @@v19@@ = @@v22@@ ; if ( have_dupfd_cloexec_2895 < Number ) { @@v18@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v22@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; } else { @@v18@@ = fcntl ( @@a1@@ , Number , ( unsigned int ) @@v22@@ ) ; if ( @@v18@@ < Number && * __errno_location ( ) == Number ) { @@v18@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v19@@ , @@v14@@ , @@v15@@ , @@v16@@ ) ; if ( @@v18@@ < Number ) return ( unsigned int ) @@v18@@ ; have_dupfd_cloexec_2895 = Number ; } else { have_dupfd_cloexec_2895 = Number ; } } if ( @@v18@@ >= Number && have_dupfd_cloexec_2895 == Number ) { @@v20@@ = fcntl ( @@v18@@ , Number ) ; if ( @@v20@@ < Number || fcntl ( @@v18@@ , Number , @@v20@@ | Number ) == Number ) { @@v21@@ = * __errno_location ( ) ; close ( @@v18@@ ) ; * __errno_location ( ) = @@v21@@ ; @@v18@@ = Number ; } } return ( unsigned int ) @@v18@@ ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
_BOOL8 __fastcall c_isupper ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
long double __fastcall adjust_value ( int @@a1@@ , long double @@a2@@ ) { _BOOL4 @@v7@@ ; unsigned __int64 @@v9@@ ; if ( @@a1@@ != Number && @@a2@@ < Number ) { if ( @@a2@@ >= Number ) @@v9@@ = ( __int64 ) ( @@a2@@ - Number ) ^ Number ; else @@v9@@ = ( __int64 ) @@a2@@ ; @@v7@@ = ! @@a1@@ && @@a2@@ != ( long double ) @@v9@@ ; @@a2@@ = ( long double ) ( @@v7@@ + @@v9@@ ) ; } return @@a2@@ ; }
_BOOL8 __fastcall c_isxdigit ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number || ( int ) ( @@a1@@ & Number ) > Number && ( int ) ( @@a1@@ & Number ) <= Number ; }
__int64 __fastcall io_blksize ( __int64 a1 , __int64 a2 , __int64 a3 , __int64 a4 , __int64 a5 , __int64 a6 , int a7 , int a8 , int a9 , int a10 , int a11 , int a12 , int a13 , __int64 @@a14@@ ) { __int64 @@result@@ ; if ( @@a14@@ <= Number || ( unsigned __int64 ) @@a14@@ > Number || @@a14@@ <= Number ) { @@result@@ = Number ; } else { @@result@@ = @@a14@@ ; } return @@result@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; _bss_start = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
__int64 __fastcall imaxtostr ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = @@a1@@ ; @@v4@@ = @@a2@@ + Number ; * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; if ( @@a1@@ >= Number ) { do { * ( _BYTE * ) -- @@v4@@ = ( char ) @@v3@@ % Number + Number ; @@v3@@ /= Number L ; } while ( @@v3@@ ) ; } else { do { * ( _BYTE * ) -- @@v4@@ = Number - ( char ) @@v3@@ % Number ; @@v3@@ /= Number L ; } while ( @@v3@@ ) ; * ( _BYTE * ) -- @@v4@@ = Number ; } return @@v4@@ ; }
__int64 __fastcall human_options ( char * @@a1@@ , int * @@a2@@ , _QWORD * @@a3@@ ) { unsigned int @@v5@@ ; @@v5@@ = humblock ( @@a1@@ , @@a3@@ , @@a2@@ ) ; if ( ! * @@a3@@ ) { * @@a3@@ = default_block_size ( ) ; @@v5@@ = Number ; } return @@v5@@ ; }
unsigned __int64 __fastcall mmalloca ( unsigned __int64 @@a1@@ ) { char * @@v2@@ ; unsigned __int64 @@v3@@ ; if ( @@a1@@ + Number < @@a1@@ ) return Number L ; @@v2@@ = ( char * ) malloc ( @@a1@@ + Number ) ; if ( ! @@v2@@ ) return Number L ; @@v3@@ = ( unsigned __int64 ) ( @@v2@@ + Number ) ; * ( _DWORD * ) ( @@v3@@ - Number ) = Number ; * ( _QWORD * ) ( @@v3@@ - Number ) = mmalloca_results [ @@v3@@ % Number ] ; mmalloca_results [ @@v3@@ % Number ] = @@v3@@ ; return @@v3@@ ; }
__int64 __fastcall bytes_split ( unsigned __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { const char * @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; char @@v7@@ ; unsigned __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; @@v7@@ = Number ; @@v9@@ = @@a1@@ ; do { @@v11@@ = full_read ( Number L , @@a2@@ , @@a3@@ ) ; if ( @@v11@@ == Number ) { @@v3@@ = infile ; @@v4@@ = __errno_location ( ) ; error ( Number , * @@v4@@ , String , @@v3@@ ) ; } @@v10@@ = @@a2@@ ; @@v8@@ = @@v11@@ ; while ( @@v8@@ >= @@v9@@ ) { cwrite ( @@v7@@ , @@v10@@ , @@v9@@ ) ; @@v10@@ += @@v9@@ ; @@v8@@ -= @@v9@@ ; @@v7@@ = Number ; @@v9@@ = @@a1@@ ; } if ( @@v8@@ ) { cwrite ( @@v7@@ , @@v10@@ , @@v8@@ ) ; @@v9@@ -= @@v8@@ ; @@v7@@ = Number ; } @@result@@ = @@v11@@ ; } while ( @@v11@@ == @@a3@@ ) ; return @@result@@ ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
__int64 __fastcall dup_safer ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
char * __fastcall group_number ( char * @@a1@@ , size_t @@a2@@ , unsigned __int8 * @@a3@@ , const char * @@a4@@ ) { char * @@i@@ ; size_t @@v5@@ ; char * @@v6@@ ; unsigned __int8 @@v10@@ ; size_t @@v11@@ ; size_t @@v12@@ ; size_t @@v13@@ ; char @@dest@@ [ Number ] ; unsigned __int64 @@v15@@ ; @@v15@@ = __readfsqword ( Number ) ; @@v11@@ = Number ; @@v13@@ = strlen ( @@a4@@ ) ; @@v12@@ = @@a2@@ ; memcpy ( @@dest@@ , @@a1@@ , @@a2@@ ) ; for ( @@i@@ = & @@a1@@ [ @@a2@@ ] ; ; memcpy ( @@i@@ , @@a4@@ , @@v13@@ ) ) { @@v10@@ = * @@a3@@ ; if ( * @@a3@@ ) { if ( @@v10@@ > Number ) @@v5@@ = @@v12@@ ; else @@v5@@ = @@v10@@ ; @@v11@@ = @@v5@@ ; ++ @@a3@@ ; } if ( @@v12@@ < @@v11@@ ) @@v11@@ = @@v12@@ ; @@v6@@ = & @@i@@ [ - @@v11@@ ] ; @@v12@@ -= @@v11@@ ; memcpy ( @@v6@@ , & @@dest@@ [ @@v12@@ ] , @@v11@@ ) ; if ( ! @@v12@@ ) break ; @@i@@ = & @@v6@@ [ - @@v13@@ ] ; } return @@v6@@ ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_208038 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
int __fastcall fstat ( int @@fildes@@ , struct stat * @@stat_buf@@ ) { return __fxstat ( Number , @@fildes@@ , @@stat_buf@@ ) ; }
__int64 __fastcall full_write ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v5@@ ; __int64 @@v7@@ ; @@v5@@ = Number L ; while ( @@a3@@ ) { @@v7@@ = safe_write ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( @@v7@@ == Number ) break ; if ( ! @@v7@@ ) { * __errno_location ( ) = Number ; return @@v5@@ ; } @@v5@@ += @@v7@@ ; @@a2@@ += @@v7@@ ; @@a3@@ -= @@v7@@ ; } return @@v5@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
void * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
const char * __fastcall proper_name ( const char * @@a1@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; char * @@s@@ ; char * @@v5@@ ; @@s@@ = gettext ( @@a1@@ ) ; if ( @@s@@ == @@a1@@ ) return @@a1@@ ; if ( ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@s@@ , ( __int64 ) @@a1@@ ) ) return @@s@@ ; @@v2@@ = strlen ( @@s@@ ) ; @@v3@@ = strlen ( @@a1@@ ) ; @@v5@@ = ( char * ) xmalloc ( @@v2@@ + @@v3@@ + Number ) ; sprintf ( @@v5@@ , String , @@s@@ , @@a1@@ ) ; return @@v5@@ ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_208188 ; @@v4@@ [ Number ] = qword_208190 ; @@v4@@ [ Number ] = qword_208198 ; @@v4@@ [ Number ] = qword_2081A0 ; @@v4@@ [ Number ] = qword_2081A8 ; @@v4@@ [ Number ] = qword_2081B0 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
void * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall strnlen1 ( const void * @@a1@@ , size_t @@a2@@ ) { __int64 @@result@@ ; _BYTE * @@v3@@ ; @@v3@@ = memchr ( @@a1@@ , Number , @@a2@@ ) ; if ( @@v3@@ ) @@result@@ = @@v3@@ - ( _BYTE * ) @@a1@@ + Number ; else @@result@@ = @@a2@@ ; return @@result@@ ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_208028 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = ( __int64 * ) & slotvec0 ; } nslots = Number ; return @@result@@ ; }
__int64 __fastcall read_utmp ( const char * @@a1@@ , _QWORD * @@a2@@ , _QWORD * @@a3@@ , char @@a4@@ ) { __int64 @@v4@@ ; _QWORD * @@v5@@ ; struct utmpx * @@v6@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; __int64 @@v12@@ ; struct utmpx * @@v13@@ ; unsigned __int64 @@v14@@ ; @@v14@@ = __readfsqword ( Number ) ; @@v11@@ = Number L ; @@v10@@ = Number L ; @@v12@@ = Number L ; utmpxname ( @@a1@@ ) ; setutxent ( ) ; while ( Number ) { @@v13@@ = getutxent ( ) ; if ( ! @@v13@@ ) break ; if ( desirable_utmp_entry ( ( __int64 ) @@v13@@ , @@a4@@ ) ) { if ( @@v11@@ == @@v10@@ ) @@v12@@ = x2nrealloc ( @@v12@@ , & @@v10@@ , Number L ) ; @@v4@@ = @@v11@@ ++ ; @@v5@@ = ( _QWORD * ) ( Number * @@v4@@ + @@v12@@ ) ; @@v6@@ = @@v13@@ ; * @@v5@@ = * ( _QWORD * ) & @@v13@@ -> ut_type ; @@v5@@ [ Number ] = * ( _QWORD * ) & @@v6@@ -> __unused [ Number ] ; qmemcpy ( ( void * ) ( ( unsigned __int64 ) ( @@v5@@ + Number ) & Number ) , ( const void * ) ( ( char * ) @@v6@@ - ( ( char * ) @@v5@@ - ( ( unsigned __int64 ) ( @@v5@@ + Number ) & Number ) ) ) , Number L * ( ( ( ( _DWORD ) @@v5@@ - ( ( ( _DWORD ) @@v5@@ + Number ) & Number ) + Number ) & Number ) >> Number ) ) ; } } endutxent ( ) ; * @@a2@@ = @@v11@@ ; * @@a3@@ = @@v12@@ ; return Number L ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
void * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
void * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_2080C8 ; @@v4@@ [ Number ] = qword_2080D0 ; @@v4@@ [ Number ] = qword_2080D8 ; @@v4@@ [ Number ] = qword_2080E0 ; @@v4@@ [ Number ] = qword_2080E8 ; @@v4@@ [ Number ] = qword_2080F0 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; char * @@v3@@ ; FILE * @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; FILE * @@v10@@ ; char * @@v11@@ ; @@v1@@ = program_name ; if ( @@a1@@ ) { @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = gettext ( String ) ; printf ( @@v3@@ , @@v1@@ ) ; @@v4@@ = stdout ; @@v5@@ = gettext ( String String String String ) ; fputs_unlocked ( @@v5@@ , @@v4@@ ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; @@v8@@ = stdout ; @@v9@@ = gettext ( String ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = stdout ; @@v11@@ = gettext ( String ) ; fputs_unlocked ( @@v11@@ , @@v10@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
void * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
int __cdecl __noreturn main ( int @@argc@@ , const char * * @@argv@@ , const char * * @@envp@@ ) { int * @@v3@@ ; char @@v4@@ ; int @@v5@@ ; unsigned int @@v6@@ ; __int64 ( __fastcall * @@v7@@ ( ) ( constchar , int ) ) ( const char * , int ) ; @@v7@@ ( ) ( constchar , int ) = bsd_sum_file ; set_program_name ( * @@argv@@ , @@argv@@ , @@envp@@ ) ; setlocale ( Number , & locale ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; setvbuf ( stdout , Number L , Number , Number L ) ; have_read_stdin = Number ; while ( Number ) { @@v5@@ = getopt_long ( @@argc@@ , ( char * const * ) @@argv@@ , String , & longopts , Number L ) ; if ( @@v5@@ == Number ) { @@v6@@ = @@argc@@ - optind ; if ( @@argc@@ - optind > Number ) { @@v4@@ = Number ; while ( @@argc@@ > optind ) { @@v4@@ = ( unsigned __int8 ) ( @@v4@@ & @@v7@@ ( ) ( constchar , int ) ( @@argv@@ [ optind ] , @@v6@@ ) ) != Number ; ++ optind ; } } else { @@v4@@ = @@v7@@ ( ) ( constchar , int ) ( String , @@v6@@ ) ; } if ( have_read_stdin ) { if ( fclose ( stdin ) == Number ) { @@v3@@ = __errno_location ( ) ; error ( Number , * @@v3@@ , String ) ; } } exit ( ( unsigned __int8 ) @@v4@@ ^ Number ) ; } if ( @@v5@@ == Number ) usage ( Number ) ; if ( @@v5@@ <= Number ) break ; if ( @@v5@@ == Number ) { @@v7@@ ( ) ( constchar , int ) = bsd_sum_file ; } else { if ( @@v5@@ != Number ) goto LABEL_13 ; @@v7@@ ( ) ( constchar , int ) = sysv_sum_file ; } } if ( @@v5@@ == Number ) { version_etc ( ( _DWORD ) stdout , ( unsigned int ) String , ( unsigned int ) String , ( _DWORD ) Version , ( unsigned int ) String , ( unsigned int ) String , Number ) ; exit ( Number ) ; } LABEL_13 : usage ( Number ) ; }
__int64 __fastcall open_safer ( const char * @@a1@@ , char @@a2@@ , unsigned int @@a3@@ ) { unsigned int @@v3@@ ; unsigned int @@v5@@ ; @@v5@@ = Number ; if ( ( @@a2@@ & Number ) != Number ) @@v5@@ = @@a3@@ ; @@v3@@ = open ( @@a1@@ , @@a2@@ , @@v5@@ ) ; return fd_safer ( @@v3@@ ) ; }
void * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_2080C8 ; @@v8@@ [ Number ] = qword_2080D0 ; @@v8@@ [ Number ] = qword_2080D8 ; @@v8@@ [ Number ] = qword_2080E0 ; @@v8@@ [ Number ] = qword_2080E8 ; @@v8@@ [ Number ] = qword_2080F0 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
void __fastcall argmatch_invalid ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { char * @@v3@@ ; __int64 @@v4@@ ; void * @@v5@@ ; char * @@format@@ ; if ( @@a3@@ == Number ) @@v3@@ = gettext ( String ) ; else @@v3@@ = gettext ( String ) ; @@format@@ = @@v3@@ ; @@v4@@ = quote_n ( Number L , @@a1@@ ) ; @@v5@@ = quotearg_n_style ( Number , Number , @@a2@@ ) ; error ( Number , Number , @@format@@ , @@v5@@ , @@v4@@ ) ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; FILE * @@v10@@ ; char * @@v11@@ ; FILE * @@v12@@ ; char * @@v13@@ ; FILE * @@v14@@ ; char * @@v15@@ ; FILE * @@v16@@ ; char * @@v17@@ ; if ( @@a1@@ ) { @@v1@@ = program_name ; @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = program_name ; @@v4@@ = program_name ; @@v5@@ = gettext ( String ) ; printf ( @@v5@@ , @@v4@@ , @@v3@@ ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String String String String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; @@v8@@ = stdout ; @@v9@@ = gettext ( String ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = stdout ; @@v11@@ = gettext ( String String String String ) ; fputs_unlocked ( @@v11@@ , @@v10@@ ) ; @@v12@@ = stdout ; @@v13@@ = gettext ( String ) ; fputs_unlocked ( @@v13@@ , @@v12@@ ) ; @@v14@@ = stdout ; @@v15@@ = gettext ( String ) ; fputs_unlocked ( @@v15@@ , @@v14@@ ) ; @@v16@@ = stdout ; @@v17@@ = gettext ( String String String String String String ) ; fputs_unlocked ( @@v17@@ , @@v16@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
__int64 __fastcall argmatch ( const char * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { __int64 @@result@@ ; char @@v7@@ ; __int64 @@i@@ ; __int64 @@v9@@ ; size_t @@n@@ ; @@v9@@ = Number ; @@v7@@ = Number ; @@n@@ = strlen ( @@a1@@ ) ; for ( @@i@@ = Number L ; * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; ++ @@i@@ ) { if ( ! strncmp ( * ( const char * * ) ( Number * @@i@@ + @@a2@@ ) , @@a1@@ , @@n@@ ) ) { if ( @@n@@ == strlen ( * ( const char * * ) ( Number * @@i@@ + @@a2@@ ) ) ) return @@i@@ ; if ( @@v9@@ == Number ) { @@v9@@ = @@i@@ ; } else if ( ! @@a3@@ || memcmp ( ( const void * ) ( @@a4@@ * @@v9@@ + @@a3@@ ) , ( const void * ) ( @@i@@ * @@a4@@ + @@a3@@ ) , @@a4@@ ) ) { @@v7@@ = Number ; } } } if ( @@v7@@ ) @@result@@ = Number ; else @@result@@ = @@v9@@ ; return @@result@@ ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
const char * __fastcall proper_name ( const char * @@a1@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; char * @@s@@ ; char * @@v5@@ ; @@s@@ = gettext ( @@a1@@ ) ; if ( @@s@@ == @@a1@@ ) return @@a1@@ ; if ( ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@s@@ , ( __int64 ) @@a1@@ ) ) return @@s@@ ; @@v2@@ = strlen ( @@s@@ ) ; @@v3@@ = strlen ( @@a1@@ ) ; @@v5@@ = ( char * ) xmalloc ( @@v2@@ + @@v3@@ + Number ) ; sprintf ( @@v5@@ , String , @@s@@ , @@a1@@ ) ; return @@v5@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
__int64 __fastcall xstr_cd_iconv ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v3@@ ; @@v3@@ = str_cd_iconv ( @@a1@@ , @@a2@@ ) ; if ( ! @@v3@@ && * __errno_location ( ) == Number ) xalloc_die ( ) ; return @@v3@@ ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_20E038 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
void * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
struct passwd * getpwnam ( const char * @@name@@ ) { return getpwnam ( @@name@@ ) ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
ssize_t __fastcall safe_write ( int @@a1@@ , const void * @@a2@@ , size_t @@a3@@ ) { ssize_t @@result@@ ; ssize_t @@v5@@ ; LABEL_1 : for ( @@result@@ = write ( @@a1@@ , @@a2@@ , @@a3@@ ) ; ; @@result@@ = write ( @@a1@@ , @@a2@@ , Number ) ) { @@v5@@ = @@result@@ ; if ( @@result@@ >= Number ) break ; if ( * __errno_location ( ) == Number ) goto LABEL_1 ; if ( * __errno_location ( ) != Number || @@a3@@ <= Number ) return @@v5@@ ; @@a3@@ = Number L ; } return @@result@@ ; }
int __xstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _xstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
__int64 __fastcall count_ampersands ( _BYTE * @@a1@@ ) { _BYTE * @@v1@@ ; __int64 @@v4@@ ; @@v4@@ = Number L ; do { if ( * @@a1@@ == Number ) ++ @@v4@@ ; @@v1@@ = @@a1@@ ++ ; } while ( * @@v1@@ ) ; return @@v4@@ ; }
__int64 __fastcall bkm_scale_by_power ( unsigned __int64 * @@a1@@ , int @@a2@@ , int @@a3@@ ) { unsigned int @@i@@ ; for ( @@i@@ = Number ; @@a3@@ -- ; @@i@@ |= bkm_scale ( @@a1@@ , @@a2@@ ) ) ; return @@i@@ ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
char * strdup ( const char * @@s@@ ) { return strdup ( @@s@@ ) ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v4@@ ; @@v4@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v4@@ >= Number / @@a3@@ ) xalloc_die ( ) ; @@v4@@ += ( @@v4@@ + Number ) >> Number ; } else if ( ! @@v4@@ ) { @@v4@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v4@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v4@@ ) ; }
int __fastcall argmatch_valid ( __int64 @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { char * @@v3@@ ; __int64 @@i@@ ; void * @@s1@@ ; @@s1@@ = Number L ; @@v3@@ = gettext ( String ) ; fprintf ( stderr , @@v3@@ ) ; for ( @@i@@ = Number L ; * ( _QWORD * ) ( Number * @@i@@ + @@a1@@ ) ; ++ @@i@@ ) { if ( @@i@@ && ! memcmp ( @@s1@@ , ( const void * ) ( @@i@@ * @@a3@@ + @@a2@@ ) , @@a3@@ ) ) { fprintf ( stderr , String , * ( const char * * ) ( Number * @@i@@ + @@a1@@ ) ) ; } else { fprintf ( stderr , String , * ( const char * * ) ( Number * @@i@@ + @@a1@@ ) ) ; @@s1@@ = ( void * ) ( @@i@@ * @@a3@@ + @@a2@@ ) ; } } return putc_unlocked ( Number , stderr ) ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_20C038 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
__int64 __fastcall scan_entries ( __int64 @@a1@@ , const char * @@a2@@ , int @@a3@@ , __int64 @@a4@@ ) { __int64 @@result@@ ; int @@i@@ ; if ( ( unsigned __int8 ) hard_locale ( Number L ) ) { time_format = String ; time_format_width = Number ; } else { time_format = String ; time_format_width = Number ; } if ( include_heading ) print_heading ( ) ; while ( Number ) { @@result@@ = @@a1@@ -- ; if ( ! @@result@@ ) return @@result@@ ; if ( @@a2@@ [ Number ] && * ( _WORD * ) @@a2@@ == Number ) { if ( @@a3@@ ) { for ( @@i@@ = Number ; @@i@@ < @@a3@@ ; ++ @@i@@ ) { if ( ! strncmp ( @@a2@@ + Number , * ( const char * * ) ( Number L * @@i@@ + @@a4@@ ) , Number ) ) goto LABEL_14 ; } } else { LABEL_14 : print_entry ( @@a2@@ ) ; } } @@a2@@ += Number ; } }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 __fastcall c_strcasecmp ( unsigned __int8 * @@a1@@ , unsigned __int8 * @@a2@@ ) { unsigned __int8 * @@v2@@ ; unsigned __int8 * @@v3@@ ; unsigned __int8 @@v5@@ ; unsigned __int8 @@v6@@ ; @@v2@@ = @@a1@@ ; @@v3@@ = @@a2@@ ; if ( @@a1@@ == @@a2@@ ) return Number L ; do { @@v5@@ = c_tolower ( * @@v2@@ ) ; @@v6@@ = c_tolower ( * @@v3@@ ) ; if ( ! @@v5@@ ) break ; ++ @@v2@@ ; ++ @@v3@@ ; } while ( @@v5@@ == @@v6@@ ) ; return @@v5@@ - ( unsigned int ) @@v6@@ ; }
int utmpxname ( const char * @@file@@ ) { return utmpxname ( @@file@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
struct tm * localtime ( const time_t * @@timer@@ ) { return localtime ( @@timer@@ ) ; }
char * __fastcall time_string ( __int64 @@a1@@ ) { time_t @@timer@@ ; struct tm * @@tp@@ ; unsigned __int64 @@v4@@ ; @@v4@@ = __readfsqword ( Number ) ; @@timer@@ = * ( int * ) ( @@a1@@ + Number ) ; @@tp@@ = localtime ( & @@timer@@ ) ; if ( ! @@tp@@ ) return ( char * ) timetostr ( @@timer@@ , ( __int64 ) buf_5680 ) ; strftime ( buf_5680 , Number , time_format , @@tp@@ ) ; return buf_5680 ; }
int toupper ( int @@c@@ ) { return toupper ( @@c@@ ) ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
const char * gai_strerror ( int @@ecode@@ ) { return gai_strerror ( @@ecode@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
unsigned __int64 __fastcall short_pinky ( __int64 @@a1@@ , int @@a2@@ , __int64 @@a3@@ ) { int * @@v3@@ ; __int64 @@v6@@ ; const char * @@v7@@ ; unsigned __int64 @@v8@@ ; @@v8@@ = __readfsqword ( Number ) ; if ( ( unsigned int ) read_utmp ( @@a1@@ , & @@v6@@ , & @@v7@@ , Number L ) ) { @@v3@@ = __errno_location ( ) ; error ( Number , * @@v3@@ , off_5C97 , @@a1@@ ) ; } scan_entries ( @@v6@@ , @@v7@@ , @@a2@@ , @@a3@@ ) ; return __readfsqword ( Number ) ^ @@v8@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_20C3E8 ; @@v4@@ [ Number ] = qword_20C3F0 ; @@v4@@ [ Number ] = qword_20C3F8 ; @@v4@@ [ Number ] = qword_20C400 ; @@v4@@ [ Number ] = qword_20C408 ; @@v4@@ [ Number ] = qword_20C410 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
time_t time ( time_t * @@timer@@ ) { return time ( @@timer@@ ) ; }
__int64 __fastcall mem_cd_iconv ( char * @@a1@@ , size_t @@a2@@ , void * @@a3@@ , void * * @@a4@@ , size_t * @@a5@@ ) { int @@v9@@ ; char * @@inbuf@@ ; size_t @@inbytesleft@@ ; char * @@outbuf@@ ; size_t @@outbytesleft@@ ; void * @@ptr@@ ; size_t @@v15@@ ; size_t @@v16@@ ; size_t @@v17@@ ; size_t @@size@@ ; size_t @@v19@@ ; size_t @@v20@@ ; char @@v21@@ $D1F1B2789FC85C59BE59CF61C76BFA1E [ Number ] ; unsigned __int64 @@v22@@ ; @@v22@@ = __readfsqword ( Number ) ; iconv ( @@a3@@ , Number L , Number L , Number L , Number L ) ; @@v15@@ = Number L ; @@inbuf@@ = @@a1@@ ; @@inbytesleft@@ = @@a2@@ ; while ( @@inbytesleft@@ ) { @@outbuf@@ = @@v21@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; @@outbytesleft@@ = Number L ; @@v16@@ = iconv ( @@a3@@ , & @@inbuf@@ , & @@inbytesleft@@ , & @@outbuf@@ , & @@outbytesleft@@ ) ; if ( @@v16@@ == Number && * __errno_location ( ) != Number ) { if ( * __errno_location ( ) != Number ) return Number ; break ; } @@v15@@ += @@outbuf@@ - @@v21@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; } @@outbuf@@ = @@v21@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; @@outbytesleft@@ = Number L ; @@v17@@ = iconv ( @@a3@@ , Number L , Number L , & @@outbuf@@ , & @@outbytesleft@@ ) ; if ( @@v17@@ == Number ) return Number ; @@v15@@ += @@outbuf@@ - @@v21@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; @@size@@ = @@v15@@ ; if ( ! @@v15@@ ) { * @@a5@@ = Number L ; return Number L ; } if ( * @@a4@@ && @@size@@ <= * @@a5@@ ) { @@ptr@@ = * @@a4@@ ; } else { @@ptr@@ = malloc ( @@size@@ ) ; if ( ! @@ptr@@ ) { * __errno_location ( ) = Number ; return Number ; } } iconv ( @@a3@@ , Number L , Number L , Number L , Number L ) ; @@inbuf@@ = @@a1@@ ; @@inbytesleft@@ = @@a2@@ ; @@outbuf@@ = ( char * ) @@ptr@@ ; @@outbytesleft@@ = @@size@@ ; while ( @@inbytesleft@@ ) { @@v19@@ = iconv ( @@a3@@ , & @@inbuf@@ , & @@inbytesleft@@ , & @@outbuf@@ , & @@outbytesleft@@ ) ; if ( @@v19@@ == Number ) { if ( * __errno_location ( ) != Number ) goto LABEL_26 ; break ; } } @@v20@@ = iconv ( @@a3@@ , Number L , Number L , & @@outbuf@@ , & @@outbytesleft@@ ) ; if ( @@v20@@ != Number ) { if ( @@outbytesleft@@ ) abort ( ) ; * @@a4@@ = @@ptr@@ ; * @@a5@@ = @@size@@ ; return Number L ; } LABEL_26 : if ( @@ptr@@ != * @@a4@@ ) { @@v9@@ = * __errno_location ( ) ; free ( @@ptr@@ ) ; * __errno_location ( ) = @@v9@@ ; } return Number ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall str2sig ( const char * @@a1@@ , int * @@a2@@ ) { __int64 @@result@@ ; * @@a2@@ = str2signum ( @@a1@@ ) ; if ( * @@a2@@ >= Number ) @@result@@ = Number L ; else @@result@@ = Number ; return @@result@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall canon_host ( __int64 @@a1@@ ) { return canon_host_r ( @@a1@@ , & last_cherror ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
__int64 __fastcall xnrealloc ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { if ( ! is_mul_ok ( @@a3@@ , @@a2@@ ) ) xalloc_die ( ) ; return xrealloc ( @@a1@@ , @@a3@@ * @@a2@@ ) ; }
int putchar_unlocked ( int @@c@@ ) { return putchar_unlocked ( @@c@@ ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
char * __fastcall canon_host_r ( const char * @@a1@@ , int * @@a2@@ ) { char * @@v2@@ ; int @@v4@@ ; struct addrinfo * @@pai@@ ; char * @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = Number L ; @@pai@@ = Number L ; hints_3123 . ai_flags = Number ; @@v4@@ = getaddrinfo ( @@a1@@ , Number L , & hints_3123 , & @@pai@@ ) ; if ( @@v4@@ ) { if ( @@a2@@ ) * @@a2@@ = @@v4@@ ; } else { if ( @@pai@@ -> ai_canonname ) @@v2@@ = @@pai@@ -> ai_canonname ; else @@v2@@ = ( char * ) @@a1@@ ; @@v6@@ = strdup ( @@v2@@ ) ; if ( ! @@v6@@ && @@a2@@ ) * @@a2@@ = Number ; freeaddrinfo ( @@pai@@ ) ; } return @@v6@@ ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v4@@ ; @@v4@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v4@@ >= Number / @@a3@@ ) xalloc_die ( ) ; @@v4@@ += ( @@v4@@ + Number ) >> Number ; } else if ( ! @@v4@@ ) { @@v4@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v4@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v4@@ ) ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
const char * __fastcall idle_string ( __int64 @@a1@@ ) { __int64 @@v2@@ ; if ( ! now_5671 ) time ( & now_5671 ) ; @@v2@@ = now_5671 - @@a1@@ ; if ( now_5671 - @@a1@@ <= Number ) return String ; if ( @@v2@@ > Number ) sprintf ( buf_5672 , String , @@v2@@ / Number ) ; else sprintf ( buf_5672 , String , ( unsigned int ) ( ( int ) @@v2@@ / Number ) , ( unsigned int ) ( @@v2@@ % Number / Number ) ) ; return buf_5672 ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
__int64 __fastcall long_pinky ( int @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; unsigned int @@i@@ ; for ( @@i@@ = Number ; ; ++ @@i@@ ) { @@result@@ = @@i@@ ; if ( ( int ) @@i@@ >= @@a1@@ ) break ; print_long_entry ( * ( const char * * ) ( Number L * ( int ) @@i@@ + @@a2@@ ) ) ; } return @@result@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
const char * locale_charset ( ) { const char * @@s1@@ ; char * @@s2@@ ; char * @@s2a@@ ; @@s1@@ = nl_langinfo ( Number ) ; if ( ! @@s1@@ ) @@s1@@ = ( const char * ) & unk_A16E ; for ( @@s2@@ = ( char * ) get_charset_aliases ( ) ; * @@s2@@ ; @@s2@@ = & @@s2a@@ [ strlen ( @@s2a@@ ) + Number ] ) { if ( ! strcmp ( @@s1@@ , @@s2@@ ) || * @@s2@@ == Number && ! @@s2@@ [ Number ] ) { @@s1@@ = & @@s2@@ [ strlen ( @@s2@@ ) + Number ] ; break ; } @@s2a@@ = & @@s2@@ [ strlen ( @@s2@@ ) + Number ] ; } if ( ! * @@s1@@ ) @@s1@@ = String ; return @@s1@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
int __cdecl __noreturn main ( int @@argc@@ , const char * * @@argv@@ , const char * * @@envp@@ ) { char * @@v3@@ ; int @@v4@@ ; int @@v5@@ ; set_program_name ( * @@argv@@ , @@argv@@ , @@envp@@ ) ; setlocale ( Number , & locale ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; while ( Number ) { while ( Number ) { while ( Number ) { @@v4@@ = getopt_long ( @@argc@@ , ( char * const * ) @@argv@@ , String , & longopts , Number L ) ; if ( @@v4@@ == Number ) { @@v5@@ = @@argc@@ - optind ; if ( do_short_format != Number && ! @@v5@@ ) { @@v3@@ = gettext ( String ) ; error ( Number , Number , @@v3@@ ) ; usage ( Number ) ; } if ( do_short_format ) short_pinky ( ( __int64 ) String , @@v5@@ , ( __int64 ) & @@argv@@ [ optind ] ) ; else long_pinky ( @@v5@@ , ( __int64 ) & @@argv@@ [ optind ] ) ; exit ( Number ) ; } if ( @@v4@@ != Number ) break ; include_fullname = Number ; include_where = Number ; } if ( @@v4@@ <= Number ) break ; if ( @@v4@@ == Number ) { include_fullname = Number ; include_where = Number ; include_idle = Number ; } else if ( @@v4@@ > Number ) { if ( @@v4@@ == Number ) { do_short_format = Number ; } else { if ( @@v4@@ != Number ) goto LABEL_31 ; include_fullname = Number ; } } else if ( @@v4@@ == Number ) { do_short_format = Number ; } else { if ( @@v4@@ != Number ) goto LABEL_31 ; include_plan = Number ; } } if ( @@v4@@ == Number ) { include_home_and_shell = Number ; } else { if ( @@v4@@ <= Number ) { if ( @@v4@@ == Number ) { version_etc ( ( _DWORD ) stdout , ( unsigned int ) String , ( unsigned int ) String , ( _DWORD ) Version , ( unsigned int ) String , ( unsigned int ) String , String , Number L ) ; exit ( Number ) ; } if ( @@v4@@ == Number ) usage ( Number ) ; LABEL_31 : usage ( Number ) ; } if ( @@v4@@ == Number ) { include_heading = Number ; } else { if ( @@v4@@ != Number ) goto LABEL_31 ; include_project = Number ; } } } }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
__int64 default_block_size ( ) { __int64 @@result@@ ; if ( getenv ( String ) ) @@result@@ = Number L ; else @@result@@ = Number L ; return @@result@@ ; }
_BOOL8 __fastcall c_isascii ( int @@a1@@ ) { return @@a1@@ >= Number && @@a1@@ <= Number ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
_BOOL8 __fastcall c_isalpha ( int @@a1@@ ) { return ( int ) ( @@a1@@ & Number ) > Number && ( int ) ( @@a1@@ & Number ) <= Number ; }
char * __fastcall extract_trimmed_name ( __int64 @@a1@@ ) { char * @@i@@ ; char * @@dest@@ ; @@dest@@ = ( char * ) xmalloc ( Number L ) ; strncpy ( @@dest@@ , ( const char * ) ( @@a1@@ + Number ) , Number ) ; @@dest@@ [ Number ] = Number ; for ( @@i@@ = & @@dest@@ [ strlen ( @@dest@@ ) ] ; @@dest@@ < @@i@@ && * ( @@i@@ - Number ) == Number ; * @@i@@ = Number ) { -- @@i@@ ; } return @@dest@@ ; }
_BOOL8 __fastcall c_isblank ( int @@a1@@ ) { return @@a1@@ == Number || @@a1@@ == Number ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall humblock ( char * @@a1@@ , _QWORD * @@a2@@ , int * @@a3@@ ) { char * @@v5@@ ; int @@v6@@ ; int @@v7@@ ; unsigned int @@v8@@ ; __int64 @@v9@@ [ Number ] ; @@v5@@ = @@a1@@ ; @@v9@@ [ Number ] = __readfsqword ( Number ) ; @@v6@@ = Number ; if ( @@a1@@ || ( @@v5@@ = getenv ( String ) ) != Number L || ( @@v5@@ = getenv ( String ) ) != Number L ) { if ( * @@v5@@ == Number ) { @@v6@@ = Number ; ++ @@v5@@ ; } @@v7@@ = argmatch ( @@v5@@ , & block_size_args , block_size_opts , Number L ) ; if ( @@v7@@ < Number ) { @@v8@@ = xstrtoumax ( @@v5@@ , @@v9@@ , Number L , @@a2@@ , String ) ; if ( @@v8@@ ) { * @@a3@@ = Number ; return @@v8@@ ; } while ( * @@v5@@ <= Number || * @@v5@@ > Number ) { if ( @@v5@@ == ( char * ) @@v9@@ [ Number ] ) { @@v6@@ |= Number ; if ( * ( _BYTE * ) ( @@v9@@ [ Number ] - Number ) == Number ) @@v6@@ |= Number ; if ( * ( _BYTE * ) ( @@v9@@ [ Number ] - Number ) != Number || * ( _BYTE * ) ( @@v9@@ [ Number ] - Number ) == Number ) @@v6@@ |= Number ; break ; } ++ @@v5@@ ; } } else { @@v6@@ |= block_size_opts [ @@v7@@ ] ; * @@a2@@ = Number L ; } } else { * @@a2@@ = default_block_size ( ) ; } * @@a3@@ = @@v6@@ ; return Number L ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v4@@ ; @@v4@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v4@@ >= Number / @@a3@@ ) xalloc_die ( ) ; @@v4@@ += ( @@v4@@ + Number ) >> Number ; } else if ( ! @@v4@@ ) { @@v4@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v4@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v4@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
_BOOL8 __fastcall c_isdigit ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
void * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * @@v4@@ ; void * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * @@v12@@ ; void * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == ( __int64 * ) & slotvec0 ; if ( slotvec == ( __int64 * ) & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = off_208028 ; * @@v12@@ = ( __int64 ) slotvec0 ; @@v12@@ [ Number ] = ( __int64 ) @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = ( void * ) @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = @@v17@@ + Number ; if ( @@ptr@@ != & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( void * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = ( __int64 ) @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
_BOOL8 __fastcall c_isgraph ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
_BOOL8 __fastcall c_isupper ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
__int64 __fastcall argmatch_to_argument ( const void * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; ++ @@i@@ ) { if ( ! memcmp ( @@a1@@ , ( const void * ) ( @@i@@ * @@a4@@ + @@a3@@ ) , @@a4@@ ) ) return * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; } return Number L ; }
int getc_unlocked ( FILE * @@stream@@ ) { return getc_unlocked ( @@stream@@ ) ; }
_BOOL8 __fastcall c_isxdigit ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number || ( int ) ( @@a1@@ & Number ) > Number && ( int ) ( @@a1@@ & Number ) <= Number ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_208188 ; @@v8@@ [ Number ] = qword_208190 ; @@v8@@ [ Number ] = qword_208198 ; @@v8@@ [ Number ] = qword_2081A0 ; @@v8@@ [ Number ] = qword_2081A8 ; @@v8@@ [ Number ] = qword_2081B0 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
unsigned int alarm ( unsigned int @@seconds@@ ) { return alarm ( @@seconds@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
_BOOL8 __fastcall desirable_utmp_entry ( __int64 @@a1@@ , char @@a2@@ ) { bool @@v2@@ ; @@v2@@ = * ( _BYTE * ) ( @@a1@@ + Number ) && * ( _WORD * ) @@a1@@ == Number ; if ( ( @@a2@@ & Number ) != Number && ! @@v2@@ ) return Number L ; return ( @@a2@@ & Number ) == Number || ! @@v2@@ || * ( int * ) ( @@a1@@ + Number ) > Number && ( kill ( * ( _DWORD * ) ( @@a1@@ + Number ) , Number ) >= Number || * __errno_location ( ) != Number ) ; }
__int64 __fastcall xnrealloc ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { if ( ! is_mul_ok ( @@a3@@ , @@a2@@ ) ) xalloc_die ( ) ; return xrealloc ( @@a1@@ , @@a3@@ * @@a2@@ ) ; }
void __fastcall freea ( unsigned __int64 @@a1@@ ) { _QWORD * @@i@@ ; if ( @@a1@@ && * ( _DWORD * ) ( @@a1@@ - Number ) == Number ) { for ( @@i@@ = & mmalloca_results [ @@a1@@ % Number ] ; * @@i@@ ; @@i@@ = ( _QWORD * ) ( * @@i@@ - Number L ) ) { if ( @@a1@@ == * @@i@@ ) { * @@i@@ = * ( _QWORD * ) ( @@a1@@ - Number ) ; free ( ( void * ) ( @@a1@@ - Number ) ) ; return ; } } } }
int iswalnum ( wint_t @@wc@@ ) { return iswalnum ( @@wc@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ ) { return xmalloc ( @@a1@@ ) ; }
int putchar_unlocked ( int @@c@@ ) { return putchar_unlocked ( @@c@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( ) ; return @@ptr@@ ; }
int iswspace ( wint_t @@wc@@ ) { return iswspace ( @@wc@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@v2@@ ; @@v2@@ = malloc ( @@a1@@ ) ; if ( ! @@v2@@ && @@a1@@ ) xalloc_die ( ) ; return @@v2@@ ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
void freeaddrinfo ( struct addrinfo * @@ai@@ ) { freeaddrinfo ( @@ai@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@v3@@ ; @@v3@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v3@@ ) xalloc_die ( ) ; return @@v3@@ ; }
void * __fastcall xzalloc ( size_t @@a1@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@a1@@ ) ; return memset ( @@v1@@ , Number , @@a1@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
int __fastcall send_sig ( __pid_t @@a1@@ , int @@a2@@ ) { sigs_to_ignore [ @@a2@@ ] = Number ; return kill ( @@a1@@ , @@a2@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
unsigned __int64 __fastcall install_signal_handlers ( int @@a1@@ ) { struct sigaction @@v2@@ ; unsigned __int64 @@v3@@ ; @@v3@@ = __readfsqword ( Number ) ; sigemptyset ( & @@v2@@ . sa_mask ) ; @@v2@@ . sa_handler = ( __sighandler_t ) cleanup ; @@v2@@ . sa_flags = Number ; sigaction ( Number , & @@v2@@ , Number L ) ; sigaction ( Number , & @@v2@@ , Number L ) ; sigaction ( Number , & @@v2@@ , Number L ) ; sigaction ( Number , & @@v2@@ , Number L ) ; sigaction ( Number , & @@v2@@ , Number L ) ; sigaction ( @@a1@@ , & @@v2@@ , Number L ) ; return __readfsqword ( Number ) ^ @@v3@@ ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; char * @@v3@@ ; FILE * @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; FILE * @@v10@@ ; char * @@v11@@ ; char * @@v12@@ ; @@v1@@ = program_name ; if ( @@a1@@ ) { @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = gettext ( String ) ; printf ( @@v3@@ , @@v1@@ ) ; @@v4@@ = stdout ; @@v5@@ = gettext ( String String String String String String ) ; fputs_unlocked ( @@v5@@ , @@v4@@ ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String String String String String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; @@v8@@ = stdout ; @@v9@@ = gettext ( String ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = stdout ; @@v11@@ = gettext ( String ) ; fputs_unlocked ( @@v11@@ , @@v10@@ ) ; @@v12@@ = gettext ( String ) ; printf ( @@v12@@ , String ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
bool __fastcall is_basic ( unsigned __int8 @@a1@@ ) { return ( ( * ( ( _DWORD * ) & is_basic_table + ( @@a1@@ >> Number ) ) >> ( @@a1@@ & Number ) ) & Number ) != Number ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
int sigemptyset ( sigset_t * @@set@@ ) { return sigemptyset ( @@set@@ ) ; }
char * nl_langinfo ( nl_item @@item@@ ) { return nl_langinfo ( @@item@@ ) ; }
char * __fastcall proper_name_utf8 ( const char * @@a1@@ , __int64 @@a2@@ ) { char * @@v2@@ ; char * @@result@@ ; size_t @@v4@@ ; size_t @@v5@@ ; char * @@ptr@@ ; char * @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; char * @@s1@@ ; char * @@s@@ ; size_t @@n@@ ; char * @@dest@@ ; char * @@v14@@ ; char * @@v15@@ ; char * @@v16@@ ; @@s1@@ = gettext ( @@a1@@ ) ; @@s@@ = ( char * ) locale_charset ( ) ; @@ptr@@ = Number L ; @@v7@@ = Number L ; @@v9@@ = Number L ; if ( ( unsigned int ) c_strcasecmp ( @@s@@ , String ) ) { @@ptr@@ = ( char * ) xstr_iconv ( @@a2@@ , String , @@s@@ ) ; @@v8@@ = ( __int64 ) @@ptr@@ ; @@n@@ = strlen ( @@s@@ ) ; @@dest@@ = ( char * ) xmalloc ( @@n@@ + Number ) ; memcpy ( @@dest@@ , @@s@@ , @@n@@ ) ; memcpy ( & @@dest@@ [ @@n@@ ] , String , Number ) ; @@v14@@ = ( char * ) xstr_iconv ( @@a2@@ , String , @@dest@@ ) ; free ( @@dest@@ ) ; if ( @@v14@@ ) { if ( strchr ( @@v14@@ , Number ) ) { free ( @@v14@@ ) ; } else { @@v7@@ = @@v14@@ ; @@v9@@ = ( __int64 ) @@v14@@ ; } } } else { @@v8@@ = @@a2@@ ; @@v9@@ = @@a2@@ ; } if ( @@v8@@ ) { @@v2@@ = ( char * ) @@v8@@ ; } else if ( @@v9@@ ) { @@v2@@ = ( char * ) @@v9@@ ; } else { @@v2@@ = ( char * ) @@a1@@ ; } @@v15@@ = @@v2@@ ; if ( ! strcmp ( @@s1@@ , @@a1@@ ) ) { if ( @@ptr@@ && @@ptr@@ != @@v15@@ ) free ( @@ptr@@ ) ; if ( @@v7@@ && @@v7@@ != @@v15@@ ) free ( @@v7@@ ) ; @@result@@ = @@v15@@ ; } else if ( ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@s1@@ , ( __int64 ) @@a1@@ ) || @@v8@@ && ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@s1@@ , @@v8@@ ) || @@v9@@ && ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@s1@@ , @@v9@@ ) ) { if ( @@ptr@@ ) free ( @@ptr@@ ) ; if ( @@v7@@ ) free ( @@v7@@ ) ; @@result@@ = @@s1@@ ; } else { @@v4@@ = strlen ( @@s1@@ ) ; @@v5@@ = strlen ( @@v15@@ ) ; @@v16@@ = ( char * ) xmalloc ( @@v4@@ + @@v5@@ + Number ) ; sprintf ( @@v16@@ , String , @@s1@@ , @@v15@@ ) ; if ( @@ptr@@ ) free ( @@ptr@@ ) ; if ( @@v7@@ ) free ( @@v7@@ ) ; @@result@@ = @@v16@@ ; } return @@result@@ ; }
unsigned __int64 __fastcall factor_wheel ( unsigned __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v4@@ ; const char * @@v5@@ ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; unsigned __int64 @@v8@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@v10@@ ; const char * @@v11@@ ; @@v7@@ = @@a1@@ ; @@v10@@ = Number L ; @@v11@@ = ( const char * ) & wheel_tab ; if ( @@a1@@ <= Number ) return Number L ; @@v8@@ = Number L ; do { for ( @@i@@ = @@v7@@ / @@v8@@ ; @@v7@@ == @@v8@@ * @@i@@ ; @@i@@ /= @@v8@@ ) { if ( @@v10@@ >= @@a2@@ ) __assert_fail ( String , String , Number , String ) ; @@v4@@ = @@v10@@ ++ ; * ( _QWORD * ) ( @@a3@@ + Number * @@v4@@ ) = @@v8@@ ; @@v7@@ = @@i@@ ; } @@v5@@ = @@v11@@ ++ ; @@v8@@ += * ( unsigned __int8 * ) @@v5@@ ; if ( @@v11@@ == String ) @@v11@@ = ( const char * ) & unk_4E85 ; } while ( @@v8@@ <= @@i@@ ) ; if ( @@v7@@ != Number ) { if ( @@v10@@ >= @@a2@@ ) __assert_fail ( String , String , Number , String ) ; @@v6@@ = @@v10@@ ++ ; * ( _QWORD * ) ( @@a3@@ + Number * @@v6@@ ) = @@v7@@ ; } return @@v10@@ ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
int iconv_close ( iconv_t @@cd@@ ) { return iconv_close ( @@cd@@ ) ; }
__pid_t wait ( __WAIT_STATUS @@stat_loc@@ ) { return wait ( @@stat_loc@@ ) ; }
__int64 __fastcall hard_locale ( int @@a1@@ ) { unsigned __int8 @@v2@@ ; const char * @@s1@@ ; @@v2@@ = Number ; @@s1@@ = setlocale ( @@a1@@ , Number L ) ; if ( @@s1@@ && ( ! strcmp ( @@s1@@ , String ) || ! strcmp ( @@s1@@ , String ) ) ) @@v2@@ = Number ; return @@v2@@ ; }
char * strdup ( const char * @@s@@ ) { return strdup ( @@s@@ ) ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( is_mul_ok ( @@a2@@ , * @@a1@@ ) ) { * @@a1@@ *= @@a2@@ ; @@result@@ = Number L ; } else { * @@a1@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
int __fastcall cleanup ( int @@a1@@ ) { _DWORD * @@v1@@ ; int @@v3@@ ; @@v3@@ = @@a1@@ ; if ( @@a1@@ == Number ) { timed_out = Number ; @@v3@@ = term_signal ; } if ( ! monitored_pid ) _exit ( @@v3@@ + Number ) ; if ( sigs_to_ignore [ @@v3@@ ] ) { @@v1@@ = sigs_to_ignore ; sigs_to_ignore [ @@v3@@ ] = Number ; } else { LODWORD ( @@v1@@ ) = send_sig ( Number , @@v3@@ ) ; if ( @@v3@@ != Number && @@v3@@ != Number ) LODWORD ( @@v1@@ ) = send_sig ( Number , Number ) ; } return ( int ) @@v1@@ ; }
__int64 __fastcall sig2str ( int @@a1@@ , char * @@a2@@ ) { unsigned int @@i@@ ; int @@v4@@ ; int @@v5@@ ; for ( @@i@@ = Number ; @@i@@ <= Number ; ++ @@i@@ ) { if ( @@a1@@ == * ( ( _DWORD * ) & numname_table + Number * @@i@@ ) ) { strcpy ( @@a2@@ , ( const char * ) & numname_table + Number * @@i@@ + Number ) ; return Number L ; } } @@v4@@ = __libc_current_sigrtmin ( ) ; @@v5@@ = __libc_current_sigrtmax ( ) ; if ( @@v4@@ > @@a1@@ || @@a1@@ > @@v5@@ ) return Number ; if ( @@a1@@ > ( @@v5@@ - @@v4@@ ) / Number + @@v4@@ ) { if ( @@v5@@ == @@a1@@ ) sprintf ( @@a2@@ , String ) ; else sprintf ( @@a2@@ , String , ( unsigned int ) ( @@v5@@ - @@a1@@ ) ) ; } else if ( @@a1@@ == @@v4@@ ) { sprintf ( @@a2@@ , String ) ; } else { sprintf ( @@a2@@ , String , ( unsigned int ) ( @@a1@@ - @@v4@@ ) ) ; } return Number L ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 __fastcall bkm_scale_by_power ( unsigned __int64 * @@a1@@ , int @@a2@@ , int @@a3@@ ) { unsigned int @@i@@ ; for ( @@i@@ = Number ; @@a3@@ -- ; @@i@@ |= bkm_scale ( @@a1@@ , @@a2@@ ) ) ; return @@i@@ ; }
__int64 __fastcall operand2sig ( const char * @@a1@@ , __int64 @@a2@@ ) { int @@v2@@ ; char * @@v3@@ ; unsigned int @@v5@@ ; int @@v6@@ ; char * @@endptr@@ ; _BYTE * @@i@@ ; void * @@ptr@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; @@v11@@ = __readfsqword ( Number ) ; if ( ( unsigned int ) ( * @@a1@@ - Number ) > Number ) { @@ptr@@ = ( void * ) xstrdup ( @@a1@@ ) ; for ( @@i@@ = @@ptr@@ ; * @@i@@ ; ++ @@i@@ ) { if ( strchr ( String , ( char ) * @@i@@ ) ) * @@i@@ -= Number ; } if ( ( unsigned int ) str2sig ( @@ptr@@ , & @@v5@@ ) && ( * ( _BYTE * ) @@ptr@@ != Number || * ( ( _BYTE * ) @@ptr@@ + Number ) != Number || * ( ( _BYTE * ) @@ptr@@ + Number ) != Number || ( unsigned int ) str2sig ( ( char * ) @@ptr@@ + Number , & @@v5@@ ) ) ) { @@v5@@ = Number ; } free ( @@ptr@@ ) ; } else { * __errno_location ( ) = Number ; @@v10@@ = strtol ( @@a1@@ , & @@endptr@@ , Number ) ; @@v6@@ = @@v10@@ ; if ( @@a1@@ == @@endptr@@ || * @@endptr@@ || * __errno_location ( ) || @@v10@@ != @@v6@@ ) { @@v2@@ = Number ; } else if ( ( char ) ( ( @@v6@@ & Number ) + Number ) >> Number <= Number ) { @@v2@@ = @@v6@@ ; } else { @@v2@@ = @@v6@@ & Number ; } @@v5@@ = @@v2@@ ; } if ( ( @@v5@@ & Number ) == Number && ! ( unsigned int ) sig2str ( @@v5@@ , @@a2@@ ) ) return @@v5@@ ; @@v3@@ = gettext ( String ) ; error ( Number , Number , @@v3@@ , @@a1@@ ) ; return Number ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@v3@@ ; @@v3@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v3@@ ) xalloc_die ( ) ; return @@v3@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
__int64 __fastcall apply_time_suffix ( _QWORD * @@a1@@ , char @@a2@@ ) { unsigned int @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = Number ; if ( @@a2@@ != Number ) { if ( @@a2@@ > Number ) { if ( @@a2@@ == Number ) goto LABEL_11 ; if ( @@a2@@ != Number ) return Number L ; } else if ( @@a2@@ ) { if ( @@a2@@ != Number ) return Number L ; @@v3@@ = Number ; goto LABEL_10 ; } return Number L ; } LABEL_10 : @@v3@@ *= Number ; LABEL_11 : if ( @@v3@@ > Number ) return Number L ; @@v4@@ = Number * @@v3@@ ; if ( * @@a1@@ > ( unsigned __int64 ) ( Number / @@v4@@ ) ) return Number L ; * @@a1@@ *= @@v4@@ ; return Number L ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
__int64 __fastcall c_strcasecmp ( unsigned __int8 * @@a1@@ , unsigned __int8 * @@a2@@ ) { unsigned __int8 * @@v2@@ ; unsigned __int8 * @@v3@@ ; unsigned __int8 @@v5@@ ; unsigned __int8 @@v6@@ ; @@v2@@ = @@a1@@ ; @@v3@@ = @@a2@@ ; if ( @@a1@@ == @@a2@@ ) return Number L ; do { @@v5@@ = c_tolower ( * @@v2@@ ) ; @@v6@@ = c_tolower ( * @@v3@@ ) ; if ( ! @@v5@@ ) break ; ++ @@v2@@ ; ++ @@v3@@ ; } while ( @@v5@@ == @@v6@@ ) ; return @@v5@@ - ( unsigned int ) @@v6@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
char * __fastcall str_iconv ( char * @@a1@@ , char * @@a2@@ , char * @@a3@@ ) { char * @@result@@ ; int @@v5@@ ; int @@v6@@ ; iconv_t @@cd@@ ; void * @@ptr@@ ; char * @@v9@@ ; if ( * @@a1@@ && ( unsigned int ) c_strcasecmp ( ( unsigned __int8 * ) @@a2@@ , ( unsigned __int8 * ) @@a3@@ ) ) { @@cd@@ = iconv_open ( @@a3@@ , @@a2@@ ) ; if ( @@cd@@ == ( iconv_t ) Number ) return Number L ; @@ptr@@ = str_cd_iconv ( @@a1@@ , @@cd@@ ) ; if ( @@ptr@@ ) { if ( iconv_close ( @@cd@@ ) < Number ) { @@v5@@ = * __errno_location ( ) ; free ( @@ptr@@ ) ; * __errno_location ( ) = @@v5@@ ; return Number L ; } } else { @@v6@@ = * __errno_location ( ) ; iconv_close ( @@cd@@ ) ; * __errno_location ( ) = @@v6@@ ; } @@result@@ = ( char * ) @@ptr@@ ; } else { @@v9@@ = strdup ( @@a1@@ ) ; if ( ! @@v9@@ ) * __errno_location ( ) = Number ; @@result@@ = @@v9@@ ; } return @@result@@ ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_208038 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
_BOOL8 __fastcall c_islower ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
int __fastcall stat ( char * @@filename@@ , struct stat * @@stat_buf@@ ) { return __xstat ( Number , @@filename@@ , @@stat_buf@@ ) ; }
_BOOL8 __fastcall c_ispunct ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number && ( @@a1@@ <= Number || @@a1@@ > Number ) && ( ( int ) ( @@a1@@ & Number ) <= Number || ( int ) ( @@a1@@ & Number ) > Number ) ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_207028 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
__int64 __fastcall c_toupper ( int @@a1@@ ) { __int64 @@result@@ ; if ( @@a1@@ <= Number || @@a1@@ > Number ) @@result@@ = ( unsigned int ) @@a1@@ ; else @@result@@ = ( unsigned int ) ( @@a1@@ - Number ) ; return @@result@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_2070C8 ; @@v4@@ [ Number ] = qword_2070D0 ; @@v4@@ [ Number ] = qword_2070D8 ; @@v4@@ [ Number ] = qword_2070E0 ; @@v4@@ [ Number ] = qword_2070E8 ; @@v4@@ [ Number ] = qword_2070F0 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_20C3E8 ; @@v8@@ [ Number ] = qword_20C3F0 ; @@v8@@ [ Number ] = qword_20C3F8 ; @@v8@@ [ Number ] = qword_20C400 ; @@v8@@ [ Number ] = qword_20C408 ; @@v8@@ [ Number ] = qword_20C410 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
__int64 __fastcall umaxtostr ( unsigned __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v4@@ ; @@v4@@ = @@a2@@ + Number ; * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; do { * ( _BYTE * ) -- @@v4@@ = @@a1@@ % Number + Number ; @@a1@@ /= Number ; } while ( @@a1@@ ) ; return @@v4@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; FILE * @@v10@@ ; char * @@v11@@ ; if ( @@a1@@ ) { @@v1@@ = program_name ; @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = program_name ; @@v4@@ = program_name ; @@v5@@ = gettext ( String ) ; printf ( @@v5@@ , @@v4@@ , @@v3@@ ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String String String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; @@v8@@ = stdout ; @@v9@@ = gettext ( String ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = stdout ; @@v11@@ = gettext ( String ) ; fputs_unlocked ( @@v11@@ , @@v10@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ ) { return xmalloc ( @@a1@@ ) ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return xmalloc ( @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
void * __fastcall xzalloc ( size_t @@a1@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@a1@@ ) ; return memset ( @@v1@@ , Number , @@a1@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
__int64 __fastcall str2signum ( const char * @@a1@@ ) { unsigned int @@i@@ ; int @@v3@@ ; int @@v4@@ ; char * @@endptr@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; if ( ( unsigned int ) ( * @@a1@@ - Number ) > Number ) { for ( @@i@@ = Number ; @@i@@ <= Number ; ++ @@i@@ ) { if ( ! strcmp ( ( const char * ) & numname_table + Number * @@i@@ + Number , @@a1@@ ) ) return * ( ( unsigned int * ) & numname_table + Number * @@i@@ ) ; } @@v3@@ = __libc_current_sigrtmin ( ) ; @@v4@@ = __libc_current_sigrtmax ( ) ; if ( @@v3@@ > Number && ! strncmp ( @@a1@@ , String , Number ) ) { @@v6@@ = strtol ( @@a1@@ + Number , & @@endptr@@ , Number ) ; if ( ! * @@endptr@@ && @@v6@@ >= Number && @@v6@@ <= @@v4@@ - @@v3@@ ) { return ( unsigned int ) ( @@v6@@ + @@v3@@ ) ; } } else if ( @@v4@@ > Number && ! strncmp ( @@a1@@ , String , Number ) ) { @@v7@@ = strtol ( @@a1@@ + Number , & @@endptr@@ , Number ) ; if ( ! * @@endptr@@ && @@v7@@ >= @@v3@@ - @@v4@@ && @@v7@@ <= Number ) { return ( unsigned int ) ( @@v7@@ + @@v4@@ ) ; } } } else { @@v8@@ = strtol ( @@a1@@ , & @@endptr@@ , Number ) ; if ( ! * @@endptr@@ && @@v8@@ <= Number ) return @@v8@@ ; } return Number ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( is_mul_ok ( @@a2@@ , * @@a1@@ ) ) { * @@a1@@ *= @@a2@@ ; @@result@@ = Number L ; } else { * @@a1@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( ) ; return @@ptr@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 __fastcall bkm_scale_by_power ( unsigned __int64 * @@a1@@ , int @@a2@@ , int @@a3@@ ) { unsigned int @@i@@ ; for ( @@i@@ = Number ; @@a3@@ -- ; @@i@@ |= bkm_scale ( @@a1@@ , @@a2@@ ) ) { ; } return @@i@@ ; }
__int64 __fastcall strnlen1 ( const void * @@a1@@ , size_t @@a2@@ ) { __int64 @@result@@ ; _BYTE * @@v3@@ ; @@v3@@ = memchr ( @@a1@@ , Number , @@a2@@ ) ; if ( @@v3@@ ) @@result@@ = @@v3@@ - ( _BYTE * ) @@a1@@ + Number ; else @@result@@ = @@a2@@ ; return @@result@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
__int64 __fastcall knuth_morris_pratt_unibyte ( _BYTE * @@a1@@ , char * @@a2@@ , _QWORD * @@a3@@ ) { void * @@v3@@ ; unsigned __int64 @@v4@@ ; _QWORD * @@v6@@ ; char * @@s@@ ; _BYTE * @@v8@@ ; char @@v9@@ ; unsigned __int64 @@i@@ ; __int64 @@v11@@ ; __int64 @@v12@@ ; _BYTE * @@v13@@ ; _BYTE * @@v14@@ ; size_t @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v8@@ = @@a1@@ ; @@s@@ = @@a2@@ ; @@v6@@ = @@a3@@ ; @@v17@@ = __readfsqword ( Number ) ; @@v15@@ = strlen ( @@a2@@ ) ; if ( @@v15@@ > Number ) { @@v4@@ = Number L ; } else if ( Number * @@v15@@ > Number ) { @@v4@@ = mmalloca ( Number * @@v15@@ ) ; } else { @@v3@@ = alloca ( Number * ( ( Number * ( @@v15@@ + Number ) + Number ) / Number ) ) ; @@v4@@ = Number * ( ( ( unsigned __int64 ) & @@v6@@ + Number ) >> Number ) + Number ; } @@v16@@ = @@v4@@ ; if ( ! @@v4@@ ) return Number L ; * ( _QWORD * ) ( @@v16@@ + Number ) = Number L ; @@v11@@ = Number L ; for ( @@i@@ = Number L ; @@i@@ < @@v15@@ ; ++ @@i@@ ) { @@v9@@ = @@s@@ [ @@i@@ - Number ] ; while ( Number ) { if ( @@v9@@ == @@s@@ [ @@v11@@ ] ) { ++ @@v11@@ ; * ( _QWORD * ) ( @@v16@@ + Number * @@i@@ ) = @@i@@ - @@v11@@ ; goto LABEL_15 ; } if ( ! @@v11@@ ) break ; @@v11@@ -= * ( _QWORD * ) ( Number * @@v11@@ + @@v16@@ ) ; } * ( _QWORD * ) ( @@v16@@ + Number * @@i@@ ) = @@i@@ ; LABEL_15 : ; } * @@v6@@ = Number L ; @@v12@@ = Number L ; @@v13@@ = @@v8@@ ; @@v14@@ = @@v8@@ ; while ( * @@v14@@ ) { if ( @@s@@ [ @@v12@@ ] == * @@v14@@ ) { ++ @@v12@@ ; ++ @@v14@@ ; if ( @@v12@@ == @@v15@@ ) { * @@v6@@ = @@v13@@ ; break ; } } else if ( @@v12@@ ) { @@v13@@ += * ( _QWORD * ) ( Number * @@v12@@ + @@v16@@ ) ; @@v12@@ -= * ( _QWORD * ) ( Number * @@v12@@ + @@v16@@ ) ; } else { ++ @@v13@@ ; ++ @@v14@@ ; } } freea ( @@v16@@ ) ; return Number L ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
bool __fastcall is_basic_1 ( unsigned __int8 @@a1@@ ) { return ( ( * ( ( _DWORD * ) & is_basic_table + ( @@a1@@ >> Number ) ) >> ( @@a1@@ & Number ) ) & Number ) != Number ; }
bool __fastcall is_basic_0 ( unsigned __int8 @@a1@@ ) { return ( ( * ( ( _DWORD * ) & is_basic_table + ( @@a1@@ >> Number ) ) >> ( @@a1@@ & Number ) ) & Number ) != Number ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
unsigned __int64 __fastcall mmalloca ( unsigned __int64 @@a1@@ ) { char * @@v2@@ ; unsigned __int64 @@v3@@ ; if ( @@a1@@ + Number < @@a1@@ ) return Number L ; @@v2@@ = ( char * ) malloc ( @@a1@@ + Number ) ; if ( ! @@v2@@ ) return Number L ; @@v3@@ = ( unsigned __int64 ) ( @@v2@@ + Number ) ; * ( _DWORD * ) ( @@v3@@ - Number ) = Number ; * ( _QWORD * ) ( @@v3@@ - Number ) = mmalloca_results [ @@v3@@ % Number ] ; mmalloca_results [ @@v3@@ % Number ] = @@v3@@ ; return @@v3@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 __fastcall mem_cd_iconv ( char * @@a1@@ , size_t @@a2@@ , void * @@a3@@ , void * * @@a4@@ , size_t * @@a5@@ ) { int @@v9@@ ; char * @@inbuf@@ ; size_t @@inbytesleft@@ ; char * @@outbuf@@ ; size_t @@outbytesleft@@ ; void * @@ptr@@ ; size_t @@v15@@ ; size_t @@v16@@ ; size_t @@v17@@ ; size_t @@size@@ ; size_t @@v19@@ ; size_t @@v20@@ ; char @@v21@@ $D1F1B2789FC85C59BE59CF61C76BFA1E [ Number ] ; unsigned __int64 @@v22@@ ; @@v22@@ = __readfsqword ( Number ) ; iconv ( @@a3@@ , Number L , Number L , Number L , Number L ) ; @@v15@@ = Number L ; @@inbuf@@ = @@a1@@ ; @@inbytesleft@@ = @@a2@@ ; while ( @@inbytesleft@@ ) { @@outbuf@@ = @@v21@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; @@outbytesleft@@ = Number L ; @@v16@@ = iconv ( @@a3@@ , & @@inbuf@@ , & @@inbytesleft@@ , & @@outbuf@@ , & @@outbytesleft@@ ) ; if ( @@v16@@ == Number && * __errno_location ( ) != Number ) { if ( * __errno_location ( ) != Number ) return Number ; break ; } @@v15@@ += @@outbuf@@ - @@v21@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; } @@outbuf@@ = @@v21@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; @@outbytesleft@@ = Number L ; @@v17@@ = iconv ( @@a3@@ , Number L , Number L , & @@outbuf@@ , & @@outbytesleft@@ ) ; if ( @@v17@@ == Number ) return Number ; @@v15@@ += @@outbuf@@ - @@v21@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; @@size@@ = @@v15@@ ; if ( ! @@v15@@ ) { * @@a5@@ = Number L ; return Number L ; } if ( * @@a4@@ && @@size@@ <= * @@a5@@ ) { @@ptr@@ = * @@a4@@ ; } else { @@ptr@@ = malloc ( @@size@@ ) ; if ( ! @@ptr@@ ) { * __errno_location ( ) = Number ; return Number ; } } iconv ( @@a3@@ , Number L , Number L , Number L , Number L ) ; @@inbuf@@ = @@a1@@ ; @@inbytesleft@@ = @@a2@@ ; @@outbuf@@ = ( char * ) @@ptr@@ ; @@outbytesleft@@ = @@size@@ ; while ( @@inbytesleft@@ ) { @@v19@@ = iconv ( @@a3@@ , & @@inbuf@@ , & @@inbytesleft@@ , & @@outbuf@@ , & @@outbytesleft@@ ) ; if ( @@v19@@ == Number ) { if ( * __errno_location ( ) != Number ) goto LABEL_26 ; break ; } } @@v20@@ = iconv ( @@a3@@ , Number L , Number L , & @@outbuf@@ , & @@outbytesleft@@ ) ; if ( @@v20@@ != Number ) { if ( @@outbytesleft@@ ) abort ( ) ; * @@a4@@ = @@ptr@@ ; * @@a5@@ = @@size@@ ; return Number L ; } LABEL_26 : if ( @@ptr@@ != * @@a4@@ ) { @@v9@@ = * __errno_location ( ) ; free ( @@ptr@@ ) ; * __errno_location ( ) = @@v9@@ ; } return Number ; }
__int64 __fastcall xstr_iconv ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v4@@ ; @@v4@@ = str_iconv ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( ! @@v4@@ && * __errno_location ( ) == Number ) xalloc_die ( ) ; return @@v4@@ ; }
int getc_unlocked ( FILE * @@stream@@ ) { return getc_unlocked ( @@stream@@ ) ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
bool __fastcall is_basic_2 ( unsigned __int8 @@a1@@ ) { return ( ( * ( ( _DWORD * ) & is_basic_table + ( @@a1@@ >> Number ) ) >> ( @@a1@@ & Number ) ) & Number ) != Number ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
int tcgetattr ( int @@fd@@ , struct termios * @@termios_p@@ ) { return tcgetattr ( @@fd@@ , @@termios_p@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
int cfsetispeed ( struct termios * @@termios_p@@ , speed_t @@speed@@ ) { return cfsetispeed ( @@termios_p@@ , @@speed@@ ) ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_2070C8 ; @@v8@@ [ Number ] = qword_2070D0 ; @@v8@@ [ Number ] = qword_2070D8 ; @@v8@@ [ Number ] = qword_2070E0 ; @@v8@@ [ Number ] = qword_2070E8 ; @@v8@@ [ Number ] = qword_2070F0 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
unsigned __int64 __fastcall print_factors_single ( unsigned __int64 @@a1@@ ) { const char * @@v1@@ ; const char * @@v2@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@v5@@ ; __int64 @@v6@@ [ Number ] ; char @@v7@@ [ Number ] ; unsigned __int64 @@v8@@ ; @@v8@@ = __readfsqword ( Number ) ; @@v5@@ = factor_wheel ( @@a1@@ , Number , ( __int64 ) @@v6@@ ) ; @@v1@@ = ( const char * ) umaxtostr ( @@a1@@ , @@v7@@ ) ; printf ( String , @@v1@@ ) ; for ( @@i@@ = Number L ; @@i@@ < @@v5@@ ; ++ @@i@@ ) { @@v2@@ = ( const char * ) umaxtostr ( @@v6@@ [ @@i@@ ] , @@v7@@ ) ; printf ( String , @@v2@@ ) ; } putchar_unlocked ( Number ) ; return __readfsqword ( Number ) ^ @@v8@@ ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
int __fastcall set_speed ( int @@a1@@ , __int64 @@a2@@ , struct termios * @@a3@@ ) { int @@result@@ ; speed_t @@speed@@ ; @@result@@ = string_to_baud ( @@a2@@ ) ; @@speed@@ = @@result@@ ; if ( ! @@a1@@ || @@a1@@ == Number ) @@result@@ = cfsetispeed ( @@a3@@ , @@result@@ ) ; if ( @@a1@@ == Number || @@a1@@ == Number ) @@result@@ = cfsetospeed ( @@a3@@ , @@speed@@ ) ; return @@result@@ ; }
int putchar_unlocked ( int @@c@@ ) { return putchar_unlocked ( @@c@@ ) ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
int __cdecl __noreturn main ( int @@argc@@ , const char * * @@argv@@ , const char * * @@envp@@ ) { bool @@v3@@ ; int @@i@@ ; int @@v5@@ ; set_program_name ( * @@argv@@ , @@argv@@ , @@envp@@ ) ; setlocale ( Number , shortopts ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; while ( Number ) { @@v5@@ = getopt_long ( @@argc@@ , ( char * const * ) @@argv@@ , shortopts , & long_options , Number L ) ; if ( @@v5@@ == Number ) break ; if ( @@v5@@ == Number ) usage ( Number ) ; if ( @@v5@@ != Number ) { if ( @@v5@@ != Number ) usage ( Number ) ; version_etc ( ( _DWORD ) stdout , ( unsigned int ) String , ( unsigned int ) String , ( _DWORD ) Version , ( unsigned int ) String , Number , ( char ) @@argv@@ ) ; exit ( Number ) ; } verbose = Number ; } if ( @@argc@@ > optind ) { @@v3@@ = Number ; for ( @@i@@ = optind ; @@i@@ < @@argc@@ ; ++ @@i@@ ) { if ( ( unsigned __int8 ) print_factors ( ( __int64 ) @@argv@@ [ @@i@@ ] ) != Number ) @@v3@@ = Number ; } } else { @@v3@@ = do_stdin ( ) ; } exit ( ! @@v3@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
__int64 screen_columns ( ) { __int64 @@v1@@ ; char * @@v2@@ ; char @@v3@@ [ Number ] ; unsigned __int16 @@v4@@ ; unsigned __int64 @@v5@@ ; @@v5@@ = __readfsqword ( Number ) ; if ( ! ( unsigned int ) get_win_size ( Number , ( __int64 ) @@v3@@ ) && @@v4@@ ) return @@v4@@ ; @@v2@@ = getenv ( String ) ; if ( ! @@v2@@ || ( unsigned int ) xstrtol ( @@v2@@ , Number L , Number L , & @@v1@@ , & locale ) || @@v1@@ <= Number || @@v1@@ > Number ) { @@v1@@ = Number L ; } return @@v1@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_20C038 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
int __fastcall display_recoverable ( unsigned int * @@a1@@ ) { unsigned __int64 @@i@@ ; printf ( String , * @@a1@@ , @@a1@@ [ Number ] , @@a1@@ [ Number ] , @@a1@@ [ Number ] ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) printf ( String , * ( ( unsigned __int8 * ) @@a1@@ + @@i@@ + Number ) ) ; return putchar_unlocked ( Number ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@v2@@ ; @@v2@@ = malloc ( @@a1@@ ) ; if ( ! @@v2@@ && @@a1@@ ) xalloc_die ( ) ; return @@v2@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
__int64 __fastcall baud_to_value ( int @@a1@@ ) { int @@i@@ ; for ( @@i@@ = Number ; ( & speeds ) [ Number * @@i@@ ] ; ++ @@i@@ ) { if ( @@a1@@ == * ( ( _DWORD * ) & unk_213868 + Number * @@i@@ ) ) return * ( ( _QWORD * ) & unk_213870 + Number * @@i@@ ) ; } return Number L ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
__int64 __fastcall print_factors ( __int64 @@a1@@ ) { int @@v1@@ ; __int64 @@v2@@ ; char * @@v3@@ ; __int64 @@result@@ ; unsigned __int64 @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; @@v1@@ = xstrtoumax ( @@a1@@ , Number L , Number L , @@v5@@ , shortopts ) ; if ( @@v1@@ ) { if ( @@v1@@ == Number ) { @@v2@@ = quote ( @@a1@@ ) ; @@v3@@ = gettext ( String ) ; } else { @@v2@@ = quote ( @@a1@@ ) ; @@v3@@ = gettext ( String ) ; } error ( Number , Number , @@v3@@ , @@v2@@ ) ; @@result@@ = Number L ; } else { gettext ( String ) ; debug ( ) ; print_factors_single ( @@v5@@ [ Number ] ) ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall mb_copy ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; if ( * ( _QWORD * ) @@a2@@ == @@a2@@ + Number ) { memcpy ( ( void * ) ( @@a1@@ + Number ) , ( const void * ) ( @@a2@@ + Number ) , * ( _QWORD * ) ( @@a2@@ + Number ) ) ; * ( _QWORD * ) @@a1@@ = @@a1@@ + Number ; } else { * ( _QWORD * ) @@a1@@ = * ( _QWORD * ) @@a2@@ ; } * ( _QWORD * ) ( @@a1@@ + Number ) = * ( _QWORD * ) ( @@a2@@ + Number ) ; * ( _BYTE * ) ( @@a1@@ + Number ) = * ( _BYTE * ) ( @@a2@@ + Number ) ; @@result@@ = * ( unsigned __int8 * ) ( @@a1@@ + Number ) ; if ( ( _BYTE ) @@result@@ ) { @@result@@ = @@a1@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = * ( _DWORD * ) ( @@a2@@ + Number ) ; } return @@result@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
speed_t cfgetispeed ( const struct termios * @@termios_p@@ ) { return cfgetispeed ( @@termios_p@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_207028 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
int cfsetospeed ( struct termios * @@termios_p@@ , speed_t @@speed@@ ) { return cfsetospeed ( @@termios_p@@ , @@speed@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall rpl_fcntl ( int @@a1@@ , int @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , __m128 @@a7@@ , __m128 @@a8@@ , __m128 @@a9@@ , __m128 @@a10@@ , __m128 @@a11@@ , __m128 @@a12@@ , __m128 @@a13@@ , __m128 @@a14@@ ) { int @@v14@@ ; int @@v15@@ ; int @@v16@@ ; int @@v18@@ ; int @@v19@@ ; int @@v20@@ ; int @@v21@@ ; __int64 @@v22@@ ; __int64 @@v23@@ ; __int64 @@v24@@ ; __int64 @@v25@@ ; __m128 @@v26@@ ; __m128 @@v27@@ ; __m128 @@v28@@ ; __m128 @@v29@@ ; __m128 @@v30@@ ; __m128 @@v31@@ ; __m128 @@v32@@ ; __m128 @@v33@@ ; @@v22@@ = @@a3@@ ; @@v23@@ = @@a4@@ ; @@v24@@ = @@a5@@ ; @@v25@@ = @@a6@@ ; @@v26@@ = @@a7@@ ; @@v27@@ = @@a8@@ ; @@v28@@ = @@a9@@ ; @@v29@@ = @@a10@@ ; @@v30@@ = @@a11@@ ; @@v31@@ = @@a12@@ ; @@v32@@ = @@a13@@ ; @@v33@@ = @@a14@@ ; if ( @@a2@@ != Number ) return ( unsigned int ) fcntl ( @@a1@@ , @@a2@@ , @@v22@@ ) ; @@v19@@ = @@v22@@ ; if ( have_dupfd_cloexec_2895 < Number ) { @@v18@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v22@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; } else { @@v18@@ = fcntl ( @@a1@@ , Number , ( unsigned int ) @@v22@@ ) ; if ( @@v18@@ < Number && * __errno_location ( ) == Number ) { @@v18@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v19@@ , @@v14@@ , @@v15@@ , @@v16@@ ) ; if ( @@v18@@ < Number ) return ( unsigned int ) @@v18@@ ; have_dupfd_cloexec_2895 = Number ; } else { have_dupfd_cloexec_2895 = Number ; } } if ( @@v18@@ >= Number && have_dupfd_cloexec_2895 == Number ) { @@v20@@ = fcntl ( @@v18@@ , Number ) ; if ( @@v20@@ < Number || fcntl ( @@v18@@ , Number , @@v20@@ | Number ) == Number ) { @@v21@@ = * __errno_location ( ) ; close ( @@v18@@ ) ; * __errno_location ( ) = @@v21@@ ; @@v18@@ = Number ; } } return ( unsigned int ) @@v18@@ ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
_BOOL8 __fastcall c_isalnum ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number || ( int ) ( @@a1@@ & Number ) > Number && ( int ) ( @@a1@@ & Number ) <= Number ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
int putchar_unlocked ( int @@c@@ ) { return putchar_unlocked ( @@c@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
_BOOL8 __fastcall c_iscntrl ( int @@a1@@ ) { return ( @@a1@@ & Number ) == Number || @@a1@@ == Number ; }
speed_t cfgetospeed ( const struct termios * @@termios_p@@ ) { return cfgetospeed ( @@termios_p@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
_BOOL8 __fastcall c_isprint ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
int tcsetattr ( int @@fd@@ , int @@optional_actions@@ , const struct termios * @@termios_p@@ ) { return tcsetattr ( @@fd@@ , @@optional_actions@@ , @@termios_p@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
_BOOL8 __fastcall c_isspace ( int @@a1@@ ) { return @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
unsigned __int64 __fastcall rpl_vasprintf ( void * * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { unsigned __int64 @@result@@ ; unsigned __int64 @@v4@@ ; void * @@ptr@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = __readfsqword ( Number ) ; @@ptr@@ = ( void * ) vasnprintf ( Number L , & @@v4@@ , @@a2@@ , @@a3@@ ) ; if ( ! @@ptr@@ ) return Number ; if ( @@v4@@ <= Number ) { * @@a1@@ = @@ptr@@ ; @@result@@ = @@v4@@ ; } else { free ( @@ptr@@ ) ; * __errno_location ( ) = Number ; @@result@@ = Number ; } return @@result@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
__int64 __fastcall c_tolower ( int @@a1@@ ) { __int64 @@result@@ ; if ( @@a1@@ <= Number || @@a1@@ > Number ) @@result@@ = ( unsigned int ) @@a1@@ ; else @@result@@ = ( unsigned int ) ( @@a1@@ + Number ) ; return @@result@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( ) ; return @@ptr@@ ; }
char * nl_langinfo ( nl_item @@item@@ ) { return nl_langinfo ( @@item@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
size_t __fastcall mbslen ( const char * @@a1@@ ) { __int64 @@v3@@ ; char @@v4@@ [ Number ] ; int @@v5@@ ; char @@i@@ ; const char * @@v7@@ ; __int64 @@v8@@ ; char @@v9@@ ; int @@v10@@ ; unsigned __int64 @@v11@@ ; @@v11@@ = __readfsqword ( Number ) ; if ( __ctype_get_mb_cur_max ( ) <= Number ) return strlen ( @@a1@@ ) ; @@v3@@ = Number L ; @@v7@@ = @@a1@@ ; @@v4@@ [ Number ] = Number ; memset ( & @@v5@@ , Number , Number ) ; for ( @@i@@ = Number ; ; @@i@@ = Number ) { mbuiter_multi_next_1 ( ( __int64 ) @@v4@@ ) ; if ( @@v9@@ == Number && ! @@v10@@ ) break ; ++ @@v3@@ ; @@v7@@ += @@v8@@ ; } return @@v3@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
__int64 __fastcall bkm_scale ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( * @@a1@@ >= ( __int64 ) Number / @@a2@@ ) { if ( Number / @@a2@@ >= * @@a1@@ ) { * @@a1@@ *= @@a2@@ ; @@result@@ = Number L ; } else { * @@a1@@ = Number ; @@result@@ = Number L ; } } else { * @@a1@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int64 __fastcall mode_type_flag ( int @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; switch ( @@a1@@ ) { case Number : @@result@@ = @@a2@@ + Number ; break ; case Number : @@result@@ = @@a2@@ ; break ; case Number : @@result@@ = @@a2@@ + Number ; break ; case Number : @@result@@ = @@a2@@ + Number ; break ; case Number : @@result@@ = Number L ; break ; default : abort ( ) ; } return @@result@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
__int64 decimal_point_char ( ) { __int64 @@result@@ ; char * @@v1@@ ; @@v1@@ = nl_langinfo ( Number ) ; if ( * @@v1@@ ) @@result@@ = ( unsigned __int8 ) * @@v1@@ ; else @@result@@ = Number L ; return @@result@@ ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
__int64 __fastcall get_win_size ( int @@a1@@ , __int64 @@a2@@ ) { return ( unsigned int ) ioctl ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall string_to_baud ( const char * @@a1@@ ) { int @@i@@ ; for ( @@i@@ = Number ; ( & speeds ) [ Number * @@i@@ ] ; ++ @@i@@ ) { if ( ! strcmp ( @@a1@@ , ( & speeds ) [ Number * @@i@@ ] ) ) return * ( ( unsigned int * ) & unk_213868 + Number * @@i@@ ) ; } return Number ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) _frame_dummy_init_array_entry [ @@i@@ ] ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
int __fxstatat ( int @@ver@@ , int @@fildes@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ , int @@flag@@ ) { return _fxstatat ( @@ver@@ , @@fildes@@ , @@filename@@ , @@stat_buf@@ , @@flag@@ ) ; }
unsigned __int64 __fastcall display_window_size ( char @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; int * @@v4@@ ; char * @@v5@@ ; const char * @@v6@@ ; __int16 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; if ( ( unsigned int ) get_win_size ( Number , ( __int64 ) @@v8@@ ) ) { if ( * __errno_location ( ) != Number ) { @@v4@@ = __errno_location ( ) ; error ( Number , * @@v4@@ , format , @@a2@@ ) ; } if ( @@a1@@ != Number ) { @@v5@@ = gettext ( String ) ; error ( Number , Number , @@v5@@ , @@a2@@ ) ; } } else { if ( @@a1@@ ) @@v6@@ = String ; else @@v6@@ = String ; wrapf ( ( __int64 ) @@v6@@ , ( unsigned __int16 ) @@v8@@ [ Number ] , ( unsigned __int16 ) @@v8@@ [ Number ] , ( unsigned __int16 ) @@v8@@ [ Number ] , @@v2@@ , @@v3@@ , @@a2@@ ) ; if ( @@a1@@ != Number ) current_col = Number ; } return __readfsqword ( Number ) ^ @@v9@@ ; }
__int64 __fastcall integer_arg ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { __int64 @@v2@@ ; char * @@v3@@ ; __int64 @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; if ( ( unsigned int ) xstrtoul ( @@a1@@ , Number L , Number L , @@v5@@ , String ) || @@a2@@ < @@v5@@ [ Number ] ) { @@v2@@ = quote ( @@a1@@ ) ; @@v3@@ = gettext ( String ) ; error ( Number , Number , @@v3@@ , @@v2@@ ) ; usage ( Number ) ; } return @@v5@@ [ Number ] ; }
__int64 __fastcall readtoken ( FILE * @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ , __int64 * @@a4@@ ) { __int64 @@v5@@ ; char @@v8@@ ; int @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@j@@ ; unsigned __int64 @@v14@@ ; @@v14@@ = __readfsqword ( Number ) ; if ( ! @@a2@@ && ! saved_delim_3296 ) abort ( ) ; @@v8@@ = Number ; if ( @@a2@@ != saved_delim_3296 && saved_delim_3296 ) { @@v8@@ = Number ; for ( @@i@@ = Number L ; @@i@@ < @@a3@@ ; ++ @@i@@ ) { if ( * ( _BYTE * ) ( @@a2@@ + @@i@@ ) != * ( _BYTE * ) ( saved_delim_3296 + @@i@@ ) ) { @@v8@@ = Number ; break ; } } } if ( @@v8@@ != Number ) { saved_delim_3296 = @@a2@@ ; memset ( isdelim_3297 , Number , sizeof ( isdelim_3297 ) ) ; for ( @@j@@ = Number L ; @@j@@ < @@a3@@ ; ++ @@j@@ ) isdelim_3297 [ * ( unsigned __int8 * ) ( @@a2@@ + @@j@@ ) ] = Number ; } do @@v9@@ = getc_unlocked ( @@a1@@ ) ; while ( @@v9@@ >= Number && isdelim_3297 [ @@v9@@ ] ) ; @@v11@@ = @@a4@@ [ Number ] ; @@v10@@ = * @@a4@@ ; @@i@@ = Number L ; while ( Number ) { if ( @@v9@@ < Number && ! @@i@@ ) return Number ; if ( @@i@@ == @@v10@@ ) @@v11@@ = x2nrealloc ( @@v11@@ , & @@v10@@ , Number L ) ; if ( @@v9@@ < Number ) { * ( _BYTE * ) ( @@v11@@ + @@i@@ ) = Number ; goto LABEL_28 ; } if ( isdelim_3297 [ @@v9@@ ] ) break ; @@v5@@ = @@i@@ ++ ; * ( _BYTE * ) ( @@v11@@ + @@v5@@ ) = @@v9@@ ; @@v9@@ = getc_unlocked ( @@a1@@ ) ; } * ( _BYTE * ) ( @@v11@@ + @@i@@ ) = Number ; LABEL_28 : @@a4@@ [ Number ] = @@v11@@ ; * @@a4@@ = @@v10@@ ; return @@i@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
int __fxstat ( int @@ver@@ , int @@fildes@@ , struct stat * @@stat_buf@@ ) { return _fxstat ( @@ver@@ , @@fildes@@ , @@stat_buf@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
__int64 __fastcall strtoul_tcflag_t ( const char * @@a1@@ , int @@a2@@ , char * * @@a3@@ , _DWORD * @@a4@@ , char @@a5@@ ) { unsigned __int64 @@v9@@ ; * __errno_location ( ) = Number ; @@v9@@ = strtoul ( @@a1@@ , @@a3@@ , @@a2@@ ) ; if ( * __errno_location ( ) || @@a5@@ != * * @@a3@@ || @@a1@@ == * @@a3@@ || @@v9@@ != ( unsigned int ) @@v9@@ ) { return Number ; } * @@a4@@ = @@v9@@ ; return Number L ; }
unsigned __int64 __fastcall set_window_size ( int @@a1@@ , int @@a2@@ , __int64 @@a3@@ ) { int * @@v3@@ ; int * @@v4@@ ; __int16 @@s@@ [ Number ] ; unsigned __int64 @@v8@@ ; @@v8@@ = __readfsqword ( Number ) ; if ( ( unsigned int ) get_win_size ( Number , ( __int64 ) @@s@@ ) ) { if ( * __errno_location ( ) != Number ) { @@v3@@ = __errno_location ( ) ; error ( Number , * @@v3@@ , format , @@a3@@ ) ; } memset ( @@s@@ , Number , sizeof ( @@s@@ ) ) ; } if ( @@a1@@ >= Number ) @@s@@ [ Number ] = @@a1@@ ; if ( @@a2@@ >= Number ) @@s@@ [ Number ] = @@a2@@ ; if ( ioctl ( Number , Number , @@s@@ ) ) { @@v4@@ = __errno_location ( ) ; error ( Number , * @@v4@@ , format , @@a3@@ ) ; } return __readfsqword ( Number ) ^ @@v8@@ ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
char * __fastcall sane_mode ( __int64 @@a1@@ ) { char * @@result@@ ; int @@i@@ ; int @@j@@ ; _DWORD * @@v4@@ ; _DWORD * @@v5@@ ; for ( @@i@@ = Number ; ( & control_info ) [ Number * @@i@@ ] ; ++ @@i@@ ) * ( _BYTE * ) ( @@a1@@ + * ( ( _QWORD * ) & unk_2135F0 + Number * @@i@@ ) + Number ) = * ( ( _BYTE * ) & unk_2135E8 + Number * @@i@@ ) ; for ( @@j@@ = Number ; ; ++ @@j@@ ) { @@result@@ = ( & mode_info ) [ Number * @@j@@ ] ; if ( ! @@result@@ ) break ; if ( ( * ( ( _BYTE * ) & unk_212B0C + Number * @@j@@ ) & Number ) != Number ) { @@v4@@ = ( _DWORD * ) mode_type_flag ( * ( ( _DWORD * ) & unk_212B08 + Number * @@j@@ ) , @@a1@@ ) ; * @@v4@@ = * ( ( _QWORD * ) & unk_212B10 + Number * @@j@@ ) | ~ ( unsigned int ) * ( ( _QWORD * ) & unk_212B18 + Number * @@j@@ ) & * @@v4@@ ; } else if ( ( * ( ( _BYTE * ) & unk_212B0C + Number * @@j@@ ) & Number ) != Number ) { @@v5@@ = ( _DWORD * ) mode_type_flag ( * ( ( _DWORD * ) & unk_212B08 + Number * @@j@@ ) , @@a1@@ ) ; * @@v5@@ &= ~ ( unsigned int ) * ( ( _QWORD * ) & unk_212B10 + Number * @@j@@ ) & ~ ( unsigned int ) * ( ( _QWORD * ) & unk_212B18 + Number * @@j@@ ) ; } } return @@result@@ ; }
__int64 __fastcall display_settings ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@result@@ ; @@result@@ = @@a1@@ ; switch ( @@a1@@ ) { case Number : return display_all ( @@a2@@ , @@a3@@ ) ; case Number : return display_changed ( @@a2@@ ) ; case Number : @@result@@ = display_recoverable ( @@a2@@ ) ; break ; } return @@result@@ ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; FILE * @@v11@@ ; char * @@v12@@ ; FILE * @@v13@@ ; char * @@v14@@ ; FILE * @@v15@@ ; char * @@v16@@ ; FILE * @@v17@@ ; char * @@v18@@ ; if ( @@a1@@ ) { @@v1@@ = program_name ; @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = program_name ; @@v4@@ = program_name ; @@v5@@ = program_name ; @@v6@@ = gettext ( String String String ) ; printf ( @@v6@@ , @@v5@@ , @@v4@@ , @@v3@@ ) ; @@v7@@ = stdout ; @@v8@@ = gettext ( String String String String ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = stdout ; @@v10@@ = gettext ( String String String String ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; @@v11@@ = stdout ; @@v12@@ = gettext ( String String String String String ) ; fputs_unlocked ( @@v12@@ , @@v11@@ ) ; @@v13@@ = stdout ; @@v14@@ = gettext ( String String String String String String String String String String ) ; fputs_unlocked ( @@v14@@ , @@v13@@ ) ; @@v15@@ = stdout ; @@v16@@ = gettext ( String ) ; fputs_unlocked ( @@v16@@ , @@v15@@ ) ; @@v17@@ = stdout ; @@v18@@ = gettext ( String ) ; fputs_unlocked ( @@v18@@ , @@v17@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
__int64 __fastcall recover_mode ( const char * @@a1@@ , _DWORD * @@a2@@ ) { char @@v3@@ ; char * @@v4@@ ; const char * @@v5@@ ; unsigned __int64 @@i@@ ; int @@v7@@ [ Number ] ; unsigned __int64 @@v8@@ ; @@v8@@ = __readfsqword ( Number ) ; @@v5@@ = @@a1@@ ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( ( unsigned int ) strtoul_tcflag_t ( @@v5@@ , Number , & @@v4@@ , & @@v7@@ [ @@i@@ ] , Number ) ) return Number L ; @@v5@@ = @@v4@@ + Number ; } * @@a2@@ = @@v7@@ [ Number ] ; @@a2@@ [ Number ] = @@v7@@ [ Number ] ; @@a2@@ [ Number ] = @@v7@@ [ Number ] ; @@a2@@ [ Number ] = @@v7@@ [ Number ] ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( @@i@@ > Number ) @@v3@@ = Number ; else @@v3@@ = Number ; if ( ( unsigned int ) strtoul_cc_t ( @@v5@@ , Number , & @@v4@@ , ( _BYTE * ) @@a2@@ + @@i@@ + Number , @@v3@@ ) ) return Number L ; @@v5@@ = @@v4@@ + Number ; } return Number L ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
_BOOL8 __fastcall AD_compare ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { return @@a1@@ [ Number ] == @@a2@@ [ Number ] && * @@a1@@ == * @@a2@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_214028 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
__int64 __fastcall enter_dir ( __int64 @@a1@@ , __int64 @@a2@@ ) { _QWORD * @@ptr@@ ; __int64 @@v4@@ ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { @@ptr@@ = malloc ( Number ) ; if ( ! @@ptr@@ ) return Number L ; * @@ptr@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@ptr@@ [ Number ] = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@ptr@@ [ Number ] = @@a2@@ ; @@v4@@ = hash_insert ( * ( _QWORD * ) ( @@a1@@ + Number ) , @@ptr@@ ) ; if ( ( _QWORD * ) @@v4@@ != @@ptr@@ ) { free ( @@ptr@@ ) ; if ( ! @@v4@@ ) return Number L ; * ( _QWORD * ) @@a2@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; * ( _WORD * ) ( @@a2@@ + Number ) = Number ; } } else if ( ( unsigned __int8 ) cycle_check ( * ( _QWORD * ) ( @@a1@@ + Number ) , @@a2@@ + Number ) ) { * ( _QWORD * ) @@a2@@ = @@a2@@ ; * ( _WORD * ) ( @@a2@@ + Number ) = Number ; } return Number L ; }
unsigned __int64 __fastcall readtokens ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , unsigned __int64 @@a4@@ , _QWORD * @@a5@@ , _QWORD * @@a6@@ ) { void * * @@v6@@ ; __int64 @@v12@@ ; unsigned __int64 @@v13@@ ; __int64 @@v14@@ ; __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; __int64 * @@v17@@ ; __int64 @@v18@@ ; void * @@dest@@ ; char @@v20@@ ; unsigned __int64 @@v21@@ ; @@v21@@ = __readfsqword ( Number ) ; @@v17@@ = ( __int64 * ) & @@v20@@ ; if ( @@a2@@ ) @@v12@@ = @@a2@@ + Number ; else @@v12@@ = Number L ; @@v13@@ = @@v12@@ ; @@v14@@ = xnmalloc ( @@v12@@ , Number L ) ; @@v15@@ = xnmalloc ( @@v12@@ , Number L ) ; @@v16@@ = Number L ; init_tokenbuffer ( @@v17@@ ) ; while ( Number ) { @@v18@@ = readtoken ( @@a1@@ , @@a3@@ , @@a4@@ , @@v17@@ ) ; if ( @@v16@@ >= @@v13@@ ) { @@v14@@ = x2nrealloc ( @@v14@@ , & @@v13@@ , Number L ) ; @@v15@@ = xnrealloc ( @@v15@@ , @@v13@@ , Number L ) ; } if ( @@v18@@ == Number ) break ; @@dest@@ = ( void * ) xnmalloc ( @@v18@@ + Number , Number L ) ; * ( _QWORD * ) ( @@v15@@ + Number * @@v16@@ ) = @@v18@@ ; @@v6@@ = ( void * * ) ( Number * @@v16@@ + @@v14@@ ) ; * @@v6@@ = memcpy ( @@dest@@ , ( const void * ) @@v17@@ [ Number ] , @@v18@@ + Number ) ; ++ @@v16@@ ; } * ( _QWORD * ) ( Number * @@v16@@ + @@v14@@ ) = Number L ; * ( _QWORD * ) ( Number * @@v16@@ + @@v15@@ ) = Number L ; free ( ( void * ) @@v17@@ [ Number ] ) ; * @@a5@@ = @@v14@@ ; if ( @@a6@@ ) * @@a6@@ = @@v15@@ ; return @@v16@@ ; }
__int64 __fastcall xsum4 ( unsigned __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ ) { __int64 @@v4@@ ; __int64 @@v5@@ ; @@v4@@ = xsum ( @@a1@@ , @@a2@@ ) ; @@v5@@ = xsum ( @@v4@@ , @@a3@@ ) ; return xsum ( @@v5@@ , @@a4@@ ) ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , off_109D6 , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
__int64 __fastcall fts_close ( __int64 @@a1@@ ) { _QWORD * @@v1@@ ; void * @@v2@@ ; _QWORD * @@v3@@ ; int @@v5@@ ; @@v5@@ = Number ; if ( * ( _QWORD * ) @@a1@@ ) { @@v1@@ = * ( _QWORD * * ) @@a1@@ ; while ( ( __int64 ) @@v1@@ [ Number ] >= Number ) { @@v2@@ = @@v1@@ ; if ( @@v1@@ [ Number ] ) @@v3@@ = ( _QWORD * ) @@v1@@ [ Number ] ; else @@v3@@ = ( _QWORD * ) @@v1@@ [ Number ] ; @@v1@@ = @@v3@@ ; free ( @@v2@@ ) ; } free ( @@v1@@ ) ; } if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) fts_lfree ( * ( void * * ) ( @@a1@@ + Number ) ) ; free ( * ( void * * ) ( @@a1@@ + Number ) ) ; free ( * ( void * * ) ( @@a1@@ + Number ) ) ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { if ( * ( int * ) ( @@a1@@ + Number ) >= Number && close ( * ( _DWORD * ) ( @@a1@@ + Number ) ) ) { LABEL_20 : @@v5@@ = * __errno_location ( ) ; goto LABEL_21 ; } } else if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) == Number ) { if ( fchdir ( * ( _DWORD * ) ( @@a1@@ + Number ) ) ) @@v5@@ = * __errno_location ( ) ; if ( close ( * ( _DWORD * ) ( @@a1@@ + Number ) ) && ! @@v5@@ ) goto LABEL_20 ; } LABEL_21 : fd_ring_clear ( @@a1@@ + Number ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) hash_free ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ; free_dir ( @@a1@@ ) ; free ( ( void * ) @@a1@@ ) ; if ( ! @@v5@@ ) return Number L ; * __errno_location ( ) = @@v5@@ ; return Number ; }
__int64 __fastcall xsum_0 ( unsigned __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; if ( @@a1@@ + @@a2@@ < @@a1@@ ) @@result@@ = Number ; else @@result@@ = @@a1@@ + @@a2@@ ; return @@result@@ ; }
__int64 __fastcall set_control_char ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@result@@ ; __int64 @@v5@@ ; if ( ! strcmp ( * ( const char * * ) @@a1@@ , String ) || ! strcmp ( * ( const char * * ) @@a1@@ , String ) ) { goto LABEL_15 ; } if ( * ( _BYTE * ) @@a2@@ && * ( _BYTE * ) ( @@a2@@ + Number ) ) { if ( ! strcmp ( ( const char * ) @@a2@@ , String ) || ! strcmp ( ( const char * ) @@a2@@ , String ) ) { LOBYTE ( @@v5@@ ) = Number ; } else { if ( * ( _BYTE * ) @@a2@@ != Number || ! * ( _BYTE * ) ( @@a2@@ + Number ) ) { LABEL_15 : LOBYTE ( @@v5@@ ) = integer_arg ( @@a2@@ , Number L ) ; goto LABEL_16 ; } if ( * ( _BYTE * ) ( @@a2@@ + Number ) == Number ) LOBYTE ( @@v5@@ ) = Number ; else @@v5@@ = to_uchar ( * ( _BYTE * ) ( @@a2@@ + Number ) ) & Number ; } } else { LOBYTE ( @@v5@@ ) = to_uchar ( * ( _BYTE * ) @@a2@@ ) ; } LABEL_16 : @@result@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _BYTE * ) ( @@a3@@ + @@result@@ + Number ) = @@v5@@ ; return @@result@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
__int64 __fastcall fts_sort ( __int64 @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { size_t @@v3@@ ; _QWORD * @@v5@@ ; __int64 @@i@@ ; _QWORD * @@v7@@ ; _QWORD * @@v8@@ ; __int64 @@v9@@ ; int ( * @@compar@@ ( ) ( constvoid , constvoid ) ) ( const void * , const void * ) ; void * @@v11@@ ; @@v3@@ = @@a3@@ ; @@compar@@ ( ) ( constvoid , constvoid ) = * ( int ( * * ) ( const void * , const void * ) ) ( @@a1@@ + Number ) ; if ( @@a3@@ > * ( _QWORD * ) ( @@a1@@ + Number ) ) { * ( _QWORD * ) ( @@a1@@ + Number ) = @@a3@@ + Number ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) > Number || ( @@v11@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number L * * ( _QWORD * ) ( @@a1@@ + Number ) ) ) == Number L ) { free ( * ( void * * ) ( @@a1@@ + Number ) ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; return @@a2@@ ; } * ( _QWORD * ) ( @@a1@@ + Number ) = @@v11@@ ; } @@v5@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; for ( @@i@@ = @@a2@@ ; @@i@@ ; @@i@@ = * ( _QWORD * ) ( @@i@@ + Number ) ) { @@v7@@ = @@v5@@ ++ ; * @@v7@@ = @@i@@ ; } qsort ( * ( void * * ) ( @@a1@@ + Number ) , @@v3@@ , Number , @@compar@@ ( ) ( constvoid , constvoid ) ) ; @@v8@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; @@v9@@ = * @@v8@@ ; while ( -- @@v3@@ ) { * ( _QWORD * ) ( * @@v8@@ + Number L ) = @@v8@@ [ Number ] ; ++ @@v8@@ ; } * ( _QWORD * ) ( * @@v8@@ + Number L ) = Number L ; return @@v9@@ ; }
__int64 __fastcall strtoul_cc_t ( const char * @@a1@@ , int @@a2@@ , char * * @@a3@@ , _BYTE * @@a4@@ , char @@a5@@ ) { unsigned __int64 @@v9@@ ; * __errno_location ( ) = Number ; @@v9@@ = strtoul ( @@a1@@ , @@a3@@ , @@a2@@ ) ; if ( * __errno_location ( ) || @@a5@@ != * * @@a3@@ || @@a1@@ == * @@a3@@ || @@v9@@ != ( unsigned __int8 ) @@v9@@ ) { return Number ; } * @@a4@@ = @@v9@@ ; return Number L ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 __fastcall xnrealloc ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { if ( ! is_mul_ok ( @@a3@@ , @@a2@@ ) ) xalloc_die ( ) ; return xrealloc ( @@a1@@ , @@a3@@ * @@a2@@ ) ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
__int64 __fastcall hash_get_n_buckets ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
int dirfd ( DIR * @@dirp@@ ) { return dirfd ( @@dirp@@ ) ; }
__int64 __fastcall hash_get_n_entries ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
int fchdir ( int @@fd@@ ) { return fchdir ( @@fd@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_214028 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v4@@ ; @@v4@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v4@@ >= Number / @@a3@@ ) xalloc_die ( ) ; @@v4@@ += ( @@v4@@ + Number ) >> Number ; } else if ( ! @@v4@@ ) { @@v4@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v4@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v4@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
_BOOL8 __fastcall hash_table_ok ( __int64 @@a1@@ ) { _QWORD * @@i@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; _QWORD * @@v5@@ ; @@v3@@ = Number L ; @@v4@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { @@v5@@ = @@i@@ ; ++ @@v3@@ ; ++ @@v4@@ ; while ( Number ) { @@v5@@ = ( _QWORD * ) @@v5@@ [ Number ] ; if ( ! @@v5@@ ) break ; ++ @@v4@@ ; } } } return @@v3@@ == * ( _QWORD * ) ( @@a1@@ + Number ) && @@v4@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ; }
const char * __fastcall visible ( unsigned __int8 @@a1@@ ) { _BYTE * @@v2@@ ; _BYTE * @@v3@@ ; if ( ! @@a1@@ ) return String ; if ( @@a1@@ <= Number ) { buf_5942 [ Number ] = Number ; @@v2@@ = & buf_5942 [ Number ] ; buf_5942 [ Number ] = @@a1@@ + Number ; } else if ( @@a1@@ > Number ) { if ( @@a1@@ == Number ) { buf_5942 [ Number ] = Number ; @@v2@@ = & buf_5942 [ Number ] ; buf_5942 [ Number ] = Number ; } else { buf_5942 [ Number ] = Number ; @@v3@@ = & buf_5942 [ Number ] ; buf_5942 [ Number ] = Number ; if ( @@a1@@ <= Number ) { * @@v3@@ = Number ; @@v2@@ = & buf_5942 [ Number ] ; buf_5942 [ Number ] = @@a1@@ - Number ; } else if ( @@a1@@ == Number ) { * @@v3@@ = Number ; @@v2@@ = & buf_5942 [ Number ] ; buf_5942 [ Number ] = Number ; } else { @@v2@@ = & buf_5942 [ Number ] ; buf_5942 [ Number ] = @@a1@@ + Number ; } } } else { @@v2@@ = & buf_5942 [ Number ] ; buf_5942 [ Number ] = @@a1@@ ; } * @@v2@@ = Number ; return buf_5942 ; }
__int64 __fastcall compute_context_from_mask ( __int64 @@a1@@ , unsigned int * @@a2@@ ) { __int64 @@v2@@ ; char * @@v3@@ ; int * @@v4@@ ; __int64 @@result@@ ; __int64 @@v6@@ ; char * @@v7@@ ; int * @@v8@@ ; __int64 @@v9@@ ; char * @@v10@@ ; int * @@v11@@ ; __int64 @@v12@@ ; char * @@v13@@ ; int * @@v14@@ ; __int64 @@v15@@ ; char * @@v16@@ ; int * @@v17@@ ; char @@v18@@ ; unsigned int @@v19@@ ; int @@v20@@ ; @@v18@@ = Number ; @@v19@@ = context_new ( @@a1@@ ) ; if ( @@v19@@ ) { if ( specified_user && ( unsigned int ) context_user_set ( @@v19@@ , specified_user ) ) { @@v6@@ = quote ( specified_user ) ; @@v7@@ = gettext ( String ) ; @@v8@@ = __errno_location ( ) ; error ( Number , * @@v8@@ , @@v7@@ , String , @@v6@@ ) ; @@v18@@ = Number ; } if ( specified_range && ( unsigned int ) context_range_set ( @@v19@@ , specified_range ) ) { @@v9@@ = quote ( specified_range ) ; @@v10@@ = gettext ( String ) ; @@v11@@ = __errno_location ( ) ; error ( Number , * @@v11@@ , @@v10@@ , String , @@v9@@ ) ; @@v18@@ = Number ; } if ( specified_role && ( unsigned int ) context_role_set ( @@v19@@ , specified_role ) ) { @@v12@@ = quote ( specified_role ) ; @@v13@@ = gettext ( String ) ; @@v14@@ = __errno_location ( ) ; error ( Number , * @@v14@@ , @@v13@@ , String , @@v12@@ ) ; @@v18@@ = Number ; } if ( specified_type && ( unsigned int ) context_type_set ( @@v19@@ , specified_type ) ) { @@v15@@ = quote ( specified_type ) ; @@v16@@ = gettext ( String ) ; @@v17@@ = __errno_location ( ) ; error ( Number , * @@v17@@ , @@v16@@ , String , @@v15@@ ) ; @@v18@@ = Number ; } if ( @@v18@@ != Number ) { @@v20@@ = * __errno_location ( ) ; context_free ( ) ; * __errno_location ( ) = @@v20@@ ; @@result@@ = Number L ; } else { * @@a2@@ = @@v19@@ ; @@result@@ = Number L ; } } else { @@v2@@ = quotearg_colon ( @@a1@@ ) ; @@v3@@ = gettext ( String ) ; @@v4@@ = __errno_location ( ) ; error ( Number , * @@v4@@ , @@v3@@ , @@v2@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall hash_get_next ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; _QWORD * @@v4@@ ; _QWORD * @@i@@ ; @@v2@@ = * @@a1@@ ; @@v4@@ = ( _QWORD * ) ( @@v2@@ + Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) ) ; if ( ( unsigned __int64 ) @@v4@@ >= @@a1@@ [ Number ] ) abort ( ) ; for ( @@i@@ = @@v4@@ ; @@i@@ ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { if ( @@a2@@ == * @@i@@ && @@i@@ [ Number ] ) return * ( _QWORD * ) @@i@@ [ Number ] ; } while ( Number ) { @@v4@@ += Number ; if ( ( unsigned __int64 ) @@v4@@ >= @@a1@@ [ Number ] ) break ; if ( * @@v4@@ ) return * @@v4@@ ; } return Number L ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
__int64 __fastcall bkm_scale_by_power_0 ( unsigned __int64 * @@a1@@ , int @@a2@@ , int @@a3@@ ) { unsigned int @@i@@ ; for ( @@i@@ = Number ; @@a3@@ -- ; @@i@@ |= bkm_scale_0 ( @@a1@@ , @@a2@@ ) ) { ; } return @@i@@ ; }
unsigned __int64 __fastcall raw_hasher ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return rotr_sz ( @@a1@@ , Number ) % @@a2@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_2140E8 ; @@v8@@ [ Number ] = qword_2140F0 ; @@v8@@ [ Number ] = qword_2140F8 ; @@v8@@ [ Number ] = qword_214100 ; @@v8@@ [ Number ] = qword_214108 ; @@v8@@ [ Number ] = qword_214110 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
unsigned __int64 __fastcall leave_dir ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 * @@v3@@ ; __int64 * @@v4@@ ; void * @@ptr@@ ; __int64 @@v6@@ [ Number ] ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v3@@ = ( __int64 * ) ( @@a2@@ + Number ) ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { @@v6@@ [ Number ] = * @@v3@@ ; @@v6@@ [ Number ] = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@ptr@@ = ( void * ) hash_delete ( * ( _QWORD * ) ( @@a1@@ + Number ) , @@v6@@ ) ; if ( ! @@ptr@@ ) abort ( ) ; free ( @@ptr@@ ) ; } else { @@v4@@ = * ( __int64 * * ) ( @@a2@@ + Number ) ; if ( @@v4@@ && @@v4@@ [ Number ] >= Number ) { if ( ! * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L ) ) abort ( ) ; if ( * * ( _QWORD * * ) ( @@a1@@ + Number ) == * ( _QWORD * ) ( @@a2@@ + Number ) && * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L ) == * @@v3@@ ) { * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L ) = @@v4@@ [ Number ] ; * * ( _QWORD * * ) ( @@a1@@ + Number ) = @@v4@@ [ Number ] ; } } } return __readfsqword ( Number ) ^ @@v7@@ ; }
unsigned __int64 __fastcall compute_bucket_size ( __int64 @@a1@@ , __int64 @@a2@@ ) { float @@v2@@ ; unsigned __int64 @@result@@ ; unsigned __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; float @@v6@@ ; @@v4@@ = @@a1@@ ; if ( * ( _BYTE * ) ( @@a2@@ + Number ) != Number ) { if ( @@a1@@ < Number ) @@v2@@ = ( float ) ( @@a1@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@a1@@ >> Number ) ) + ( float ) ( @@a1@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@a1@@ >> Number ) ) ; else @@v2@@ = ( float ) ( int ) @@a1@@ ; @@v6@@ = @@v2@@ / * ( float * ) ( @@a2@@ + Number ) ; if ( @@v6@@ >= Number ) return Number L ; if ( @@v6@@ >= Number ) @@v4@@ = ( unsigned int ) ( int ) ( float ) ( @@v6@@ - Number ) ^ Number ; else @@v4@@ = ( unsigned int ) ( int ) @@v6@@ ; } @@v5@@ = next_prime ( @@v4@@ ) ; if ( @@v5@@ <= Number ) @@result@@ = @@v5@@ ; else @@result@@ = Number L ; return @@result@@ ; }
void * __fastcall xzalloc ( size_t @@a1@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@a1@@ ) ; return memset ( @@v1@@ , Number , @@a1@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
_BOOL8 __fastcall dirent_inode_sort_may_be_useful ( int @@a1@@ ) { struct statfs @@buf@@ ; unsigned __int64 @@v3@@ ; @@v3@@ = __readfsqword ( Number ) ; if ( fstatfs ( @@a1@@ , & @@buf@@ ) ) return Number L ; return @@buf@@ . f_type != Number && @@buf@@ . f_type != Number ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
bool __fastcall LCO_compare ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { return * @@a1@@ == * @@a2@@ ; }
int __lxstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _lxstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
__int64 __fastcall transfer_entries ( __int64 @@a1@@ , __int64 @@a2@@ , char @@a3@@ ) { __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 * @@i@@ ; _QWORD * @@j@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; _QWORD * @@v11@@ ; _QWORD * @@v12@@ ; _QWORD * @@v13@@ ; _QWORD * @@v14@@ ; for ( @@i@@ = * ( __int64 * * ) @@a2@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a2@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = ( _QWORD * ) @@i@@ [ Number ] ; @@j@@ ; @@j@@ = @@v14@@ ) { @@v9@@ = * @@j@@ ; @@v3@@ = * ( _QWORD * ) @@a1@@ ; @@v11@@ = ( _QWORD * ) ( @@v3@@ + Number * ( * ( __int64 ( __fastcall * * ) ( _QWORD , _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@j@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@v11@@ >= * ( _QWORD * ) ( @@a1@@ + Number ) ) abort ( ) ; @@v14@@ = ( _QWORD * ) @@j@@ [ Number ] ; if ( * @@v11@@ ) { @@j@@ [ Number ] = @@v11@@ [ Number ] ; @@v11@@ [ Number ] = @@j@@ ; } else { * @@v11@@ = @@v9@@ ; ++ * ( _QWORD * ) ( @@a1@@ + Number ) ; free_entry ( @@a1@@ , @@j@@ ) ; } } @@v10@@ = * @@i@@ ; @@i@@ [ Number ] = Number L ; if ( ! @@a3@@ ) { @@v4@@ = * ( _QWORD * ) @@a1@@ ; @@v12@@ = ( _QWORD * ) ( @@v4@@ + Number * ( * ( __int64 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@v10@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@v12@@ >= * ( _QWORD * ) ( @@a1@@ + Number ) ) abort ( ) ; if ( * @@v12@@ ) { @@v13@@ = allocate_entry ( @@a1@@ ) ; if ( ! @@v13@@ ) return Number L ; * @@v13@@ = @@v10@@ ; @@v13@@ [ Number ] = @@v12@@ [ Number ] ; @@v12@@ [ Number ] = @@v13@@ ; } else { * @@v12@@ = @@v10@@ ; ++ * ( _QWORD * ) ( @@a1@@ + Number ) ; } * @@i@@ = Number L ; -- * ( _QWORD * ) ( @@a2@@ + Number ) ; } } } return Number L ; }
__int64 __fastcall bkm_scale_0 ( unsigned __int64 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( is_mul_ok ( @@a2@@ , * @@a1@@ ) ) { * @@a1@@ *= @@a2@@ ; @@result@@ = Number L ; } else { * @@a1@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
int closedir ( DIR * @@dirp@@ ) { return closedir ( @@dirp@@ ) ; }
__int64 __fastcall fts_set ( __int64 a1 , __int64 @@a2@@ , int @@a3@@ ) { __int64 @@result@@ ; if ( ! @@a3@@ || @@a3@@ == Number || @@a3@@ == Number || @@a3@@ == Number || @@a3@@ == Number ) { * ( _WORD * ) ( @@a2@@ + Number ) = @@a3@@ ; @@result@@ = Number L ; } else { * __errno_location ( ) = Number ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall xsum ( unsigned __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; if ( @@a1@@ + @@a2@@ < @@a1@@ ) @@result@@ = Number ; else @@result@@ = @@a1@@ + @@a2@@ ; return @@result@@ ; }
struct dirent * readdir ( DIR * @@dirp@@ ) { return readdir ( @@dirp@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
DIR * fdopendir ( int @@fd@@ ) { return fdopendir ( @@fd@@ ) ; }
unsigned __int64 __fastcall xmax ( unsigned __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { unsigned __int64 @@result@@ ; @@result@@ = @@a2@@ ; if ( @@a1@@ >= @@a2@@ ) @@result@@ = @@a1@@ ; return @@result@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
_BOOL8 __fastcall rpl_isnanl ( __int64 a1 , __int64 a2 , __int64 a3 , __int64 a4 , __int64 a5 , __int64 a6 , __int128 @@a7@@ ) { if ( ( WORD4 ( @@a7@@ ) & Number ) == Number ) return DWORD1 ( @@a7@@ ) >> Number ; if ( ( WORD4 ( @@a7@@ ) & Number ) == Number ) return ( DWORD1 ( @@a7@@ ) ^ Number | ( unsigned int ) @@a7@@ ) != Number ; return ( DWORD1 ( @@a7@@ ) & Number ) == Number ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
void free ( void * @@ptr@@ ) { __imp_free ( @@ptr@@ ) ; }
__int64 __fastcall fts_compare_ino ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; if ( * ( _QWORD * ) ( * ( _QWORD * ) @@a1@@ + Number L ) < * ( _QWORD * ) ( * ( _QWORD * ) @@a2@@ + Number L ) ) @@result@@ = Number ; else @@result@@ = * ( _QWORD * ) ( * ( _QWORD * ) @@a2@@ + Number L ) < * ( _QWORD * ) ( * ( _QWORD * ) @@a1@@ + Number L ) ; return @@result@@ ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_2140E8 ; @@v4@@ [ Number ] = qword_2140F0 ; @@v4@@ [ Number ] = qword_2140F8 ; @@v4@@ [ Number ] = qword_214100 ; @@v4@@ [ Number ] = qword_214108 ; @@v4@@ [ Number ] = qword_214110 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
__int64 __fastcall fts_stat ( __int64 @@a1@@ , __int64 @@a2@@ , char @@a3@@ ) { __int64 @@result@@ ; __int64 @@v4@@ ; int @@v6@@ ; struct stat * @@s@@ ; @@s@@ = ( struct stat * ) ( @@a2@@ + Number ) ; if ( ! * ( _QWORD * ) ( @@a2@@ + Number ) && ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) @@a3@@ = Number ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number || @@a3@@ ) { if ( ( unsigned int ) stat ( * ( char * * ) ( @@a2@@ + Number ) , @@s@@ ) ) { @@v6@@ = * __errno_location ( ) ; if ( * __errno_location ( ) == Number && ! ( unsigned int ) lstat ( * ( char * * ) ( @@a2@@ + Number ) , @@s@@ ) ) { * __errno_location ( ) = Number ; return Number L ; } * ( _DWORD * ) ( @@a2@@ + Number ) = @@v6@@ ; goto LABEL_13 ; } } else if ( ( unsigned int ) fstatat ( * ( _DWORD * ) ( @@a1@@ + Number ) , * ( char * * ) ( @@a2@@ + Number ) , @@s@@ , Number ) ) { * ( _DWORD * ) ( @@a2@@ + Number ) = * __errno_location ( ) ; LABEL_13 : memset ( @@s@@ , Number , sizeof ( struct stat ) ) ; return Number L ; } switch ( * ( _DWORD * ) ( @@a2@@ + Number ) & Number ) { case Number : if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) @@v4@@ = Number L ; else @@v4@@ = Number L ; * ( _QWORD * ) ( @@a2@@ + Number ) = * ( _QWORD * ) ( @@a2@@ + Number ) - @@v4@@ ; if ( * ( _BYTE * ) ( @@a2@@ + Number ) != Number || * ( _BYTE * ) ( @@a2@@ + Number ) && ( * ( _BYTE * ) ( @@a2@@ + Number ) != Number || * ( _BYTE * ) ( @@a2@@ + Number ) ) ) { @@result@@ = Number L ; } else if ( * ( _QWORD * ) ( @@a2@@ + Number ) ) { @@result@@ = Number L ; } else { @@result@@ = Number L ; } break ; case Number : @@result@@ = Number L ; break ; case Number : @@result@@ = Number L ; break ; default : @@result@@ = Number L ; break ; } return @@result@@ ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return xmalloc ( @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall change_file_context ( unsigned int @@a1@@ , __int64 @@a2@@ ) { int @@v2@@ ; __int64 @@v3@@ ; char * @@v4@@ ; int * @@v5@@ ; __int64 @@v7@@ ; char * @@v8@@ ; int @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; char * @@v12@@ ; int * @@v13@@ ; unsigned int @@v14@@ ; unsigned int @@v15@@ ; int @@v16@@ ; int @@v17@@ ; char * @@s2@@ ; char * @@s1@@ ; unsigned __int64 @@v20@@ ; @@v20@@ = __readfsqword ( Number ) ; @@s2@@ = Number L ; @@v15@@ = Number ; if ( specified_context ) { @@v14@@ = context_new ( specified_context ) ; if ( ! @@v14@@ ) abort ( ) ; } else { if ( affect_symlink_referent ) @@v2@@ = getfileconat ( @@a1@@ , @@a2@@ , & @@s2@@ ) ; else @@v2@@ = lgetfileconat ( @@a1@@ , @@a2@@ , & @@s2@@ ) ; @@v16@@ = @@v2@@ ; if ( @@v2@@ < Number && * __errno_location ( ) != Number ) { @@v3@@ = quote ( @@a2@@ ) ; @@v4@@ = gettext ( String ) ; @@v5@@ = __errno_location ( ) ; error ( Number , * @@v5@@ , @@v4@@ , @@v3@@ ) ; return Number L ; } if ( ! @@s2@@ ) { @@v7@@ = quote ( @@a2@@ ) ; @@v8@@ = gettext ( String ) ; error ( Number , Number , @@v8@@ , @@v7@@ ) ; return Number L ; } if ( ( unsigned int ) compute_context_from_mask ( ( __int64 ) @@s2@@ , & @@v14@@ ) ) return Number L ; } @@s1@@ = ( char * ) context_str ( @@v14@@ ) ; if ( ! @@s2@@ || strcmp ( @@s1@@ , @@s2@@ ) ) { if ( affect_symlink_referent ) @@v9@@ = setfileconat ( @@a1@@ , @@a2@@ , @@s1@@ ) ; else @@v9@@ = lsetfileconat ( @@a1@@ , @@a2@@ , @@s1@@ ) ; @@v17@@ = @@v9@@ ; if ( @@v9@@ ) { @@v15@@ = Number ; @@v10@@ = quote_n ( Number L , @@s1@@ ) ; @@v11@@ = quote_n ( Number L , @@a2@@ ) ; @@v12@@ = gettext ( String ) ; @@v13@@ = __errno_location ( ) ; error ( Number , * @@v13@@ , @@v12@@ , @@v11@@ , @@v10@@ ) ; } } context_free ( ) ; freecon ( ) ; return @@v15@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@v2@@ ; @@v2@@ = malloc ( @@a1@@ ) ; if ( ! @@v2@@ && @@a1@@ ) xalloc_die ( ) ; return @@v2@@ ; }
int __fastcall hash_print_statistics ( __int64 @@a1@@ , FILE * @@a2@@ ) { double @@v2@@ ; double @@v3@@ ; double @@v4@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v6@@ = hash_get_n_entries ( @@a1@@ ) ; @@v7@@ = hash_get_n_buckets ( @@a1@@ ) ; @@v8@@ = hash_get_n_buckets_used ( @@a1@@ ) ; @@v9@@ = hash_get_max_bucket_length ( @@a1@@ ) ; fprintf ( @@a2@@ , String , @@v6@@ ) ; fprintf ( @@a2@@ , String , @@v7@@ ) ; if ( @@v8@@ < Number ) @@v2@@ = ( double ) ( int ) ( @@v8@@ & Number | ( ( unsigned __int64 ) @@v8@@ >> Number ) ) + ( double ) ( int ) ( @@v8@@ & Number | ( ( unsigned __int64 ) @@v8@@ >> Number ) ) ; else @@v2@@ = ( double ) ( int ) @@v8@@ ; @@v3@@ = Number * @@v2@@ ; if ( @@v7@@ < Number ) @@v4@@ = ( double ) ( int ) ( @@v7@@ & Number | ( ( unsigned __int64 ) @@v7@@ >> Number ) ) + ( double ) ( int ) ( @@v7@@ & Number | ( ( unsigned __int64 ) @@v7@@ >> Number ) ) ; else @@v4@@ = ( double ) ( int ) @@v7@@ ; fprintf ( @@a2@@ , String , @@v8@@ , @@v3@@ / @@v4@@ ) ; return fprintf ( @@a2@@ , String , @@v9@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_210108 ; @@v4@@ [ Number ] = qword_210110 ; @@v4@@ [ Number ] = qword_210118 ; @@v4@@ [ Number ] = qword_210120 ; @@v4@@ [ Number ] = qword_210128 ; @@v4@@ [ Number ] = qword_210130 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall fts_set_stat_required ( __int64 @@a1@@ , char @@a2@@ ) { __int64 @@v2@@ ; __int64 @@result@@ ; if ( * ( _WORD * ) ( @@a1@@ + Number ) != Number ) abort ( ) ; if ( @@a2@@ ) @@v2@@ = Number L ; else @@v2@@ = Number L ; @@result@@ = @@a1@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v2@@ ; return @@result@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@v3@@ ; @@v3@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v3@@ ) xalloc_die ( ) ; return @@v3@@ ; }
unsigned __int64 __fastcall hash_string ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ ) { unsigned __int64 @@v4@@ ; @@v4@@ = Number L ; while ( * @@a1@@ ) @@v4@@ = ( Number * @@v4@@ + ( unsigned __int8 ) * @@a1@@ ++ ) % @@a2@@ ; return @@v4@@ ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
__int64 __fastcall bkm_scale_by_power ( __int64 * @@a1@@ , int @@a2@@ , int @@a3@@ ) { unsigned int @@i@@ ; for ( @@i@@ = Number ; @@a3@@ -- ; @@i@@ |= bkm_scale ( @@a1@@ , @@a2@@ ) ) ; return @@i@@ ; }
__int64 __fastcall diropen ( __int64 @@a1@@ , int @@a2@@ , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { int @@v6@@ ; int @@v8@@ ; unsigned int @@v9@@ ; @@v8@@ = ( * ( _DWORD * ) ( @@a1@@ + Number ) << Number ) & Number | Number ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) @@v6@@ = openat_safer ( * ( _DWORD * ) ( @@a1@@ + Number ) , @@a2@@ , @@v8@@ , @@a2@@ , @@a5@@ , @@a6@@ , @@a2@@ ) ; else @@v6@@ = open_safer ( @@a2@@ , @@v8@@ , @@v8@@ , @@a4@@ , @@a5@@ , @@a6@@ , @@a2@@ ) ; @@v9@@ = @@v6@@ ; if ( @@v6@@ >= Number ) set_cloexec_flag ( ( unsigned int ) @@v6@@ , Number L ) ; return @@v9@@ ; }
__int64 __fastcall check_tuning ( __int64 @@a1@@ ) { __int64 @@v2@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( ( _UNKNOWN * ) @@v2@@ == & default_tuning ) return Number L ; if ( * ( float * ) ( @@v2@@ + Number ) > Number && ( float ) ( Number - Number ) > * ( float * ) ( @@v2@@ + Number ) && * ( float * ) ( @@v2@@ + Number ) > ( float ) ( Number + Number ) && * ( float * ) @@v2@@ >= Number && * ( float * ) ( @@v2@@ + Number ) > ( float ) ( * ( float * ) @@v2@@ + Number ) && * ( float * ) ( @@v2@@ + Number ) <= Number && * ( float * ) ( @@v2@@ + Number ) > ( float ) ( * ( float * ) @@v2@@ + Number ) ) { return Number L ; } * ( _QWORD * ) ( @@a1@@ + Number ) = & default_tuning ; return Number L ; }
__int64 __fastcall lgetfileconat ( int @@a1@@ , _BYTE * @@a2@@ , __int64 @@a3@@ ) { __int64 @@result@@ ; int * @@v4@@ ; int @@v5@@ ; int * @@v6@@ ; unsigned int @@v8@@ ; int @@v9@@ ; unsigned int @@v10@@ ; int @@v11@@ ; int @@v12@@ ; char * @@ptr@@ ; int @@v14@@ [ Number ] ; char @@v15@@ [ Number ] ; unsigned __int64 @@v16@@ ; @@v16@@ = __readfsqword ( Number ) ; if ( @@a1@@ == Number || * @@a2@@ == Number ) return lgetfilecon ( @@a2@@ , @@a3@@ ) ; @@ptr@@ = ( char * ) openat_proc_name ( @@v15@@ , ( unsigned int ) @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ ) goto LABEL_33 ; @@v8@@ = lgetfilecon ( @@ptr@@ , @@a3@@ ) ; @@v9@@ = * __errno_location ( ) ; if ( @@ptr@@ != @@v15@@ ) free ( @@ptr@@ ) ; if ( @@v8@@ != Number ) return @@v8@@ ; if ( @@v9@@ == Number || @@v9@@ == Number || @@v9@@ == Number || @@v9@@ == Number || @@v9@@ == Number || @@v9@@ == Number ) { LABEL_33 : if ( ( unsigned int ) save_cwd ( @@v14@@ ) ) { @@v4@@ = __errno_location ( ) ; openat_save_fail ( ( unsigned int ) * @@v4@@ ) ; } if ( @@a1@@ >= Number && @@a1@@ == @@v14@@ [ Number ] ) { free_cwd ( @@v14@@ ) ; * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( fchdir ( @@a1@@ ) ) { @@v11@@ = * __errno_location ( ) ; free_cwd ( @@v14@@ ) ; * __errno_location ( ) = @@v11@@ ; @@result@@ = Number ; } else { @@v10@@ = lgetfilecon ( @@a2@@ , @@a3@@ ) ; if ( @@v10@@ == Number ) @@v5@@ = * __errno_location ( ) ; else @@v5@@ = Number ; @@v12@@ = @@v5@@ ; if ( ( unsigned int ) restore_cwd ( @@v14@@ ) ) { @@v6@@ = __errno_location ( ) ; openat_restore_fail ( ( unsigned int ) * @@v6@@ ) ; } free_cwd ( @@v14@@ ) ; if ( @@v12@@ ) * __errno_location ( ) = @@v12@@ ; @@result@@ = @@v10@@ ; } } else { * __errno_location ( ) = @@v9@@ ; @@result@@ = Number ; } return @@result@@ ; }
__int64 __fastcall fd_reopen ( int @@a1@@ , const char * @@a2@@ , int @@a3@@ , unsigned int @@a4@@ ) { int @@fd@@ ; unsigned int @@v6@@ ; int @@v7@@ ; @@fd@@ = open ( @@a2@@ , @@a3@@ , @@a4@@ ) ; if ( @@fd@@ == @@a1@@ || @@fd@@ < Number ) return ( unsigned int ) @@fd@@ ; @@v6@@ = dup2 ( @@fd@@ , @@a1@@ ) ; @@v7@@ = * __errno_location ( ) ; close ( @@fd@@ ) ; * __errno_location ( ) = @@v7@@ ; return @@v6@@ ; }
_BOOL8 __fastcall process_files ( __int64 @@a1@@ , unsigned int @@a2@@ ) { char * @@v2@@ ; int * @@v3@@ ; char * @@v4@@ ; int * @@v5@@ ; bool @@v7@@ ; __int64 @@i@@ ; __int64 @@v9@@ ; @@v7@@ = Number ; for ( @@i@@ = xfts_open ( @@a1@@ , @@a2@@ , Number L ) ; ; @@v7@@ = ( @@v7@@ & ( unsigned __int8 ) process_file ( @@i@@ , @@v9@@ ) ) != Number ) { @@v9@@ = fts_read ( @@i@@ ) ; if ( ! @@v9@@ ) break ; } if ( * __errno_location ( ) ) { @@v2@@ = gettext ( String ) ; @@v3@@ = __errno_location ( ) ; error ( Number , * @@v3@@ , @@v2@@ ) ; @@v7@@ = Number ; } if ( ( unsigned int ) fts_close ( @@i@@ ) ) { @@v4@@ = gettext ( String ) ; @@v5@@ = __errno_location ( ) ; error ( Number , * @@v5@@ , @@v4@@ ) ; @@v7@@ = Number ; } return @@v7@@ ; }
unsigned __int64 __fastcall LCO_hash ( _QWORD * @@a1@@ , unsigned __int64 @@a2@@ ) { return * @@a1@@ % @@a2@@ ; }
void * __fastcall allocate_entry ( __int64 @@a1@@ ) { __int64 @@v2@@ ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return malloc ( Number ) ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = * ( _QWORD * ) ( @@v2@@ + Number ) ; return ( void * ) @@v2@@ ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
_BOOL8 __fastcall is_infinite_or_zerol ( long double @@a1@@ ) { return ( unsigned int ) rpl_isnanl ( * ( _TBYTE * ) & @@a1@@ ) || @@a1@@ == @@a1@@ + @@a1@@ ; }
__int64 __fastcall link_count_optimize_ok ( __int64 @@a1@@ ) { __int64 @@result@@ ; bool @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; _BYTE * @@ptr@@ ; __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v3@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; if ( ( * ( _DWORD * ) ( @@v4@@ + Number ) & Number ) == Number ) return Number L ; if ( ! @@v3@@ ) { * ( _QWORD * ) ( @@v4@@ + Number ) = hash_initialize ( Number L , Number L , LCO_hash , LCO_compare , & free ) ; @@v3@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; if ( ! @@v3@@ ) return Number L ; } @@v8@@ [ Number ] = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v5@@ = hash_lookup ( @@v3@@ , @@v8@@ ) ; if ( @@v5@@ ) return * ( unsigned __int8 * ) ( @@v5@@ + Number ) ; @@ptr@@ = malloc ( Number ) ; if ( ! @@ptr@@ ) return Number L ; @@v2@@ = leaf_optimization_applies ( * ( _DWORD * ) ( @@v4@@ + Number ) ) ; @@ptr@@ [ Number ] = @@v2@@ ; * ( _QWORD * ) @@ptr@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v6@@ = hash_insert ( @@v3@@ , @@ptr@@ ) ; if ( @@v6@@ ) { if ( ( _BYTE * ) @@v6@@ != @@ptr@@ ) abort ( ) ; @@result@@ = @@v2@@ ; } else { free ( @@ptr@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
__int64 __fastcall fts_padjust ( __int64 @@a1@@ , _QWORD * @@a2@@ ) { _QWORD * @@v2@@ ; __int64 @@result@@ ; _QWORD * @@i@@ ; __int64 @@v6@@ ; @@v6@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; for ( @@i@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; @@i@@ ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { if ( ( _QWORD * ) @@i@@ [ Number ] != @@i@@ + Number ) @@i@@ [ Number ] = @@v6@@ + @@i@@ [ Number ] - @@i@@ [ Number ] ; @@i@@ [ Number ] = @@v6@@ ; } while ( Number ) { @@result@@ = @@a2@@ [ Number ] ; if ( @@result@@ < Number ) break ; if ( ( _QWORD * ) @@a2@@ [ Number ] != @@a2@@ + Number ) @@a2@@ [ Number ] = @@v6@@ + @@a2@@ [ Number ] - @@a2@@ [ Number ] ; @@a2@@ [ Number ] = @@v6@@ ; if ( @@a2@@ [ Number ] ) @@v2@@ = ( _QWORD * ) @@a2@@ [ Number ] ; else @@v2@@ = ( _QWORD * ) @@a2@@ [ Number ] ; @@a2@@ = @@v2@@ ; } return @@result@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
__int64 __fastcall hash_rehash ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; unsigned __int64 @@nmemb@@ ; void * @@v4@@ ; __int64 @@v5@@ ; unsigned __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; __int64 @@v12@@ ; __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; @@v14@@ = __readfsqword ( Number ) ; @@nmemb@@ = compute_bucket_size ( @@a2@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ; if ( ! @@nmemb@@ ) return Number L ; if ( @@nmemb@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; @@v4@@ = calloc ( @@nmemb@@ , Number ) ; if ( ! @@v4@@ ) return Number L ; @@v6@@ = @@nmemb@@ ; @@v5@@ = ( __int64 ) @@v4@@ + Number * @@nmemb@@ ; @@v7@@ = Number L ; @@v8@@ = Number L ; @@v9@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v10@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v11@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v12@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v13@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( ( unsigned __int8 ) transfer_entries ( ( __int64 ) & @@v4@@ , @@a1@@ , Number ) ) { free ( * ( void * * ) @@a1@@ ) ; * ( _QWORD * ) @@a1@@ = @@v4@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v5@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v6@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v7@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v13@@ ; @@result@@ = Number L ; } else { * ( _QWORD * ) ( @@a1@@ + Number ) = @@v13@@ ; if ( ( unsigned __int8 ) transfer_entries ( @@a1@@ , ( __int64 ) & @@v4@@ , Number ) != Number || ( unsigned __int8 ) transfer_entries ( @@a1@@ , ( __int64 ) & @@v4@@ , Number ) != Number ) { abort ( ) ; } free ( @@v4@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
DIR * opendir ( const char * @@name@@ ) { return opendir ( @@name@@ ) ; }
void __fastcall __noreturn openat_restore_fail ( int @@a1@@ ) { char * @@v1@@ ; @@v1@@ = gettext ( String ) ; error ( exit_failure , @@a1@@ , @@v1@@ ) ; abort ( ) ; }
__int64 __fastcall hash_get_n_buckets_used ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
unsigned __int64 __fastcall AD_hash ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) % @@a2@@ ; }
__int64 __fastcall dup_cloexec ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
int chdir ( const char * @@path@@ ) { return chdir ( @@path@@ ) ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
int __xstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _xstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 __fastcall setup_dir ( __int64 @@a1@@ ) { if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { * ( _QWORD * ) ( @@a1@@ + Number ) = hash_initialize ( Number L , Number L , AD_hash , AD_compare , & free ) ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; } else { * ( _QWORD * ) ( @@a1@@ + Number ) = malloc ( Number ) ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; cycle_check_init ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ; } return Number L ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
unsigned __int64 __fastcall hash_get_max_bucket_length ( __int64 @@a1@@ ) { _QWORD * @@i@@ ; unsigned __int64 @@v3@@ ; _QWORD * @@v4@@ ; unsigned __int64 @@j@@ ; @@v3@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { @@v4@@ = @@i@@ ; for ( @@j@@ = Number L ; ; ++ @@j@@ ) { @@v4@@ = ( _QWORD * ) @@v4@@ [ Number ] ; if ( ! @@v4@@ ) break ; } if ( @@j@@ > @@v3@@ ) @@v3@@ = @@j@@ ; } } return @@v3@@ ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
char * __fastcall openat_proc_name ( char * @@a1@@ , struct stat * @@a2@@ , const char * @@a3@@ ) { char * @@result@@ ; int @@v4@@ ; char * @@v5@@ ; unsigned int @@v7@@ ; int @@fd@@ ; size_t @@v9@@ ; char * @@v10@@ ; struct stat @@v11@@ ; struct stat @@v12@@ ; char @@s@@ [ Number ] ; unsigned __int64 @@v14@@ ; @@v7@@ = ( unsigned int ) @@a2@@ ; @@v14@@ = __readfsqword ( Number ) ; if ( * @@a3@@ ) { if ( ! proc_status_4428 ) { @@a2@@ = Number L ; @@fd@@ = open ( String , Number ) ; if ( @@fd@@ >= Number ) { sprintf ( @@s@@ , String , ( unsigned int ) @@fd@@ , String ) ; @@a2@@ = & @@v11@@ ; if ( ( unsigned int ) stat ( @@s@@ , & @@v11@@ ) || ( @@a2@@ = & @@v12@@ , ( unsigned int ) stat ( String , & @@v12@@ ) ) || @@v11@@ . st_ino != @@v12@@ . st_ino || @@v11@@ . st_dev != @@v12@@ . st_dev ) { @@v4@@ = Number ; } else { @@v4@@ = Number ; } proc_status_4428 = @@v4@@ ; close ( @@fd@@ ) ; } else { proc_status_4428 = Number ; } } if ( proc_status_4428 >= Number ) { @@v9@@ = strlen ( @@a3@@ ) + Number ; if ( @@v9@@ <= Number ) @@v5@@ = @@a1@@ ; else @@v5@@ = ( char * ) xmalloc ( @@v9@@ , ( __int64 ) @@a2@@ ) ; @@v10@@ = @@v5@@ ; sprintf ( @@v5@@ , String , @@v7@@ , @@a3@@ ) ; @@result@@ = @@v10@@ ; } else { @@result@@ = Number L ; } } else { * @@a1@@ = Number ; @@result@@ = @@a1@@ ; } return @@result@@ ; }
void __fastcall free_dir ( __int64 @@a1@@ ) { if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) hash_free ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ; } else { free ( * ( void * * ) ( @@a1@@ + Number ) ) ; } }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 __fastcall hash_get_first ( unsigned __int64 * @@a1@@ ) { unsigned __int64 @@i@@ ; if ( ! @@a1@@ [ Number ] ) return Number L ; for ( @@i@@ = * @@a1@@ ; ; @@i@@ += Number L ) { if ( @@i@@ >= @@a1@@ [ Number ] ) abort ( ) ; if ( * ( _QWORD * ) @@i@@ ) break ; } return * ( _QWORD * ) @@i@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
__int64 __fastcall opendirat ( int @@a1@@ , int @@a2@@ , __int64 a3 , __int64 a4 , int @@a5@@ , int @@a6@@ ) { int @@fd@@ ; _BYTE @@v8@@ [ Number ] ; @@fd@@ = openat_safer ( @@a1@@ , @@a2@@ , Number , @@a2@@ , @@a5@@ , @@a6@@ , @@a2@@ ) ; if ( @@fd@@ < Number ) return Number L ; set_cloexec_flag ( ( unsigned int ) @@fd@@ , Number L ) ; * ( _QWORD * ) & @@v8@@ [ Number ] = fdopendir ( @@fd@@ ) ; if ( ! * ( _QWORD * ) & @@v8@@ [ Number ] ) { * ( _QWORD * ) @@v8@@ = ( unsigned int ) * __errno_location ( ) ; close ( @@fd@@ ) ; * __errno_location ( ) = * ( _DWORD * ) @@v8@@ ; } return * ( _QWORD * ) & @@v8@@ [ Number ] ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
__int64 __fastcall hash_do_for_each ( __int64 @@a1@@ , unsigned __int8 ( __fastcall * @@a2@@ ) ( _QWORD , __int64 ) , __int64 @@a3@@ ) { __int64 @@v5@@ ; _QWORD * @@i@@ ; _QWORD * @@j@@ ; @@v5@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = @@i@@ ; @@j@@ ; @@j@@ = ( _QWORD * ) @@j@@ [ Number ] ) { if ( @@a2@@ ( * @@j@@ , @@a3@@ ) != Number ) return @@v5@@ ; ++ @@v5@@ ; } } } return @@v5@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_210028 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
_BOOL8 __fastcall leaf_optimization_applies ( int @@a1@@ ) { _BOOL8 @@result@@ ; struct statfs @@buf@@ ; unsigned __int64 @@v3@@ ; @@v3@@ = __readfsqword ( Number ) ; if ( fstatfs ( @@a1@@ , & @@buf@@ ) ) @@result@@ = Number L ; else @@result@@ = @@buf@@ . f_type == Number ; return @@result@@ ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
__int64 __fastcall next_prime ( unsigned __int64 @@a1@@ ) { __int64 @@v2@@ ; __int64 @@i@@ ; @@v2@@ = @@a1@@ ; if ( @@a1@@ <= Number ) @@v2@@ = Number L ; for ( @@i@@ = @@v2@@ | Number ; @@i@@ != Number && ! is_prime ( @@i@@ ) ; @@i@@ += Number L ) { ; } return @@i@@ ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , off_C862 , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
int fileno ( FILE * @@stream@@ ) { return fileno ( @@stream@@ ) ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
__int64 __fastcall hash_clear ( __int64 @@a1@@ ) { __int64 @@result@@ ; _QWORD * @@i@@ ; _QWORD * @@j@@ ; _QWORD * @@v4@@ ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = ( _QWORD * ) @@i@@ [ Number ] ; @@j@@ ; @@j@@ = @@v4@@ ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@j@@ ) ; * @@j@@ = Number L ; @@v4@@ = ( _QWORD * ) @@j@@ [ Number ] ; @@j@@ [ Number ] = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@j@@ ; } if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@i@@ ) ; * @@i@@ = Number L ; @@i@@ [ Number ] = Number L ; } } * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; @@result@@ = @@a1@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; return @@result@@ ; }
__int64 __fastcall fts_children ( __int64 @@a1@@ , int @@a2@@ ) { __int64 @@v3@@ ; __int64 @@v4@@ ; int @@v5@@ ; int @@v6@@ ; int @@v7@@ ; int @@v8@@ ; unsigned int @@v9@@ ; int @@fd@@ ; int @@v11@@ ; if ( @@a2@@ && @@a2@@ != Number ) { * __errno_location ( ) = Number ; return Number L ; } @@v3@@ = * ( _QWORD * ) @@a1@@ ; * __errno_location ( ) = Number ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) return Number L ; if ( * ( _WORD * ) ( @@v3@@ + Number ) == Number ) return * ( _QWORD * ) ( @@v3@@ + Number ) ; if ( * ( _WORD * ) ( @@v3@@ + Number ) != Number ) return Number L ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) fts_lfree ( * ( void * * ) ( @@a1@@ + Number ) ) ; if ( @@a2@@ == Number ) { @@v8@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; BYTE1 ( @@v8@@ ) |= Number ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@v8@@ ; @@v9@@ = Number ; } else { @@v9@@ = Number ; } if ( * ( _QWORD * ) ( @@v3@@ + Number ) || * * ( _BYTE * * ) ( @@v3@@ + Number ) == Number || ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { * ( _QWORD * ) ( @@a1@@ + Number ) = fts_build ( @@a1@@ , @@v9@@ ) ; return * ( _QWORD * ) ( @@a1@@ + Number ) ; } @@fd@@ = diropen ( @@a1@@ , ( int ) & unk_C869 , @@v4@@ , @@v5@@ , @@v6@@ , @@v7@@ ) ; if ( @@fd@@ < Number ) { * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; return Number L ; } * ( _QWORD * ) ( @@a1@@ + Number ) = fts_build ( @@a1@@ , @@v9@@ ) ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { cwd_advance_fd ( @@a1@@ , @@fd@@ , Number ) ; } else { if ( fchdir ( @@fd@@ ) ) { @@v11@@ = * __errno_location ( ) ; close ( @@fd@@ ) ; * __errno_location ( ) = @@v11@@ ; return Number L ; } close ( @@fd@@ ) ; } return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
__int64 __fastcall fd_ring_clear ( __int64 @@a1@@ ) { __int64 @@result@@ ; int @@fd@@ ; while ( Number ) { @@result@@ = ( unsigned int ) i_ring_empty ( @@a1@@ ) ^ Number ; if ( ! ( _BYTE ) @@result@@ ) break ; @@fd@@ = i_ring_pop ( @@a1@@ ) ; if ( @@fd@@ >= Number ) close ( @@fd@@ ) ; } return @@result@@ ; }
int feof_unlocked ( FILE * @@stream@@ ) { return feof_unlocked ( @@stream@@ ) ; }
__int64 __fastcall i_ring_init ( __int64 @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; int @@i@@ ; * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; * ( _DWORD * ) ( @@a1@@ + Number ) = Number ; * ( _DWORD * ) ( @@a1@@ + Number ) = Number ; for ( @@i@@ = Number ; @@i@@ <= Number ; ++ @@i@@ ) * ( _DWORD * ) ( @@a1@@ + Number L * @@i@@ ) = @@a2@@ ; @@result@@ = @@a1@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall hash_lookup ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; _QWORD * @@i@@ ; _QWORD * @@v5@@ ; @@v2@@ = * @@a1@@ ; @@v5@@ = ( _QWORD * ) ( @@v2@@ + Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) ) ; if ( ( unsigned __int64 ) @@v5@@ >= @@a1@@ [ Number ] ) abort ( ) ; if ( ! * @@v5@@ ) return Number L ; for ( @@i@@ = @@v5@@ ; @@i@@ ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { if ( @@a2@@ == * @@i@@ || ( ( unsigned __int8 ( __fastcall * ) ( __int64 , _QWORD ) ) @@a1@@ [ Number ] ) ( @@a2@@ , * @@i@@ ) ) { return * @@i@@ ; } } return Number L ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return xmalloc ( @@a1@@ , @@a2@@ , @@a3@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
unsigned __int64 __fastcall hash_get_entries ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; _QWORD * @@i@@ ; _QWORD * @@j@@ ; @@v5@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = @@i@@ ; @@j@@ ; @@j@@ = ( _QWORD * ) @@j@@ [ Number ] ) { if ( @@v5@@ >= @@a3@@ ) return @@v5@@ ; @@v4@@ = @@v5@@ ++ ; * ( _QWORD * ) ( @@a2@@ + Number * @@v4@@ ) = * @@j@@ ; } } } return @@v5@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
__int64 __fastcall cwd_advance_fd ( __int64 @@a1@@ , int @@a2@@ , char @@a3@@ ) { __int64 @@result@@ ; int @@v4@@ ; int @@fd@@ ; @@v4@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; if ( @@v4@@ == @@a2@@ && @@v4@@ != Number ) abort ( ) ; if ( @@a3@@ ) { @@fd@@ = i_ring_push ( @@a1@@ + Number , ( unsigned int ) @@v4@@ ) ; if ( @@fd@@ >= Number ) close ( @@fd@@ ) ; } else if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) == Number && @@v4@@ >= Number ) { close ( @@v4@@ ) ; } @@result@@ = @@a1@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
__int64 __fastcall i_ring_pop ( __int64 @@a1@@ ) { unsigned int @@v2@@ ; if ( ( unsigned __int8 ) i_ring_empty ( @@a1@@ ) ) abort ( ) ; @@v2@@ = * ( _DWORD * ) ( @@a1@@ + Number L * * ( unsigned int * ) ( @@a1@@ + Number ) ) ; * ( _DWORD * ) ( @@a1@@ + Number L * * ( unsigned int * ) ( @@a1@@ + Number ) ) = * ( _DWORD * ) ( @@a1@@ + Number ) ; if ( * ( _DWORD * ) ( @@a1@@ + Number ) == * ( _DWORD * ) ( @@a1@@ + Number ) ) * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; else * ( _DWORD * ) ( @@a1@@ + Number ) = ( ( unsigned __int8 ) * ( _DWORD * ) ( @@a1@@ + Number ) + Number ) & Number ; return @@v2@@ ; }
bool __fastcall is_prime ( unsigned __int64 @@a1@@ ) { unsigned __int64 @@v2@@ ; unsigned __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; @@v2@@ = Number L ; @@v4@@ = Number L ; while ( @@v4@@ < @@a1@@ && @@a1@@ % @@v2@@ ) { @@v3@@ = @@v2@@ + Number ; @@v4@@ += Number * @@v3@@ ; @@v2@@ = @@v3@@ + Number ; } return @@a1@@ % @@v2@@ != Number ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
__int64 __fastcall set_stat_type ( __int64 @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; int @@v3@@ ; switch ( @@a2@@ ) { case Number : @@v3@@ = Number ; break ; case Number : @@v3@@ = Number ; break ; case Number : @@v3@@ = Number ; break ; case Number : @@v3@@ = Number ; break ; case Number : @@v3@@ = Number ; break ; case Number : @@v3@@ = Number ; break ; case Number : @@v3@@ = Number ; break ; default : @@v3@@ = Number ; break ; } @@result@@ = @@a1@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@v3@@ ; return @@result@@ ; }
__int64 __fastcall open_safer ( const char * @@a1@@ , char @@a2@@ , unsigned int @@a3@@ ) { unsigned int @@v3@@ ; unsigned int @@v5@@ ; @@v5@@ = Number ; if ( ( @@a2@@ & Number ) != Number ) @@v5@@ = @@a3@@ ; @@v3@@ = open ( @@a1@@ , @@a2@@ , @@v5@@ ) ; return fd_safer ( @@v3@@ ) ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
__int64 __fastcall fts_compar ( __int64 @@a1@@ , __int64 @@a2@@ ) { return ( * ( __int64 ( __fastcall * * ) ( __int64 , __int64 ) ) ( * ( _QWORD * ) ( * ( _QWORD * ) @@a1@@ + Number L ) + Number L ) ) ( @@a1@@ , @@a2@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
_BOOL8 __fastcall cycle_warning_required ( __int64 @@a1@@ , __int64 @@a2@@ ) { return ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number && ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) == Number || ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number && ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number && * ( _QWORD * ) ( @@a2@@ + Number ) ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
size_t * __fastcall hash_initialize ( __int64 @@a1@@ , void * @@a2@@ , unsigned __int64 ( __fastcall * @@a3@@ ) ( __int64 a1 , unsigned __int64 a2 ) , bool ( __fastcall * @@a4@@ ) ( __int64 a1 , __int64 a2 ) , size_t @@a5@@ ) { size_t * @@result@@ ; bool ( __fastcall * @@v7@@ ) ( __int64 , __int64 ) ; unsigned __int64 ( __fastcall * @@v8@@ ) ( __int64 , unsigned __int64 ) ; void * @@v9@@ ; size_t * @@ptr@@ ; @@v9@@ = @@a2@@ ; @@v8@@ = @@a3@@ ; @@v7@@ = @@a4@@ ; if ( ! @@a3@@ ) @@v8@@ = raw_hasher ; if ( ! @@a4@@ ) @@v7@@ = raw_comparator ; @@ptr@@ = ( size_t * ) malloc ( Number ) ; if ( ! @@ptr@@ ) return Number L ; if ( ! @@a2@@ ) @@v9@@ = & default_tuning ; @@ptr@@ [ Number ] = ( size_t ) @@v9@@ ; if ( ( unsigned __int8 ) check_tuning ( ( __int64 ) @@ptr@@ ) == Number && ( @@ptr@@ [ Number ] = compute_bucket_size ( @@a1@@ , ( __int64 ) @@v9@@ ) ) != Number && ( * @@ptr@@ = ( size_t ) calloc ( @@ptr@@ [ Number ] , Number ) ) != Number ) { @@ptr@@ [ Number ] = Number * @@ptr@@ [ Number ] + * @@ptr@@ ; @@ptr@@ [ Number ] = Number L ; @@ptr@@ [ Number ] = Number L ; @@ptr@@ [ Number ] = ( size_t ) @@v8@@ ; @@ptr@@ [ Number ] = ( size_t ) @@v7@@ ; @@ptr@@ [ Number ] = @@a5@@ ; @@ptr@@ [ Number ] = Number L ; @@result@@ = @@ptr@@ ; } else { free ( @@ptr@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall fts_palloc ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; unsigned __int64 @@v3@@ ; void * @@v4@@ ; @@v3@@ = * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ + Number ; if ( @@v3@@ >= * ( _QWORD * ) ( @@a1@@ + Number ) ) { * ( _QWORD * ) ( @@a1@@ + Number ) = @@v3@@ ; @@v4@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , * ( _QWORD * ) ( @@a1@@ + Number ) ) ; if ( @@v4@@ ) { * ( _QWORD * ) ( @@a1@@ + Number ) = @@v4@@ ; @@result@@ = Number L ; } else { free ( * ( void * * ) ( @@a1@@ + Number ) ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; @@result@@ = Number L ; } } else { free ( * ( void * * ) ( @@a1@@ + Number ) ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * __errno_location ( ) = Number ; @@result@@ = Number L ; } return @@result@@ ; }
FILE * __fastcall fopen_safer ( const char * @@a1@@ , const char * @@a2@@ ) { int @@v3@@ ; int @@fd@@ ; int @@v5@@ ; int @@v6@@ ; FILE * @@stream@@ ; @@stream@@ = fopen ( @@a1@@ , @@a2@@ ) ; if ( ! @@stream@@ ) return @@stream@@ ; @@v3@@ = fileno ( @@stream@@ ) ; if ( @@v3@@ < Number || @@v3@@ > Number ) return @@stream@@ ; @@fd@@ = dup_safer ( ( unsigned int ) @@v3@@ ) ; if ( @@fd@@ < Number ) { @@v6@@ = * __errno_location ( ) ; fclose ( @@stream@@ ) ; * __errno_location ( ) = @@v6@@ ; return Number L ; } if ( ! fclose ( @@stream@@ ) ) { @@stream@@ = fdopen ( @@fd@@ , @@a2@@ ) ; if ( @@stream@@ ) return @@stream@@ ; } @@v5@@ = * __errno_location ( ) ; close ( @@fd@@ ) ; * __errno_location ( ) = @@v5@@ ; return Number L ; }
bool __fastcall is_zero_or_power_of_two ( __int64 @@a1@@ ) { return ( @@a1@@ & ( @@a1@@ - Number ) ) == Number ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
__int64 __fastcall free_entry ( __int64 @@a1@@ , _QWORD * @@a2@@ ) { __int64 @@result@@ ; * @@a2@@ = Number L ; @@a2@@ [ Number ] = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@result@@ = @@a1@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
size_t __fastcall fts_maxarglen ( const char * * @@a1@@ ) { size_t @@v3@@ ; size_t @@v4@@ ; @@v3@@ = Number L ; while ( * @@a1@@ ) { @@v4@@ = strlen ( * @@a1@@ ) ; if ( @@v4@@ > @@v3@@ ) @@v3@@ = @@v4@@ ; ++ @@a1@@ ; } return @@v3@@ + Number ; }
__int64 __fastcall dup_safer ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall i_ring_empty ( __int64 @@a1@@ ) { return * ( unsigned __int8 * ) ( @@a1@@ + Number ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall fd_safer ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { unsigned int @@fd@@ ; unsigned int @@v8@@ ; int @@v9@@ ; @@fd@@ = @@a1@@ ; if ( @@a1@@ >= Number && @@a1@@ <= Number ) { @@v8@@ = dup_safer ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; @@v9@@ = * __errno_location ( ) ; close ( @@a1@@ ) ; * __errno_location ( ) = @@v9@@ ; @@fd@@ = @@v8@@ ; } return @@fd@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall save_cwd ( __int64 @@a1@@ , __int64 a2 , unsigned int @@a3@@ ) { __int64 @@result@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _DWORD * ) @@a1@@ = open_safer ( String , Number , @@a3@@ ) ; if ( * ( int * ) @@a1@@ >= Number ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = xgetcwd ( ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) @@result@@ = Number L ; else @@result@@ = Number ; return @@result@@ ; }
__int64 __fastcall i_ring_push ( __int64 @@a1@@ , int @@a2@@ ) { int @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = ( ( unsigned __int8 ) * ( _DWORD * ) ( @@a1@@ + Number ) + ( * ( _BYTE * ) ( @@a1@@ + Number ) ^ Number ) ) & Number ; @@v4@@ = * ( _DWORD * ) ( @@a1@@ + Number L * ( ( ( unsigned __int8 ) * ( _DWORD * ) ( @@a1@@ + Number ) + ( * ( _BYTE * ) ( @@a1@@ + Number ) ^ Number ) ) & Number ) ) ; * ( _DWORD * ) ( @@a1@@ + Number L * ( ( ( unsigned __int8 ) * ( _DWORD * ) ( @@a1@@ + Number ) + ( * ( _BYTE * ) ( @@a1@@ + Number ) ^ Number ) ) & Number ) ) = @@a2@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@v3@@ ; if ( @@v3@@ == * ( _DWORD * ) ( @@a1@@ + Number ) ) * ( _DWORD * ) ( @@a1@@ + Number ) = ( ( unsigned __int8 ) * ( _DWORD * ) ( @@a1@@ + Number ) + ( * ( _BYTE * ) ( @@a1@@ + Number ) ^ Number ) ) & Number ; * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; return @@v4@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 __fastcall fts_safe_changedir ( __int64 @@a1@@ , __int64 @@a2@@ , int @@a3@@ , const char * @@a4@@ , int @@a5@@ , int @@a6@@ ) { bool @@v6@@ ; char * @@s1@@ ; char @@v10@@ ; unsigned int @@v11@@ ; int @@fildes@@ ; int @@v13@@ ; int @@v14@@ ; struct stat @@v15@@ ; unsigned __int64 @@v16@@ ; @@s1@@ = ( char * ) @@a4@@ ; @@v16@@ = __readfsqword ( Number ) ; @@v6@@ = @@a4@@ && ! strcmp ( @@a4@@ , off_C86B ) ; @@v10@@ = @@v6@@ ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number && @@a3@@ >= Number ) close ( @@a3@@ ) ; return Number L ; } if ( @@a3@@ < Number ) { if ( @@v10@@ ) { if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number && ( unsigned __int8 ) i_ring_empty ( @@a1@@ + Number ) != Number ) { @@v13@@ = i_ring_pop ( @@a1@@ + Number ) ; @@v10@@ = Number ; if ( @@v13@@ >= Number ) { @@a3@@ = @@v13@@ ; @@s1@@ = Number L ; } } } } @@fildes@@ = @@a3@@ ; if ( @@a3@@ < Number ) { @@fildes@@ = diropen ( @@a1@@ , ( int ) @@s1@@ , ( __int64 ) @@s1@@ , ( int ) @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( @@fildes@@ < Number ) return Number ; } if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) == Number && ( ! @@s1@@ || strcmp ( @@s1@@ , off_C86B ) ) ) goto LABEL_27 ; if ( ! ( unsigned int ) fstat ( @@fildes@@ , & @@v15@@ ) ) { if ( * ( _QWORD * ) ( @@a2@@ + Number ) != @@v15@@ . st_dev || * ( _QWORD * ) ( @@a2@@ + Number ) != @@v15@@ . st_ino ) { * __errno_location ( ) = Number ; @@v11@@ = Number ; goto LABEL_30 ; } LABEL_27 : if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { cwd_advance_fd ( @@a1@@ , @@fildes@@ , @@v10@@ == Number ) ; return Number L ; } @@v11@@ = fchdir ( @@fildes@@ ) ; goto LABEL_30 ; } @@v11@@ = Number ; LABEL_30 : if ( @@a3@@ < Number ) { @@v14@@ = * __errno_location ( ) ; close ( @@fildes@@ ) ; * __errno_location ( ) = @@v14@@ ; } return @@v11@@ ; }
int __fastcall restore_cwd ( __int64 @@a1@@ ) { int @@result@@ ; if ( * ( int * ) @@a1@@ < Number ) @@result@@ = chdir_long ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ; else @@result@@ = fchdir ( * ( _DWORD * ) @@a1@@ ) ; return @@result@@ ; }
__int64 __fastcall openat_safer ( int @@a1@@ , const char * @@a2@@ , char @@a3@@ , unsigned int @@a4@@ ) { unsigned int @@v4@@ ; unsigned int @@v6@@ ; @@v6@@ = Number ; if ( ( @@a3@@ & Number ) != Number ) @@v6@@ = @@a4@@ ; @@v4@@ = openat ( @@a1@@ , @@a2@@ , @@a3@@ , @@v6@@ ) ; return fd_safer ( @@v4@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
int __fastcall cdb_fchdir ( int * @@a1@@ ) { return fchdir ( * @@a1@@ ) ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall cdb_free ( int * @@a1@@ ) { __int64 @@result@@ ; @@result@@ = ( unsigned int ) * @@a1@@ ; if ( ( int ) @@result@@ >= Number ) { @@result@@ = close ( * @@a1@@ ) == Number ; if ( ! ( _BYTE ) @@result@@ ) __assert_fail ( String , String , Number , String ) ; } return @@result@@ ; }
void __fastcall hash_free ( __int64 @@a1@@ ) { _QWORD * @@i@@ ; _QWORD * @@j@@ ; _QWORD * @@ptr@@ ; _QWORD * @@ptra@@ ; _QWORD * @@ptrb@@ ; _QWORD * @@v6@@ ; _QWORD * @@v7@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) && * ( _QWORD * ) ( @@a1@@ + Number ) ) { for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@ptr@@ = @@i@@ ; @@ptr@@ ; @@ptr@@ = ( _QWORD * ) @@ptr@@ [ Number ] ) { ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@ptr@@ ) ; } } } } for ( @@j@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@j@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@j@@ += Number ) { for ( @@ptra@@ = ( _QWORD * ) @@j@@ [ Number ] ; @@ptra@@ ; @@ptra@@ = @@v6@@ ) { @@v6@@ = ( _QWORD * ) @@ptra@@ [ Number ] ; free ( @@ptra@@ ) ; } } for ( @@ptrb@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; @@ptrb@@ ; @@ptrb@@ = @@v7@@ ) { @@v7@@ = ( _QWORD * ) @@ptrb@@ [ Number ] ; free ( @@ptrb@@ ) ; } free ( * ( void * * ) @@a1@@ ) ; free ( ( void * ) @@a1@@ ) ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_20A0E8 ; @@v4@@ [ Number ] = qword_20A0F0 ; @@v4@@ [ Number ] = qword_20A0F8 ; @@v4@@ [ Number ] = qword_20A100 ; @@v4@@ [ Number ] = qword_20A108 ; @@v4@@ [ Number ] = qword_20A110 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
__int64 __fastcall getfileconat ( int @@a1@@ , _BYTE * @@a2@@ , __int64 @@a3@@ ) { __int64 @@result@@ ; int * @@v4@@ ; int @@v5@@ ; int * @@v6@@ ; unsigned int @@v8@@ ; int @@v9@@ ; unsigned int @@v10@@ ; int @@v11@@ ; int @@v12@@ ; char * @@ptr@@ ; int @@v14@@ [ Number ] ; char @@v15@@ [ Number ] ; unsigned __int64 @@v16@@ ; @@v16@@ = __readfsqword ( Number ) ; if ( @@a1@@ == Number || * @@a2@@ == Number ) return getfilecon_0 ( @@a2@@ , @@a3@@ ) ; @@ptr@@ = ( char * ) openat_proc_name ( @@v15@@ , ( unsigned int ) @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ ) goto LABEL_33 ; @@v8@@ = getfilecon_0 ( @@ptr@@ , @@a3@@ ) ; @@v9@@ = * __errno_location ( ) ; if ( @@ptr@@ != @@v15@@ ) free ( @@ptr@@ ) ; if ( @@v8@@ != Number ) return @@v8@@ ; if ( @@v9@@ == Number || @@v9@@ == Number || @@v9@@ == Number || @@v9@@ == Number || @@v9@@ == Number || @@v9@@ == Number ) { LABEL_33 : if ( ( unsigned int ) save_cwd ( @@v14@@ ) ) { @@v4@@ = __errno_location ( ) ; openat_save_fail ( ( unsigned int ) * @@v4@@ ) ; } if ( @@a1@@ >= Number && @@a1@@ == @@v14@@ [ Number ] ) { free_cwd ( @@v14@@ ) ; * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( fchdir ( @@a1@@ ) ) { @@v11@@ = * __errno_location ( ) ; free_cwd ( @@v14@@ ) ; * __errno_location ( ) = @@v11@@ ; @@result@@ = Number ; } else { @@v10@@ = getfilecon_0 ( @@a2@@ , @@a3@@ ) ; if ( @@v10@@ == Number ) @@v5@@ = * __errno_location ( ) ; else @@v5@@ = Number ; @@v12@@ = @@v5@@ ; if ( ( unsigned int ) restore_cwd ( @@v14@@ ) ) { @@v6@@ = __errno_location ( ) ; openat_restore_fail ( ( unsigned int ) * @@v6@@ ) ; } free_cwd ( @@v14@@ ) ; if ( @@v12@@ ) * __errno_location ( ) = @@v12@@ ; @@result@@ = @@v10@@ ; } } else { * __errno_location ( ) = @@v9@@ ; @@result@@ = Number ; } return @@result@@ ; }
int __fastcall fstat ( int @@fildes@@ , struct stat * @@stat_buf@@ ) { return __fxstat ( Number , @@fildes@@ , @@stat_buf@@ ) ; }
__int64 __fastcall hash_find_entry ( __int64 @@a1@@ , __int64 @@a2@@ , _QWORD * @@a3@@ , char @@a4@@ ) { __int64 @@v4@@ ; __int64 @@result@@ ; __int64 @@v6@@ ; _QWORD * @@i@@ ; _QWORD * @@v10@@ ; __int64 @@v11@@ ; _QWORD * @@v12@@ ; __int64 @@v13@@ ; _QWORD * @@v14@@ ; @@v4@@ = * ( _QWORD * ) @@a1@@ ; @@v10@@ = ( _QWORD * ) ( @@v4@@ + Number * ( * ( __int64 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@a2@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@v10@@ >= * ( _QWORD * ) ( @@a1@@ + Number ) ) abort ( ) ; * @@a3@@ = @@v10@@ ; if ( ! * @@v10@@ ) return Number L ; if ( @@a2@@ == * @@v10@@ || ( * ( unsigned __int8 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@a2@@ , * @@v10@@ ) ) { @@v13@@ = * @@v10@@ ; if ( @@a4@@ ) { if ( @@v10@@ [ Number ] ) { @@v14@@ = ( _QWORD * ) @@v10@@ [ Number ] ; @@v6@@ = @@v14@@ [ Number ] ; * @@v10@@ = * @@v14@@ ; @@v10@@ [ Number ] = @@v6@@ ; free_entry ( @@a1@@ , @@v14@@ ) ; } else { * @@v10@@ = Number L ; } } @@result@@ = @@v13@@ ; } else { for ( @@i@@ = @@v10@@ ; ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { if ( ! @@i@@ [ Number ] ) return Number L ; if ( @@a2@@ == * ( _QWORD * ) @@i@@ [ Number ] || ( * ( unsigned __int8 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@a2@@ , * ( _QWORD * ) @@i@@ [ Number ] ) ) { break ; } } @@v11@@ = * ( _QWORD * ) @@i@@ [ Number ] ; if ( @@a4@@ ) { @@v12@@ = ( _QWORD * ) @@i@@ [ Number ] ; @@i@@ [ Number ] = @@v12@@ [ Number ] ; free_entry ( @@a1@@ , @@v12@@ ) ; } @@result@@ = @@v11@@ ; } return @@result@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
void __fastcall free_cwd ( __int64 @@a1@@ ) { if ( * ( int * ) @@a1@@ >= Number ) close ( * ( _DWORD * ) @@a1@@ ) ; free ( * ( void * * ) ( @@a1@@ + Number ) ) ; }
int __fastcall fstatat ( int @@fildes@@ , char * @@filename@@ , struct stat * @@stat_buf@@ , int @@flag@@ ) { return __fxstatat ( Number , @@fildes@@ , @@filename@@ , @@stat_buf@@ , @@flag@@ ) ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
DIR * __fastcall opendir_safer ( const char * @@a1@@ ) { int @@v2@@ ; int @@fd@@ ; int @@v4@@ ; DIR * @@dirp@@ ; DIR * @@v6@@ ; @@dirp@@ = opendir ( @@a1@@ ) ; if ( @@dirp@@ ) { @@v2@@ = dirfd ( @@dirp@@ ) ; if ( @@v2@@ >= Number && @@v2@@ <= Number ) { @@fd@@ = dup_safer ( ( unsigned int ) @@v2@@ ) ; @@v6@@ = fdopendir ( @@fd@@ ) ; @@v4@@ = * __errno_location ( ) ; if ( ! @@v6@@ ) close ( @@fd@@ ) ; closedir ( @@dirp@@ ) ; * __errno_location ( ) = @@v4@@ ; @@dirp@@ = @@v6@@ ; } } return @@dirp@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
const char * __fastcall find_non_slash ( const char * @@a1@@ ) { return & @@a1@@ [ strspn ( @@a1@@ , String ) ] ; }
__int64 __fastcall dup_safer ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
int __fastcall stat ( char * @@filename@@ , struct stat * @@stat_buf@@ ) { return __xstat ( Number , @@filename@@ , @@stat_buf@@ ) ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_210108 ; @@v8@@ [ Number ] = qword_210110 ; @@v8@@ [ Number ] = qword_210118 ; @@v8@@ [ Number ] = qword_210120 ; @@v8@@ [ Number ] = qword_210128 ; @@v8@@ [ Number ] = qword_210130 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_210028 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
int tolower ( int @@c@@ ) { return tolower ( @@c@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
int putchar_unlocked ( int @@c@@ ) { return putchar_unlocked ( @@c@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall select_plural ( __int64 @@a1@@ ) { return @@a1@@ ; }
__int64 __fastcall bad_cast ( __int64 @@a1@@ ) { return @@a1@@ ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
__int64 __fastcall lsetfileconat ( int @@a1@@ , _BYTE * @@a2@@ , __int64 @@a3@@ ) { __int64 @@result@@ ; int * @@v4@@ ; int @@v5@@ ; int * @@v6@@ ; unsigned int @@v8@@ ; int @@v9@@ ; unsigned int @@v10@@ ; int @@v11@@ ; int @@v12@@ ; char * @@ptr@@ ; int @@v14@@ [ Number ] ; char @@v15@@ [ Number ] ; unsigned __int64 @@v16@@ ; @@v16@@ = __readfsqword ( Number ) ; if ( @@a1@@ == Number || * @@a2@@ == Number ) return lsetfilecon ( @@a2@@ , @@a3@@ ) ; @@ptr@@ = ( char * ) openat_proc_name ( @@v15@@ , ( unsigned int ) @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ ) goto LABEL_33 ; @@v8@@ = lsetfilecon ( @@ptr@@ , @@a3@@ ) ; @@v9@@ = * __errno_location ( ) ; if ( @@ptr@@ != @@v15@@ ) free ( @@ptr@@ ) ; if ( @@v8@@ != Number ) return @@v8@@ ; if ( @@v9@@ == Number || @@v9@@ == Number || @@v9@@ == Number || @@v9@@ == Number || @@v9@@ == Number || @@v9@@ == Number ) { LABEL_33 : if ( ( unsigned int ) save_cwd ( @@v14@@ ) ) { @@v4@@ = __errno_location ( ) ; openat_save_fail ( ( unsigned int ) * @@v4@@ ) ; } if ( @@a1@@ >= Number && @@a1@@ == @@v14@@ [ Number ] ) { free_cwd ( @@v14@@ ) ; * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( fchdir ( @@a1@@ ) ) { @@v11@@ = * __errno_location ( ) ; free_cwd ( @@v14@@ ) ; * __errno_location ( ) = @@v11@@ ; @@result@@ = Number ; } else { @@v10@@ = lsetfilecon ( @@a2@@ , @@a3@@ ) ; if ( @@v10@@ == Number ) @@v5@@ = * __errno_location ( ) ; else @@v5@@ = Number ; @@v12@@ = @@v5@@ ; if ( ( unsigned int ) restore_cwd ( @@v14@@ ) ) { @@v6@@ = __errno_location ( ) ; openat_restore_fail ( ( unsigned int ) * @@v6@@ ) ; } free_cwd ( @@v14@@ ) ; if ( @@v12@@ ) * __errno_location ( ) = @@v12@@ ; @@result@@ = @@v10@@ ; } } else { * __errno_location ( ) = @@v9@@ ; @@result@@ = Number ; } return @@result@@ ; }
__ino_t * __fastcall get_root_dev_ino ( __ino_t * @@a1@@ ) { struct stat @@v2@@ ; unsigned __int64 @@v3@@ ; @@v3@@ = __readfsqword ( Number ) ; if ( ( unsigned int ) lstat ( String , & @@v2@@ ) ) return Number L ; * @@a1@@ = @@v2@@ . st_ino ; @@a1@@ [ Number ] = @@v2@@ . st_dev ; return @@a1@@ ; }
__int64 __fastcall bsd_split_3 ( __int64 @@a1@@ , __int64 @@a2@@ , _QWORD * @@a3@@ , _QWORD * @@a4@@ ) { __int64 @@v5@@ ; __int64 @@i@@ ; __int64 @@v7@@ ; __int64 @@j@@ ; if ( ! @@a2@@ ) return Number L ; * @@a4@@ = @@a1@@ ; for ( @@i@@ = @@a2@@ - Number ; @@i@@ && * ( _BYTE * ) ( @@a1@@ + @@i@@ ) != Number ; -- @@i@@ ) { ; } if ( * ( _BYTE * ) ( @@a1@@ + @@i@@ ) != Number ) return Number L ; @@v5@@ = @@i@@ ; @@v7@@ = @@i@@ + Number ; * ( _BYTE * ) ( @@a1@@ + @@v5@@ ) = Number ; while ( * ( _BYTE * ) ( @@a1@@ + @@v7@@ ) == Number || * ( _BYTE * ) ( @@a1@@ + @@v7@@ ) == Number ) ++ @@v7@@ ; if ( * ( _BYTE * ) ( @@a1@@ + @@v7@@ ) != Number ) return Number L ; for ( @@j@@ = @@v7@@ + Number ; * ( _BYTE * ) ( @@a1@@ + @@j@@ ) == Number || * ( _BYTE * ) ( @@a1@@ + @@j@@ ) == Number ; ++ @@j@@ ) { ; } * @@a3@@ = @@j@@ + @@a1@@ ; return Number L ; }
int __cdecl __noreturn main ( int @@argc@@ , const char * * @@argv@@ , const char * * @@envp@@ ) { char * @@v3@@ ; __int64 @@v4@@ ; char * @@v5@@ ; __int64 @@v6@@ ; char * @@v7@@ ; int * @@v8@@ ; set_program_name ( * @@argv@@ , @@argv@@ , @@envp@@ ) ; setlocale ( Number , & shortopts ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; parse_long_options ( @@argc@@ , ( _DWORD ) @@argv@@ , ( unsigned int ) String , ( unsigned int ) String , ( _DWORD ) Version , ( unsigned int ) usage , String , Number L ) ; if ( getopt_long ( @@argc@@ , ( char * const * ) @@argv@@ , & shortopts , Number L , Number L ) != Number ) usage ( Number ) ; if ( @@argc@@ < optind + Number ) { @@v3@@ = gettext ( String ) ; error ( Number , Number , @@v3@@ ) ; usage ( Number ) ; } if ( @@argc@@ > optind + Number ) { @@v4@@ = quote ( @@argv@@ [ optind + Number ] ) ; @@v5@@ = gettext ( String ) ; error ( Number , Number , @@v5@@ , @@v4@@ ) ; usage ( Number ) ; } if ( unlink ( @@argv@@ [ optind ] ) ) { @@v6@@ = quote ( @@argv@@ [ optind ] ) ; @@v7@@ = gettext ( String ) ; @@v8@@ = __errno_location ( ) ; error ( Number , * @@v8@@ , @@v7@@ , @@v6@@ ) ; } exit ( Number ) ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; char * @@v3@@ ; FILE * @@v4@@ ; char * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; FILE * @@v11@@ ; char * @@v12@@ ; FILE * @@v13@@ ; char * @@v14@@ ; char * @@v15@@ ; @@v1@@ = program_name ; if ( @@a1@@ ) { @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = gettext ( String String String String ) ; printf ( @@v3@@ , @@v1@@ , String , Number L ) ; @@v4@@ = stdout ; @@v5@@ = gettext ( String ) ; fputs_unlocked ( @@v5@@ , @@v4@@ ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , String ) ; @@v7@@ = stdout ; @@v8@@ = gettext ( String ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = stdout ; @@v10@@ = gettext ( String String String String String String ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; @@v11@@ = stdout ; @@v12@@ = gettext ( String ) ; fputs_unlocked ( @@v12@@ , @@v11@@ ) ; @@v13@@ = stdout ; @@v14@@ = gettext ( String ) ; fputs_unlocked ( @@v14@@ , @@v13@@ ) ; @@v15@@ = gettext ( String String String String String ) ; printf ( @@v15@@ , String ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
void __fastcall __noreturn openat_save_fail ( int @@a1@@ ) { char * @@v1@@ ; @@v1@@ = gettext ( String ) ; error ( exit_failure , @@a1@@ , @@v1@@ ) ; abort ( ) ; }
__int64 __fastcall setfileconat ( int @@a1@@ , _BYTE * @@a2@@ , __int64 @@a3@@ ) { __int64 @@result@@ ; int * @@v4@@ ; int @@v5@@ ; int * @@v6@@ ; unsigned int @@v8@@ ; int @@v9@@ ; unsigned int @@v10@@ ; int @@v11@@ ; int @@v12@@ ; char * @@ptr@@ ; int @@v14@@ [ Number ] ; char @@v15@@ [ Number ] ; unsigned __int64 @@v16@@ ; @@v16@@ = __readfsqword ( Number ) ; if ( @@a1@@ == Number || * @@a2@@ == Number ) return setfilecon ( @@a2@@ , @@a3@@ ) ; @@ptr@@ = ( char * ) openat_proc_name ( @@v15@@ , ( unsigned int ) @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ ) goto LABEL_33 ; @@v8@@ = setfilecon ( @@ptr@@ , @@a3@@ ) ; @@v9@@ = * __errno_location ( ) ; if ( @@ptr@@ != @@v15@@ ) free ( @@ptr@@ ) ; if ( @@v8@@ != Number ) return @@v8@@ ; if ( @@v9@@ == Number || @@v9@@ == Number || @@v9@@ == Number || @@v9@@ == Number || @@v9@@ == Number || @@v9@@ == Number ) { LABEL_33 : if ( ( unsigned int ) save_cwd ( @@v14@@ ) ) { @@v4@@ = __errno_location ( ) ; openat_save_fail ( ( unsigned int ) * @@v4@@ ) ; } if ( @@a1@@ >= Number && @@a1@@ == @@v14@@ [ Number ] ) { free_cwd ( @@v14@@ ) ; * __errno_location ( ) = Number ; @@result@@ = Number ; } else if ( fchdir ( @@a1@@ ) ) { @@v11@@ = * __errno_location ( ) ; free_cwd ( @@v14@@ ) ; * __errno_location ( ) = @@v11@@ ; @@result@@ = Number ; } else { @@v10@@ = setfilecon ( @@a2@@ , @@a3@@ ) ; if ( @@v10@@ == Number ) @@v5@@ = * __errno_location ( ) ; else @@v5@@ = Number ; @@v12@@ = @@v5@@ ; if ( ( unsigned int ) restore_cwd ( @@v14@@ ) ) { @@v6@@ = __errno_location ( ) ; openat_restore_fail ( ( unsigned int ) * @@v6@@ ) ; } free_cwd ( @@v14@@ ) ; if ( @@v12@@ ) * __errno_location ( ) = @@v12@@ ; @@result@@ = @@v10@@ ; } } else { * __errno_location ( ) = @@v9@@ ; @@result@@ = Number ; } return @@result@@ ; }
_DWORD * __fastcall md5_read_ctx ( int * @@a1@@ , _DWORD * @@a2@@ ) { set_uint32 ( @@a2@@ , * @@a1@@ ) ; set_uint32 ( @@a2@@ + Number , @@a1@@ [ Number ] ) ; set_uint32 ( @@a2@@ + Number , @@a1@@ [ Number ] ) ; set_uint32 ( @@a2@@ + Number , @@a1@@ [ Number ] ) ; return @@a2@@ ; }
_DWORD * __fastcall md5_finish_ctx ( int * @@a1@@ , _DWORD * @@a2@@ ) { __int64 @@v2@@ ; unsigned int @@v4@@ ; __int64 @@v5@@ ; @@v4@@ = @@a1@@ [ Number ] ; if ( @@v4@@ > Number ) @@v2@@ = Number L ; else @@v2@@ = Number L ; @@v5@@ = @@v2@@ ; @@a1@@ [ Number ] += @@v4@@ ; if ( @@v4@@ > @@a1@@ [ Number ] ) ++ @@a1@@ [ Number ] ; @@a1@@ [ @@v2@@ + Number ] = Number * @@a1@@ [ Number ] ; @@a1@@ [ @@v2@@ + Number ] = * ( ( __int64 * ) @@a1@@ + Number ) >> Number ; memcpy ( ( char * ) @@a1@@ + @@v4@@ + Number , & fillbuf , Number * @@v2@@ - @@v4@@ - Number ) ; md5_process_block ( @@a1@@ + Number , Number * @@v5@@ , @@a1@@ ) ; return md5_read_ctx ( @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 __fastcall set_cloexec_flag ( int @@a1@@ , char @@a2@@ , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { int @@v6@@ ; int @@v7@@ ; int @@v8@@ ; unsigned int @@v9@@ ; __int64 @@result@@ ; int @@v11@@ ; @@v11@@ = rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( @@v11@@ < Number || ( ! @@a2@@ ? ( @@v9@@ = @@v11@@ & Number ) : ( @@v9@@ = @@v11@@ | Number ) , @@v11@@ != @@v9@@ && ( unsigned int ) rpl_fcntl ( @@a1@@ , Number , @@v9@@ , @@v6@@ , @@v7@@ , @@v8@@ ) == Number ) ) { @@result@@ = Number ; } else { @@result@@ = Number L ; } return @@result@@ ; }
_DWORD * __fastcall md5_buffer ( __int64 @@a1@@ , __int64 @@a2@@ , _DWORD * @@a3@@ ) { int @@v5@@ [ Number ] ; unsigned __int64 @@v6@@ ; @@v6@@ = __readfsqword ( Number ) ; md5_init_ctx ( @@v5@@ ) ; md5_process_bytes ( @@a1@@ , @@a2@@ , @@v5@@ ) ; return md5_finish_ctx ( @@v5@@ , @@a3@@ ) ; }
__int64 __fastcall xfts_open ( const char * * @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { unsigned int @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; __int64 @@v7@@ ; @@v3@@ = @@a2@@ ; BYTE1 ( @@v3@@ ) = BYTE1 ( @@a2@@ ) | Number ; @@v4@@ = @@v3@@ ; @@v7@@ = fts_open ( @@a1@@ , @@v3@@ , @@a3@@ ) ; if ( ! @@v7@@ ) { if ( * __errno_location ( ) == Number ) __assert_fail ( String , String , Number , String ) ; xalloc_die ( @@a1@@ , @@v4@@ , @@v5@@ ) ; } return @@v7@@ ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_206028 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
__int64 __fastcall rpl_fcntl ( int @@a1@@ , int @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , __m128 @@a7@@ , __m128 @@a8@@ , __m128 @@a9@@ , __m128 @@a10@@ , __m128 @@a11@@ , __m128 @@a12@@ , __m128 @@a13@@ , __m128 @@a14@@ ) { int @@v14@@ ; int @@v15@@ ; int @@v16@@ ; int @@v18@@ ; int @@v19@@ ; int @@v20@@ ; int @@v21@@ ; __int64 @@v22@@ ; __int64 @@v23@@ ; __int64 @@v24@@ ; __int64 @@v25@@ ; __m128 @@v26@@ ; __m128 @@v27@@ ; __m128 @@v28@@ ; __m128 @@v29@@ ; __m128 @@v30@@ ; __m128 @@v31@@ ; __m128 @@v32@@ ; __m128 @@v33@@ ; @@v22@@ = @@a3@@ ; @@v23@@ = @@a4@@ ; @@v24@@ = @@a5@@ ; @@v25@@ = @@a6@@ ; @@v26@@ = @@a7@@ ; @@v27@@ = @@a8@@ ; @@v28@@ = @@a9@@ ; @@v29@@ = @@a10@@ ; @@v30@@ = @@a11@@ ; @@v31@@ = @@a12@@ ; @@v32@@ = @@a13@@ ; @@v33@@ = @@a14@@ ; if ( @@a2@@ != Number ) return ( unsigned int ) fcntl ( @@a1@@ , @@a2@@ , @@v22@@ ) ; @@v19@@ = @@v22@@ ; if ( have_dupfd_cloexec_2895 < Number ) { @@v18@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v22@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; } else { @@v18@@ = fcntl ( @@a1@@ , Number , ( unsigned int ) @@v22@@ ) ; if ( @@v18@@ < Number && * __errno_location ( ) == Number ) { @@v18@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v19@@ , @@v14@@ , @@v15@@ , @@v16@@ ) ; if ( @@v18@@ < Number ) return ( unsigned int ) @@v18@@ ; have_dupfd_cloexec_2895 = Number ; } else { have_dupfd_cloexec_2895 = Number ; } } if ( @@v18@@ >= Number && have_dupfd_cloexec_2895 == Number ) { @@v20@@ = fcntl ( @@v18@@ , Number ) ; if ( @@v20@@ < Number || fcntl ( @@v18@@ , Number , @@v20@@ | Number ) == Number ) { @@v21@@ = * __errno_location ( ) ; close ( @@v18@@ ) ; * __errno_location ( ) = @@v21@@ ; @@v18@@ = Number ; } } return ( unsigned int ) @@v18@@ ; }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 __fastcall cycle_check ( __int64 @@a1@@ , _QWORD * @@a2@@ ) { if ( * ( _DWORD * ) ( @@a1@@ + Number ) != Number ) __assert_fail ( String , String , Number , String ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) && @@a2@@ [ Number ] == * ( _QWORD * ) @@a1@@ && * @@a2@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ) { return Number L ; } if ( is_zero_or_power_of_two ( ++ * ( _QWORD * ) ( @@a1@@ + Number ) ) ) { if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = * @@a2@@ ; * ( _QWORD * ) @@a1@@ = @@a2@@ [ Number ] ; } return Number L ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
bool __fastcall hex_digits ( _BYTE * @@a1@@ ) { unsigned int @@i@@ ; for ( @@i@@ = Number ; @@i@@ < ( unsigned __int64 ) digest_hex_bytes ; ++ @@i@@ ) { if ( ( ( * __ctype_b_loc ( ) ) [ ( unsigned __int8 ) * @@a1@@ ] & Number ) == Number ) return Number ; ++ @@a1@@ ; } return * @@a1@@ == Number ; }
char * xgetcwd ( ) { char * @@v1@@ ; @@v1@@ = getcwd ( Number L , Number L ) ; if ( ! @@v1@@ && * __errno_location ( ) == Number ) xalloc_die ( ) ; return @@v1@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
int chdir ( const char * @@path@@ ) { return chdir ( @@path@@ ) ; }
int putenv ( char * @@string@@ ) { return putenv ( @@string@@ ) ; }
__int64 __fastcall cdb_advance_fd ( int * @@a1@@ , const char * @@a2@@ ) { int @@v3@@ ; @@v3@@ = openat ( * @@a1@@ , @@a2@@ , Number ) ; if ( @@v3@@ < Number ) return Number ; cdb_free ( @@a1@@ ) ; * @@a1@@ = @@v3@@ ; return Number L ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
int tcgetattr ( int @@fd@@ , struct termios * @@termios_p@@ ) { return tcgetattr ( @@fd@@ , @@termios_p@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
int __fastcall lstat ( char * @@filename@@ , struct stat * @@stat_buf@@ ) { return __lxstat ( Number , @@filename@@ , @@stat_buf@@ ) ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_20A028 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
int setuid ( __uid_t @@uid@@ ) { return setuid ( @@uid@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , off_7DC2 , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
int unlink ( const char * @@name@@ ) { return unlink ( @@name@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return xmalloc ( @@a1@@ , @@a2@@ , @@a3@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
unsigned __int64 __fastcall md5_process_bytes ( char * @@a1@@ , unsigned __int64 @@a2@@ , unsigned int * @@a3@@ ) { unsigned __int64 @@result@@ ; size_t @@v4@@ ; void * @@v5@@ ; size_t @@v7@@ ; char * @@src@@ ; size_t @@v9@@ ; size_t @@v10@@ ; __int64 @@v11@@ ; size_t @@n@@ ; @@src@@ = @@a1@@ ; @@v7@@ = @@a2@@ ; @@result@@ = @@a3@@ [ Number ] ; if ( ( _DWORD ) @@result@@ ) { @@v11@@ = @@a3@@ [ Number ] ; @@v4@@ = Number - @@v11@@ ; if ( @@a2@@ <= Number - @@v11@@ ) @@v4@@ = @@a2@@ ; @@n@@ = @@v4@@ ; memcpy ( ( char * ) @@a3@@ + @@v11@@ + Number , @@a1@@ , @@v4@@ ) ; @@a3@@ [ Number ] += @@n@@ ; if ( @@a3@@ [ Number ] > Number ) { md5_process_block ( @@a3@@ + Number , @@a3@@ [ Number ] & Number , @@a3@@ ) ; @@a3@@ [ Number ] &= Number ; memcpy ( @@a3@@ + Number , ( char * ) @@a3@@ + ( ( @@v11@@ + @@n@@ ) & Number ) + Number , @@a3@@ [ Number ] ) ; } @@src@@ = & @@a1@@ [ @@n@@ ] ; @@result@@ = @@n@@ ; @@v7@@ = @@a2@@ - @@n@@ ; } if ( @@v7@@ > Number ) { @@result@@ = ( unsigned __int8 ) @@src@@ & Number ; if ( ( ( unsigned __int8 ) @@src@@ & Number ) != Number ) { while ( @@v7@@ > Number ) { @@v5@@ = memcpy ( @@a3@@ + Number , @@src@@ , Number ) ; @@result@@ = md5_process_block ( @@v5@@ , Number L , @@a3@@ ) ; @@src@@ += Number ; @@v7@@ -= Number L ; } } else { md5_process_block ( @@src@@ , @@v7@@ & Number , @@a3@@ ) ; @@result@@ = @@v7@@ & Number ; @@src@@ += @@v7@@ & Number ; @@v7@@ &= Number ; } } if ( @@v7@@ ) { @@v9@@ = @@a3@@ [ Number ] ; memcpy ( ( char * ) @@a3@@ + @@v9@@ + Number , @@src@@ , @@v7@@ ) ; @@v10@@ = @@v7@@ + @@v9@@ ; if ( @@v10@@ > Number ) { md5_process_block ( @@a3@@ + Number , Number L , @@a3@@ ) ; @@v10@@ -= Number L ; memcpy ( @@a3@@ + Number , @@a3@@ + Number , @@v10@@ ) ; } @@result@@ = ( unsigned __int64 ) @@a3@@ ; @@a3@@ [ Number ] = @@v10@@ ; } return @@result@@ ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
void __fastcall __noreturn run_shell ( const char * @@a1@@ , char * @@a2@@ , const void * @@a3@@ , __int64 @@a4@@ ) { int @@v4@@ ; size_t @@v5@@ ; __int64 @@v6@@ ; int @@v7@@ ; int * @@v8@@ ; int @@status@@ ; __int64 @@v12@@ ; char * * @@argv@@ ; char * @@s@@ ; char * @@v15@@ ; if ( @@a2@@ ) @@v4@@ = Number ; else @@v4@@ = Number ; @@argv@@ = ( char * * ) xnmalloc ( @@v4@@ + ( unsigned __int8 ) fast_startup + Number + @@a4@@ + Number , Number L ) ; @@v12@@ = Number L ; if ( simulate_login ) { @@s@@ = ( char * ) last_component ( @@a1@@ ) ; @@v5@@ = strlen ( @@s@@ ) ; @@v15@@ = ( char * ) xmalloc ( @@v5@@ + Number ) ; * @@v15@@ = Number ; strcpy ( @@v15@@ + Number , @@s@@ ) ; * @@argv@@ = @@v15@@ ; } else { * @@argv@@ = ( char * ) last_component ( @@a1@@ ) ; } if ( fast_startup ) { @@v12@@ = Number L ; @@argv@@ [ Number ] = String ; } if ( @@a2@@ ) { @@argv@@ [ @@v12@@ ] = String ; @@v6@@ = @@v12@@ + Number ; @@v12@@ += Number L ; @@argv@@ [ @@v6@@ ] = @@a2@@ ; } memcpy ( & @@argv@@ [ @@v12@@ ] , @@a3@@ , Number * @@a4@@ ) ; ( & @@argv@@ [ @@v12@@ ] ) [ @@a4@@ ] = Number L ; execv ( @@a1@@ , @@argv@@ ) ; if ( * __errno_location ( ) == Number ) @@v7@@ = Number ; else @@v7@@ = Number ; @@status@@ = @@v7@@ ; @@v8@@ = __errno_location ( ) ; error ( Number , * @@v8@@ , String , @@a1@@ ) ; exit ( @@status@@ ) ; }
__int64 __fastcall digest_file ( const char * @@a1@@ , __int64 a2 , __int64 @@a3@@ ) { int @@v3@@ ; int @@v4@@ ; int * @@v5@@ ; int * @@v7@@ ; bool @@v9@@ ; FILE * @@stream@@ ; @@v3@@ = strcmp ( @@a1@@ , String ) ; @@v9@@ = @@v3@@ == Number ; if ( @@v3@@ ) { @@stream@@ = ( FILE * ) fopen_safer ( @@a1@@ , String ) ; if ( ! @@stream@@ ) goto LABEL_4 ; @@v4@@ = md5_stream ( @@stream@@ , @@a3@@ ) ; } else { have_read_stdin = Number ; @@stream@@ = stdin ; @@v4@@ = md5_stream ( stdin , @@a3@@ ) ; } if ( ! @@v4@@ ) { if ( @@v9@@ || ! fclose ( @@stream@@ ) ) return Number L ; LABEL_4 : @@v5@@ = __errno_location ( ) ; error ( Number , * @@v5@@ , String , @@a1@@ ) ; return Number L ; } @@v7@@ = __errno_location ( ) ; error ( Number , * @@v7@@ , String , @@a1@@ ) ; if ( @@stream@@ != stdin ) fclose ( @@stream@@ ) ; return Number L ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; FILE * @@v10@@ ; char * @@v11@@ ; if ( @@a1@@ ) { @@v1@@ = program_name ; @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = program_name ; @@v4@@ = program_name ; @@v5@@ = gettext ( String ) ; printf ( @@v5@@ , @@v4@@ , @@v3@@ ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; @@v8@@ = stdout ; @@v9@@ = gettext ( String ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = stdout ; @@v11@@ = gettext ( String ) ; fputs_unlocked ( @@v11@@ , @@v10@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
char * __fastcall gnu_getpass ( const char * @@a1@@ ) { int @@v1@@ ; int @@v2@@ ; int @@v3@@ ; bool @@v5@@ ; FILE * @@stream@@ ; FILE * @@v7@@ ; FILE * @@fp@@ ; __ssize_t @@v9@@ ; struct termios @@v10@@ ; struct termios @@termios_p@@ ; unsigned __int64 @@v12@@ ; @@v12@@ = __readfsqword ( Number ) ; @@v5@@ = Number ; @@fp@@ = fopen ( String , String ) ; if ( @@fp@@ ) { __fsetlocking ( @@fp@@ , Number ) ; @@stream@@ = @@fp@@ ; @@v7@@ = @@fp@@ ; @@v1@@ = fileno ( @@fp@@ ) ; } else { @@stream@@ = ( FILE * ) stdin ; @@v7@@ = stderr ; @@v1@@ = fileno ( ( FILE * ) stdin ) ; } if ( ! tcgetattr ( @@v1@@ , & @@termios_p@@ ) ) { @@v10@@ = @@termios_p@@ ; @@termios_p@@ . c_lflag &= Number ; @@v2@@ = fileno ( @@stream@@ ) ; @@v5@@ = tcsetattr ( @@v2@@ , Number , & @@termios_p@@ ) == Number ; } fputs_unlocked ( @@a1@@ , @@v7@@ ) ; fflush_unlocked ( @@v7@@ ) ; @@v9@@ = getline ( & buf_3288 , & bufsize_3289 , @@stream@@ ) ; rpl_fseeko ( @@v7@@ , Number L , Number L ) ; if ( buf_3288 ) { if ( @@v9@@ >= Number ) { if ( buf_3288 [ @@v9@@ - Number ] == Number ) { buf_3288 [ @@v9@@ - Number ] = Number ; if ( @@v5@@ ) putc_unlocked ( Number , @@v7@@ ) ; } } else { * buf_3288 = Number ; } } if ( @@v5@@ ) { @@v3@@ = fileno ( @@stream@@ ) ; tcsetattr ( @@v3@@ , Number , & @@v10@@ ) ; } call_fclose ( @@fp@@ ) ; return buf_3288 ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_208028 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall md5_stream ( FILE * @@a1@@ , _DWORD * @@a2@@ ) { __int64 @@v3@@ ; char * @@ptr@@ ; size_t @@v5@@ ; int @@v6@@ [ Number ] ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@ptr@@ = ( char * ) malloc ( Number ) ; if ( ! @@ptr@@ ) return Number L ; md5_init_ctx ( @@v6@@ ) ; LABEL_4 : @@v3@@ = Number L ; while ( Number ) { @@v5@@ = fread_unlocked ( & @@ptr@@ [ @@v3@@ ] , Number , Number - @@v3@@ , @@a1@@ ) ; @@v3@@ += @@v5@@ ; if ( @@v3@@ == Number ) { md5_process_block ( @@ptr@@ , Number , @@v6@@ ) ; goto LABEL_4 ; } if ( ! @@v5@@ ) break ; if ( feof_unlocked ( @@a1@@ ) ) goto LABEL_12 ; } if ( ferror_unlocked ( @@a1@@ ) ) { free ( @@ptr@@ ) ; return Number L ; } LABEL_12 : if ( @@v3@@ ) md5_process_bytes ( @@ptr@@ , @@v3@@ , @@v6@@ ) ; md5_finish_ctx ( @@v6@@ , @@a2@@ ) ; free ( @@ptr@@ ) ; return Number L ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_2080C8 ; @@v8@@ [ Number ] = qword_2080D0 ; @@v8@@ [ Number ] = qword_2080D8 ; @@v8@@ [ Number ] = qword_2080E0 ; @@v8@@ [ Number ] = qword_2080E8 ; @@v8@@ [ Number ] = qword_2080F0 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_20A028 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
void clearerr_unlocked ( FILE * @@stream@@ ) { clearerr_unlocked ( @@stream@@ ) ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_20A0E8 ; @@v8@@ [ Number ] = qword_20A0F0 ; @@v8@@ [ Number ] = qword_20A0F8 ; @@v8@@ [ Number ] = qword_20A100 ; @@v8@@ [ Number ] = qword_20A108 ; @@v8@@ [ Number ] = qword_20A110 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
struct passwd * getpwnam ( const char * @@name@@ ) { return getpwnam ( @@name@@ ) ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_206028 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
int tcsetattr ( int @@fd@@ , int @@optional_actions@@ , const struct termios * @@termios_p@@ ) { return tcsetattr ( @@fd@@ , @@optional_actions@@ , @@termios_p@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_2060C8 ; @@v8@@ [ Number ] = qword_2060D0 ; @@v8@@ [ Number ] = qword_2060D8 ; @@v8@@ [ Number ] = qword_2060E0 ; @@v8@@ [ Number ] = qword_2060E8 ; @@v8@@ [ Number ] = qword_2060F0 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
int __fastcall xsetenv ( const char * @@a1@@ , const char * @@a2@@ ) { int @@result@@ ; size_t @@v3@@ ; size_t @@v4@@ ; char * @@dest@@ ; @@v3@@ = strlen ( @@a1@@ ) ; @@v4@@ = strlen ( @@a2@@ ) ; @@dest@@ = ( char * ) xmalloc ( @@v3@@ + @@v4@@ + Number ) ; strcpy ( @@dest@@ , @@a1@@ ) ; @@dest@@ [ @@v3@@ ] = Number ; strcpy ( & @@dest@@ [ @@v3@@ + Number ] , @@a2@@ ) ; @@result@@ = putenv ( @@dest@@ ) ; if ( @@result@@ ) xalloc_die ( ) ; return @@result@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall rpl_fcntl ( int @@a1@@ , int @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , __m128 @@a7@@ , __m128 @@a8@@ , __m128 @@a9@@ , __m128 @@a10@@ , __m128 @@a11@@ , __m128 @@a12@@ , __m128 @@a13@@ , __m128 @@a14@@ ) { int @@v14@@ ; int @@v15@@ ; int @@v16@@ ; int @@v18@@ ; int @@v19@@ ; int @@v20@@ ; int @@v21@@ ; __int64 @@v22@@ ; __int64 @@v23@@ ; __int64 @@v24@@ ; __int64 @@v25@@ ; __m128 @@v26@@ ; __m128 @@v27@@ ; __m128 @@v28@@ ; __m128 @@v29@@ ; __m128 @@v30@@ ; __m128 @@v31@@ ; __m128 @@v32@@ ; __m128 @@v33@@ ; @@v22@@ = @@a3@@ ; @@v23@@ = @@a4@@ ; @@v24@@ = @@a5@@ ; @@v25@@ = @@a6@@ ; @@v26@@ = @@a7@@ ; @@v27@@ = @@a8@@ ; @@v28@@ = @@a9@@ ; @@v29@@ = @@a10@@ ; @@v30@@ = @@a11@@ ; @@v31@@ = @@a12@@ ; @@v32@@ = @@a13@@ ; @@v33@@ = @@a14@@ ; if ( @@a2@@ != Number ) return ( unsigned int ) fcntl ( @@a1@@ , @@a2@@ , @@v22@@ ) ; @@v19@@ = @@v22@@ ; if ( have_dupfd_cloexec_2895 < Number ) { @@v18@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v22@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; } else { @@v18@@ = fcntl ( @@a1@@ , Number , ( unsigned int ) @@v22@@ ) ; if ( @@v18@@ < Number && * __errno_location ( ) == Number ) { @@v18@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v19@@ , @@v14@@ , @@v15@@ , @@v16@@ ) ; if ( @@v18@@ < Number ) return ( unsigned int ) @@v18@@ ; have_dupfd_cloexec_2895 = Number ; } else { have_dupfd_cloexec_2895 = Number ; } } if ( @@v18@@ >= Number && have_dupfd_cloexec_2895 == Number ) { @@v20@@ = fcntl ( @@v18@@ , Number ) ; if ( @@v20@@ < Number || fcntl ( @@v18@@ , Number , @@v20@@ | Number ) == Number ) { @@v21@@ = * __errno_location ( ) ; close ( @@v18@@ ) ; * __errno_location ( ) = @@v21@@ ; @@v18@@ = Number ; } } return ( unsigned int ) @@v18@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall restricted_shell ( const char * @@a1@@ ) { char * @@s1@@ ; setusershell ( ) ; while ( Number ) { @@s1@@ = getusershell ( ) ; if ( ! @@s1@@ ) break ; if ( * @@s1@@ != Number && ! strcmp ( @@s1@@ , @@a1@@ ) ) { endusershell ( ) ; return Number L ; } } endusershell ( ) ; return Number L ; }
FILE * __fastcall next_file ( FILE * @@a1@@ ) { const char * @@v1@@ ; int * @@v2@@ ; const char * @@v3@@ ; int * @@v4@@ ; int * @@v6@@ ; char * * @@v7@@ ; FILE * @@stream@@ ; char * @@s1@@ ; if ( @@a1@@ ) { if ( ferror_unlocked ( @@a1@@ ) ) { @@v1@@ = prev_file_5522 ; @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v1@@ ) ; exit_status = Number ; } if ( ! strcmp ( prev_file_5522 , String ) ) { clearerr_unlocked ( @@a1@@ ) ; } else if ( fclose ( @@a1@@ ) ) { @@v3@@ = prev_file_5522 ; @@v4@@ = __errno_location ( ) ; error ( Number , * @@v4@@ , String , @@v3@@ ) ; exit_status = Number ; } } while ( Number ) { @@v7@@ = ( char * * ) file_list ; file_list += Number L ; @@s1@@ = * @@v7@@ ; if ( ! * @@v7@@ ) break ; if ( ! strcmp ( @@s1@@ , String ) ) { have_read_stdin = Number ; prev_file_5522 = @@s1@@ ; return stdin ; } @@stream@@ = fopen ( @@s1@@ , String ) ; if ( @@stream@@ ) { prev_file_5522 = @@s1@@ ; return @@stream@@ ; } @@v6@@ = __errno_location ( ) ; error ( Number , * @@v6@@ , String , @@s1@@ ) ; exit_status = Number ; } return Number L ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
struct spwd * getspnam ( const char * @@name@@ ) { return getspnam ( @@name@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
int fflush_unlocked ( FILE * @@stream@@ ) { return fflush_unlocked ( @@stream@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_207128 ; @@v4@@ [ Number ] = qword_207130 ; @@v4@@ [ Number ] = qword_207138 ; @@v4@@ [ Number ] = qword_207140 ; @@v4@@ [ Number ] = qword_207148 ; @@v4@@ [ Number ] = qword_207150 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
int fileno ( FILE * @@stream@@ ) { return fileno ( @@stream@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
int __fastcall modify_environment ( __int64 @@a1@@ , const char * @@a2@@ ) { __int64 @@v2@@ ; const char * @@v3@@ ; int @@result@@ ; char * @@v5@@ ; if ( simulate_login ) { @@v5@@ = getenv ( String ) ; if ( @@v5@@ ) @@v5@@ = ( char * ) xstrdup ( @@v5@@ ) ; if ( @@v5@@ ) @@v2@@ = Number L ; else @@v2@@ = Number L ; environ = xmalloc ( @@v2@@ ) ; * ( _QWORD * ) environ = Number L ; if ( @@v5@@ ) xsetenv ( String , @@v5@@ ) ; xsetenv ( String , * ( const char * * ) ( @@a1@@ + Number ) ) ; xsetenv ( String , @@a2@@ ) ; xsetenv ( String , * ( const char * * ) @@a1@@ ) ; xsetenv ( String , * ( const char * * ) @@a1@@ ) ; if ( * ( _DWORD * ) ( @@a1@@ + Number ) ) @@v3@@ = String ; else @@v3@@ = String ; @@result@@ = xsetenv ( String , @@v3@@ ) ; } else { @@result@@ = ( unsigned __int8 ) change_environment ; if ( change_environment ) { xsetenv ( String , * ( const char * * ) ( @@a1@@ + Number ) ) ; xsetenv ( String , @@a2@@ ) ; @@result@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; if ( @@result@@ ) { xsetenv ( String , * ( const char * * ) @@a1@@ ) ; @@result@@ = xsetenv ( String , * ( const char * * ) @@a1@@ ) ; } } } return @@result@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ ) ; return @@ptr@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_2060C8 ; @@v4@@ [ Number ] = qword_2060D0 ; @@v4@@ [ Number ] = qword_2060D8 ; @@v4@@ [ Number ] = qword_2060E0 ; @@v4@@ [ Number ] = qword_2060E8 ; @@v4@@ [ Number ] = qword_2060F0 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return xmalloc ( @@a1@@ , @@a2@@ , @@a3@@ ) ; }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
int __fastcall call_fclose ( FILE * @@a1@@ ) { int @@result@@ ; if ( @@a1@@ ) @@result@@ = fclose ( @@a1@@ ) ; return @@result@@ ; }
int raise ( int @@sig@@ ) { return raise ( @@sig@@ ) ; }
__int64 __fastcall xnrealloc ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { if ( ! is_mul_ok ( @@a3@@ , @@a2@@ ) ) xalloc_die ( ) ; return xrealloc ( @@a1@@ , @@a3@@ * @@a2@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ ) { return xmalloc ( @@a1@@ ) ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
int toupper ( int @@c@@ ) { return toupper ( @@c@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
bool __fastcall correct_password ( __int64 @@a1@@ ) { bool @@result@@ ; char * @@v2@@ ; char * @@v3@@ ; size_t @@v4@@ ; char * @@salt@@ ; struct spwd * @@v6@@ ; char * @@key@@ ; const char * @@s1@@ ; @@v6@@ = getspnam ( * ( const char * * ) @@a1@@ ) ; endspent ( ) ; if ( @@v6@@ ) @@salt@@ = @@v6@@ -> sp_pwdp ; else @@salt@@ = * ( char * * ) ( @@a1@@ + Number ) ; if ( ! getuid ( ) || ! @@salt@@ || ! * @@salt@@ ) return Number ; @@v2@@ = gettext ( String ) ; @@key@@ = ( char * ) gnu_getpass ( @@v2@@ ) ; if ( @@key@@ ) { @@s1@@ = crypt ( @@key@@ , @@salt@@ ) ; @@v4@@ = strlen ( @@key@@ ) ; memset ( @@key@@ , Number , @@v4@@ ) ; @@result@@ = strcmp ( @@s1@@ , @@salt@@ ) == Number ; } else { @@v3@@ = gettext ( String ) ; error ( Number , Number , @@v3@@ ) ; @@result@@ = Number ; } return @@result@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@v2@@ ; @@v2@@ = malloc ( @@a1@@ ) ; if ( ! @@v2@@ && @@a1@@ ) xalloc_die ( ) ; return @@v2@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( ) ; return @@ptr@@ ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@v3@@ ; @@v3@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v3@@ ) xalloc_die ( ) ; return @@v3@@ ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; char * @@v3@@ ; FILE * @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; FILE * @@v10@@ ; char * @@v11@@ ; @@v1@@ = program_name ; if ( @@a1@@ ) { @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = gettext ( String ) ; printf ( @@v3@@ , @@v1@@ ) ; @@v4@@ = stdout ; @@v5@@ = gettext ( String String String String String String String String ) ; fputs_unlocked ( @@v5@@ , @@v4@@ ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; @@v8@@ = stdout ; @@v9@@ = gettext ( String ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = stdout ; @@v11@@ = gettext ( String ) ; fputs_unlocked ( @@v11@@ , @@v10@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
int dirfd ( DIR * @@dirp@@ ) { return dirfd ( @@dirp@@ ) ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
int __xstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _xstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
int __fxstat ( int @@ver@@ , int @@fildes@@ , struct stat * @@stat_buf@@ ) { return _fxstat ( @@ver@@ , @@fildes@@ , @@stat_buf@@ ) ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
int setgid ( __gid_t @@gid@@ ) { return setgid ( @@gid@@ ) ; }
int getc_unlocked ( FILE * @@stream@@ ) { return getc_unlocked ( @@stream@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_2080C8 ; @@v4@@ [ Number ] = qword_2080D0 ; @@v4@@ [ Number ] = qword_2080D8 ; @@v4@@ [ Number ] = qword_2080E0 ; @@v4@@ [ Number ] = qword_2080E8 ; @@v4@@ [ Number ] = qword_2080F0 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
void __fastcall change_identity ( __int64 @@a1@@ ) { char * @@v1@@ ; int * @@v2@@ ; char * @@v3@@ ; int * @@v4@@ ; char * @@v5@@ ; int * @@v6@@ ; * __errno_location ( ) = Number ; if ( initgroups ( * ( const char * * ) @@a1@@ , * ( _DWORD * ) ( @@a1@@ + Number ) ) == Number ) { @@v1@@ = gettext ( String ) ; @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , @@v1@@ ) ; } endgrent ( ) ; if ( setgid ( * ( _DWORD * ) ( @@a1@@ + Number ) ) ) { @@v3@@ = gettext ( String ) ; @@v4@@ = __errno_location ( ) ; error ( Number , * @@v4@@ , @@v3@@ ) ; } if ( setuid ( * ( _DWORD * ) ( @@a1@@ + Number ) ) ) { @@v5@@ = gettext ( String ) ; @@v6@@ = __errno_location ( ) ; error ( Number , * @@v6@@ , @@v5@@ ) ; } }
unsigned __int64 process_signals ( ) { int @@sig@@ ; sigset_t @@oset@@ ; unsigned __int64 @@v3@@ ; @@v3@@ = __readfsqword ( Number ) ; while ( interrupt_signal || stop_signal_count ) { if ( used_color ) restore_default_color ( ) ; fflush_unlocked ( stdout ) ; sigprocmask ( Number , & caught_signals , & @@oset@@ ) ; @@sig@@ = interrupt_signal ; if ( stop_signal_count ) { -- stop_signal_count ; raise ( Number ) ; } else { signal ( interrupt_signal , Number L ) ; raise ( @@sig@@ ) ; } sigprocmask ( Number , & @@oset@@ , Number L ) ; } return __readfsqword ( Number ) ^ @@v3@@ ; }
unsigned __int64 __fastcall validate_tab_stops ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { char * @@v2@@ ; char * @@v3@@ ; unsigned __int64 @@result@@ ; unsigned __int64 @@v5@@ ; unsigned __int64 @@i@@ ; @@v5@@ = Number L ; for ( @@i@@ = Number L ; ; ++ @@i@@ ) { @@result@@ = @@i@@ ; if ( @@i@@ >= @@a2@@ ) break ; if ( ! * ( _QWORD * ) ( Number * @@i@@ + @@a1@@ ) ) { @@v2@@ = gettext ( String ) ; error ( Number , Number , @@v2@@ ) ; } if ( @@v5@@ >= * ( _QWORD * ) ( Number * @@i@@ + @@a1@@ ) ) { @@v3@@ = gettext ( String ) ; error ( Number , Number , @@v3@@ ) ; } @@v5@@ = * ( _QWORD * ) ( Number * @@i@@ + @@a1@@ ) ; } return @@result@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_208028 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
int __fastcall rpl_fseeko ( FILE * @@a1@@ , __off_t @@a2@@ , int @@a3@@ ) { __off_t @@v3@@ ; int @@v4@@ ; int @@result@@ ; if ( @@a1@@ -> _IO_read_end != @@a1@@ -> _IO_read_ptr || @@a1@@ -> _IO_write_ptr != @@a1@@ -> _IO_write_base || @@a1@@ -> _IO_save_base ) { goto LABEL_13 ; } if ( @@a3@@ == Number && @@a2@@ > Number ) @@v3@@ = Number L ; else @@v3@@ = @@a2@@ ; @@v4@@ = fileno ( @@a1@@ ) ; if ( lseek ( @@v4@@ , @@v3@@ , @@a3@@ ) == Number ) return Number ; @@a1@@ -> _flags &= Number ; if ( @@a3@@ == Number && @@a2@@ > Number ) LABEL_13 : @@result@@ = fseeko ( @@a1@@ , @@a2@@ , @@a3@@ ) ; else @@result@@ = Number ; return @@result@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
_BOOL8 __fastcall is_directory ( __int64 @@a1@@ ) { return * ( _DWORD * ) ( @@a1@@ + Number ) == Number || * ( _DWORD * ) ( @@a1@@ + Number ) == Number ; }
char * __fastcall xstrndup ( const char * @@a1@@ , size_t @@a2@@ ) { char * @@v3@@ ; @@v3@@ = strndup ( @@a1@@ , @@a2@@ ) ; if ( ! @@v3@@ ) xalloc_die ( @@a1@@ , @@a2@@ ) ; return @@v3@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
__int64 __fastcall make_link_name ( const char * @@a1@@ , const char * @@a2@@ ) { size_t @@v3@@ ; char * @@dest@@ ; char * @@desta@@ ; __int64 @@n@@ ; if ( ! @@a2@@ ) return Number L ; if ( * @@a2@@ == Number ) return xstrdup ( @@a2@@ ) ; @@dest@@ = strrchr ( @@a1@@ , Number ) ; if ( ! @@dest@@ ) return xstrdup ( @@a2@@ ) ; @@n@@ = @@dest@@ - @@a1@@ + Number ; @@v3@@ = strlen ( @@a2@@ ) ; @@desta@@ = ( char * ) xmalloc ( @@v3@@ + @@n@@ + Number ) ; strncpy ( @@desta@@ , @@a1@@ , @@n@@ ) ; strcpy ( & @@desta@@ [ @@n@@ ] , @@a2@@ ) ; return ( __int64 ) @@desta@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; char * @@v3@@ ; FILE * @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; FILE * @@v10@@ ; char * @@v11@@ ; FILE * @@v12@@ ; char * @@v13@@ ; @@v1@@ = program_name ; if ( @@a1@@ ) { @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = gettext ( String ) ; printf ( @@v3@@ , @@v1@@ ) ; @@v4@@ = stdout ; @@v5@@ = gettext ( String String String ) ; fputs_unlocked ( @@v5@@ , @@v4@@ ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; @@v8@@ = stdout ; @@v9@@ = gettext ( String String String String ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = stdout ; @@v11@@ = gettext ( String ) ; fputs_unlocked ( @@v11@@ , @@v10@@ ) ; @@v12@@ = stdout ; @@v13@@ = gettext ( String ) ; fputs_unlocked ( @@v13@@ , @@v12@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
__int64 __fastcall cmp_size ( _QWORD * @@a1@@ , _QWORD * @@a2@@ , __int64 ( __fastcall * @@a3@@ ( ) ( constchar , constchar ) ) ( _QWORD , _QWORD ) ) { __int64 @@result@@ ; if ( @@a2@@ [ Number ] < @@a1@@ [ Number ] ) LODWORD ( @@result@@ ) = Number ; else LODWORD ( @@result@@ ) = @@a2@@ [ Number ] > @@a1@@ [ Number ] ; if ( ( _DWORD ) @@result@@ ) @@result@@ = ( unsigned int ) @@result@@ ; else @@result@@ = @@a3@@ ( ) ( constchar , constchar ) ( * @@a1@@ , * @@a2@@ ) ; return @@result@@ ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 __fastcall strcmp_df_ctime ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_ctime ( @@a1@@ , @@a2@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) & strcmp ) ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
__int64 __fastcall xstrcoll_df_mtime ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_mtime ( @@a1@@ , @@a2@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) xstrcoll ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
unsigned __int64 __fastcall parse_tab_stops ( unsigned __int8 * @@a1@@ ) { const unsigned __int16 * @@v1@@ ; char @@v2@@ ; __int64 @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; char @@v9@@ ; char @@v10@@ ; unsigned __int64 @@v11@@ ; char * @@s@@ ; size_t @@v13@@ ; void * @@ptr@@ ; unsigned __int64 @@v15@@ ; @@v15@@ = __readfsqword ( Number ) ; @@v9@@ = Number ; @@v10@@ = Number ; while ( * @@a1@@ ) { if ( * @@a1@@ == Number || ( @@v1@@ = * __ctype_b_loc ( ) , ( @@v1@@ [ ( unsigned __int8 ) to_uchar ( * @@a1@@ ) ] & Number ) != Number ) ) { if ( @@v9@@ ) add_tab_stop ( @@v11@@ ) ; @@v9@@ = Number ; } else { if ( ( unsigned int ) ( ( char ) * @@a1@@ - Number ) > Number ) { @@v5@@ = quote ( @@a1@@ ) ; @@v6@@ = gettext ( String ) ; error ( Number , Number , @@v6@@ , @@v5@@ ) ; @@v10@@ = Number ; break ; } if ( @@v9@@ != Number ) { @@v11@@ = Number L ; @@v9@@ = Number ; @@s@@ = ( char * ) @@a1@@ ; } if ( @@v11@@ > Number || ( char ) * @@a1@@ - Number + Number * @@v11@@ < @@v11@@ ) { @@v2@@ = Number ; } else { @@v11@@ = Number * @@v11@@ + ( char ) * @@a1@@ - Number ; @@v2@@ = Number ; } if ( @@v2@@ ) { @@v13@@ = strspn ( @@s@@ , String ) ; @@ptr@@ = ( void * ) xstrndup ( @@s@@ , @@v13@@ ) ; @@v3@@ = quote ( @@ptr@@ ) ; @@v4@@ = gettext ( String ) ; error ( Number , Number , @@v4@@ , @@v3@@ ) ; free ( @@ptr@@ ) ; @@v10@@ = Number ; @@a1@@ = ( unsigned __int8 * ) & @@s@@ [ @@v13@@ - Number ] ; } } ++ @@a1@@ ; } if ( @@v10@@ != Number ) exit ( Number ) ; if ( @@v9@@ ) add_tab_stop ( @@v11@@ ) ; return __readfsqword ( Number ) ^ @@v15@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
__int64 __fastcall strcmp_df_atime ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_atime ( @@a1@@ , @@a2@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) & strcmp ) ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_207038 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall strcmp_df_size ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_size ( @@a1@@ , @@a2@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) & strcmp ) ; }
__int64 __fastcall xnmalloc ( unsigned __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { if ( ! is_mul_ok ( @@a2@@ , @@a1@@ ) ) xalloc_die ( ) ; return xmalloc ( @@a2@@ * @@a1@@ ) ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
__int64 __fastcall xstrcoll_df_name ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_name ( @@a1@@ , @@a2@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) xstrcoll ) ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_207128 ; @@v8@@ [ Number ] = qword_207130 ; @@v8@@ [ Number ] = qword_207138 ; @@v8@@ [ Number ] = qword_207140 ; @@v8@@ [ Number ] = qword_207148 ; @@v8@@ [ Number ] = qword_207150 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v4@@ ; @@v4@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v4@@ >= Number / @@a3@@ ) xalloc_die ( ) ; @@v4@@ += ( @@v4@@ + Number ) >> Number ; } else if ( ! @@v4@@ ) { @@v4@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v4@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v4@@ ) ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
__int64 __fastcall rev_strcmp_df_name ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_name ( @@a2@@ , @@a1@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) & strcmp ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@v3@@ ; @@v3@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v3@@ ) xalloc_die ( @@a1@@ , @@a2@@ ) ; return @@v3@@ ; }
void * __fastcall xzalloc ( size_t @@a1@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@a1@@ ) ; return memset ( @@v1@@ , Number , @@a1@@ ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
__int64 __fastcall rev_xstrcoll_df_extension ( const char * * @@a1@@ , const char * * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_extension ( @@a2@@ , @@a1@@ , xstrcoll ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
__int64 __fastcall xstrcoll_df_version ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_version ( @@a1@@ , @@a2@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
struct tm * localtime ( const time_t * @@timer@@ ) { return localtime ( @@timer@@ ) ; }
int putchar_unlocked ( int @@c@@ ) { return putchar_unlocked ( @@c@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
__int64 print_current_files ( ) { __int64 @@result@@ ; unsigned __int64 @@j@@ ; unsigned __int64 @@i@@ ; @@result@@ = ( unsigned int ) format ; switch ( format ) { case Number : for ( @@i@@ = Number L ; ; ++ @@i@@ ) { @@result@@ = cwd_n_used ; if ( @@i@@ >= cwd_n_used ) break ; print_long_format ( * ( ( _QWORD * ) sorted_file + @@i@@ ) ) ; putchar_unlocked ( Number ) ; ++ dired_pos ; } break ; case Number : for ( @@j@@ = Number L ; ; ++ @@j@@ ) { @@result@@ = cwd_n_used ; if ( @@j@@ >= cwd_n_used ) break ; print_file_name_and_frills ( * ( ( _QWORD * ) sorted_file + @@j@@ ) , Number L ) ; putchar_unlocked ( Number ) ; } break ; case Number : @@result@@ = print_many_per_line ( ) ; break ; case Number : @@result@@ = print_horizontal ( ) ; break ; case Number : @@result@@ = print_with_commas ( ) ; break ; default : return @@result@@ ; } return @@result@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
int isatty ( int @@fd@@ ) { return isatty ( @@fd@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ ) { return xmalloc ( @@a1@@ ) ; }
__int64 long_time_expected_width ( ) { time_t @@timer@@ ; struct tm * @@v2@@ ; __int64 @@v3@@ ; char @@v4@@ [ Number ] ; unsigned __int64 @@v5@@ ; @@v5@@ = __readfsqword ( Number ) ; if ( width_8232 < Number ) { @@timer@@ = Number L ; @@v2@@ = localtime ( & @@timer@@ ) ; if ( @@v2@@ ) { @@v3@@ = align_nstrftime ( ( __int64 ) @@v4@@ , Number L , long_time_format , ( __int64 ) @@v2@@ , Number , Number ) ; if ( @@v3@@ ) width_8232 = mbsnwidth ( @@v4@@ , @@v3@@ , Number L ) ; } if ( width_8232 < Number ) width_8232 = Number ; } return ( unsigned int ) width_8232 ; }
__int64 __fastcall add_tab_stop ( unsigned __int64 @@a1@@ ) { unsigned __int64 @@v1@@ ; unsigned __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@result@@ ; unsigned __int64 @@v5@@ ; if ( first_free_tab ) @@v1@@ = * ( _QWORD * ) ( Number * first_free_tab - Number + tab_list ) ; else @@v1@@ = Number L ; if ( @@v1@@ > @@a1@@ ) @@v2@@ = Number L ; else @@v2@@ = @@a1@@ - @@v1@@ ; @@v5@@ = @@v2@@ ; if ( first_free_tab == n_tabs_allocated ) tab_list = x2nrealloc ( tab_list , & n_tabs_allocated , Number L ) ; @@v3@@ = first_free_tab ++ ; * ( _QWORD * ) ( tab_list + Number * @@v3@@ ) = @@a1@@ ; @@result@@ = max_column_width ; if ( @@v5@@ > max_column_width ) { @@result@@ = @@v5@@ ; max_column_width = @@v5@@ ; } return @@result@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v4@@ ; @@v4@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v4@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ ) ; @@v4@@ += ( @@v4@@ + Number ) >> Number ; } else if ( ! @@v4@@ ) { @@v4@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v4@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v4@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v3@@ ; @@v3@@ = malloc ( @@a1@@ ) ; if ( ! @@v3@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ ) ; return @@v3@@ ; }
int __lxstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _lxstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
size_t __fastcall format_user_or_group_width ( __int64 @@a1@@ , __int64 @@a2@@ ) { size_t @@result@@ ; int @@v3@@ ; char @@s@@ [ Number ] ; unsigned __int64 @@v5@@ ; @@v5@@ = __readfsqword ( Number ) ; if ( @@a1@@ ) { @@v3@@ = gnu_mbswidth ( @@a1@@ , Number L ) ; @@result@@ = Number L ; if ( @@v3@@ >= Number ) @@result@@ = ( unsigned int ) @@v3@@ ; } else { sprintf ( @@s@@ , String , @@a2@@ ) ; @@result@@ = strlen ( @@s@@ ) ; } return @@result@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
const char * __fastcall format_inode ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ ) { const char * @@result@@ ; if ( @@a2@@ <= Number ) __assert_fail ( String , String , Number , String ) ; if ( * ( _BYTE * ) ( @@a3@@ + Number ) && * ( _QWORD * ) ( @@a3@@ + Number ) ) @@result@@ = ( const char * ) umaxtostr ( * ( _QWORD * ) ( @@a3@@ + Number ) , @@a1@@ ) ; else @@result@@ = String ; return @@result@@ ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
struct group * getgrnam ( const char * @@name@@ ) { return getgrnam ( @@name@@ ) ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
int clock_gettime ( clockid_t @@clock_id@@ , struct timespec * @@tp@@ ) { return clock_gettime ( @@clock_id@@ , @@tp@@ ) ; }
__pid_t tcgetpgrp ( int @@fd@@ ) { return tcgetpgrp ( @@fd@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
char * nl_langinfo ( nl_item @@item@@ ) { return nl_langinfo ( @@item@@ ) ; }
int closedir ( DIR * @@dirp@@ ) { return closedir ( @@dirp@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
struct passwd * getpwnam ( const char * @@name@@ ) { return getpwnam ( @@name@@ ) ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
int iswcntrl ( wint_t @@wc@@ ) { return iswcntrl ( @@wc@@ ) ; }
int wcwidth ( wchar_t @@c@@ ) { return wcwidth ( @@c@@ ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
_BYTE * __fastcall strmode ( __int16 @@a1@@ , _BYTE * @@a2@@ ) { char @@v2@@ ; char @@v3@@ ; char @@v4@@ ; char @@v5@@ ; char @@v6@@ ; char @@v7@@ ; char @@v8@@ ; char @@v9@@ ; char @@v10@@ ; _BYTE * @@result@@ ; * @@a2@@ = ftypelet ( @@a1@@ ) ; if ( ( @@a1@@ & Number ) != Number ) @@v2@@ = Number ; else @@v2@@ = Number ; @@a2@@ [ Number ] = @@v2@@ ; if ( ( @@a1@@ & Number ) != Number ) @@v3@@ = Number ; else @@v3@@ = Number ; @@a2@@ [ Number ] = @@v3@@ ; if ( ( @@a1@@ & Number ) != Number ) { if ( ( @@a1@@ & Number ) != Number ) @@v4@@ = Number ; else @@v4@@ = Number ; } else if ( ( @@a1@@ & Number ) != Number ) { @@v4@@ = Number ; } else { @@v4@@ = Number ; } @@a2@@ [ Number ] = @@v4@@ ; if ( ( @@a1@@ & Number ) != Number ) @@v5@@ = Number ; else @@v5@@ = Number ; @@a2@@ [ Number ] = @@v5@@ ; if ( ( @@a1@@ & Number ) != Number ) @@v6@@ = Number ; else @@v6@@ = Number ; @@a2@@ [ Number ] = @@v6@@ ; if ( ( @@a1@@ & Number ) != Number ) { if ( ( @@a1@@ & Number ) != Number ) @@v7@@ = Number ; else @@v7@@ = Number ; } else if ( ( @@a1@@ & Number ) != Number ) { @@v7@@ = Number ; } else { @@v7@@ = Number ; } @@a2@@ [ Number ] = @@v7@@ ; if ( ( @@a1@@ & Number ) != Number ) @@v8@@ = Number ; else @@v8@@ = Number ; @@a2@@ [ Number ] = @@v8@@ ; if ( ( @@a1@@ & Number ) != Number ) @@v9@@ = Number ; else @@v9@@ = Number ; @@a2@@ [ Number ] = @@v9@@ ; if ( ( @@a1@@ & Number ) != Number ) { if ( ( @@a1@@ & Number ) != Number ) @@v10@@ = Number ; else @@v10@@ = Number ; } else if ( ( @@a1@@ & Number ) != Number ) { @@v10@@ = Number ; } else { @@v10@@ = Number ; } @@a2@@ [ Number ] = @@v10@@ ; @@a2@@ [ Number ] = Number ; @@result@@ = @@a2@@ + Number ; @@a2@@ [ Number ] = Number ; return @@result@@ ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
DIR * opendir ( const char * @@name@@ ) { return opendir ( @@name@@ ) ; }
time_t mktime ( struct tm * @@tp@@ ) { return mktime ( @@tp@@ ) ; }
unsigned int __fastcall dired_dump_obstack ( const char * @@a1@@ , __int64 @@a2@@ ) { unsigned int @@result@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@v4@@ ; __int64 @@v5@@ ; @@result@@ = ( unsigned int ) ( * ( _DWORD * ) ( @@a2@@ + Number ) - * ( _DWORD * ) ( @@a2@@ + Number ) ) >> Number ; @@v4@@ = @@result@@ ; if ( @@result@@ ) { @@v5@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( @@v5@@ == * ( _QWORD * ) ( @@a2@@ + Number ) ) * ( _BYTE * ) ( @@a2@@ + Number ) |= Number ; * ( _QWORD * ) ( @@a2@@ + Number ) = ( * ( int * ) ( @@a2@@ + Number ) + * ( _QWORD * ) ( @@a2@@ + Number ) ) & ~ * ( _DWORD * ) ( @@a2@@ + Number ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) - * ( _QWORD * ) ( @@a2@@ + Number ) > * ( _QWORD * ) ( @@a2@@ + Number ) - * ( _QWORD * ) ( @@a2@@ + Number ) ) * ( _QWORD * ) ( @@a2@@ + Number ) = * ( _QWORD * ) ( @@a2@@ + Number ) ; * ( _QWORD * ) ( @@a2@@ + Number ) = * ( _QWORD * ) ( @@a2@@ + Number ) ; fputs_unlocked ( @@a1@@ , stdout ) ; for ( @@i@@ = Number L ; @@i@@ < @@v4@@ ; ++ @@i@@ ) printf ( String , * ( _QWORD * ) ( Number * @@i@@ + @@v5@@ ) ) ; @@result@@ = putchar_unlocked ( Number ) ; } return @@result@@ ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
struct group * getgrgid ( __gid_t @@gid@@ ) { return getgrgid ( @@gid@@ ) ; }
unsigned __int64 __fastcall hash_string ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ ) { unsigned __int64 @@v4@@ ; @@v4@@ = Number L ; while ( * @@a1@@ ) @@v4@@ = ( Number * @@v4@@ + ( unsigned __int8 ) * @@a1@@ ++ ) % @@a2@@ ; return @@v4@@ ; }
void free ( void * @@ptr@@ ) { __imp_free ( @@ptr@@ ) ; }
int sigemptyset ( sigset_t * @@set@@ ) { return sigemptyset ( @@set@@ ) ; }
unsigned __int64 __fastcall raw_hasher ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return rotr_sz ( @@a1@@ , Number ) % @@a2@@ ; }
__int64 __fastcall cmp_ctime ( _QWORD * @@a1@@ , _QWORD * @@a2@@ , __int64 ( __fastcall * @@a3@@ ( ) ( constchar , constchar ) ) ( _QWORD , _QWORD ) ) { __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@result@@ ; unsigned int @@v10@@ ; @@v3@@ = get_stat_ctime ( ( __int64 ) ( @@a1@@ + Number ) ) ; @@v5@@ = @@v4@@ ; @@v6@@ = get_stat_ctime ( ( __int64 ) ( @@a2@@ + Number ) ) ; @@v10@@ = timespec_cmp ( @@v6@@ , @@v7@@ , @@v3@@ , @@v5@@ ) ; if ( @@v10@@ ) @@result@@ = @@v10@@ ; else @@result@@ = @@a3@@ ( ) ( constchar , constchar ) ( * @@a1@@ , * @@a2@@ ) ; return @@result@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_207038 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
__int64 __fastcall bad_cast ( __int64 @@a1@@ ) { return @@a1@@ ; }
struct dirent * readdir ( DIR * @@dirp@@ ) { return readdir ( @@dirp@@ ) ; }
__int64 __fastcall check_tuning ( __int64 @@a1@@ ) { __int64 @@v2@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( ( _UNKNOWN * ) @@v2@@ == & default_tuning ) return Number L ; if ( * ( float * ) ( @@v2@@ + Number ) > Number && ( float ) ( Number - Number ) > * ( float * ) ( @@v2@@ + Number ) && * ( float * ) ( @@v2@@ + Number ) > ( float ) ( Number + Number ) && * ( float * ) @@v2@@ >= Number && * ( float * ) ( @@v2@@ + Number ) > ( float ) ( * ( float * ) @@v2@@ + Number ) && * ( float * ) ( @@v2@@ + Number ) <= Number && * ( float * ) ( @@v2@@ + Number ) > ( float ) ( * ( float * ) @@v2@@ + Number ) ) { return Number L ; } * ( _QWORD * ) ( @@a1@@ + Number ) = & default_tuning ; return Number L ; }
__int64 __fastcall cmp_extension ( const char * * @@a1@@ , const char * * @@a2@@ , __int64 ( __fastcall * @@a3@@ ( ) ( constchar , constchar ) ) ( const char * , const char * ) ) { const char * @@v3@@ ; const char * @@v4@@ ; __int64 @@result@@ ; unsigned int @@v7@@ ; char * @@v8@@ ; char * @@v9@@ ; @@v8@@ = strrchr ( * @@a1@@ , Number ) ; @@v9@@ = strrchr ( * @@a2@@ , Number ) ; if ( @@v9@@ ) @@v3@@ = @@v9@@ ; else @@v3@@ = & off_16E97 [ Number ] ; if ( @@v8@@ ) @@v4@@ = @@v8@@ ; else @@v4@@ = & off_16E97 [ Number ] ; @@v7@@ = @@a3@@ ( ) ( constchar , constchar ) ( @@v4@@ , @@v3@@ ) ; if ( @@v7@@ ) @@result@@ = @@v7@@ ; else @@result@@ = @@a3@@ ( ) ( constchar , constchar ) ( * @@a1@@ , * @@a2@@ ) ; return @@result@@ ; }
unsigned int gnu_dev_minor ( unsigned __int64 @@dev@@ ) { return gnu_dev_minor ( @@dev@@ ) ; }
struct passwd * getpwuid ( __uid_t @@uid@@ ) { return getpwuid ( @@uid@@ ) ; }
__int64 __fastcall get_stat_atime ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
__int64 __fastcall get_stat_mtime ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
int _setjmp ( struct __jmp_buf_tag @@env@@ ( ( orgarrdim ( Number , Number ) ) ) [ Number ] ) { return setjmp ( @@env@@ ( ( orgarrdim ( Number , Number ) ) ) ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 __fastcall strcmp_df_mtime ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_mtime ( @@a1@@ , @@a2@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) & strcmp ) ; }
int putchar_unlocked ( int @@c@@ ) { return putchar_unlocked ( @@c@@ ) ; }
__int64 __fastcall get_stat_ctime ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
int tolower ( int @@c@@ ) { return tolower ( @@c@@ ) ; }
__int64 abmon_init ( ) { char * @@v0@@ ; __int64 @@v2@@ ; int @@i@@ ; unsigned __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; unsigned __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; required_mon_width = Number L ; do { @@v5@@ = required_mon_width ; required_mon_width = Number L ; for ( @@i@@ = Number ; @@i@@ <= Number ; ++ @@i@@ ) { @@v4@@ = @@v5@@ ; @@v0@@ = nl_langinfo ( @@i@@ + Number ) ; @@v6@@ = mbsalign ( @@v0@@ , ( char * ) & abmon + Number * @@i@@ , Number L , & @@v4@@ , Number L , Number L ) ; if ( @@v6@@ == Number || @@v6@@ > Number ) { required_mon_width = Number L ; return Number L ; } @@v2@@ = required_mon_width ; if ( @@v4@@ >= required_mon_width ) @@v2@@ = @@v4@@ ; required_mon_width = @@v2@@ ; } } while ( @@v5@@ > required_mon_width ) ; return required_mon_width ; }
void __fastcall hash_free ( __int64 @@a1@@ ) { _QWORD * @@i@@ ; _QWORD * @@j@@ ; _QWORD * @@ptr@@ ; _QWORD * @@ptra@@ ; _QWORD * @@ptrb@@ ; _QWORD * @@v6@@ ; _QWORD * @@v7@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) && * ( _QWORD * ) ( @@a1@@ + Number ) ) { for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@ptr@@ = @@i@@ ; @@ptr@@ ; @@ptr@@ = ( _QWORD * ) @@ptr@@ [ Number ] ) { ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@ptr@@ ) ; } } } } for ( @@j@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@j@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@j@@ += Number ) { for ( @@ptra@@ = ( _QWORD * ) @@j@@ [ Number ] ; @@ptra@@ ; @@ptra@@ = @@v6@@ ) { @@v6@@ = ( _QWORD * ) @@ptra@@ [ Number ] ; free ( @@ptra@@ ) ; } } for ( @@ptrb@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; @@ptrb@@ ; @@ptrb@@ = @@v7@@ ) { @@v7@@ = ( _QWORD * ) @@ptrb@@ [ Number ] ; free ( @@ptrb@@ ) ; } free ( * ( void * * ) @@a1@@ ) ; free ( ( void * ) @@a1@@ ) ; }
unsigned int gnu_dev_major ( unsigned __int64 @@dev@@ ) { return gnu_dev_major ( @@dev@@ ) ; }
_BOOL8 __fastcall dev_ino_compare ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { return * @@a1@@ == * @@a2@@ && @@a1@@ [ Number ] == @@a2@@ [ Number ] ; }
__int64 __fastcall xstrcoll_df_size ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_size ( @@a1@@ , @@a2@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) xstrcoll ) ; }
_QWORD * __fastcall add_ignore_pattern ( __int64 @@a1@@ ) { _QWORD * @@result@@ ; @@result@@ = ( _QWORD * ) xmalloc ( Number L ) ; * @@result@@ = @@a1@@ ; @@result@@ [ Number ] = ignore_patterns ; ignore_patterns = ( __int64 ) @@result@@ ; return @@result@@ ; }
int fflush_unlocked ( FILE * @@stream@@ ) { return fflush_unlocked ( @@stream@@ ) ; }
__int64 __fastcall strcmp_df_name ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_name ( @@a1@@ , @@a2@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) & strcmp ) ; }
__int64 __fastcall unsigned_file_size ( __int64 @@a1@@ ) { return @@a1@@ ; }
_BOOL8 __fastcall is_colored ( unsigned int @@a1@@ ) { __int64 @@v3@@ ; char * @@s1@@ ; @@v3@@ = * ( ( _QWORD * ) & color_indicator + Number * @@a1@@ ) ; @@s1@@ = ( char * ) * ( & off_21F088 + Number * @@a1@@ ) ; return @@v3@@ && ( @@v3@@ != Number || * @@s1@@ != Number ) && ( @@v3@@ != Number || strncmp ( @@s1@@ , off_16E97 , Number ) ) ; }
void * malloc ( size_t @@size@@ ) { return __imp_malloc ( @@size@@ ) ; }
__int64 __fastcall hash_rehash ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; unsigned __int64 @@nmemb@@ ; void * @@v4@@ ; __int64 @@v5@@ ; unsigned __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; __int64 @@v12@@ ; __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; @@v14@@ = __readfsqword ( Number ) ; @@nmemb@@ = compute_bucket_size ( @@a2@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ; if ( ! @@nmemb@@ ) return Number L ; if ( @@nmemb@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; @@v4@@ = calloc ( @@nmemb@@ , Number ) ; if ( ! @@v4@@ ) return Number L ; @@v6@@ = @@nmemb@@ ; @@v5@@ = ( __int64 ) @@v4@@ + Number * @@nmemb@@ ; @@v7@@ = Number L ; @@v8@@ = Number L ; @@v9@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v10@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v11@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v12@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v13@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( ( unsigned __int8 ) transfer_entries ( ( __int64 ) & @@v4@@ , @@a1@@ , Number ) ) { free ( * ( void * * ) @@a1@@ ) ; * ( _QWORD * ) @@a1@@ = @@v4@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v5@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v6@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v7@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v13@@ ; @@result@@ = Number L ; } else { * ( _QWORD * ) ( @@a1@@ + Number ) = @@v13@@ ; if ( ( unsigned __int8 ) transfer_entries ( @@a1@@ , ( __int64 ) & @@v4@@ , Number ) != Number || ( unsigned __int8 ) transfer_entries ( @@a1@@ , ( __int64 ) & @@v4@@ , Number ) != Number ) { abort ( ) ; } free ( @@v4@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall file_failure ( unsigned __int8 @@a1@@ , const char * @@a2@@ , __int64 @@a3@@ ) { __int64 @@v3@@ ; int * @@v4@@ ; @@v3@@ = quotearg_colon ( @@a3@@ ) ; @@v4@@ = __errno_location ( ) ; error ( Number , * @@v4@@ , @@a2@@ , @@v3@@ ) ; return set_exit_status ( @@a1@@ ) ; }
__int64 __fastcall strcmp_df_extension ( const char * * @@a1@@ , const char * * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_extension ( @@a1@@ , @@a2@@ , ( __int64 ( __fastcall * ) ( const char * , const char * ) ) & strcmp ) ; }
_BOOL8 __fastcall dot_or_dotdot ( _BYTE * @@a1@@ ) { __int64 @@v1@@ ; char @@v4@@ ; if ( * @@a1@@ != Number ) return Number L ; if ( @@a1@@ [ Number ] == Number ) @@v1@@ = Number L ; else @@v1@@ = Number L ; @@v4@@ = @@a1@@ [ @@v1@@ ] ; return ! @@v4@@ || @@v4@@ == Number ; }
__int64 __fastcall get_link_name ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@result@@ ; char * @@v4@@ ; * ( _QWORD * ) ( @@a2@@ + Number ) = areadlink_with_size ( @@a1@@ , * ( _QWORD * ) ( @@a2@@ + Number ) ) ; @@result@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( ! @@result@@ ) { @@v4@@ = gettext ( String ) ; @@result@@ = file_failure ( @@a3@@ , @@v4@@ , @@a1@@ ) ; } return @@result@@ ; }
__int64 __fastcall human_options ( char * @@a1@@ , int * @@a2@@ , _QWORD * @@a3@@ ) { unsigned int @@v5@@ ; @@v5@@ = humblock ( @@a1@@ , @@a3@@ , @@a2@@ ) ; if ( ! * @@a3@@ ) { * @@a3@@ = default_block_size ( ) ; @@v5@@ = Number ; } return @@v5@@ ; }
__int64 __fastcall patterns_match ( __int64 @@a1@@ , const char * @@a2@@ ) { while ( @@a1@@ ) { if ( ! fnmatch ( * ( const char * * ) @@a1@@ , @@a2@@ , Number ) ) return Number L ; @@a1@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; } return Number L ; }
unsigned __int64 __fastcall dev_ino_hash ( _QWORD * @@a1@@ , unsigned __int64 @@a2@@ ) { return * @@a1@@ % @@a2@@ ; }
__int64 __fastcall rev_xstrcoll_df_version ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_version ( @@a2@@ , @@a1@@ ) ; }
void __fastcall dev_ino_free ( void * @@a1@@ ) { free ( @@a1@@ ) ; }
__int64 __fastcall extract_dirs_from_files ( __int64 @@a1@@ , char @@a2@@ ) { __int64 @@result@@ ; __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 * @@v8@@ ; void * @@ptr@@ ; if ( @@a1@@ && active_dir_set ) queue_directory ( Number L , @@a1@@ , Number ) ; @@v4@@ = cwd_n_used ; while ( @@v4@@ -- ) { @@v8@@ = ( __int64 * ) * ( ( _QWORD * ) sorted_file + @@v4@@ ) ; if ( is_directory ( ( __int64 ) @@v8@@ ) && ( ! @@a1@@ || ! basename_is_dot_or_dotdot ( * @@v8@@ ) ) ) { if ( @@a1@@ && * ( _BYTE * ) * @@v8@@ != Number ) { @@ptr@@ = ( void * ) file_name_concat ( @@a1@@ , * @@v8@@ , Number L ) ; queue_directory ( ( __int64 ) @@ptr@@ , @@v8@@ [ Number ] , @@a2@@ ) ; free ( @@ptr@@ ) ; } else { queue_directory ( * @@v8@@ , @@v8@@ [ Number ] , @@a2@@ ) ; } if ( * ( ( _DWORD * ) @@v8@@ + Number ) == Number ) free ( ( void * ) * @@v8@@ ) ; } } @@v5@@ = Number L ; @@v6@@ = Number L ; while ( @@v5@@ < cwd_n_used ) { @@v7@@ = * ( ( _QWORD * ) sorted_file + @@v5@@ ) ; * ( ( _QWORD * ) sorted_file + @@v6@@ ) = @@v7@@ ; @@v6@@ += * ( _DWORD * ) ( @@v7@@ + Number ) != Number ; ++ @@v5@@ ; } @@result@@ = @@v6@@ ; cwd_n_used = @@v6@@ ; return @@result@@ ; }
__int64 clear_files ( ) { __int64 @@result@@ ; unsigned __int64 @@i@@ ; void * * @@v2@@ ; for ( @@i@@ = Number L ; ; ++ @@i@@ ) { @@result@@ = cwd_n_used ; if ( @@i@@ >= cwd_n_used ) break ; @@v2@@ = ( void * * ) * ( ( _QWORD * ) sorted_file + @@i@@ ) ; free ( * @@v2@@ ) ; free ( @@v2@@ [ Number ] ) ; if ( @@v2@@ [ Number ] != & UNKNOWN_SECURITY_CONTEXT ) freecon ( ) ; } cwd_n_used = Number L ; any_has_acl = Number ; inode_number_width = Number ; block_size_width = Number ; nlink_width = Number ; owner_width = Number ; group_width = Number ; author_width = Number ; scontext_width = Number ; major_device_number_width = Number ; minor_device_number_width = Number ; file_size_width = Number ; return @@result@@ ; }
__int64 __fastcall getgroup ( __gid_t @@a1@@ ) { const char * @@v1@@ ; size_t @@v2@@ ; __int64 @@result@@ ; __int64 @@i@@ ; __int64 @@v5@@ ; struct group * @@v6@@ ; char * @@s@@ ; @@v5@@ = Number L ; for ( @@i@@ = group_alist ; @@i@@ ; @@i@@ = * ( _QWORD * ) ( @@i@@ + Number ) ) { if ( @@a1@@ == * ( _DWORD * ) @@i@@ ) { @@v5@@ = @@i@@ ; break ; } } if ( ! @@v5@@ ) { @@v6@@ = getgrgid ( @@a1@@ ) ; if ( @@v6@@ ) @@v1@@ = @@v6@@ -> gr_name ; else @@v1@@ = ( const char * ) & unk_19CC0 ; @@s@@ = ( char * ) @@v1@@ ; @@v2@@ = strlen ( @@v1@@ ) ; @@v5@@ = xmalloc ( @@v2@@ + Number ) ; * ( _DWORD * ) @@v5@@ = @@a1@@ ; strcpy ( ( char * ) ( @@v5@@ + Number ) , @@s@@ ) ; * ( _QWORD * ) ( @@v5@@ + Number ) = group_alist ; group_alist = @@v5@@ ; } if ( * ( _BYTE * ) ( @@v5@@ + Number ) ) @@result@@ = @@v5@@ + Number ; else @@result@@ = Number L ; return @@result@@ ; }
_BOOL8 __fastcall visit_dir ( __int64 @@a1@@ , __int64 @@a2@@ ) { _QWORD * @@ptr@@ ; __int64 @@v4@@ ; @@ptr@@ = ( _QWORD * ) xmalloc ( Number L ) ; * @@ptr@@ = @@a2@@ ; @@ptr@@ [ Number ] = @@a1@@ ; @@v4@@ = hash_insert ( active_dir_set , @@ptr@@ ) ; if ( ! @@v4@@ ) xalloc_die ( ) ; if ( ( _QWORD * ) @@v4@@ != @@ptr@@ ) free ( @@ptr@@ ) ; return @@v4@@ != ( _QWORD ) @@ptr@@ ; }
__int64 __fastcall align_nstrftime ( __int64 @@a1@@ , __int64 @@a2@@ , const char * @@a3@@ , __int64 @@a4@@ , unsigned int @@a5@@ , unsigned int @@a6@@ ) { char * @@v6@@ ; char * @@haystack@@ ; char * @@v12@@ ; char * @@v13@@ ; char * @@dest@@ ; char @@v15@@ [ Number ] ; unsigned __int64 @@v16@@ ; @@haystack@@ = ( char * ) @@a3@@ ; @@v16@@ = __readfsqword ( Number ) ; @@v12@@ = ( char * ) @@a3@@ ; if ( required_mon_width ) { @@v13@@ = strstr ( @@a3@@ , needle ) ; if ( @@v13@@ ) { if ( strlen ( @@haystack@@ ) <= Number ) { @@v12@@ = @@v15@@ ; @@v6@@ = ( char * ) mempcpy ( @@v15@@ , @@haystack@@ , @@v13@@ - @@haystack@@ ) ; @@dest@@ = stpcpy ( @@v6@@ , & abmon [ Number * * ( int * ) ( @@a4@@ + Number ) ] ) ; strcpy ( @@dest@@ , @@v13@@ + Number ) ; } } } return nstrftime ( @@a1@@ , @@a2@@ , @@v12@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
__int64 __fastcall rev_strcmp_df_ctime ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_ctime ( @@a2@@ , @@a1@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) & strcmp ) ; }
__int64 __fastcall cmp_mtime ( _QWORD * @@a1@@ , _QWORD * @@a2@@ , __int64 ( __fastcall * @@a3@@ ( ) ( constchar , constchar ) ) ( _QWORD , _QWORD ) ) { __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@result@@ ; unsigned int @@v10@@ ; @@v3@@ = get_stat_mtime ( ( __int64 ) ( @@a1@@ + Number ) ) ; @@v5@@ = @@v4@@ ; @@v6@@ = get_stat_mtime ( ( __int64 ) ( @@a2@@ + Number ) ) ; @@v10@@ = timespec_cmp ( @@v6@@ , @@v7@@ , @@v3@@ , @@v5@@ ) ; if ( @@v10@@ ) @@result@@ = @@v10@@ ; else @@result@@ = @@a3@@ ( ) ( constchar , constchar ) ( * @@a1@@ , * @@a2@@ ) ; return @@result@@ ; }
__int64 __fastcall imaxtostr ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = @@a1@@ ; @@v4@@ = @@a2@@ + Number ; * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; if ( @@a1@@ >= Number ) { do { * ( _BYTE * ) -- @@v4@@ = ( char ) @@v3@@ % Number + Number ; @@v3@@ /= Number L ; } while ( @@v3@@ ) ; } else { do { * ( _BYTE * ) -- @@v4@@ = Number - ( char ) @@v3@@ % Number ; @@v3@@ /= Number L ; } while ( @@v3@@ ) ; * ( _BYTE * ) -- @@v4@@ = Number ; } return @@v4@@ ; }
__int64 __fastcall queue_directory ( __int64 @@a1@@ , __int64 @@a2@@ , char @@a3@@ ) { __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@result@@ ; __int64 @@v7@@ ; @@v7@@ = xmalloc ( Number L ) ; if ( @@a2@@ ) @@v3@@ = xstrdup ( @@a2@@ ) ; else @@v3@@ = Number L ; * ( _QWORD * ) ( @@v7@@ + Number ) = @@v3@@ ; if ( @@a1@@ ) @@v4@@ = xstrdup ( @@a1@@ ) ; else @@v4@@ = Number L ; * ( _QWORD * ) @@v7@@ = @@v4@@ ; * ( _BYTE * ) ( @@v7@@ + Number ) = @@a3@@ ; * ( _QWORD * ) ( @@v7@@ + Number ) = pending_dirs ; @@result@@ = @@v7@@ ; pending_dirs = @@v7@@ ; return @@result@@ ; }
__int64 __fastcall rev_strcmp_df_mtime ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_mtime ( @@a2@@ , @@a1@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) & strcmp ) ; }
__int64 __fastcall format_user_or_group ( const char * @@a1@@ , __int64 @@a2@@ , int @@a3@@ ) { int @@v3@@ ; __int64 @@result@@ ; int @@v7@@ ; int @@v8@@ ; size_t @@v9@@ ; if ( @@a1@@ ) { @@v8@@ = @@a3@@ - gnu_mbswidth ( @@a1@@ , Number L ) ; @@v3@@ = Number ; if ( @@v8@@ >= Number ) @@v3@@ = @@v8@@ ; @@v7@@ = @@v3@@ ; fputs_unlocked ( @@a1@@ , stdout ) ; @@v9@@ = strlen ( @@a1@@ ) + @@v7@@ ; do putchar_unlocked ( Number ) ; while ( @@v7@@ -- ) ; } else { printf ( String , @@a3@@ , @@a2@@ ) ; @@v9@@ = @@a3@@ ; } @@result@@ = dired_pos + @@v9@@ + Number ; dired_pos = @@result@@ ; return @@result@@ ; }
__int64 __fastcall cmp_name ( _QWORD * @@a1@@ , _QWORD * @@a2@@ , __int64 ( __fastcall * @@a3@@ ( ) ( constchar , constchar ) ) ( _QWORD , _QWORD ) ) { return @@a3@@ ( ) ( constchar , constchar ) ( * @@a1@@ , * @@a2@@ ) ; }
void __fastcall mpsort ( __int64 * @@a1@@ , unsigned __int64 @@a2@@ , __int64 ( __fastcall * @@a3@@ ) ( __int64 , __int64 ) ) { mpsort_with_tmp ( @@a1@@ , @@a2@@ , & @@a1@@ [ @@a2@@ ] , @@a3@@ ) ; }
_BOOL8 __fastcall basename_is_dot_or_dotdot ( __int64 @@a1@@ ) { _BYTE * @@v2@@ ; @@v2@@ = ( _BYTE * ) last_component ( @@a1@@ ) ; return dot_or_dotdot ( @@v2@@ ) ; }
__int64 __fastcall rev_xstrcoll_df_atime ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_atime ( @@a2@@ , @@a1@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) xstrcoll ) ; }
size_t __fastcall format_group_width ( unsigned int @@a1@@ ) { __int64 @@v1@@ ; if ( numeric_ids ) @@v1@@ = Number L ; else @@v1@@ = getgroup ( @@a1@@ ) ; return format_user_or_group_width ( @@v1@@ , @@a1@@ ) ; }
__int64 __fastcall xstrcoll_df_ctime ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_ctime ( @@a1@@ , @@a2@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) xstrcoll ) ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
__int64 __fastcall rev_xstrcoll_df_size ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_size ( @@a2@@ , @@a1@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) xstrcoll ) ; }
__int64 __fastcall cmp_atime ( _QWORD * @@a1@@ , _QWORD * @@a2@@ , __int64 ( __fastcall * @@a3@@ ( ) ( constchar , constchar ) ) ( _QWORD , _QWORD ) ) { __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@result@@ ; unsigned int @@v10@@ ; @@v3@@ = get_stat_atime ( ( __int64 ) ( @@a1@@ + Number ) ) ; @@v5@@ = @@v4@@ ; @@v6@@ = get_stat_atime ( ( __int64 ) ( @@a2@@ + Number ) ) ; @@v10@@ = timespec_cmp ( @@v6@@ , @@v7@@ , @@v3@@ , @@v5@@ ) ; if ( @@v10@@ ) @@result@@ = @@v10@@ ; else @@result@@ = @@a3@@ ( ) ( constchar , constchar ) ( * @@a1@@ , * @@a2@@ ) ; return @@result@@ ; }
__int64 __fastcall xstrcoll_df_atime ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_atime ( @@a1@@ , @@a2@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) xstrcoll ) ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
__int64 __fastcall rev_xstrcoll_df_name ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_name ( @@a2@@ , @@a1@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) xstrcoll ) ; }
size_t __fastcall print_name_with_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , struct obstack * @@a3@@ , unsigned __int64 @@a4@@ ) { __int64 @@v4@@ ; bool @@v5@@ ; bool @@v9@@ ; __int64 @@v10@@ ; size_t @@v11@@ ; if ( @@a2@@ ) @@v4@@ = @@a1@@ [ Number ] ; else @@v4@@ = * @@a1@@ ; @@v10@@ = @@v4@@ ; @@v5@@ = print_with_color && ( unsigned __int8 ) print_color_indicator ( @@a1@@ , @@a2@@ ) ; @@v9@@ = @@v5@@ ; if ( @@a3@@ && dired ) { if ( @@a3@@ -> next_free + Number > @@a3@@ -> chunk_limit ) _obstack_newchunk ( @@a3@@ , Number ) ; memcpy ( @@a3@@ -> next_free , & dired_pos , Number ) ; @@a3@@ -> next_free += Number ; } @@v11@@ = quote_name ( stdout , @@v10@@ , filename_quoting_options , Number L ) ; dired_pos += @@v11@@ ; if ( @@a3@@ && dired ) { if ( @@a3@@ -> next_free + Number > @@a3@@ -> chunk_limit ) _obstack_newchunk ( @@a3@@ , Number ) ; memcpy ( @@a3@@ -> next_free , & dired_pos , Number ) ; @@a3@@ -> next_free += Number ; } if ( @@v9@@ ) { process_signals ( ) ; prep_non_filename_text ( ) ; if ( @@a4@@ / line_length != ( @@a4@@ + @@v11@@ - Number ) / line_length ) put_indicator ( & unk_21F1F0 ) ; } return @@v11@@ ; }
__int64 __fastcall rev_xstrcoll_df_ctime ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_ctime ( @@a2@@ , @@a1@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) xstrcoll ) ; }
__int64 __fastcall rev_strcmp_df_atime ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_atime ( @@a2@@ , @@a1@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) & strcmp ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
__int64 __fastcall xstrcoll_df_extension ( const char * * @@a1@@ , const char * * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_extension ( @@a1@@ , @@a2@@ , xstrcoll ) ; }
__int64 __fastcall rev_xstrcoll_df_mtime ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_mtime ( @@a2@@ , @@a1@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) xstrcoll ) ; }
size_t __fastcall print_file_name_and_frills ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { const char * @@v2@@ ; int @@v3@@ ; const char * @@v4@@ ; int @@v5@@ ; int @@v6@@ ; size_t @@v8@@ ; char @@v9@@ [ Number ] ; unsigned __int64 @@v10@@ ; @@v10@@ = __readfsqword ( Number ) ; if ( print_inode ) { @@v2@@ = format_inode ( ( __int64 ) @@v9@@ , Number , @@a1@@ ) ; if ( format == Number ) @@v3@@ = Number ; else @@v3@@ = inode_number_width ; printf ( String , @@v3@@ , @@v2@@ ) ; } if ( print_block_size ) { if ( * ( _BYTE * ) ( @@a1@@ + Number ) != Number ) @@v4@@ = String ; else @@v4@@ = ( const char * ) human_readable ( * ( _QWORD * ) ( @@a1@@ + Number ) , @@v9@@ , ( unsigned int ) human_output_opts , Number L , output_block_size ) ; if ( format == Number ) @@v5@@ = Number ; else @@v5@@ = block_size_width ; printf ( String , @@v5@@ , @@v4@@ ) ; } if ( print_scontext ) { if ( format == Number ) @@v6@@ = Number ; else @@v6@@ = scontext_width ; printf ( String , @@v6@@ , * ( const char * * ) ( @@a1@@ + Number ) ) ; } @@v8@@ = print_name_with_quoting ( ( __int64 * ) @@a1@@ , Number , Number L , @@a2@@ ) ; if ( indicator_style ) @@v8@@ += ( unsigned __int8 ) print_type_indicator ( * ( unsigned __int8 * ) ( @@a1@@ + Number ) , * ( unsigned int * ) ( @@a1@@ + Number ) , * ( unsigned int * ) ( @@a1@@ + Number ) ) ; return @@v8@@ ; }
__int64 __fastcall rev_strcmp_df_size ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_size ( @@a2@@ , @@a1@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) & strcmp ) ; }
__int64 __fastcall rev_strcmp_df_extension ( const char * * @@a1@@ , const char * * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_extension ( @@a2@@ , @@a1@@ , ( __int64 ( __fastcall * ) ( const char * , const char * ) ) & strcmp ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
char * __fastcall areadlink_with_size ( const char * @@a1@@ , unsigned __int64 @@a2@@ ) { __int64 @@v2@@ ; char * @@i@@ ; int @@v5@@ ; size_t @@size@@ ; char * @@buf@@ ; ssize_t @@v8@@ ; if ( @@a2@@ >= Number ) @@v2@@ = Number L ; else @@v2@@ = @@a2@@ + Number ; @@size@@ = @@v2@@ ; LABEL_5 : for ( @@i@@ = ( char * ) malloc ( @@size@@ ) ; ; @@i@@ = ( char * ) malloc ( Number ) ) { @@buf@@ = @@i@@ ; if ( ! @@i@@ ) return Number L ; @@v8@@ = readlink ( @@a1@@ , @@i@@ , @@size@@ ) ; if ( @@v8@@ < Number && * __errno_location ( ) != Number ) { @@v5@@ = * __errno_location ( ) ; free ( @@buf@@ ) ; * __errno_location ( ) = @@v5@@ ; return Number L ; } if ( @@v8@@ < @@size@@ ) { @@buf@@ [ @@v8@@ ] = Number ; return @@buf@@ ; } free ( @@buf@@ ) ; if ( @@size@@ <= Number ) { @@size@@ *= Number L ; goto LABEL_5 ; } if ( @@size@@ > Number ) break ; @@size@@ = Number ; } * __errno_location ( ) = Number ; return Number L ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
__int64 __fastcall order ( unsigned __int8 @@a1@@ ) { if ( ( unsigned __int8 ) c_isdigit ( @@a1@@ ) ) return Number L ; if ( ( unsigned __int8 ) c_isalpha ( @@a1@@ ) ) return @@a1@@ ; if ( @@a1@@ == Number ) return Number ; return ( unsigned int ) @@a1@@ + Number ; }
__int64 __fastcall get_type_indicator ( char @@a1@@ , __int16 @@a2@@ , int @@a3@@ ) { bool @@v3@@ ; bool @@v4@@ ; bool @@v5@@ ; bool @@v6@@ ; bool @@v7@@ ; bool @@v8@@ ; unsigned __int8 @@v10@@ ; if ( @@a1@@ ) @@v3@@ = ( @@a2@@ & Number ) == Number ; else @@v3@@ = @@a3@@ == Number ; if ( @@v3@@ ) { if ( @@a1@@ && indicator_style == Number && ( @@a2@@ & Number ) != Number ) @@v10@@ = Number ; else @@v10@@ = Number ; } else { if ( @@a1@@ ) { @@v4@@ = ( @@a2@@ & Number ) == Number ; } else { @@v5@@ = @@a3@@ == Number || @@a3@@ == Number ; @@v4@@ = @@v5@@ ; } if ( @@v4@@ ) { @@v10@@ = Number ; } else if ( indicator_style == Number ) { @@v10@@ = Number ; } else { if ( @@a1@@ ) @@v6@@ = ( @@a2@@ & Number ) == Number ; else @@v6@@ = @@a3@@ == Number ; if ( @@v6@@ ) { @@v10@@ = Number ; } else { if ( @@a1@@ ) @@v7@@ = ( @@a2@@ & Number ) == Number ; else @@v7@@ = @@a3@@ == Number ; if ( @@v7@@ ) { @@v10@@ = Number ; } else { if ( @@a1@@ ) @@v8@@ = ( @@a2@@ & Number ) == Number ; else @@v8@@ = @@a3@@ == Number ; if ( @@v8@@ ) @@v10@@ = Number ; else @@v10@@ = Number ; } } } } return @@v10@@ ; }
__int64 sort_files ( ) { __int64 @@result@@ ; int @@v1@@ ; unsigned __int8 @@v2@@ ; if ( cwd_n_used + ( ( unsigned __int64 ) cwd_n_used >> Number ) > sorted_file_alloc ) { free ( sorted_file ) ; sorted_file = ( void * ) xnmalloc ( cwd_n_used , Number L ) ; sorted_file_alloc = Number * cwd_n_used ; } initialize_ordering_vector ( ) ; @@result@@ = ( unsigned int ) sort_type ; if ( sort_type != Number ) { if ( _setjmp ( failed_strcoll ) ) { @@v2@@ = Number ; if ( sort_type == Number ) __assert_fail ( String , String , Number , String ) ; initialize_ordering_vector ( ) ; } else { @@v2@@ = Number ; } if ( sort_type == Number ) @@v1@@ = time_type ; else @@v1@@ = Number ; @@result@@ = mpsort ( sorted_file , cwd_n_used , * ( & sort_functions [ Number * ( unsigned int ) ( @@v1@@ + sort_type ) ] + Number * @@v2@@ + Number * ( unsigned __int8 ) sort_reverse + ( unsigned __int8 ) directories_first ) ) ; } return @@result@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
bool __fastcall print_type_indicator ( char @@a1@@ , __int16 @@a2@@ , int @@a3@@ ) { char @@v4@@ ; @@v4@@ = get_type_indicator ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( @@v4@@ ) { putchar_unlocked ( @@v4@@ ) ; ++ dired_pos ; } return @@v4@@ != Number ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
__int64 __fastcall format_user ( unsigned int @@a1@@ , int @@a2@@ , char @@a3@@ ) { const char * @@v3@@ ; if ( @@a3@@ != Number ) { @@v3@@ = String ; } else if ( numeric_ids ) { @@v3@@ = Number L ; } else { @@v3@@ = ( const char * ) getuser ( @@a1@@ ) ; } return format_user_or_group ( @@v3@@ , @@a1@@ , @@a2@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
size_t __fastcall put_indicator ( __int64 @@a1@@ ) { if ( used_color != Number ) { used_color = Number ; prep_non_filename_text ( ) ; } return fwrite_unlocked ( * ( const void * * ) ( @@a1@@ + Number ) , * ( _QWORD * ) @@a1@@ , Number , stdout ) ; }
__int64 __fastcall verrevcmp ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , unsigned __int64 @@a4@@ ) { int @@v4@@ ; int @@v5@@ ; unsigned int @@v9@@ ; int @@v10@@ ; unsigned __int64 @@v11@@ ; unsigned __int64 @@v12@@ ; @@v11@@ = Number L ; @@v12@@ = Number L ; while ( @@v11@@ < @@a2@@ || @@v12@@ < @@a4@@ ) { @@v9@@ = Number ; while ( @@v11@@ < @@a2@@ && ( unsigned __int8 ) c_isdigit ( ( unsigned int ) * ( char * ) ( @@a1@@ + @@v11@@ ) ) != Number || @@v12@@ < @@a4@@ && ( unsigned __int8 ) c_isdigit ( ( unsigned int ) * ( char * ) ( @@a3@@ + @@v12@@ ) ) != Number ) { if ( @@v11@@ == @@a2@@ ) @@v4@@ = Number ; else @@v4@@ = order ( * ( _BYTE * ) ( @@a1@@ + @@v11@@ ) ) ; @@v10@@ = @@v4@@ ; if ( @@v12@@ == @@a4@@ ) @@v5@@ = Number ; else @@v5@@ = order ( * ( _BYTE * ) ( @@a3@@ + @@v12@@ ) ) ; if ( @@v10@@ != @@v5@@ ) return ( unsigned int ) ( @@v10@@ - @@v5@@ ) ; ++ @@v11@@ ; ++ @@v12@@ ; } while ( * ( _BYTE * ) ( @@a1@@ + @@v11@@ ) == Number ) ++ @@v11@@ ; while ( * ( _BYTE * ) ( @@a3@@ + @@v12@@ ) == Number ) ++ @@v12@@ ; while ( ( unsigned __int8 ) c_isdigit ( ( unsigned int ) * ( char * ) ( @@a1@@ + @@v11@@ ) ) && ( unsigned __int8 ) c_isdigit ( ( unsigned int ) * ( char * ) ( @@a3@@ + @@v12@@ ) ) ) { if ( ! @@v9@@ ) @@v9@@ = * ( char * ) ( @@a1@@ + @@v11@@ ) - * ( char * ) ( @@a3@@ + @@v12@@ ) ; ++ @@v11@@ ; ++ @@v12@@ ; } if ( ( unsigned __int8 ) c_isdigit ( ( unsigned int ) * ( char * ) ( @@a1@@ + @@v11@@ ) ) ) return Number L ; if ( ( unsigned __int8 ) c_isdigit ( ( unsigned int ) * ( char * ) ( @@a3@@ + @@v12@@ ) ) ) return Number ; if ( @@v9@@ ) return @@v9@@ ; } return Number L ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
__int64 __fastcall format_group ( unsigned int @@a1@@ , int @@a2@@ , char @@a3@@ ) { const char * @@v3@@ ; if ( @@a3@@ != Number ) { @@v3@@ = String ; } else if ( numeric_ids ) { @@v3@@ = Number L ; } else { @@v3@@ = ( const char * ) getgroup ( @@a1@@ ) ; } return format_user_or_group ( @@v3@@ , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall length_of_file_name_and_frills ( __int64 @@a1@@ ) { const char * @@v1@@ ; __int64 @@v2@@ ; const char * @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; char @@v7@@ ; size_t @@v8@@ ; __int64 @@v9@@ ; char @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; if ( print_inode ) { if ( format == Number ) { @@v1@@ = ( const char * ) umaxtostr ( * ( _QWORD * ) ( @@a1@@ + Number ) , @@v10@@ ) ; @@v2@@ = strlen ( @@v1@@ ) + Number ; } else { @@v2@@ = inode_number_width + Number L ; } @@v9@@ += @@v2@@ ; } if ( print_block_size ) { if ( format == Number ) { if ( * ( _BYTE * ) ( @@a1@@ + Number ) != Number ) @@v3@@ = String ; else @@v3@@ = ( const char * ) human_readable ( * ( _QWORD * ) ( @@a1@@ + Number ) , @@v10@@ , ( unsigned int ) human_output_opts , Number L , output_block_size ) ; @@v4@@ = strlen ( @@v3@@ ) + Number ; } else { @@v4@@ = block_size_width + Number L ; } @@v9@@ += @@v4@@ ; } if ( print_scontext ) { if ( format == Number ) @@v5@@ = strlen ( * ( const char * * ) ( @@a1@@ + Number ) ) + Number ; else @@v5@@ = scontext_width + Number L ; @@v9@@ += @@v5@@ ; } quote_name ( Number L , * ( _QWORD * ) @@a1@@ , filename_quoting_options , & @@v8@@ ) ; @@v9@@ += @@v8@@ ; if ( indicator_style ) { @@v7@@ = get_type_indicator ( * ( _BYTE * ) ( @@a1@@ + Number ) , * ( _DWORD * ) ( @@a1@@ + Number ) , * ( _DWORD * ) ( @@a1@@ + Number ) ) ; @@v9@@ += @@v7@@ != Number ; } return @@v9@@ ; }
__int64 __fastcall wc_ensure_printable ( wint_t * @@a1@@ ) { unsigned __int8 @@v2@@ ; @@v2@@ = Number ; while ( * @@a1@@ ) { if ( ! iswprint ( * @@a1@@ ) ) { * @@a1@@ = Number ; @@v2@@ = Number ; } ++ @@a1@@ ; } return @@v2@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
size_t __fastcall format_user_width ( unsigned int @@a1@@ ) { __int64 @@v1@@ ; if ( numeric_ids ) @@v1@@ = Number L ; else @@v1@@ = getuser ( @@a1@@ ) ; return format_user_or_group_width ( @@v1@@ , @@a1@@ ) ; }
unsigned __int64 print_many_per_line ( ) { __int64 @@v0@@ ; unsigned __int64 @@result@@ ; unsigned __int64 @@i@@ ; __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; unsigned __int64 @@j@@ ; unsigned __int64 @@v6@@ ; __int64 @@v7@@ ; unsigned __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; @@v6@@ = calculate_columns ( Number L ) ; @@v7@@ = column_info + Number * @@v6@@ - Number ; @@v8@@ = cwd_n_used / @@v6@@ + ( cwd_n_used % @@v6@@ != Number ) ; for ( @@i@@ = Number L ; ; ++ @@i@@ ) { @@result@@ = @@i@@ ; if ( @@i@@ >= @@v8@@ ) break ; @@v3@@ = Number L ; @@v4@@ = @@i@@ ; for ( @@j@@ = Number L ; ; @@j@@ += @@v11@@ ) { @@v9@@ = * ( ( _QWORD * ) sorted_file + @@v4@@ ) ; @@v10@@ = length_of_file_name_and_frills ( @@v9@@ ) ; @@v0@@ = @@v3@@ ++ ; @@v11@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( @@v7@@ + Number ) + Number * @@v0@@ ) ; print_file_name_and_frills ( @@v9@@ , @@j@@ ) ; @@v4@@ += @@v8@@ ; if ( @@v4@@ >= cwd_n_used ) break ; indent ( @@j@@ + @@v10@@ , @@v11@@ + @@j@@ ) ; } putchar_unlocked ( Number ) ; } return @@result@@ ; }
__int64 __fastcall memcpy_lowcase ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { while ( @@a3@@ -- ) * ( _BYTE * ) ( @@a1@@ + @@a3@@ ) = tolower ( * ( unsigned __int8 * ) ( @@a2@@ + @@a3@@ ) ) ; return @@a1@@ ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
__int64 __fastcall wc_truncate ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { int @@v4@@ ; __int64 @@v5@@ ; @@v5@@ = Number L ; while ( * @@a1@@ ) { @@v4@@ = wcwidth ( * @@a1@@ ) ; if ( @@v4@@ == Number ) { * @@a1@@ = Number ; @@v4@@ = Number ; } if ( @@a2@@ < @@v4@@ + @@v5@@ ) break ; @@v5@@ += @@v4@@ ; ++ @@a1@@ ; } * @@a1@@ = Number ; return @@v5@@ ; }
__int64 __fastcall iso_week_days ( int @@a1@@ , int @@a2@@ ) { return ( unsigned int ) ( @@a1@@ - ( @@a1@@ - @@a2@@ + Number ) % Number + Number ) ; }
int print_horizontal ( ) { unsigned __int64 @@i@@ ; unsigned __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; @@v2@@ = Number L ; @@v5@@ = calculate_columns ( Number L ) ; @@v6@@ = column_info + Number * @@v5@@ - Number ; @@v7@@ = * ( _QWORD * ) sorted_file ; @@v3@@ = length_of_file_name_and_frills ( * ( _QWORD * ) sorted_file ) ; @@v4@@ = * * ( _QWORD * * ) ( @@v6@@ + Number ) ; print_file_name_and_frills ( @@v7@@ , Number L ) ; for ( @@i@@ = Number L ; @@i@@ < cwd_n_used ; ++ @@i@@ ) { if ( @@i@@ % @@v5@@ ) { indent ( @@v2@@ + @@v3@@ , @@v4@@ + @@v2@@ ) ; @@v2@@ += @@v4@@ ; } else { putchar_unlocked ( Number ) ; @@v2@@ = Number L ; } @@v8@@ = * ( ( _QWORD * ) sorted_file + @@i@@ ) ; print_file_name_and_frills ( @@v8@@ , @@v2@@ ) ; @@v3@@ = length_of_file_name_and_frills ( @@v8@@ ) ; @@v4@@ = * ( _QWORD * ) ( Number * ( @@i@@ % @@v5@@ ) + * ( _QWORD * ) ( @@v6@@ + Number ) ) ; } return putchar_unlocked ( Number ) ; }
_BYTE * __fastcall filemodestring ( __int64 @@a1@@ , _BYTE * @@a2@@ ) { return strmode ( * ( _DWORD * ) ( @@a1@@ + Number ) , @@a2@@ ) ; }
int print_with_commas ( ) { char @@v1@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; @@v3@@ = Number L ; for ( @@i@@ = Number L ; @@i@@ < cwd_n_used ; ++ @@i@@ ) { @@v4@@ = * ( ( _QWORD * ) sorted_file + @@i@@ ) ; @@v5@@ = length_of_file_name_and_frills ( @@v4@@ ) ; if ( @@i@@ ) { if ( @@v3@@ + @@v5@@ + Number >= line_length ) { @@v3@@ = Number L ; @@v1@@ = Number ; } else { @@v3@@ += Number L ; @@v1@@ = Number ; } putchar_unlocked ( Number ) ; putchar_unlocked ( @@v1@@ ) ; } print_file_name_and_frills ( @@v4@@ , @@v3@@ ) ; @@v3@@ += @@v5@@ ; } return putchar_unlocked ( Number ) ; }
__int64 __fastcall xnrealloc ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { if ( ! is_mul_ok ( @@a3@@ , @@a2@@ ) ) xalloc_die ( ) ; return xrealloc ( @@a1@@ , @@a3@@ * @@a2@@ ) ; }
__int64 __fastcall rpl_wcswidth ( wchar_t * @@a1@@ , __int64 @@a2@@ ) { wchar_t * @@v2@@ ; __int64 @@v4@@ ; int @@i@@ ; int @@v8@@ ; for ( @@i@@ = Number ; ; @@i@@ += @@v8@@ ) { @@v4@@ = @@a2@@ -- ; if ( ! @@v4@@ || ! * @@a1@@ ) break ; @@v2@@ = @@a1@@ ++ ; @@v8@@ = wcwidth ( * @@v2@@ ) ; if ( @@v8@@ == Number ) return Number ; if ( @@i@@ > Number - @@v8@@ ) return Number ; } return ( unsigned int ) @@i@@ ; }
_BYTE * __fastcall longest_relative_suffix ( _BYTE * @@a1@@ ) { while ( * @@a1@@ == Number ) ++ @@a1@@ ; return @@a1@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@v2@@ ; @@v2@@ = malloc ( @@a1@@ ) ; if ( ! @@v2@@ && @@a1@@ ) xalloc_die ( ) ; return @@v2@@ ; }
unsigned __int64 __fastcall indent ( unsigned __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { unsigned __int64 @@result@@ ; while ( Number ) { @@result@@ = @@a1@@ ; if ( @@a1@@ >= @@a2@@ ) break ; if ( tabsize && @@a2@@ / tabsize > ( @@a1@@ + Number ) / tabsize ) { putchar_unlocked ( Number ) ; @@a1@@ += tabsize - @@a1@@ % tabsize ; } else { putchar_unlocked ( Number ) ; ++ @@a1@@ ; } } return @@result@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@v3@@ ; @@v3@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v3@@ ) xalloc_die ( ) ; return @@v3@@ ; }
void * __fastcall mfile_name_concat ( _BYTE * @@a1@@ , _BYTE * @@a2@@ , _QWORD * @@a3@@ ) { _BOOL4 @@v3@@ ; const char * @@v6@@ ; size_t @@v7@@ ; size_t @@n@@ ; _BOOL8 @@v9@@ ; char * @@s@@ ; size_t @@v11@@ ; void * @@dest@@ ; _BYTE * @@v13@@ ; char * @@v14@@ ; @@v6@@ = last_component ( @@a1@@ ) ; @@v7@@ = base_len ( @@v6@@ ) ; @@n@@ = @@v6@@ - @@a1@@ + @@v7@@ ; @@v3@@ = @@v7@@ && @@v6@@ [ @@v7@@ - Number ] != Number ; @@v9@@ = @@v3@@ ; @@s@@ = longest_relative_suffix ( @@a2@@ ) ; @@v11@@ = strlen ( @@s@@ ) ; @@dest@@ = malloc ( @@v9@@ + @@n@@ + @@v11@@ + Number ) ; if ( ! @@dest@@ ) return Number L ; @@v13@@ = mempcpy ( @@dest@@ , @@a1@@ , @@n@@ ) ; * @@v13@@ = Number ; @@v14@@ = & @@v13@@ [ @@v9@@ ] ; if ( @@a3@@ ) * @@a3@@ = & @@v14@@ [ - ( * @@a2@@ == Number ) ] ; * ( _BYTE * ) mempcpy ( @@v14@@ , @@s@@ , @@v11@@ ) = Number ; return @@dest@@ ; }
__int64 __fastcall mbsnwidth ( char * @@a1@@ , __int64 @@a2@@ , char @@a3@@ ) { int @@v3@@ ; char * @@v5@@ ; unsigned __int8 @@v7@@ ; wchar_t @@pwc@@ ; unsigned int @@v9@@ ; int @@v10@@ ; char * @@v11@@ ; size_t @@v12@@ ; char * @@v13@@ ; mbstate_t @@s@@ [ Number ] ; @@s@@ [ Number ] = ( mbstate_t ) __readfsqword ( Number ) ; @@v11@@ = @@a1@@ ; @@v13@@ = & @@a1@@ [ @@a2@@ ] ; @@v9@@ = Number ; if ( __ctype_get_mb_cur_max ( ) > Number ) { while ( Number ) { LABEL_28 : if ( @@v11@@ >= @@v13@@ ) return @@v9@@ ; @@v3@@ = * @@v11@@ ; if ( @@v3@@ > Number ) { if ( @@v3@@ < Number || @@v3@@ > Number && ( unsigned int ) ( @@v3@@ - Number ) > Number ) { LABEL_11 : memset ( @@s@@ , Number , Number ) ; while ( Number ) { @@v12@@ = mbrtowc ( & @@pwc@@ , @@v11@@ , @@v13@@ - @@v11@@ , @@s@@ ) ; if ( @@v12@@ == Number ) { if ( ( @@a3@@ & Number ) == Number ) { ++ @@v11@@ ; ++ @@v9@@ ; goto LABEL_28 ; } return Number ; } if ( @@v12@@ == Number ) break ; if ( ! @@v12@@ ) @@v12@@ = Number L ; @@v10@@ = wcwidth ( @@pwc@@ ) ; if ( @@v10@@ < Number ) { if ( ( @@a3@@ & Number ) != Number ) return Number ; @@v9@@ += iswcntrl ( @@pwc@@ ) == Number ; } else { @@v9@@ += @@v10@@ ; } @@v11@@ += @@v12@@ ; if ( mbsinit ( @@s@@ ) ) goto LABEL_28 ; } if ( ( @@a3@@ & Number ) == Number ) { @@v11@@ = @@v13@@ ; ++ @@v9@@ ; continue ; } return Number ; } } else if ( @@v3@@ < Number && ( unsigned int ) ( @@v3@@ - Number ) > Number ) { goto LABEL_11 ; } ++ @@v11@@ ; ++ @@v9@@ ; } } while ( @@v11@@ < @@v13@@ ) { @@v5@@ = @@v11@@ ++ ; @@v7@@ = * @@v5@@ ; if ( ( ( * __ctype_b_loc ( ) ) [ @@v7@@ ] & Number ) != Number ) { ++ @@v9@@ ; } else { if ( ( @@a3@@ & Number ) != Number ) return Number ; @@v9@@ += ( ( * __ctype_b_loc ( ) ) [ @@v7@@ ] & Number ) == Number ; } } return @@v9@@ ; }
unsigned __int64 __fastcall xstrtol_error ( unsigned int @@a1@@ , int @@a2@@ , char @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , int @@a6@@ ) { char * @@v6@@ ; char * @@v10@@ ; char * @@msgid@@ ; char * @@v12@@ ; char @@v13@@ [ Number ] ; unsigned __int64 @@v14@@ ; @@v14@@ = __readfsqword ( Number ) ; @@v10@@ = ( char * ) & unk_1A278 ; if ( @@a1@@ > Number ) { if ( @@a1@@ != Number ) goto LABEL_6 ; @@msgid@@ = String ; } else if ( @@a1@@ >= Number ) { @@msgid@@ = String ; } else { if ( @@a1@@ != Number ) LABEL_6 : abort ( ) ; @@msgid@@ = String ; } if ( @@a2@@ >= Number ) { @@v12@@ = * ( char * * ) ( Number L * @@a2@@ + @@a4@@ ) ; } else { @@v10@@ = ( char * ) & unk_1A278 - @@a2@@ ; @@v13@@ [ Number ] = @@a3@@ ; @@v13@@ [ Number ] = Number ; @@v12@@ = @@v13@@ ; } @@v6@@ = gettext ( @@msgid@@ ) ; error ( @@a6@@ , Number , @@v6@@ , @@v10@@ , @@v12@@ , @@a5@@ ) ; return __readfsqword ( Number ) ^ @@v14@@ ; }
_BYTE * __fastcall attach ( _BYTE * @@a1@@ , _BYTE * @@a2@@ , _BYTE * @@a3@@ ) { _BYTE * @@v3@@ ; _BYTE * @@v4@@ ; _BYTE * @@v5@@ ; _BYTE * @@v6@@ ; _BYTE * @@v7@@ ; _BYTE * @@result@@ ; _BYTE * @@v11@@ ; @@v11@@ = @@a2@@ ; if ( * @@a2@@ != Number || @@a2@@ [ Number ] ) { while ( * @@v11@@ ) { @@v3@@ = @@v11@@ ++ ; @@v4@@ = @@a1@@ ++ ; * @@v4@@ = * @@v3@@ ; } if ( @@v11@@ > @@a2@@ && * ( @@v11@@ - Number ) != Number ) { @@v5@@ = @@a1@@ ++ ; * @@v5@@ = Number ; } } while ( * @@a3@@ ) { @@v6@@ = @@a3@@ ++ ; @@v7@@ = @@a1@@ ++ ; * @@v7@@ = * @@v6@@ ; } @@result@@ = @@a1@@ ; * @@a1@@ = Number ; return @@result@@ ; }
__int64 __fastcall hash_lookup ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; _QWORD * @@i@@ ; _QWORD * @@v5@@ ; @@v2@@ = * @@a1@@ ; @@v5@@ = ( _QWORD * ) ( @@v2@@ + Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) ) ; if ( ( unsigned __int64 ) @@v5@@ >= @@a1@@ [ Number ] ) abort ( ) ; if ( ! * @@v5@@ ) return Number L ; for ( @@i@@ = @@v5@@ ; @@i@@ ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { if ( @@a2@@ == * @@i@@ || ( ( unsigned __int8 ( __fastcall * ) ( __int64 , _QWORD ) ) @@a1@@ [ Number ] ) ( @@a2@@ , * @@i@@ ) ) { return * @@i@@ ; } } return Number L ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
void __fastcall argmatch_invalid ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { char * @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; char * @@format@@ ; if ( @@a3@@ == Number ) @@v3@@ = gettext ( String ) ; else @@v3@@ = gettext ( String ) ; @@format@@ = @@v3@@ ; @@v4@@ = quote_n ( Number L , @@a1@@ ) ; @@v5@@ = quotearg_n_style ( Number L , Number L , @@a2@@ ) ; error ( Number , Number , @@format@@ , @@v5@@ , @@v4@@ ) ; }
unsigned __int64 init_column_info ( ) { unsigned __int64 @@v0@@ ; unsigned __int64 @@result@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@j@@ ; unsigned __int64 @@v4@@ ; __int64 @@v5@@ ; unsigned __int64 @@k@@ ; unsigned __int64 @@v7@@ ; unsigned __int64 @@v8@@ ; @@v0@@ = max_idx ; if ( cwd_n_used <= ( unsigned __int64 ) max_idx ) @@v0@@ = cwd_n_used ; @@v7@@ = @@v0@@ ; if ( @@v0@@ > column_info_alloc_8572 ) { if ( @@v0@@ >= ( unsigned __int64 ) max_idx >> Number ) { column_info = xnrealloc ( column_info , max_idx , Number L ) ; @@v4@@ = max_idx ; } else { column_info = xnrealloc ( column_info , @@v0@@ , Number L ) ; @@v4@@ = Number * @@v7@@ ; } @@v8@@ = ( @@v4@@ - column_info_alloc_8572 ) * ( column_info_alloc_8572 + @@v4@@ + Number ) ; if ( column_info_alloc_8572 + @@v4@@ + Number < @@v4@@ || column_info_alloc_8572 + @@v4@@ + Number != @@v8@@ / ( @@v4@@ - column_info_alloc_8572 ) ) { xalloc_die ( ) ; } @@v5@@ = xnmalloc ( @@v8@@ >> Number , Number L ) ; for ( @@i@@ = column_info_alloc_8572 ; @@i@@ < @@v4@@ ; ++ @@i@@ ) { * ( _QWORD * ) ( column_info + Number * @@i@@ + Number ) = @@v5@@ ; @@v5@@ += Number * ( @@i@@ + Number ) ; } column_info_alloc_8572 = @@v4@@ ; } for ( @@j@@ = Number L ; ; ++ @@j@@ ) { @@result@@ = @@j@@ ; if ( @@j@@ >= @@v7@@ ) break ; * ( _BYTE * ) ( column_info + Number * @@j@@ ) = Number ; * ( _QWORD * ) ( column_info + Number * @@j@@ + Number ) = Number * ( @@j@@ + Number ) ; for ( @@k@@ = Number L ; @@k@@ <= @@j@@ ; ++ @@k@@ ) * ( _QWORD * ) ( Number * @@k@@ + * ( _QWORD * ) ( column_info + Number * @@j@@ + Number ) ) = Number L ; } return @@result@@ ; }
unsigned __int64 __fastcall hash_get_entries ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; _QWORD * @@i@@ ; _QWORD * @@j@@ ; @@v5@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = @@i@@ ; @@j@@ ; @@j@@ = ( _QWORD * ) @@j@@ [ Number ] ) { if ( @@v5@@ >= @@a3@@ ) return @@v5@@ ; @@v4@@ = @@v5@@ ++ ; * ( _QWORD * ) ( @@a2@@ + Number * @@v4@@ ) = * @@j@@ ; } } } return @@v5@@ ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
int __fastcall argmatch_valid ( __int64 @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { char * @@v3@@ ; __int64 @@i@@ ; void * @@s1@@ ; @@s1@@ = Number L ; @@v3@@ = gettext ( String ) ; fprintf ( stderr , @@v3@@ ) ; for ( @@i@@ = Number L ; * ( _QWORD * ) ( Number * @@i@@ + @@a1@@ ) ; ++ @@i@@ ) { if ( @@i@@ && ! memcmp ( @@s1@@ , ( const void * ) ( @@i@@ * @@a3@@ + @@a2@@ ) , @@a3@@ ) ) { fprintf ( stderr , String , * ( const char * * ) ( Number * @@i@@ + @@a1@@ ) ) ; } else { fprintf ( stderr , String , * ( const char * * ) ( Number * @@i@@ + @@a1@@ ) ) ; @@s1@@ = ( void * ) ( @@i@@ * @@a3@@ + @@a2@@ ) ; } } return putc_unlocked ( Number , stderr ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
__int64 __fastcall next_prime ( unsigned __int64 @@a1@@ ) { __int64 @@v2@@ ; __int64 @@i@@ ; @@v2@@ = @@a1@@ ; if ( @@a1@@ <= Number ) @@v2@@ = Number L ; for ( @@i@@ = @@v2@@ | Number ; @@i@@ != Number && ! is_prime ( @@i@@ ) ; @@i@@ += Number L ) { ; } return @@i@@ ; }
unsigned __int64 __fastcall calculate_columns ( char @@a1@@ ) { __int64 @@v1@@ ; unsigned __int64 @@v2@@ ; __int64 @@v3@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@k@@ ; unsigned __int64 @@j@@ ; unsigned __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; @@v1@@ = max_idx ; if ( cwd_n_used <= ( unsigned __int64 ) max_idx ) @@v1@@ = cwd_n_used ; @@v8@@ = @@v1@@ ; init_column_info ( ) ; for ( @@i@@ = Number L ; @@i@@ < cwd_n_used ; ++ @@i@@ ) { @@v9@@ = length_of_file_name_and_frills ( * ( ( _QWORD * ) sorted_file + @@i@@ ) ) ; for ( @@j@@ = Number L ; @@j@@ < @@v8@@ ; ++ @@j@@ ) { if ( * ( _BYTE * ) ( column_info + Number * @@j@@ ) ) { @@v2@@ = @@a1@@ ? @@i@@ / ( ( cwd_n_used + @@j@@ ) / ( @@j@@ + Number ) ) : @@i@@ % ( @@j@@ + Number ) ; @@v3@@ = @@v2@@ == @@j@@ ? Number L : Number L ; @@v10@@ = @@v3@@ + @@v9@@ ; if ( ( unsigned __int64 ) ( @@v3@@ + @@v9@@ ) > * ( _QWORD * ) ( Number * @@v2@@ + * ( _QWORD * ) ( column_info + Number * @@j@@ + Number ) ) ) { * ( _QWORD * ) ( column_info + Number * @@j@@ + Number ) += @@v10@@ - * ( _QWORD * ) ( Number * @@v2@@ + * ( _QWORD * ) ( column_info + Number * @@j@@ + Number ) ) ; * ( _QWORD * ) ( * ( _QWORD * ) ( column_info + Number * @@j@@ + Number ) + Number * @@v2@@ ) = @@v10@@ ; * ( _BYTE * ) ( column_info + Number * @@j@@ ) = * ( _QWORD * ) ( column_info + Number * @@j@@ + Number ) < ( unsigned __int64 ) line_length ; } } } } for ( @@k@@ = @@v8@@ ; @@k@@ > Number && ! * ( _BYTE * ) ( column_info + Number * @@k@@ - Number ) ; -- @@k@@ ) { ; } return @@k@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
unsigned __int64 __fastcall compute_bucket_size ( __int64 @@a1@@ , __int64 @@a2@@ ) { float @@v2@@ ; unsigned __int64 @@result@@ ; unsigned __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; float @@v6@@ ; @@v4@@ = @@a1@@ ; if ( * ( _BYTE * ) ( @@a2@@ + Number ) != Number ) { if ( @@a1@@ < Number ) @@v2@@ = ( float ) ( @@a1@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@a1@@ >> Number ) ) + ( float ) ( @@a1@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@a1@@ >> Number ) ) ; else @@v2@@ = ( float ) ( int ) @@a1@@ ; @@v6@@ = @@v2@@ / * ( float * ) ( @@a2@@ + Number ) ; if ( @@v6@@ >= Number ) return Number L ; if ( @@v6@@ >= Number ) @@v4@@ = ( unsigned int ) ( int ) ( float ) ( @@v6@@ - Number ) ^ Number ; else @@v4@@ = ( unsigned int ) ( int ) @@v6@@ ; } @@v5@@ = next_prime ( @@v4@@ ) ; if ( @@v5@@ <= Number ) @@result@@ = @@v5@@ ; else @@result@@ = Number L ; return @@result@@ ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
__int64 __fastcall ftypelet ( __int16 @@a1@@ ) { switch ( @@a1@@ & Number ) { case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; } return Number L ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
void * __fastcall allocate_entry ( __int64 @@a1@@ ) { __int64 @@v2@@ ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return malloc ( Number ) ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = * ( _QWORD * ) ( @@v2@@ + Number ) ; return ( void * ) @@v2@@ ; }
__int64 __fastcall file_name_concat ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v4@@ ; @@v4@@ = mfile_name_concat ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( ! @@v4@@ ) xalloc_die ( ) ; return @@v4@@ ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
__int64 __fastcall free_entry ( __int64 @@a1@@ , _QWORD * @@a2@@ ) { __int64 @@result@@ ; * @@a2@@ = Number L ; @@a2@@ [ Number ] = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@result@@ = @@a1@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall hard_locale ( int @@a1@@ ) { unsigned __int8 @@v2@@ ; const char * @@s1@@ ; @@v2@@ = Number ; @@s1@@ = setlocale ( @@a1@@ , Number L ) ; if ( @@s1@@ && ( ! strcmp ( @@s1@@ , String ) || ! strcmp ( @@s1@@ , String ) ) ) @@v2@@ = Number ; return @@v2@@ ; }
__int64 __fastcall hash_get_n_entries ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_21F238 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
_BOOL8 __fastcall hash_table_ok ( __int64 @@a1@@ ) { _QWORD * @@i@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; _QWORD * @@v5@@ ; @@v3@@ = Number L ; @@v4@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { @@v5@@ = @@i@@ ; ++ @@v3@@ ; ++ @@v4@@ ; while ( Number ) { @@v5@@ = ( _QWORD * ) @@v5@@ [ Number ] ; if ( ! @@v5@@ ) break ; ++ @@v4@@ ; } } } return @@v3@@ == * ( _QWORD * ) ( @@a1@@ + Number ) && @@v4@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_2060C8 ; @@v4@@ [ Number ] = qword_2060D0 ; @@v4@@ [ Number ] = qword_2060D8 ; @@v4@@ [ Number ] = qword_2060E0 ; @@v4@@ [ Number ] = qword_2060E8 ; @@v4@@ [ Number ] = qword_2060F0 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_21FE88 ; @@v4@@ [ Number ] = qword_21FE90 ; @@v4@@ [ Number ] = qword_21FE98 ; @@v4@@ [ Number ] = qword_21FEA0 ; @@v4@@ [ Number ] = qword_21FEA8 ; @@v4@@ [ Number ] = qword_21FEB0 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
__int64 __fastcall transfer_entries ( __int64 @@a1@@ , __int64 @@a2@@ , char @@a3@@ ) { __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 * @@i@@ ; _QWORD * @@j@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; _QWORD * @@v11@@ ; _QWORD * @@v12@@ ; _QWORD * @@v13@@ ; _QWORD * @@v14@@ ; for ( @@i@@ = * ( __int64 * * ) @@a2@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a2@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = ( _QWORD * ) @@i@@ [ Number ] ; @@j@@ ; @@j@@ = @@v14@@ ) { @@v9@@ = * @@j@@ ; @@v3@@ = * ( _QWORD * ) @@a1@@ ; @@v11@@ = ( _QWORD * ) ( @@v3@@ + Number * ( * ( __int64 ( __fastcall * * ) ( _QWORD , _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@j@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@v11@@ >= * ( _QWORD * ) ( @@a1@@ + Number ) ) abort ( ) ; @@v14@@ = ( _QWORD * ) @@j@@ [ Number ] ; if ( * @@v11@@ ) { @@j@@ [ Number ] = @@v11@@ [ Number ] ; @@v11@@ [ Number ] = @@j@@ ; } else { * @@v11@@ = @@v9@@ ; ++ * ( _QWORD * ) ( @@a1@@ + Number ) ; free_entry ( @@a1@@ , @@j@@ ) ; } } @@v10@@ = * @@i@@ ; @@i@@ [ Number ] = Number L ; if ( ! @@a3@@ ) { @@v4@@ = * ( _QWORD * ) @@a1@@ ; @@v12@@ = ( _QWORD * ) ( @@v4@@ + Number * ( * ( __int64 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@v10@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@v12@@ >= * ( _QWORD * ) ( @@a1@@ + Number ) ) abort ( ) ; if ( * @@v12@@ ) { @@v13@@ = allocate_entry ( @@a1@@ ) ; if ( ! @@v13@@ ) return Number L ; * @@v13@@ = @@v10@@ ; @@v13@@ [ Number ] = @@v12@@ [ Number ] ; @@v12@@ [ Number ] = @@v13@@ ; } else { * @@v12@@ = @@v10@@ ; ++ * ( _QWORD * ) ( @@a1@@ + Number ) ; } * @@i@@ = Number L ; -- * ( _QWORD * ) ( @@a2@@ + Number ) ; } } } return Number L ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__int64 __fastcall hash_get_first ( unsigned __int64 * @@a1@@ ) { unsigned __int64 @@i@@ ; if ( ! @@a1@@ [ Number ] ) return Number L ; for ( @@i@@ = * @@a1@@ ; ; @@i@@ += Number L ) { if ( @@i@@ >= @@a1@@ [ Number ] ) abort ( ) ; if ( * ( _QWORD * ) @@i@@ ) break ; } return * ( _QWORD * ) @@i@@ ; }
__int64 __fastcall umaxtostr ( unsigned __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v4@@ ; @@v4@@ = @@a2@@ + Number ; * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; do { * ( _BYTE * ) -- @@v4@@ = @@a1@@ % Number + Number ; @@a1@@ /= Number ; } while ( @@a1@@ ) ; return @@v4@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
void * __fastcall xzalloc ( size_t @@a1@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@a1@@ ) ; return memset ( @@v1@@ , Number , @@a1@@ ) ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
__int64 __fastcall hash_get_next ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; _QWORD * @@v4@@ ; _QWORD * @@i@@ ; @@v2@@ = * @@a1@@ ; @@v4@@ = ( _QWORD * ) ( @@v2@@ + Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) ) ; if ( ( unsigned __int64 ) @@v4@@ >= @@a1@@ [ Number ] ) abort ( ) ; for ( @@i@@ = @@v4@@ ; @@i@@ ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { if ( @@a2@@ == * @@i@@ && @@i@@ [ Number ] ) return * ( _QWORD * ) @@i@@ [ Number ] ; } while ( Number ) { @@v4@@ += Number ; if ( ( unsigned __int64 ) @@v4@@ >= @@a1@@ [ Number ] ) break ; if ( * @@v4@@ ) return * @@v4@@ ; } return Number L ; }
__int64 __fastcall bkm_scale_by_power ( unsigned __int64 * @@a1@@ , int @@a2@@ , int @@a3@@ ) { unsigned int @@i@@ ; for ( @@i@@ = Number ; @@a3@@ -- ; @@i@@ |= bkm_scale ( @@a1@@ , @@a2@@ ) ) { ; } return @@i@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
__int64 __fastcall humblock ( char * @@a1@@ , _QWORD * @@a2@@ , int * @@a3@@ ) { char * @@v5@@ ; int @@v6@@ ; int @@v7@@ ; unsigned int @@v8@@ ; __int64 @@v9@@ [ Number ] ; @@v5@@ = @@a1@@ ; @@v9@@ [ Number ] = __readfsqword ( Number ) ; @@v6@@ = Number ; if ( @@a1@@ || ( @@v5@@ = getenv ( String ) ) != Number L || ( @@v5@@ = getenv ( String ) ) != Number L ) { if ( * @@v5@@ == Number ) { @@v6@@ = Number ; ++ @@v5@@ ; } @@v7@@ = argmatch ( @@v5@@ , ( __int64 ) block_size_args , ( __int64 ) block_size_opts , Number ) ; if ( @@v7@@ < Number ) { @@v8@@ = xstrtoumax ( @@v5@@ , @@v9@@ , Number L , @@a2@@ , String ) ; if ( @@v8@@ ) { * @@a3@@ = Number ; return @@v8@@ ; } while ( * @@v5@@ <= Number || * @@v5@@ > Number ) { if ( @@v5@@ == ( char * ) @@v9@@ [ Number ] ) { @@v6@@ |= Number ; if ( * ( _BYTE * ) ( @@v9@@ [ Number ] - Number ) == Number ) @@v6@@ |= Number ; if ( * ( _BYTE * ) ( @@v9@@ [ Number ] - Number ) != Number || * ( _BYTE * ) ( @@v9@@ [ Number ] - Number ) == Number ) @@v6@@ |= Number ; break ; } ++ @@v5@@ ; } } else { @@v6@@ |= block_size_opts [ @@v7@@ ] ; * @@a2@@ = Number L ; } } else { * @@a2@@ = default_block_size ( ) ; } * @@a3@@ = @@v6@@ ; return Number L ; }
_BOOL8 __fastcall c_isalpha ( int @@a1@@ ) { return ( int ) ( @@a1@@ & Number ) > Number && ( int ) ( @@a1@@ & Number ) <= Number ; }
bool __fastcall is_prime ( unsigned __int64 @@a1@@ ) { unsigned __int64 @@v2@@ ; unsigned __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; @@v2@@ = Number L ; @@v4@@ = Number L ; while ( @@v4@@ < @@a1@@ && @@a1@@ % @@v2@@ ) { @@v3@@ = @@v2@@ + Number ; @@v4@@ += Number * @@v3@@ ; @@v2@@ = @@v3@@ + Number ; } return @@a1@@ % @@v2@@ != Number ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
_BOOL8 __fastcall c_isblank ( int @@a1@@ ) { return @@a1@@ == Number || @@a1@@ == Number ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
_BOOL8 __fastcall c_isgraph ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
_BOOL8 __fastcall c_isspace ( int @@a1@@ ) { return @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number ; }
__int64 __fastcall c_tolower ( int @@a1@@ ) { __int64 @@result@@ ; if ( @@a1@@ <= Number || @@a1@@ > Number ) @@result@@ = ( unsigned int ) @@a1@@ ; else @@result@@ = ( unsigned int ) ( @@a1@@ + Number ) ; return @@result@@ ; }
__int64 __fastcall bkm_scale_by_power_0 ( unsigned __int64 * @@a1@@ , int @@a2@@ , int @@a3@@ ) { unsigned int @@i@@ ; for ( @@i@@ = Number ; @@a3@@ -- ; @@i@@ |= bkm_scale_0 ( @@a1@@ , @@a2@@ ) ) { ; } return @@i@@ ; }
size_t * __fastcall hash_initialize ( __int64 @@a1@@ , void * @@a2@@ , unsigned __int64 ( __fastcall * @@a3@@ ) ( __int64 a1 , unsigned __int64 a2 ) , bool ( __fastcall * @@a4@@ ) ( __int64 a1 , __int64 a2 ) , size_t @@a5@@ ) { size_t * @@result@@ ; bool ( __fastcall * @@v7@@ ) ( __int64 , __int64 ) ; unsigned __int64 ( __fastcall * @@v8@@ ) ( __int64 , unsigned __int64 ) ; void * @@v9@@ ; size_t * @@ptr@@ ; @@v9@@ = @@a2@@ ; @@v8@@ = @@a3@@ ; @@v7@@ = @@a4@@ ; if ( ! @@a3@@ ) @@v8@@ = raw_hasher ; if ( ! @@a4@@ ) @@v7@@ = raw_comparator ; @@ptr@@ = ( size_t * ) malloc ( Number ) ; if ( ! @@ptr@@ ) return Number L ; if ( ! @@a2@@ ) @@v9@@ = & default_tuning ; @@ptr@@ [ Number ] = ( size_t ) @@v9@@ ; if ( ( unsigned __int8 ) check_tuning ( ( __int64 ) @@ptr@@ ) == Number && ( @@ptr@@ [ Number ] = compute_bucket_size ( @@a1@@ , ( __int64 ) @@v9@@ ) ) != Number && ( * @@ptr@@ = ( size_t ) calloc ( @@ptr@@ [ Number ] , Number ) ) != Number ) { @@ptr@@ [ Number ] = Number * @@ptr@@ [ Number ] + * @@ptr@@ ; @@ptr@@ [ Number ] = Number L ; @@ptr@@ [ Number ] = Number L ; @@ptr@@ [ Number ] = ( size_t ) @@v8@@ ; @@ptr@@ [ Number ] = ( size_t ) @@v7@@ ; @@ptr@@ [ Number ] = @@a5@@ ; @@ptr@@ [ Number ] = Number L ; @@result@@ = @@ptr@@ ; } else { free ( @@ptr@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
int __fastcall fstat ( int @@fildes@@ , struct stat * @@stat_buf@@ ) { return __fxstat ( Number , @@fildes@@ , @@stat_buf@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
void __fastcall mpsort_with_tmp ( __int64 * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int64 ( __fastcall * @@a4@@ ) ( __int64 , __int64 ) ) { int @@i@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; __int64 @@v12@@ ; __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; __int64 @@v15@@ ; __int64 @@v16@@ ; if ( @@a2@@ > Number ) { @@v10@@ = Number L ; @@v14@@ = @@a2@@ >> Number ; @@v11@@ = @@a2@@ >> Number ; mpsort_with_tmp ( & @@a1@@ [ @@a2@@ >> Number ] , @@a2@@ - ( @@a2@@ >> Number ) , @@a3@@ , @@a4@@ ) ; if ( @@a2@@ >> Number > Number ) mpsort_into_tmp ( @@a1@@ , @@a2@@ >> Number , @@a3@@ , @@a4@@ ) ; else * @@a3@@ = * @@a1@@ ; @@v13@@ = * @@a3@@ ; @@v12@@ = @@a1@@ [ @@v11@@ ] ; @@v9@@ = Number L ; for ( @@i@@ = @@a4@@ ( * @@a3@@ , @@v12@@ ) ; ; @@i@@ = @@a4@@ ( @@v13@@ , @@v12@@ ) ) { while ( @@i@@ <= Number ) { @@v5@@ = @@v9@@ ++ ; @@a1@@ [ @@v5@@ ] = @@v13@@ ; if ( ++ @@v10@@ == @@v14@@ ) return ; @@v13@@ = @@a3@@ [ @@v10@@ ] ; @@i@@ = @@a4@@ ( @@v13@@ , @@v12@@ ) ; } @@v6@@ = @@v9@@ ++ ; @@a1@@ [ @@v6@@ ] = @@v12@@ ; if ( ++ @@v11@@ == @@a2@@ ) break ; @@v12@@ = @@a1@@ [ @@v11@@ ] ; } memcpy ( & @@a1@@ [ @@v9@@ ] , & @@a3@@ [ @@v10@@ ] , Number * ( @@v14@@ - @@v10@@ ) ) ; } else if ( @@a2@@ == Number ) { @@v15@@ = * @@a1@@ ; @@v16@@ = @@a1@@ [ Number ] ; if ( ( int ) @@a4@@ ( * @@a1@@ , @@v16@@ ) > Number ) { * @@a1@@ = @@v16@@ ; @@a1@@ [ Number ] = @@v15@@ ; } } }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
__int64 __fastcall hash_find_entry ( __int64 @@a1@@ , __int64 @@a2@@ , _QWORD * @@a3@@ , char @@a4@@ ) { __int64 @@v4@@ ; __int64 @@result@@ ; __int64 @@v6@@ ; _QWORD * @@i@@ ; _QWORD * @@v10@@ ; __int64 @@v11@@ ; _QWORD * @@v12@@ ; __int64 @@v13@@ ; _QWORD * @@v14@@ ; @@v4@@ = * ( _QWORD * ) @@a1@@ ; @@v10@@ = ( _QWORD * ) ( @@v4@@ + Number * ( * ( __int64 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@a2@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@v10@@ >= * ( _QWORD * ) ( @@a1@@ + Number ) ) abort ( ) ; * @@a3@@ = @@v10@@ ; if ( ! * @@v10@@ ) return Number L ; if ( @@a2@@ == * @@v10@@ || ( * ( unsigned __int8 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@a2@@ , * @@v10@@ ) ) { @@v13@@ = * @@v10@@ ; if ( @@a4@@ ) { if ( @@v10@@ [ Number ] ) { @@v14@@ = ( _QWORD * ) @@v10@@ [ Number ] ; @@v6@@ = @@v14@@ [ Number ] ; * @@v10@@ = * @@v14@@ ; @@v10@@ [ Number ] = @@v6@@ ; free_entry ( @@a1@@ , @@v14@@ ) ; } else { * @@v10@@ = Number L ; } } @@result@@ = @@v13@@ ; } else { for ( @@i@@ = @@v10@@ ; ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { if ( ! @@i@@ [ Number ] ) return Number L ; if ( @@a2@@ == * ( _QWORD * ) @@i@@ [ Number ] || ( * ( unsigned __int8 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@a2@@ , * ( _QWORD * ) @@i@@ [ Number ] ) ) { break ; } } @@v11@@ = * ( _QWORD * ) @@i@@ [ Number ] ; if ( @@a4@@ ) { @@v12@@ = ( _QWORD * ) @@i@@ [ Number ] ; @@i@@ [ Number ] = @@v12@@ [ Number ] ; free_entry ( @@a1@@ , @@v12@@ ) ; } @@result@@ = @@v11@@ ; } return @@result@@ ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_21F238 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
__int64 __fastcall getuidbyname ( const char * @@a1@@ ) { __int64 @@result@@ ; size_t @@v2@@ ; __int64 @@i@@ ; __int64 @@j@@ ; __int64 @@v5@@ ; struct passwd * @@v6@@ ; for ( @@i@@ = user_alist ; @@i@@ ; @@i@@ = * ( _QWORD * ) ( @@i@@ + Number ) ) { if ( * ( _BYTE * ) ( @@i@@ + Number ) == * @@a1@@ && ! strcmp ( ( const char * ) ( @@i@@ + Number ) , @@a1@@ ) ) { return @@i@@ ; } } for ( @@j@@ = nouser_alist ; @@j@@ ; @@j@@ = * ( _QWORD * ) ( @@j@@ + Number ) ) { if ( * ( _BYTE * ) ( @@j@@ + Number ) == * @@a1@@ && ! strcmp ( ( const char * ) ( @@j@@ + Number ) , @@a1@@ ) ) { return Number L ; } } @@v6@@ = getpwnam ( @@a1@@ ) ; @@v2@@ = strlen ( @@a1@@ ) ; @@v5@@ = xmalloc ( @@v2@@ + Number ) ; strcpy ( ( char * ) ( @@v5@@ + Number ) , @@a1@@ ) ; if ( @@v6@@ ) { * ( _DWORD * ) @@v5@@ = @@v6@@ -> pw_uid ; * ( _QWORD * ) ( @@v5@@ + Number ) = user_alist ; user_alist = @@v5@@ ; @@result@@ = @@v5@@ ; } else { * ( _QWORD * ) ( @@v5@@ + Number ) = nouser_alist ; nouser_alist = @@v5@@ ; @@result@@ = Number L ; } return @@result@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) _frame_dummy_init_array_entry [ @@i@@ ] ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
void * __fastcall mpsort_into_tmp ( __int64 * @@a1@@ , unsigned __int64 @@a2@@ , _QWORD * @@a3@@ , __int64 ( __fastcall * @@a4@@ ) ( __int64 , __int64 ) ) { int @@i@@ ; _QWORD * @@v5@@ ; _QWORD * @@v6@@ ; _QWORD * @@dest@@ ; unsigned __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; unsigned __int64 @@v12@@ ; __int64 @@v13@@ ; __int64 @@v14@@ ; @@dest@@ = @@a3@@ ; @@v10@@ = Number L ; @@v11@@ = @@a2@@ >> Number ; @@v12@@ = @@a2@@ >> Number ; mpsort_with_tmp ( & @@a1@@ [ @@a2@@ >> Number ] , @@a2@@ - ( @@a2@@ >> Number ) , @@a3@@ , @@a4@@ ) ; mpsort_with_tmp ( @@a1@@ , @@a2@@ >> Number , @@dest@@ , @@a4@@ ) ; @@v13@@ = * @@a1@@ ; @@v14@@ = @@a1@@ [ @@a2@@ >> Number ] ; for ( @@i@@ = @@a4@@ ( * @@a1@@ , @@v14@@ ) ; ; @@i@@ = @@a4@@ ( @@v13@@ , @@v14@@ ) ) { while ( @@i@@ > Number ) { @@v6@@ = @@dest@@ ++ ; * @@v6@@ = @@v14@@ ; if ( ++ @@v12@@ == @@a2@@ ) return memcpy ( @@dest@@ , & @@a1@@ [ @@v10@@ ] , Number * ( @@v11@@ - @@v10@@ ) ) ; @@v14@@ = @@a1@@ [ @@v12@@ ] ; @@i@@ = @@a4@@ ( @@v13@@ , @@v14@@ ) ; } @@v5@@ = @@dest@@ ++ ; * @@v5@@ = @@v13@@ ; if ( ++ @@v10@@ == @@v11@@ ) break ; @@v13@@ = @@a1@@ [ @@v10@@ ] ; } @@v10@@ = @@v12@@ ; @@v11@@ = @@a2@@ ; return memcpy ( @@dest@@ , & @@a1@@ [ @@v10@@ ] , Number * ( @@v11@@ - @@v10@@ ) ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
_BYTE * __fastcall match_suffix ( _BYTE * * @@a1@@ ) { char @@v2@@ ; _BYTE * @@v3@@ ; @@v3@@ = Number L ; @@v2@@ = Number ; while ( * * @@a1@@ ) { if ( @@v2@@ ) { @@v2@@ = Number ; if ( ( unsigned __int8 ) c_isalpha ( ( unsigned int ) ( char ) * * @@a1@@ ) != Number && * * @@a1@@ != Number ) { @@v3@@ = Number L ; } } else if ( * * @@a1@@ == Number ) { @@v2@@ = Number ; if ( ! @@v3@@ ) @@v3@@ = * @@a1@@ ; } else if ( ( unsigned __int8 ) c_isalnum ( ( unsigned int ) ( char ) * * @@a1@@ ) != Number && * * @@a1@@ != Number ) { @@v3@@ = Number L ; } ++ * @@a1@@ ; } return @@v3@@ ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 __fastcall memcpy_uppcase ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { while ( @@a3@@ -- ) * ( _BYTE * ) ( @@a1@@ + @@a3@@ ) = toupper ( * ( unsigned __int8 * ) ( @@a2@@ + @@a3@@ ) ) ; return @@a1@@ ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; FILE * @@v10@@ ; char * @@v11@@ ; if ( @@a1@@ ) { @@v1@@ = program_name ; @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = program_name ; @@v4@@ = program_name ; @@v5@@ = gettext ( String ) ; printf ( @@v5@@ , @@v4@@ , @@v3@@ ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; @@v8@@ = stdout ; @@v9@@ = gettext ( String ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = stdout ; @@v11@@ = gettext ( String ) ; fputs_unlocked ( @@v11@@ , @@v10@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
__int64 __fastcall filevercmp ( const char * @@a1@@ , const char * @@a2@@ ) { __int64 @@result@@ ; _BYTE * @@v3@@ ; _BYTE * @@v4@@ ; __int64 @@s2@@ ; __int64 @@s1@@ ; unsigned int @@v7@@ ; unsigned int @@v8@@ ; _BYTE * @@v9@@ ; _BYTE * @@v10@@ ; size_t @@n@@ ; _BYTE * @@v12@@ ; _BYTE * @@v13@@ ; _BYTE * @@v14@@ ; unsigned __int64 @@v15@@ ; @@s1@@ = ( __int64 ) @@a1@@ ; @@s2@@ = ( __int64 ) @@a2@@ ; @@v15@@ = __readfsqword ( Number ) ; @@v7@@ = strcmp ( @@a1@@ , @@a2@@ ) ; if ( ! @@v7@@ ) return Number L ; if ( ! * @@a1@@ ) return Number ; if ( ! * @@a2@@ ) return Number L ; if ( ! strcmp ( String , @@a1@@ ) ) return Number ; if ( ! strcmp ( String , @@a2@@ ) ) return Number L ; if ( ! strcmp ( String , @@a1@@ ) ) return Number ; if ( ! strcmp ( String , @@a2@@ ) ) return Number L ; if ( * @@a1@@ == Number && * @@a2@@ != Number ) return Number ; if ( * @@a1@@ != Number && * @@a2@@ == Number ) return Number L ; if ( * @@a1@@ == Number && * @@a2@@ == Number ) { @@s1@@ = ( __int64 ) ( @@a1@@ + Number ) ; @@s2@@ = ( __int64 ) ( @@a2@@ + Number ) ; } @@v9@@ = ( _BYTE * ) @@s1@@ ; @@v10@@ = ( _BYTE * ) @@s2@@ ; @@v13@@ = match_suffix ( & @@v9@@ ) ; @@v14@@ = match_suffix ( & @@v10@@ ) ; if ( @@v13@@ ) @@v3@@ = @@v13@@ ; else @@v3@@ = @@v9@@ ; @@n@@ = ( size_t ) & @@v3@@ [ - @@s1@@ ] ; if ( @@v14@@ ) @@v4@@ = @@v14@@ ; else @@v4@@ = @@v10@@ ; @@v12@@ = & @@v4@@ [ - @@s2@@ ] ; if ( ( @@v13@@ || @@v14@@ ) && ( _BYTE * ) @@n@@ == @@v12@@ && ! strncmp ( ( const char * ) @@s1@@ , ( const char * ) @@s2@@ , @@n@@ ) ) { @@n@@ = ( size_t ) & @@v9@@ [ - @@s1@@ ] ; @@v12@@ = & @@v10@@ [ - @@s2@@ ] ; } @@v8@@ = verrevcmp ( @@s1@@ , @@n@@ , @@s2@@ , ( unsigned __int64 ) @@v12@@ ) ; if ( @@v8@@ ) @@result@@ = @@v8@@ ; else @@result@@ = @@v7@@ ; return @@result@@ ; }
__int64 __fastcall nstrftime ( char * @@a1@@ , __int64 @@a2@@ , char * @@a3@@ , __int64 @@a4@@ , int @@a5@@ , int @@a6@@ ) { return strftime_case_ ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_2060C8 ; @@v8@@ [ Number ] = qword_2060D0 ; @@v8@@ [ Number ] = qword_2060D8 ; @@v8@@ [ Number ] = qword_2060E0 ; @@v8@@ [ Number ] = qword_2060E8 ; @@v8@@ [ Number ] = qword_2060F0 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_206028 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
_BYTE * __fastcall mbs_align_pad ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ ) { _BYTE * @@v3@@ ; __int64 @@v4@@ ; while ( Number ) { @@v4@@ = @@a3@@ -- ; if ( ! @@v4@@ || ( unsigned __int64 ) @@a1@@ >= @@a2@@ ) break ; @@v3@@ = @@a1@@ ++ ; * @@v3@@ = Number ; } * @@a1@@ = Number ; return @@a1@@ ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v4@@ ; @@v4@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v4@@ >= Number / @@a3@@ ) xalloc_die ( ) ; @@v4@@ += ( @@v4@@ + Number ) >> Number ; } else if ( ! @@v4@@ ) { @@v4@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v4@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v4@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall gnu_mbswidth ( const char * @@a1@@ , unsigned int @@a2@@ ) { size_t @@v2@@ ; @@v2@@ = strlen ( @@a1@@ ) ; return mbsnwidth ( @@a1@@ , @@v2@@ , @@a2@@ ) ; }
const char * __fastcall remove_suffix ( const char * @@a1@@ , const char * @@a2@@ ) { const char * @@result@@ ; const char * @@v3@@ ; const char * @@v4@@ ; @@v3@@ = & @@a1@@ [ strlen ( @@a1@@ ) ] ; @@v4@@ = & @@a2@@ [ strlen ( @@a2@@ ) ] ; while ( @@v3@@ > @@a1@@ && @@v4@@ > @@a2@@ ) { -- @@v3@@ ; @@result@@ = ( const char * ) * ( unsigned __int8 * ) -- @@v4@@ ; if ( * @@v3@@ != ( _BYTE ) @@result@@ ) return @@result@@ ; } @@result@@ = @@v3@@ ; if ( @@v3@@ > @@a1@@ ) { @@result@@ = @@v3@@ ; * @@v3@@ = Number ; } return @@result@@ ; }
_BOOL8 __fastcall c_isascii ( int @@a1@@ ) { return @@a1@@ >= Number && @@a1@@ <= Number ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
_BOOL8 __fastcall c_isalnum ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number || ( int ) ( @@a1@@ & Number ) > Number && ( int ) ( @@a1@@ & Number ) <= Number ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
_BOOL8 __fastcall c_isdigit ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
_BOOL8 __fastcall c_isprint ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
_BOOL8 __fastcall c_isupper ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 __fastcall base_name ( __int64 @@a1@@ ) { __int64 @@v1@@ ; __int64 @@result@@ ; __int64 @@v3@@ ; _BYTE * @@v4@@ ; @@v4@@ = ( _BYTE * ) last_component ( @@a1@@ ) ; if ( * @@v4@@ ) { @@v3@@ = base_len ( @@v4@@ ) ; if ( @@v4@@ [ @@v3@@ ] == Number ) ++ @@v3@@ ; @@result@@ = xstrndup ( @@v4@@ , @@v3@@ ) ; } else { @@v1@@ = base_len ( @@a1@@ ) ; @@result@@ = xstrndup ( @@a1@@ , @@v1@@ ) ; } return @@result@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
int __xstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _xstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
_BOOL8 __fastcall c_isxdigit ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number || ( int ) ( @@a1@@ & Number ) > Number && ( int ) ( @@a1@@ & Number ) <= Number ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
__int64 __fastcall bkm_scale_0 ( unsigned __int64 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( is_mul_ok ( @@a2@@ , * @@a1@@ ) ) { * @@a1@@ *= @@a2@@ ; @@result@@ = Number L ; } else { * @@a1@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return xmalloc ( @@a1@@ , @@a2@@ , @@a3@@ ) ; }
int __fastcall stat ( char * @@filename@@ , struct stat * @@stat_buf@@ ) { return __xstat ( Number , @@filename@@ , @@stat_buf@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
int __fastcall lstat ( char * @@filename@@ , struct stat * @@stat_buf@@ ) { return __lxstat ( Number , @@filename@@ , @@stat_buf@@ ) ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
unsigned __int64 __fastcall print_line ( int @@a1@@ , __int64 @@a2@@ , char @@a3@@ , int @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , const char * @@a7@@ , const char * @@a8@@ , __int64 @@a9@@ , const char * @@a10@@ ) { size_t @@v10@@ ; const char * @@v11@@ ; const char * @@v12@@ ; char * @@v13@@ ; char * @@v18@@ ; char * @@v19@@ ; char * @@v20@@ ; char @@v21@@ [ Number ] ; char @@v22@@ [ Number ] ; unsigned __int64 @@v23@@ ; @@v23@@ = __readfsqword ( Number ) ; byte_20F019 = @@a3@@ ; if ( include_idle && short_output != Number && strlen ( @@a7@@ ) <= Number ) sprintf ( @@v21@@ , String , @@a7@@ ) ; else @@v21@@ [ Number ] = Number ; if ( short_output != Number && strlen ( @@a8@@ ) <= Number ) sprintf ( @@v22@@ , String , @@a8@@ ) ; else @@v22@@ [ Number ] = Number ; if ( include_exit ) { if ( strlen ( @@a10@@ ) <= Number ) @@v10@@ = Number L ; else @@v10@@ = strlen ( @@a10@@ ) + Number ; } else { @@v10@@ = Number L ; } @@v20@@ = ( char * ) xmalloc ( @@v10@@ ) ; if ( include_exit ) sprintf ( @@v20@@ , String , @@a10@@ ) ; else * @@v20@@ = Number ; if ( include_mesg ) @@v11@@ = ( const char * ) & mesg_5665 ; else @@v11@@ = & locale ; if ( @@a2@@ ) LODWORD ( @@v12@@ ) = @@a2@@ ; else @@v12@@ = String ; if ( ( unsigned int ) rpl_asprintf ( ( unsigned int ) & @@v18@@ , ( unsigned int ) String , @@a1@@ , ( _DWORD ) @@v12@@ , ( _DWORD ) @@v11@@ , @@a4@@ , @@a5@@ , ( unsigned int ) time_format_width , @@a6@@ , @@v21@@ , @@v22@@ , @@a9@@ , @@v20@@ ) == Number ) xalloc_die ( ) ; @@v13@@ = @@v18@@ ; @@v19@@ = & @@v13@@ [ strlen ( @@v18@@ ) ] ; do -- @@v19@@ ; while ( * @@v19@@ == Number ) ; @@v19@@ [ Number ] = Number ; puts ( @@v18@@ ) ; free ( @@v18@@ ) ; free ( @@v20@@ ) ; return __readfsqword ( Number ) ^ @@v23@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_206028 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
_BOOL8 __fastcall c_isalnum ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number || ( int ) ( @@a1@@ & Number ) > Number && ( int ) ( @@a1@@ & Number ) <= Number ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
__int64 __fastcall argmatch ( const char * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { __int64 @@result@@ ; char @@v7@@ ; __int64 @@i@@ ; __int64 @@v9@@ ; size_t @@n@@ ; @@v9@@ = Number ; @@v7@@ = Number ; @@n@@ = strlen ( @@a1@@ ) ; for ( @@i@@ = Number L ; * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; ++ @@i@@ ) { if ( ! strncmp ( * ( const char * * ) ( Number * @@i@@ + @@a2@@ ) , @@a1@@ , @@n@@ ) ) { if ( @@n@@ == strlen ( * ( const char * * ) ( Number * @@i@@ + @@a2@@ ) ) ) return @@i@@ ; if ( @@v9@@ == Number ) { @@v9@@ = @@i@@ ; } else if ( ! @@a3@@ || memcmp ( ( const void * ) ( @@a4@@ * @@v9@@ + @@a3@@ ) , ( const void * ) ( @@i@@ * @@a4@@ + @@a3@@ ) , @@a4@@ ) ) { @@v7@@ = Number ; } } } if ( @@v7@@ ) @@result@@ = Number ; else @@result@@ = @@v9@@ ; return @@result@@ ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
_BOOL8 __fastcall c_iscntrl ( int @@a1@@ ) { return ( @@a1@@ & Number ) == Number || @@a1@@ == Number ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
unsigned __int64 __fastcall print_deadprocs ( __int64 @@a1@@ ) { char * @@v1@@ ; size_t @@v2@@ ; char * @@v3@@ ; size_t @@v4@@ ; unsigned int @@v5@@ ; char * @@v6@@ ; unsigned int @@v7@@ ; char * @@v8@@ ; const char * @@v9@@ ; char * @@v10@@ ; char * @@ptr@@ ; char @@s@@ [ Number ] ; unsigned __int64 @@v14@@ ; @@v14@@ = __readfsqword ( Number ) ; @@ptr@@ = make_id_equals_comment ( @@a1@@ ) ; sprintf ( @@s@@ , String , * ( int * ) ( @@a1@@ + Number ) ) ; if ( ! exitstr_5700 ) { @@v1@@ = gettext ( String ) ; @@v2@@ = strlen ( @@v1@@ ) ; @@v3@@ = gettext ( String ) ; @@v4@@ = strlen ( @@v3@@ ) ; exitstr_5700 = ( char * ) xmalloc ( @@v2@@ + @@v4@@ + Number ) ; } @@v5@@ = * ( __int16 * ) ( @@a1@@ + Number ) ; @@v6@@ = gettext ( String ) ; @@v7@@ = * ( __int16 * ) ( @@a1@@ + Number ) ; @@v8@@ = gettext ( String ) ; sprintf ( exitstr_5700 , String , @@v8@@ , @@v7@@ , @@v6@@ , @@v5@@ ) ; @@v9@@ = exitstr_5700 ; @@v10@@ = time_string ( @@a1@@ ) ; print_line ( Number , ( __int64 ) & locale , Number , Number , @@a1@@ + Number , ( __int64 ) @@v10@@ , & locale , @@s@@ , ( __int64 ) @@ptr@@ , @@v9@@ ) ; free ( @@ptr@@ ) ; return __readfsqword ( Number ) ^ @@v14@@ ; }
__int64 __fastcall _xargmatch_internal ( __int64 @@a1@@ , const char * @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ , void ( * @@a6@@ ) ( void ) ) { __int64 @@v11@@ ; @@v11@@ = argmatch ( @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; if ( @@v11@@ >= Number ) return @@v11@@ ; argmatch_invalid ( @@a1@@ , ( __int64 ) @@a2@@ , @@v11@@ ) ; argmatch_valid ( @@a3@@ , @@a4@@ , @@a5@@ ) ; @@a6@@ ( ) ; return Number ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
_BOOL8 __fastcall c_isgraph ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall argmatch_to_argument ( const void * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; ++ @@i@@ ) { if ( ! memcmp ( @@a1@@ , ( const void * ) ( @@i@@ * @@a4@@ + @@a3@@ ) , @@a4@@ ) ) return * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; } return Number L ; }
_BOOL8 __fastcall c_isprint ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
char * __fastcall scan_entries ( char * @@a1@@ , __int64 @@a2@@ ) { char * @@result@@ ; char * @@s1@@ ; time_t @@v6@@ ; @@v6@@ = Number ; if ( include_heading ) print_heading ( ) ; if ( my_line_only ) { @@result@@ = ttyname ( Number ) ; @@s1@@ = @@result@@ ; if ( ! @@result@@ ) return @@result@@ ; if ( ! strncmp ( @@result@@ , String , Number ) ) @@s1@@ += Number ; } while ( Number ) { @@result@@ = @@a1@@ -- ; if ( ! @@result@@ ) break ; if ( my_line_only != Number || ! strncmp ( @@s1@@ , ( const char * ) ( @@a2@@ + Number ) , Number ) ) { if ( need_users && * ( _BYTE * ) ( @@a2@@ + Number ) && * ( _WORD * ) @@a2@@ == Number ) { print_user ( @@a2@@ , @@v6@@ ) ; } else if ( need_runlevel && * ( _WORD * ) @@a2@@ == Number ) { print_runlevel ( @@a2@@ ) ; } else if ( need_boottime && * ( _WORD * ) @@a2@@ == Number ) { print_boottime ( @@a2@@ ) ; } else if ( need_clockchange && * ( _WORD * ) @@a2@@ == Number ) { print_clockchange ( @@a2@@ ) ; } else if ( need_initspawn && * ( _WORD * ) @@a2@@ == Number ) { print_initspawn ( @@a2@@ ) ; } else if ( need_login && * ( _WORD * ) @@a2@@ == Number ) { print_login ( @@a2@@ ) ; } else if ( need_deadprocs && * ( _WORD * ) @@a2@@ == Number ) { print_deadprocs ( @@a2@@ ) ; } } if ( * ( _WORD * ) @@a2@@ == Number ) @@v6@@ = * ( int * ) ( @@a2@@ + Number ) ; @@a2@@ += Number L ; } return @@result@@ ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
_BOOL8 __fastcall c_isspace ( int @@a1@@ ) { return @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
int __cdecl __noreturn main ( int @@argc@@ , const char * * @@argv@@ , const char * * @@envp@@ ) { char * @@v3@@ ; __int64 @@v4@@ ; char * @@v5@@ ; char * @@s@@ ; set_program_name ( * @@argv@@ , @@argv@@ , @@envp@@ ) ; setlocale ( Number , & locale ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; parse_long_options ( @@argc@@ , ( _DWORD ) @@argv@@ , ( unsigned int ) String , ( unsigned int ) String , ( _DWORD ) Version , ( unsigned int ) usage , String , Number L ) ; if ( getopt_long ( @@argc@@ , ( char * const * ) @@argv@@ , String , Number L , Number L ) != Number ) usage ( Number ) ; if ( @@argc@@ < optind + Number ) { @@v3@@ = gettext ( String ) ; error ( Number , Number , @@v3@@ ) ; usage ( Number ) ; } if ( @@argc@@ > optind + Number ) { @@v4@@ = quote ( @@argv@@ [ optind + Number ] ) ; @@v5@@ = gettext ( String ) ; error ( Number , Number , @@v5@@ , @@v4@@ ) ; usage ( Number ) ; } @@s@@ = ( char * ) base_name ( @@argv@@ [ optind ] ) ; strip_trailing_slashes ( @@s@@ ) ; if ( @@argc@@ == optind + Number && * @@s@@ != Number ) remove_suffix ( @@s@@ , @@argv@@ [ optind + Number ] ) ; puts ( @@s@@ ) ; free ( @@s@@ ) ; exit ( Number ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
__int64 __fastcall hash_get_n_buckets ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
__int64 __fastcall c_tolower ( int @@a1@@ ) { __int64 @@result@@ ; if ( @@a1@@ <= Number || @@a1@@ > Number ) @@result@@ = ( unsigned int ) @@a1@@ ; else @@result@@ = ( unsigned int ) ( @@a1@@ + Number ) ; return @@result@@ ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 __fastcall hash_get_n_buckets_used ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int64 __fastcall imaxtostr ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = @@a1@@ ; @@v4@@ = @@a2@@ + Number ; * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; if ( @@a1@@ >= Number ) { do { * ( _BYTE * ) -- @@v4@@ = ( char ) @@v3@@ % Number + Number ; @@v3@@ /= Number L ; } while ( @@v3@@ ) ; } else { do { * ( _BYTE * ) -- @@v4@@ = Number - ( char ) @@v3@@ % Number ; @@v3@@ /= Number L ; } while ( @@v3@@ ) ; * ( _BYTE * ) -- @@v4@@ = Number ; } return @@v4@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
unsigned __int64 __fastcall hash_get_max_bucket_length ( __int64 @@a1@@ ) { _QWORD * @@i@@ ; unsigned __int64 @@v3@@ ; _QWORD * @@v4@@ ; unsigned __int64 @@j@@ ; @@v3@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { @@v4@@ = @@i@@ ; for ( @@j@@ = Number L ; ; ++ @@j@@ ) { @@v4@@ = ( _QWORD * ) @@v4@@ [ Number ] ; if ( ! @@v4@@ ) break ; } if ( @@j@@ > @@v3@@ ) @@v3@@ = @@j@@ ; } } return @@v3@@ ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_206028 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
int __fastcall hash_print_statistics ( __int64 @@a1@@ , FILE * @@a2@@ ) { double @@v2@@ ; double @@v3@@ ; double @@v4@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v6@@ = hash_get_n_entries ( @@a1@@ ) ; @@v7@@ = hash_get_n_buckets ( @@a1@@ ) ; @@v8@@ = hash_get_n_buckets_used ( @@a1@@ ) ; @@v9@@ = hash_get_max_bucket_length ( @@a1@@ ) ; fprintf ( @@a2@@ , String , @@v6@@ ) ; fprintf ( @@a2@@ , String , @@v7@@ ) ; if ( @@v8@@ < Number ) @@v2@@ = ( double ) ( int ) ( @@v8@@ & Number | ( ( unsigned __int64 ) @@v8@@ >> Number ) ) + ( double ) ( int ) ( @@v8@@ & Number | ( ( unsigned __int64 ) @@v8@@ >> Number ) ) ; else @@v2@@ = ( double ) ( int ) @@v8@@ ; @@v3@@ = Number * @@v2@@ ; if ( @@v7@@ < Number ) @@v4@@ = ( double ) ( int ) ( @@v7@@ & Number | ( ( unsigned __int64 ) @@v7@@ >> Number ) ) + ( double ) ( int ) ( @@v7@@ & Number | ( ( unsigned __int64 ) @@v7@@ >> Number ) ) ; else @@v4@@ = ( double ) ( int ) @@v7@@ ; fprintf ( @@a2@@ , String , @@v8@@ , @@v3@@ / @@v4@@ ) ; return fprintf ( @@a2@@ , String , @@v9@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_2060C8 ; @@v4@@ [ Number ] = qword_2060D0 ; @@v4@@ [ Number ] = qword_2060D8 ; @@v4@@ [ Number ] = qword_2060E0 ; @@v4@@ [ Number ] = qword_2060E8 ; @@v4@@ [ Number ] = qword_2060F0 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_206028 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
__int64 __fastcall hash_do_for_each ( __int64 @@a1@@ , unsigned __int8 ( __fastcall * @@a2@@ ) ( _QWORD , __int64 ) , __int64 @@a3@@ ) { __int64 @@v5@@ ; _QWORD * @@i@@ ; _QWORD * @@j@@ ; @@v5@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = @@i@@ ; @@j@@ ; @@j@@ = ( _QWORD * ) @@j@@ [ Number ] ) { if ( @@a2@@ ( * @@j@@ , @@a3@@ ) != Number ) return @@v5@@ ; ++ @@v5@@ ; } } } return @@v5@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return xmalloc ( @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
_BOOL8 __fastcall desirable_utmp_entry ( __int64 @@a1@@ , char @@a2@@ ) { bool @@v2@@ ; @@v2@@ = * ( _BYTE * ) ( @@a1@@ + Number ) && * ( _WORD * ) @@a1@@ == Number ; if ( ( @@a2@@ & Number ) != Number && ! @@v2@@ ) return Number L ; return ( @@a2@@ & Number ) == Number || ! @@v2@@ || * ( int * ) ( @@a1@@ + Number ) > Number && ( kill ( * ( _DWORD * ) ( @@a1@@ + Number ) , Number ) >= Number || * __errno_location ( ) != Number ) ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
__int64 __fastcall hash_clear ( __int64 @@a1@@ ) { __int64 @@result@@ ; _QWORD * @@i@@ ; _QWORD * @@j@@ ; _QWORD * @@v4@@ ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = ( _QWORD * ) @@i@@ [ Number ] ; @@j@@ ; @@j@@ = @@v4@@ ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@j@@ ) ; * @@j@@ = Number L ; @@v4@@ = ( _QWORD * ) @@j@@ [ Number ] ; @@j@@ [ Number ] = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@j@@ ; } if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@i@@ ) ; * @@i@@ = Number L ; @@i@@ [ Number ] = Number L ; } } * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; @@result@@ = @@a1@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; return @@result@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
__int64 __fastcall xnrealloc ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { if ( ! is_mul_ok ( @@a3@@ , @@a2@@ ) ) xalloc_die ( ) ; return xrealloc ( @@a1@@ , @@a3@@ * @@a2@@ ) ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
char * __fastcall xstrndup ( const char * @@a1@@ , size_t @@a2@@ ) { char * @@v3@@ ; @@v3@@ = strndup ( @@a1@@ , @@a2@@ ) ; if ( ! @@v3@@ ) xalloc_die ( ) ; return @@v3@@ ; }
long double __fastcall adjust_value ( int @@a1@@ , long double @@a2@@ ) { _BOOL4 @@v7@@ ; unsigned __int64 @@v9@@ ; if ( @@a1@@ != Number && @@a2@@ < Number ) { if ( @@a2@@ >= Number ) @@v9@@ = ( __int64 ) ( @@a2@@ - Number ) ^ Number ; else @@v9@@ = ( __int64 ) @@a2@@ ; @@v7@@ = ! @@a1@@ && @@a2@@ != ( long double ) @@v9@@ ; @@a2@@ = ( long double ) ( @@v7@@ + @@v9@@ ) ; } return @@a2@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v4@@ ; @@v4@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v4@@ >= Number / @@a3@@ ) xalloc_die ( ) ; @@v4@@ += ( @@v4@@ + Number ) >> Number ; } else if ( ! @@v4@@ ) { @@v4@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v4@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v4@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
char * __fastcall group_number ( char * @@a1@@ , size_t @@a2@@ , unsigned __int8 * @@a3@@ , const char * @@a4@@ ) { char * @@i@@ ; size_t @@v5@@ ; char * @@v6@@ ; unsigned __int8 @@v10@@ ; size_t @@v11@@ ; size_t @@v12@@ ; size_t @@v13@@ ; char @@dest@@ [ Number ] ; unsigned __int64 @@v15@@ ; @@v15@@ = __readfsqword ( Number ) ; @@v11@@ = Number ; @@v13@@ = strlen ( @@a4@@ ) ; @@v12@@ = @@a2@@ ; memcpy ( @@dest@@ , @@a1@@ , @@a2@@ ) ; for ( @@i@@ = & @@a1@@ [ @@a2@@ ] ; ; memcpy ( @@i@@ , @@a4@@ , @@v13@@ ) ) { @@v10@@ = * @@a3@@ ; if ( * @@a3@@ ) { if ( @@v10@@ > Number ) @@v5@@ = @@v12@@ ; else @@v5@@ = @@v10@@ ; @@v11@@ = @@v5@@ ; ++ @@a3@@ ; } if ( @@v12@@ < @@v11@@ ) @@v11@@ = @@v12@@ ; @@v6@@ = & @@i@@ [ - @@v11@@ ] ; @@v12@@ -= @@v11@@ ; memcpy ( @@v6@@ , & @@dest@@ [ @@v12@@ ] , @@v11@@ ) ; if ( ! @@v12@@ ) break ; @@i@@ = & @@v6@@ [ - @@v13@@ ] ; } return @@v6@@ ; }
int utmpxname ( const char * @@file@@ ) { return utmpxname ( @@file@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
_BOOL8 __fastcall is_infinite_or_zerol ( long double @@a1@@ ) { return ( unsigned int ) rpl_isnanl ( * ( _TBYTE * ) & @@a1@@ ) || @@a1@@ == @@a1@@ + @@a1@@ ; }
__int64 default_block_size ( ) { __int64 @@result@@ ; if ( getenv ( String ) ) @@result@@ = Number L ; else @@result@@ = Number L ; return @@result@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
char * __fastcall extract_trimmed_name ( __int64 @@a1@@ ) { char * @@i@@ ; char * @@dest@@ ; @@dest@@ = ( char * ) xmalloc ( Number L ) ; strncpy ( @@dest@@ , ( const char * ) ( @@a1@@ + Number ) , Number ) ; @@dest@@ [ Number ] = Number ; for ( @@i@@ = & @@dest@@ [ strlen ( @@dest@@ ) ] ; @@dest@@ < @@i@@ && * ( @@i@@ - Number ) == Number ; * @@i@@ = Number ) { -- @@i@@ ; } return @@dest@@ ; }
__int64 __fastcall getuser ( __uid_t @@a1@@ ) { const char * @@v1@@ ; size_t @@v2@@ ; __int64 @@result@@ ; __int64 @@i@@ ; __int64 @@v5@@ ; struct passwd * @@v6@@ ; char * @@s@@ ; @@v5@@ = Number L ; for ( @@i@@ = user_alist ; @@i@@ ; @@i@@ = * ( _QWORD * ) ( @@i@@ + Number ) ) { if ( @@a1@@ == * ( _DWORD * ) @@i@@ ) { @@v5@@ = @@i@@ ; break ; } } if ( ! @@v5@@ ) { @@v6@@ = getpwuid ( @@a1@@ ) ; if ( @@v6@@ ) @@v1@@ = @@v6@@ -> pw_name ; else @@v1@@ = ( const char * ) & unk_19CC0 ; @@s@@ = ( char * ) @@v1@@ ; @@v2@@ = strlen ( @@v1@@ ) ; @@v5@@ = xmalloc ( @@v2@@ + Number ) ; * ( _DWORD * ) @@v5@@ = @@a1@@ ; strcpy ( ( char * ) ( @@v5@@ + Number ) , @@s@@ ) ; * ( _QWORD * ) ( @@v5@@ + Number ) = user_alist ; user_alist = @@v5@@ ; } if ( * ( _BYTE * ) ( @@v5@@ + Number ) ) @@result@@ = @@v5@@ + Number ; else @@result@@ = Number L ; return @@result@@ ; }
int puts ( const char * @@s@@ ) { return puts ( @@s@@ ) ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
unsigned __int64 __fastcall rpl_vasprintf ( void * * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { unsigned __int64 @@result@@ ; unsigned __int64 @@v4@@ ; void * @@ptr@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = __readfsqword ( Number ) ; @@ptr@@ = ( void * ) vasnprintf ( Number L , & @@v4@@ , @@a2@@ , @@a3@@ ) ; if ( ! @@ptr@@ ) return Number ; if ( @@v4@@ <= Number ) { * @@a1@@ = @@ptr@@ ; @@result@@ = @@v4@@ ; } else { free ( @@ptr@@ ) ; * __errno_location ( ) = Number ; @@result@@ = Number ; } return @@result@@ ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ ) { return xmalloc ( @@a1@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 __fastcall getgidbyname ( const char * @@a1@@ ) { __int64 @@result@@ ; size_t @@v2@@ ; __int64 @@i@@ ; __int64 @@j@@ ; __int64 @@v5@@ ; struct group * @@v6@@ ; for ( @@i@@ = group_alist ; @@i@@ ; @@i@@ = * ( _QWORD * ) ( @@i@@ + Number ) ) { if ( * ( _BYTE * ) ( @@i@@ + Number ) == * @@a1@@ && ! strcmp ( ( const char * ) ( @@i@@ + Number ) , @@a1@@ ) ) { return @@i@@ ; } } for ( @@j@@ = nogroup_alist ; @@j@@ ; @@j@@ = * ( _QWORD * ) ( @@j@@ + Number ) ) { if ( * ( _BYTE * ) ( @@j@@ + Number ) == * @@a1@@ && ! strcmp ( ( const char * ) ( @@j@@ + Number ) , @@a1@@ ) ) { return Number L ; } } @@v6@@ = getgrnam ( @@a1@@ ) ; @@v2@@ = strlen ( @@a1@@ ) ; @@v5@@ = xmalloc ( @@v2@@ + Number ) ; strcpy ( ( char * ) ( @@v5@@ + Number ) , @@a1@@ ) ; if ( @@v6@@ ) { * ( _DWORD * ) @@v5@@ = @@v6@@ -> gr_gid ; * ( _QWORD * ) ( @@v5@@ + Number ) = group_alist ; group_alist = @@v5@@ ; @@result@@ = @@v5@@ ; } else { * ( _QWORD * ) ( @@v5@@ + Number ) = nogroup_alist ; nogroup_alist = @@v5@@ ; @@result@@ = Number L ; } return @@result@@ ; }
const char * gai_strerror ( int @@ecode@@ ) { return gai_strerror ( @@ecode@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( ) ; return @@ptr@@ ; }
wctype_t wctype ( const char * @@property@@ ) { return wctype ( @@property@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; FILE * @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; __int64 @@v13@@ ; char * @@v14@@ ; if ( @@a1@@ ) { @@v1@@ = program_name ; @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = program_name ; @@v4@@ = program_name ; @@v5@@ = gettext ( String ) ; printf ( @@v5@@ , @@v4@@ , @@v3@@ ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String String String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; @@v8@@ = stdout ; @@v9@@ = gettext ( String ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = stdout ; @@v11@@ = gettext ( String ) ; fputs_unlocked ( @@v11@@ , @@v10@@ ) ; @@v12@@ = program_name ; @@v13@@ = program_name ; @@v14@@ = gettext ( String String String String ) ; printf ( @@v14@@ , @@v13@@ , @@v12@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
__int64 __fastcall xsum ( unsigned __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; if ( @@a1@@ + @@a2@@ < @@a1@@ ) @@result@@ = Number ; else @@result@@ = @@a1@@ + @@a2@@ ; return @@result@@ ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
__int64 decimal_point_char ( ) { __int64 @@result@@ ; char * @@v1@@ ; @@v1@@ = nl_langinfo ( Number ) ; if ( * @@v1@@ ) @@result@@ = ( unsigned __int8 ) * @@v1@@ ; else @@result@@ = Number L ; return @@result@@ ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; char * @@v3@@ ; FILE * @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; FILE * @@v10@@ ; char * @@v11@@ ; FILE * @@v12@@ ; char * @@v13@@ ; FILE * @@v14@@ ; char * @@v15@@ ; FILE * @@v16@@ ; char * @@v17@@ ; FILE * @@v18@@ ; char * @@v19@@ ; FILE * @@v20@@ ; char * @@v21@@ ; @@v1@@ = program_name ; if ( @@a1@@ ) { @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = gettext ( String ) ; printf ( @@v3@@ , @@v1@@ ) ; @@v4@@ = stdout ; @@v5@@ = gettext ( String String String ) ; fputs_unlocked ( @@v5@@ , @@v4@@ ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; @@v8@@ = stdout ; @@v9@@ = gettext ( String String String ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = stdout ; @@v11@@ = gettext ( String String String String String String ) ; fputs_unlocked ( @@v11@@ , @@v10@@ ) ; @@v12@@ = stdout ; @@v13@@ = gettext ( String String ) ; fputs_unlocked ( @@v13@@ , @@v12@@ ) ; @@v14@@ = stdout ; @@v15@@ = gettext ( String ) ; fputs_unlocked ( @@v15@@ , @@v14@@ ) ; @@v16@@ = stdout ; @@v17@@ = gettext ( String ) ; fputs_unlocked ( @@v17@@ , @@v16@@ ) ; @@v18@@ = stdout ; @@v19@@ = gettext ( String String String String ) ; fputs_unlocked ( @@v19@@ , @@v18@@ ) ; @@v20@@ = stdout ; @@v21@@ = gettext ( String String String String String String String String String String String String String ) ; fputs_unlocked ( @@v21@@ , @@v20@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
unsigned __int64 __fastcall print_login ( __int64 @@a1@@ ) { char * @@v1@@ ; char * @@v2@@ ; char * @@ptr@@ ; char @@s@@ [ Number ] ; unsigned __int64 @@v6@@ ; @@v6@@ = __readfsqword ( Number ) ; @@ptr@@ = make_id_equals_comment ( @@a1@@ ) ; sprintf ( @@s@@ , String , * ( int * ) ( @@a1@@ + Number ) ) ; @@v1@@ = time_string ( @@a1@@ ) ; @@v2@@ = gettext ( String ) ; print_line ( Number , ( __int64 ) @@v2@@ , Number , Number , @@a1@@ + Number , ( __int64 ) @@v1@@ , & locale , @@s@@ , ( __int64 ) @@ptr@@ , & locale ) ; free ( @@ptr@@ ) ; return __readfsqword ( Number ) ^ @@v6@@ ; }
int __fastcall stat ( char * @@filename@@ , struct stat * @@stat_buf@@ ) { return __xstat ( Number , @@filename@@ , @@stat_buf@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
__int64 __fastcall bkm_scale_by_power ( __int64 * @@a1@@ , int @@a2@@ , int @@a3@@ ) { unsigned int @@i@@ ; for ( @@i@@ = Number ; @@a3@@ -- ; @@i@@ |= bkm_scale ( @@a1@@ , @@a2@@ ) ) ; return @@i@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
unsigned __int64 __fastcall print_runlevel ( __int64 @@a1@@ ) { int @@v1@@ ; char * @@v2@@ ; size_t @@v3@@ ; char * @@v4@@ ; char * @@v5@@ ; size_t @@v6@@ ; unsigned int @@v7@@ ; char * @@v8@@ ; const char * @@v9@@ ; char * @@v10@@ ; unsigned __int8 @@v12@@ ; unsigned __int8 @@v13@@ ; @@v1@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; if ( @@v1@@ < Number ) BYTE1 ( @@v1@@ ) = ( unsigned __int16 ) ( @@v1@@ + Number ) >> Number ; @@v12@@ = BYTE1 ( @@v1@@ ) ; @@v13@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; if ( ! runlevline_5719 ) { @@v2@@ = gettext ( String ) ; @@v3@@ = strlen ( @@v2@@ ) ; runlevline_5719 = ( char * ) xmalloc ( @@v3@@ + Number ) ; } @@v4@@ = gettext ( String ) ; sprintf ( runlevline_5719 , String , @@v4@@ , @@v13@@ ) ; if ( ! comment_5720 ) { @@v5@@ = gettext ( String ) ; @@v6@@ = strlen ( @@v5@@ ) ; comment_5720 = ( char * ) xmalloc ( @@v6@@ + Number ) ; } if ( @@v12@@ == Number ) @@v7@@ = Number ; else @@v7@@ = @@v12@@ ; @@v8@@ = gettext ( String ) ; sprintf ( comment_5720 , String , @@v8@@ , @@v7@@ ) ; if ( ( unsigned __int8 ) c_isprint ( @@v12@@ ) ) @@v9@@ = comment_5720 ; else @@v9@@ = & locale ; @@v10@@ = time_string ( @@a1@@ ) ; return print_line ( Number , ( __int64 ) & locale , Number , Number , ( __int64 ) runlevline_5719 , ( __int64 ) @@v10@@ , & locale , & locale , ( __int64 ) @@v9@@ , & locale ) ; }
int toupper ( int @@c@@ ) { return toupper ( @@c@@ ) ; }
_BOOL8 __fastcall c_isupper ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 __fastcall c_toupper ( int @@a1@@ ) { __int64 @@result@@ ; if ( @@a1@@ <= Number || @@a1@@ > Number ) @@result@@ = ( unsigned int ) @@a1@@ ; else @@result@@ = ( unsigned int ) ( @@a1@@ - Number ) ; return @@result@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
char * nl_langinfo ( nl_item @@item@@ ) { return nl_langinfo ( @@item@@ ) ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_21FE88 ; @@v8@@ [ Number ] = qword_21FE90 ; @@v8@@ [ Number ] = qword_21FE98 ; @@v8@@ [ Number ] = qword_21FEA0 ; @@v8@@ [ Number ] = qword_21FEA8 ; @@v8@@ [ Number ] = qword_21FEB0 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ ) { return xmalloc ( @@a1@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall hard_locale ( int @@a1@@ ) { unsigned __int8 @@v2@@ ; const char * @@s1@@ ; @@v2@@ = Number ; @@s1@@ = setlocale ( @@a1@@ , Number L ) ; if ( @@s1@@ && ( ! strcmp ( @@s1@@ , String ) || ! strcmp ( @@s1@@ , String ) ) ) @@v2@@ = Number ; return @@v2@@ ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( ) ; return @@ptr@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
__int64 check_section ( ) { size_t @@v1@@ ; @@v1@@ = n - Number ; if ( n - Number <= Number || memcmp ( s1 , section_del , Number ) ) return Number L ; if ( @@v1@@ == header_del_len && ! memcmp ( s1 , header_del , header_del_len ) ) return Number L ; if ( @@v1@@ == body_del_len && ! memcmp ( s1 , body_del , body_del_len ) ) return Number L ; if ( @@v1@@ == footer_del_len && ! memcmp ( s1 , footer_del , footer_del_len ) ) return Number L ; return Number L ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
time_t time ( time_t * @@timer@@ ) { return time ( @@timer@@ ) ; }
void * __fastcall initbuffer ( void * @@a1@@ ) { return memset ( @@a1@@ , Number , Number ) ; }
char * nl_langinfo ( nl_item @@item@@ ) { return nl_langinfo ( @@item@@ ) ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( is_mul_ok ( @@a2@@ , * @@a1@@ ) ) { * @@a1@@ *= @@a2@@ ; @@result@@ = Number L ; } else { * @@a1@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
_BOOL8 __fastcall c_iscntrl ( int @@a1@@ ) { return ( @@a1@@ & Number ) == Number || @@a1@@ == Number ; }
__int64 * __fastcall readlinebuffer_delim ( __int64 * @@a1@@ , FILE * @@a2@@ , char @@a3@@ ) { _BYTE * @@v4@@ ; int @@v6@@ ; __int64 @@v7@@ ; _BYTE * @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; @@v7@@ = @@a1@@ [ Number ] ; @@v8@@ = ( _BYTE * ) @@v7@@ ; @@v9@@ = * @@a1@@ + @@v7@@ ; if ( feof_unlocked ( @@a2@@ ) ) return Number L ; while ( Number ) { @@v6@@ = getc_unlocked ( @@a2@@ ) ; if ( @@v6@@ == Number ) break ; LABEL_9 : if ( @@v8@@ == ( _BYTE * ) @@v9@@ ) { @@v10@@ = * @@a1@@ ; @@v7@@ = x2realloc ( @@v7@@ , @@a1@@ ) ; @@v8@@ = ( _BYTE * ) ( @@v7@@ + @@v10@@ ) ; @@a1@@ [ Number ] = @@v7@@ ; @@v9@@ = * @@a1@@ + @@v7@@ ; } @@v4@@ = @@v8@@ ++ ; * @@v4@@ = @@v6@@ ; if ( @@v6@@ == @@a3@@ ) goto LABEL_12 ; } if ( @@v8@@ == ( _BYTE * ) @@v7@@ || ferror_unlocked ( @@a2@@ ) ) return Number L ; if ( @@a3@@ != * ( @@v8@@ - Number ) ) { @@v6@@ = @@a3@@ ; goto LABEL_9 ; } LABEL_12 : @@a1@@ [ Number ] = ( __int64 ) & @@v8@@ [ - @@v7@@ ] ; return @@a1@@ ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
_BOOL8 __fastcall c_islower ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
_QWORD * __fastcall bitset_set ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { _QWORD * @@result@@ ; @@result@@ = ( _QWORD * ) ( Number * ( @@a2@@ >> Number ) + @@a1@@ ) ; * @@result@@ |= Number L << ( @@a2@@ & Number ) ; return @@result@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
_BOOL8 __fastcall c_ispunct ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number && ( @@a1@@ <= Number || @@a1@@ > Number ) && ( ( int ) ( @@a1@@ & Number ) <= Number || ( int ) ( @@a1@@ & Number ) > Number ) ; }
bool __fastcall bitset_contain ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return ( ( * ( _QWORD * ) ( Number * ( @@a2@@ >> Number ) + @@a1@@ ) >> ( @@a2@@ & Number ) ) & Number L ) != Number ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
char * __fastcall time_string ( __int64 @@a1@@ ) { time_t @@timer@@ ; struct tm * @@tp@@ ; unsigned __int64 @@v4@@ ; @@v4@@ = __readfsqword ( Number ) ; @@timer@@ = * ( int * ) ( @@a1@@ + Number ) ; @@tp@@ = localtime ( & @@timer@@ ) ; if ( ! @@tp@@ ) return ( char * ) timetostr ( @@timer@@ , ( __int64 ) buf_5650 ) ; strftime ( buf_5650 , Number , time_format , @@tp@@ ) ; return buf_5650 ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , off_1D1DE , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
__int64 __fastcall c_toupper ( int @@a1@@ ) { __int64 @@result@@ ; if ( @@a1@@ <= Number || @@a1@@ > Number ) @@result@@ = ( unsigned int ) @@a1@@ ; else @@result@@ = ( unsigned int ) ( @@a1@@ - Number ) ; return @@result@@ ; }
char * __fastcall make_id_equals_comment ( __int64 @@a1@@ ) { char * @@v1@@ ; size_t @@v2@@ ; char * @@v3@@ ; char * @@dest@@ ; @@v1@@ = gettext ( String ) ; @@v2@@ = strlen ( @@v1@@ ) ; @@dest@@ = ( char * ) xmalloc ( @@v2@@ + Number ) ; @@v3@@ = gettext ( String ) ; strcpy ( @@dest@@ , @@v3@@ ) ; strncat ( @@dest@@ , ( const char * ) ( @@a1@@ + Number ) , Number ) ; return @@dest@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_20F1A8 ; @@v4@@ [ Number ] = qword_20F1B0 ; @@v4@@ [ Number ] = qword_20F1B8 ; @@v4@@ [ Number ] = qword_20F1C0 ; @@v4@@ [ Number ] = qword_20F1C8 ; @@v4@@ [ Number ] = qword_20F1D0 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
__int64 __fastcall re_string_construct_common ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , char @@a5@@ , __int64 @@a6@@ ) { bool @@v6@@ ; __int64 @@result@@ ; * ( _QWORD * ) @@a3@@ = @@a1@@ ; * ( _QWORD * ) ( @@a3@@ + Number ) = @@a2@@ ; * ( _QWORD * ) ( @@a3@@ + Number ) = @@a2@@ ; * ( _QWORD * ) ( @@a3@@ + Number ) = @@a4@@ ; * ( _BYTE * ) ( @@a3@@ + Number ) = @@a5@@ ; @@v6@@ = @@a4@@ || @@a5@@ ; * ( _BYTE * ) ( @@a3@@ + Number ) = @@v6@@ ; * ( _DWORD * ) ( @@a3@@ + Number ) = * ( _DWORD * ) ( @@a6@@ + Number ) ; * ( _BYTE * ) ( @@a3@@ + Number ) = ( * ( _BYTE * ) ( @@a6@@ + Number ) & Number ) != Number ; * ( _BYTE * ) ( @@a3@@ + Number ) = ( * ( _BYTE * ) ( @@a6@@ + Number ) & Number ) != Number ; * ( _QWORD * ) ( @@a3@@ + Number ) = * ( _QWORD * ) ( @@a3@@ + Number ) ; @@result@@ = @@a3@@ ; * ( _QWORD * ) ( @@a3@@ + Number ) = * ( _QWORD * ) ( @@a3@@ + Number ) ; return @@result@@ ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
unsigned __int64 __fastcall print_clockchange ( __int64 @@a1@@ ) { char * @@v1@@ ; char * @@v2@@ ; @@v1@@ = time_string ( @@a1@@ ) ; @@v2@@ = gettext ( String ) ; return print_line ( Number , ( __int64 ) & locale , Number , Number , ( __int64 ) @@v2@@ , ( __int64 ) @@v1@@ , & locale , & locale , ( __int64 ) & locale , & locale ) ; }
int putchar_unlocked ( int @@c@@ ) { return putchar_unlocked ( @@c@@ ) ; }
__int64 __fastcall read_utmp ( const char * @@a1@@ , _QWORD * @@a2@@ , _QWORD * @@a3@@ , char @@a4@@ ) { __int64 @@v4@@ ; _QWORD * @@v5@@ ; struct utmpx * @@v6@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; __int64 @@v12@@ ; struct utmpx * @@v13@@ ; unsigned __int64 @@v14@@ ; @@v14@@ = __readfsqword ( Number ) ; @@v11@@ = Number L ; @@v10@@ = Number L ; @@v12@@ = Number L ; utmpxname ( @@a1@@ ) ; setutxent ( ) ; while ( Number ) { @@v13@@ = getutxent ( ) ; if ( ! @@v13@@ ) break ; if ( desirable_utmp_entry ( ( __int64 ) @@v13@@ , @@a4@@ ) ) { if ( @@v11@@ == @@v10@@ ) @@v12@@ = x2nrealloc ( @@v12@@ , & @@v10@@ , Number L ) ; @@v4@@ = @@v11@@ ++ ; @@v5@@ = ( _QWORD * ) ( Number * @@v4@@ + @@v12@@ ) ; @@v6@@ = @@v13@@ ; * @@v5@@ = * ( _QWORD * ) & @@v13@@ -> ut_type ; @@v5@@ [ Number ] = * ( _QWORD * ) & @@v6@@ -> __unused [ Number ] ; qmemcpy ( ( void * ) ( ( unsigned __int64 ) ( @@v5@@ + Number ) & Number ) , ( const void * ) ( ( char * ) @@v6@@ - ( ( char * ) @@v5@@ - ( ( unsigned __int64 ) ( @@v5@@ + Number ) & Number ) ) ) , Number L * ( ( ( ( _DWORD ) @@v5@@ - ( ( ( _DWORD ) @@v5@@ + Number ) & Number ) + Number ) & Number ) >> Number ) ) ; } } endutxent ( ) ; * @@a2@@ = @@v11@@ ; * @@a3@@ = @@v12@@ ; return Number L ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
int __fastcall list_entries_who ( __int64 @@a1@@ , __int64 @@a2@@ ) { char * @@v3@@ ; __int64 @@v7@@ ; const char * @@v8@@ ; char * @@ptr@@ ; @@v7@@ = Number L ; @@v8@@ = & locale ; while ( @@a1@@ -- ) { if ( * ( _BYTE * ) ( @@a2@@ + Number ) && * ( _WORD * ) @@a2@@ == Number ) { @@ptr@@ = ( char * ) extract_trimmed_name ( @@a2@@ ) ; printf ( String , @@v8@@ , @@ptr@@ ) ; free ( @@ptr@@ ) ; @@v8@@ = String ; ++ @@v7@@ ; } @@a2@@ += Number L ; } @@v3@@ = gettext ( String ) ; return printf ( @@v3@@ , @@v7@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
__int64 __fastcall bad_cast ( __int64 @@a1@@ ) { return @@a1@@ ; }
unsigned __int64 __fastcall xmax ( unsigned __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { unsigned __int64 @@result@@ ; @@result@@ = @@a2@@ ; if ( @@a1@@ >= @@a2@@ ) @@result@@ = @@a1@@ ; return @@result@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__int64 __fastcall re_string_fetch_byte_case ( __int64 @@a1@@ ) { __int64 @@v1@@ ; __int64 @@v2@@ ; __int64 @@result@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; unsigned int @@v13@@ ; if ( * ( _BYTE * ) ( @@a1@@ + Number ) ) { if ( * ( _BYTE * ) ( @@a1@@ + Number ) ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) == * ( _QWORD * ) ( @@a1@@ + Number ) || * ( _DWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L * * ( _QWORD * ) ( @@a1@@ + Number ) ) != Number ) { @@v13@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) @@a1@@ + * ( _QWORD * ) ( @@a1@@ + Number ) + * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L * * ( _QWORD * ) ( @@a1@@ + Number ) ) ) ; if ( ( @@v13@@ & Number ) != Number ) { @@v6@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v7@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v7@@ + Number ; @@result@@ = * ( unsigned __int8 * ) ( @@v6@@ + @@v7@@ ) ; } else { @@v8@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v8@@ + ( int ) re_string_char_size_at ( @@a1@@ , @@v8@@ ) ; @@result@@ = @@v13@@ ; } } else { @@v4@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v5@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v5@@ + Number ; @@result@@ = * ( unsigned __int8 * ) ( @@v4@@ + @@v5@@ ) ; } } else { @@v9@@ = * ( _QWORD * ) @@a1@@ ; @@v10@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v11@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v11@@ + Number ; @@result@@ = * ( unsigned __int8 * ) ( @@v9@@ + @@v10@@ + @@v11@@ ) ; } } else { @@v1@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v2@@ + Number ; @@result@@ = * ( unsigned __int8 * ) ( @@v1@@ + @@v2@@ ) ; } return @@result@@ ; }
__int64 __fastcall xsum_0 ( unsigned __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; if ( @@a1@@ + @@a2@@ < @@a1@@ ) @@result@@ = Number ; else @@result@@ = @@a1@@ + @@a2@@ ; return @@result@@ ; }
unsigned __int64 __fastcall who ( __int64 @@a1@@ , unsigned int @@a2@@ ) { int * @@v2@@ ; char * @@v4@@ ; void * @@ptr@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = __readfsqword ( Number ) ; if ( ( unsigned int ) read_utmp ( @@a1@@ , & @@v4@@ , & @@ptr@@ , @@a2@@ ) ) { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , off_BC43 , @@a1@@ ) ; } if ( short_list ) list_entries_who ( ( __int64 ) @@v4@@ , ( __int64 ) @@ptr@@ ) ; else scan_entries ( @@v4@@ , ( __int64 ) @@ptr@@ ) ; free ( @@ptr@@ ) ; return __readfsqword ( Number ) ^ @@v6@@ ; }
int iswlower ( wint_t @@wc@@ ) { return iswlower ( @@wc@@ ) ; }
int __cdecl __noreturn main ( int @@argc@@ , const char * * @@argv@@ , const char * * @@envp@@ ) { int @@v3@@ ; char * @@v4@@ ; int * @@v5@@ ; int @@argca@@ ; int @@i@@ ; @@argca@@ = @@argc@@ ; set_program_name ( * @@argv@@ , @@argv@@ , @@envp@@ ) ; setlocale ( Number , & locale ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; parse_long_options ( @@argc@@ , ( _DWORD ) @@argv@@ , ( unsigned int ) String , ( unsigned int ) String , ( _DWORD ) Version , ( unsigned int ) usage , String , Number L ) ; if ( getopt_long ( @@argc@@ , ( char * const * ) @@argv@@ , String , Number L , Number L ) != Number ) usage ( Number ) ; if ( @@argc@@ <= optind ) { optind = @@argc@@ ; @@argca@@ = @@argc@@ + Number ; @@argv@@ [ @@argc@@ ] = ( const char * ) bad_cast ( ( __int64 ) String ) ; } while ( Number ) { for ( @@i@@ = optind ; @@i@@ < @@argca@@ ; ++ @@i@@ ) { if ( fputs_unlocked ( @@argv@@ [ @@i@@ ] , stdout ) != Number ) { @@v3@@ = @@i@@ == @@argca@@ - Number ? Number : Number ; if ( putchar_unlocked ( @@v3@@ ) != Number ) continue ; } @@v4@@ = gettext ( String ) ; @@v5@@ = __errno_location ( ) ; error ( Number , * @@v5@@ , @@v4@@ ) ; exit ( Number ) ; } } }
__int64 __fastcall re_node_set_compare ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v3@@ ; if ( ! @@a1@@ || ! @@a2@@ || * ( _QWORD * ) ( @@a1@@ + Number ) != * ( _QWORD * ) ( @@a2@@ + Number ) ) { return Number L ; } @@v3@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; while ( ( unsigned __int64 ) -- @@v3@@ <= Number ) { if ( * ( _QWORD * ) ( Number * @@v3@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) != * ( _QWORD * ) ( Number * @@v3@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) ) return Number L ; } return Number L ; }
_QWORD * __fastcall bitset_clear ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { _QWORD * @@result@@ ; @@result@@ = ( _QWORD * ) ( Number * ( @@a2@@ >> Number ) + @@a1@@ ) ; * @@result@@ &= ~ ( Number L << ( @@a2@@ & Number ) ) ; return @@result@@ ; }
_BOOL8 __fastcall c_isascii ( int @@a1@@ ) { return @@a1@@ >= Number && @@a1@@ <= Number ; }
void clearerr_unlocked ( FILE * @@stream@@ ) { clearerr_unlocked ( @@stream@@ ) ; }
void * __fastcall bitset_set_all ( void * @@a1@@ ) { return memset ( @@a1@@ , Number , Number ) ; }
__int64 __fastcall calc_state_hash ( __int64 @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v3@@ ; unsigned __int64 @@i@@ ; @@v3@@ = * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ ; for ( @@i@@ = Number L ; @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; ++ @@i@@ ) @@v3@@ += * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) ; return @@v3@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
_BOOL8 __fastcall c_isalpha ( int @@a1@@ ) { return ( int ) ( @@a1@@ & Number ) > Number && ( int ) ( @@a1@@ & Number ) <= Number ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
_QWORD * __fastcall bitset_mask ( __int64 @@a1@@ , __int64 @@a2@@ ) { _QWORD * @@result@@ ; int @@i@@ ; for ( @@i@@ = Number ; @@i@@ <= Number ; ++ @@i@@ ) { @@result@@ = ( _QWORD * ) ( Number L * @@i@@ + @@a1@@ ) ; * @@result@@ &= * ( _QWORD * ) ( Number L * @@i@@ + @@a2@@ ) ; } return @@result@@ ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
_BOOL8 __fastcall c_isblank ( int @@a1@@ ) { return @@a1@@ == Number || @@a1@@ == Number ; }
int tolower ( int @@c@@ ) { return tolower ( @@c@@ ) ; }
_BOOL8 __fastcall c_isdigit ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
wint_t btowc ( int @@c@@ ) { return btowc ( @@c@@ ) ; }
__int64 __fastcall re_string_allocate ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , unsigned __int64 @@a4@@ , __int64 @@a5@@ , unsigned __int8 @@a6@@ , __int64 @@a7@@ ) { unsigned __int64 @@v7@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; unsigned int @@v13@@ ; unsigned __int64 @@v14@@ ; @@v11@@ = @@a4@@ ; if ( @@a4@@ < * ( int * ) ( @@a7@@ + Number ) ) @@v11@@ = * ( int * ) ( @@a7@@ + Number ) ; @@v7@@ = @@a3@@ + Number ; if ( @@v11@@ <= @@a3@@ + Number ) @@v7@@ = @@v11@@ ; @@v14@@ = @@v7@@ ; re_string_construct_common ( @@a2@@ , @@a3@@ , @@a1@@ , @@a5@@ , @@a6@@ , @@a7@@ ) ; @@v13@@ = re_string_realloc_buffers ( @@a1@@ , @@v14@@ ) ; if ( @@v13@@ ) return @@v13@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@a7@@ + Number ; * ( _BYTE * ) ( @@a1@@ + Number ) = ( * ( _BYTE * ) ( @@a7@@ + Number ) & Number ) != Number ; if ( * ( _BYTE * ) ( @@a1@@ + Number ) ) @@v9@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; else @@v9@@ = @@a2@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v9@@ ; if ( * ( _BYTE * ) ( @@a1@@ + Number ) || * ( int * ) ( @@a7@@ + Number ) > Number ) @@v10@@ = Number L ; else @@v10@@ = @@a3@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v10@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = * ( _QWORD * ) ( @@a1@@ + Number ) ; return Number L ; }
__int64 __fastcall register_state ( _QWORD * @@a1@@ , _QWORD * @@a2@@ , __int64 @@a3@@ ) { __int64 @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; unsigned __int64 @@i@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; void * @@v12@@ ; __int64 @@v13@@ ; * @@a2@@ = @@a3@@ ; if ( ( unsigned int ) re_node_set_alloc ( @@a2@@ + Number , @@a2@@ [ Number ] ) ) return Number L ; for ( @@i@@ = Number L ; @@i@@ < @@a2@@ [ Number ] ; ++ @@i@@ ) { @@v13@@ = * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ [ Number ] ) ; if ( ( * ( _BYTE * ) ( Number * @@v13@@ + * @@a1@@ + Number ) & Number ) == Number && ( unsigned __int8 ) re_node_set_insert_last ( ( __int64 ) ( @@a2@@ + Number ) , @@v13@@ ) != Number ) { return Number L ; } } @@v10@@ = @@a1@@ [ Number ] + Number * ( @@a3@@ & @@a1@@ [ Number ] ) ; if ( * ( _QWORD * ) ( @@v10@@ + Number ) <= * ( _QWORD * ) @@v10@@ ) { @@v4@@ = * ( _QWORD * ) @@v10@@ + Number L ; @@v11@@ = Number * @@v4@@ ; @@v12@@ = realloc ( * ( void * * ) ( @@v10@@ + Number ) , Number * @@v4@@ ) ; if ( ! @@v12@@ ) return Number L ; * ( _QWORD * ) ( @@v10@@ + Number ) = @@v12@@ ; * ( _QWORD * ) ( @@v10@@ + Number ) = @@v11@@ ; } @@v5@@ = * ( _QWORD * ) ( @@v10@@ + Number ) ; @@v6@@ = ( * ( _QWORD * ) @@v10@@ ) ++ ; * ( _QWORD * ) ( @@v5@@ + Number * @@v6@@ ) = @@a2@@ ; return Number L ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
_BOOL8 __fastcall c_islower ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall re_string_peek_byte_case ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; __int64 @@v3@@ ; if ( ! * ( _BYTE * ) ( @@a1@@ + Number ) ) return * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ ) ; if ( * ( int * ) ( @@a1@@ + Number ) > Number && ( * ( _DWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ ) ) == Number || * ( _QWORD * ) ( @@a1@@ + Number ) != * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ + Number && * ( _DWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ + Number ) ) == Number ) ) { return * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ ) ; } @@v3@@ = * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ ; if ( * ( _BYTE * ) ( @@a1@@ + Number ) ) @@v3@@ = * ( _QWORD * ) ( Number * @@v3@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) ; if ( * ( _BYTE * ) ( @@a1@@ + Number ) && ( * ( _BYTE * ) ( * ( _QWORD * ) @@a1@@ + * ( _QWORD * ) ( @@a1@@ + Number ) + @@v3@@ ) & Number ) != Number ) { @@result@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ ) ; } else { @@result@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) @@a1@@ + * ( _QWORD * ) ( @@a1@@ + Number ) + @@v3@@ ) ; } return @@result@@ ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_2060C8 ; @@v8@@ [ Number ] = qword_2060D0 ; @@v8@@ [ Number ] = qword_2060D8 ; @@v8@@ [ Number ] = qword_2060E0 ; @@v8@@ [ Number ] = qword_2060E8 ; @@v8@@ [ Number ] = qword_2060F0 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
_BOOL8 __fastcall c_ispunct ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number && ( @@a1@@ <= Number || @@a1@@ > Number ) && ( ( int ) ( @@a1@@ & Number ) <= Number || ( int ) ( @@a1@@ & Number ) > Number ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
void __fastcall free_dfa_content ( __int64 @@a1@@ ) { unsigned __int64 @@i@@ ; unsigned __int64 @@j@@ ; unsigned __int64 @@k@@ ; unsigned __int64 @@l@@ ; __int64 @@v5@@ ; if ( * ( _QWORD * ) @@a1@@ ) { for ( @@i@@ = Number L ; @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; ++ @@i@@ ) free_token ( Number * @@i@@ + * ( _QWORD * ) @@a1@@ ) ; } free ( * ( void * * ) ( @@a1@@ + Number ) ) ; for ( @@j@@ = Number L ; @@j@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; ++ @@j@@ ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) free ( * ( void * * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@j@@ + Number ) ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) free ( * ( void * * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@j@@ + Number ) ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) free ( * ( void * * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@j@@ + Number ) ) ; } free ( * ( void * * ) ( @@a1@@ + Number ) ) ; free ( * ( void * * ) ( @@a1@@ + Number ) ) ; free ( * ( void * * ) ( @@a1@@ + Number ) ) ; free ( * ( void * * ) @@a1@@ ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) { for ( @@k@@ = Number L ; @@k@@ <= * ( _QWORD * ) ( @@a1@@ + Number ) ; ++ @@k@@ ) { @@v5@@ = * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@k@@ ; for ( @@l@@ = Number L ; @@l@@ < * ( _QWORD * ) @@v5@@ ; ++ @@l@@ ) free_state ( * ( void * * * ) ( Number * @@l@@ + * ( _QWORD * ) ( @@v5@@ + Number ) ) ) ; free ( * ( void * * ) ( @@v5@@ + Number ) ) ; } } free ( * ( void * * ) ( @@a1@@ + Number ) ) ; if ( * ( _UNKNOWN * * ) ( @@a1@@ + Number ) != & utf8_sb_map ) free ( * ( void * * ) ( @@a1@@ + Number ) ) ; free ( * ( void * * ) ( @@a1@@ + Number ) ) ; free ( ( void * ) @@a1@@ ) ; }
unsigned __int64 __fastcall re_node_set_contains ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { unsigned __int64 @@result@@ ; unsigned __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; if ( ( unsigned __int64 ) ( * ( _QWORD * ) ( @@a1@@ + Number ) - Number L ) > Number ) return Number L ; @@v3@@ = Number L ; @@v4@@ = * ( _QWORD * ) ( @@a1@@ + Number ) - Number L ; while ( @@v3@@ < @@v4@@ ) { if ( @@a2@@ <= * ( _QWORD * ) ( Number * ( ( @@v3@@ + @@v4@@ ) >> Number ) + * ( _QWORD * ) ( @@a1@@ + Number ) ) ) @@v4@@ = ( @@v3@@ + @@v4@@ ) >> Number ; else @@v3@@ = ( ( @@v3@@ + @@v4@@ ) >> Number ) + Number ; } if ( @@a2@@ == * ( _QWORD * ) ( Number * @@v3@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) ) @@result@@ = @@v3@@ + Number ; else @@result@@ = Number L ; return @@result@@ ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
__int64 __fastcall process_file ( __int64 @@a1@@ ) { int @@v1@@ ; __int64 @@result@@ ; while ( Number ) { @@result@@ = readlinebuffer ( & line_buf , @@a1@@ ) ; if ( ! @@result@@ ) break ; @@v1@@ = check_section ( ) ; if ( @@v1@@ == Number ) { proc_body ( ) ; } else if ( @@v1@@ ) { if ( @@v1@@ == Number ) { proc_footer ( ) ; } else if ( @@v1@@ == Number ) { proc_text ( ) ; } } else { proc_header ( ) ; } } return @@result@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall calc_next ( __int64 a1 , __int64 @@a2@@ ) { int @@v2@@ ; @@v2@@ = * ( unsigned __int8 * ) ( @@a2@@ + Number ) ; if ( @@v2@@ == Number ) { * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) = @@a2@@ ; } else if ( @@v2@@ == Number ) { * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) ; * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) = * ( _QWORD * ) ( @@a2@@ + Number ) ; } else { if ( * ( _QWORD * ) ( @@a2@@ + Number ) ) * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) ) * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) = * ( _QWORD * ) ( @@a2@@ + Number ) ; } return Number L ; }
__int64 __fastcall re_acquire_state_context ( _DWORD * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , unsigned int @@a4@@ ) { __int64 @@result@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ ; unsigned __int64 * @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; if ( * ( _QWORD * ) ( @@a3@@ + Number ) ) { @@v8@@ = calc_state_hash ( @@a3@@ , @@a4@@ ) ; @@v9@@ = ( unsigned __int64 * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number * ( @@v8@@ & * ( _QWORD * ) ( @@a2@@ + Number ) ) ) ; for ( @@i@@ = Number L ; @@i@@ < * @@v9@@ ; ++ @@i@@ ) { @@v11@@ = * ( _QWORD * ) ( Number * @@i@@ + @@v9@@ [ Number ] ) ; if ( @@v8@@ == * ( _QWORD * ) @@v11@@ && @@a4@@ == ( * ( _BYTE * ) ( @@v11@@ + Number ) & Number ) && ( unsigned __int8 ) re_node_set_compare ( * ( _QWORD * ) ( @@v11@@ + Number ) , @@a3@@ ) ) { return @@v11@@ ; } } @@v10@@ = create_cd_newstate ( @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ ) ; if ( ! @@v10@@ ) * @@a1@@ = Number ; @@result@@ = @@v10@@ ; } else { * @@a1@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall canon_host ( __int64 @@a1@@ ) { return canon_host_r ( @@a1@@ , & last_cherror ) ; }
int puts ( const char * @@s@@ ) { return puts ( @@s@@ ) ; }
__int64 __fastcall nl_file ( const char * @@a1@@ ) { int * @@v1@@ ; FILE * @@stream@@ ; if ( ! strcmp ( @@a1@@ , String ) ) { have_read_stdin = Number ; @@stream@@ = stdin ; process_file ( ( __int64 ) stdin ) ; } else { @@stream@@ = fopen ( @@a1@@ , String ) ; if ( ! @@stream@@ ) goto LABEL_10 ; process_file ( ( __int64 ) @@stream@@ ) ; } if ( ferror_unlocked ( @@stream@@ ) ) goto LABEL_10 ; if ( strcmp ( @@a1@@ , String ) ) { if ( fclose ( @@stream@@ ) != Number ) return Number L ; LABEL_10 : @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@a1@@ ) ; return Number L ; } clearerr_unlocked ( @@stream@@ ) ; return Number L ; }
__int64 __fastcall calc_inveclosure ( _QWORD * @@a1@@ ) { unsigned __int64 @@j@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@k@@ ; __int64 @@v5@@ ; for ( @@i@@ = Number L ; @@i@@ < @@a1@@ [ Number ] ; ++ @@i@@ ) memset ( ( void * ) ( @@a1@@ [ Number ] + Number * @@i@@ ) , Number , Number ) ; for ( @@j@@ = Number L ; @@j@@ < @@a1@@ [ Number ] ; ++ @@j@@ ) { @@v5@@ = * ( _QWORD * ) ( @@a1@@ [ Number ] + Number * @@j@@ + Number ) ; for ( @@k@@ = Number L ; @@k@@ < * ( _QWORD * ) ( @@a1@@ [ Number ] + Number * @@j@@ + Number ) ; ++ @@k@@ ) { if ( ( unsigned __int8 ) re_node_set_insert_last ( @@a1@@ [ Number ] + Number L * * ( _QWORD * ) ( Number * @@k@@ + @@v5@@ ) , @@j@@ ) != Number ) return Number L ; } } return Number L ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
size_t __fastcall rpl_regerror ( int @@a1@@ , __int64 a2 , _BYTE * @@a3@@ , size_t @@a4@@ ) { size_t @@n@@ ; const char * @@s@@ ; size_t @@v9@@ ; if ( @@a1@@ < Number || @@a1@@ > Number ) abort ( ) ; @@s@@ = gettext ( & _re_error_msgid [ _re_error_msgid_idx [ @@a1@@ ] ] ) ; @@v9@@ = strlen ( @@s@@ ) + Number ; if ( @@a4@@ ) { @@n@@ = @@v9@@ ; if ( @@v9@@ > @@a4@@ ) { @@n@@ = @@a4@@ - Number ; @@a3@@ [ @@a4@@ - Number ] = Number ; } memcpy ( @@a3@@ , @@s@@ , @@n@@ ) ; } return @@v9@@ ; }
char * __fastcall canon_host_r ( const char * @@a1@@ , int * @@a2@@ ) { char * @@v2@@ ; int @@v4@@ ; struct addrinfo * @@pai@@ ; char * @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ = Number L ; @@pai@@ = Number L ; hints_3123 . ai_flags = Number ; @@v4@@ = getaddrinfo ( @@a1@@ , Number L , & hints_3123 , & @@pai@@ ) ; if ( @@v4@@ ) { if ( @@a2@@ ) * @@a2@@ = @@v4@@ ; } else { if ( @@pai@@ -> ai_canonname ) @@v2@@ = @@pai@@ -> ai_canonname ; else @@v2@@ = ( char * ) @@a1@@ ; @@v6@@ = strdup ( @@v2@@ ) ; if ( ! @@v6@@ && @@a2@@ ) * @@a2@@ = Number ; freeaddrinfo ( @@pai@@ ) ; } return @@v6@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
__int64 __fastcall parse ( __int64 @@a1@@ , __int64 * @@a2@@ , __int64 @@a3@@ , _DWORD * @@a4@@ ) { __int64 @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; char @@v11@@ [ Number ] ; unsigned __int64 @@v12@@ ; @@v12@@ = __readfsqword ( Number ) ; @@v8@@ = * @@a2@@ ; * ( _QWORD * ) ( * @@a2@@ + Number ) = @@a3@@ ; fetch_token ( ( __int64 ) @@v11@@ , @@a1@@ , @@a3@@ | Number ) ; @@v9@@ = parse_reg_exp ( @@a1@@ , @@a2@@ , @@v11@@ , @@a3@@ , Number L , @@a4@@ ) ; if ( * @@a4@@ && ! @@v9@@ ) return Number L ; @@v10@@ = create_tree ( @@v8@@ , Number L , Number L , Number L ) ; if ( @@v9@@ ) @@v7@@ = create_tree ( @@v8@@ , @@v9@@ , @@v10@@ , Number L ) ; else @@v7@@ = @@v10@@ ; if ( @@v10@@ && @@v7@@ ) return @@v7@@ ; * @@a4@@ = Number ; return Number L ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall init_dfa ( void * * @@a1@@ , unsigned __int64 @@a2@@ ) { __int64 @@result@@ ; int @@v3@@ ; int @@i@@ ; int @@c@@ ; wint_t @@v6@@ ; size_t @@size@@ ; const char * @@s1@@ ; memset ( @@a1@@ , Number , Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = Number ; if ( @@a2@@ >= Number ) return Number L ; @@a1@@ [ Number ] = ( void * ) ( @@a2@@ + Number ) ; * @@a1@@ = malloc ( Number L * ( _QWORD ) @@a1@@ [ Number ] ) ; for ( @@size@@ = Number L ; @@size@@ <= @@a2@@ ; @@size@@ *= Number L ) ; @@a1@@ [ Number ] = calloc ( Number , @@size@@ ) ; @@a1@@ [ Number ] = ( void * ) ( @@size@@ - Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = __ctype_get_mb_cur_max ( ) ; @@s1@@ = nl_langinfo ( Number ) ; if ( ! strcasecmp ( @@s1@@ , String ) || ! strcasecmp ( @@s1@@ , String ) ) * ( ( _BYTE * ) @@a1@@ + Number ) |= Number ; * ( ( _BYTE * ) @@a1@@ + Number ) &= Number ; if ( * ( ( int * ) @@a1@@ + Number ) > Number ) { if ( ( ( _BYTE ) @@a1@@ [ Number ] & Number ) != Number ) { @@a1@@ [ Number ] = & utf8_sb_map ; } else { @@a1@@ [ Number ] = calloc ( Number , Number ) ; if ( ! @@a1@@ [ Number ] ) return Number L ; @@v3@@ = Number ; @@c@@ = Number ; while ( @@v3@@ <= Number ) { for ( @@i@@ = Number ; @@i@@ <= Number ; ++ @@i@@ ) { @@v6@@ = btowc ( @@c@@ ) ; if ( @@v6@@ != Number ) * ( ( _QWORD * ) @@a1@@ [ Number ] + @@v3@@ ) |= Number L << @@i@@ ; if ( ( @@c@@ & Number ) == Number && @@v6@@ != @@c@@ ) * ( ( _BYTE * ) @@a1@@ + Number ) |= Number ; ++ @@c@@ ; } ++ @@v3@@ ; } } } if ( * @@a1@@ && @@a1@@ [ Number ] ) @@result@@ = Number L ; else @@result@@ = Number L ; return @@result@@ ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
__int64 __fastcall build_collating_symbol ( __int64 @@a1@@ , __int64 a2 , __int64 a3 , const char * @@a4@@ ) { if ( strlen ( @@a4@@ ) != Number ) return Number L ; bitset_set ( @@a1@@ , * ( unsigned __int8 * ) @@a4@@ ) ; return Number L ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
__int64 __fastcall calc_first ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { __int64 @@v3@@ ; if ( * ( ( _BYTE * ) @@a2@@ + Number ) == Number ) { @@a2@@ [ Number ] = * ( _QWORD * ) ( @@a2@@ [ Number ] + Number L ) ; @@a2@@ [ Number ] = * ( _QWORD * ) ( @@a2@@ [ Number ] + Number L ) ; } else { @@a2@@ [ Number ] = @@a2@@ ; @@a2@@ [ Number ] = re_dfa_add_node ( ( __int64 ) @@a1@@ , @@a2@@ [ Number ] , @@a2@@ [ Number ] ) ; if ( @@a2@@ [ Number ] == Number ) return Number L ; if ( * ( ( _BYTE * ) @@a2@@ + Number ) == Number ) { @@v3@@ = Number L * @@a2@@ [ Number ] + * @@a1@@ ; * ( _DWORD * ) ( @@v3@@ + Number ) = ( ( @@a2@@ [ Number ] & Number ) << Number ) | * ( _DWORD * ) ( @@v3@@ + Number ) & Number ; } } return Number L ; }
__int64 __fastcall parse_bracket_element ( __int64 @@a1@@ , __int64 @@a2@@ , _BYTE * @@a3@@ , int @@a4@@ , __int64 a5 , char @@a6@@ , char @@a7@@ ) { __int64 @@result@@ ; int @@v11@@ ; char @@v12@@ [ Number ] ; unsigned __int64 @@v13@@ ; @@v13@@ = __readfsqword ( Number ) ; @@v11@@ = re_string_char_size_at ( @@a2@@ , * ( _QWORD * ) ( @@a2@@ + Number ) ) ; if ( @@v11@@ <= Number ) { * ( _QWORD * ) ( @@a2@@ + Number ) += @@a4@@ ; if ( @@a3@@ [ Number ] == Number || @@a3@@ [ Number ] == Number || @@a3@@ [ Number ] == Number ) { @@result@@ = parse_bracket_symbol ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } else if ( @@a3@@ [ Number ] == Number && @@a7@@ != Number && ( peek_token_bracket ( @@v12@@ , @@a2@@ , @@a6@@ ) , @@v12@@ [ Number ] != Number ) ) { @@result@@ = Number L ; } else { * ( _DWORD * ) @@a1@@ = Number ; * ( _BYTE * ) ( @@a1@@ + Number ) = * @@a3@@ ; @@result@@ = Number L ; } } else { * ( _DWORD * ) @@a1@@ = Number ; * ( _DWORD * ) ( @@a1@@ + Number ) = re_string_wchar_at ( @@a2@@ , * ( _QWORD * ) ( @@a2@@ + Number ) ) ; * ( _QWORD * ) ( @@a2@@ + Number ) += @@v11@@ ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_221088 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_20F038 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
__int64 __fastcall search_duplicated_node ( _QWORD * @@a1@@ , __int64 @@a2@@ , int @@a3@@ ) { __int64 @@i@@ ; for ( @@i@@ = @@a1@@ [ Number ] - Number L ; ( * ( _BYTE * ) ( Number * @@i@@ + * @@a1@@ + Number ) & Number ) != Number && @@i@@ ; -- @@i@@ ) { if ( @@a2@@ == * ( _QWORD * ) ( Number * @@i@@ + @@a1@@ [ Number ] ) && @@a3@@ == ( ( * ( _DWORD * ) ( Number * @@i@@ + * @@a1@@ + Number ) >> Number ) & Number ) ) { return @@i@@ ; } } return Number ; }
__int64 __fastcall rpl_regexec ( __int64 @@a1@@ , const char * @@a2@@ , __int64 @@a3@@ , __int64 * @@a4@@ , int @@a5@@ ) { int @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; if ( ( @@a5@@ & Number ) != Number ) return Number L ; if ( ( @@a5@@ & Number ) != Number ) { @@v10@@ = * @@a4@@ ; @@v11@@ = @@a4@@ [ Number ] ; } else { LODWORD ( @@v10@@ ) = Number ; LODWORD ( @@v11@@ ) = strlen ( @@a2@@ ) ; } if ( ( * ( _BYTE * ) ( @@a1@@ + Number ) & Number ) != Number ) @@v9@@ = re_search_internal ( @@a1@@ , ( _DWORD ) @@a2@@ , @@v11@@ , @@v10@@ , @@v11@@ , @@v11@@ , Number L , Number L , @@a5@@ ) ; else @@v9@@ = re_search_internal ( @@a1@@ , ( _DWORD ) @@a2@@ , @@v11@@ , @@v10@@ , @@v11@@ , @@v11@@ , @@a3@@ , ( __int64 ) @@a4@@ , @@a5@@ ) ; return @@v9@@ != Number ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@v3@@ ; @@v3@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v3@@ ) xalloc_die ( ) ; return @@v3@@ ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_221588 ; @@v8@@ [ Number ] = qword_221590 ; @@v8@@ [ Number ] = qword_221598 ; @@v8@@ [ Number ] = qword_2215A0 ; @@v8@@ [ Number ] = qword_2215A8 ; @@v8@@ [ Number ] = qword_2215B0 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
__int64 __fastcall calc_eclosure ( __int64 @@a1@@ ) { char @@v2@@ ; unsigned int @@v3@@ ; __int64 @@i@@ ; char @@v5@@ [ Number ] ; void * @@ptr@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v2@@ = Number ; for ( @@i@@ = Number L ; ; ++ @@i@@ ) { if ( @@i@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ) { if ( @@v2@@ != Number ) return Number L ; @@v2@@ = Number ; @@i@@ = Number L ; } if ( ! * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@i@@ + Number ) ) break ; LABEL_11 : ; } @@v3@@ = calc_eclosure_iter ( @@v5@@ , @@a1@@ , @@i@@ , Number L ) ; if ( ! @@v3@@ ) { if ( ! * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@i@@ + Number ) ) { @@v2@@ = Number ; free ( @@ptr@@ ) ; } goto LABEL_11 ; } return @@v3@@ ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
__int64 __fastcall prune_impossible_nodes ( __int64 @@a1@@ ) { unsigned int @@v2@@ ; __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; _QWORD * @@v5@@ ; _QWORD * @@s@@ ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; void * @@ptr@@ ; unsigned __int64 @@v10@@ ; @@v10@@ = __readfsqword ( Number ) ; @@v7@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@s@@ = Number L ; @@v4@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v3@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( @@v4@@ > Number ) return Number L ; @@v5@@ = malloc ( Number * ( @@v4@@ + Number ) ) ; if ( @@v5@@ ) { if ( * ( _QWORD * ) ( @@v7@@ + Number ) ) { @@s@@ = malloc ( Number * ( @@v4@@ + Number ) ) ; if ( @@s@@ ) { while ( Number ) { memset ( @@s@@ , Number , Number * ( @@v4@@ + Number ) ) ; sift_ctx_init ( @@v8@@ , @@v5@@ , @@s@@ , @@v3@@ , @@v4@@ ) ; @@v2@@ = sift_states_backward ( @@a1@@ , @@v8@@ ) ; free ( @@ptr@@ ) ; if ( @@v2@@ ) break ; if ( * @@v5@@ || * @@s@@ ) { @@v2@@ = merge_state_array ( @@v7@@ , @@v5@@ , @@s@@ , @@v4@@ + Number ) ; free ( @@s@@ ) ; @@s@@ = Number L ; if ( ! @@v2@@ ) goto LABEL_21 ; break ; } do { if ( -- @@v4@@ > Number ) { @@v2@@ = Number ; goto LABEL_22 ; } } while ( ! * ( _QWORD * ) ( Number * @@v4@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) || ( * ( _BYTE * ) ( * ( _QWORD * ) ( Number * @@v4@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) + Number L ) & Number ) == Number ) ; @@v3@@ = check_halt_state_context ( @@a1@@ , * ( _QWORD * ) ( Number * @@v4@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) , @@v4@@ ) ; } } else { @@v2@@ = Number ; } } else { sift_ctx_init ( @@v8@@ , @@v5@@ , Number L , @@v3@@ , @@v4@@ ) ; @@v2@@ = sift_states_backward ( @@a1@@ , @@v8@@ ) ; free ( @@ptr@@ ) ; if ( ! @@v2@@ ) { if ( * @@v5@@ ) { LABEL_21 : free ( * ( void * * ) ( @@a1@@ + Number ) ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v5@@ ; @@v5@@ = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v3@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v4@@ ; @@v2@@ = Number ; } else { @@v2@@ = Number ; } } } } else { @@v2@@ = Number ; } LABEL_22 : free ( @@v5@@ ) ; free ( @@s@@ ) ; return @@v2@@ ; }
__int64 __fastcall xsum4 ( unsigned __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ ) { __int64 @@v4@@ ; __int64 @@v5@@ ; @@v4@@ = xsum ( @@a1@@ , @@a2@@ ) ; @@v5@@ = xsum ( @@v4@@ , @@a3@@ ) ; return xsum ( @@v5@@ , @@a4@@ ) ; }
__int64 __fastcall re_string_char_size_at ( __int64 @@a1@@ , __int64 @@a2@@ ) { int @@i@@ ; if ( * ( _DWORD * ) ( @@a1@@ + Number ) == Number ) return Number L ; for ( @@i@@ = Number ; ( unsigned __int64 ) ( @@a2@@ + @@i@@ ) < * ( _QWORD * ) ( @@a1@@ + Number ) && * ( _DWORD * ) ( Number * ( @@i@@ + @@a2@@ ) + * ( _QWORD * ) ( @@a1@@ + Number ) ) == Number ; ++ @@i@@ ) { ; } return ( unsigned int ) @@i@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
__int64 __fastcall parse_reg_exp ( __int64 @@a1@@ , __int64 * @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , _DWORD * @@a6@@ ) { __int64 @@v11@@ ; __int64 @@v12@@ ; __int64 @@v13@@ ; @@v13@@ = * @@a2@@ ; @@v11@@ = parse_branch ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( * @@a6@@ && ! @@v11@@ ) return Number L ; while ( * ( _BYTE * ) ( @@a3@@ + Number ) == Number ) { fetch_token ( @@a3@@ , @@a1@@ , @@a4@@ | Number ) ; if ( * ( _BYTE * ) ( @@a3@@ + Number ) == Number || * ( _BYTE * ) ( @@a3@@ + Number ) == Number || @@a5@@ && * ( _BYTE * ) ( @@a3@@ + Number ) == Number ) { @@v12@@ = Number L ; } else { @@v12@@ = parse_branch ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( * @@a6@@ && ! @@v12@@ ) return Number L ; } @@v11@@ = create_tree ( @@v13@@ , @@v11@@ , @@v12@@ , Number L ) ; if ( ! @@v11@@ ) { * @@a6@@ = Number ; return Number L ; } } return @@v11@@ ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
__int64 __fastcall build_equiv_class ( __int64 @@a1@@ , __int64 a2 , __int64 a3 , const char * @@a4@@ ) { if ( strlen ( @@a4@@ ) != Number ) return Number L ; bitset_set ( @@a1@@ , * ( unsigned __int8 * ) @@a4@@ ) ; return Number L ; }
_BOOL8 __fastcall rpl_isnanl ( __int64 a1 , __int64 a2 , __int64 a3 , __int64 a4 , __int64 a5 , __int64 a6 , __int128 @@a7@@ ) { if ( ( WORD4 ( @@a7@@ ) & Number ) == Number ) return DWORD1 ( @@a7@@ ) >> Number ; if ( ( WORD4 ( @@a7@@ ) & Number ) == Number ) return ( DWORD1 ( @@a7@@ ) ^ Number | ( unsigned int ) @@a7@@ ) != Number ; return ( DWORD1 ( @@a7@@ ) & Number ) == Number ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall build_sifted_states ( __int64 @@a1@@ , _QWORD * @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ ) { int @@v7@@ ; unsigned __int64 @@i@@ ; _QWORD * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; @@v9@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; @@v10@@ = * ( _QWORD * ) ( Number * @@a3@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) + Number L ; for ( @@i@@ = Number L ; @@i@@ < * ( _QWORD * ) ( @@v10@@ + Number ) ; ++ @@i@@ ) { @@v11@@ = * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@v10@@ + Number ) ) ; @@v7@@ = Number ; if ( ( * ( _BYTE * ) ( Number * @@v11@@ + * @@v9@@ + Number ) & Number ) != Number ) @@v7@@ = sift_states_iter_mb ( @@a1@@ , @@a2@@ , @@v11@@ , @@a3@@ , @@a2@@ [ Number ] ) ; if ( ! @@v7@@ && ( unsigned __int8 ) check_node_accept ( @@a1@@ , * @@v9@@ + Number * @@v11@@ , @@a3@@ ) && * ( _QWORD * ) ( Number * ( @@a3@@ + Number ) + * @@a2@@ ) && re_node_set_contains ( * ( _QWORD * ) ( Number * ( @@a3@@ + Number ) + * @@a2@@ ) + Number L , * ( _QWORD * ) ( Number * @@v11@@ + @@v9@@ [ Number ] ) ) ) { @@v7@@ = Number ; } if ( @@v7@@ && ( ! @@a2@@ [ Number ] || ! ( unsigned __int8 ) check_dst_limits ( @@a1@@ , @@a2@@ + Number , * ( _QWORD * ) ( Number * @@v11@@ + @@v9@@ [ Number ] ) , @@v7@@ + @@a3@@ , @@v11@@ , @@a3@@ ) ) && ! re_node_set_insert ( @@a4@@ , @@v11@@ ) ) { return Number L ; } } return Number L ; }
__int64 __fastcall re_string_construct ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ , unsigned __int8 @@a5@@ , __int64 @@a6@@ ) { __int64 @@v7@@ ; unsigned int @@v12@@ ; unsigned int @@v13@@ ; unsigned int @@v14@@ ; memset ( ( void * ) @@a1@@ , Number , Number ) ; re_string_construct_common ( @@a2@@ , @@a3@@ , @@a1@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( @@a3@@ ) { @@v12@@ = re_string_realloc_buffers ( @@a1@@ , @@a3@@ + Number ) ; if ( @@v12@@ ) return @@v12@@ ; } if ( * ( _BYTE * ) ( @@a1@@ + Number ) ) @@v7@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; else @@v7@@ = @@a2@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v7@@ ; if ( ! @@a5@@ ) { if ( * ( int * ) ( @@a6@@ + Number ) <= Number ) { if ( @@a4@@ ) { re_string_translate_buffer ( @@a1@@ ) ; } else { * ( _QWORD * ) ( @@a1@@ + Number ) = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = * ( _QWORD * ) ( @@a1@@ + Number ) ; } } else { build_wcs_buffer ( @@a1@@ ) ; } return Number L ; } if ( * ( int * ) ( @@a6@@ + Number ) <= Number ) { build_upper_buffer ( @@a1@@ ) ; return Number L ; } do { @@v13@@ = build_wcs_upper_buffer ( @@a1@@ ) ; if ( @@v13@@ ) return @@v13@@ ; if ( @@a3@@ <= * ( _QWORD * ) ( @@a1@@ + Number ) || * ( _QWORD * ) ( @@a1@@ + Number ) > ( unsigned __int64 ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + * ( int * ) ( @@a6@@ + Number ) ) ) { return Number L ; } @@v14@@ = re_string_realloc_buffers ( @@a1@@ , Number L * * ( _QWORD * ) ( @@a1@@ + Number ) ) ; } while ( ! @@v14@@ ) ; return @@v14@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
__int64 __fastcall re_string_context_at ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , char @@a3@@ ) { __int64 @@result@@ ; int @@v4@@ ; wint_t @@wc@@ ; unsigned __int64 @@v6@@ ; if ( @@a2@@ > Number ) return * ( unsigned int * ) ( @@a1@@ + Number ) ; if ( @@a2@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ) { if ( ( @@a3@@ & Number ) != Number ) @@result@@ = Number L ; else @@result@@ = Number L ; } else if ( * ( int * ) ( @@a1@@ + Number ) <= Number ) { @@v4@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ ) ; if ( bitset_contain ( * ( _QWORD * ) ( @@a1@@ + Number ) , * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ ) ) ) { @@result@@ = Number L ; } else if ( @@v4@@ == Number && * ( _BYTE * ) ( @@a1@@ + Number ) ) { @@result@@ = Number L ; } else { @@result@@ = Number L ; } } else { @@v6@@ = @@a2@@ ; while ( * ( _DWORD * ) ( Number * @@v6@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) == Number ) { if ( -- @@v6@@ > Number ) return * ( unsigned int * ) ( @@a1@@ + Number ) ; } @@wc@@ = * ( _DWORD * ) ( Number * @@v6@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) ; if ( * ( _BYTE * ) ( @@a1@@ + Number ) && ( iswalnum ( @@wc@@ ) || @@wc@@ == Number ) ) { @@result@@ = Number L ; } else if ( @@wc@@ == Number && * ( _BYTE * ) ( @@a1@@ + Number ) ) { @@result@@ = Number L ; } else { @@result@@ = Number L ; } } return @@result@@ ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
__int64 __fastcall check_dst_limits_calc_pos_1 ( __int64 @@a1@@ , int @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ ) { int @@v5@@ ; __int64 @@result@@ ; __int64 @@v7@@ ; int @@v11@@ ; unsigned __int64 @@i@@ ; __int64 @@v13@@ ; _QWORD * @@v14@@ ; __int64 @@v15@@ ; __int64 @@v16@@ ; __int64 @@v17@@ ; @@v14@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; @@v15@@ = @@v14@@ [ Number ] + Number * @@a4@@ ; for ( @@i@@ = Number L ; ; ++ @@i@@ ) { if ( @@i@@ >= * ( _QWORD * ) ( @@v15@@ + Number ) ) return ( @@a2@@ >> Number ) & Number ; @@v16@@ = * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@v15@@ + Number ) ) ; @@v5@@ = * ( unsigned __int8 * ) ( Number * @@v16@@ + * @@v14@@ + Number ) ; if ( @@v5@@ == Number ) { if ( ( @@a2@@ & Number ) != Number && @@a3@@ == * ( _QWORD * ) ( Number * @@v16@@ + * @@v14@@ ) ) { return Number ; } continue ; } if ( @@v5@@ != Number ) break ; if ( ( @@a2@@ & Number ) != Number && @@a3@@ == * ( _QWORD * ) ( Number * @@v16@@ + * @@v14@@ ) ) { return Number L ; } LABEL_29 : ; } if ( @@v5@@ != Number || @@a5@@ == Number ) goto LABEL_29 ; @@v13@@ = * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@a5@@ ; while ( Number ) { if ( @@v16@@ != * ( _QWORD * ) @@v13@@ || @@a3@@ <= Number && ( ( * ( unsigned __int16 * ) ( @@v13@@ + Number ) >> @@a3@@ ) & Number L ) == Number ) { goto LABEL_21 ; } @@v17@@ = * * ( _QWORD * * ) ( @@v14@@ [ Number ] + Number * @@v16@@ + Number ) ; if ( @@v17@@ == @@a4@@ ) break ; @@v11@@ = check_dst_limits_calc_pos_1 ( @@a1@@ , @@a2@@ , @@a3@@ , @@v17@@ , @@a5@@ ) ; if ( @@v11@@ == Number ) return Number ; if ( ! @@v11@@ && ( @@a2@@ & Number ) != Number ) return Number L ; if ( @@a3@@ <= Number ) * ( _WORD * ) ( @@v13@@ + Number ) &= ~ ( unsigned __int16 ) ( Number L << @@a3@@ ) ; LABEL_21 : @@v7@@ = @@v13@@ ; @@v13@@ += Number L ; if ( ! * ( _BYTE * ) ( @@v7@@ + Number ) ) goto LABEL_29 ; } if ( ( @@a2@@ & Number ) != Number ) @@result@@ = Number ; else @@result@@ = Number L ; return @@result@@ ; }
__int64 __fastcall build_charclass_op ( __int64 @@a1@@ , __int64 @@a2@@ , const char * @@a3@@ , _BYTE * @@a4@@ , char @@a5@@ , _DWORD * @@a6@@ ) { int @@v11@@ ; __int64 @@v12@@ ; void * @@ptr@@ ; _BYTE * @@v14@@ ; __int64 @@v15@@ ; __int64 @@v16@@ ; void * @@v17@@ ; char @@v18@@ ; unsigned __int64 @@v19@@ ; @@v19@@ = __readfsqword ( Number ) ; @@v12@@ = Number L ; @@ptr@@ = calloc ( Number , Number ) ; @@v14@@ = calloc ( Number , Number ) ; if ( ! @@ptr@@ || ! @@v14@@ ) { * @@a6@@ = Number ; return Number L ; } if ( @@a5@@ ) @@v14@@ [ Number ] |= Number ; @@v11@@ = build_charclass ( @@a2@@ , ( __int64 ) @@ptr@@ , ( __int64 ) @@v14@@ , & @@v12@@ , @@a3@@ , Number ) ; if ( @@v11@@ ) { free ( @@ptr@@ ) ; free_charset ( @@v14@@ ) ; * @@a6@@ = @@v11@@ ; return Number L ; } while ( * @@a4@@ ) bitset_set ( ( __int64 ) @@ptr@@ , ( unsigned __int8 ) * @@a4@@ ++ ) ; if ( @@a5@@ ) bitset_not ( ( __int64 ) @@ptr@@ ) ; if ( * ( int * ) ( @@a1@@ + Number ) > Number ) bitset_mask ( ( __int64 ) @@ptr@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ; @@v18@@ = Number ; @@v17@@ = @@ptr@@ ; @@v15@@ = create_token_tree ( @@a1@@ , Number L , Number L , & @@v17@@ ) ; if ( @@v15@@ ) { if ( * ( int * ) ( @@a1@@ + Number ) <= Number ) { free_charset ( @@v14@@ ) ; return @@v15@@ ; } @@v18@@ = Number ; @@v17@@ = @@v14@@ ; * ( _BYTE * ) ( @@a1@@ + Number ) |= Number ; @@v16@@ = create_token_tree ( @@a1@@ , Number L , Number L , & @@v17@@ ) ; if ( @@v16@@ ) { @@v15@@ = create_tree ( @@a1@@ , @@v15@@ , @@v16@@ , Number L ) ; if ( @@v16@@ ) return @@v15@@ ; } } free ( @@ptr@@ ) ; free_charset ( @@v14@@ ) ; * @@a6@@ = Number ; return Number L ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
int iswalnum ( wint_t @@wc@@ ) { return iswalnum ( @@wc@@ ) ; }
unsigned __int64 __fastcall re_node_set_remove_at ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { unsigned __int64 @@result@@ ; unsigned __int64 @@v3@@ ; @@v3@@ = @@a2@@ ; @@result@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( @@a2@@ < @@result@@ ) { -- * ( _QWORD * ) ( @@a1@@ + Number ) ; while ( Number ) { @@result@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( @@v3@@ >= @@result@@ ) break ; * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@v3@@ ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * ( @@v3@@ + Number ) ) ; ++ @@v3@@ ; } } return @@result@@ ; }
wint_t towupper ( wint_t @@wc@@ ) { return towupper ( @@wc@@ ) ; }
__int64 __fastcall find_subexp_node ( _QWORD * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , int @@a4@@ ) { unsigned __int64 @@i@@ ; __int64 @@v6@@ ; for ( @@i@@ = Number L ; @@i@@ < * ( _QWORD * ) ( @@a2@@ + Number ) ; ++ @@i@@ ) { @@v6@@ = Number L * * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) + * @@a1@@ ; if ( @@a4@@ == * ( unsigned __int8 * ) ( @@v6@@ + Number ) && @@a3@@ == * ( _QWORD * ) @@v6@@ ) { return * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) ; } } return Number ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
__int64 __fastcall rpl_re_match_2 ( int @@a1@@ , int @@a2@@ , int @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ , __int64 @@a7@@ , __int64 @@a8@@ ) { return re_search_2_stub ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ , Number L , @@a7@@ , @@a8@@ , Number ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall re_search_2_stub ( int @@a1@@ , const void * @@a2@@ , size_t @@a3@@ , const void * @@a4@@ , size_t @@a5@@ , int @@a6@@ , __int64 @@a7@@ , __int64 @@a8@@ , __int64 @@a9@@ , unsigned __int8 @@a10@@ ) { __int64 @@v11@@ ; char * @@dest@@ ; size_t @@size@@ ; __int64 @@v18@@ ; @@size@@ = @@a3@@ + @@a5@@ ; @@dest@@ = Number L ; if ( @@a3@@ + @@a5@@ < @@a3@@ ) return Number ; if ( @@a5@@ ) { if ( @@a3@@ ) { @@dest@@ = ( char * ) malloc ( @@size@@ ) ; if ( ! @@dest@@ ) return Number ; memcpy ( @@dest@@ , @@a2@@ , @@a3@@ ) ; memcpy ( & @@dest@@ [ @@a3@@ ] , @@a4@@ , @@a5@@ ) ; @@v11@@ = re_search_stub ( @@a1@@ , ( _DWORD ) @@dest@@ , @@size@@ , @@a6@@ , @@a7@@ , @@a9@@ , @@a8@@ , @@a10@@ ) ; } else { @@v11@@ = re_search_stub ( @@a1@@ , ( _DWORD ) @@a4@@ , @@size@@ , @@a6@@ , @@a7@@ , @@a9@@ , @@a8@@ , @@a10@@ ) ; } } else { @@v11@@ = re_search_stub ( @@a1@@ , ( _DWORD ) @@a2@@ , @@size@@ , @@a6@@ , @@a7@@ , @@a9@@ , @@a8@@ , @@a10@@ ) ; } @@v18@@ = @@v11@@ ; free ( @@dest@@ ) ; return @@v18@@ ; }
__int64 __fastcall build_type_arg ( char * * @@a1@@ , _QWORD * @@a2@@ , __int64 @@a3@@ ) { int @@v3@@ ; char * @@v4@@ ; size_t @@v5@@ ; unsigned __int8 @@v7@@ ; const char * @@v8@@ ; @@v7@@ = Number ; @@v3@@ = * optarg ; if ( @@v3@@ == Number ) { LABEL_7 : * @@a1@@ = optarg ; return @@v7@@ ; } if ( @@v3@@ <= Number ) { if ( @@v3@@ != Number ) return Number ; goto LABEL_7 ; } if ( @@v3@@ != Number ) { if ( @@v3@@ != Number ) return Number ; goto LABEL_7 ; } @@v4@@ = optarg ++ ; * @@a1@@ = @@v4@@ ; * @@a2@@ = Number L ; @@a2@@ [ Number ] = Number L ; @@a2@@ [ Number ] = @@a3@@ ; @@a2@@ [ Number ] = Number L ; rpl_re_syntax_options = Number L ; @@v5@@ = strlen ( optarg ) ; @@v8@@ = ( const char * ) rpl_re_compile_pattern ( optarg , @@v5@@ , @@a2@@ ) ; if ( @@v8@@ ) error ( Number , Number , String , @@v8@@ ) ; return @@v7@@ ; }
char * __fastcall create_ci_newstate ( _QWORD * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { char * @@result@@ ; int @@v5@@ ; unsigned __int64 @@i@@ ; char * @@ptr@@ ; __int64 @@v8@@ ; @@ptr@@ = ( char * ) calloc ( Number , Number ) ; if ( ! @@ptr@@ ) return Number L ; if ( ( unsigned int ) re_node_set_init_copy ( @@ptr@@ + Number , @@a2@@ ) ) { free ( @@ptr@@ ) ; @@result@@ = Number L ; } else { * ( ( _QWORD * ) @@ptr@@ + Number ) = @@ptr@@ + Number ; for ( @@i@@ = Number L ; @@i@@ < * ( _QWORD * ) ( @@a2@@ + Number ) ; ++ @@i@@ ) { @@v8@@ = * @@a1@@ + Number L * * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) ; @@v5@@ = * ( unsigned __int8 * ) ( @@v8@@ + Number ) ; if ( @@v5@@ != Number || ( * ( _DWORD * ) ( @@v8@@ + Number ) & Number ) != Number ) { @@ptr@@ [ Number ] = ( Number * ( ( * ( _BYTE * ) ( @@v8@@ + Number ) & Number ) != Number || ( @@ptr@@ [ Number ] & Number ) != Number ) ) | @@ptr@@ [ Number ] & Number ; if ( @@v5@@ == Number ) { @@ptr@@ [ Number ] |= Number ; } else if ( @@v5@@ == Number ) { @@ptr@@ [ Number ] |= Number ; } else if ( @@v5@@ == Number || ( * ( _DWORD * ) ( @@v8@@ + Number ) & Number ) != Number ) { @@ptr@@ [ Number ] |= Number ; } } } if ( ( unsigned int ) register_state ( @@a1@@ , @@ptr@@ , @@a3@@ ) ) { free_state ( ( void * * ) @@ptr@@ ) ; @@ptr@@ = Number L ; } @@result@@ = @@ptr@@ ; } return @@result@@ ; }
_BOOL8 __fastcall check_node_accept ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { int @@v3@@ ; _BOOL8 @@result@@ ; char @@v6@@ ; char @@v7@@ ; @@v6@@ = * ( _BYTE * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@a3@@ ) ; @@v3@@ = * ( unsigned __int8 * ) ( @@a2@@ + Number ) ; if ( @@v3@@ == Number ) { if ( ! bitset_contain ( * ( _QWORD * ) @@a2@@ , ( unsigned __int8 ) @@v6@@ ) ) return Number L ; } else if ( * ( unsigned __int8 * ) ( @@a2@@ + Number ) > Number ) { if ( @@v3@@ != Number ) { if ( @@v3@@ != Number ) return Number L ; if ( @@v6@@ < Number ) return Number L ; } if ( @@v6@@ == Number && ( * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L ) & Number ) == Number || ! @@v6@@ && ( * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L ) & Number ) != Number ) { return Number L ; } } else { if ( @@v3@@ != Number ) return Number L ; if ( @@v6@@ != * ( _BYTE * ) @@a2@@ ) return Number L ; } @@result@@ = Number ; if ( ( * ( _DWORD * ) ( @@a2@@ + Number ) & Number ) != Number ) { if ( ( @@v7@@ = re_string_context_at ( @@a1@@ , @@a3@@ , * ( _DWORD * ) ( @@a1@@ + Number ) ) , ( ( * ( _DWORD * ) ( @@a2@@ + Number ) >> Number ) & Number ) != Number ) && ( @@v7@@ & Number ) == Number || ( ( * ( _DWORD * ) ( @@a2@@ + Number ) >> Number ) & Number ) != Number && ( @@v7@@ & Number ) != Number || ( ( * ( _DWORD * ) ( @@a2@@ + Number ) >> Number ) & Number ) != Number && ( @@v7@@ & Number ) == Number || ( ( * ( _DWORD * ) ( @@a2@@ + Number ) >> Number ) & Number ) != Number && ( @@v7@@ & Number ) == Number ) { @@result@@ = Number ; } } return @@result@@ ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
__int64 __fastcall push_fail_stack ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , const void * @@a5@@ , __int64 @@a6@@ ) { __int64 @@v6@@ ; __int64 @@v8@@ ; __int64 @@v13@@ ; void * @@v14@@ ; @@v6@@ = ( * ( _QWORD * ) @@a1@@ ) ++ ; @@v13@@ = @@v6@@ ; if ( * ( _QWORD * ) @@a1@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ) { @@v14@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number L * * ( _QWORD * ) ( @@a1@@ + Number ) ) ; if ( ! @@v14@@ ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) *= Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v14@@ ; } * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@v13@@ ) = @@a2@@ ; * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@v13@@ + Number ) = @@a3@@ ; @@v8@@ = * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@v13@@ ; * ( _QWORD * ) ( @@v8@@ + Number ) = malloc ( Number * @@a4@@ ) ; if ( ! * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@v13@@ + Number ) ) return Number L ; memcpy ( * ( void * * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@v13@@ + Number ) , @@a5@@ , Number * @@a4@@ ) ; return ( unsigned int ) re_node_set_init_copy ( ( void * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@v13@@ + Number ) , @@a6@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall search_cur_bkref_entry ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { __int64 @@result@@ ; unsigned __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; @@v4@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v3@@ = Number L ; while ( @@v3@@ < @@v4@@ ) { if ( @@a2@@ <= * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * ( ( @@v3@@ + @@v4@@ ) >> Number ) + Number ) ) @@v4@@ = ( @@v3@@ + @@v4@@ ) >> Number ; else @@v3@@ = ( ( @@v3@@ + @@v4@@ ) >> Number ) + Number ; } if ( @@v3@@ < * ( _QWORD * ) ( @@a1@@ + Number ) && @@a2@@ == * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@v3@@ + Number ) ) { @@result@@ = @@v3@@ ; } else { @@result@@ = Number ; } return @@result@@ ; }
__int64 __fastcall bkm_scale ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( * @@a1@@ >= ( __int64 ) Number / @@a2@@ ) { if ( Number / @@a2@@ >= * @@a1@@ ) { * @@a1@@ *= @@a2@@ ; @@result@@ = Number L ; } else { * @@a1@@ = Number ; @@result@@ = Number L ; } } else { * @@a1@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
_BOOL8 __fastcall strip_trailing_slashes ( char * @@a1@@ ) { char @@v1@@ ; const char * @@v3@@ ; const char * @@v4@@ ; @@v3@@ = last_component ( @@a1@@ ) ; if ( ! * @@v3@@ ) @@v3@@ = @@a1@@ ; @@v4@@ = & @@v3@@ [ base_len ( @@v3@@ ) ] ; @@v1@@ = * @@v4@@ ; * @@v4@@ = Number ; return @@v1@@ != Number ; }
__int64 __fastcall merge_state_array ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , unsigned __int64 @@a4@@ ) { _QWORD * @@v5@@ ; unsigned int @@v8@@ ; unsigned __int64 @@i@@ ; void * @@v10@@ [ Number ] ; @@v10@@ [ Number ] = ( void * ) __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ < @@a4@@ ; ++ @@i@@ ) { if ( * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ) { if ( * ( _QWORD * ) ( Number * @@i@@ + @@a3@@ ) ) { @@v8@@ = re_node_set_init_union ( @@v10@@ , * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) + Number L , * ( _QWORD * ) ( Number * @@i@@ + @@a3@@ ) + Number L ) ; if ( @@v8@@ ) return @@v8@@ ; @@v5@@ = ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; * @@v5@@ = re_acquire_state ( & @@v8@@ , @@a1@@ , ( __int64 ) @@v10@@ ) ; free ( @@v10@@ [ Number ] ) ; if ( @@v8@@ ) return @@v8@@ ; } } else { * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) = * ( _QWORD * ) ( Number * @@i@@ + @@a3@@ ) ; } } return Number L ; }
__int64 __fastcall init_word_char ( __int64 @@a1@@ ) { __int64 @@result@@ ; int @@v2@@ ; int @@i@@ ; int @@v4@@ ; @@result@@ = @@a1@@ ; * ( _BYTE * ) ( @@a1@@ + Number ) |= Number ; @@v2@@ = Number ; @@v4@@ = Number ; while ( @@v2@@ <= Number ) { for ( @@i@@ = Number ; @@i@@ <= Number ; ++ @@i@@ ) { @@result@@ = ( * __ctype_b_loc ( ) ) [ @@v4@@ ] & Number ; if ( ( _DWORD ) @@result@@ || @@v4@@ == Number ) { @@result@@ = @@a1@@ ; * ( _QWORD * ) ( @@a1@@ + Number * ( @@v2@@ + Number L ) + Number ) |= Number L << @@i@@ ; } ++ @@v4@@ ; } ++ @@v2@@ ; } return @@result@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
__int64 __fastcall check_dst_limits ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ ) { unsigned __int64 @@i@@ ; _QWORD * @@v12@@ ; __int64 @@v13@@ ; __int64 @@v14@@ ; __int64 @@v15@@ ; __int64 @@v16@@ ; @@v12@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; @@v13@@ = search_cur_bkref_entry ( @@a1@@ , @@a4@@ ) ; @@v14@@ = search_cur_bkref_entry ( @@a1@@ , @@a6@@ ) ; for ( @@i@@ = Number L ; @@i@@ < * ( _QWORD * ) ( @@a2@@ + Number ) ; ++ @@i@@ ) { @@v15@@ = * ( _QWORD * ) ( * @@v12@@ + Number L * * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L * * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) ) ) ; @@v16@@ = ( int ) check_dst_limits_calc_pos ( @@a1@@ , * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) , @@v15@@ , @@a3@@ , @@a4@@ , @@v13@@ ) ; if ( ( int ) check_dst_limits_calc_pos ( @@a1@@ , * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) , @@v15@@ , @@a5@@ , @@a6@@ , @@v14@@ ) != @@v16@@ ) return Number L ; } return Number L ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
__int64 __fastcall preorder ( _QWORD * @@a1@@ , __int64 ( __fastcall * @@a2@@ ) ( __int64 , _QWORD * ) , __int64 @@a3@@ ) { __int64 @@result@@ ; _QWORD * @@v5@@ ; _QWORD * @@v6@@ ; @@v5@@ = @@a1@@ ; LODWORD ( @@result@@ ) = @@a2@@ ( @@a3@@ , @@a1@@ ) ; while ( ! ( _DWORD ) @@result@@ ) { if ( @@v5@@ [ Number ] ) { @@v5@@ = ( _QWORD * ) @@v5@@ [ Number ] ; LODWORD ( @@result@@ ) = @@a2@@ ( @@a3@@ , @@v5@@ ) ; } else { @@v6@@ = Number L ; while ( @@v6@@ == ( _QWORD * ) @@v5@@ [ Number ] || ! @@v5@@ [ Number ] ) { @@v6@@ = @@v5@@ ; @@v5@@ = ( _QWORD * ) * @@v5@@ ; if ( ! @@v5@@ ) return Number L ; } @@v5@@ = ( _QWORD * ) @@v5@@ [ Number ] ; LODWORD ( @@result@@ ) = @@a2@@ ( @@a3@@ , @@v5@@ ) ; } } return ( unsigned int ) @@result@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
__int64 __fastcall sift_states_iter_mb ( __int64 @@a1@@ , _QWORD * @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned __int64 @@a5@@ ) { int @@v9@@ ; __int64 @@v10@@ ; @@v10@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v9@@ = check_node_accept_bytes ( @@v10@@ , @@a3@@ , @@a1@@ , @@a4@@ ) ; if ( @@v9@@ > Number && @@a5@@ >= @@v9@@ + @@a4@@ && ( ! * ( _QWORD * ) ( Number * ( @@v9@@ + @@a4@@ ) + * @@a2@@ ) || ! re_node_set_contains ( * ( _QWORD * ) ( Number * ( @@v9@@ + @@a4@@ ) + * @@a2@@ ) + Number L , * ( _QWORD * ) ( Number * @@a3@@ + * ( _QWORD * ) ( @@v10@@ + Number ) ) ) ) ) { @@v9@@ = Number ; } return ( unsigned int ) @@v9@@ ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
__int64 __fastcall lower_subexp ( _DWORD * @@a1@@ , __int64 * @@a2@@ , __int64 @@a3@@ ) { __int64 @@result@@ ; __int64 @@v4@@ ; _BOOL4 @@v5@@ ; _BOOL4 @@v6@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; __int64 @@v12@@ ; __int64 @@v13@@ ; @@v8@@ = * @@a2@@ ; @@v9@@ = * ( _QWORD * ) ( @@a3@@ + Number ) ; if ( ( @@a2@@ [ Number ] & Number ) != Number && * ( _QWORD * ) ( @@a3@@ + Number ) && ( * ( _QWORD * ) ( @@a3@@ + Number ) > Number || ( ( * ( _QWORD * ) ( @@v8@@ + Number ) >> * ( _QWORD * ) ( @@a3@@ + Number ) ) & Number L ) == Number ) ) { return * ( _QWORD * ) ( @@a3@@ + Number ) ; } @@v10@@ = create_tree ( @@v8@@ , Number L , Number L , Number L ) ; @@v11@@ = create_tree ( @@v8@@ , Number L , Number L , Number L ) ; if ( @@v9@@ ) @@v4@@ = create_tree ( @@v8@@ , @@v9@@ , @@v11@@ , Number L ) ; else @@v4@@ = @@v11@@ ; @@v12@@ = @@v4@@ ; @@v13@@ = create_tree ( @@v8@@ , @@v10@@ , @@v4@@ , Number L ) ; @@v5@@ = ! @@v13@@ || ! @@v12@@ ; @@v6@@ = @@v5@@ || ! @@v10@@ ; if ( ! @@v6@@ && @@v11@@ ) { * ( _QWORD * ) ( @@v11@@ + Number ) = * ( _QWORD * ) ( @@a3@@ + Number ) ; * ( _QWORD * ) ( @@v10@@ + Number ) = * ( _QWORD * ) ( @@v11@@ + Number ) ; * ( _BYTE * ) ( @@v11@@ + Number ) = ( Number * ( ( * ( _BYTE * ) ( @@a3@@ + Number ) & Number ) != Number ) ) | * ( _BYTE * ) ( @@v11@@ + Number ) & Number ; * ( _BYTE * ) ( @@v10@@ + Number ) = ( Number * ( ( * ( _BYTE * ) ( @@v11@@ + Number ) & Number ) != Number ) ) | * ( _BYTE * ) ( @@v10@@ + Number ) & Number ; @@result@@ = @@v13@@ ; } else { * @@a1@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
struct tm * localtime ( const time_t * @@timer@@ ) { return localtime ( @@timer@@ ) ; }
__int64 __fastcall find_recover_state ( _DWORD * @@a1@@ , _QWORD * @@a2@@ ) { __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; __int64 @@v5@@ ; do { @@v4@@ = @@a2@@ [ Number ] ; @@v3@@ = @@a2@@ [ Number ] ; do { if ( ++ @@v3@@ > @@v4@@ ) return Number L ; ++ @@a2@@ [ Number ] ; } while ( ! * ( _QWORD * ) ( Number * @@v3@@ + @@a2@@ [ Number ] ) ) ; @@v5@@ = merge_state_with_log ( @@a1@@ , ( __int64 ) @@a2@@ , Number L ) ; } while ( ! * @@a1@@ && ! @@v5@@ ) ; return @@v5@@ ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
__int64 __fastcall get_subexp_sub ( _QWORD * @@a1@@ , _QWORD * @@a2@@ , _QWORD * @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ ) { __int64 @@result@@ ; unsigned int @@v9@@ ; unsigned int @@v10@@ ; @@v9@@ = check_arrival ( ( _DWORD ) @@a1@@ , ( int ) @@a3@@ + Number , * @@a3@@ , @@a3@@ [ Number ] , @@a4@@ , @@a5@@ , Number ) ; if ( @@v9@@ ) return @@v9@@ ; @@v10@@ = match_ctx_add_entry ( @@a1@@ , @@a4@@ , @@a5@@ , * @@a2@@ , @@a3@@ [ Number ] ) ; if ( @@v10@@ ) @@result@@ = @@v10@@ ; else @@result@@ = clean_state_log_if_needed ( @@a1@@ , @@a5@@ + @@a3@@ [ Number ] - * @@a2@@ ) ; return @@result@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
__int64 __fastcall peek_token_bracket ( _BYTE * @@a1@@ , __int64 @@a2@@ , char @@a3@@ ) { char @@v4@@ ; char @@v5@@ ; unsigned int @@v6@@ ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) <= * ( _QWORD * ) ( @@a2@@ + Number ) ) { @@a1@@ [ Number ] = Number ; return Number L ; } @@v5@@ = * ( _BYTE * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + * ( _QWORD * ) ( @@a2@@ + Number ) ) ; * @@a1@@ = @@v5@@ ; if ( * ( int * ) ( @@a2@@ + Number ) > Number && * ( _QWORD * ) ( @@a2@@ + Number ) != * ( _QWORD * ) ( @@a2@@ + Number ) && * ( _DWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L * * ( _QWORD * ) ( @@a2@@ + Number ) ) == Number ) { @@a1@@ [ Number ] = Number ; return Number L ; } if ( @@v5@@ == Number && ( @@a3@@ & Number ) != Number && ( unsigned __int64 ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) < * ( _QWORD * ) ( @@a2@@ + Number ) ) { ++ * ( _QWORD * ) ( @@a2@@ + Number ) ; * @@a1@@ = * ( _BYTE * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + * ( _QWORD * ) ( @@a2@@ + Number ) ) ; @@a1@@ [ Number ] = Number ; return Number L ; } switch ( @@v5@@ ) { case String : if ( ( unsigned __int64 ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) >= * ( _QWORD * ) ( @@a2@@ + Number ) ) @@v4@@ = Number ; else @@v4@@ = * ( _BYTE * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) ; * @@a1@@ = @@v4@@ ; @@v6@@ = Number ; switch ( @@v4@@ ) { case String : if ( ( @@a3@@ & Number ) != Number ) { @@a1@@ [ Number ] = Number ; return @@v6@@ ; } break ; case String : @@a1@@ [ Number ] = Number ; return @@v6@@ ; case String : @@a1@@ [ Number ] = Number ; return @@v6@@ ; } @@a1@@ [ Number ] = Number ; * @@a1@@ = Number ; return Number ; case String : @@a1@@ [ Number ] = Number ; break ; case String : @@a1@@ [ Number ] = Number ; break ; case String : @@a1@@ [ Number ] = Number ; break ; default : @@a1@@ [ Number ] = Number ; break ; } return Number L ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_221088 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int64 __fastcall check_arrival_expand_ecl_sub ( _QWORD * @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ , unsigned int @@a5@@ ) { unsigned __int64 @@i@@ ; unsigned int @@v9@@ ; unsigned __int64 @@v10@@ ; @@v10@@ = @@a3@@ ; for ( @@i@@ = re_node_set_contains ( @@a2@@ , @@a3@@ ) ; ! @@i@@ ; @@i@@ = re_node_set_contains ( @@a2@@ , @@v10@@ ) ) { if ( @@a5@@ == * ( unsigned __int8 * ) ( Number * @@v10@@ + * @@a1@@ + Number ) && @@a4@@ == * ( _QWORD * ) ( Number * @@v10@@ + * @@a1@@ ) ) { if ( @@a5@@ == Number && ! re_node_set_insert ( @@a2@@ , @@v10@@ ) ) return Number L ; return Number L ; } if ( ! re_node_set_insert ( @@a2@@ , @@v10@@ ) ) return Number L ; if ( ! * ( _QWORD * ) ( @@a1@@ [ Number ] + Number * @@v10@@ + Number ) ) return Number L ; if ( * ( _QWORD * ) ( @@a1@@ [ Number ] + Number * @@v10@@ + Number ) == Number L ) { @@v9@@ = check_arrival_expand_ecl_sub ( @@a1@@ , @@a2@@ , * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ [ Number ] + Number * @@v10@@ + Number ) + Number L ) , @@a4@@ , @@a5@@ ) ; if ( @@v9@@ ) return @@v9@@ ; } @@v10@@ = * * ( _QWORD * * ) ( @@a1@@ [ Number ] + Number * @@v10@@ + Number ) ; } return Number L ; }
__int64 __fastcall fetch_number ( __int64 @@a1@@ , unsigned __int8 * @@a2@@ , __int64 @@a3@@ ) { unsigned __int64 @@v4@@ ; unsigned __int8 @@v6@@ ; __int64 @@i@@ ; for ( @@i@@ = Number ; ; @@i@@ = @@v4@@ ) { fetch_token ( ( __int64 ) @@a2@@ , @@a1@@ , @@a3@@ ) ; @@v6@@ = * @@a2@@ ; if ( @@a2@@ [ Number ] == Number ) return Number ; if ( @@a2@@ [ Number ] == Number || @@v6@@ == Number ) break ; if ( @@a2@@ [ Number ] != Number || @@v6@@ <= Number || @@v6@@ > Number || @@i@@ == Number ) { @@v4@@ = Number ; } else if ( @@i@@ == Number ) { @@v4@@ = @@v6@@ - Number ; } else { @@v4@@ = Number * @@i@@ + @@v6@@ - Number ; } if ( @@v4@@ > Number ) @@v4@@ = Number ; } return @@i@@ ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
unsigned __int64 __fastcall re_string_skip_chars ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ ) { _BOOL4 @@v3@@ ; wchar_t @@pwc@@ ; wchar_t @@v7@@ ; unsigned __int64 @@i@@ ; size_t @@v9@@ ; size_t @@n@@ ; __int64 @@v11@@ ; unsigned __int64 @@v12@@ ; @@v12@@ = __readfsqword ( Number ) ; @@v7@@ = Number ; for ( @@i@@ = * ( _QWORD * ) ( @@a1@@ + Number ) + * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ < @@a2@@ ; @@i@@ += @@v9@@ ) { @@n@@ = * ( _QWORD * ) ( @@a1@@ + Number ) - @@i@@ ; @@v11@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v9@@ = mbrtowc ( & @@pwc@@ , ( const char * ) ( * ( _QWORD * ) @@a1@@ + @@i@@ ) , @@n@@ , ( mbstate_t * ) ( @@a1@@ + Number ) ) ; @@v3@@ = @@v9@@ == Number || @@v9@@ == Number ; if ( ! @@v3@@ && @@v9@@ ) { @@v7@@ = @@pwc@@ ; } else { if ( @@v9@@ && @@n@@ ) @@v7@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) @@a1@@ + @@i@@ ) ; else @@v7@@ = Number ; @@v9@@ = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v11@@ ; } } * @@a3@@ = @@v7@@ ; return @@i@@ ; }
_QWORD * __fastcall match_ctx_clean ( _QWORD * @@a1@@ ) { _QWORD * @@result@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@j@@ ; void * @@v4@@ ; void * * @@ptr@@ ; for ( @@i@@ = Number L ; @@i@@ < @@a1@@ [ Number ] ; ++ @@i@@ ) { @@v4@@ = * ( void * * ) ( Number * @@i@@ + @@a1@@ [ Number ] ) ; for ( @@j@@ = Number L ; @@j@@ < * ( ( _QWORD * ) @@v4@@ + Number ) ; ++ @@j@@ ) { @@ptr@@ = * ( void * * * ) ( Number * @@j@@ + * ( ( _QWORD * ) @@v4@@ + Number ) ) ; free ( @@ptr@@ [ Number ] ) ; free ( @@ptr@@ ) ; } free ( * ( ( void * * ) @@v4@@ + Number ) ) ; if ( * ( ( _QWORD * ) @@v4@@ + Number ) ) { free ( * ( void * * ) ( * ( ( _QWORD * ) @@v4@@ + Number ) + Number L ) ) ; free ( * ( ( void * * ) @@v4@@ + Number ) ) ; } free ( @@v4@@ ) ; } @@a1@@ [ Number ] = Number L ; @@result@@ = @@a1@@ ; @@a1@@ [ Number ] = Number L ; return @@result@@ ; }
__int64 __fastcall mark_opt_subexp ( __int64 @@a1@@ , __int64 @@a2@@ ) { if ( * ( _BYTE * ) ( @@a2@@ + Number ) == Number && @@a1@@ == * ( _QWORD * ) ( @@a2@@ + Number ) ) { * ( _BYTE * ) ( @@a2@@ + Number ) |= Number ; } return Number L ; }
char * ttyname ( int @@fd@@ ) { return ttyname ( @@fd@@ ) ; }
__int64 __fastcall head_file ( const char * @@a1@@ , size_t @@a2@@ , char @@a3@@ , char @@a4@@ ) { int @@v4@@ ; unsigned __int8 @@v5@@ ; __int64 @@v6@@ ; char * @@v7@@ ; int * @@v8@@ ; __int64 @@v10@@ ; char * @@v11@@ ; int * @@v12@@ ; const char * @@s1@@ ; bool @@v16@@ ; unsigned __int8 @@v17@@ ; int @@fd@@ ; @@s1@@ = @@a1@@ ; @@v4@@ = strcmp ( @@a1@@ , String ) ; @@v16@@ = @@v4@@ == Number ; if ( @@v4@@ ) { @@fd@@ = open ( @@a1@@ , Number ) ; if ( @@fd@@ < Number ) { @@v6@@ = quote ( @@a1@@ ) ; @@v7@@ = gettext ( String ) ; @@v8@@ = __errno_location ( ) ; error ( Number , * @@v8@@ , @@v7@@ , @@v6@@ ) ; return Number L ; } @@v5@@ = head ( @@a1@@ , @@fd@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; } else { have_read_stdin = Number ; @@fd@@ = Number ; @@s1@@ = gettext ( String ) ; @@v5@@ = head ( @@s1@@ , Number , @@a2@@ , @@a3@@ , @@a4@@ ) ; } @@v17@@ = @@v5@@ ; if ( @@v16@@ || ! close ( @@fd@@ ) ) return @@v17@@ ; @@v10@@ = quote ( @@s1@@ ) ; @@v11@@ = gettext ( String ) ; @@v12@@ = __errno_location ( ) ; error ( Number , * @@v12@@ , @@v11@@ , @@v10@@ ) ; return Number L ; }
void __fastcall re_string_destruct ( __int64 @@a1@@ ) { free ( * ( void * * ) ( @@a1@@ + Number ) ) ; free ( * ( void * * ) ( @@a1@@ + Number ) ) ; if ( * ( _BYTE * ) ( @@a1@@ + Number ) ) free ( * ( void * * ) ( @@a1@@ + Number ) ) ; }
void * __fastcall sift_ctx_init ( _QWORD * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ ) { * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@a3@@ ; @@a1@@ [ Number ] = @@a4@@ ; @@a1@@ [ Number ] = @@a5@@ ; return memset ( @@a1@@ + Number , Number , Number ) ; }
char * strdup ( const char * @@s@@ ) { return strdup ( @@s@@ ) ; }
__int64 __fastcall duplicate_tree ( __int64 * * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v4@@ ; __int64 * @@v5@@ ; __int64 * @@v6@@ ; __int64 * @@v7@@ ; __int64 * @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ = & @@v4@@ ; @@v7@@ = * @@a1@@ ; @@v5@@ = ( __int64 * ) @@a1@@ ; while ( Number ) { @@v2@@ = create_token_tree ( @@a2@@ , Number L , Number L , @@v5@@ + Number ) ; * @@v6@@ = @@v2@@ ; if ( ! * @@v6@@ ) break ; * ( _QWORD * ) * @@v6@@ = @@v7@@ ; * ( _BYTE * ) ( * @@v6@@ + Number ) |= Number ; @@v7@@ = ( __int64 * ) * @@v6@@ ; if ( @@v5@@ [ Number ] ) { @@v5@@ = ( __int64 * ) @@v5@@ [ Number ] ; @@v6@@ = @@v7@@ + Number ; } else { @@v8@@ = Number L ; while ( @@v8@@ == ( __int64 * ) @@v5@@ [ Number ] || ! @@v5@@ [ Number ] ) { @@v8@@ = @@v5@@ ; @@v5@@ = ( __int64 * ) * @@v5@@ ; @@v7@@ = ( __int64 * ) * @@v7@@ ; if ( ! @@v5@@ ) return @@v4@@ ; } @@v5@@ = ( __int64 * ) @@v5@@ [ Number ] ; @@v6@@ = @@v7@@ + Number ; } } return Number L ; }
__int64 __fastcall bkm_scale_by_power ( unsigned __int64 * @@a1@@ , int @@a2@@ , int @@a3@@ ) { unsigned int @@i@@ ; for ( @@i@@ = Number ; @@a3@@ -- ; @@i@@ |= bkm_scale ( @@a1@@ , @@a2@@ ) ) ; return @@i@@ ; }
__int64 __fastcall re_node_set_alloc ( _QWORD * @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = Number L ; @@a1@@ [ Number ] = malloc ( Number * @@a2@@ ) ; if ( @@a1@@ [ Number ] ) @@result@@ = Number L ; else @@result@@ = Number L ; return @@result@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ ) { return xmalloc ( @@a1@@ ) ; }
void freeaddrinfo ( struct addrinfo * @@ai@@ ) { freeaddrinfo ( @@ai@@ ) ; }
__int64 __fastcall check_halt_state_context ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { char @@v4@@ ; unsigned __int64 @@i@@ ; @@v4@@ = re_string_context_at ( @@a1@@ , @@a3@@ , * ( _DWORD * ) ( @@a1@@ + Number ) ) ; for ( @@i@@ = Number L ; @@i@@ < * ( _QWORD * ) ( @@a2@@ + Number ) ; ++ @@i@@ ) { if ( check_halt_node_context ( * ( _QWORD * * ) ( @@a1@@ + Number ) , * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) , @@v4@@ ) ) { return * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) ; } } return Number L ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , off_76FE , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
__int64 __fastcall re_node_set_init_1 ( _QWORD * @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; * @@a1@@ = Number L ; @@a1@@ [ Number ] = Number L ; @@a1@@ [ Number ] = malloc ( Number ) ; if ( @@a1@@ [ Number ] ) { * ( _QWORD * ) @@a1@@ [ Number ] = @@a2@@ ; @@result@@ = Number L ; } else { @@a1@@ [ Number ] = Number L ; * @@a1@@ = @@a1@@ [ Number ] ; @@result@@ = Number L ; } return @@result@@ ; }
char * __fastcall idle_string ( time_t @@a1@@ , time_t @@a2@@ ) { if ( now_5644 == Number ) time ( & now_5644 ) ; if ( @@a2@@ >= @@a1@@ || @@a1@@ <= now_5644 - Number || @@a1@@ > now_5644 ) { return gettext ( String ) ; } if ( ( int ) now_5644 - ( int ) @@a1@@ <= Number ) return String ; sprintf ( idle_hhmm_5646 , String , ( unsigned int ) ( ( ( int ) now_5644 - ( int ) @@a1@@ ) / Number ) , ( unsigned int ) ( ( ( int ) now_5644 - ( int ) @@a1@@ ) % Number / Number ) ) ; return idle_hhmm_5646 ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall free_fail_stack_return ( __int64 @@a1@@ ) { unsigned __int64 @@i@@ ; if ( @@a1@@ ) { for ( @@i@@ = Number L ; @@i@@ < * ( _QWORD * ) @@a1@@ ; ++ @@i@@ ) { free ( * ( void * * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@i@@ + Number ) ) ; free ( * ( void * * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@i@@ + Number ) ) ; } free ( * ( void * * ) ( @@a1@@ + Number ) ) ; } return Number L ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
unsigned __int64 __fastcall print_boottime ( __int64 @@a1@@ ) { char * @@v1@@ ; char * @@v2@@ ; @@v1@@ = time_string ( @@a1@@ ) ; @@v2@@ = gettext ( String ) ; return print_line ( Number , ( __int64 ) & locale , Number , Number , ( __int64 ) @@v2@@ , ( __int64 ) @@v1@@ , & locale , & locale , ( __int64 ) & locale , & locale ) ; }
__int64 __fastcall re_node_set_init_copy ( void * @@a1@@ , __int64 @@a2@@ ) { * ( ( _QWORD * ) @@a1@@ + Number ) = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) ) { * ( _QWORD * ) @@a1@@ = * ( ( _QWORD * ) @@a1@@ + Number ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = malloc ( Number L * * ( _QWORD * ) @@a1@@ ) ; if ( ! * ( ( _QWORD * ) @@a1@@ + Number ) ) { * ( ( _QWORD * ) @@a1@@ + Number ) = Number L ; * ( _QWORD * ) @@a1@@ = * ( ( _QWORD * ) @@a1@@ + Number ) ; return Number L ; } memcpy ( * ( ( void * * ) @@a1@@ + Number ) , * ( const void * * ) ( @@a2@@ + Number ) , Number L * * ( _QWORD * ) ( @@a2@@ + Number ) ) ; } else { memset ( @@a1@@ , Number , Number ) ; } return Number L ; }
__int64 __fastcall bkm_scale_0 ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( * @@a1@@ >= ( __int64 ) Number / @@a2@@ ) { if ( Number / @@a2@@ >= * @@a1@@ ) { * @@a1@@ *= @@a2@@ ; @@result@@ = Number L ; } else { * @@a1@@ = Number ; @@result@@ = Number L ; } } else { * @@a1@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
unsigned __int64 __fastcall print_initspawn ( __int64 @@a1@@ ) { char * @@v1@@ ; char * @@ptr@@ ; char @@s@@ [ Number ] ; unsigned __int64 @@v5@@ ; @@v5@@ = __readfsqword ( Number ) ; @@ptr@@ = make_id_equals_comment ( @@a1@@ ) ; sprintf ( @@s@@ , String , * ( int * ) ( @@a1@@ + Number ) ) ; @@v1@@ = time_string ( @@a1@@ ) ; print_line ( Number , ( __int64 ) & locale , Number , Number , @@a1@@ + Number , ( __int64 ) @@v1@@ , & locale , @@s@@ , ( __int64 ) @@ptr@@ , & locale ) ; free ( @@ptr@@ ) ; return __readfsqword ( Number ) ^ @@v5@@ ; }
_QWORD * __fastcall update_regs ( _QWORD * @@a1@@ , _QWORD * @@a2@@ , void * @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ , unsigned __int64 @@a6@@ ) { _QWORD * @@result@@ ; int @@v7@@ ; unsigned __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@result@@ = ( _QWORD * ) * ( unsigned __int8 * ) ( Number * @@a4@@ + * @@a1@@ + Number ) ; @@v7@@ = * ( unsigned __int8 * ) ( Number * @@a4@@ + * @@a1@@ + Number ) ; if ( @@v7@@ == Number ) { @@v9@@ = * ( _QWORD * ) ( Number * @@a4@@ + * @@a1@@ ) + Number L ; @@result@@ = ( _QWORD * ) @@v9@@ ; if ( @@v9@@ < @@a6@@ ) { @@a2@@ [ Number * @@v9@@ ] = @@a5@@ ; @@result@@ = & @@a2@@ [ Number * @@v9@@ ] ; @@result@@ [ Number ] = Number ; } } else if ( @@v7@@ == Number ) { @@v8@@ = * ( _QWORD * ) ( Number * @@a4@@ + * @@a1@@ ) + Number L ; @@result@@ = ( _QWORD * ) @@v8@@ ; if ( @@v8@@ < @@a6@@ ) { if ( ( unsigned __int64 ) @@a5@@ <= @@a2@@ [ Number * @@v8@@ ] ) { if ( ( * ( _BYTE * ) ( Number * @@a4@@ + * @@a1@@ + Number ) & Number ) == Number || * ( ( _QWORD * ) @@a3@@ + Number * @@v8@@ ) == Number ) { @@result@@ = @@a5@@ ; @@a2@@ [ Number * @@v8@@ + Number ] = @@a5@@ ; } else { @@result@@ = memcpy ( @@a2@@ , @@a3@@ , Number * @@a6@@ ) ; } } else { @@a2@@ [ Number * @@v8@@ + Number ] = @@a5@@ ; @@result@@ = memcpy ( @@a3@@ , @@a2@@ , Number * @@a6@@ ) ; } } } return @@result@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
__int64 __fastcall re_node_set_insert_last ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v3@@ ; __int64 @@v4@@ ; void * @@v6@@ ; if ( * ( _QWORD * ) @@a1@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ) { * ( _QWORD * ) @@a1@@ = Number * ( * ( _QWORD * ) @@a1@@ + Number L ) ; @@v6@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number L * * ( _QWORD * ) @@a1@@ ) ; if ( ! @@v6@@ ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v6@@ ; } @@v3@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v4@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v4@@ + Number ; * ( _QWORD * ) ( @@v3@@ + Number * @@v4@@ ) = @@a2@@ ; return Number L ; }
unsigned __int64 print_heading ( ) { char * @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; char * @@v3@@ ; char * @@v4@@ ; char * @@v5@@ ; char * @@v7@@ ; @@v0@@ = gettext ( String ) ; @@v1@@ = gettext ( String ) ; @@v2@@ = gettext ( String ) ; @@v3@@ = gettext ( String ) ; @@v7@@ = gettext ( String ) ; @@v4@@ = gettext ( String ) ; @@v5@@ = gettext ( String ) ; return print_line ( Number , ( __int64 ) @@v5@@ , Number , Number , ( __int64 ) @@v4@@ , ( __int64 ) @@v7@@ , @@v3@@ , @@v2@@ , ( __int64 ) @@v1@@ , @@v0@@ ) ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_209038 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
_QWORD * __fastcall re_acquire_state ( _DWORD * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { _QWORD * @@result@@ ; unsigned __int64 @@i@@ ; __int64 @@v6@@ ; unsigned __int64 * @@v7@@ ; __int64 @@v8@@ ; _QWORD * @@v9@@ ; if ( * ( _QWORD * ) ( @@a3@@ + Number ) ) { @@v6@@ = calc_state_hash ( @@a3@@ , Number ) ; @@v7@@ = ( unsigned __int64 * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number * ( @@v6@@ & * ( _QWORD * ) ( @@a2@@ + Number ) ) ) ; for ( @@i@@ = Number L ; @@i@@ < * @@v7@@ ; ++ @@i@@ ) { @@v9@@ = * ( _QWORD * * ) ( Number * @@i@@ + @@v7@@ [ Number ] ) ; if ( @@v6@@ == * @@v9@@ && ( unsigned __int8 ) re_node_set_compare ( ( __int64 ) ( @@v9@@ + Number ) , @@a3@@ ) ) { return @@v9@@ ; } } @@v8@@ = create_ci_newstate ( @@a2@@ , @@a3@@ , @@v6@@ ) ; if ( ! @@v8@@ ) * @@a1@@ = Number ; @@result@@ = ( _QWORD * ) @@v8@@ ; } else { * @@a1@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall sub_epsilon_src_nodes ( _QWORD * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ ) { __int64 @@v4@@ ; unsigned int @@v8@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@j@@ ; __int64 @@v11@@ ; unsigned __int64 @@v12@@ ; unsigned __int64 @@v13@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; char @@s@@ [ Number ] ; void * @@ptr@@ ; unsigned __int64 @@v19@@ ; @@v19@@ = __readfsqword ( Number ) ; @@v11@@ = @@a1@@ [ Number ] + Number * @@a2@@ ; memset ( @@s@@ , Number , Number ) ; for ( @@i@@ = Number L ; @@i@@ < * ( _QWORD * ) ( @@v11@@ + Number ) ; ++ @@i@@ ) { @@v14@@ = * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@v11@@ + Number ) ) ; if ( @@v14@@ != @@a2@@ && ( * ( _BYTE * ) ( Number * @@v14@@ + * @@a1@@ + Number ) & Number ) != Number ) { @@v15@@ = * * ( _QWORD * * ) ( @@a1@@ [ Number ] + Number * @@v14@@ + Number ) ; @@v4@@ = * ( _QWORD * ) ( @@a1@@ [ Number ] + Number * @@v14@@ + Number ) <= Number ? Number : * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ [ Number ] + Number * @@v14@@ + Number ) + Number L ) ; if ( ( @@v16@@ = @@v4@@ , ! re_node_set_contains ( @@v11@@ , @@v15@@ ) ) && re_node_set_contains ( @@a3@@ , @@v15@@ ) || @@v16@@ - Number <= Number && ! re_node_set_contains ( @@v11@@ , @@v16@@ ) && re_node_set_contains ( @@a3@@ , @@v16@@ ) ) { @@v8@@ = re_node_set_add_intersect ( ( __int64 ) @@s@@ , @@a4@@ , @@a1@@ [ Number ] + Number * @@v14@@ ) ; if ( @@v8@@ ) { free ( @@ptr@@ ) ; return @@v8@@ ; } } } } for ( @@j@@ = Number L ; @@j@@ < * ( _QWORD * ) ( @@v11@@ + Number ) ; ++ @@j@@ ) { @@v12@@ = * ( _QWORD * ) ( Number * @@j@@ + * ( _QWORD * ) ( @@v11@@ + Number ) ) ; if ( ! re_node_set_contains ( ( __int64 ) @@s@@ , @@v12@@ ) ) { @@v13@@ = re_node_set_contains ( @@a3@@ , @@v12@@ ) - Number ; re_node_set_remove_at ( @@a3@@ , @@v13@@ ) ; } } free ( @@ptr@@ ) ; return Number L ; }
__mode_t umask ( __mode_t @@mask@@ ) { return umask ( @@mask@@ ) ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
__int64 __fastcall rpl_re_set_syntax ( __int64 @@a1@@ ) { __int64 @@v2@@ ; @@v2@@ = rpl_re_syntax_options ; rpl_re_syntax_options = @@a1@@ ; return @@v2@@ ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; char * @@v3@@ ; FILE * @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; FILE * @@v10@@ ; char * @@v11@@ ; FILE * @@v12@@ ; char * @@v13@@ ; FILE * @@v14@@ ; char * @@v15@@ ; FILE * @@v16@@ ; char * @@v17@@ ; FILE * @@v18@@ ; char * @@v19@@ ; char * @@v20@@ ; @@v1@@ = program_name ; if ( @@a1@@ ) { @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = gettext ( String ) ; printf ( @@v3@@ , @@v1@@ ) ; @@v4@@ = stdout ; @@v5@@ = gettext ( String ) ; fputs_unlocked ( @@v5@@ , @@v4@@ ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String String String String String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; @@v8@@ = stdout ; @@v9@@ = gettext ( String ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = stdout ; @@v11@@ = gettext ( String String String ) ; fputs_unlocked ( @@v11@@ , @@v10@@ ) ; @@v12@@ = stdout ; @@v13@@ = gettext ( String String String String ) ; fputs_unlocked ( @@v13@@ , @@v12@@ ) ; @@v14@@ = stdout ; @@v15@@ = gettext ( String String String String ) ; fputs_unlocked ( @@v15@@ , @@v14@@ ) ; @@v16@@ = stdout ; @@v17@@ = gettext ( String ) ; fputs_unlocked ( @@v17@@ , @@v16@@ ) ; @@v18@@ = stdout ; @@v19@@ = gettext ( String ) ; fputs_unlocked ( @@v19@@ , @@v18@@ ) ; @@v20@@ = gettext ( String String String ) ; printf ( @@v20@@ , String , String ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
void __fastcall diagnose_copy_fd_failure ( int @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; char * @@v3@@ ; int * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; int * @@v7@@ ; __int64 @@v8@@ ; char * @@v9@@ ; int * @@v10@@ ; switch ( @@a1@@ ) { case Number : @@v5@@ = quote ( @@a2@@ ) ; @@v6@@ = gettext ( String ) ; @@v7@@ = __errno_location ( ) ; error ( Number , * @@v7@@ , @@v6@@ , @@v5@@ ) ; break ; case Number : @@v8@@ = quote ( @@a2@@ ) ; @@v9@@ = gettext ( String ) ; @@v10@@ = __errno_location ( ) ; error ( Number , * @@v10@@ , @@v9@@ , @@v8@@ ) ; break ; case Number : @@v2@@ = quote ( @@a2@@ ) ; @@v3@@ = gettext ( String ) ; @@v4@@ = __errno_location ( ) ; error ( Number , * @@v4@@ , @@v3@@ , @@v2@@ ) ; break ; default : abort ( ) ; } }
__int64 __fastcall check_subexp_matching_top ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { unsigned int @@v5@@ ; unsigned __int64 @@i@@ ; _QWORD * @@v7@@ ; __int64 @@v8@@ ; @@v7@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; for ( @@i@@ = Number L ; @@i@@ < * ( _QWORD * ) ( @@a2@@ + Number ) ; ++ @@i@@ ) { @@v8@@ = * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) ; if ( * ( _BYTE * ) ( Number * @@v8@@ + * @@v7@@ + Number ) == Number && * ( _QWORD * ) ( Number * @@v8@@ + * @@v7@@ ) <= Number && ( ( @@v7@@ [ Number ] >> * ( _QWORD * ) ( Number * @@v8@@ + * @@v7@@ ) ) & Number L ) != Number ) { @@v5@@ = match_ctx_add_subtop ( @@a1@@ , @@v8@@ , @@a3@@ ) ; if ( @@v5@@ ) return @@v5@@ ; } } return Number L ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; char * @@v3@@ ; FILE * @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; FILE * @@v10@@ ; char * @@v11@@ ; FILE * @@v12@@ ; char * @@v13@@ ; FILE * @@v14@@ ; char * @@v15@@ ; @@v1@@ = program_name ; if ( @@a1@@ ) { @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = gettext ( String ) ; printf ( @@v3@@ , @@v1@@ ) ; @@v4@@ = stdout ; @@v5@@ = gettext ( String ) ; fputs_unlocked ( @@v5@@ , @@v4@@ ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; @@v8@@ = stdout ; @@v9@@ = gettext ( String ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = stdout ; @@v11@@ = gettext ( String ) ; fputs_unlocked ( @@v11@@ , @@v10@@ ) ; @@v12@@ = stdout ; @@v13@@ = gettext ( String ) ; fputs_unlocked ( @@v13@@ , @@v12@@ ) ; @@v14@@ = stdout ; @@v15@@ = gettext ( String ) ; fputs_unlocked ( @@v15@@ , @@v14@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
__int64 __fastcall rpl_regcomp ( __int64 @@a1@@ , const char * @@a2@@ , int @@a3@@ ) { __int64 @@v3@@ ; size_t @@v5@@ ; unsigned int @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; if ( ( @@a3@@ & Number ) != Number ) @@v3@@ = Number L ; else @@v3@@ = Number L ; @@v8@@ = @@v3@@ ; * ( _QWORD * ) @@a1@@ = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = malloc ( Number ) ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; @@v9@@ = ( @@a3@@ << Number ) & Number | ( unsigned __int64 ) @@v8@@ ; if ( ( @@a3@@ & Number ) != Number ) { @@v9@@ = @@v9@@ & Number | Number ; * ( _BYTE * ) ( @@a1@@ + Number ) |= Number ; } else { * ( _BYTE * ) ( @@a1@@ + Number ) &= Number ; } * ( _BYTE * ) ( @@a1@@ + Number ) = ( Number * ( ( @@a3@@ & Number ) != Number ) ) | * ( _BYTE * ) ( @@a1@@ + Number ) & Number ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; @@v5@@ = strlen ( @@a2@@ ) ; @@v7@@ = re_compile_internal ( @@a1@@ , @@a2@@ , @@v5@@ , @@v9@@ ) ; if ( @@v7@@ == Number ) @@v7@@ = Number ; if ( @@v7@@ ) { free ( * ( void * * ) ( @@a1@@ + Number ) ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; } else { rpl_re_compile_fastmap ( @@a1@@ ) ; } return @@v7@@ ; }
_BOOL8 __fastcall c_isxdigit ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number || ( int ) ( @@a1@@ & Number ) > Number && ( int ) ( @@a1@@ & Number ) <= Number ; }
__int64 __fastcall head_bytes ( __int64 @@a1@@ , unsigned int @@a2@@ , unsigned __int64 @@a3@@ ) { __int64 @@v3@@ ; char * @@v4@@ ; int * @@v5@@ ; char * @@v7@@ ; int * @@v8@@ ; unsigned __int64 @@v10@@ ; unsigned __int64 @@n@@ ; char @@ptr@@ [ Number ] ; unsigned __int64 @@v13@@ ; @@v13@@ = __readfsqword ( Number ) ; @@v10@@ = Number ; while ( @@a3@@ ) { if ( @@a3@@ < @@v10@@ ) @@v10@@ = @@a3@@ ; @@n@@ = safe_read ( @@a2@@ , @@ptr@@ , @@v10@@ ) ; if ( @@n@@ == Number ) { @@v3@@ = quote ( @@a1@@ ) ; @@v4@@ = gettext ( String ) ; @@v5@@ = __errno_location ( ) ; error ( Number , * @@v5@@ , @@v4@@ , @@v3@@ ) ; return Number L ; } if ( ! @@n@@ ) break ; if ( @@n@@ > fwrite_unlocked ( @@ptr@@ , Number , @@n@@ , stdout ) ) { @@v7@@ = gettext ( String ) ; @@v8@@ = __errno_location ( ) ; error ( Number , * @@v8@@ , @@v7@@ ) ; } @@a3@@ -= @@n@@ ; } return Number L ; }
__int64 __fastcall check_arrival_expand_ecl ( _QWORD * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , unsigned int @@a4@@ ) { __int64 @@v5@@ ; unsigned int @@v8@@ ; unsigned int @@v9@@ ; unsigned __int64 @@i@@ ; __int64 @@v11@@ ; __int64 @@v12@@ ; __int64 @@v13@@ [ Number ] ; void * @@ptr@@ ; unsigned __int64 @@v15@@ ; @@v15@@ = __readfsqword ( Number ) ; @@v8@@ = re_node_set_alloc ( @@v13@@ , * ( _QWORD * ) ( @@a2@@ + Number ) ) ; if ( @@v8@@ ) return @@v8@@ ; for ( @@i@@ = Number L ; @@i@@ < * ( _QWORD * ) ( @@a2@@ + Number ) ; ++ @@i@@ ) { @@v11@@ = * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) ; @@v12@@ = @@a1@@ [ Number ] + Number * @@v11@@ ; if ( find_subexp_node ( @@a1@@ , @@v12@@ , @@a3@@ , @@a4@@ ) == Number ) { @@v9@@ = re_node_set_merge ( ( __int64 ) @@v13@@ , @@v12@@ ) ; if ( @@v9@@ ) goto LABEL_6 ; } else { @@v9@@ = check_arrival_expand_ecl_sub ( @@a1@@ , @@v13@@ , @@v11@@ , @@a3@@ , @@a4@@ ) ; if ( @@v9@@ ) { LABEL_6 : free ( @@ptr@@ ) ; return @@v9@@ ; } } } free ( * ( void * * ) ( @@a2@@ + Number ) ) ; @@v5@@ = @@v13@@ [ Number ] ; * ( _QWORD * ) @@a2@@ = @@v13@@ [ Number ] ; * ( _QWORD * ) ( @@a2@@ + Number ) = @@v5@@ ; * ( _QWORD * ) ( @@a2@@ + Number ) = @@ptr@@ ; return Number L ; }
__int64 __fastcall mode_create_from_ref ( char * @@a1@@ ) { __int64 @@result@@ ; struct stat @@v2@@ ; unsigned __int64 @@v3@@ ; @@v3@@ = __readfsqword ( Number ) ; if ( ( unsigned int ) stat ( @@a1@@ , & @@v2@@ ) ) @@result@@ = Number L ; else @@result@@ = make_node_op_equals ( @@v2@@ . st_mode , Number ) ; return @@result@@ ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
__int64 __fastcall postorder ( _QWORD * @@a1@@ , __int64 ( __fastcall * @@a2@@ ( ) ( void , bintreet0 ) ) ( __int64 , _QWORD * ) , __int64 @@a3@@ ) { unsigned int @@v5@@ ; _QWORD * @@v7@@ ; LABEL_5 : while ( @@a1@@ [ Number ] || @@a1@@ [ Number ] ) { if ( @@a1@@ [ Number ] ) @@a1@@ = ( _QWORD * ) @@a1@@ [ Number ] ; else @@a1@@ = ( _QWORD * ) @@a1@@ [ Number ] ; } while ( Number ) { @@v5@@ = @@a2@@ ( ) ( void , bintreet0 ) ( @@a3@@ , @@a1@@ ) ; if ( @@v5@@ ) return @@v5@@ ; if ( ! * @@a1@@ ) return Number L ; @@v7@@ = @@a1@@ ; @@a1@@ = ( _QWORD * ) * @@a1@@ ; if ( @@v7@@ != ( _QWORD * ) @@a1@@ [ Number ] && @@a1@@ [ Number ] ) { @@a1@@ = ( _QWORD * ) @@a1@@ [ Number ] ; goto LABEL_5 ; } } }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
__int64 __fastcall extend_buffers ( __int64 @@a1@@ ) { unsigned int @@v2@@ ; unsigned int @@v3@@ ; void * @@v4@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) > Number ) return Number L ; @@v2@@ = re_string_realloc_buffers ( @@a1@@ , Number L * * ( _QWORD * ) ( @@a1@@ + Number ) ) ; if ( @@v2@@ ) return @@v2@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) { @@v4@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number * ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L ) ) ; if ( ! @@v4@@ ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v4@@ ; } if ( * ( _BYTE * ) ( @@a1@@ + Number ) ) { if ( * ( int * ) ( @@a1@@ + Number ) <= Number ) { build_upper_buffer ( ( _QWORD * ) @@a1@@ ) ; } else { @@v3@@ = build_wcs_upper_buffer ( @@a1@@ ) ; if ( @@v3@@ ) return @@v3@@ ; } } else if ( * ( int * ) ( @@a1@@ + Number ) <= Number ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) re_string_translate_buffer ( ( _QWORD * ) @@a1@@ ) ; } else { build_wcs_buffer ( @@a1@@ ) ; } return Number L ; }
__int64 __fastcall string_to_integer ( char @@a1@@ , const char * @@a2@@ ) { char * @@v2@@ ; char * @@v3@@ ; char * @@v4@@ ; int @@v6@@ ; __int64 @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; @@v6@@ = xstrtoumax ( @@a2@@ , Number L , Number L , @@v7@@ , String ) ; if ( @@v6@@ == Number ) { if ( @@a1@@ ) @@v2@@ = gettext ( String ) ; else @@v2@@ = gettext ( String ) ; @@v3@@ = gettext ( String ) ; error ( Number , Number , @@v3@@ , @@a2@@ , @@v2@@ ) ; } if ( @@v6@@ ) { if ( @@a1@@ ) @@v4@@ = gettext ( String ) ; else @@v4@@ = gettext ( String ) ; error ( Number , Number , String , @@a2@@ , @@v4@@ ) ; } return @@v7@@ [ Number ] ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
__int64 __fastcall lower_subexps ( __int64 @@a1@@ , __int64 @@a2@@ ) { unsigned int @@v3@@ ; __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; @@v5@@ = __readfsqword ( Number ) ; @@v4@@ = @@a1@@ ; @@v3@@ = Number ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) ) { if ( * ( _BYTE * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) == Number ) { * ( _QWORD * ) ( @@a2@@ + Number ) = lower_subexp ( & @@v3@@ , @@v4@@ , * ( _QWORD * ) ( @@a2@@ + Number ) ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) ) * * ( _QWORD * * ) ( @@a2@@ + Number ) = @@a2@@ ; } } if ( * ( _QWORD * ) ( @@a2@@ + Number ) ) { if ( * ( _BYTE * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) == Number ) { * ( _QWORD * ) ( @@a2@@ + Number ) = lower_subexp ( & @@v3@@ , @@v4@@ , * ( _QWORD * ) ( @@a2@@ + Number ) ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) ) * * ( _QWORD * * ) ( @@a2@@ + Number ) = @@a2@@ ; } } return @@v3@@ ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
_QWORD * __fastcall match_ctx_add_sublast ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v5@@ ; void * @@v6@@ ; _QWORD * @@v7@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) == * ( _QWORD * ) ( @@a1@@ + Number ) ) { @@v5@@ = Number L * * ( _QWORD * ) ( @@a1@@ + Number ) + Number ; @@v6@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number * @@v5@@ ) ; if ( ! @@v6@@ ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v6@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v5@@ ; } @@v7@@ = calloc ( Number , Number ) ; if ( @@v7@@ ) { * ( _QWORD * ) ( Number L * * ( _QWORD * ) ( @@a1@@ + Number ) + * ( _QWORD * ) ( @@a1@@ + Number ) ) = @@v7@@ ; * @@v7@@ = @@a2@@ ; @@v7@@ [ Number ] = @@a3@@ ; ++ * ( _QWORD * ) ( @@a1@@ + Number ) ; } return @@v7@@ ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( is_mul_ok ( @@a2@@ , * @@a1@@ ) ) { * @@a1@@ *= @@a2@@ ; @@result@@ = Number L ; } else { * @@a1@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_20F038 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
__int64 __fastcall duplicate_node ( _QWORD * @@a1@@ , __int64 @@a2@@ , __int16 @@a3@@ ) { __int64 @@v5@@ ; @@v5@@ = re_dfa_add_node ( ( __int64 ) @@a1@@ , * ( _QWORD * ) ( Number * @@a2@@ + * @@a1@@ ) , * ( _QWORD * ) ( Number * @@a2@@ + * @@a1@@ + Number ) ) ; if ( @@v5@@ != Number ) { * ( _DWORD * ) ( * @@a1@@ + Number * @@v5@@ + Number ) = ( ( @@a3@@ & Number ) << Number ) | * ( _DWORD * ) ( * @@a1@@ + Number * @@v5@@ + Number ) & Number ; * ( _DWORD * ) ( Number * @@v5@@ + * @@a1@@ + Number ) = ( ( ( ( * ( _DWORD * ) ( Number * @@a2@@ + * @@a1@@ + Number ) >> Number ) & Number | ( * ( _DWORD * ) ( Number * @@v5@@ + * @@a1@@ + Number ) >> Number ) & Number ) & Number ) << Number ) | * ( _DWORD * ) ( Number * @@v5@@ + * @@a1@@ + Number ) & Number ; * ( _BYTE * ) ( Number * @@v5@@ + * @@a1@@ + Number ) |= Number ; * ( _QWORD * ) ( @@a1@@ [ Number ] + Number * @@v5@@ ) = @@a2@@ ; } return @@v5@@ ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_207028 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
__int64 __fastcall parse_branch ( __int64 @@a1@@ , __int64 * @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , _DWORD * @@a6@@ ) { __int64 @@v11@@ ; __int64 @@v12@@ ; __int64 @@v13@@ ; @@v12@@ = * @@a2@@ ; @@v11@@ = parse_expression ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( * @@a6@@ && ! @@v11@@ ) return Number L ; while ( * ( _BYTE * ) ( @@a3@@ + Number ) != Number && * ( _BYTE * ) ( @@a3@@ + Number ) != Number && ( ! @@a5@@ || * ( _BYTE * ) ( @@a3@@ + Number ) != Number ) ) { @@v13@@ = parse_expression ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( * @@a6@@ && ! @@v13@@ ) return Number L ; if ( @@v11@@ && @@v13@@ ) { @@v11@@ = create_tree ( @@v12@@ , @@v11@@ , @@v13@@ , Number L ) ; if ( ! @@v11@@ ) { * @@a6@@ = Number ; return Number L ; } } else if ( ! @@v11@@ ) { @@v11@@ = @@v13@@ ; } } return @@v11@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
int __fxstat ( int @@ver@@ , int @@fildes@@ , struct stat * @@stat_buf@@ ) { return _fxstat ( @@ver@@ , @@fildes@@ , @@stat_buf@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 __fastcall parse_bracket_symbol ( __int64 @@a1@@ , _QWORD * @@a2@@ , char * @@a3@@ ) { __int64 @@v4@@ ; __int64 @@v5@@ ; int @@v6@@ ; char @@v9@@ ; char @@v10@@ ; int @@v11@@ ; @@v10@@ = * @@a3@@ ; @@v11@@ = Number ; if ( @@a2@@ [ Number ] <= @@a2@@ [ Number ] ) return Number L ; while ( Number ) { if ( @@v11@@ > Number ) return Number L ; if ( @@a3@@ [ Number ] == Number ) { @@v9@@ = re_string_fetch_byte_case ( ( __int64 ) @@a2@@ ) ; } else { @@v4@@ = @@a2@@ [ Number ] ; @@v5@@ = @@a2@@ [ Number ] ; @@a2@@ [ Number ] = @@v5@@ + Number ; @@v9@@ = * ( _BYTE * ) ( @@v4@@ + @@v5@@ ) ; } if ( @@a2@@ [ Number ] <= @@a2@@ [ Number ] ) return Number L ; if ( @@v9@@ == @@v10@@ && * ( _BYTE * ) ( @@a2@@ [ Number ] + @@a2@@ [ Number ] ) == Number ) { break ; } * ( _BYTE * ) ( @@v11@@ ++ + * ( _QWORD * ) ( @@a1@@ + Number ) ) = @@v9@@ ; } ++ @@a2@@ [ Number ] ; * ( _BYTE * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@v11@@ ) = Number ; @@v6@@ = ( unsigned __int8 ) @@a3@@ [ Number ] ; switch ( @@v6@@ ) { case Number : * ( _DWORD * ) @@a1@@ = Number ; break ; case Number : * ( _DWORD * ) @@a1@@ = Number ; break ; case Number : * ( _DWORD * ) @@a1@@ = Number ; break ; } return Number L ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_20F1A8 ; @@v8@@ [ Number ] = qword_20F1B0 ; @@v8@@ [ Number ] = qword_20F1B8 ; @@v8@@ [ Number ] = qword_20F1C0 ; @@v8@@ [ Number ] = qword_20F1C8 ; @@v8@@ [ Number ] = qword_20F1D0 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
void __fastcall free_token ( __int64 @@a1@@ ) { if ( * ( _BYTE * ) ( @@a1@@ + Number ) != Number || ( * ( _BYTE * ) ( @@a1@@ + Number ) & Number ) != Number ) { if ( * ( _BYTE * ) ( @@a1@@ + Number ) == Number && ( * ( _BYTE * ) ( @@a1@@ + Number ) & Number ) == Number ) free ( * ( void * * ) @@a1@@ ) ; } else { free_charset ( * ( void * * * ) @@a1@@ ) ; } }
__int64 __fastcall copy_fd ( unsigned int @@a1@@ , FILE * @@a2@@ , unsigned __int64 @@a3@@ ) { __int64 @@v3@@ ; unsigned __int64 @@n@@ ; char @@ptr@@ [ Number ] ; unsigned __int64 @@v8@@ ; @@v8@@ = __readfsqword ( Number ) ; while ( @@a3@@ ) { @@v3@@ = Number ; if ( @@a3@@ <= Number ) @@v3@@ = @@a3@@ ; @@n@@ = safe_read ( @@a1@@ , @@ptr@@ , @@v3@@ ) ; if ( @@n@@ == Number ) return Number L ; @@a3@@ -= @@n@@ ; if ( ! @@n@@ && @@a3@@ ) return Number L ; if ( @@n@@ > fwrite_unlocked ( @@ptr@@ , Number , @@n@@ , @@a2@@ ) ) return Number L ; } return Number L ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@v2@@ ; @@v2@@ = malloc ( @@a1@@ ) ; if ( ! @@v2@@ && @@a1@@ ) xalloc_die ( ) ; return @@v2@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
__int64 __fastcall rpl_re_match ( int @@a1@@ , int @@a2@@ , int @@a3@@ , int @@a4@@ , __int64 @@a5@@ ) { return re_search_stub ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , Number , @@a3@@ , @@a5@@ , Number ) ; }
__int64 __fastcall elide_tail_lines_file ( __int64 @@a1@@ , unsigned int @@a2@@ , size_t @@a3@@ ) { __int64 @@v5@@ ; __int64 @@v6@@ ; if ( presume_input_pipe == Number ) return elide_tail_lines_pipe ( @@a1@@ , @@a2@@ , @@a3@@ ) ; @@v5@@ = lseek ( @@a2@@ , Number L , Number ) ; @@v6@@ = lseek ( @@a2@@ , Number L , Number ) ; if ( @@v5@@ < Number || @@v5@@ >= @@v6@@ ) return elide_tail_lines_pipe ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( @@v6@@ ) return elide_tail_lines_seekable ( @@a1@@ , @@a2@@ , @@a3@@ , @@v5@@ , @@v6@@ ) ; return Number L ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
void * __fastcall xzalloc ( size_t @@a1@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@a1@@ ) ; return memset ( @@v1@@ , Number , @@a1@@ ) ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
__int64 __fastcall rpl_re_search ( int @@a1@@ , int @@a2@@ , int @@a3@@ , int @@a4@@ , int @@a5@@ , __int64 @@a6@@ ) { return re_search_stub ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a3@@ , @@a6@@ , Number ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall rpl_re_search_2 ( int @@a1@@ , int @@a2@@ , int @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ , __int64 @@a7@@ , __int64 @@a8@@ , __int64 @@a9@@ ) { return re_search_2_stub ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ , @@a7@@ , @@a8@@ , @@a9@@ , Number ) ; }
__int64 __fastcall head ( const char * @@a1@@ , unsigned int @@a2@@ , size_t @@a3@@ , char @@a4@@ , char @@a5@@ ) { __int64 @@result@@ ; if ( print_headers ) write_header ( @@a1@@ ) ; if ( @@a5@@ ) { if ( @@a4@@ ) @@result@@ = elide_tail_lines_file ( ( __int64 ) @@a1@@ , @@a2@@ , @@a3@@ ) ; else @@result@@ = elide_tail_bytes_file ( ( __int64 ) @@a1@@ , @@a2@@ , @@a3@@ ) ; } else if ( @@a4@@ ) { @@result@@ = head_lines ( ( __int64 ) @@a1@@ , @@a2@@ , @@a3@@ ) ; } else { @@result@@ = head_bytes ( ( __int64 ) @@a1@@ , @@a2@@ , @@a3@@ ) ; } return @@result@@ ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
ssize_t __fastcall safe_read ( int @@a1@@ , void * @@a2@@ , size_t @@a3@@ ) { ssize_t @@result@@ ; ssize_t @@v5@@ ; LABEL_1 : for ( @@result@@ = read ( @@a1@@ , @@a2@@ , @@a3@@ ) ; ; @@result@@ = read ( @@a1@@ , @@a2@@ , Number ) ) { @@v5@@ = @@result@@ ; if ( @@result@@ >= Number ) break ; if ( * __errno_location ( ) == Number ) goto LABEL_1 ; if ( * __errno_location ( ) != Number || @@a3@@ <= Number ) return @@v5@@ ; @@a3@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall full_read ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v5@@ ; __int64 @@v7@@ ; @@v5@@ = Number L ; while ( @@a3@@ ) { @@v7@@ = safe_read ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( @@v7@@ == Number ) break ; if ( ! @@v7@@ ) { * __errno_location ( ) = Number ; return @@v5@@ ; } @@v5@@ += @@v7@@ ; @@a2@@ += @@v7@@ ; @@a3@@ -= @@v7@@ ; } return @@v5@@ ; }
__int64 __fastcall re_copy_regs ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ , int @@a4@@ ) { _QWORD * @@v5@@ ; unsigned int @@v7@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@v9@@ ; void * @@ptr@@ ; void * @@v11@@ ; @@v7@@ = Number ; @@v9@@ = @@a3@@ + Number ; if ( @@a4@@ ) { if ( @@a4@@ == Number ) { if ( @@v9@@ > * ( _QWORD * ) @@a1@@ ) { @@ptr@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number * @@v9@@ ) ; if ( ! @@ptr@@ ) return Number L ; @@v11@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number * @@v9@@ ) ; if ( ! @@v11@@ ) { free ( @@ptr@@ ) ; return Number L ; } * ( _QWORD * ) ( @@a1@@ + Number ) = @@ptr@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v11@@ ; * ( _QWORD * ) @@a1@@ = @@v9@@ ; } } else { if ( @@a4@@ != Number ) __assert_fail ( String , String , Number , String ) ; if ( @@a3@@ > * ( _QWORD * ) @@a1@@ ) __assert_fail ( String , String , Number , String ) ; @@v7@@ = Number ; } } else { * ( _QWORD * ) ( @@a1@@ + Number ) = malloc ( Number * @@v9@@ ) ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = malloc ( Number * @@v9@@ ) ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) { free ( * ( void * * ) ( @@a1@@ + Number ) ) ; return Number L ; } * ( _QWORD * ) @@a1@@ = @@v9@@ ; } for ( @@i@@ = Number L ; @@i@@ < @@a3@@ ; ++ @@i@@ ) { * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@i@@ ) = * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@i@@ ) = * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ + Number ) ; } while ( @@i@@ < * ( _QWORD * ) @@a1@@ ) { @@v5@@ = ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) ; * @@v5@@ = Number ; * ( _QWORD * ) ( Number * @@i@@ ++ + * ( _QWORD * ) ( @@a1@@ + Number ) ) = * @@v5@@ ; } return @@v7@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
char * nl_langinfo ( nl_item @@item@@ ) { return nl_langinfo ( @@item@@ ) ; }
int getc_unlocked ( FILE * @@stream@@ ) { return getc_unlocked ( @@stream@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 __fastcall sift_states_backward ( __int64 @@a1@@ , __int64 @@a2@@ ) { int @@v3@@ ; unsigned int @@v4@@ ; unsigned int @@v5@@ ; int @@v6@@ ; __int64 @@v7@@ ; void * @@v8@@ [ Number ] ; void * @@ptr@@ ; unsigned __int64 @@v10@@ ; @@v10@@ = __readfsqword ( Number ) ; @@v6@@ = Number ; @@v7@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@v4@@ = re_node_set_init_1 ( @@v8@@ , * ( _QWORD * ) ( @@a2@@ + Number ) ) ; if ( @@v4@@ ) return @@v4@@ ; @@v5@@ = update_cur_sifted_state ( @@a1@@ , @@a2@@ , @@v7@@ , @@v8@@ ) ; if ( ! @@v5@@ ) { while ( @@v7@@ ) { if ( * ( _QWORD * ) ( Number * @@v7@@ + * ( _QWORD * ) @@a2@@ ) ) @@v3@@ = Number ; else @@v3@@ = @@v6@@ + Number ; @@v6@@ = @@v3@@ ; if ( @@v3@@ > * ( _DWORD * ) ( @@a1@@ + Number ) ) { memset ( * ( void * * ) @@a2@@ , Number , Number * @@v7@@ ) ; free ( @@ptr@@ ) ; return Number L ; } @@v8@@ [ Number ] = Number L ; -- @@v7@@ ; if ( ! * ( _QWORD * ) ( Number * @@v7@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) || ( @@v5@@ = build_sifted_states ( @@a1@@ , @@a2@@ , @@v7@@ , @@v8@@ ) ) == Number ) { @@v5@@ = update_cur_sifted_state ( @@a1@@ , @@a2@@ , @@v7@@ , @@v8@@ ) ; if ( ! @@v5@@ ) continue ; } goto LABEL_15 ; } @@v5@@ = Number ; } LABEL_15 : free ( @@ptr@@ ) ; return @@v5@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
int putchar_unlocked ( int @@c@@ ) { return putchar_unlocked ( @@c@@ ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
wint_t towlower ( wint_t @@wc@@ ) { return towlower ( @@wc@@ ) ; }
__int64 __fastcall add_epsilon_src_nodes ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { unsigned int @@v5@@ ; unsigned __int64 @@i@@ ; _QWORD * @@v7@@ ; unsigned __int64 @@v8@@ ; @@v8@@ = __readfsqword ( Number ) ; @@v5@@ = Number ; @@v7@@ = re_acquire_state ( & @@v5@@ , @@a1@@ , @@a2@@ ) ; if ( @@v5@@ ) return @@v5@@ ; if ( ! @@v7@@ [ Number ] ) { @@v5@@ = re_node_set_alloc ( @@v7@@ + Number , * ( _QWORD * ) ( @@a2@@ + Number ) ) ; if ( @@v5@@ ) return Number L ; for ( @@i@@ = Number L ; @@i@@ < * ( _QWORD * ) ( @@a2@@ + Number ) ; ++ @@i@@ ) re_node_set_merge ( ( __int64 ) ( @@v7@@ + Number ) , * ( _QWORD * ) ( @@a1@@ + Number ) + Number L * * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) ) ; } return re_node_set_add_intersect ( @@a2@@ , @@a3@@ , ( __int64 ) ( @@v7@@ + Number ) ) ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
_QWORD * __fastcall mpz_sub ( _QWORD * @@a1@@ , _QWORD * @@a2@@ , __int64 * @@a3@@ ) { _QWORD * @@result@@ ; if ( * @@a2@@ < * @@a2@@ - * @@a3@@ != * @@a3@@ < Number ) integer_overflow ( Number L ) ; @@result@@ = @@a1@@ ; * @@a1@@ = * @@a2@@ - * @@a3@@ ; return @@result@@ ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
int feof_unlocked ( FILE * @@stream@@ ) { return feof_unlocked ( @@stream@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall mpz_get_str ( __int64 a1 , __int64 a2 , _QWORD * @@a3@@ ) { __int64 @@v3@@ ; char @@v5@@ [ Number ] ; unsigned __int64 @@v6@@ ; @@v6@@ = __readfsqword ( Number ) ; @@v3@@ = imaxtostr ( * @@a3@@ , @@v5@@ ) ; return xstrdup ( @@v3@@ ) ; }
__int64 __fastcall check_dst_limits_calc_pos ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ , unsigned __int64 @@a5@@ , __int64 @@a6@@ ) { __int64 @@result@@ ; int @@v7@@ ; int @@v8@@ ; __int64 @@v9@@ ; @@v9@@ = * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@a2@@ ; if ( @@a5@@ < * ( _QWORD * ) ( @@v9@@ + Number ) ) return Number ; if ( @@a5@@ > * ( _QWORD * ) ( @@v9@@ + Number ) ) return Number L ; if ( @@a5@@ == * ( _QWORD * ) ( @@v9@@ + Number ) ) @@v7@@ = Number ; else @@v7@@ = Number ; @@v8@@ = @@v7@@ | ( @@a5@@ == * ( _QWORD * ) ( @@v9@@ + Number ) ) ; if ( @@v8@@ ) @@result@@ = check_dst_limits_calc_pos_1 ( @@a1@@ , @@v8@@ , @@a3@@ , @@a4@@ , @@a6@@ ) ; else @@result@@ = Number L ; return @@result@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
_BOOL8 __fastcall mpz_fits_ulong_p ( _QWORD * @@a1@@ ) { return * @@a1@@ >= Number L ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
__int64 __fastcall transit_state ( _DWORD * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; unsigned __int8 @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; if ( ( * ( _BYTE * ) ( @@a3@@ + Number ) & Number ) != Number ) { * @@a1@@ = transit_state_mb ( @@a2@@ , @@a3@@ ) ; if ( * @@a1@@ ) return Number L ; } @@v4@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@v5@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; * ( _QWORD * ) ( @@a2@@ + Number ) = @@v5@@ + Number ; @@v9@@ = * ( _BYTE * ) ( @@v4@@ + @@v5@@ ) ; while ( Number ) { @@v10@@ = * ( _QWORD * ) ( @@a3@@ + Number ) ; if ( @@v10@@ ) return * ( _QWORD * ) ( Number L * @@v9@@ + @@v10@@ ) ; @@v11@@ = * ( _QWORD * ) ( @@a3@@ + Number ) ; if ( @@v11@@ ) break ; if ( ( unsigned __int8 ) build_trtable ( * ( _QWORD * ) ( @@a2@@ + Number ) , @@a3@@ ) != Number ) { * @@a1@@ = Number ; return Number L ; } } if ( ( re_string_context_at ( @@a2@@ , * ( _QWORD * ) ( @@a2@@ + Number ) - Number L , * ( _DWORD * ) ( @@a2@@ + Number ) ) & Number ) != Number ) @@v6@@ = Number * ( @@v9@@ + Number L ) ; else @@v6@@ = Number L * @@v9@@ ; return * ( _QWORD * ) ( @@v6@@ + @@v11@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ ) { return xmalloc ( @@a1@@ ) ; }
__int64 __fastcall readlinebuffer ( __int64 @@a1@@ , __int64 @@a2@@ ) { return readlinebuffer_delim ( @@a1@@ , @@a2@@ , Number L ) ; }
__int64 __fastcall check_arrival_add_next_nodes ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ ) { _QWORD * @@v5@@ ; unsigned int @@v8@@ ; int @@v9@@ ; unsigned __int64 @@i@@ ; _QWORD * @@v11@@ ; __int64 @@v12@@ ; unsigned __int64 @@v13@@ ; __int64 @@v14@@ ; __int64 @@v15@@ ; char @@s@@ [ Number ] ; __int64 @@v17@@ ; void * @@ptr@@ ; unsigned __int64 @@v19@@ ; @@v19@@ = __readfsqword ( Number ) ; @@v11@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; @@v8@@ = Number ; memset ( @@s@@ , Number , Number ) ; for ( @@i@@ = Number L ; @@i@@ < * ( _QWORD * ) ( @@a3@@ + Number ) ; ++ @@i@@ ) { @@v9@@ = Number ; @@v12@@ = * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a3@@ + Number ) ) ; if ( ( * ( _BYTE * ) ( Number * @@v12@@ + * @@v11@@ + Number ) & Number ) != Number ) { @@v9@@ = check_node_accept_bytes ( @@v11@@ , @@v12@@ , @@a1@@ , @@a2@@ ) ; if ( @@v9@@ > Number ) { @@v13@@ = * ( _QWORD * ) ( Number * @@v12@@ + @@v11@@ [ Number ] ) ; @@v14@@ = @@v9@@ + @@a2@@ ; @@v15@@ = * ( _QWORD * ) ( Number * @@v14@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) ; @@v17@@ = Number L ; if ( @@v15@@ ) { @@v8@@ = re_node_set_merge ( ( __int64 ) @@s@@ , @@v15@@ + Number ) ; if ( @@v8@@ ) goto LABEL_6 ; } if ( ! re_node_set_insert ( ( __int64 ) @@s@@ , @@v13@@ ) ) goto LABEL_8 ; @@v5@@ = ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@v14@@ ) ; * @@v5@@ = re_acquire_state ( & @@v8@@ , ( __int64 ) @@v11@@ , ( __int64 ) @@s@@ ) ; if ( ! * ( _QWORD * ) ( Number * @@v14@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) ) { if ( @@v8@@ ) { LABEL_6 : free ( @@ptr@@ ) ; return @@v8@@ ; } } } } if ( ( @@v9@@ || ( unsigned __int8 ) check_node_accept ( @@a1@@ , * @@v11@@ + Number * @@v12@@ , @@a2@@ ) ) && ! re_node_set_insert ( @@a4@@ , * ( _QWORD * ) ( Number * @@v12@@ + @@v11@@ [ Number ] ) ) ) { LABEL_8 : free ( @@ptr@@ ) ; return Number L ; } } free ( @@ptr@@ ) ; return Number L ; }
_BOOL8 __fastcall mpz_out_str ( FILE * @@a1@@ , __int64 a2 , _QWORD * @@a3@@ ) { const char * @@v3@@ ; char @@v5@@ [ Number ] ; unsigned __int64 @@v6@@ ; @@v6@@ = __readfsqword ( Number ) ; @@v3@@ = ( const char * ) imaxtostr ( * @@a3@@ , @@v5@@ ) ; return fputs_unlocked ( @@v3@@ , @@a1@@ ) != Number ; }
int __xstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _xstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
void __fastcall freebuffer ( __int64 @@a1@@ ) { free ( * ( void * * ) ( @@a1@@ + Number ) ) ; }
int __fastcall printv ( __int64 @@a1@@ ) { int @@result@@ ; if ( * ( _DWORD * ) @@a1@@ ) { if ( * ( _DWORD * ) @@a1@@ != Number ) abort ( ) ; @@result@@ = puts ( * ( const char * * ) ( @@a1@@ + Number ) ) ; } else { mpz_out_str ( stdout , Number L , ( _QWORD * ) ( @@a1@@ + Number ) ) ; @@result@@ = putchar_unlocked ( Number ) ; } return @@result@@ ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
unsigned int * __fastcall tostring ( unsigned int * @@a1@@ ) { unsigned int * @@result@@ ; __int64 @@v2@@ ; @@result@@ = ( unsigned int * ) * @@a1@@ ; if ( ( _DWORD ) @@result@@ ) { if ( ( _DWORD ) @@result@@ != Number ) abort ( ) ; } else { @@v2@@ = mpz_get_str ( Number L , Number L , ( _QWORD * ) @@a1@@ + Number ) ; mpz_clear ( ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = @@v2@@ ; @@result@@ = @@a1@@ ; * @@a1@@ = Number ; } return @@result@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
int __fastcall fstat ( int @@fildes@@ , struct stat * @@stat_buf@@ ) { return __fxstat ( Number , @@fildes@@ , @@stat_buf@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
void * * __fastcall eval4 ( unsigned __int8 @@a1@@ ) { char * @@v2@@ ; char * @@v3@@ ; int @@v4@@ $B16BB1FB0E13686A99D5A99C8504F879 ; void * * @@v5@@ ; void * * @@v6@@ ; @@v5@@ = eval5 ( @@a1@@ ) ; while ( Number ) { if ( nextarg ( ( const char * ) & asc_1D394 [ Number ] ) ) { @@v4@@ $B16BB1FB0E13686A99D5A99C8504F879 = Number ; goto LABEL_9 ; } if ( nextarg ( ( const char * ) & asc_1D394 [ Number ] ) ) { @@v4@@ $B16BB1FB0E13686A99D5A99C8504F879 = Number ; goto LABEL_9 ; } if ( ! nextarg ( ( const char * ) & asc_1D394 [ Number ] ) ) return @@v5@@ ; @@v4@@ $B16BB1FB0E13686A99D5A99C8504F879 = Number ; LABEL_9 : @@v6@@ = eval5 ( @@a1@@ ) ; if ( @@a1@@ ) { if ( ( unsigned __int8 ) toarith ( ( __int64 ) @@v5@@ ) != Number || ( unsigned __int8 ) toarith ( ( __int64 ) @@v6@@ ) != Number ) { @@v2@@ = gettext ( String ) ; error ( Number , Number , @@v2@@ ) ; } if ( @@v4@@ $B16BB1FB0E13686A99D5A99C8504F879 && ! ( unsigned int ) mpz_sgn ( ( __int64 * ) @@v6@@ + Number ) ) { @@v3@@ = gettext ( String ) ; error ( Number , Number , @@v3@@ ) ; } if ( @@v4@@ $B16BB1FB0E13686A99D5A99C8504F879 ) { if ( @@v4@@ $B16BB1FB0E13686A99D5A99C8504F879 == Number ) mpz_tdiv_q ( ( __int64 * ) @@v5@@ + Number , @@v5@@ + Number , ( __int64 * ) @@v6@@ + Number ) ; else mpz_tdiv_r ( ( __int64 * ) @@v5@@ + Number , ( __int64 * ) @@v5@@ + Number , ( __int64 * ) @@v6@@ + Number ) ; } else { mpz_mul ( ( __int64 * ) @@v5@@ + Number , ( __int64 * ) @@v5@@ + Number , ( __int64 * ) @@v6@@ + Number ) ; } } freev ( @@v6@@ ) ; } }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
__int64 __fastcall bkm_scale ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( * @@a1@@ >= ( __int64 ) Number / @@a2@@ ) { if ( Number / @@a2@@ >= * @@a1@@ ) { * @@a1@@ *= @@a2@@ ; @@result@@ = Number L ; } else { * @@a1@@ = Number ; @@result@@ = Number L ; } } else { * @@a1@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
__int64 __fastcall bkm_scale_by_power_0 ( __int64 * @@a1@@ , int @@a2@@ , int @@a3@@ ) { unsigned int @@i@@ ; for ( @@i@@ = Number ; @@a3@@ -- ; @@i@@ |= bkm_scale_0 ( @@a1@@ , @@a2@@ ) ) { ; } return @@i@@ ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
__int64 __fastcall make_node_op_equals ( int @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; @@result@@ = xmalloc ( Number L ) ; * ( _BYTE * ) @@result@@ = Number ; * ( _BYTE * ) ( @@result@@ + Number ) = Number ; * ( _DWORD * ) ( @@result@@ + Number ) = Number ; * ( _DWORD * ) ( @@result@@ + Number ) = @@a1@@ ; * ( _DWORD * ) ( @@result@@ + Number ) = @@a2@@ ; * ( _BYTE * ) ( @@result@@ + Number ) = Number ; return @@result@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
int __fastcall write_header ( const char * @@a1@@ ) { const char * @@v1@@ ; int @@result@@ ; if ( first_file_5548 ) @@v1@@ = & locale ; else @@v1@@ = String ; @@result@@ = printf ( String , @@v1@@ , @@a1@@ ) ; first_file_5548 = Number ; return @@result@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_221588 ; @@v4@@ [ Number ] = qword_221590 ; @@v4@@ [ Number ] = qword_221598 ; @@v4@@ [ Number ] = qword_2215A0 ; @@v4@@ [ Number ] = qword_2215A8 ; @@v4@@ [ Number ] = qword_2215B0 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_222028 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
void * __fastcall bitset_empty ( void * @@a1@@ ) { return memset ( @@a1@@ , Number , Number ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_2220C8 ; @@v4@@ [ Number ] = qword_2220D0 ; @@v4@@ [ Number ] = qword_2220D8 ; @@v4@@ [ Number ] = qword_2220E0 ; @@v4@@ [ Number ] = qword_2220E8 ; @@v4@@ [ Number ] = qword_2220F0 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
__int64 __fastcall elide_tail_bytes_file ( __int64 @@a1@@ , unsigned int @@a2@@ , unsigned __int64 @@a3@@ ) { __int64 @@result@@ ; __int64 @@v4@@ ; char * @@v5@@ ; int * @@v6@@ ; unsigned __int64 @@v7@@ ; __int64 @@v8@@ ; char * @@v9@@ ; int * @@v10@@ ; int @@v12@@ ; __off_t @@whence@@ ; __off_t @@v14@@ ; unsigned __int64 @@v15@@ ; struct stat @@stat_buf@@ ; unsigned __int64 @@v17@@ ; @@v17@@ = __readfsqword ( Number ) ; if ( presume_input_pipe || ( unsigned int ) fstat ( @@a2@@ , & @@stat_buf@@ ) || ( @@stat_buf@@ . st_mode & Number ) != Number ) { return elide_tail_bytes_pipe ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } @@whence@@ = lseek ( @@a2@@ , Number L , Number ) ; if ( @@whence@@ == Number || ( @@v14@@ = lseek ( @@a2@@ , Number L , Number ) , @@v14@@ == Number ) ) { @@v4@@ = quote ( @@a1@@ ) ; @@v5@@ = gettext ( String ) ; @@v6@@ = __errno_location ( ) ; error ( Number , * @@v6@@ , @@v5@@ , @@v4@@ ) ; @@result@@ = Number L ; } else { if ( @@v14@@ - @@whence@@ < Number ) @@v7@@ = Number L ; else @@v7@@ = @@v14@@ - @@whence@@ ; @@v15@@ = @@v7@@ ; if ( @@v7@@ > @@a3@@ ) { if ( lseek ( @@a2@@ , Number L , @@whence@@ ) == Number ) { @@v8@@ = quote ( @@a1@@ ) ; @@v9@@ = gettext ( String ) ; @@v10@@ = __errno_location ( ) ; error ( Number , * @@v10@@ , @@v9@@ , @@v8@@ ) ; @@result@@ = Number L ; } else { @@v12@@ = copy_fd ( @@a2@@ , stdout , @@v15@@ - @@a3@@ ) ; if ( @@v12@@ ) { diagnose_copy_fd_failure ( @@v12@@ , @@a1@@ ) ; @@result@@ = Number L ; } else { @@result@@ = Number L ; } } } else { @@result@@ = Number L ; } } return @@result@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_207028 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
_QWORD * __fastcall bitset_clear ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { _QWORD * @@result@@ ; @@result@@ = ( _QWORD * ) ( Number * ( @@a2@@ >> Number ) + @@a1@@ ) ; * @@result@@ &= ~ ( Number L << ( @@a2@@ & Number ) ) ; return @@result@@ ; }
wint_t towlower ( wint_t @@wc@@ ) { return towlower ( @@wc@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
_QWORD * __fastcall bitset_merge ( __int64 @@a1@@ , __int64 @@a2@@ ) { _QWORD * @@result@@ ; int @@i@@ ; for ( @@i@@ = Number ; @@i@@ <= Number ; ++ @@i@@ ) { @@result@@ = ( _QWORD * ) ( Number L * @@i@@ + @@a1@@ ) ; * @@result@@ |= * ( _QWORD * ) ( Number L * @@i@@ + @@a2@@ ) ; } return @@result@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
_QWORD * __fastcall bitset_mask ( __int64 @@a1@@ , __int64 @@a2@@ ) { _QWORD * @@result@@ ; int @@i@@ ; for ( @@i@@ = Number ; @@i@@ <= Number ; ++ @@i@@ ) { @@result@@ = ( _QWORD * ) ( Number L * @@i@@ + @@a1@@ ) ; * @@result@@ &= * ( _QWORD * ) ( Number L * @@i@@ + @@a2@@ ) ; } return @@result@@ ; }
__int64 __fastcall re_string_wchar_at ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; if ( * ( _DWORD * ) ( @@a1@@ + Number ) == Number ) @@result@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ ) ; else @@result@@ = * ( unsigned int * ) ( Number * @@a2@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) ; return @@result@@ ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int64 __fastcall offtostr ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = @@a1@@ ; @@v4@@ = @@a2@@ + Number ; * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; if ( @@a1@@ >= Number ) { do { * ( _BYTE * ) -- @@v4@@ = ( char ) @@v3@@ % Number + Number ; @@v3@@ /= Number L ; } while ( @@v3@@ ) ; } else { do { * ( _BYTE * ) -- @@v4@@ = Number - ( char ) @@v3@@ % Number ; @@v3@@ /= Number L ; } while ( @@v3@@ ) ; * ( _BYTE * ) -- @@v4@@ = Number ; } return @@v4@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
__int64 __fastcall re_string_realloc_buffers ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { void * @@v3@@ ; void * @@v4@@ ; void * @@v5@@ ; if ( * ( int * ) ( @@a1@@ + Number ) > Number ) { if ( ! is_mul_ok ( Number , @@a2@@ ) ) return Number L ; @@v3@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number * @@a2@@ ) ; if ( ! @@v3@@ ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v3@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) { @@v4@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number * @@a2@@ ) ; if ( ! @@v4@@ ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v4@@ ; } } if ( * ( _BYTE * ) ( @@a1@@ + Number ) ) { @@v5@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , @@a2@@ ) ; if ( ! @@v5@@ ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v5@@ ; } * ( _QWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; return Number L ; }
__int64 __fastcall re_string_construct ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ , unsigned __int8 @@a5@@ , __int64 @@a6@@ ) { __int64 @@v7@@ ; unsigned int @@v12@@ ; unsigned int @@v13@@ ; unsigned int @@v14@@ ; memset ( ( void * ) @@a1@@ , Number , Number ) ; re_string_construct_common ( @@a2@@ , @@a3@@ , @@a1@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( @@a3@@ ) { @@v12@@ = re_string_realloc_buffers ( @@a1@@ , @@a3@@ + Number ) ; if ( @@v12@@ ) return @@v12@@ ; } if ( * ( _BYTE * ) ( @@a1@@ + Number ) ) @@v7@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; else @@v7@@ = @@a2@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v7@@ ; if ( ! @@a5@@ ) { if ( * ( int * ) ( @@a6@@ + Number ) <= Number ) { if ( @@a4@@ ) { re_string_translate_buffer ( @@a1@@ ) ; } else { * ( _QWORD * ) ( @@a1@@ + Number ) = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = * ( _QWORD * ) ( @@a1@@ + Number ) ; } } else { build_wcs_buffer ( @@a1@@ ) ; } return Number L ; } if ( * ( int * ) ( @@a6@@ + Number ) <= Number ) { build_upper_buffer ( @@a1@@ ) ; return Number L ; } do { @@v13@@ = build_wcs_upper_buffer ( @@a1@@ ) ; if ( @@v13@@ ) return @@v13@@ ; if ( @@a3@@ <= * ( _QWORD * ) ( @@a1@@ + Number ) || * ( _QWORD * ) ( @@a1@@ + Number ) > ( unsigned __int64 ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + * ( int * ) ( @@a6@@ + Number ) ) ) { return Number L ; } @@v14@@ = re_string_realloc_buffers ( @@a1@@ , Number L * * ( _QWORD * ) ( @@a1@@ + Number ) ) ; } while ( ! @@v14@@ ) ; return @@v14@@ ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 __fastcall int_value ( __int64 @@a1@@ ) { __int64 @@v2@@ ; @@v2@@ = xmalloc ( Number L ) ; * ( _DWORD * ) @@v2@@ = Number ; mpz_init_set_ui ( ( _QWORD * ) ( @@v2@@ + Number ) , @@a1@@ ) ; return @@v2@@ ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
_QWORD * __fastcall build_upper_buffer ( _QWORD * @@a1@@ ) { unsigned __int64 @@v1@@ ; _QWORD * @@result@@ ; int @@c@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@v5@@ ; @@v1@@ = @@a1@@ [ Number ] ; if ( @@a1@@ [ Number ] <= @@v1@@ ) @@v1@@ = @@a1@@ [ Number ] ; @@v5@@ = @@v1@@ ; for ( @@i@@ = @@a1@@ [ Number ] ; @@i@@ < @@v5@@ ; ++ @@i@@ ) { @@c@@ = * ( unsigned __int8 * ) ( * @@a1@@ + @@a1@@ [ Number ] + @@i@@ ) ; if ( @@a1@@ [ Number ] ) @@c@@ = * ( unsigned __int8 * ) ( @@a1@@ [ Number ] + * ( unsigned __int8 * ) ( * @@a1@@ + @@a1@@ [ Number ] + @@i@@ ) ) ; if ( ( ( * __ctype_b_loc ( ) ) [ @@c@@ ] & Number ) != Number ) * ( _BYTE * ) ( @@a1@@ [ Number ] + @@i@@ ) = toupper ( @@c@@ ) ; else * ( _BYTE * ) ( @@a1@@ [ Number ] + @@i@@ ) = @@c@@ ; } @@a1@@ [ Number ] = @@i@@ ; @@result@@ = @@a1@@ ; @@a1@@ [ Number ] = @@i@@ ; return @@result@@ ; }
bool __fastcall null ( __int64 @@a1@@ ) { _BYTE * @@v2@@ ; _BYTE * @@v3@@ ; if ( ! * ( _DWORD * ) @@a1@@ ) return ( unsigned int ) mpz_sgn ( ( __int64 * ) ( @@a1@@ + Number ) ) == Number ; if ( * ( _DWORD * ) @@a1@@ != Number ) abort ( ) ; @@v2@@ = * ( _BYTE * * ) ( @@a1@@ + Number ) ; if ( ! * @@v2@@ ) return Number ; @@v3@@ = & @@v2@@ [ * @@v2@@ == Number ] ; do { if ( * @@v3@@ != Number ) return Number ; ++ @@v3@@ ; } while ( * @@v3@@ ) ; return Number ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_209038 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall re_string_context_at ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , char @@a3@@ ) { __int64 @@result@@ ; int @@v4@@ ; wint_t @@wc@@ ; unsigned __int64 @@v6@@ ; if ( @@a2@@ > Number ) return * ( unsigned int * ) ( @@a1@@ + Number ) ; if ( @@a2@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ) { if ( ( @@a3@@ & Number ) != Number ) @@result@@ = Number L ; else @@result@@ = Number L ; } else if ( * ( int * ) ( @@a1@@ + Number ) <= Number ) { @@v4@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ ) ; if ( bitset_contain ( * ( _QWORD * ) ( @@a1@@ + Number ) , * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ ) ) ) { @@result@@ = Number L ; } else if ( @@v4@@ == Number && * ( _BYTE * ) ( @@a1@@ + Number ) ) { @@result@@ = Number L ; } else { @@result@@ = Number L ; } } else { @@v6@@ = @@a2@@ ; while ( * ( _DWORD * ) ( Number * @@v6@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) == Number ) { if ( -- @@v6@@ > Number ) return * ( unsigned int * ) ( @@a1@@ + Number ) ; } @@wc@@ = * ( _DWORD * ) ( Number * @@v6@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) ; if ( * ( _BYTE * ) ( @@a1@@ + Number ) && ( iswalnum ( @@wc@@ ) || @@wc@@ == Number ) ) { @@result@@ = Number L ; } else if ( @@wc@@ == Number && * ( _BYTE * ) ( @@a1@@ + Number ) ) { @@result@@ = Number L ; } else { @@result@@ = Number L ; } } return @@result@@ ; }
__int64 __fastcall re_node_set_init_2 ( _QWORD * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { * @@a1@@ = Number L ; @@a1@@ [ Number ] = malloc ( Number ) ; if ( ! @@a1@@ [ Number ] ) return Number L ; if ( @@a2@@ == @@a3@@ ) { @@a1@@ [ Number ] = Number L ; * ( _QWORD * ) @@a1@@ [ Number ] = @@a2@@ ; } else { @@a1@@ [ Number ] = Number L ; if ( @@a2@@ >= @@a3@@ ) { * ( _QWORD * ) @@a1@@ [ Number ] = @@a3@@ ; * ( _QWORD * ) ( @@a1@@ [ Number ] + Number L ) = @@a2@@ ; } else { * ( _QWORD * ) @@a1@@ [ Number ] = @@a2@@ ; * ( _QWORD * ) ( @@a1@@ [ Number ] + Number L ) = @@a3@@ ; } } return Number L ; }
__int64 __fastcall getsize ( __int64 * @@a1@@ ) { __int64 @@v2@@ ; if ( ( int ) mpz_sgn ( @@a1@@ ) < Number ) return Number ; if ( ! mpz_fits_ulong_p ( @@a1@@ ) ) return Number ; @@v2@@ = mpz_get_ui ( ( __int64 ) @@a1@@ ) ; if ( @@v2@@ == Number ) return Number ; return @@v2@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall re_node_set_insert_last ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v3@@ ; __int64 @@v4@@ ; void * @@v6@@ ; if ( * ( _QWORD * ) @@a1@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ) { * ( _QWORD * ) @@a1@@ = Number * ( * ( _QWORD * ) @@a1@@ + Number L ) ; @@v6@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number L * * ( _QWORD * ) @@a1@@ ) ; if ( ! @@v6@@ ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v6@@ ; } @@v3@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v4@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v4@@ + Number ; * ( _QWORD * ) ( @@v3@@ + Number * @@v4@@ ) = @@a2@@ ; return Number L ; }
_BOOL8 __fastcall nextarg ( const char * @@a1@@ ) { bool @@v2@@ ; if ( ! * ( _QWORD * ) args ) return Number L ; @@v2@@ = strcmp ( * ( const char * * ) args , @@a1@@ ) == Number ; args += Number L * @@v2@@ ; return @@v2@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_2090E8 ; @@v8@@ [ Number ] = qword_2090F0 ; @@v8@@ [ Number ] = qword_2090F8 ; @@v8@@ [ Number ] = qword_209100 ; @@v8@@ [ Number ] = qword_209108 ; @@v8@@ [ Number ] = qword_209110 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 __fastcall calc_state_hash ( __int64 @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v3@@ ; unsigned __int64 @@i@@ ; @@v3@@ = * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ ; for ( @@i@@ = Number L ; @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; ++ @@i@@ ) @@v3@@ += * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) ; return @@v3@@ ; }
void * * __fastcall eval5 ( unsigned __int8 @@a1@@ ) { void * * @@v2@@ ; void * * @@v3@@ ; __int64 @@v4@@ ; @@v2@@ = ( void * * ) eval6 ( @@a1@@ ) ; while ( nextarg ( ( const char * ) asc_1D394 ) ) { @@v3@@ = ( void * * ) eval6 ( @@a1@@ ) ; if ( @@a1@@ ) { @@v4@@ = docolon ( ( __int64 ) @@v2@@ , ( __int64 ) @@v3@@ ) ; freev ( @@v2@@ ) ; @@v2@@ = ( void * * ) @@v4@@ ; } freev ( @@v3@@ ) ; } return @@v2@@ ; }
bool __fastcall re_node_set_insert ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { __int64 @@i@@ ; void * @@v4@@ ; if ( ! * ( _QWORD * ) @@a1@@ ) return ( unsigned int ) re_node_set_init_1 ( ( _QWORD * ) @@a1@@ , @@a2@@ ) == Number ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) { * * ( _QWORD * * ) ( @@a1@@ + Number ) = @@a2@@ ; ++ * ( _QWORD * ) ( @@a1@@ + Number ) ; return Number ; } if ( * ( _QWORD * ) @@a1@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ) { * ( _QWORD * ) @@a1@@ *= Number L ; @@v4@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number L * * ( _QWORD * ) @@a1@@ ) ; if ( ! @@v4@@ ) return Number ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v4@@ ; } if ( @@a2@@ >= * * ( _QWORD * * ) ( @@a1@@ + Number ) ) { for ( @@i@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@a2@@ < * ( _QWORD * ) ( Number * @@i@@ - Number + * ( _QWORD * ) ( @@a1@@ + Number ) ) ; -- @@i@@ ) { * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@i@@ ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@i@@ - Number ) ; } } else { for ( @@i@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ ; -- @@i@@ ) * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@i@@ ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@i@@ - Number ) ; } * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@i@@ ) = @@a2@@ ; ++ * ( _QWORD * ) ( @@a1@@ + Number ) ; return Number ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_2070C8 ; @@v8@@ [ Number ] = qword_2070D0 ; @@v8@@ [ Number ] = qword_2070D8 ; @@v8@@ [ Number ] = qword_2070E0 ; @@v8@@ [ Number ] = qword_2070E8 ; @@v8@@ [ Number ] = qword_2070F0 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
void * * __fastcall eval1 ( unsigned __int8 @@a1@@ ) { bool @@v1@@ ; void * * @@v3@@ ; void * * @@v4@@ ; @@v3@@ = ( void * * ) eval2 ( @@a1@@ ) ; while ( nextarg ( String ) ) { @@v1@@ = @@a1@@ && ! null ( ( __int64 ) @@v3@@ ) ; @@v4@@ = ( void * * ) eval2 ( @@v1@@ ) ; if ( null ( ( __int64 ) @@v3@@ ) || null ( ( __int64 ) @@v4@@ ) ) { freev ( @@v3@@ ) ; freev ( @@v4@@ ) ; @@v3@@ = ( void * * ) int_value ( Number L ) ; } else { freev ( @@v4@@ ) ; } } return @@v3@@ ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
char * __fastcall rpl_re_compile_pattern ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { char * @@result@@ ; int @@v4@@ ; * ( _BYTE * ) ( @@a3@@ + Number ) = ( Number * ( ( rpl_re_syntax_options & Number ) != Number ) ) | * ( _BYTE * ) ( @@a3@@ + Number ) & Number ; * ( _BYTE * ) ( @@a3@@ + Number ) |= Number ; @@v4@@ = re_compile_internal ( @@a3@@ , @@a1@@ , @@a2@@ , rpl_re_syntax_options ) ; if ( @@v4@@ ) @@result@@ = gettext ( & _re_error_msgid [ _re_error_msgid_idx [ @@v4@@ ] ] ) ; else @@result@@ = Number L ; return @@result@@ ; }
__int64 __fastcall register_state ( _QWORD * @@a1@@ , _QWORD * @@a2@@ , __int64 @@a3@@ ) { __int64 @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; unsigned __int64 @@i@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; void * @@v12@@ ; __int64 @@v13@@ ; * @@a2@@ = @@a3@@ ; if ( ( unsigned int ) re_node_set_alloc ( @@a2@@ + Number , @@a2@@ [ Number ] ) ) return Number L ; for ( @@i@@ = Number L ; @@i@@ < @@a2@@ [ Number ] ; ++ @@i@@ ) { @@v13@@ = * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ [ Number ] ) ; if ( ( * ( _BYTE * ) ( Number * @@v13@@ + * @@a1@@ + Number ) & Number ) == Number && ( unsigned __int8 ) re_node_set_insert_last ( ( __int64 ) ( @@a2@@ + Number ) , @@v13@@ ) != Number ) { return Number L ; } } @@v10@@ = @@a1@@ [ Number ] + Number * ( @@a3@@ & @@a1@@ [ Number ] ) ; if ( * ( _QWORD * ) ( @@v10@@ + Number ) <= * ( _QWORD * ) @@v10@@ ) { @@v4@@ = * ( _QWORD * ) @@v10@@ + Number L ; @@v11@@ = Number * @@v4@@ ; @@v12@@ = realloc ( * ( void * * ) ( @@v10@@ + Number ) , Number * @@v4@@ ) ; if ( ! @@v12@@ ) return Number L ; * ( _QWORD * ) ( @@v10@@ + Number ) = @@v12@@ ; * ( _QWORD * ) ( @@v10@@ + Number ) = @@v11@@ ; } @@v5@@ = * ( _QWORD * ) ( @@v10@@ + Number ) ; @@v6@@ = ( * ( _QWORD * ) @@v10@@ ) ++ ; * ( _QWORD * ) ( @@v5@@ + Number * @@v6@@ ) = @@a2@@ ; return Number L ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
void * * __fastcall eval ( unsigned __int8 @@a1@@ ) { bool @@v1@@ ; void * * @@v3@@ ; void * * @@v4@@ ; @@v3@@ = eval1 ( @@a1@@ ) ; while ( nextarg ( String ) ) { @@v1@@ = @@a1@@ && null ( ( __int64 ) @@v3@@ ) ; @@v4@@ = eval1 ( @@v1@@ ) ; if ( null ( ( __int64 ) @@v3@@ ) ) { freev ( @@v3@@ ) ; @@v3@@ = @@v4@@ ; if ( null ( ( __int64 ) @@v4@@ ) ) { freev ( @@v4@@ ) ; @@v3@@ = ( void * * ) int_value ( Number L ) ; } } else { freev ( @@v4@@ ) ; } } return @@v3@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
__int64 __fastcall rpl_re_compile_fastmap ( __int64 @@a1@@ ) { _QWORD * @@v2@@ ; void * @@s@@ ; @@v2@@ = * ( _QWORD * * ) @@a1@@ ; @@s@@ = * ( void * * ) ( @@a1@@ + Number ) ; memset ( @@s@@ , Number , Number ) ; re_compile_fastmap_iter ( @@a1@@ , @@v2@@ [ Number ] , @@s@@ ) ; if ( @@v2@@ [ Number ] != @@v2@@ [ Number ] ) re_compile_fastmap_iter ( @@a1@@ , @@v2@@ [ Number ] , @@s@@ ) ; if ( @@v2@@ [ Number ] != @@v2@@ [ Number ] ) re_compile_fastmap_iter ( @@a1@@ , @@v2@@ [ Number ] , @@s@@ ) ; if ( @@v2@@ [ Number ] != @@v2@@ [ Number ] ) re_compile_fastmap_iter ( @@a1@@ , @@v2@@ [ Number ] , @@s@@ ) ; * ( _BYTE * ) ( @@a1@@ + Number ) |= Number ; return Number L ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 __fastcall imaxtostr ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = @@a1@@ ; @@v4@@ = @@a2@@ + Number ; * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; if ( @@a1@@ >= Number ) { do { * ( _BYTE * ) -- @@v4@@ = ( char ) @@v3@@ % Number + Number ; @@v3@@ /= Number L ; } while ( @@v3@@ ) ; } else { do { * ( _BYTE * ) -- @@v4@@ = Number - ( char ) @@v3@@ % Number ; @@v3@@ /= Number L ; } while ( @@v3@@ ) ; * ( _BYTE * ) -- @@v4@@ = Number ; } return @@v4@@ ; }
void __fastcall free_dfa_content ( __int64 @@a1@@ ) { unsigned __int64 @@i@@ ; unsigned __int64 @@j@@ ; unsigned __int64 @@k@@ ; unsigned __int64 @@l@@ ; __int64 @@v5@@ ; if ( * ( _QWORD * ) @@a1@@ ) { for ( @@i@@ = Number L ; @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; ++ @@i@@ ) free_token ( Number * @@i@@ + * ( _QWORD * ) @@a1@@ ) ; } free ( * ( void * * ) ( @@a1@@ + Number ) ) ; for ( @@j@@ = Number L ; @@j@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; ++ @@j@@ ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) free ( * ( void * * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@j@@ + Number ) ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) free ( * ( void * * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@j@@ + Number ) ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) free ( * ( void * * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@j@@ + Number ) ) ; } free ( * ( void * * ) ( @@a1@@ + Number ) ) ; free ( * ( void * * ) ( @@a1@@ + Number ) ) ; free ( * ( void * * ) ( @@a1@@ + Number ) ) ; free ( * ( void * * ) @@a1@@ ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) { for ( @@k@@ = Number L ; @@k@@ <= * ( _QWORD * ) ( @@a1@@ + Number ) ; ++ @@k@@ ) { @@v5@@ = * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@k@@ ; for ( @@l@@ = Number L ; @@l@@ < * ( _QWORD * ) @@v5@@ ; ++ @@l@@ ) free_state ( * ( void * * * ) ( Number * @@l@@ + * ( _QWORD * ) ( @@v5@@ + Number ) ) ) ; free ( * ( void * * ) ( @@v5@@ + Number ) ) ; } } free ( * ( void * * ) ( @@a1@@ + Number ) ) ; if ( * ( _UNKNOWN * * ) ( @@a1@@ + Number ) != & utf8_sb_map ) free ( * ( void * * ) ( @@a1@@ + Number ) ) ; free ( * ( void * * ) ( @@a1@@ + Number ) ) ; free ( ( void * ) @@a1@@ ) ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 __fastcall free_workarea_compile ( __int64 * @@a1@@ ) { __int64 @@result@@ ; _QWORD * @@ptr@@ ; __int64 @@v3@@ ; _QWORD * @@v4@@ ; @@v3@@ = * @@a1@@ ; for ( @@ptr@@ = * ( _QWORD * * ) ( * @@a1@@ + Number ) ; @@ptr@@ ; @@ptr@@ = @@v4@@ ) { @@v4@@ = ( _QWORD * ) * @@ptr@@ ; free ( @@ptr@@ ) ; } * ( _QWORD * ) ( @@v3@@ + Number ) = Number L ; * ( _DWORD * ) ( @@v3@@ + Number ) = Number ; * ( _QWORD * ) ( @@v3@@ + Number ) = Number L ; free ( * ( void * * ) ( @@v3@@ + Number ) ) ; @@result@@ = @@v3@@ ; * ( _QWORD * ) ( @@v3@@ + Number ) = Number L ; return @@result@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall search_duplicated_node ( _QWORD * @@a1@@ , __int64 @@a2@@ , int @@a3@@ ) { __int64 @@i@@ ; for ( @@i@@ = @@a1@@ [ Number ] - Number L ; ( * ( _BYTE * ) ( Number * @@i@@ + * @@a1@@ + Number ) & Number ) != Number && @@i@@ ; -- @@i@@ ) { if ( @@a2@@ == * ( _QWORD * ) ( Number * @@i@@ + @@a1@@ [ Number ] ) && @@a3@@ == ( ( * ( _DWORD * ) ( Number * @@i@@ + * @@a1@@ + Number ) >> Number ) & Number ) ) { return @@i@@ ; } } return Number ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
int toupper ( int @@c@@ ) { return toupper ( @@c@@ ) ; }
__int64 __fastcall calc_inveclosure ( _QWORD * @@a1@@ ) { unsigned __int64 @@j@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@k@@ ; __int64 @@v5@@ ; for ( @@i@@ = Number L ; @@i@@ < @@a1@@ [ Number ] ; ++ @@i@@ ) memset ( ( void * ) ( @@a1@@ [ Number ] + Number * @@i@@ ) , Number , Number ) ; for ( @@j@@ = Number L ; @@j@@ < @@a1@@ [ Number ] ; ++ @@j@@ ) { @@v5@@ = * ( _QWORD * ) ( @@a1@@ [ Number ] + Number * @@j@@ + Number ) ; for ( @@k@@ = Number L ; @@k@@ < * ( _QWORD * ) ( @@a1@@ [ Number ] + Number * @@j@@ + Number ) ; ++ @@k@@ ) { if ( ( unsigned __int8 ) re_node_set_insert_last ( @@a1@@ [ Number ] + Number L * * ( _QWORD * ) ( Number * @@k@@ + @@v5@@ ) , @@j@@ ) != Number ) return Number L ; } } return Number L ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__int64 __fastcall parse ( __int64 @@a1@@ , __int64 * @@a2@@ , __int64 @@a3@@ , _DWORD * @@a4@@ ) { __int64 @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; char @@v11@@ [ Number ] ; unsigned __int64 @@v12@@ ; @@v12@@ = __readfsqword ( Number ) ; @@v8@@ = * @@a2@@ ; * ( _QWORD * ) ( * @@a2@@ + Number ) = @@a3@@ ; fetch_token ( ( __int64 ) @@v11@@ , @@a1@@ , @@a3@@ | Number ) ; @@v9@@ = parse_reg_exp ( @@a1@@ , @@a2@@ , @@v11@@ , @@a3@@ , Number L , @@a4@@ ) ; if ( * @@a4@@ && ! @@v9@@ ) return Number L ; @@v10@@ = create_tree ( @@v8@@ , Number L , Number L , Number L ) ; if ( @@v9@@ ) @@v7@@ = create_tree ( @@v8@@ , @@v9@@ , @@v10@@ , Number L ) ; else @@v7@@ = @@v10@@ ; if ( @@v10@@ && @@v7@@ ) return @@v7@@ ; * @@a4@@ = Number ; return Number L ; }
__int64 __fastcall optimize_subexps ( __int64 @@a1@@ , __int64 @@a2@@ ) { unsigned __int64 @@v3@@ ; if ( * ( _BYTE * ) ( @@a2@@ + Number ) == Number && * ( _QWORD * ) ( @@a1@@ + Number ) ) { * ( _QWORD * ) ( @@a2@@ + Number ) = * ( _QWORD * ) ( Number L * ( int ) * ( _QWORD * ) ( @@a2@@ + Number ) + * ( _QWORD * ) ( @@a1@@ + Number ) ) ; * ( _QWORD * ) ( @@a1@@ + Number ) |= Number << * ( _QWORD * ) ( @@a2@@ + Number ) ; } else if ( * ( _BYTE * ) ( @@a2@@ + Number ) == Number && * ( _QWORD * ) ( @@a2@@ + Number ) && * ( _BYTE * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) == Number ) { @@v3@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) ; * ( _QWORD * ) ( @@a2@@ + Number ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) ) * * ( _QWORD * * ) ( @@a2@@ + Number ) = @@a2@@ ; * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@v3@@ ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L * * ( _QWORD * ) ( @@a2@@ + Number ) ) ; if ( @@v3@@ <= Number ) * ( _QWORD * ) ( @@a1@@ + Number ) &= ~ ( Number L << @@v3@@ ) ; } return Number L ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
_QWORD * __fastcall bitset_set ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { _QWORD * @@result@@ ; @@result@@ = ( _QWORD * ) ( Number * ( @@a2@@ >> Number ) + @@a1@@ ) ; * @@result@@ |= Number L << ( @@a2@@ & Number ) ; return @@result@@ ; }
__int64 __fastcall build_collating_symbol ( __int64 @@a1@@ , __int64 a2 , __int64 a3 , const char * @@a4@@ ) { if ( strlen ( @@a4@@ ) != Number ) return Number L ; bitset_set ( @@a1@@ , * ( unsigned __int8 * ) @@a4@@ ) ; return Number L ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
int putchar_unlocked ( int @@c@@ ) { return putchar_unlocked ( @@c@@ ) ; }
bool __fastcall bitset_contain ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return ( ( * ( _QWORD * ) ( Number * ( @@a2@@ >> Number ) + @@a1@@ ) >> ( @@a2@@ & Number ) ) & Number L ) != Number ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
wint_t towupper ( wint_t @@wc@@ ) { return towupper ( @@wc@@ ) ; }
_QWORD * __fastcall bitset_merge ( __int64 @@a1@@ , __int64 @@a2@@ ) { _QWORD * @@result@@ ; int @@i@@ ; for ( @@i@@ = Number ; @@i@@ <= Number ; ++ @@i@@ ) { @@result@@ = ( _QWORD * ) ( Number L * @@i@@ + @@a1@@ ) ; * @@result@@ |= * ( _QWORD * ) ( Number L * @@i@@ + @@a2@@ ) ; } return @@result@@ ; }
__int64 __fastcall link_nfa_nodes ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; unsigned int @@v3@@ ; unsigned __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; __int64 @@v6@@ ; @@v6@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@v3@@ = Number ; switch ( * ( _BYTE * ) ( @@a2@@ + Number ) ) { case Number : if ( * ( _QWORD * ) ( @@a2@@ + Number ) ) __assert_fail ( String , String , Number , String ) ; return @@result@@ ; case Number : * ( _QWORD * ) ( Number * @@v6@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) ; if ( * ( _BYTE * ) ( @@a2@@ + Number ) == Number ) re_node_set_init_1 ( ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@v6@@ ) , * ( _QWORD * ) ( Number * @@v6@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) ) ; break ; case Number : case Number : case Number : @@v3@@ = re_node_set_init_1 ( ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@v6@@ ) , * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) ) ; break ; case Number : case Number : * ( _BYTE * ) ( @@a1@@ + Number ) |= Number ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) ) @@v4@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) + Number L ) ; else @@v4@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) ) @@v5@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) + Number L ) ; else @@v5@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) ; if ( @@v4@@ > Number ) __assert_fail ( String , String , Number , String ) ; if ( @@v5@@ > Number ) __assert_fail ( String , String , Number , String ) ; @@v3@@ = re_node_set_init_2 ( ( _QWORD * ) ( Number * @@v6@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) , @@v4@@ , @@v5@@ ) ; break ; case Number : return @@v3@@ ; default : if ( ( * ( _BYTE * ) ( @@a2@@ + Number ) & Number ) != Number ) __assert_fail ( String , String , Number , String ) ; * ( _QWORD * ) ( Number * @@v6@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) ; break ; } return @@v3@@ ; }
__int64 __fastcall parse_bracket_element ( __int64 @@a1@@ , __int64 @@a2@@ , _BYTE * @@a3@@ , int @@a4@@ , __int64 a5 , char @@a6@@ , char @@a7@@ ) { __int64 @@result@@ ; int @@v11@@ ; char @@v12@@ [ Number ] ; unsigned __int64 @@v13@@ ; @@v13@@ = __readfsqword ( Number ) ; @@v11@@ = re_string_char_size_at ( @@a2@@ , * ( _QWORD * ) ( @@a2@@ + Number ) ) ; if ( @@v11@@ <= Number ) { * ( _QWORD * ) ( @@a2@@ + Number ) += @@a4@@ ; if ( @@a3@@ [ Number ] == Number || @@a3@@ [ Number ] == Number || @@a3@@ [ Number ] == Number ) { @@result@@ = parse_bracket_symbol ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } else if ( @@a3@@ [ Number ] == Number && @@a7@@ != Number && ( peek_token_bracket ( @@v12@@ , @@a2@@ , @@a6@@ ) , @@v12@@ [ Number ] != Number ) ) { @@result@@ = Number L ; } else { * ( _DWORD * ) @@a1@@ = Number ; * ( _BYTE * ) ( @@a1@@ + Number ) = * @@a3@@ ; @@result@@ = Number L ; } } else { * ( _DWORD * ) @@a1@@ = Number ; * ( _DWORD * ) ( @@a1@@ + Number ) = re_string_wchar_at ( @@a2@@ , * ( _QWORD * ) ( @@a2@@ + Number ) ) ; * ( _QWORD * ) ( @@a2@@ + Number ) += @@v11@@ ; @@result@@ = Number L ; } return @@result@@ ; }
_QWORD * __fastcall mpz_add ( _QWORD * @@a1@@ , _QWORD * @@a2@@ , __int64 * @@a3@@ ) { _QWORD * @@result@@ ; if ( * @@a2@@ + * @@a3@@ < * @@a2@@ != * @@a3@@ < Number ) integer_overflow ( Number L ) ; @@result@@ = @@a1@@ ; * @@a1@@ = * @@a2@@ + * @@a3@@ ; return @@result@@ ; }
__int64 __fastcall re_string_allocate ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , unsigned __int64 @@a4@@ , __int64 @@a5@@ , unsigned __int8 @@a6@@ , __int64 @@a7@@ ) { unsigned __int64 @@v7@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; unsigned int @@v13@@ ; unsigned __int64 @@v14@@ ; @@v11@@ = @@a4@@ ; if ( @@a4@@ < * ( int * ) ( @@a7@@ + Number ) ) @@v11@@ = * ( int * ) ( @@a7@@ + Number ) ; @@v7@@ = @@a3@@ + Number ; if ( @@v11@@ <= @@a3@@ + Number ) @@v7@@ = @@v11@@ ; @@v14@@ = @@v7@@ ; re_string_construct_common ( @@a2@@ , @@a3@@ , @@a1@@ , @@a5@@ , @@a6@@ , @@a7@@ ) ; @@v13@@ = re_string_realloc_buffers ( @@a1@@ , @@v14@@ ) ; if ( @@v13@@ ) return @@v13@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@a7@@ + Number ; * ( _BYTE * ) ( @@a1@@ + Number ) = ( * ( _BYTE * ) ( @@a7@@ + Number ) & Number ) != Number ; if ( * ( _BYTE * ) ( @@a1@@ + Number ) ) @@v9@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; else @@v9@@ = @@a2@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v9@@ ; if ( * ( _BYTE * ) ( @@a1@@ + Number ) || * ( int * ) ( @@a7@@ + Number ) > Number ) @@v10@@ = Number L ; else @@v10@@ = @@a3@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v10@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = * ( _QWORD * ) ( @@a1@@ + Number ) ; return Number L ; }
__int64 __fastcall mode_adjust ( __int16 @@a1@@ , unsigned __int8 @@a2@@ , int @@a3@@ , char * @@a4@@ , _DWORD * @@a5@@ ) { int @@v5@@ ; int @@v6@@ ; int @@v7@@ ; int @@v8@@ ; int @@v9@@ ; int @@v10@@ ; int @@v11@@ ; int @@v12@@ ; int @@v13@@ ; unsigned int @@v17@@ ; int @@v18@@ ; int @@v19@@ ; int @@v20@@ ; int @@v21@@ ; int @@v22@@ ; int @@v23@@ ; @@v17@@ = @@a1@@ & Number ; @@v18@@ = Number ; while ( @@a4@@ [ Number ] ) { @@v22@@ = * ( ( _DWORD * ) @@a4@@ + Number ) ; if ( @@a2@@ ) @@v5@@ = Number ; else @@v5@@ = Number ; @@v23@@ = @@v5@@ & ~ * ( ( _DWORD * ) @@a4@@ + Number ) ; @@v19@@ = * ( ( _DWORD * ) @@a4@@ + Number ) ; @@v6@@ = @@a4@@ [ Number ] ; if ( @@v6@@ == Number ) { if ( @@v17@@ & Number | @@a2@@ ) @@v19@@ |= Number ; } else if ( @@v6@@ == Number ) { @@v20@@ = @@v17@@ & @@v19@@ ; if ( ( @@v20@@ & Number ) != Number ) @@v7@@ = Number ; else @@v7@@ = Number ; if ( ( @@v20@@ & Number ) != Number ) @@v8@@ = Number ; else @@v8@@ = Number ; @@v9@@ = @@v8@@ | @@v7@@ ; if ( ( @@v20@@ & Number ) != Number ) @@v10@@ = Number ; else @@v10@@ = Number ; @@v19@@ = @@v9@@ | @@v10@@ | @@v20@@ ; } if ( @@v22@@ ) @@v11@@ = * ( ( _DWORD * ) @@a4@@ + Number ) ; else @@v11@@ = ~ @@a3@@ ; @@v21@@ = ~ @@v23@@ & @@v11@@ & @@v19@@ ; @@v12@@ = * @@a4@@ ; switch ( @@v12@@ ) { case String : @@v18@@ |= @@v21@@ ; @@v17@@ &= ~ @@v21@@ ; break ; case String : if ( @@v22@@ ) @@v13@@ = ~ @@v22@@ ; else @@v13@@ = Number ; @@v18@@ |= ~ ( ( unsigned __int16 ) @@v23@@ | ( unsigned __int16 ) @@v13@@ ) & Number ; @@v17@@ = @@v21@@ | ( @@v23@@ | @@v13@@ ) & @@v17@@ ; break ; case String : @@v18@@ |= @@v21@@ ; @@v17@@ |= @@v21@@ ; break ; } @@a4@@ += Number ; } if ( @@a5@@ ) * @@a5@@ = @@v18@@ ; return @@v17@@ ; }
__int64 __fastcall mark_opt_subexp ( __int64 @@a1@@ , __int64 @@a2@@ ) { if ( * ( _BYTE * ) ( @@a2@@ + Number ) == Number && @@a1@@ == * ( _QWORD * ) ( @@a2@@ + Number ) ) { * ( _BYTE * ) ( @@a2@@ + Number ) |= Number ; } return Number L ; }
__int64 * __fastcall mpz_tdiv_r ( __int64 * @@a1@@ , __int64 * @@a2@@ , __int64 * @@a3@@ ) { __int64 @@v3@@ ; __int64 * @@result@@ ; __int64 @@v5@@ ; @@v5@@ = * @@a3@@ ; if ( * @@a2@@ == Number && @@v5@@ == Number ) @@v3@@ = Number L ; else @@v3@@ = * @@a2@@ % @@v5@@ ; @@result@@ = @@a1@@ ; * @@a1@@ = @@v3@@ ; return @@result@@ ; }
__int64 __fastcall parse_sub_exp ( __int64 @@a1@@ , __int64 * @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , _DWORD * @@a6@@ ) { unsigned __int64 @@v6@@ ; __int64 @@result@@ ; __int64 @@v12@@ ; __int64 @@v13@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; @@v14@@ = * @@a2@@ ; @@v6@@ = @@a2@@ [ Number ] ; @@a2@@ [ Number ] = @@v6@@ + Number ; @@v15@@ = @@v6@@ ; fetch_token ( @@a3@@ , @@a1@@ , @@a4@@ | Number ) ; if ( * ( _BYTE * ) ( @@a3@@ + Number ) == Number ) { @@v12@@ = Number L ; } else { @@v12@@ = parse_reg_exp ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( ! * @@a6@@ && * ( _BYTE * ) ( @@a3@@ + Number ) != Number ) * @@a6@@ = Number ; if ( * @@a6@@ ) return Number L ; } if ( @@v15@@ <= Number ) * ( _QWORD * ) ( @@v14@@ + Number ) |= Number << @@v15@@ ; @@v13@@ = create_tree ( @@v14@@ , @@v12@@ , Number L , Number L ) ; if ( @@v13@@ ) { * ( _QWORD * ) ( @@v13@@ + Number ) = @@v15@@ ; @@result@@ = @@v13@@ ; } else { * @@a6@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall mpz_get_ui ( __int64 @@a1@@ ) { return * ( _QWORD * ) @@a1@@ ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
__int64 __fastcall re_string_fetch_byte_case ( __int64 @@a1@@ ) { __int64 @@v1@@ ; __int64 @@v2@@ ; __int64 @@result@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; unsigned int @@v13@@ ; if ( * ( _BYTE * ) ( @@a1@@ + Number ) ) { if ( * ( _BYTE * ) ( @@a1@@ + Number ) ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) == * ( _QWORD * ) ( @@a1@@ + Number ) || * ( _DWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L * * ( _QWORD * ) ( @@a1@@ + Number ) ) != Number ) { @@v13@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) @@a1@@ + * ( _QWORD * ) ( @@a1@@ + Number ) + * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L * * ( _QWORD * ) ( @@a1@@ + Number ) ) ) ; if ( ( @@v13@@ & Number ) != Number ) { @@v6@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v7@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v7@@ + Number ; @@result@@ = * ( unsigned __int8 * ) ( @@v6@@ + @@v7@@ ) ; } else { @@v8@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v8@@ + ( int ) re_string_char_size_at ( @@a1@@ , @@v8@@ ) ; @@result@@ = @@v13@@ ; } } else { @@v4@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v5@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v5@@ + Number ; @@result@@ = * ( unsigned __int8 * ) ( @@v4@@ + @@v5@@ ) ; } } else { @@v9@@ = * ( _QWORD * ) @@a1@@ ; @@v10@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v11@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v11@@ + Number ; @@result@@ = * ( unsigned __int8 * ) ( @@v9@@ + @@v10@@ + @@v11@@ ) ; } } else { @@v1@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v2@@ + Number ; @@result@@ = * ( unsigned __int8 * ) ( @@v1@@ + @@v2@@ ) ; } return @@result@@ ; }
__int64 __fastcall create_tree ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , char @@a4@@ ) { char @@v5@@ [ Number ] ; unsigned __int64 @@v6@@ ; @@v6@@ = __readfsqword ( Number ) ; @@v5@@ [ Number ] = @@a4@@ ; return create_token_tree ( @@a1@@ , @@a2@@ , @@a3@@ , @@v5@@ ) ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
void __fastcall free_token ( __int64 @@a1@@ ) { if ( * ( _BYTE * ) ( @@a1@@ + Number ) != Number || ( * ( _BYTE * ) ( @@a1@@ + Number ) & Number ) != Number ) { if ( * ( _BYTE * ) ( @@a1@@ + Number ) == Number && ( * ( _BYTE * ) ( @@a1@@ + Number ) & Number ) == Number ) free ( * ( void * * ) @@a1@@ ) ; } else { free_charset ( * ( void * * * ) @@a1@@ ) ; } }
int __cdecl __noreturn main ( int @@argc@@ , const char * * @@argv@@ , const char * * @@envp@@ ) { char * @@v3@@ ; unsigned __int8 @@v4@@ ; const char * * @@v5@@ ; int @@v6@@ ; __int64 @@v7@@ ; @@v6@@ = @@argc@@ ; @@v5@@ = @@argv@@ ; set_program_name ( * @@argv@@ , @@argv@@ , @@envp@@ ) ; setlocale ( Number , & off_1D2EC [ Number ] ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; initialize_exit_failure ( Number ) ; atexit ( close_stdout ) ; parse_long_options ( @@argc@@ , ( _DWORD ) @@argv@@ , ( unsigned int ) String , ( unsigned int ) String , ( unsigned int ) String , ( unsigned int ) usage , String , String , String , Number L ) ; if ( @@argc@@ > Number && ! strcmp ( @@argv@@ [ Number ] , String ) ) { @@v6@@ = @@argc@@ - Number ; @@v5@@ = @@argv@@ + Number ; } if ( @@v6@@ <= Number ) { @@v3@@ = gettext ( String ) ; error ( Number , Number , @@v3@@ ) ; usage ( Number ) ; } args = ( __int64 ) ( @@v5@@ + Number ) ; @@v7@@ = eval ( Number L ) ; if ( ( unsigned __int8 ) nomoreargs ( ) != Number ) syntax_error ( ) ; printv ( @@v7@@ ) ; @@v4@@ = null ( @@v7@@ ) ; exit ( @@v4@@ ) ; }
unsigned __int64 __fastcall re_node_set_remove_at ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { unsigned __int64 @@result@@ ; unsigned __int64 @@v3@@ ; @@v3@@ = @@a2@@ ; @@result@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( @@a2@@ < @@result@@ ) { -- * ( _QWORD * ) ( @@a1@@ + Number ) ; while ( Number ) { @@result@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( @@v3@@ >= @@result@@ ) break ; * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@v3@@ ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * ( @@v3@@ + Number ) ) ; ++ @@v3@@ ; } } return @@result@@ ; }
int __fastcall stat ( char * @@filename@@ , struct stat * @@stat_buf@@ ) { return __xstat ( Number , @@filename@@ , @@stat_buf@@ ) ; }
__int64 __fastcall rpl_regexec ( __int64 @@a1@@ , const char * @@a2@@ , __int64 @@a3@@ , __int64 * @@a4@@ , int @@a5@@ ) { int @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; if ( ( @@a5@@ & Number ) != Number ) return Number L ; if ( ( @@a5@@ & Number ) != Number ) { @@v10@@ = * @@a4@@ ; @@v11@@ = @@a4@@ [ Number ] ; } else { LODWORD ( @@v10@@ ) = Number ; LODWORD ( @@v11@@ ) = strlen ( @@a2@@ ) ; } if ( ( * ( _BYTE * ) ( @@a1@@ + Number ) & Number ) != Number ) @@v9@@ = re_search_internal ( @@a1@@ , ( _DWORD ) @@a2@@ , @@v11@@ , @@v10@@ , @@v11@@ , @@v11@@ , Number L , Number L , @@a5@@ ) ; else @@v9@@ = re_search_internal ( @@a1@@ , ( _DWORD ) @@a2@@ , @@v11@@ , @@v10@@ , @@v11@@ , @@v11@@ , @@a3@@ , ( __int64 ) @@a4@@ , @@a5@@ ) ; return @@v9@@ != Number ; }
int iswlower ( wint_t @@wc@@ ) { return iswlower ( @@wc@@ ) ; }
__int64 __fastcall eval7 ( unsigned __int8 @@a1@@ ) { __int64 @@result@@ ; __int64 * @@v2@@ ; __int64 @@v3@@ ; if ( nomoreargs ( ) ) syntax_error ( ) ; if ( nextarg ( ( const char * ) asc_1D374 ) ) { @@v3@@ = eval ( @@a1@@ ) ; if ( ! nextarg ( ( const char * ) & asc_1D374 [ Number ] ) ) syntax_error ( ) ; @@result@@ = @@v3@@ ; } else { if ( nextarg ( ( const char * ) & asc_1D374 [ Number ] ) ) syntax_error ( ) ; @@v2@@ = ( __int64 * ) args ; args += Number L ; @@result@@ = str_value ( * @@v2@@ ) ; } return @@result@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
__int64 __fastcall re_acquire_state_context ( _DWORD * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , unsigned int @@a4@@ ) { __int64 @@result@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ ; unsigned __int64 * @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; if ( * ( _QWORD * ) ( @@a3@@ + Number ) ) { @@v8@@ = calc_state_hash ( @@a3@@ , @@a4@@ ) ; @@v9@@ = ( unsigned __int64 * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number * ( @@v8@@ & * ( _QWORD * ) ( @@a2@@ + Number ) ) ) ; for ( @@i@@ = Number L ; @@i@@ < * @@v9@@ ; ++ @@i@@ ) { @@v11@@ = * ( _QWORD * ) ( Number * @@i@@ + @@v9@@ [ Number ] ) ; if ( @@v8@@ == * ( _QWORD * ) @@v11@@ && @@a4@@ == ( * ( _BYTE * ) ( @@v11@@ + Number ) & Number ) && ( unsigned __int8 ) re_node_set_compare ( * ( _QWORD * ) ( @@v11@@ + Number ) , @@a3@@ ) ) { return @@v11@@ ; } } @@v10@@ = create_cd_newstate ( @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ ) ; if ( ! @@v10@@ ) * @@a1@@ = Number ; @@result@@ = @@v10@@ ; } else { * @@a1@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall create_token_tree ( __int64 @@a1@@ , __int64 * @@a2@@ , __int64 * @@a3@@ , _QWORD * @@a4@@ ) { __int64 @@v5@@ ; int @@v6@@ ; __int64 @@v7@@ ; _QWORD * @@v11@@ ; __int64 @@v12@@ ; if ( * ( _DWORD * ) ( @@a1@@ + Number ) == Number ) { @@v11@@ = malloc ( Number ) ; if ( ! @@v11@@ ) return Number L ; * @@v11@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v11@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = Number ; } @@v5@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v6@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@v6@@ + Number ; @@v12@@ = @@v5@@ + ( ( __int64 ) @@v6@@ << Number ) + Number ; * ( _QWORD * ) @@v12@@ = Number L ; * ( _QWORD * ) ( @@v12@@ + Number ) = @@a2@@ ; * ( _QWORD * ) ( @@v12@@ + Number ) = @@a3@@ ; @@v7@@ = @@a4@@ [ Number ] ; * ( _QWORD * ) ( @@v12@@ + Number ) = * @@a4@@ ; * ( _QWORD * ) ( @@v5@@ + ( ( __int64 ) @@v6@@ << Number ) + Number ) = @@v7@@ ; * ( _BYTE * ) ( @@v12@@ + Number ) &= Number ; * ( _BYTE * ) ( @@v12@@ + Number ) &= Number ; * ( _QWORD * ) ( @@v12@@ + Number ) = Number L ; * ( _QWORD * ) ( @@v12@@ + Number ) = Number L ; * ( _QWORD * ) ( @@v12@@ + Number ) = Number ; if ( @@a2@@ ) * @@a2@@ = @@v12@@ ; if ( @@a3@@ ) * @@a3@@ = @@v12@@ ; return @@v5@@ + ( ( __int64 ) @@v6@@ << Number ) + Number ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
__int64 __fastcall eval2 ( unsigned __int8 @@a1@@ ) { char * @@v2@@ ; int * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; char * @@v7@@ ; bool @@v8@@ ; int @@v9@@ $8B6283BB588625B42BF25B000F30A210 ; int @@v10@@ ; __int64 @@i@@ ; void * * @@v12@@ ; for ( @@i@@ = ( __int64 ) eval3 ( @@a1@@ ) ; ; @@i@@ = int_value ( @@v8@@ ) ) { @@v8@@ = Number ; if ( nextarg ( String ) ) { @@v9@@ $8B6283BB588625B42BF25B000F30A210 = Number ; goto LABEL_16 ; } if ( nextarg ( String ) ) { @@v9@@ $8B6283BB588625B42BF25B000F30A210 = Number ; goto LABEL_16 ; } if ( nextarg ( String ) || nextarg ( String ) ) { @@v9@@ $8B6283BB588625B42BF25B000F30A210 = Number ; goto LABEL_16 ; } if ( nextarg ( String ) ) { @@v9@@ $8B6283BB588625B42BF25B000F30A210 = Number ; goto LABEL_16 ; } if ( nextarg ( String ) ) { @@v9@@ $8B6283BB588625B42BF25B000F30A210 = Number ; goto LABEL_16 ; } if ( ! nextarg ( String ) ) break ; @@v9@@ $8B6283BB588625B42BF25B000F30A210 = Number ; LABEL_16 : @@v12@@ = eval3 ( @@a1@@ ) ; if ( @@a1@@ ) { tostring ( ( unsigned int * ) @@i@@ ) ; tostring ( ( unsigned int * ) @@v12@@ ) ; if ( ( unsigned __int8 ) looks_like_integer ( * ( _BYTE * * ) ( @@i@@ + Number ) ) && ( unsigned __int8 ) looks_like_integer ( @@v12@@ [ Number ] ) ) { @@v10@@ = strintcmp ( * ( _QWORD * ) ( @@i@@ + Number ) , @@v12@@ [ Number ] ) ; } else { * __errno_location ( ) = Number ; @@v10@@ = strcoll ( * ( const char * * ) ( @@i@@ + Number ) , ( const char * ) @@v12@@ [ Number ] ) ; if ( * __errno_location ( ) ) { @@v2@@ = gettext ( String ) ; @@v3@@ = __errno_location ( ) ; error ( Number , * @@v3@@ , @@v2@@ ) ; @@v4@@ = gettext ( String ) ; error ( Number , Number , @@v4@@ ) ; @@v5@@ = quotearg_n_style ( Number L , Number L , @@v12@@ [ Number ] ) ; @@v6@@ = quotearg_n_style ( Number L , Number L , * ( _QWORD * ) ( @@i@@ + Number ) ) ; @@v7@@ = gettext ( String ) ; error ( Number , Number , @@v7@@ , @@v6@@ , @@v5@@ ) ; } } switch ( @@v9@@ $8B6283BB588625B42BF25B000F30A210 ) { case Number : @@v8@@ = @@v10@@ < Number ; break ; case Number : @@v8@@ = @@v10@@ <= Number ; break ; case Number : @@v8@@ = @@v10@@ == Number ; break ; case Number : @@v8@@ = @@v10@@ != Number ; break ; case Number : @@v8@@ = @@v10@@ >= Number ; break ; case Number : @@v8@@ = @@v10@@ > Number ; break ; default : abort ( ) ; } } freev ( ( void * * ) @@i@@ ) ; freev ( @@v12@@ ) ; } return @@i@@ ; }
__int64 __fastcall prune_impossible_nodes ( __int64 @@a1@@ ) { unsigned int @@v2@@ ; __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; _QWORD * @@v5@@ ; _QWORD * @@s@@ ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; void * @@ptr@@ ; unsigned __int64 @@v10@@ ; @@v10@@ = __readfsqword ( Number ) ; @@v7@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@s@@ = Number L ; @@v4@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v3@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( @@v4@@ > Number ) return Number L ; @@v5@@ = malloc ( Number * ( @@v4@@ + Number ) ) ; if ( @@v5@@ ) { if ( * ( _QWORD * ) ( @@v7@@ + Number ) ) { @@s@@ = malloc ( Number * ( @@v4@@ + Number ) ) ; if ( @@s@@ ) { while ( Number ) { memset ( @@s@@ , Number , Number * ( @@v4@@ + Number ) ) ; sift_ctx_init ( @@v8@@ , @@v5@@ , @@s@@ , @@v3@@ , @@v4@@ ) ; @@v2@@ = sift_states_backward ( @@a1@@ , @@v8@@ ) ; free ( @@ptr@@ ) ; if ( @@v2@@ ) break ; if ( * @@v5@@ || * @@s@@ ) { @@v2@@ = merge_state_array ( @@v7@@ , @@v5@@ , @@s@@ , @@v4@@ + Number ) ; free ( @@s@@ ) ; @@s@@ = Number L ; if ( ! @@v2@@ ) goto LABEL_21 ; break ; } do { if ( -- @@v4@@ > Number ) { @@v2@@ = Number ; goto LABEL_22 ; } } while ( ! * ( _QWORD * ) ( Number * @@v4@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) || ( * ( _BYTE * ) ( * ( _QWORD * ) ( Number * @@v4@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) + Number L ) & Number ) == Number ) ; @@v3@@ = check_halt_state_context ( @@a1@@ , * ( _QWORD * ) ( Number * @@v4@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) , @@v4@@ ) ; } } else { @@v2@@ = Number ; } } else { sift_ctx_init ( @@v8@@ , @@v5@@ , Number L , @@v3@@ , @@v4@@ ) ; @@v2@@ = sift_states_backward ( @@a1@@ , @@v8@@ ) ; free ( @@ptr@@ ) ; if ( ! @@v2@@ ) { if ( * @@v5@@ ) { LABEL_21 : free ( * ( void * * ) ( @@a1@@ + Number ) ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v5@@ ; @@v5@@ = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v3@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v4@@ ; @@v2@@ = Number ; } else { @@v2@@ = Number ; } } } } else { @@v2@@ = Number ; } LABEL_22 : free ( @@v5@@ ) ; free ( @@s@@ ) ; return @@v2@@ ; }
__int64 __fastcall rpl_regcomp ( __int64 @@a1@@ , const char * @@a2@@ , int @@a3@@ ) { __int64 @@v3@@ ; size_t @@v5@@ ; unsigned int @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; if ( ( @@a3@@ & Number ) != Number ) @@v3@@ = Number L ; else @@v3@@ = Number L ; @@v8@@ = @@v3@@ ; * ( _QWORD * ) @@a1@@ = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = malloc ( Number ) ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; @@v9@@ = ( @@a3@@ << Number ) & Number | ( unsigned __int64 ) @@v8@@ ; if ( ( @@a3@@ & Number ) != Number ) { @@v9@@ = @@v9@@ & Number | Number ; * ( _BYTE * ) ( @@a1@@ + Number ) |= Number ; } else { * ( _BYTE * ) ( @@a1@@ + Number ) &= Number ; } * ( _BYTE * ) ( @@a1@@ + Number ) = ( Number * ( ( @@a3@@ & Number ) != Number ) ) | * ( _BYTE * ) ( @@a1@@ + Number ) & Number ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; @@v5@@ = strlen ( @@a2@@ ) ; @@v7@@ = re_compile_internal ( @@a1@@ , @@a2@@ , @@v5@@ , @@v9@@ ) ; if ( @@v7@@ == Number ) @@v7@@ = Number ; if ( @@v7@@ ) { free ( * ( void * * ) ( @@a1@@ + Number ) ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; } else { rpl_re_compile_fastmap ( @@a1@@ ) ; } return @@v7@@ ; }
int puts ( const char * @@s@@ ) { return puts ( @@s@@ ) ; }
_QWORD * __fastcall rpl_re_set_registers ( __int64 @@a1@@ , _QWORD * @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ ) { _QWORD * @@result@@ ; if ( @@a3@@ ) { * ( _BYTE * ) ( @@a1@@ + Number ) = * ( _BYTE * ) ( @@a1@@ + Number ) & Number | Number ; * @@a2@@ = @@a3@@ ; @@a2@@ [ Number ] = @@a4@@ ; @@result@@ = @@a2@@ ; @@a2@@ [ Number ] = @@a5@@ ; } else { * ( _BYTE * ) ( @@a1@@ + Number ) &= Number ; * @@a2@@ = Number L ; @@a2@@ [ Number ] = Number L ; @@result@@ = @@a2@@ ; @@a2@@ [ Number ] = @@a2@@ [ Number ] ; } return @@result@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_222028 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 __fastcall merge_state_array ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , unsigned __int64 @@a4@@ ) { _QWORD * @@v5@@ ; unsigned int @@v8@@ ; unsigned __int64 @@i@@ ; void * @@v10@@ [ Number ] ; @@v10@@ [ Number ] = ( void * ) __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ < @@a4@@ ; ++ @@i@@ ) { if ( * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ) { if ( * ( _QWORD * ) ( Number * @@i@@ + @@a3@@ ) ) { @@v8@@ = re_node_set_init_union ( @@v10@@ , * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) + Number L , * ( _QWORD * ) ( Number * @@i@@ + @@a3@@ ) + Number L ) ; if ( @@v8@@ ) return @@v8@@ ; @@v5@@ = ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; * @@v5@@ = re_acquire_state ( & @@v8@@ , @@a1@@ , ( __int64 ) @@v10@@ ) ; free ( @@v10@@ [ Number ] ) ; if ( @@v8@@ ) return @@v8@@ ; } } else { * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) = * ( _QWORD * ) ( Number * @@i@@ + @@a3@@ ) ; } } return Number L ; }
__int64 __fastcall optimize_subexps ( __int64 @@a1@@ , __int64 @@a2@@ ) { unsigned __int64 @@v3@@ ; if ( * ( _BYTE * ) ( @@a2@@ + Number ) == Number && * ( _QWORD * ) ( @@a1@@ + Number ) ) { * ( _QWORD * ) ( @@a2@@ + Number ) = * ( _QWORD * ) ( Number L * ( int ) * ( _QWORD * ) ( @@a2@@ + Number ) + * ( _QWORD * ) ( @@a1@@ + Number ) ) ; * ( _QWORD * ) ( @@a1@@ + Number ) |= Number << * ( _QWORD * ) ( @@a2@@ + Number ) ; } else if ( * ( _BYTE * ) ( @@a2@@ + Number ) == Number && * ( _QWORD * ) ( @@a2@@ + Number ) && * ( _BYTE * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) == Number ) { @@v3@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) ; * ( _QWORD * ) ( @@a2@@ + Number ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) ) * * ( _QWORD * * ) ( @@a2@@ + Number ) = @@a2@@ ; * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@v3@@ ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L * * ( _QWORD * ) ( @@a2@@ + Number ) ) ; if ( @@v3@@ <= Number ) * ( _QWORD * ) ( @@a1@@ + Number ) &= ~ ( Number L << @@v3@@ ) ; } return Number L ; }
_BOOL8 __fastcall check_halt_node_context ( _QWORD * @@a1@@ , __int64 @@a2@@ , char @@a3@@ ) { if ( * ( _BYTE * ) ( Number * @@a2@@ + * @@a1@@ + Number ) != Number ) return Number L ; if ( ( ( * ( _DWORD * ) ( Number * @@a2@@ + * @@a1@@ + Number ) >> Number ) & Number ) == Number ) return Number L ; return ( ( * ( _DWORD * ) ( Number * @@a2@@ + * @@a1@@ + Number ) & Number ) == Number || ( @@a3@@ & Number ) != Number ) && ( ( * ( _DWORD * ) ( Number * @@a2@@ + * @@a1@@ + Number ) & Number ) == Number || ( @@a3@@ & Number ) == Number ) && ( ( * ( _DWORD * ) ( Number * @@a2@@ + * @@a1@@ + Number ) & Number ) == Number || ( @@a3@@ & Number ) != Number ) && ( ( * ( _DWORD * ) ( Number * @@a2@@ + * @@a1@@ + Number ) & Number ) == Number || ( @@a3@@ & Number ) != Number ) ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
unsigned __int64 __fastcall re_string_skip_chars ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ ) { _BOOL4 @@v3@@ ; wchar_t @@pwc@@ ; wchar_t @@v7@@ ; unsigned __int64 @@i@@ ; size_t @@v9@@ ; size_t @@n@@ ; __int64 @@v11@@ ; unsigned __int64 @@v12@@ ; @@v12@@ = __readfsqword ( Number ) ; @@v7@@ = Number ; for ( @@i@@ = * ( _QWORD * ) ( @@a1@@ + Number ) + * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ < @@a2@@ ; @@i@@ += @@v9@@ ) { @@n@@ = * ( _QWORD * ) ( @@a1@@ + Number ) - @@i@@ ; @@v11@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v9@@ = mbrtowc ( & @@pwc@@ , ( const char * ) ( * ( _QWORD * ) @@a1@@ + @@i@@ ) , @@n@@ , ( mbstate_t * ) ( @@a1@@ + Number ) ) ; @@v3@@ = @@v9@@ == Number || @@v9@@ == Number ; if ( ! @@v3@@ && @@v9@@ ) { @@v7@@ = @@pwc@@ ; } else { if ( @@v9@@ && @@n@@ ) @@v7@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) @@a1@@ + @@i@@ ) ; else @@v7@@ = Number ; @@v9@@ = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v11@@ ; } } * @@a3@@ = @@v7@@ ; return @@i@@ ; }
__int64 __fastcall add_epsilon_src_nodes ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { unsigned int @@v5@@ ; unsigned __int64 @@i@@ ; _QWORD * @@v7@@ ; unsigned __int64 @@v8@@ ; @@v8@@ = __readfsqword ( Number ) ; @@v5@@ = Number ; @@v7@@ = re_acquire_state ( & @@v5@@ , @@a1@@ , @@a2@@ ) ; if ( @@v5@@ ) return @@v5@@ ; if ( ! @@v7@@ [ Number ] ) { @@v5@@ = re_node_set_alloc ( @@v7@@ + Number , * ( _QWORD * ) ( @@a2@@ + Number ) ) ; if ( @@v5@@ ) return Number L ; for ( @@i@@ = Number L ; @@i@@ < * ( _QWORD * ) ( @@a2@@ + Number ) ; ++ @@i@@ ) re_node_set_merge ( ( __int64 ) ( @@v7@@ + Number ) , * ( _QWORD * ) ( @@a1@@ + Number ) + Number L * * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) ) ; } return re_node_set_add_intersect ( @@a2@@ , @@a3@@ , ( __int64 ) ( @@v7@@ + Number ) ) ; }
__int64 __fastcall calc_next ( __int64 a1 , __int64 @@a2@@ ) { int @@v2@@ ; @@v2@@ = * ( unsigned __int8 * ) ( @@a2@@ + Number ) ; if ( @@v2@@ == Number ) { * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) = @@a2@@ ; } else if ( @@v2@@ == Number ) { * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) ; * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) = * ( _QWORD * ) ( @@a2@@ + Number ) ; } else { if ( * ( _QWORD * ) ( @@a2@@ + Number ) ) * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) ) * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) = * ( _QWORD * ) ( @@a2@@ + Number ) ; } return Number L ; }
int tolower ( int @@c@@ ) { return tolower ( @@c@@ ) ; }
__int64 __fastcall pop_fail_stack ( _QWORD * @@a1@@ , _QWORD * @@a2@@ , __int64 @@a3@@ , void * @@a4@@ , __int64 @@a5@@ ) { _QWORD * @@v5@@ ; __int64 @@v6@@ ; __int64 @@v9@@ ; @@v9@@ = -- * @@a1@@ ; if ( * @@a1@@ > Number ) __assert_fail ( String , String , Number , String ) ; * @@a2@@ = * ( _QWORD * ) ( @@a1@@ [ Number ] + Number * @@v9@@ ) ; memcpy ( @@a4@@ , * ( const void * * ) ( @@a1@@ [ Number ] + Number * @@v9@@ + Number ) , Number * @@a3@@ ) ; free ( * ( void * * ) ( @@a5@@ + Number ) ) ; free ( * ( void * * ) ( @@a1@@ [ Number ] + Number * @@v9@@ + Number ) ) ; @@v5@@ = ( _QWORD * ) ( @@a1@@ [ Number ] + Number * @@v9@@ ) ; @@v6@@ = @@v5@@ [ Number ] ; * ( _QWORD * ) @@a5@@ = @@v5@@ [ Number ] ; * ( _QWORD * ) ( @@a5@@ + Number ) = @@v6@@ ; * ( _QWORD * ) ( @@a5@@ + Number ) = @@v5@@ [ Number ] ; return * ( _QWORD * ) ( @@a1@@ [ Number ] + Number * @@v9@@ + Number ) ; }
void __fastcall re_string_destruct ( __int64 @@a1@@ ) { free ( * ( void * * ) ( @@a1@@ + Number ) ) ; free ( * ( void * * ) ( @@a1@@ + Number ) ) ; if ( * ( _BYTE * ) ( @@a1@@ + Number ) ) free ( * ( void * * ) ( @@a1@@ + Number ) ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
__int64 __fastcall check_dst_limits_calc_pos ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ , unsigned __int64 @@a5@@ , __int64 @@a6@@ ) { __int64 @@result@@ ; int @@v7@@ ; int @@v8@@ ; __int64 @@v9@@ ; @@v9@@ = * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@a2@@ ; if ( @@a5@@ < * ( _QWORD * ) ( @@v9@@ + Number ) ) return Number ; if ( @@a5@@ > * ( _QWORD * ) ( @@v9@@ + Number ) ) return Number L ; if ( @@a5@@ == * ( _QWORD * ) ( @@v9@@ + Number ) ) @@v7@@ = Number ; else @@v7@@ = Number ; @@v8@@ = @@v7@@ | ( @@a5@@ == * ( _QWORD * ) ( @@v9@@ + Number ) ) ; if ( @@v8@@ ) @@result@@ = check_dst_limits_calc_pos_1 ( @@a1@@ , @@v8@@ , @@a3@@ , @@a4@@ , @@a6@@ ) ; else @@result@@ = Number L ; return @@result@@ ; }
__int64 __fastcall peek_token_bracket ( _BYTE * @@a1@@ , __int64 @@a2@@ , char @@a3@@ ) { char @@v4@@ ; char @@v5@@ ; unsigned int @@v6@@ ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) <= * ( _QWORD * ) ( @@a2@@ + Number ) ) { @@a1@@ [ Number ] = Number ; return Number L ; } @@v5@@ = * ( _BYTE * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + * ( _QWORD * ) ( @@a2@@ + Number ) ) ; * @@a1@@ = @@v5@@ ; if ( * ( int * ) ( @@a2@@ + Number ) > Number && * ( _QWORD * ) ( @@a2@@ + Number ) != * ( _QWORD * ) ( @@a2@@ + Number ) && * ( _DWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L * * ( _QWORD * ) ( @@a2@@ + Number ) ) == Number ) { @@a1@@ [ Number ] = Number ; return Number L ; } if ( @@v5@@ == Number && ( @@a3@@ & Number ) != Number && ( unsigned __int64 ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) < * ( _QWORD * ) ( @@a2@@ + Number ) ) { ++ * ( _QWORD * ) ( @@a2@@ + Number ) ; * @@a1@@ = * ( _BYTE * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + * ( _QWORD * ) ( @@a2@@ + Number ) ) ; @@a1@@ [ Number ] = Number ; return Number L ; } switch ( @@v5@@ ) { case String : if ( ( unsigned __int64 ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) >= * ( _QWORD * ) ( @@a2@@ + Number ) ) @@v4@@ = Number ; else @@v4@@ = * ( _BYTE * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) ; * @@a1@@ = @@v4@@ ; @@v6@@ = Number ; switch ( @@v4@@ ) { case String : if ( ( @@a3@@ & Number ) != Number ) { @@a1@@ [ Number ] = Number ; return @@v6@@ ; } break ; case String : @@a1@@ [ Number ] = Number ; return @@v6@@ ; case String : @@a1@@ [ Number ] = Number ; return @@v6@@ ; } @@a1@@ [ Number ] = Number ; * @@a1@@ = Number ; return Number ; case String : @@a1@@ [ Number ] = Number ; break ; case String : @@a1@@ [ Number ] = Number ; break ; case String : @@a1@@ [ Number ] = Number ; break ; default : @@a1@@ [ Number ] = Number ; break ; } return Number L ; }
__int64 __fastcall re_node_set_alloc ( _QWORD * @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = Number L ; @@a1@@ [ Number ] = malloc ( Number * @@a2@@ ) ; if ( @@a1@@ [ Number ] ) @@result@@ = Number L ; else @@result@@ = Number L ; return @@result@@ ; }
__int64 __fastcall clean_state_log_if_needed ( _QWORD * @@a1@@ , unsigned __int64 @@a2@@ ) { unsigned int @@v3@@ ; unsigned __int64 @@v4@@ ; @@v4@@ = @@a1@@ [ Number ] ; if ( @@a2@@ >= @@a1@@ [ Number ] || @@a2@@ >= @@a1@@ [ Number ] && @@a1@@ [ Number ] < @@a1@@ [ Number ] ) { @@v3@@ = extend_buffers ( @@a1@@ ) ; if ( @@v3@@ ) return @@v3@@ ; } if ( @@v4@@ < @@a2@@ ) { memset ( ( void * ) ( Number * ( @@v4@@ + Number ) + @@a1@@ [ Number ] ) , Number , Number * ( @@a2@@ - @@v4@@ ) ) ; @@a1@@ [ Number ] = @@a2@@ ; } return Number L ; }
__int64 __fastcall mpz_init_set_str ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned int @@a3@@ ) { __int64 @@result@@ ; if ( ( unsigned int ) xstrtoimax ( @@a2@@ , Number L , @@a3@@ , @@a1@@ , Number L ) ) @@result@@ = Number ; else @@result@@ = Number L ; return @@result@@ ; }
__int64 __fastcall check_subexp_matching_top ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { unsigned int @@v5@@ ; unsigned __int64 @@i@@ ; _QWORD * @@v7@@ ; __int64 @@v8@@ ; @@v7@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; for ( @@i@@ = Number L ; @@i@@ < * ( _QWORD * ) ( @@a2@@ + Number ) ; ++ @@i@@ ) { @@v8@@ = * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) ; if ( * ( _BYTE * ) ( Number * @@v8@@ + * @@v7@@ + Number ) == Number && * ( _QWORD * ) ( Number * @@v8@@ + * @@v7@@ ) <= Number && ( ( @@v7@@ [ Number ] >> * ( _QWORD * ) ( Number * @@v8@@ + * @@v7@@ ) ) & Number L ) != Number ) { @@v5@@ = match_ctx_add_subtop ( @@a1@@ , @@v8@@ , @@a3@@ ) ; if ( @@v5@@ ) return @@v5@@ ; } } return Number L ; }
__int64 __fastcall re_node_set_init_1 ( _QWORD * @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; * @@a1@@ = Number L ; @@a1@@ [ Number ] = Number L ; @@a1@@ [ Number ] = malloc ( Number ) ; if ( @@a1@@ [ Number ] ) { * ( _QWORD * ) @@a1@@ [ Number ] = @@a2@@ ; @@result@@ = Number L ; } else { @@a1@@ [ Number ] = Number L ; * @@a1@@ = @@a1@@ [ Number ] ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 * __fastcall mpz_tdiv_q ( __int64 * @@a1@@ , _QWORD * @@a2@@ , __int64 * @@a3@@ ) { __int64 * @@result@@ ; __int64 @@v4@@ ; @@v4@@ = * @@a3@@ ; if ( * @@a2@@ == Number && @@v4@@ == Number ) integer_overflow ( Number L ) ; @@result@@ = @@a1@@ ; * @@a1@@ = * @@a2@@ / @@v4@@ ; return @@result@@ ; }
__int64 __fastcall fetch_number ( __int64 @@a1@@ , unsigned __int8 * @@a2@@ , __int64 @@a3@@ ) { unsigned __int64 @@v4@@ ; unsigned __int8 @@v6@@ ; __int64 @@i@@ ; for ( @@i@@ = Number ; ; @@i@@ = @@v4@@ ) { fetch_token ( ( __int64 ) @@a2@@ , @@a1@@ , @@a3@@ ) ; @@v6@@ = * @@a2@@ ; if ( @@a2@@ [ Number ] == Number ) return Number ; if ( @@a2@@ [ Number ] == Number || @@v6@@ == Number ) break ; if ( @@a2@@ [ Number ] != Number || @@v6@@ <= Number || @@v6@@ > Number || @@i@@ == Number ) { @@v4@@ = Number ; } else if ( @@i@@ == Number ) { @@v4@@ = @@v6@@ - Number ; } else { @@v4@@ = Number * @@i@@ + @@v6@@ - Number ; } if ( @@v4@@ > Number ) @@v4@@ = Number ; } return @@i@@ ; }
__int64 __fastcall update_cur_sifted_state ( _QWORD * @@a1@@ , _QWORD * @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ ) { __int64 @@v4@@ ; __int64 @@result@@ ; _QWORD * @@v6@@ ; unsigned int @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; unsigned __int64 @@v12@@ ; @@v12@@ = __readfsqword ( Number ) ; @@v10@@ = @@a1@@ [ Number ] ; @@v9@@ = Number ; if ( * ( _QWORD * ) ( Number * @@a3@@ + @@a1@@ [ Number ] ) ) @@v4@@ = * ( _QWORD * ) ( Number * @@a3@@ + @@a1@@ [ Number ] ) + Number L ; else @@v4@@ = Number L ; @@v11@@ = @@v4@@ ; if ( * ( _QWORD * ) ( @@a4@@ + Number ) ) { if ( @@v11@@ ) { @@v9@@ = add_epsilon_src_nodes ( @@v10@@ , @@a4@@ , @@v11@@ ) ; if ( @@v9@@ ) return @@v9@@ ; if ( @@a2@@ [ Number ] ) { @@v9@@ = check_subexp_limits ( @@v10@@ , @@a4@@ , @@v11@@ , @@a2@@ + Number , @@a1@@ [ Number ] , @@a3@@ ) ; if ( @@v9@@ ) return @@v9@@ ; } } @@v6@@ = ( _QWORD * ) ( * @@a2@@ + Number * @@a3@@ ) ; * @@v6@@ = re_acquire_state ( & @@v9@@ , @@v10@@ , @@a4@@ ) ; if ( @@v9@@ ) return @@v9@@ ; } else { * ( _QWORD * ) ( Number * @@a3@@ + * @@a2@@ ) = Number L ; } if ( @@v11@@ && ( * ( _BYTE * ) ( * ( _QWORD * ) ( Number * @@a3@@ + @@a1@@ [ Number ] ) + Number L ) & Number ) != Number && ( @@v9@@ = sift_states_bkref ( @@a1@@ , @@a2@@ , @@a3@@ , @@v11@@ ) ) != Number ) { @@result@@ = @@v9@@ ; } else { @@result@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall mpz_sgn ( __int64 * @@a1@@ ) { __int64 @@result@@ ; if ( * @@a1@@ < Number ) @@result@@ = Number ; else @@result@@ = * @@a1@@ > Number ; return @@result@@ ; }
__int64 __fastcall re_node_set_init_copy ( void * @@a1@@ , __int64 @@a2@@ ) { * ( ( _QWORD * ) @@a1@@ + Number ) = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) ) { * ( _QWORD * ) @@a1@@ = * ( ( _QWORD * ) @@a1@@ + Number ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = malloc ( Number L * * ( _QWORD * ) @@a1@@ ) ; if ( ! * ( ( _QWORD * ) @@a1@@ + Number ) ) { * ( ( _QWORD * ) @@a1@@ + Number ) = Number L ; * ( _QWORD * ) @@a1@@ = * ( ( _QWORD * ) @@a1@@ + Number ) ; return Number L ; } memcpy ( * ( ( void * * ) @@a1@@ + Number ) , * ( const void * * ) ( @@a2@@ + Number ) , Number L * * ( _QWORD * ) ( @@a2@@ + Number ) ) ; } else { memset ( @@a1@@ , Number , Number ) ; } return Number L ; }
_BOOL8 __fastcall check_node_accept ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { int @@v3@@ ; _BOOL8 @@result@@ ; char @@v6@@ ; char @@v7@@ ; @@v6@@ = * ( _BYTE * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@a3@@ ) ; @@v3@@ = * ( unsigned __int8 * ) ( @@a2@@ + Number ) ; if ( @@v3@@ == Number ) { if ( ! bitset_contain ( * ( _QWORD * ) @@a2@@ , ( unsigned __int8 ) @@v6@@ ) ) return Number L ; } else if ( * ( unsigned __int8 * ) ( @@a2@@ + Number ) > Number ) { if ( @@v3@@ != Number ) { if ( @@v3@@ != Number ) return Number L ; if ( @@v6@@ < Number ) return Number L ; } if ( @@v6@@ == Number && ( * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L ) & Number ) == Number || ! @@v6@@ && ( * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L ) & Number ) != Number ) { return Number L ; } } else { if ( @@v3@@ != Number ) return Number L ; if ( @@v6@@ != * ( _BYTE * ) @@a2@@ ) return Number L ; } @@result@@ = Number ; if ( ( * ( _DWORD * ) ( @@a2@@ + Number ) & Number ) != Number ) { if ( ( @@v7@@ = re_string_context_at ( @@a1@@ , @@a3@@ , * ( _DWORD * ) ( @@a1@@ + Number ) ) , ( ( * ( _DWORD * ) ( @@a2@@ + Number ) >> Number ) & Number ) != Number ) && ( @@v7@@ & Number ) == Number || ( ( * ( _DWORD * ) ( @@a2@@ + Number ) >> Number ) & Number ) != Number && ( @@v7@@ & Number ) != Number || ( ( * ( _DWORD * ) ( @@a2@@ + Number ) >> Number ) & Number ) != Number && ( @@v7@@ & Number ) == Number || ( ( * ( _DWORD * ) ( @@a2@@ + Number ) >> Number ) & Number ) != Number && ( @@v7@@ & Number ) == Number ) { @@result@@ = Number ; } } return @@result@@ ; }
__int64 __fastcall duplicate_tree ( __int64 * * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v4@@ ; __int64 * @@v5@@ ; __int64 * @@v6@@ ; __int64 * @@v7@@ ; __int64 * @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ = & @@v4@@ ; @@v7@@ = * @@a1@@ ; @@v5@@ = ( __int64 * ) @@a1@@ ; while ( Number ) { @@v2@@ = create_token_tree ( @@a2@@ , Number L , Number L , @@v5@@ + Number ) ; * @@v6@@ = @@v2@@ ; if ( ! * @@v6@@ ) break ; * ( _QWORD * ) * @@v6@@ = @@v7@@ ; * ( _BYTE * ) ( * @@v6@@ + Number ) |= Number ; @@v7@@ = ( __int64 * ) * @@v6@@ ; if ( @@v5@@ [ Number ] ) { @@v5@@ = ( __int64 * ) @@v5@@ [ Number ] ; @@v6@@ = @@v7@@ + Number ; } else { @@v8@@ = Number L ; while ( @@v8@@ == ( __int64 * ) @@v5@@ [ Number ] || ! @@v5@@ [ Number ] ) { @@v8@@ = @@v5@@ ; @@v5@@ = ( __int64 * ) * @@v5@@ ; @@v7@@ = ( __int64 * ) * @@v7@@ ; if ( ! @@v5@@ ) return @@v4@@ ; } @@v5@@ = ( __int64 * ) @@v5@@ [ Number ] ; @@v6@@ = @@v7@@ + Number ; } } return Number L ; }
void __fastcall __noreturn integer_overflow ( char @@a1@@ ) { error ( Number , Number , String , ( unsigned int ) @@a1@@ ) ; abort ( ) ; }
__int64 __fastcall re_node_set_compare ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v3@@ ; if ( ! @@a1@@ || ! @@a2@@ || * ( _QWORD * ) ( @@a1@@ + Number ) != * ( _QWORD * ) ( @@a2@@ + Number ) ) { return Number L ; } @@v3@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; while ( ( unsigned __int64 ) -- @@v3@@ <= Number ) { if ( * ( _QWORD * ) ( Number * @@v3@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) != * ( _QWORD * ) ( Number * @@v3@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) ) return Number L ; } return Number L ; }
__int64 __fastcall merge_state_with_log ( _DWORD * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v4@@ ; __int64 * @@v5@@ ; __int64 @@v6@@ ; unsigned int @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; __int64 @@v12@@ [ Number ] ; void * @@ptr@@ ; unsigned __int64 @@v14@@ ; @@v6@@ = @@a3@@ ; @@v14@@ = __readfsqword ( Number ) ; @@v9@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@v10@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( @@v10@@ <= * ( _QWORD * ) ( @@a2@@ + Number ) ) { if ( * ( _QWORD * ) ( Number * @@v10@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) ) { @@v8@@ = Number L ; @@v11@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( Number * @@v10@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) + Number L ) ; if ( @@a3@@ ) { @@v8@@ = * ( _QWORD * ) ( @@a3@@ + Number ) ; * @@a1@@ = re_node_set_init_union ( @@v12@@ , @@v8@@ , @@v11@@ ) ; if ( * @@a1@@ ) return Number L ; } else { @@v4@@ = * ( _QWORD * ) ( @@v11@@ + Number ) ; @@v12@@ [ Number ] = * ( _QWORD * ) @@v11@@ ; @@v12@@ [ Number ] = @@v4@@ ; @@ptr@@ = * ( void * * ) ( @@v11@@ + Number ) ; } @@v7@@ = re_string_context_at ( @@a2@@ , * ( _QWORD * ) ( @@a2@@ + Number ) - Number L , * ( _DWORD * ) ( @@a2@@ + Number ) ) ; @@v5@@ = ( __int64 * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number * @@v10@@ ) ; * @@v5@@ = re_acquire_state_context ( @@a1@@ , @@v9@@ , ( __int64 ) @@v12@@ , @@v7@@ ) ; @@v6@@ = * @@v5@@ ; if ( @@v8@@ ) free ( @@ptr@@ ) ; } else { * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number * @@v10@@ ) = @@a3@@ ; } } else { * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number * @@v10@@ ) = @@a3@@ ; * ( _QWORD * ) ( @@a2@@ + Number ) = @@v10@@ ; } if ( * ( _QWORD * ) ( @@v9@@ + Number ) && @@v6@@ ) { * @@a1@@ = check_subexp_matching_top ( @@a2@@ , @@v6@@ + Number , @@v10@@ ) ; if ( * @@a1@@ ) return Number L ; if ( ( * ( _BYTE * ) ( @@v6@@ + Number ) & Number ) != Number ) { * @@a1@@ = transit_state_bkref ( @@a2@@ , @@v6@@ + Number ) ; if ( * @@a1@@ ) return Number L ; @@v6@@ = * ( _QWORD * ) ( Number * @@v10@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) ; } } return @@v6@@ ; }
__int64 __fastcall match_ctx_add_subtop ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v3@@ ; void * * @@v5@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@v9@@ ; void * @@v10@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) == * ( _QWORD * ) ( @@a1@@ + Number ) ) { @@v3@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v9@@ = Number * @@v3@@ ; @@v10@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number * @@v3@@ ) ; if ( ! @@v10@@ ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v10@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v9@@ ; } @@v5@@ = ( void * * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L * * ( _QWORD * ) ( @@a1@@ + Number ) ) ; * @@v5@@ = calloc ( Number , Number ) ; if ( ! * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L * * ( _QWORD * ) ( @@a1@@ + Number ) ) ) return Number L ; * ( _QWORD * ) ( * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L * * ( _QWORD * ) ( @@a1@@ + Number ) ) + Number L ) = @@a2@@ ; @@v6@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v7@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v7@@ + Number ; * * ( _QWORD * * ) ( @@v6@@ + Number * @@v7@@ ) = @@a3@@ ; return Number L ; }
__int64 __fastcall str_value ( __int64 @@a1@@ ) { __int64 @@v2@@ ; @@v2@@ = xmalloc ( Number L ) ; * ( _DWORD * ) @@v2@@ = Number ; * ( _QWORD * ) ( @@v2@@ + Number ) = xstrdup ( @@a1@@ ) ; return @@v2@@ ; }
_BOOL8 __fastcall check_halt_node_context ( _QWORD * @@a1@@ , __int64 @@a2@@ , char @@a3@@ ) { if ( * ( _BYTE * ) ( Number * @@a2@@ + * @@a1@@ + Number ) != Number ) return Number L ; if ( ( ( * ( _DWORD * ) ( Number * @@a2@@ + * @@a1@@ + Number ) >> Number ) & Number ) == Number ) return Number L ; return ( ( * ( _DWORD * ) ( Number * @@a2@@ + * @@a1@@ + Number ) & Number ) == Number || ( @@a3@@ & Number ) != Number ) && ( ( * ( _DWORD * ) ( Number * @@a2@@ + * @@a1@@ + Number ) & Number ) == Number || ( @@a3@@ & Number ) == Number ) && ( ( * ( _DWORD * ) ( Number * @@a2@@ + * @@a1@@ + Number ) & Number ) == Number || ( @@a3@@ & Number ) != Number ) && ( ( * ( _DWORD * ) ( Number * @@a2@@ + * @@a1@@ + Number ) & Number ) == Number || ( @@a3@@ & Number ) != Number ) ; }
_QWORD * __fastcall re_acquire_state ( _DWORD * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { _QWORD * @@result@@ ; unsigned __int64 @@i@@ ; __int64 @@v6@@ ; unsigned __int64 * @@v7@@ ; __int64 @@v8@@ ; _QWORD * @@v9@@ ; if ( * ( _QWORD * ) ( @@a3@@ + Number ) ) { @@v6@@ = calc_state_hash ( @@a3@@ , Number ) ; @@v7@@ = ( unsigned __int64 * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number * ( @@v6@@ & * ( _QWORD * ) ( @@a2@@ + Number ) ) ) ; for ( @@i@@ = Number L ; @@i@@ < * @@v7@@ ; ++ @@i@@ ) { @@v9@@ = * ( _QWORD * * ) ( Number * @@i@@ + @@v7@@ [ Number ] ) ; if ( @@v6@@ == * @@v9@@ && ( unsigned __int8 ) re_node_set_compare ( ( __int64 ) ( @@v9@@ + Number ) , @@a3@@ ) ) { return @@v9@@ ; } } @@v8@@ = create_ci_newstate ( @@a2@@ , @@a3@@ , @@v6@@ ) ; if ( ! @@v8@@ ) * @@a1@@ = Number ; @@result@@ = ( _QWORD * ) @@v8@@ ; } else { * @@a1@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 __fastcall looks_like_integer ( _BYTE * @@a1@@ ) { _BYTE * @@v2@@ ; @@v2@@ = & @@a1@@ [ * @@a1@@ == Number ] ; do { if ( ( unsigned int ) ( ( char ) * @@v2@@ - Number ) > Number ) return Number L ; ++ @@v2@@ ; } while ( * @@v2@@ ) ; return Number L ; }
__int64 __fastcall match_ctx_init ( __int64 @@a1@@ , int @@a2@@ , unsigned __int64 @@a3@@ ) { * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number ; if ( ! @@a3@@ ) goto LABEL_7 ; if ( ! is_mul_ok ( Number , @@a3@@ ) ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = malloc ( Number * @@a3@@ ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = malloc ( Number * @@a3@@ ) ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) || ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; LABEL_7 : * ( _QWORD * ) ( @@a1@@ + Number ) = @@a3@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = Number ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@a3@@ ; return Number L ; }
__int64 __fastcall pop_fail_stack ( _QWORD * @@a1@@ , _QWORD * @@a2@@ , __int64 @@a3@@ , void * @@a4@@ , __int64 @@a5@@ ) { _QWORD * @@v5@@ ; __int64 @@v6@@ ; __int64 @@v9@@ ; @@v9@@ = -- * @@a1@@ ; if ( * @@a1@@ > Number ) __assert_fail ( String , String , Number , String ) ; * @@a2@@ = * ( _QWORD * ) ( @@a1@@ [ Number ] + Number * @@v9@@ ) ; memcpy ( @@a4@@ , * ( const void * * ) ( @@a1@@ [ Number ] + Number * @@v9@@ + Number ) , Number * @@a3@@ ) ; free ( * ( void * * ) ( @@a5@@ + Number ) ) ; free ( * ( void * * ) ( @@a1@@ [ Number ] + Number * @@v9@@ + Number ) ) ; @@v5@@ = ( _QWORD * ) ( @@a1@@ [ Number ] + Number * @@v9@@ ) ; @@v6@@ = @@v5@@ [ Number ] ; * ( _QWORD * ) @@a5@@ = @@v5@@ [ Number ] ; * ( _QWORD * ) ( @@a5@@ + Number ) = @@v6@@ ; * ( _QWORD * ) ( @@a5@@ + Number ) = @@v5@@ [ Number ] ; return * ( _QWORD * ) ( @@a1@@ [ Number ] + Number * @@v9@@ + Number ) ; }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
__int64 __fastcall rpl_re_set_syntax ( __int64 @@a1@@ ) { __int64 @@v2@@ ; @@v2@@ = rpl_re_syntax_options ; rpl_re_syntax_options = @@a1@@ ; return @@v2@@ ; }
__int64 __fastcall toarith ( __int64 @@a1@@ ) { _BYTE * @@ptr@@ ; if ( ! * ( _DWORD * ) @@a1@@ ) return Number L ; if ( * ( _DWORD * ) @@a1@@ != Number ) abort ( ) ; @@ptr@@ = * ( _BYTE * * ) ( @@a1@@ + Number ) ; if ( ( unsigned __int8 ) looks_like_integer ( @@ptr@@ ) != Number ) return Number L ; if ( ( unsigned int ) mpz_init_set_str ( @@a1@@ + Number , ( __int64 ) @@ptr@@ , Number ) ) error ( Number , Number , off_1D2EC , @@ptr@@ ) ; free ( @@ptr@@ ) ; * ( _DWORD * ) @@a1@@ = Number ; return Number L ; }
int fdatasync ( int @@fildes@@ ) { return fdatasync ( @@fildes@@ ) ; }
void __fastcall match_ctx_free ( __int64 @@a1@@ ) { match_ctx_clean ( ( _QWORD * ) @@a1@@ ) ; free ( * ( void * * ) ( @@a1@@ + Number ) ) ; free ( * ( void * * ) ( @@a1@@ + Number ) ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
__int64 __fastcall rpl_re_compile_fastmap ( __int64 @@a1@@ ) { _QWORD * @@v2@@ ; void * @@s@@ ; @@v2@@ = * ( _QWORD * * ) @@a1@@ ; @@s@@ = * ( void * * ) ( @@a1@@ + Number ) ; memset ( @@s@@ , Number , Number ) ; re_compile_fastmap_iter ( @@a1@@ , @@v2@@ [ Number ] , @@s@@ ) ; if ( @@v2@@ [ Number ] != @@v2@@ [ Number ] ) re_compile_fastmap_iter ( @@a1@@ , @@v2@@ [ Number ] , @@s@@ ) ; if ( @@v2@@ [ Number ] != @@v2@@ [ Number ] ) re_compile_fastmap_iter ( @@a1@@ , @@v2@@ [ Number ] , @@s@@ ) ; if ( @@v2@@ [ Number ] != @@v2@@ [ Number ] ) re_compile_fastmap_iter ( @@a1@@ , @@v2@@ [ Number ] , @@s@@ ) ; * ( _BYTE * ) ( @@a1@@ + Number ) |= Number ; return Number L ; }
__int64 __fastcall sift_states_backward ( __int64 @@a1@@ , __int64 @@a2@@ ) { int @@v3@@ ; unsigned int @@v4@@ ; unsigned int @@v5@@ ; int @@v6@@ ; __int64 @@v7@@ ; void * @@v8@@ [ Number ] ; void * @@ptr@@ ; unsigned __int64 @@v10@@ ; @@v10@@ = __readfsqword ( Number ) ; @@v6@@ = Number ; @@v7@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@v4@@ = re_node_set_init_1 ( @@v8@@ , * ( _QWORD * ) ( @@a2@@ + Number ) ) ; if ( @@v4@@ ) return @@v4@@ ; @@v5@@ = update_cur_sifted_state ( @@a1@@ , @@a2@@ , @@v7@@ , @@v8@@ ) ; if ( ! @@v5@@ ) { while ( @@v7@@ ) { if ( * ( _QWORD * ) ( Number * @@v7@@ + * ( _QWORD * ) @@a2@@ ) ) @@v3@@ = Number ; else @@v3@@ = @@v6@@ + Number ; @@v6@@ = @@v3@@ ; if ( @@v3@@ > * ( _DWORD * ) ( @@a1@@ + Number ) ) { memset ( * ( void * * ) @@a2@@ , Number , Number * @@v7@@ ) ; free ( @@ptr@@ ) ; return Number L ; } @@v8@@ [ Number ] = Number L ; -- @@v7@@ ; if ( ! * ( _QWORD * ) ( Number * @@v7@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) || ( @@v5@@ = build_sifted_states ( @@a1@@ , @@a2@@ , @@v7@@ , @@v8@@ ) ) == Number ) { @@v5@@ = update_cur_sifted_state ( @@a1@@ , @@a2@@ , @@v7@@ , @@v8@@ ) ; if ( ! @@v5@@ ) continue ; } goto LABEL_15 ; } @@v5@@ = Number ; } LABEL_15 : free ( @@ptr@@ ) ; return @@v5@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 __fastcall docolon ( __int64 @@a1@@ , __int64 @@a2@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; char * @@v4@@ ; int @@v5@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; void * @@ptr@@ ; void * @@v12@@ ; __int64 @@v13@@ [ Number ] ; char * @@v14@@ ; __int64 @@v15@@ ; __int64 @@v16@@ ; char @@v17@@ ; char @@v18@@ ; unsigned __int64 @@v19@@ ; @@v19@@ = __readfsqword ( Number ) ; tostring ( ( unsigned int * ) @@a1@@ ) ; tostring ( ( unsigned int * ) @@a2@@ ) ; @@v10@@ = Number L ; @@ptr@@ = Number L ; @@v12@@ = Number L ; @@v13@@ [ Number ] = Number L ; @@v13@@ [ Number ] = Number L ; @@v14@@ = & @@v18@@ ; @@v15@@ = Number L ; rpl_re_syntax_options = Number L ; @@v2@@ = strlen ( * ( const char * * ) ( @@a2@@ + Number ) ) ; @@v8@@ = rpl_re_compile_pattern ( * ( _QWORD * ) ( @@a2@@ + Number ) , @@v2@@ , @@v13@@ ) ; if ( @@v8@@ ) error ( Number , Number , off_1D2EC , @@v8@@ ) ; @@v17@@ &= Number ; @@v3@@ = strlen ( * ( const char * * ) ( @@a1@@ + Number ) ) ; @@v9@@ = rpl_re_match ( @@v13@@ , * ( _QWORD * ) ( @@a1@@ + Number ) , @@v3@@ , Number L , & @@v10@@ ) ; if ( @@v9@@ < Number ) { if ( @@v9@@ == Number ) { if ( @@v16@@ ) @@v7@@ = str_value ( ( __int64 ) & off_1D2EC [ Number ] ) ; else @@v7@@ = int_value ( Number L ) ; } else { @@v4@@ = gettext ( String ) ; if ( @@v9@@ == Number ) @@v5@@ = * __errno_location ( ) ; else @@v5@@ = Number ; error ( Number , @@v5@@ , @@v4@@ ) ; } } else if ( @@v16@@ ) { * ( _BYTE * ) ( * ( ( _QWORD * ) @@v12@@ + Number ) + * ( _QWORD * ) ( @@a1@@ + Number ) ) = Number ; @@v7@@ = str_value ( * ( ( _QWORD * ) @@ptr@@ + Number ) + * ( _QWORD * ) ( @@a1@@ + Number ) ) ; } else { @@v7@@ = int_value ( @@v9@@ ) ; } if ( @@v10@@ ) { free ( @@ptr@@ ) ; free ( @@v12@@ ) ; } @@v14@@ = Number L ; rpl_regfree ( @@v13@@ ) ; return @@v7@@ ; }
__int64 __fastcall match_ctx_add_subtop ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v3@@ ; void * * @@v5@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@v9@@ ; void * @@v10@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) == * ( _QWORD * ) ( @@a1@@ + Number ) ) { @@v3@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v9@@ = Number * @@v3@@ ; @@v10@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number * @@v3@@ ) ; if ( ! @@v10@@ ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v10@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v9@@ ; } @@v5@@ = ( void * * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L * * ( _QWORD * ) ( @@a1@@ + Number ) ) ; * @@v5@@ = calloc ( Number , Number ) ; if ( ! * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L * * ( _QWORD * ) ( @@a1@@ + Number ) ) ) return Number L ; * ( _QWORD * ) ( * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L * * ( _QWORD * ) ( @@a1@@ + Number ) ) + Number L ) = @@a2@@ ; @@v6@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v7@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v7@@ + Number ; * * ( _QWORD * * ) ( @@v6@@ + Number * @@v7@@ ) = @@a3@@ ; return Number L ; }
__int64 __fastcall init_dfa ( void * * @@a1@@ , unsigned __int64 @@a2@@ ) { __int64 @@result@@ ; int @@v3@@ ; int @@i@@ ; int @@c@@ ; wint_t @@v6@@ ; size_t @@size@@ ; const char * @@s1@@ ; memset ( @@a1@@ , Number , Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = Number ; if ( @@a2@@ >= Number ) return Number L ; @@a1@@ [ Number ] = ( void * ) ( @@a2@@ + Number ) ; * @@a1@@ = malloc ( Number L * ( _QWORD ) @@a1@@ [ Number ] ) ; for ( @@size@@ = Number L ; @@size@@ <= @@a2@@ ; @@size@@ *= Number L ) ; @@a1@@ [ Number ] = calloc ( Number , @@size@@ ) ; @@a1@@ [ Number ] = ( void * ) ( @@size@@ - Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = __ctype_get_mb_cur_max ( ) ; @@s1@@ = nl_langinfo ( Number ) ; if ( ! strcasecmp ( @@s1@@ , String ) || ! strcasecmp ( @@s1@@ , String ) ) * ( ( _BYTE * ) @@a1@@ + Number ) |= Number ; * ( ( _BYTE * ) @@a1@@ + Number ) &= Number ; if ( * ( ( int * ) @@a1@@ + Number ) > Number ) { if ( ( ( _BYTE ) @@a1@@ [ Number ] & Number ) != Number ) { @@a1@@ [ Number ] = & utf8_sb_map ; } else { @@a1@@ [ Number ] = calloc ( Number , Number ) ; if ( ! @@a1@@ [ Number ] ) return Number L ; @@v3@@ = Number ; @@c@@ = Number ; while ( @@v3@@ <= Number ) { for ( @@i@@ = Number ; @@i@@ <= Number ; ++ @@i@@ ) { @@v6@@ = btowc ( @@c@@ ) ; if ( @@v6@@ != Number ) * ( ( _QWORD * ) @@a1@@ [ Number ] + @@v3@@ ) |= Number L << @@i@@ ; if ( ( @@c@@ & Number ) == Number && @@v6@@ != @@c@@ ) * ( ( _BYTE * ) @@a1@@ + Number ) |= Number ; ++ @@c@@ ; } ++ @@v3@@ ; } } } if ( * @@a1@@ && @@a1@@ [ Number ] ) @@result@@ = Number L ; else @@result@@ = Number L ; return @@result@@ ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 __fastcall sub_epsilon_src_nodes ( _QWORD * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ ) { __int64 @@v4@@ ; unsigned int @@v8@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@j@@ ; __int64 @@v11@@ ; unsigned __int64 @@v12@@ ; unsigned __int64 @@v13@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; char @@s@@ [ Number ] ; void * @@ptr@@ ; unsigned __int64 @@v19@@ ; @@v19@@ = __readfsqword ( Number ) ; @@v11@@ = @@a1@@ [ Number ] + Number * @@a2@@ ; memset ( @@s@@ , Number , Number ) ; for ( @@i@@ = Number L ; @@i@@ < * ( _QWORD * ) ( @@v11@@ + Number ) ; ++ @@i@@ ) { @@v14@@ = * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@v11@@ + Number ) ) ; if ( @@v14@@ != @@a2@@ && ( * ( _BYTE * ) ( Number * @@v14@@ + * @@a1@@ + Number ) & Number ) != Number ) { @@v15@@ = * * ( _QWORD * * ) ( @@a1@@ [ Number ] + Number * @@v14@@ + Number ) ; @@v4@@ = * ( _QWORD * ) ( @@a1@@ [ Number ] + Number * @@v14@@ + Number ) <= Number ? Number : * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ [ Number ] + Number * @@v14@@ + Number ) + Number L ) ; if ( ( @@v16@@ = @@v4@@ , ! re_node_set_contains ( @@v11@@ , @@v15@@ ) ) && re_node_set_contains ( @@a3@@ , @@v15@@ ) || @@v16@@ - Number <= Number && ! re_node_set_contains ( @@v11@@ , @@v16@@ ) && re_node_set_contains ( @@a3@@ , @@v16@@ ) ) { @@v8@@ = re_node_set_add_intersect ( ( __int64 ) @@s@@ , @@a4@@ , @@a1@@ [ Number ] + Number * @@v14@@ ) ; if ( @@v8@@ ) { free ( @@ptr@@ ) ; return @@v8@@ ; } } } } for ( @@j@@ = Number L ; @@j@@ < * ( _QWORD * ) ( @@v11@@ + Number ) ; ++ @@j@@ ) { @@v12@@ = * ( _QWORD * ) ( Number * @@j@@ + * ( _QWORD * ) ( @@v11@@ + Number ) ) ; if ( ! re_node_set_contains ( ( __int64 ) @@s@@ , @@v12@@ ) ) { @@v13@@ = re_node_set_contains ( @@a3@@ , @@v12@@ ) - Number ; re_node_set_remove_at ( @@a3@@ , @@v13@@ ) ; } } free ( @@ptr@@ ) ; return Number L ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 __fastcall bkm_scale_by_power ( __int64 * @@a1@@ , int @@a2@@ , int @@a3@@ ) { unsigned int @@i@@ ; for ( @@i@@ = Number ; @@a3@@ -- ; @@i@@ |= bkm_scale ( @@a1@@ , @@a2@@ ) ) ; return @@i@@ ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
__int64 __fastcall calc_first ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { __int64 @@v3@@ ; if ( * ( ( _BYTE * ) @@a2@@ + Number ) == Number ) { @@a2@@ [ Number ] = * ( _QWORD * ) ( @@a2@@ [ Number ] + Number L ) ; @@a2@@ [ Number ] = * ( _QWORD * ) ( @@a2@@ [ Number ] + Number L ) ; } else { @@a2@@ [ Number ] = @@a2@@ ; @@a2@@ [ Number ] = re_dfa_add_node ( ( __int64 ) @@a1@@ , @@a2@@ [ Number ] , @@a2@@ [ Number ] ) ; if ( @@a2@@ [ Number ] == Number ) return Number L ; if ( * ( ( _BYTE * ) @@a2@@ + Number ) == Number ) { @@v3@@ = Number L * @@a2@@ [ Number ] + * @@a1@@ ; * ( _DWORD * ) ( @@v3@@ + Number ) = ( ( @@a2@@ [ Number ] & Number ) << Number ) | * ( _DWORD * ) ( @@v3@@ + Number ) & Number ; } } return Number L ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
int fileno ( FILE * @@stream@@ ) { return fileno ( @@stream@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
int rename ( const char * @@old@@ , const char * @@a2@@ ) { return rename ( @@old@@ , @@a2@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
__int64 * _do_global_dtors_aux ( ) { __int64 * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; char * @@v3@@ ; FILE * @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; FILE * @@v10@@ ; char * @@v11@@ ; FILE * @@v12@@ ; char * @@v13@@ ; FILE * @@v14@@ ; char * @@v15@@ ; FILE * @@v16@@ ; char * @@v17@@ ; @@v1@@ = program_name ; if ( @@a1@@ ) { @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = gettext ( String ) ; printf ( @@v3@@ , @@v1@@ ) ; @@v4@@ = stdout ; @@v5@@ = gettext ( String String String String ) ; fputs_unlocked ( @@v5@@ , @@v4@@ ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; @@v8@@ = stdout ; @@v9@@ = gettext ( String String String String String String ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = stdout ; @@v11@@ = gettext ( String String ) ; fputs_unlocked ( @@v11@@ , @@v10@@ ) ; @@v12@@ = stdout ; @@v13@@ = gettext ( String ) ; fputs_unlocked ( @@v13@@ , @@v12@@ ) ; @@v14@@ = stdout ; @@v15@@ = gettext ( String ) ; fputs_unlocked ( @@v15@@ , @@v14@@ ) ; @@v16@@ = stdout ; @@v17@@ = gettext ( String String String String ) ; fputs_unlocked ( @@v17@@ , @@v16@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
__int64 __fastcall duplicate_node ( _QWORD * @@a1@@ , __int64 @@a2@@ , __int16 @@a3@@ ) { __int64 @@v5@@ ; @@v5@@ = re_dfa_add_node ( ( __int64 ) @@a1@@ , * ( _QWORD * ) ( Number * @@a2@@ + * @@a1@@ ) , * ( _QWORD * ) ( Number * @@a2@@ + * @@a1@@ + Number ) ) ; if ( @@v5@@ != Number ) { * ( _DWORD * ) ( * @@a1@@ + Number * @@v5@@ + Number ) = ( ( @@a3@@ & Number ) << Number ) | * ( _DWORD * ) ( * @@a1@@ + Number * @@v5@@ + Number ) & Number ; * ( _DWORD * ) ( Number * @@v5@@ + * @@a1@@ + Number ) = ( ( ( ( * ( _DWORD * ) ( Number * @@a2@@ + * @@a1@@ + Number ) >> Number ) & Number | ( * ( _DWORD * ) ( Number * @@v5@@ + * @@a1@@ + Number ) >> Number ) & Number ) & Number ) << Number ) | * ( _DWORD * ) ( Number * @@v5@@ + * @@a1@@ + Number ) & Number ; * ( _BYTE * ) ( Number * @@v5@@ + * @@a1@@ + Number ) |= Number ; * ( _QWORD * ) ( @@a1@@ [ Number ] + Number * @@v5@@ ) = @@a2@@ ; } return @@v5@@ ; }
__int64 __fastcall merge_state_with_log ( _DWORD * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v4@@ ; __int64 * @@v5@@ ; __int64 @@v6@@ ; unsigned int @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; __int64 @@v12@@ [ Number ] ; void * @@ptr@@ ; unsigned __int64 @@v14@@ ; @@v6@@ = @@a3@@ ; @@v14@@ = __readfsqword ( Number ) ; @@v9@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@v10@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( @@v10@@ <= * ( _QWORD * ) ( @@a2@@ + Number ) ) { if ( * ( _QWORD * ) ( Number * @@v10@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) ) { @@v8@@ = Number L ; @@v11@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( Number * @@v10@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) + Number L ) ; if ( @@a3@@ ) { @@v8@@ = * ( _QWORD * ) ( @@a3@@ + Number ) ; * @@a1@@ = re_node_set_init_union ( @@v12@@ , @@v8@@ , @@v11@@ ) ; if ( * @@a1@@ ) return Number L ; } else { @@v4@@ = * ( _QWORD * ) ( @@v11@@ + Number ) ; @@v12@@ [ Number ] = * ( _QWORD * ) @@v11@@ ; @@v12@@ [ Number ] = @@v4@@ ; @@ptr@@ = * ( void * * ) ( @@v11@@ + Number ) ; } @@v7@@ = re_string_context_at ( @@a2@@ , * ( _QWORD * ) ( @@a2@@ + Number ) - Number L , * ( _DWORD * ) ( @@a2@@ + Number ) ) ; @@v5@@ = ( __int64 * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number * @@v10@@ ) ; * @@v5@@ = re_acquire_state_context ( @@a1@@ , @@v9@@ , ( __int64 ) @@v12@@ , @@v7@@ ) ; @@v6@@ = * @@v5@@ ; if ( @@v8@@ ) free ( @@ptr@@ ) ; } else { * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number * @@v10@@ ) = @@a3@@ ; } } else { * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number * @@v10@@ ) = @@a3@@ ; * ( _QWORD * ) ( @@a2@@ + Number ) = @@v10@@ ; } if ( * ( _QWORD * ) ( @@v9@@ + Number ) && @@v6@@ ) { * @@a1@@ = check_subexp_matching_top ( @@a2@@ , @@v6@@ + Number , @@v10@@ ) ; if ( * @@a1@@ ) return Number L ; if ( ( * ( _BYTE * ) ( @@v6@@ + Number ) & Number ) != Number ) { * @@a1@@ = transit_state_bkref ( @@a2@@ , @@v6@@ + Number ) ; if ( * @@a1@@ ) return Number L ; @@v6@@ = * ( _QWORD * ) ( Number * @@v10@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) ; } } return @@v6@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
int __fastcall passname ( unsigned __int8 * @@a1@@ , char * @@a2@@ ) { int @@result@@ ; if ( @@a1@@ ) @@result@@ = sprintf ( @@a2@@ , String , * @@a1@@ , @@a1@@ [ Number ] , @@a1@@ [ Number ] ) ; else @@result@@ = ( unsigned int ) memcpy ( @@a2@@ , String , Number ) ; return @@result@@ ; }
__int64 __fastcall head_lines ( __int64 @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { __int64 @@v3@@ ; char * @@v4@@ ; int * @@v5@@ ; size_t @@v7@@ ; __int64 @@v8@@ ; char * @@v9@@ ; char * @@v10@@ ; int * @@v11@@ ; int @@errnum@@ ; size_t @@n@@ ; unsigned __int64 @@v15@@ ; struct stat @@stat_buf@@ ; char @@ptr@@ [ Number ] ; unsigned __int64 @@v18@@ ; @@v18@@ = __readfsqword ( Number ) ; while ( @@a3@@ ) { @@v15@@ = safe_read ( @@a2@@ , @@ptr@@ , Number ) ; @@n@@ = Number L ; if ( @@v15@@ == Number ) { @@v3@@ = quote ( @@a1@@ ) ; @@v4@@ = gettext ( String ) ; @@v5@@ = __errno_location ( ) ; error ( Number , * @@v5@@ , @@v4@@ , @@v3@@ ) ; return Number L ; } if ( ! @@v15@@ ) break ; while ( @@n@@ < @@v15@@ ) { @@v7@@ = @@n@@ ++ ; if ( @@ptr@@ [ @@v7@@ ] == Number && ! -- @@a3@@ ) { if ( lseek ( @@a2@@ , @@n@@ - @@v15@@ , Number ) < Number ) { @@errnum@@ = * __errno_location ( ) ; if ( ( unsigned int ) fstat ( @@a2@@ , & @@stat_buf@@ ) || ( @@stat_buf@@ . st_mode & Number ) == Number ) { @@v8@@ = quote ( @@a1@@ ) ; @@v9@@ = gettext ( String ) ; error ( Number , @@errnum@@ , @@v9@@ , @@v8@@ ) ; } } break ; } } if ( @@n@@ > fwrite_unlocked ( @@ptr@@ , Number , @@n@@ , stdout ) ) { @@v10@@ = gettext ( String ) ; @@v11@@ = __errno_location ( ) ; error ( Number , * @@v11@@ , @@v10@@ ) ; } } return Number L ; }
__int64 __fastcall parse_sub_exp ( __int64 @@a1@@ , __int64 * @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , _DWORD * @@a6@@ ) { unsigned __int64 @@v6@@ ; __int64 @@result@@ ; __int64 @@v12@@ ; __int64 @@v13@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; @@v14@@ = * @@a2@@ ; @@v6@@ = @@a2@@ [ Number ] ; @@a2@@ [ Number ] = @@v6@@ + Number ; @@v15@@ = @@v6@@ ; fetch_token ( @@a3@@ , @@a1@@ , @@a4@@ | Number ) ; if ( * ( _BYTE * ) ( @@a3@@ + Number ) == Number ) { @@v12@@ = Number L ; } else { @@v12@@ = parse_reg_exp ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( ! * @@a6@@ && * ( _BYTE * ) ( @@a3@@ + Number ) != Number ) * @@a6@@ = Number ; if ( * @@a6@@ ) return Number L ; } if ( @@v15@@ <= Number ) * ( _QWORD * ) ( @@v14@@ + Number ) |= Number << @@v15@@ ; @@v13@@ = create_tree ( @@v14@@ , @@v12@@ , Number L , Number L ) ; if ( @@v13@@ ) { * ( _QWORD * ) ( @@v13@@ + Number ) = @@v15@@ ; @@result@@ = @@v13@@ ; } else { * @@a6@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
__int64 __fastcall match_ctx_init ( __int64 @@a1@@ , int @@a2@@ , unsigned __int64 @@a3@@ ) { * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number ; if ( ! @@a3@@ ) goto LABEL_7 ; if ( ! is_mul_ok ( Number , @@a3@@ ) ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = malloc ( Number * @@a3@@ ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = malloc ( Number * @@a3@@ ) ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) || ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; LABEL_7 : * ( _QWORD * ) ( @@a1@@ + Number ) = @@a3@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = Number ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@a3@@ ; return Number L ; }
_BOOL8 __fastcall ignorable_sync_errno ( int @@a1@@ ) { return @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
__int64 __fastcall create_tree ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , char @@a4@@ ) { char @@v5@@ [ Number ] ; unsigned __int64 @@v6@@ ; @@v6@@ = __readfsqword ( Number ) ; @@v5@@ [ Number ] = @@a4@@ ; return create_token_tree ( @@a1@@ , @@a2@@ , @@a3@@ , @@v5@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
_QWORD * __fastcall match_ctx_add_sublast ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v5@@ ; void * @@v6@@ ; _QWORD * @@v7@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) == * ( _QWORD * ) ( @@a1@@ + Number ) ) { @@v5@@ = Number L * * ( _QWORD * ) ( @@a1@@ + Number ) + Number ; @@v6@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number * @@v5@@ ) ; if ( ! @@v6@@ ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v6@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v5@@ ; } @@v7@@ = calloc ( Number , Number ) ; if ( @@v7@@ ) { * ( _QWORD * ) ( Number L * * ( _QWORD * ) ( @@a1@@ + Number ) + * ( _QWORD * ) ( @@a1@@ + Number ) ) = @@v7@@ ; * @@v7@@ = @@a2@@ ; @@v7@@ [ Number ] = @@a3@@ ; ++ * ( _QWORD * ) ( @@a1@@ + Number ) ; } return @@v7@@ ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
__int64 __fastcall direct_mode ( int @@a1@@ , char @@a2@@ , int @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { __int64 @@result@@ ; int @@v7@@ ; int @@v8@@ ; int @@v9@@ ; int @@v10@@ ; @@result@@ = rpl_fcntl ( @@a1@@ , Number , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; @@v10@@ = @@result@@ ; if ( ( int ) @@result@@ > Number ) { if ( @@a2@@ ) BYTE1 ( @@result@@ ) |= Number ; else BYTE1 ( @@result@@ ) &= Number ; @@result@@ = ( unsigned int ) @@result@@ ; if ( ( _DWORD ) @@result@@ != @@v10@@ ) @@result@@ = rpl_fcntl ( @@a1@@ , Number , @@result@@ , @@v7@@ , @@v8@@ , @@v9@@ ) ; } return @@result@@ ; }
__int64 __fastcall create_token_tree ( __int64 @@a1@@ , __int64 * @@a2@@ , __int64 * @@a3@@ , _QWORD * @@a4@@ ) { __int64 @@v5@@ ; int @@v6@@ ; __int64 @@v7@@ ; _QWORD * @@v11@@ ; __int64 @@v12@@ ; if ( * ( _DWORD * ) ( @@a1@@ + Number ) == Number ) { @@v11@@ = malloc ( Number ) ; if ( ! @@v11@@ ) return Number L ; * @@v11@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v11@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = Number ; } @@v5@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v6@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@v6@@ + Number ; @@v12@@ = @@v5@@ + ( ( __int64 ) @@v6@@ << Number ) + Number ; * ( _QWORD * ) @@v12@@ = Number L ; * ( _QWORD * ) ( @@v12@@ + Number ) = @@a2@@ ; * ( _QWORD * ) ( @@v12@@ + Number ) = @@a3@@ ; @@v7@@ = @@a4@@ [ Number ] ; * ( _QWORD * ) ( @@v12@@ + Number ) = * @@a4@@ ; * ( _QWORD * ) ( @@v5@@ + ( ( __int64 ) @@v6@@ << Number ) + Number ) = @@v7@@ ; * ( _BYTE * ) ( @@v12@@ + Number ) &= Number ; * ( _BYTE * ) ( @@v12@@ + Number ) &= Number ; * ( _QWORD * ) ( @@v12@@ + Number ) = Number L ; * ( _QWORD * ) ( @@v12@@ + Number ) = Number L ; * ( _QWORD * ) ( @@v12@@ + Number ) = Number ; if ( @@a2@@ ) * @@a2@@ = @@v12@@ ; if ( @@a3@@ ) * @@a3@@ = @@v12@@ ; return @@v5@@ + ( ( __int64 ) @@v6@@ << Number ) + Number ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
__int64 __fastcall fraccompare ( _BYTE * @@a1@@ , _BYTE * @@a2@@ , char @@a3@@ ) { _BYTE * @@v4@@ ; _BYTE * @@v5@@ ; @@v5@@ = @@a1@@ ; @@v4@@ = @@a2@@ ; if ( @@a3@@ == * @@a1@@ && @@a3@@ == * @@a2@@ ) { while ( * ++ @@v5@@ == * ++ @@v4@@ ) { if ( ( unsigned int ) ( ( char ) * @@v5@@ - Number ) > Number ) return Number L ; } if ( ( unsigned int ) ( ( char ) * @@v5@@ - Number ) <= Number && ( unsigned int ) ( ( char ) * @@v4@@ - Number ) <= Number ) { return ( unsigned int ) ( ( char ) * @@v5@@ - ( char ) * @@v4@@ ) ; } if ( ( unsigned int ) ( ( char ) * @@v5@@ - Number ) > Number ) { if ( ( unsigned int ) ( ( char ) * @@v4@@ - Number ) > Number ) return Number L ; LABEL_23 : while ( * @@v4@@ == Number ) ++ @@v4@@ ; return ( unsigned int ) - ( ( unsigned int ) ( ( char ) * @@v4@@ - Number ) <= Number ) ; } } else { @@v5@@ = @@a1@@ + Number ; if ( @@a3@@ != * @@a1@@ ) { @@v4@@ = @@a2@@ + Number ; if ( @@a3@@ != * @@a2@@ ) return Number L ; goto LABEL_23 ; } } while ( * @@v5@@ == Number ) ++ @@v5@@ ; return ( unsigned int ) ( ( char ) * @@v5@@ - Number ) <= Number ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
__int64 __fastcall incname ( __int64 @@a1@@ , __int64 @@a2@@ ) { char * @@v5@@ ; while ( @@a2@@ -- ) { @@v5@@ = strchr ( String , * ( char * ) ( @@a1@@ + @@a2@@ ) ) ; if ( @@v5@@ [ Number ] ) { * ( _BYTE * ) ( @@a2@@ + @@a1@@ ) = @@v5@@ [ Number ] ; return Number L ; } * ( _BYTE * ) ( @@a1@@ + @@a2@@ ) = Number ; } return Number L ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
__int64 __fastcall re_copy_regs ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ , int @@a4@@ ) { _QWORD * @@v5@@ ; unsigned int @@v7@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@v9@@ ; void * @@ptr@@ ; void * @@v11@@ ; @@v7@@ = Number ; @@v9@@ = @@a3@@ + Number ; if ( @@a4@@ ) { if ( @@a4@@ == Number ) { if ( @@v9@@ > * ( _QWORD * ) @@a1@@ ) { @@ptr@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number * @@v9@@ ) ; if ( ! @@ptr@@ ) return Number L ; @@v11@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number * @@v9@@ ) ; if ( ! @@v11@@ ) { free ( @@ptr@@ ) ; return Number L ; } * ( _QWORD * ) ( @@a1@@ + Number ) = @@ptr@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v11@@ ; * ( _QWORD * ) @@a1@@ = @@v9@@ ; } } else { if ( @@a4@@ != Number ) __assert_fail ( String , String , Number , String ) ; if ( @@a3@@ > * ( _QWORD * ) @@a1@@ ) __assert_fail ( String , String , Number , String ) ; @@v7@@ = Number ; } } else { * ( _QWORD * ) ( @@a1@@ + Number ) = malloc ( Number * @@v9@@ ) ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = malloc ( Number * @@v9@@ ) ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) { free ( * ( void * * ) ( @@a1@@ + Number ) ) ; return Number L ; } * ( _QWORD * ) @@a1@@ = @@v9@@ ; } for ( @@i@@ = Number L ; @@i@@ < @@a3@@ ; ++ @@i@@ ) { * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@i@@ ) = * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@i@@ ) = * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ + Number ) ; } while ( @@i@@ < * ( _QWORD * ) @@a1@@ ) { @@v5@@ = ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) ; * @@v5@@ = Number ; * ( _QWORD * ) ( Number * @@i@@ ++ + * ( _QWORD * ) ( @@a1@@ + Number ) ) = * @@v5@@ ; } return @@v7@@ ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_2220C8 ; @@v8@@ [ Number ] = qword_2220D0 ; @@v8@@ [ Number ] = qword_2220D8 ; @@v8@@ [ Number ] = qword_2220E0 ; @@v8@@ [ Number ] = qword_2220E8 ; @@v8@@ [ Number ] = qword_2220F0 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; _bss_start = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
_QWORD * __fastcall update_regs ( _QWORD * @@a1@@ , _QWORD * @@a2@@ , void * @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ , unsigned __int64 @@a6@@ ) { _QWORD * @@result@@ ; int @@v7@@ ; unsigned __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@result@@ = ( _QWORD * ) * ( unsigned __int8 * ) ( Number * @@a4@@ + * @@a1@@ + Number ) ; @@v7@@ = * ( unsigned __int8 * ) ( Number * @@a4@@ + * @@a1@@ + Number ) ; if ( @@v7@@ == Number ) { @@v9@@ = * ( _QWORD * ) ( Number * @@a4@@ + * @@a1@@ ) + Number L ; @@result@@ = ( _QWORD * ) @@v9@@ ; if ( @@v9@@ < @@a6@@ ) { @@a2@@ [ Number * @@v9@@ ] = @@a5@@ ; @@result@@ = & @@a2@@ [ Number * @@v9@@ ] ; @@result@@ [ Number ] = Number ; } } else if ( @@v7@@ == Number ) { @@v8@@ = * ( _QWORD * ) ( Number * @@a4@@ + * @@a1@@ ) + Number L ; @@result@@ = ( _QWORD * ) @@v8@@ ; if ( @@v8@@ < @@a6@@ ) { if ( ( unsigned __int64 ) @@a5@@ <= @@a2@@ [ Number * @@v8@@ ] ) { if ( ( * ( _BYTE * ) ( Number * @@a4@@ + * @@a1@@ + Number ) & Number ) == Number || * ( ( _QWORD * ) @@a3@@ + Number * @@v8@@ ) == Number ) { @@result@@ = @@a5@@ ; @@a2@@ [ Number * @@v8@@ + Number ] = @@a5@@ ; } else { @@result@@ = memcpy ( @@a2@@ , @@a3@@ , Number * @@a6@@ ) ; } } else { @@a2@@ [ Number * @@v8@@ + Number ] = @@a5@@ ; @@result@@ = memcpy ( @@a3@@ , @@a2@@ , Number * @@a6@@ ) ; } } } return @@result@@ ; }
void __fastcall genpattern ( char * @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ ) { int * @@v3@@ ; int * @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; int @@v8@@ ; int @@v9@@ ; int @@v10@@ ; __int64 @@v11@@ ; unsigned __int64 @@v12@@ ; int * @@src@@ ; char * @@dest@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@j@@ ; unsigned __int64 @@v17@@ ; __int64 @@v18@@ ; if ( @@a2@@ ) { @@src@@ = ( int * ) & patterns ; @@v11@@ = Number L ; @@dest@@ = @@a1@@ ; for ( @@i@@ = @@a2@@ ; ; @@i@@ -= @@v8@@ ) { while ( Number ) { while ( Number ) { @@v3@@ = @@src@@ ++ ; @@v8@@ = * @@v3@@ ; if ( * @@v3@@ ) break ; @@src@@ = ( int * ) & patterns ; } if ( @@v8@@ >= Number ) break ; @@v9@@ = - @@v8@@ ; if ( @@i@@ <= @@v9@@ ) { @@v11@@ += @@i@@ ; goto LABEL_18 ; } @@v11@@ += @@v9@@ ; @@i@@ -= @@v9@@ ; } if ( @@i@@ < @@v8@@ ) break ; memcpy ( @@dest@@ , @@src@@ , Number L * @@v8@@ ) ; @@src@@ += @@v8@@ ; @@dest@@ += Number * @@v8@@ ; } if ( @@i@@ > Number && Number * @@i@@ >= @@v8@@ ) { do { if ( @@i@@ == @@v8@@ || @@i@@ > randint_choose ( @@a3@@ , @@v8@@ ) ) { @@v4@@ = ( int * ) @@dest@@ ; @@dest@@ += Number ; * @@v4@@ = * @@src@@ ; -- @@i@@ ; } ++ @@src@@ ; } while ( @@i@@ ) ; } else { @@v11@@ += @@i@@ ; } LABEL_18 : @@v18@@ = @@a2@@ - @@v11@@ ; @@v12@@ = @@v11@@ - Number ; @@v17@@ = @@v12@@ ; for ( @@j@@ = Number L ; @@j@@ < @@a2@@ ; ++ @@j@@ ) { if ( @@v17@@ > @@v12@@ ) { @@v6@@ = randint_choose ( @@a3@@ , @@v18@@ - @@j@@ ) ; @@v10@@ = * ( _DWORD * ) & @@a1@@ [ Number * @@j@@ ] ; * ( _DWORD * ) & @@a1@@ [ Number * @@j@@ ] = * ( _DWORD * ) & @@a1@@ [ Number * @@v6@@ + Number * @@j@@ ] ; * ( _DWORD * ) & @@a1@@ [ Number * @@v6@@ + Number * @@j@@ ] = @@v10@@ ; } else { @@v17@@ = @@a2@@ + @@v17@@ - Number ; @@v5@@ = @@v18@@ ++ ; * ( _DWORD * ) & @@a1@@ [ Number * @@v5@@ ] = * ( _DWORD * ) & @@a1@@ [ Number * @@j@@ ] ; * ( _DWORD * ) & @@a1@@ [ Number * @@j@@ ] = Number ; } @@v17@@ -= @@v12@@ ; } } }
void * __fastcall bitset_empty ( void * @@a1@@ ) { return memset ( @@a1@@ , Number , Number ) ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
void * __fastcall bitset_set_all ( void * @@a1@@ ) { return memset ( @@a1@@ , Number , Number ) ; }
void __fastcall __noreturn randread_error ( __int64 @@a1@@ ) { __int64 @@v1@@ ; const char * @@v2@@ ; char * @@v3@@ ; int * @@v4@@ ; if ( @@a1@@ ) { @@v1@@ = quotearg_colon ( @@a1@@ ) ; if ( * __errno_location ( ) ) @@v2@@ = String ; else @@v2@@ = String ; @@v3@@ = gettext ( @@v2@@ ) ; @@v4@@ = __errno_location ( ) ; error ( exit_failure , * @@v4@@ , @@v3@@ , @@v1@@ ) ; } abort ( ) ; }
__int64 __fastcall check_dst_limits ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ ) { unsigned __int64 @@i@@ ; _QWORD * @@v12@@ ; __int64 @@v13@@ ; __int64 @@v14@@ ; __int64 @@v15@@ ; __int64 @@v16@@ ; @@v12@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; @@v13@@ = search_cur_bkref_entry ( @@a1@@ , @@a4@@ ) ; @@v14@@ = search_cur_bkref_entry ( @@a1@@ , @@a6@@ ) ; for ( @@i@@ = Number L ; @@i@@ < * ( _QWORD * ) ( @@a2@@ + Number ) ; ++ @@i@@ ) { @@v15@@ = * ( _QWORD * ) ( * @@v12@@ + Number L * * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L * * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) ) ) ; @@v16@@ = ( int ) check_dst_limits_calc_pos ( @@a1@@ , * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) , @@v15@@ , @@a3@@ , @@a4@@ , @@v13@@ ) ; if ( ( int ) check_dst_limits_calc_pos ( @@a1@@ , * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) , @@v15@@ , @@a5@@ , @@a6@@ , @@v14@@ ) != @@v16@@ ) return Number L ; } return Number L ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall re_string_char_size_at ( __int64 @@a1@@ , __int64 @@a2@@ ) { int @@i@@ ; if ( * ( _DWORD * ) ( @@a1@@ + Number ) == Number ) return Number L ; for ( @@i@@ = Number ; ( unsigned __int64 ) ( @@a2@@ + @@i@@ ) < * ( _QWORD * ) ( @@a1@@ + Number ) && * ( _DWORD * ) ( Number * ( @@i@@ + @@a2@@ ) + * ( _QWORD * ) ( @@a1@@ + Number ) ) == Number ; ++ @@i@@ ) { ; } return ( unsigned int ) @@i@@ ; }
size_t * __fastcall readisaac ( size_t * @@a1@@ , char * @@a2@@ , size_t @@a3@@ ) { size_t * @@result@@ ; size_t @@i@@ ; char * @@v7@@ ; for ( @@i@@ = * @@a1@@ ; @@a3@@ > @@i@@ ; @@i@@ = Number L ) { memcpy ( @@a2@@ , ( char * ) @@a1@@ + Number - @@i@@ + Number , @@i@@ ) ; @@a2@@ += @@i@@ ; @@a3@@ -= @@i@@ ; if ( ( ( unsigned __int8 ) @@a2@@ & Number ) == Number ) { @@v7@@ = @@a2@@ ; while ( @@a3@@ > Number ) { isaac_refill ( @@a1@@ + Number , @@v7@@ ) ; @@v7@@ += Number ; @@a3@@ -= Number L ; if ( ! @@a3@@ ) { @@result@@ = @@a1@@ ; * @@a1@@ = Number L ; return @@result@@ ; } } @@a2@@ = @@v7@@ ; } isaac_refill ( @@a1@@ + Number , ( char * ) @@a1@@ + Number ) ; } memcpy ( @@a2@@ , ( char * ) @@a1@@ + Number - @@i@@ + Number , @@a3@@ ) ; @@result@@ = @@a1@@ ; * @@a1@@ = @@i@@ - @@a3@@ ; return @@result@@ ; }
size_t __fastcall readsource ( __int64 @@a1@@ , char * @@a2@@ , size_t @@a3@@ ) { size_t @@result@@ ; int @@v4@@ ; int @@v7@@ ; size_t @@v8@@ ; while ( Number ) { @@v8@@ = fread_unlocked ( @@a2@@ , Number , @@a3@@ , * ( FILE * * ) @@a1@@ ) ; @@v7@@ = * __errno_location ( ) ; @@a2@@ += @@v8@@ ; @@result@@ = @@v8@@ ; @@a3@@ -= @@v8@@ ; if ( ! @@a3@@ ) break ; if ( ferror_unlocked ( * ( FILE * * ) @@a1@@ ) ) @@v4@@ = @@v7@@ ; else @@v4@@ = Number ; * __errno_location ( ) = @@v4@@ ; ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@a1@@ + Number ) ) ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ; } return @@result@@ ; }
__int64 __fastcall transit_state ( _DWORD * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; unsigned __int8 @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; if ( ( * ( _BYTE * ) ( @@a3@@ + Number ) & Number ) != Number ) { * @@a1@@ = transit_state_mb ( @@a2@@ , @@a3@@ ) ; if ( * @@a1@@ ) return Number L ; } @@v4@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@v5@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; * ( _QWORD * ) ( @@a2@@ + Number ) = @@v5@@ + Number ; @@v9@@ = * ( _BYTE * ) ( @@v4@@ + @@v5@@ ) ; while ( Number ) { @@v10@@ = * ( _QWORD * ) ( @@a3@@ + Number ) ; if ( @@v10@@ ) return * ( _QWORD * ) ( Number L * @@v9@@ + @@v10@@ ) ; @@v11@@ = * ( _QWORD * ) ( @@a3@@ + Number ) ; if ( @@v11@@ ) break ; if ( ( unsigned __int8 ) build_trtable ( * ( _QWORD * ) ( @@a2@@ + Number ) , @@a3@@ ) != Number ) { * @@a1@@ = Number ; return Number L ; } } if ( ( re_string_context_at ( @@a2@@ , * ( _QWORD * ) ( @@a2@@ + Number ) - Number L , * ( _DWORD * ) ( @@a2@@ + Number ) ) & Number ) != Number ) @@v6@@ = Number * ( @@v9@@ + Number L ) ; else @@v6@@ = Number L * @@v9@@ ; return * ( _QWORD * ) ( @@v6@@ + @@v11@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_2090E8 ; @@v4@@ [ Number ] = qword_2090F0 ; @@v4@@ [ Number ] = qword_2090F8 ; @@v4@@ [ Number ] = qword_209100 ; @@v4@@ [ Number ] = qword_209108 ; @@v4@@ [ Number ] = qword_209110 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
__int64 __fastcall re_string_construct_common ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , char @@a5@@ , __int64 @@a6@@ ) { bool @@v6@@ ; __int64 @@result@@ ; * ( _QWORD * ) @@a3@@ = @@a1@@ ; * ( _QWORD * ) ( @@a3@@ + Number ) = @@a2@@ ; * ( _QWORD * ) ( @@a3@@ + Number ) = @@a2@@ ; * ( _QWORD * ) ( @@a3@@ + Number ) = @@a4@@ ; * ( _BYTE * ) ( @@a3@@ + Number ) = @@a5@@ ; @@v6@@ = @@a4@@ || @@a5@@ ; * ( _BYTE * ) ( @@a3@@ + Number ) = @@v6@@ ; * ( _DWORD * ) ( @@a3@@ + Number ) = * ( _DWORD * ) ( @@a6@@ + Number ) ; * ( _BYTE * ) ( @@a3@@ + Number ) = ( * ( _BYTE * ) ( @@a6@@ + Number ) & Number ) != Number ; * ( _BYTE * ) ( @@a3@@ + Number ) = ( * ( _BYTE * ) ( @@a6@@ + Number ) & Number ) != Number ; * ( _QWORD * ) ( @@a3@@ + Number ) = * ( _QWORD * ) ( @@a3@@ + Number ) ; @@result@@ = @@a3@@ ; * ( _QWORD * ) ( @@a3@@ + Number ) = * ( _QWORD * ) ( @@a3@@ + Number ) ; return @@result@@ ; }
_DWORD * __fastcall isaac_seed_data ( _DWORD * @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { _DWORD * @@result@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@j@@ ; unsigned __int64 @@k@@ ; char * @@v9@@ ; char * @@v10@@ ; for ( @@i@@ = Number L - ( unsigned int ) @@a1@@ [ Number ] ; @@a3@@ > @@i@@ ; @@i@@ = Number L ) { @@v9@@ = ( char * ) @@a1@@ + ( unsigned int ) @@a1@@ [ Number ] ; for ( @@j@@ = Number L ; @@j@@ < @@i@@ ; ++ @@j@@ ) @@v9@@ [ @@j@@ ] ^= * ( _BYTE * ) ( @@a2@@ + @@j@@ ) ; @@a2@@ += @@i@@ ; @@a3@@ -= @@i@@ ; isaac_mix ( @@a1@@ , ( __int64 ) @@a1@@ ) ; @@a1@@ [ Number ] = Number ; } @@v10@@ = ( char * ) @@a1@@ + ( unsigned int ) @@a1@@ [ Number ] ; for ( @@k@@ = Number L ; @@k@@ < @@a3@@ ; ++ @@k@@ ) @@v10@@ [ @@k@@ ] ^= * ( _BYTE * ) ( @@a2@@ + @@k@@ ) ; @@result@@ = @@a1@@ ; @@a1@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
__int64 __fastcall re_string_peek_byte_case ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; __int64 @@v3@@ ; if ( ! * ( _BYTE * ) ( @@a1@@ + Number ) ) return * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ ) ; if ( * ( int * ) ( @@a1@@ + Number ) > Number && ( * ( _DWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ ) ) == Number || * ( _QWORD * ) ( @@a1@@ + Number ) != * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ + Number && * ( _DWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ + Number ) ) == Number ) ) { return * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ ) ; } @@v3@@ = * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ ; if ( * ( _BYTE * ) ( @@a1@@ + Number ) ) @@v3@@ = * ( _QWORD * ) ( Number * @@v3@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) ; if ( * ( _BYTE * ) ( @@a1@@ + Number ) && ( * ( _BYTE * ) ( * ( _QWORD * ) @@a1@@ + * ( _QWORD * ) ( @@a1@@ + Number ) + @@v3@@ ) & Number ) != Number ) { @@result@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ ) ; } else { @@result@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) @@a1@@ + * ( _QWORD * ) ( @@a1@@ + Number ) + @@v3@@ ) ; } return @@result@@ ; }
__int64 __fastcall find_subexp_node ( _QWORD * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , int @@a4@@ ) { unsigned __int64 @@i@@ ; __int64 @@v6@@ ; for ( @@i@@ = Number L ; @@i@@ < * ( _QWORD * ) ( @@a2@@ + Number ) ; ++ @@i@@ ) { @@v6@@ = Number L * * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) + * @@a1@@ ; if ( @@a4@@ == * ( unsigned __int8 * ) ( @@v6@@ + Number ) && @@a3@@ == * ( _QWORD * ) @@v6@@ ) { return * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) ; } } return Number ; }
FILE * __fastcall fopen_safer ( const char * @@a1@@ , const char * @@a2@@ ) { int @@v3@@ ; int @@fd@@ ; int @@v5@@ ; int @@v6@@ ; FILE * @@stream@@ ; @@stream@@ = fopen ( @@a1@@ , @@a2@@ ) ; if ( ! @@stream@@ ) return @@stream@@ ; @@v3@@ = fileno ( @@stream@@ ) ; if ( @@v3@@ < Number || @@v3@@ > Number ) return @@stream@@ ; @@fd@@ = dup_safer ( ( unsigned int ) @@v3@@ ) ; if ( @@fd@@ < Number ) { @@v6@@ = * __errno_location ( ) ; fclose ( @@stream@@ ) ; * __errno_location ( ) = @@v6@@ ; return Number L ; } if ( ! fclose ( @@stream@@ ) ) { @@stream@@ = fdopen ( @@fd@@ , @@a2@@ ) ; if ( @@stream@@ ) return @@stream@@ ; } @@v5@@ = * __errno_location ( ) ; close ( @@fd@@ ) ; * __errno_location ( ) = @@v5@@ ; return Number L ; }
__int64 __fastcall umaxtostr ( unsigned __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v4@@ ; @@v4@@ = @@a2@@ + Number ; * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; do { * ( _BYTE * ) -- @@v4@@ = @@a1@@ % Number + Number ; @@a1@@ /= Number ; } while ( @@a1@@ ) ; return @@v4@@ ; }
__int64 __fastcall dir_name ( __int64 @@a1@@ ) { __int64 @@v2@@ ; @@v2@@ = mdir_name ( @@a1@@ ) ; if ( ! @@v2@@ ) xalloc_die ( ) ; return @@v2@@ ; }
unsigned __int64 __fastcall re_node_set_contains ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { unsigned __int64 @@result@@ ; unsigned __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; if ( ( unsigned __int64 ) ( * ( _QWORD * ) ( @@a1@@ + Number ) - Number L ) > Number ) return Number L ; @@v3@@ = Number L ; @@v4@@ = * ( _QWORD * ) ( @@a1@@ + Number ) - Number L ; while ( @@v3@@ < @@v4@@ ) { if ( @@a2@@ <= * ( _QWORD * ) ( Number * ( ( @@v3@@ + @@v4@@ ) >> Number ) + * ( _QWORD * ) ( @@a1@@ + Number ) ) ) @@v4@@ = ( @@v3@@ + @@v4@@ ) >> Number ; else @@v3@@ = ( ( @@v3@@ + @@v4@@ ) >> Number ) + Number ; } if ( @@a2@@ == * ( _QWORD * ) ( Number * @@v3@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) ) @@result@@ = @@v3@@ + Number ; else @@result@@ = Number L ; return @@result@@ ; }
__int64 __fastcall check_arrival_expand_ecl ( _QWORD * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , unsigned int @@a4@@ ) { __int64 @@v5@@ ; unsigned int @@v8@@ ; unsigned int @@v9@@ ; unsigned __int64 @@i@@ ; __int64 @@v11@@ ; __int64 @@v12@@ ; __int64 @@v13@@ [ Number ] ; void * @@ptr@@ ; unsigned __int64 @@v15@@ ; @@v15@@ = __readfsqword ( Number ) ; @@v8@@ = re_node_set_alloc ( @@v13@@ , * ( _QWORD * ) ( @@a2@@ + Number ) ) ; if ( @@v8@@ ) return @@v8@@ ; for ( @@i@@ = Number L ; @@i@@ < * ( _QWORD * ) ( @@a2@@ + Number ) ; ++ @@i@@ ) { @@v11@@ = * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) ; @@v12@@ = @@a1@@ [ Number ] + Number * @@v11@@ ; if ( find_subexp_node ( @@a1@@ , @@v12@@ , @@a3@@ , @@a4@@ ) == Number ) { @@v9@@ = re_node_set_merge ( ( __int64 ) @@v13@@ , @@v12@@ ) ; if ( @@v9@@ ) goto LABEL_6 ; } else { @@v9@@ = check_arrival_expand_ecl_sub ( @@a1@@ , @@v13@@ , @@v11@@ , @@a3@@ , @@a4@@ ) ; if ( @@v9@@ ) { LABEL_6 : free ( @@ptr@@ ) ; return @@v9@@ ; } } } free ( * ( void * * ) ( @@a2@@ + Number ) ) ; @@v5@@ = @@v13@@ [ Number ] ; * ( _QWORD * ) @@a2@@ = @@v13@@ [ Number ] ; * ( _QWORD * ) ( @@a2@@ + Number ) = @@v5@@ ; * ( _QWORD * ) ( @@a2@@ + Number ) = @@ptr@@ ; return Number L ; }
__int64 __fastcall human_options ( char * @@a1@@ , int * @@a2@@ , uintmax_t * @@a3@@ ) { unsigned int @@v5@@ ; @@v5@@ = humblock ( @@a1@@ , @@a3@@ , @@a2@@ ) ; if ( ! * @@a3@@ ) { * @@a3@@ = default_block_size ( ) ; @@v5@@ = Number ; } return @@v5@@ ; }
char * __fastcall create_ci_newstate ( _QWORD * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { char * @@result@@ ; int @@v5@@ ; unsigned __int64 @@i@@ ; char * @@ptr@@ ; __int64 @@v8@@ ; @@ptr@@ = ( char * ) calloc ( Number , Number ) ; if ( ! @@ptr@@ ) return Number L ; if ( ( unsigned int ) re_node_set_init_copy ( @@ptr@@ + Number , @@a2@@ ) ) { free ( @@ptr@@ ) ; @@result@@ = Number L ; } else { * ( ( _QWORD * ) @@ptr@@ + Number ) = @@ptr@@ + Number ; for ( @@i@@ = Number L ; @@i@@ < * ( _QWORD * ) ( @@a2@@ + Number ) ; ++ @@i@@ ) { @@v8@@ = * @@a1@@ + Number L * * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) ; @@v5@@ = * ( unsigned __int8 * ) ( @@v8@@ + Number ) ; if ( @@v5@@ != Number || ( * ( _DWORD * ) ( @@v8@@ + Number ) & Number ) != Number ) { @@ptr@@ [ Number ] = ( Number * ( ( * ( _BYTE * ) ( @@v8@@ + Number ) & Number ) != Number || ( @@ptr@@ [ Number ] & Number ) != Number ) ) | @@ptr@@ [ Number ] & Number ; if ( @@v5@@ == Number ) { @@ptr@@ [ Number ] |= Number ; } else if ( @@v5@@ == Number ) { @@ptr@@ [ Number ] |= Number ; } else if ( @@v5@@ == Number || ( * ( _DWORD * ) ( @@v8@@ + Number ) & Number ) != Number ) { @@ptr@@ [ Number ] |= Number ; } } } if ( ( unsigned int ) register_state ( @@a1@@ , @@ptr@@ , @@a3@@ ) ) { free_state ( ( void * * ) @@ptr@@ ) ; @@ptr@@ = Number L ; } @@result@@ = @@ptr@@ ; } return @@result@@ ; }
__int64 __fastcall rpl_fcntl ( int @@a1@@ , int @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , __m128 @@a7@@ , __m128 @@a8@@ , __m128 @@a9@@ , __m128 @@a10@@ , __m128 @@a11@@ , __m128 @@a12@@ , __m128 @@a13@@ , __m128 @@a14@@ ) { int @@v14@@ ; int @@v15@@ ; int @@v16@@ ; int @@v18@@ ; int @@v19@@ ; int @@v20@@ ; int @@v21@@ ; __int64 @@v22@@ ; __int64 @@v23@@ ; __int64 @@v24@@ ; __int64 @@v25@@ ; __m128 @@v26@@ ; __m128 @@v27@@ ; __m128 @@v28@@ ; __m128 @@v29@@ ; __m128 @@v30@@ ; __m128 @@v31@@ ; __m128 @@v32@@ ; __m128 @@v33@@ ; @@v22@@ = @@a3@@ ; @@v23@@ = @@a4@@ ; @@v24@@ = @@a5@@ ; @@v25@@ = @@a6@@ ; @@v26@@ = @@a7@@ ; @@v27@@ = @@a8@@ ; @@v28@@ = @@a9@@ ; @@v29@@ = @@a10@@ ; @@v30@@ = @@a11@@ ; @@v31@@ = @@a12@@ ; @@v32@@ = @@a13@@ ; @@v33@@ = @@a14@@ ; if ( @@a2@@ != Number ) return ( unsigned int ) fcntl ( @@a1@@ , @@a2@@ , @@v22@@ ) ; @@v19@@ = @@v22@@ ; if ( have_dupfd_cloexec_2895 < Number ) { @@v18@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v22@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; } else { @@v18@@ = fcntl ( @@a1@@ , Number , ( unsigned int ) @@v22@@ ) ; if ( @@v18@@ < Number && * __errno_location ( ) == Number ) { @@v18@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v19@@ , @@v14@@ , @@v15@@ , @@v16@@ ) ; if ( @@v18@@ < Number ) return ( unsigned int ) @@v18@@ ; have_dupfd_cloexec_2895 = Number ; } else { have_dupfd_cloexec_2895 = Number ; } } if ( @@v18@@ >= Number && have_dupfd_cloexec_2895 == Number ) { @@v20@@ = fcntl ( @@v18@@ , Number ) ; if ( @@v20@@ < Number || fcntl ( @@v18@@ , Number , @@v20@@ | Number ) == Number ) { @@v21@@ = * __errno_location ( ) ; close ( @@v18@@ ) ; * __errno_location ( ) = @@v21@@ ; @@v18@@ = Number ; } } return ( unsigned int ) @@v18@@ ; }
void __fastcall match_ctx_free ( __int64 @@a1@@ ) { match_ctx_clean ( ( _QWORD * ) @@a1@@ ) ; free ( * ( void * * ) ( @@a1@@ + Number ) ) ; free ( * ( void * * ) ( @@a1@@ + Number ) ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
__int64 __fastcall free_workarea_compile ( __int64 * @@a1@@ ) { __int64 @@result@@ ; _QWORD * @@ptr@@ ; __int64 @@v3@@ ; _QWORD * @@v4@@ ; @@v3@@ = * @@a1@@ ; for ( @@ptr@@ = * ( _QWORD * * ) ( * @@a1@@ + Number ) ; @@ptr@@ ; @@ptr@@ = @@v4@@ ) { @@v4@@ = ( _QWORD * ) * @@ptr@@ ; free ( @@ptr@@ ) ; } * ( _QWORD * ) ( @@v3@@ + Number ) = Number L ; * ( _DWORD * ) ( @@v3@@ + Number ) = Number ; * ( _QWORD * ) ( @@v3@@ + Number ) = Number L ; free ( * ( void * * ) ( @@v3@@ + Number ) ) ; @@result@@ = @@v3@@ ; * ( _QWORD * ) ( @@v3@@ + Number ) = Number L ; return @@result@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
__int64 __fastcall search_cur_bkref_entry ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { __int64 @@result@@ ; unsigned __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; @@v4@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v3@@ = Number L ; while ( @@v3@@ < @@v4@@ ) { if ( @@a2@@ <= * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * ( ( @@v3@@ + @@v4@@ ) >> Number ) + Number ) ) @@v4@@ = ( @@v3@@ + @@v4@@ ) >> Number ; else @@v3@@ = ( ( @@v3@@ + @@v4@@ ) >> Number ) + Number ; } if ( @@v3@@ < * ( _QWORD * ) ( @@a1@@ + Number ) && @@a2@@ == * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@v3@@ + Number ) ) { @@result@@ = @@v3@@ ; } else { @@result@@ = Number ; } return @@result@@ ; }
__int64 __fastcall postorder ( _QWORD * @@a1@@ , __int64 ( __fastcall * @@a2@@ ( ) ( void , bintreet0 ) ) ( __int64 , _QWORD * ) , __int64 @@a3@@ ) { unsigned int @@v5@@ ; _QWORD * @@v7@@ ; LABEL_5 : while ( @@a1@@ [ Number ] || @@a1@@ [ Number ] ) { if ( @@a1@@ [ Number ] ) @@a1@@ = ( _QWORD * ) @@a1@@ [ Number ] ; else @@a1@@ = ( _QWORD * ) @@a1@@ [ Number ] ; } while ( Number ) { @@v5@@ = @@a2@@ ( ) ( void , bintreet0 ) ( @@a3@@ , @@a1@@ ) ; if ( @@v5@@ ) return @@v5@@ ; if ( ! * @@a1@@ ) return Number L ; @@v7@@ = @@a1@@ ; @@a1@@ = ( _QWORD * ) * @@a1@@ ; if ( @@v7@@ != ( _QWORD * ) @@a1@@ [ Number ] && @@a1@@ [ Number ] ) { @@a1@@ = ( _QWORD * ) @@a1@@ [ Number ] ; goto LABEL_5 ; } } }
void * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
int __cdecl __noreturn main ( int @@argc@@ , const char * * @@argv@@ , const char * * @@envp@@ ) { char * @@v3@@ ; __int64 @@v4@@ ; char * @@v5@@ ; int * @@v6@@ ; char * @@v7@@ ; __mode_t @@v8@@ ; char * @@v9@@ ; __int64 @@v10@@ ; char * @@v11@@ ; int * @@v12@@ ; __mode_t @@mode@@ ; int @@status@@ ; int @@v15@@ ; __int64 @@v16@@ ; __int64 @@v17@@ ; void * @@ptr@@ ; @@v16@@ = Number L ; @@status@@ = Number ; @@v17@@ = Number L ; set_program_name ( * @@argv@@ , @@argv@@ , @@envp@@ ) ; setlocale ( Number , & locale ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; while ( Number ) { @@v15@@ = getopt_long ( @@argc@@ , ( char * const * ) @@argv@@ , String , & longopts , Number L ) ; if ( @@v15@@ == Number ) { if ( @@argc@@ == optind ) { @@v3@@ = gettext ( String ) ; error ( Number , Number , @@v3@@ ) ; usage ( Number ) ; } if ( @@v17@@ && ( int ) setfscreatecon ( @@v17@@ ) < Number ) { @@v4@@ = quote ( @@v17@@ ) ; @@v5@@ = gettext ( String ) ; @@v6@@ = __errno_location ( ) ; error ( Number , * @@v6@@ , @@v5@@ , @@v4@@ ) ; } @@mode@@ = Number ; if ( @@v16@@ ) { @@ptr@@ = ( void * ) mode_compile ( @@v16@@ ) ; if ( ! @@ptr@@ ) { @@v7@@ = gettext ( String ) ; error ( Number , Number , @@v7@@ ) ; } @@v8@@ = umask ( Number ) ; @@mode@@ = mode_adjust ( Number L , Number L , @@v8@@ , @@ptr@@ , Number L ) ; free ( @@ptr@@ ) ; if ( ( @@mode@@ & Number ) != Number ) { @@v9@@ = gettext ( String ) ; error ( Number , Number , @@v9@@ ) ; } } while ( @@argc@@ > optind ) { if ( mkfifo ( @@argv@@ [ optind ] , @@mode@@ ) ) { @@v10@@ = quote ( @@argv@@ [ optind ] ) ; @@v11@@ = gettext ( String ) ; @@v12@@ = __errno_location ( ) ; error ( Number , * @@v12@@ , @@v11@@ , @@v10@@ ) ; @@status@@ = Number ; } ++ optind ; } exit ( @@status@@ ) ; } if ( @@v15@@ == Number ) usage ( Number ) ; if ( @@v15@@ <= Number ) break ; if ( @@v15@@ == Number ) { @@v17@@ = optarg ; } else { if ( @@v15@@ != Number ) goto LABEL_12 ; @@v16@@ = optarg ; } } if ( @@v15@@ == Number ) { version_etc ( ( _DWORD ) stdout , ( unsigned int ) String , ( unsigned int ) String , ( _DWORD ) Version , ( unsigned int ) String , Number , ( char ) @@argv@@ ) ; exit ( Number ) ; } LABEL_12 : usage ( Number ) ; }
void * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall lower_subexps ( __int64 @@a1@@ , __int64 @@a2@@ ) { unsigned int @@v3@@ ; __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; @@v5@@ = __readfsqword ( Number ) ; @@v4@@ = @@a1@@ ; @@v3@@ = Number ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) ) { if ( * ( _BYTE * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) == Number ) { * ( _QWORD * ) ( @@a2@@ + Number ) = lower_subexp ( & @@v3@@ , @@v4@@ , * ( _QWORD * ) ( @@a2@@ + Number ) ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) ) * * ( _QWORD * * ) ( @@a2@@ + Number ) = @@a2@@ ; } } if ( * ( _QWORD * ) ( @@a2@@ + Number ) ) { if ( * ( _BYTE * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) == Number ) { * ( _QWORD * ) ( @@a2@@ + Number ) = lower_subexp ( & @@v3@@ , @@v4@@ , * ( _QWORD * ) ( @@a2@@ + Number ) ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) ) * * ( _QWORD * * ) ( @@a2@@ + Number ) = @@a2@@ ; } } return @@v3@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
void * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
__int64 __fastcall link_nfa_nodes ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; unsigned int @@v3@@ ; unsigned __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; __int64 @@v6@@ ; @@v6@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@v3@@ = Number ; switch ( * ( _BYTE * ) ( @@a2@@ + Number ) ) { case Number : if ( * ( _QWORD * ) ( @@a2@@ + Number ) ) __assert_fail ( String , String , Number , String ) ; return @@result@@ ; case Number : * ( _QWORD * ) ( Number * @@v6@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) ; if ( * ( _BYTE * ) ( @@a2@@ + Number ) == Number ) re_node_set_init_1 ( ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@v6@@ ) , * ( _QWORD * ) ( Number * @@v6@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) ) ; break ; case Number : case Number : case Number : @@v3@@ = re_node_set_init_1 ( ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@v6@@ ) , * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) ) ; break ; case Number : case Number : * ( _BYTE * ) ( @@a1@@ + Number ) |= Number ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) ) @@v4@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) + Number L ) ; else @@v4@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) ) @@v5@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) + Number L ) ; else @@v5@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) ; if ( @@v4@@ > Number ) __assert_fail ( String , String , Number , String ) ; if ( @@v5@@ > Number ) __assert_fail ( String , String , Number , String ) ; @@v3@@ = re_node_set_init_2 ( ( _QWORD * ) ( Number * @@v6@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) , @@v4@@ , @@v5@@ ) ; break ; case Number : return @@v3@@ ; default : if ( ( * ( _BYTE * ) ( @@a2@@ + Number ) & Number ) != Number ) __assert_fail ( String , String , Number , String ) ; * ( _QWORD * ) ( Number * @@v6@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) ; break ; } return @@v3@@ ; }
void * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall umaxtostr ( unsigned __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v4@@ ; @@v4@@ = @@a2@@ + Number ; * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; do { * ( _BYTE * ) -- @@v4@@ = @@a1@@ % Number + Number ; @@a1@@ /= Number ; } while ( @@a1@@ ) ; return @@v4@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
void * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
int unlink ( const char * @@name@@ ) { return unlink ( @@name@@ ) ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
int isatty ( int @@fd@@ ) { return isatty ( @@fd@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_2070C8 ; @@v4@@ [ Number ] = qword_2070D0 ; @@v4@@ [ Number ] = qword_2070D8 ; @@v4@@ [ Number ] = qword_2070E0 ; @@v4@@ [ Number ] = qword_2070E8 ; @@v4@@ [ Number ] = qword_2070F0 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
void * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_20D0C8 ; @@v8@@ [ Number ] = qword_20D0D0 ; @@v8@@ [ Number ] = qword_20D0D8 ; @@v8@@ [ Number ] = qword_20D0E0 ; @@v8@@ [ Number ] = qword_20D0E8 ; @@v8@@ [ Number ] = qword_20D0F0 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
__int64 __fastcall parse_branch ( __int64 @@a1@@ , __int64 * @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , _DWORD * @@a6@@ ) { __int64 @@v11@@ ; __int64 @@v12@@ ; __int64 @@v13@@ ; @@v12@@ = * @@a2@@ ; @@v11@@ = parse_expression ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( * @@a6@@ && ! @@v11@@ ) return Number L ; while ( * ( _BYTE * ) ( @@a3@@ + Number ) != Number && * ( _BYTE * ) ( @@a3@@ + Number ) != Number && ( ! @@a5@@ || * ( _BYTE * ) ( @@a3@@ + Number ) != Number ) ) { @@v13@@ = parse_expression ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( * @@a6@@ && ! @@v13@@ ) return Number L ; if ( @@v11@@ && @@v13@@ ) { @@v11@@ = create_tree ( @@v12@@ , @@v11@@ , @@v13@@ , Number L ) ; if ( ! @@v11@@ ) { * @@a6@@ = Number ; return Number L ; } } else if ( ! @@v11@@ ) { @@v11@@ = @@v13@@ ; } } return @@v11@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 __fastcall _xargmatch_internal ( __int64 @@a1@@ , const char * @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ , void ( * @@a6@@ ) ( void ) ) { __int64 @@v11@@ ; @@v11@@ = argmatch ( @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; if ( @@v11@@ >= Number ) return @@v11@@ ; argmatch_invalid ( @@a1@@ , ( __int64 ) @@a2@@ , @@v11@@ ) ; argmatch_valid ( @@a3@@ , @@a4@@ , @@a5@@ ) ; @@a6@@ ( ) ; return Number ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ ) { return xmalloc ( @@a1@@ ) ; }
int __fastcall argmatch_valid ( __int64 @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { char * @@v3@@ ; __int64 @@i@@ ; void * @@s1@@ ; @@s1@@ = Number L ; @@v3@@ = gettext ( String ) ; fprintf ( stderr , @@v3@@ ) ; for ( @@i@@ = Number L ; * ( _QWORD * ) ( Number * @@i@@ + @@a1@@ ) ; ++ @@i@@ ) { if ( @@i@@ && ! memcmp ( @@s1@@ , ( const void * ) ( @@i@@ * @@a3@@ + @@a2@@ ) , @@a3@@ ) ) { fprintf ( stderr , String , * ( const char * * ) ( Number * @@i@@ + @@a1@@ ) ) ; } else { fprintf ( stderr , String , * ( const char * * ) ( Number * @@i@@ + @@a1@@ ) ) ; @@s1@@ = ( void * ) ( @@i@@ * @@a3@@ + @@a2@@ ) ; } } return putc_unlocked ( Number , stderr ) ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
__int64 __fastcall build_equiv_class ( __int64 @@a1@@ , __int64 a2 , __int64 a3 , const char * @@a4@@ ) { if ( strlen ( @@a4@@ ) != Number ) return Number L ; bitset_set ( @@a1@@ , * ( unsigned __int8 * ) @@a4@@ ) ; return Number L ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
time_t time ( time_t * @@timer@@ ) { return time ( @@timer@@ ) ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
int fsync ( int @@fd@@ ) { return fsync ( @@fd@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
int __fastcall lstat ( char * @@filename@@ , struct stat * @@stat_buf@@ ) { return __lxstat ( Number , @@filename@@ , @@stat_buf@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall build_charclass_op ( __int64 @@a1@@ , __int64 @@a2@@ , const char * @@a3@@ , _BYTE * @@a4@@ , char @@a5@@ , _DWORD * @@a6@@ ) { int @@v11@@ ; __int64 @@v12@@ ; void * @@ptr@@ ; _BYTE * @@v14@@ ; __int64 @@v15@@ ; __int64 @@v16@@ ; void * @@v17@@ ; char @@v18@@ ; unsigned __int64 @@v19@@ ; @@v19@@ = __readfsqword ( Number ) ; @@v12@@ = Number L ; @@ptr@@ = calloc ( Number , Number ) ; @@v14@@ = calloc ( Number , Number ) ; if ( ! @@ptr@@ || ! @@v14@@ ) { * @@a6@@ = Number ; return Number L ; } if ( @@a5@@ ) @@v14@@ [ Number ] |= Number ; @@v11@@ = build_charclass ( @@a2@@ , ( __int64 ) @@ptr@@ , ( __int64 ) @@v14@@ , & @@v12@@ , @@a3@@ , Number ) ; if ( @@v11@@ ) { free ( @@ptr@@ ) ; free_charset ( @@v14@@ ) ; * @@a6@@ = @@v11@@ ; return Number L ; } while ( * @@a4@@ ) bitset_set ( ( __int64 ) @@ptr@@ , ( unsigned __int8 ) * @@a4@@ ++ ) ; if ( @@a5@@ ) bitset_not ( ( __int64 ) @@ptr@@ ) ; if ( * ( int * ) ( @@a1@@ + Number ) > Number ) bitset_mask ( ( __int64 ) @@ptr@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ; @@v18@@ = Number ; @@v17@@ = @@ptr@@ ; @@v15@@ = create_token_tree ( @@a1@@ , Number L , Number L , & @@v17@@ ) ; if ( @@v15@@ ) { if ( * ( int * ) ( @@a1@@ + Number ) <= Number ) { free_charset ( @@v14@@ ) ; return @@v15@@ ; } @@v18@@ = Number ; @@v17@@ = @@v14@@ ; * ( _BYTE * ) ( @@a1@@ + Number ) |= Number ; @@v16@@ = create_token_tree ( @@a1@@ , Number L , Number L , & @@v17@@ ) ; if ( @@v16@@ ) { @@v15@@ = create_tree ( @@a1@@ , @@v15@@ , @@v16@@ , Number L ) ; if ( @@v16@@ ) return @@v15@@ ; } } free ( @@ptr@@ ) ; free_charset ( @@v14@@ ) ; * @@a6@@ = Number ; return Number L ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
int __lxstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _lxstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall rpl_re_search_2 ( int @@a1@@ , int @@a2@@ , int @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ , __int64 @@a7@@ , __int64 @@a8@@ , __int64 @@a9@@ ) { return re_search_2_stub ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ , @@a7@@ , @@a8@@ , @@a9@@ , Number ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
int isatty ( int @@fd@@ ) { return isatty ( @@fd@@ ) ; }
__int64 __fastcall randint_choose ( __int64 @@a1@@ , __int64 @@a2@@ ) { return randint_genmax ( @@a1@@ , @@a2@@ - Number ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
wctype_t wctype ( const char * @@property@@ ) { return wctype ( @@property@@ ) ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
int iswalnum ( wint_t @@wc@@ ) { return iswalnum ( @@wc@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
wint_t btowc ( int @@c@@ ) { return btowc ( @@c@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
_QWORD * __fastcall rpl_re_set_registers ( __int64 @@a1@@ , _QWORD * @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ ) { _QWORD * @@result@@ ; if ( @@a3@@ ) { * ( _BYTE * ) ( @@a1@@ + Number ) = * ( _BYTE * ) ( @@a1@@ + Number ) & Number | Number ; * @@a2@@ = @@a3@@ ; @@a2@@ [ Number ] = @@a4@@ ; @@result@@ = @@a2@@ ; @@a2@@ [ Number ] = @@a5@@ ; } else { * ( _BYTE * ) ( @@a1@@ + Number ) &= Number ; * @@a2@@ = Number L ; @@a2@@ [ Number ] = Number L ; @@result@@ = @@a2@@ ; @@a2@@ [ Number ] = @@a2@@ [ Number ] ; } return @@result@@ ; }
size_t __fastcall fillpattern ( __int16 @@a1@@ , _BYTE * @@a2@@ , size_t @@a3@@ ) { size_t @@result@@ ; unsigned int @@v5@@ ; size_t @@n@@ ; size_t @@na@@ ; @@v5@@ = ( ( @@a1@@ & Number ) << Number ) | @@a1@@ & Number ; * @@a2@@ = @@v5@@ >> Number ; @@a2@@ [ Number ] = BYTE1 ( @@v5@@ ) ; @@a2@@ [ Number ] = @@a1@@ ; for ( @@n@@ = Number L ; @@n@@ < @@a3@@ >> Number ; @@n@@ *= Number L ) memcpy ( & @@a2@@ [ @@n@@ ] , @@a2@@ , @@n@@ ) ; if ( @@n@@ < @@a3@@ ) memcpy ( & @@a2@@ [ @@n@@ ] , @@a2@@ , @@a3@@ - @@n@@ ) ; @@result@@ = @@a1@@ & Number ; if ( ( @@a1@@ & Number ) != Number ) { for ( @@na@@ = Number L ; ; @@na@@ += Number L ) { @@result@@ = @@na@@ ; if ( @@na@@ >= @@a3@@ ) break ; @@a2@@ [ @@na@@ ] ^= Number ; } } return @@result@@ ; }
unsigned __int8 * __fastcall find_int ( unsigned __int8 * @@a1@@ ) { const unsigned __int16 * @@v1@@ ; unsigned __int8 * @@v2@@ ; const unsigned __int16 * @@v3@@ ; __int64 @@v5@@ ; char * @@v6@@ ; unsigned __int8 * @@i@@ ; unsigned __int8 * @@v8@@ ; unsigned __int8 * @@v9@@ ; unsigned __int8 * @@v10@@ ; for ( @@i@@ = @@a1@@ ; ; ++ @@i@@ ) { @@v1@@ = * __ctype_b_loc ( ) ; if ( ( @@v1@@ [ ( unsigned __int8 ) to_uchar ( * @@i@@ ) ] & Number ) == Number ) break ; } if ( * @@i@@ == Number ) { @@v8@@ = @@i@@ + Number ; @@v10@@ = @@v8@@ ; } else { @@v10@@ = @@i@@ ; @@v8@@ = & @@i@@ [ * @@i@@ == Number ] ; } @@v2@@ = @@v8@@ ; @@v9@@ = @@v8@@ + Number ; if ( ( unsigned int ) ( ( char ) * @@v2@@ - Number ) > Number ) goto LABEL_16 ; while ( ( unsigned int ) ( ( char ) * @@v9@@ - Number ) <= Number ) ++ @@v9@@ ; while ( Number ) { @@v3@@ = * __ctype_b_loc ( ) ; if ( ( @@v3@@ [ ( unsigned __int8 ) to_uchar ( * @@v9@@ ) ] & Number ) == Number ) break ; ++ @@v9@@ ; } if ( * @@v9@@ ) { LABEL_16 : @@v5@@ = quote ( @@a1@@ ) ; @@v6@@ = gettext ( String ) ; test_syntax_error ( @@v6@@ , @@v5@@ ) ; } return @@v10@@ ; }
__int64 __fastcall get_stat_mtime ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 __fastcall check_halt_state_context ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { char @@v4@@ ; unsigned __int64 @@i@@ ; @@v4@@ = re_string_context_at ( @@a1@@ , @@a3@@ , * ( _DWORD * ) ( @@a1@@ + Number ) ) ; for ( @@i@@ = Number L ; @@i@@ < * ( _QWORD * ) ( @@a2@@ + Number ) ; ++ @@i@@ ) { if ( check_halt_node_context ( * ( _QWORD * * ) ( @@a1@@ + Number ) , * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) , @@v4@@ ) ) { return * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) ; } } return Number L ; }
__int64 __fastcall wipefd ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , int @@a5@@ , int @@a6@@ ) { char * @@v6@@ ; int * @@v7@@ ; __int64 @@result@@ ; char * @@v9@@ ; int @@v12@@ ; @@v12@@ = rpl_fcntl ( @@a1@@ , Number , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( @@v12@@ >= Number ) { if ( ( @@v12@@ & Number ) != Number ) { @@v9@@ = gettext ( String ) ; error ( Number , Number , @@v9@@ , @@a2@@ ) ; @@result@@ = Number L ; } else { @@result@@ = do_wipefd ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; } } else { @@v6@@ = gettext ( String ) ; @@v7@@ = __errno_location ( ) ; error ( Number , * @@v7@@ , @@v6@@ , @@a2@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
void __fastcall __noreturn test_syntax_error ( const char * @@a1@@ , __int64 @@a2@@ ) { fprintf ( stderr , String , * ( const char * * ) argv ) ; fprintf ( stderr , @@a1@@ , @@a2@@ ) ; fputc_unlocked ( Number , stderr ) ; fflush_unlocked ( stderr ) ; exit ( Number ) ; }
__int64 * __fastcall mpz_mul ( __int64 * @@a1@@ , __int64 * @@a2@@ , __int64 * @@a3@@ ) { __int64 * @@result@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; @@v4@@ = * @@a2@@ ; @@v5@@ = * @@a3@@ ; @@v6@@ = * @@a3@@ * * @@a2@@ ; if ( * @@a2@@ && @@v5@@ && ( @@v6@@ < Number != ( ( @@v4@@ < Number ) ^ ( @@v5@@ < Number ) ) || @@v5@@ != @@v6@@ / @@v4@@ ) ) { integer_overflow ( Number L ) ; } @@result@@ = @@a1@@ ; * @@a1@@ = @@v6@@ ; return @@result@@ ; }
_QWORD * __fastcall randint_new ( __int64 @@a1@@ ) { _QWORD * @@result@@ ; @@result@@ = ( _QWORD * ) xmalloc ( Number L ) ; * @@result@@ = @@a1@@ ; @@result@@ [ Number ] = Number L ; @@result@@ [ Number ] = @@result@@ [ Number ] ; return @@result@@ ; }
__int64 __fastcall free_fail_stack_return ( __int64 @@a1@@ ) { unsigned __int64 @@i@@ ; if ( @@a1@@ ) { for ( @@i@@ = Number L ; @@i@@ < * ( _QWORD * ) @@a1@@ ; ++ @@i@@ ) { free ( * ( void * * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@i@@ + Number ) ) ; free ( * ( void * * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@i@@ + Number ) ) ; } free ( * ( void * * ) ( @@a1@@ + Number ) ) ; } return Number L ; }
__int64 __fastcall randint_get_source ( __int64 @@a1@@ ) { return * ( _QWORD * ) @@a1@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
_BOOL8 __fastcall get_mtime ( char * @@a1@@ , __int64 * @@a2@@ ) { int @@v2@@ ; __int64 @@v3@@ ; bool @@v5@@ ; struct stat @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v2@@ = stat ( @@a1@@ , & @@v6@@ ) ; @@v5@@ = @@v2@@ == Number ; if ( ! @@v2@@ ) { * @@a2@@ = get_stat_mtime ( ( __int64 ) & @@v6@@ ) ; @@a2@@ [ Number ] = @@v3@@ ; } return @@v5@@ ; }
__int64 __fastcall shift_left ( __int64 @@a1@@ ) { return @@a1@@ << Number ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
__int64 __fastcall clean_state_log_if_needed ( _QWORD * @@a1@@ , unsigned __int64 @@a2@@ ) { unsigned int @@v3@@ ; unsigned __int64 @@v4@@ ; @@v4@@ = @@a1@@ [ Number ] ; if ( @@a2@@ >= @@a1@@ [ Number ] || @@a2@@ >= @@a1@@ [ Number ] && @@a1@@ [ Number ] < @@a1@@ [ Number ] ) { @@v3@@ = extend_buffers ( @@a1@@ ) ; if ( @@v3@@ ) return @@v3@@ ; } if ( @@v4@@ < @@a2@@ ) { memset ( ( void * ) ( Number * ( @@v4@@ + Number ) + @@a1@@ [ Number ] ) , Number , Number * ( @@a2@@ - @@v4@@ ) ) ; @@a1@@ [ Number ] = @@a2@@ ; } return Number L ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; FILE * @@v10@@ ; char * @@v11@@ ; FILE * @@v12@@ ; char * @@v13@@ ; FILE * @@v14@@ ; char * @@v15@@ ; FILE * @@v16@@ ; char * @@v17@@ ; FILE * @@v18@@ ; char * @@v19@@ ; FILE * @@v20@@ ; char * @@v21@@ ; FILE * @@v22@@ ; char * @@v23@@ ; FILE * @@v24@@ ; char * @@v25@@ ; if ( @@a1@@ ) { @@v1@@ = program_name ; @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = program_name ; @@v4@@ = program_name ; @@v5@@ = gettext ( String ) ; printf ( @@v5@@ , @@v4@@ , @@v3@@ ) ; putchar_unlocked ( Number ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; @@v8@@ = stdout ; @@v9@@ = gettext ( String ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = stdout ; @@v11@@ = gettext ( String String String String String String String ) ; fputs_unlocked ( @@v11@@ , @@v10@@ ) ; @@v12@@ = stdout ; @@v13@@ = gettext ( String String String String String String String ) ; fputs_unlocked ( @@v13@@ , @@v12@@ ) ; @@v14@@ = stdout ; @@v15@@ = gettext ( String String String ) ; fputs_unlocked ( @@v15@@ , @@v14@@ ) ; @@v16@@ = stdout ; @@v17@@ = gettext ( String String String String ) ; fputs_unlocked ( @@v17@@ , @@v16@@ ) ; @@v18@@ = stdout ; @@v19@@ = gettext ( String String String String String String String ) ; fputs_unlocked ( @@v19@@ , @@v18@@ ) ; @@v20@@ = stdout ; @@v21@@ = gettext ( String String String String ) ; fputs_unlocked ( @@v21@@ , @@v20@@ ) ; @@v22@@ = stdout ; @@v23@@ = gettext ( String String String String String ) ; fputs_unlocked ( @@v23@@ , @@v22@@ ) ; @@v24@@ = stdout ; @@v25@@ = gettext ( String String String ) ; fputs_unlocked ( @@v25@@ , @@v24@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
unsigned __int64 __fastcall randint_genmax ( __int64 * @@a1@@ , unsigned __int64 @@a2@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; char @@v11@@ [ Number ] ; unsigned __int64 @@v12@@ ; @@v12@@ = __readfsqword ( Number ) ; @@v8@@ = * @@a1@@ ; @@v3@@ = @@a1@@ [ Number ] ; @@v4@@ = @@a1@@ [ Number ] ; @@v9@@ = @@a2@@ + Number ; while ( Number ) { if ( @@v4@@ < @@a2@@ ) { @@v5@@ = Number L ; @@v7@@ = @@v4@@ ; do { @@v7@@ = shift_left ( @@v7@@ ) + Number ; ++ @@v5@@ ; } while ( @@v7@@ < @@a2@@ ) ; randread ( @@v8@@ , @@v11@@ , @@v5@@ ) ; @@v6@@ = Number L ; do { @@v3@@ = shift_left ( @@v3@@ ) + ( unsigned __int8 ) @@v11@@ [ @@v6@@ ] ; @@v4@@ = shift_left ( @@v4@@ ) + Number ; ++ @@v6@@ ; } while ( @@v4@@ < @@a2@@ ) ; } if ( @@v4@@ == @@a2@@ ) { @@a1@@ [ Number ] = Number L ; @@a1@@ [ Number ] = @@a1@@ [ Number ] ; return @@v3@@ ; } @@v10@@ = ( @@v4@@ - @@a2@@ ) % @@v9@@ ; if ( @@v3@@ <= @@v4@@ - @@v10@@ ) break ; @@v3@@ %= @@v9@@ ; @@v4@@ = @@v10@@ - Number ; } @@a1@@ [ Number ] = @@v3@@ / @@v9@@ ; @@a1@@ [ Number ] = ( @@v4@@ - @@a2@@ ) / @@v9@@ ; return @@v3@@ % @@v9@@ ; }
__int64 __fastcall update_cur_sifted_state ( _QWORD * @@a1@@ , _QWORD * @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ ) { __int64 @@v4@@ ; __int64 @@result@@ ; _QWORD * @@v6@@ ; unsigned int @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; unsigned __int64 @@v12@@ ; @@v12@@ = __readfsqword ( Number ) ; @@v10@@ = @@a1@@ [ Number ] ; @@v9@@ = Number ; if ( * ( _QWORD * ) ( Number * @@a3@@ + @@a1@@ [ Number ] ) ) @@v4@@ = * ( _QWORD * ) ( Number * @@a3@@ + @@a1@@ [ Number ] ) + Number L ; else @@v4@@ = Number L ; @@v11@@ = @@v4@@ ; if ( * ( _QWORD * ) ( @@a4@@ + Number ) ) { if ( @@v11@@ ) { @@v9@@ = add_epsilon_src_nodes ( @@v10@@ , @@a4@@ , @@v11@@ ) ; if ( @@v9@@ ) return @@v9@@ ; if ( @@a2@@ [ Number ] ) { @@v9@@ = check_subexp_limits ( @@v10@@ , @@a4@@ , @@v11@@ , @@a2@@ + Number , @@a1@@ [ Number ] , @@a3@@ ) ; if ( @@v9@@ ) return @@v9@@ ; } } @@v6@@ = ( _QWORD * ) ( * @@a2@@ + Number * @@a3@@ ) ; * @@v6@@ = re_acquire_state ( & @@v9@@ , @@v10@@ , @@a4@@ ) ; if ( @@v9@@ ) return @@v9@@ ; } else { * ( _QWORD * ) ( Number * @@a3@@ + * @@a2@@ ) = Number L ; } if ( @@v11@@ && ( * ( _BYTE * ) ( * ( _QWORD * ) ( Number * @@a3@@ + @@a1@@ [ Number ] ) + Number L ) & Number ) != Number && ( @@v9@@ = sift_states_bkref ( @@a1@@ , @@a2@@ , @@a3@@ , @@v11@@ ) ) != Number ) { @@result@@ = @@v9@@ ; } else { @@result@@ = Number L ; } return @@result@@ ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; FILE * @@v11@@ ; char * @@v12@@ ; FILE * @@v13@@ ; char * @@v14@@ ; FILE * @@v15@@ ; char * @@v16@@ ; FILE * @@v17@@ ; char * @@v18@@ ; FILE * @@v19@@ ; char * @@v20@@ ; FILE * @@v21@@ ; char * @@v22@@ ; FILE * @@v23@@ ; char * @@v24@@ ; FILE * @@v25@@ ; char * @@v26@@ ; FILE * @@v27@@ ; char * @@v28@@ ; FILE * @@v29@@ ; char * @@v30@@ ; FILE * @@v31@@ ; char * @@v32@@ ; char * @@v33@@ ; char * @@v34@@ ; if ( @@a1@@ ) { @@v1@@ = program_name ; @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = gettext ( String ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = stdout ; @@v8@@ = gettext ( String ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = stdout ; @@v10@@ = gettext ( String ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; @@v11@@ = stdout ; @@v12@@ = gettext ( String String String ) ; fputs_unlocked ( @@v12@@ , @@v11@@ ) ; @@v13@@ = stdout ; @@v14@@ = gettext ( String String String String String ) ; fputs_unlocked ( @@v14@@ , @@v13@@ ) ; @@v15@@ = stdout ; @@v16@@ = gettext ( String String String String String String ) ; fputs_unlocked ( @@v16@@ , @@v15@@ ) ; @@v17@@ = stdout ; @@v18@@ = gettext ( String String String String String String String ) ; fputs_unlocked ( @@v18@@ , @@v17@@ ) ; @@v19@@ = stdout ; @@v20@@ = gettext ( String String String String ) ; fputs_unlocked ( @@v20@@ , @@v19@@ ) ; @@v21@@ = stdout ; @@v22@@ = gettext ( String String String String String ) ; fputs_unlocked ( @@v22@@ , @@v21@@ ) ; @@v23@@ = stdout ; @@v24@@ = gettext ( String String String String String ) ; fputs_unlocked ( @@v24@@ , @@v23@@ ) ; @@v25@@ = stdout ; @@v26@@ = gettext ( String String String String String ) ; fputs_unlocked ( @@v26@@ , @@v25@@ ) ; @@v27@@ = stdout ; @@v28@@ = gettext ( String String String String String ) ; fputs_unlocked ( @@v28@@ , @@v27@@ ) ; @@v29@@ = stdout ; @@v30@@ = gettext ( String String String String ) ; fputs_unlocked ( @@v30@@ , @@v29@@ ) ; @@v31@@ = stdout ; @@v32@@ = gettext ( String String String ) ; fputs_unlocked ( @@v32@@ , @@v31@@ ) ; @@v33@@ = gettext ( String ) ; @@v34@@ = gettext ( String String String String ) ; printf ( @@v34@@ , @@v33@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
void * * __fastcall eval3 ( unsigned __int8 @@a1@@ ) { char * @@v2@@ ; int @@v3@@ $15114BBF10992532484F7C0F379D99C4 ; void * * @@v4@@ ; void * * @@v5@@ ; @@v4@@ = eval4 ( @@a1@@ ) ; while ( Number ) { if ( nextarg ( ( const char * ) & asc_1D374 [ Number ] ) ) { @@v3@@ $15114BBF10992532484F7C0F379D99C4 = Number ; goto LABEL_7 ; } if ( ! nextarg ( String ) ) return @@v4@@ ; @@v3@@ $15114BBF10992532484F7C0F379D99C4 = Number ; LABEL_7 : @@v5@@ = eval4 ( @@a1@@ ) ; if ( @@a1@@ ) { if ( ( unsigned __int8 ) toarith ( ( __int64 ) @@v4@@ ) != Number || ( unsigned __int8 ) toarith ( ( __int64 ) @@v5@@ ) != Number ) { @@v2@@ = gettext ( String ) ; error ( Number , Number , @@v2@@ ) ; } if ( @@v3@@ $15114BBF10992532484F7C0F379D99C4 ) mpz_sub ( @@v4@@ + Number , @@v4@@ + Number , ( __int64 * ) @@v5@@ + Number ) ; else mpz_add ( @@v4@@ + Number , @@v4@@ + Number , ( __int64 * ) @@v5@@ + Number ) ; } freev ( @@v5@@ ) ; } }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
__int64 __fastcall sift_states_iter_mb ( __int64 @@a1@@ , _QWORD * @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned __int64 @@a5@@ ) { int @@v9@@ ; __int64 @@v10@@ ; @@v10@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v9@@ = check_node_accept_bytes ( @@v10@@ , @@a3@@ , @@a1@@ , @@a4@@ ) ; if ( @@v9@@ > Number && @@a5@@ >= @@v9@@ + @@a4@@ && ( ! * ( _QWORD * ) ( Number * ( @@v9@@ + @@a4@@ ) + * @@a2@@ ) || ! re_node_set_contains ( * ( _QWORD * ) ( Number * ( @@v9@@ + @@a4@@ ) + * @@a2@@ ) + Number L , * ( _QWORD * ) ( Number * @@a3@@ + * ( _QWORD * ) ( @@v10@@ + Number ) ) ) ) ) { @@v9@@ = Number ; } return ( unsigned int ) @@v9@@ ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_20A0A8 ; @@v8@@ [ Number ] = qword_20A0B0 ; @@v8@@ [ Number ] = qword_20A0B8 ; @@v8@@ [ Number ] = qword_20A0C0 ; @@v8@@ [ Number ] = qword_20A0C8 ; @@v8@@ [ Number ] = qword_20A0D0 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( is_mul_ok ( @@a2@@ , * @@a1@@ ) ) { * @@a1@@ *= @@a2@@ ; @@result@@ = Number L ; } else { * @@a1@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 __fastcall find_recover_state ( _DWORD * @@a1@@ , _QWORD * @@a2@@ ) { __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; __int64 @@v5@@ ; do { @@v4@@ = @@a2@@ [ Number ] ; @@v3@@ = @@a2@@ [ Number ] ; do { if ( ++ @@v3@@ > @@v4@@ ) return Number L ; ++ @@a2@@ [ Number ] ; } while ( ! * ( _QWORD * ) ( Number * @@v3@@ + @@a2@@ [ Number ] ) ) ; @@v5@@ = merge_state_with_log ( @@a1@@ , ( __int64 ) @@a2@@ , Number L ) ; } while ( ! * @@a1@@ && ! @@v5@@ ) ; return @@v5@@ ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
__int64 __fastcall bkm_scale_by_power ( unsigned __int64 * @@a1@@ , int @@a2@@ , int @@a3@@ ) { unsigned int @@i@@ ; for ( @@i@@ = Number ; @@a3@@ -- ; @@i@@ |= bkm_scale ( @@a1@@ , @@a2@@ ) ) ; return @@i@@ ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_20A028 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
__int64 __fastcall get_subexp_sub ( _QWORD * @@a1@@ , _QWORD * @@a2@@ , _QWORD * @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ ) { __int64 @@result@@ ; unsigned int @@v9@@ ; unsigned int @@v10@@ ; @@v9@@ = check_arrival ( ( _DWORD ) @@a1@@ , ( int ) @@a3@@ + Number , * @@a3@@ , @@a3@@ [ Number ] , @@a4@@ , @@a5@@ , Number ) ; if ( @@v9@@ ) return @@v9@@ ; @@v10@@ = match_ctx_add_entry ( @@a1@@ , @@a4@@ , @@a5@@ , * @@a2@@ , @@a3@@ [ Number ] ) ; if ( @@v10@@ ) @@result@@ = @@v10@@ ; else @@result@@ = clean_state_log_if_needed ( @@a1@@ , @@a5@@ + @@a3@@ [ Number ] - * @@a2@@ ) ; return @@result@@ ; }
__int64 __fastcall fraccompare ( _BYTE * @@a1@@ , _BYTE * @@a2@@ , char @@a3@@ ) { _BYTE * @@v4@@ ; _BYTE * @@v5@@ ; @@v5@@ = @@a1@@ ; @@v4@@ = @@a2@@ ; if ( @@a3@@ == * @@a1@@ && @@a3@@ == * @@a2@@ ) { while ( * ++ @@v5@@ == * ++ @@v4@@ ) { if ( ( unsigned int ) ( ( char ) * @@v5@@ - Number ) > Number ) return Number L ; } if ( ( unsigned int ) ( ( char ) * @@v5@@ - Number ) <= Number && ( unsigned int ) ( ( char ) * @@v4@@ - Number ) <= Number ) { return ( unsigned int ) ( ( char ) * @@v5@@ - ( char ) * @@v4@@ ) ; } if ( ( unsigned int ) ( ( char ) * @@v5@@ - Number ) > Number ) { if ( ( unsigned int ) ( ( char ) * @@v4@@ - Number ) > Number ) return Number L ; LABEL_23 : while ( * @@v4@@ == Number ) ++ @@v4@@ ; return ( unsigned int ) - ( ( unsigned int ) ( ( char ) * @@v4@@ - Number ) <= Number ) ; } } else { @@v5@@ = @@a1@@ + Number ; if ( @@a3@@ != * @@a1@@ ) { @@v4@@ = @@a2@@ + Number ; if ( @@a3@@ != * @@a2@@ ) return Number L ; goto LABEL_23 ; } } while ( * @@v5@@ == Number ) ++ @@v5@@ ; return ( unsigned int ) ( ( char ) * @@v5@@ - Number ) <= Number ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
__int64 __fastcall send_signals ( int @@a1@@ , char * * @@a2@@ ) { char * @@v2@@ ; int * @@v3@@ ; char * * @@v5@@ ; unsigned int @@v6@@ ; __pid_t @@pid@@ ; char * @@endptr@@ ; char * @@nptr@@ ; intmax_t @@v10@@ ; unsigned __int64 @@v11@@ ; @@v5@@ = @@a2@@ ; @@v11@@ = __readfsqword ( Number ) ; @@v6@@ = Number ; @@nptr@@ = * @@a2@@ ; do { * __errno_location ( ) = Number ; @@v10@@ = strtoimax ( @@nptr@@ , & @@endptr@@ , Number ) ; @@pid@@ = @@v10@@ ; if ( * __errno_location ( ) == Number || @@v10@@ != @@pid@@ || @@nptr@@ == @@endptr@@ || * @@endptr@@ ) { @@v2@@ = gettext ( String ) ; error ( Number , Number , @@v2@@ , @@nptr@@ ) ; @@v6@@ = Number ; } else if ( kill ( @@pid@@ , @@a1@@ ) ) { @@v3@@ = __errno_location ( ) ; error ( Number , * @@v3@@ , String , @@nptr@@ ) ; @@v6@@ = Number ; } @@nptr@@ = * ++ @@v5@@ ; } while ( @@nptr@@ ) ; return @@v6@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall check_arrival_add_next_nodes ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ ) { _QWORD * @@v5@@ ; unsigned int @@v8@@ ; int @@v9@@ ; unsigned __int64 @@i@@ ; _QWORD * @@v11@@ ; __int64 @@v12@@ ; unsigned __int64 @@v13@@ ; __int64 @@v14@@ ; __int64 @@v15@@ ; char @@s@@ [ Number ] ; __int64 @@v17@@ ; void * @@ptr@@ ; unsigned __int64 @@v19@@ ; @@v19@@ = __readfsqword ( Number ) ; @@v11@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; @@v8@@ = Number ; memset ( @@s@@ , Number , Number ) ; for ( @@i@@ = Number L ; @@i@@ < * ( _QWORD * ) ( @@a3@@ + Number ) ; ++ @@i@@ ) { @@v9@@ = Number ; @@v12@@ = * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a3@@ + Number ) ) ; if ( ( * ( _BYTE * ) ( Number * @@v12@@ + * @@v11@@ + Number ) & Number ) != Number ) { @@v9@@ = check_node_accept_bytes ( @@v11@@ , @@v12@@ , @@a1@@ , @@a2@@ ) ; if ( @@v9@@ > Number ) { @@v13@@ = * ( _QWORD * ) ( Number * @@v12@@ + @@v11@@ [ Number ] ) ; @@v14@@ = @@v9@@ + @@a2@@ ; @@v15@@ = * ( _QWORD * ) ( Number * @@v14@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) ; @@v17@@ = Number L ; if ( @@v15@@ ) { @@v8@@ = re_node_set_merge ( ( __int64 ) @@s@@ , @@v15@@ + Number ) ; if ( @@v8@@ ) goto LABEL_6 ; } if ( ! re_node_set_insert ( ( __int64 ) @@s@@ , @@v13@@ ) ) goto LABEL_8 ; @@v5@@ = ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@v14@@ ) ; * @@v5@@ = re_acquire_state ( & @@v8@@ , ( __int64 ) @@v11@@ , ( __int64 ) @@s@@ ) ; if ( ! * ( _QWORD * ) ( Number * @@v14@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) ) { if ( @@v8@@ ) { LABEL_6 : free ( @@ptr@@ ) ; return @@v8@@ ; } } } } if ( ( @@v9@@ || ( unsigned __int8 ) check_node_accept ( @@a1@@ , * @@v11@@ + Number * @@v12@@ , @@a2@@ ) ) && ! re_node_set_insert ( @@a4@@ , * ( _QWORD * ) ( Number * @@v12@@ + @@v11@@ [ Number ] ) ) ) { LABEL_8 : free ( @@ptr@@ ) ; return Number L ; } } free ( @@ptr@@ ) ; return Number L ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
void * __fastcall mdir_name ( _BYTE * @@a1@@ ) { _BYTE * @@n@@ ; void * @@dest@@ ; @@n@@ = dir_len ( @@a1@@ ) ; @@dest@@ = malloc ( ( size_t ) & @@n@@ [ ( @@n@@ == Number L ) + Number ] ) ; if ( ! @@dest@@ ) return Number L ; memcpy ( @@dest@@ , @@a1@@ , ( size_t ) @@n@@ ) ; if ( ! @@n@@ ) { @@n@@ = ( _BYTE * ) ( & dword_0 + Number ) ; * ( _BYTE * ) @@dest@@ = Number ; } @@n@@ [ ( _QWORD ) @@dest@@ ] = Number ; return @@dest@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 default_block_size ( ) { __int64 @@result@@ ; if ( getenv ( String ) ) @@result@@ = Number L ; else @@result@@ = Number L ; return @@result@@ ; }
_QWORD * __fastcall match_ctx_clean ( _QWORD * @@a1@@ ) { _QWORD * @@result@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@j@@ ; void * @@v4@@ ; void * * @@ptr@@ ; for ( @@i@@ = Number L ; @@i@@ < @@a1@@ [ Number ] ; ++ @@i@@ ) { @@v4@@ = * ( void * * ) ( Number * @@i@@ + @@a1@@ [ Number ] ) ; for ( @@j@@ = Number L ; @@j@@ < * ( ( _QWORD * ) @@v4@@ + Number ) ; ++ @@j@@ ) { @@ptr@@ = * ( void * * * ) ( Number * @@j@@ + * ( ( _QWORD * ) @@v4@@ + Number ) ) ; free ( @@ptr@@ [ Number ] ) ; free ( @@ptr@@ ) ; } free ( * ( ( void * * ) @@v4@@ + Number ) ) ; if ( * ( ( _QWORD * ) @@v4@@ + Number ) ) { free ( * ( void * * ) ( * ( ( _QWORD * ) @@v4@@ + Number ) + Number L ) ) ; free ( * ( ( void * * ) @@v4@@ + Number ) ) ; } free ( @@v4@@ ) ; } @@a1@@ [ Number ] = Number L ; @@result@@ = @@a1@@ ; @@a1@@ [ Number ] = Number L ; return @@result@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
__int64 __fastcall humblock ( char * @@a1@@ , uintmax_t * @@a2@@ , int * @@a3@@ ) { char * @@v5@@ ; int @@v6@@ ; int @@v7@@ ; unsigned int @@v8@@ ; char * @@v9@@ [ Number ] ; @@v5@@ = @@a1@@ ; @@v9@@ [ Number ] = ( char * ) __readfsqword ( Number ) ; @@v6@@ = Number ; if ( @@a1@@ || ( @@v5@@ = getenv ( String ) ) != Number L || ( @@v5@@ = getenv ( String ) ) != Number L ) { if ( * @@v5@@ == Number ) { @@v6@@ = Number ; ++ @@v5@@ ; } @@v7@@ = argmatch ( @@v5@@ , & block_size_args , block_size_opts , Number L ) ; if ( @@v7@@ < Number ) { @@v8@@ = xstrtoumax ( @@v5@@ , @@v9@@ , Number , @@a2@@ , String ) ; if ( @@v8@@ ) { * @@a3@@ = Number ; return @@v8@@ ; } while ( * @@v5@@ <= Number || * @@v5@@ > Number ) { if ( @@v5@@ == @@v9@@ [ Number ] ) { @@v6@@ |= Number ; if ( * ( @@v9@@ [ Number ] - Number ) == Number ) @@v6@@ |= Number ; if ( * ( @@v9@@ [ Number ] - Number ) != Number || * ( @@v9@@ [ Number ] - Number ) == Number ) @@v6@@ |= Number ; break ; } ++ @@v5@@ ; } } else { @@v6@@ |= block_size_opts [ @@v7@@ ] ; * @@a2@@ = Number L ; } } else { * @@a2@@ = default_block_size ( ) ; } * @@a3@@ = @@v6@@ ; return Number L ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ ) { return xmalloc ( @@a1@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
void * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * @@v4@@ ; void * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * @@v12@@ ; void * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == ( __int64 * ) & slotvec0 ; if ( slotvec == ( __int64 * ) & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = off_20D028 ; * @@v12@@ = ( __int64 ) slotvec0 ; @@v12@@ [ Number ] = ( __int64 ) @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = ( void * ) @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = @@v17@@ + Number ; if ( @@ptr@@ != & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( void * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = ( __int64 ) @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
__int64 __fastcall argmatch_to_argument ( const void * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; ++ @@i@@ ) { if ( ! memcmp ( @@a1@@ , ( const void * ) ( @@i@@ * @@a4@@ + @@a3@@ ) , @@a4@@ ) ) return * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; } return Number L ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall re_string_wchar_at ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; if ( * ( _DWORD * ) ( @@a1@@ + Number ) == Number ) @@result@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ ) ; else @@result@@ = * ( unsigned int * ) ( Number * @@a2@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) ; return @@result@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall fd_safer ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , __m128 @@a7@@ , __m128 @@a8@@ , __m128 @@a9@@ , __m128 @@a10@@ , __m128 @@a11@@ , __m128 @@a12@@ , __m128 @@a13@@ , __m128 @@a14@@ ) { unsigned int @@fd@@ ; unsigned int @@v16@@ ; int @@v17@@ ; @@fd@@ = @@a1@@ ; if ( @@a1@@ >= Number && @@a1@@ <= Number ) { @@v16@@ = dup_safer ( @@a1@@ , @@a7@@ , @@a8@@ , @@a9@@ , @@a10@@ , @@a11@@ , @@a12@@ , @@a13@@ , @@a14@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; @@v17@@ = * __errno_location ( ) ; close ( @@a1@@ ) ; * __errno_location ( ) = @@v17@@ ; @@fd@@ = @@v16@@ ; } return @@fd@@ ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
__int64 __fastcall re_string_realloc_buffers ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { void * @@v3@@ ; void * @@v4@@ ; void * @@v5@@ ; if ( * ( int * ) ( @@a1@@ + Number ) > Number ) { if ( ! is_mul_ok ( Number , @@a2@@ ) ) return Number L ; @@v3@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number * @@a2@@ ) ; if ( ! @@v3@@ ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v3@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) { @@v4@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number * @@a2@@ ) ; if ( ! @@v4@@ ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v4@@ ; } } if ( * ( _BYTE * ) ( @@a1@@ + Number ) ) { @@v5@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , @@a2@@ ) ; if ( ! @@v5@@ ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v5@@ ; } * ( _QWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; return Number L ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
_BOOL8 __fastcall binop ( const char * @@a1@@ ) { return ! strcmp ( @@a1@@ , String ) || ! strcmp ( @@a1@@ , String ) || ! strcmp ( @@a1@@ , String ) || ! strcmp ( @@a1@@ , String ) || ! strcmp ( @@a1@@ , String ) || ! strcmp ( @@a1@@ , String ) || ! strcmp ( @@a1@@ , String ) || ! strcmp ( @@a1@@ , String ) || ! strcmp ( @@a1@@ , String ) || ! strcmp ( @@a1@@ , String ) || ! strcmp ( @@a1@@ , String ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
int puts ( const char * @@s@@ ) { return puts ( @@s@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
_QWORD * __fastcall build_upper_buffer ( _QWORD * @@a1@@ ) { unsigned __int64 @@v1@@ ; _QWORD * @@result@@ ; int @@c@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@v5@@ ; @@v1@@ = @@a1@@ [ Number ] ; if ( @@a1@@ [ Number ] <= @@v1@@ ) @@v1@@ = @@a1@@ [ Number ] ; @@v5@@ = @@v1@@ ; for ( @@i@@ = @@a1@@ [ Number ] ; @@i@@ < @@v5@@ ; ++ @@i@@ ) { @@c@@ = * ( unsigned __int8 * ) ( * @@a1@@ + @@a1@@ [ Number ] + @@i@@ ) ; if ( @@a1@@ [ Number ] ) @@c@@ = * ( unsigned __int8 * ) ( @@a1@@ [ Number ] + * ( unsigned __int8 * ) ( * @@a1@@ + @@a1@@ [ Number ] + @@i@@ ) ) ; if ( ( ( * __ctype_b_loc ( ) ) [ @@c@@ ] & Number ) != Number ) * ( _BYTE * ) ( @@a1@@ [ Number ] + @@i@@ ) = toupper ( @@c@@ ) ; else * ( _BYTE * ) ( @@a1@@ [ Number ] + @@i@@ ) = @@c@@ ; } @@a1@@ [ Number ] = @@i@@ ; @@result@@ = @@a1@@ ; @@a1@@ [ Number ] = @@i@@ ; return @@result@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
__int64 __fastcall str2signum ( const char * @@a1@@ ) { unsigned int @@i@@ ; int @@v3@@ ; int @@v4@@ ; char * @@endptr@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; if ( ( unsigned int ) ( * @@a1@@ - Number ) > Number ) { for ( @@i@@ = Number ; @@i@@ <= Number ; ++ @@i@@ ) { if ( ! strcmp ( ( const char * ) & numname_table + Number * @@i@@ + Number , @@a1@@ ) ) return * ( ( unsigned int * ) & numname_table + Number * @@i@@ ) ; } @@v3@@ = __libc_current_sigrtmin ( ) ; @@v4@@ = __libc_current_sigrtmax ( ) ; if ( @@v3@@ > Number && ! strncmp ( @@a1@@ , String , Number ) ) { @@v6@@ = strtol ( @@a1@@ + Number , & @@endptr@@ , Number ) ; if ( ! * @@endptr@@ && @@v6@@ >= Number && @@v6@@ <= @@v4@@ - @@v3@@ ) { return ( unsigned int ) ( @@v6@@ + @@v3@@ ) ; } } else if ( @@v4@@ > Number && ! strncmp ( @@a1@@ , String , Number ) ) { @@v7@@ = strtol ( @@a1@@ + Number , & @@endptr@@ , Number ) ; if ( ! * @@endptr@@ && @@v7@@ >= @@v3@@ - @@v4@@ && @@v7@@ <= Number ) { return ( unsigned int ) ( @@v7@@ + @@v4@@ ) ; } } } else { @@v8@@ = strtol ( @@a1@@ , & @@endptr@@ , Number ) ; if ( ! * @@endptr@@ && @@v8@@ <= Number ) return @@v8@@ ; } return Number ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; FILE * @@v11@@ ; char * @@v12@@ ; FILE * @@v13@@ ; char * @@v14@@ ; FILE * @@v15@@ ; char * @@v16@@ ; FILE * @@v17@@ ; char * @@v18@@ ; char * @@v19@@ ; if ( @@a1@@ ) { @@v1@@ = program_name ; @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = program_name ; @@v4@@ = program_name ; @@v5@@ = program_name ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ , @@v4@@ , @@v3@@ ) ; @@v7@@ = stdout ; @@v8@@ = gettext ( String ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = stdout ; @@v10@@ = gettext ( String ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; @@v11@@ = stdout ; @@v12@@ = gettext ( String String String String ) ; fputs_unlocked ( @@v12@@ , @@v11@@ ) ; @@v13@@ = stdout ; @@v14@@ = gettext ( String ) ; fputs_unlocked ( @@v14@@ , @@v13@@ ) ; @@v15@@ = stdout ; @@v16@@ = gettext ( String ) ; fputs_unlocked ( @@v16@@ , @@v15@@ ) ; @@v17@@ = stdout ; @@v18@@ = gettext ( String String String String ) ; fputs_unlocked ( @@v18@@ , @@v17@@ ) ; @@v19@@ = gettext ( String String String String ) ; printf ( @@v19@@ , String ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; char * @@v3@@ ; FILE * @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; FILE * @@v11@@ ; char * @@v12@@ ; FILE * @@v13@@ ; char * @@v14@@ ; FILE * @@v15@@ ; char * @@v16@@ ; FILE * @@v17@@ ; char * @@v18@@ ; FILE * @@v19@@ ; char * @@v20@@ ; FILE * @@v21@@ ; char * @@v22@@ ; FILE * @@v23@@ ; char * @@v24@@ ; FILE * @@v25@@ ; char * @@v26@@ ; @@v1@@ = program_name ; if ( @@a1@@ ) { @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = gettext ( String ) ; printf ( @@v3@@ , @@v1@@ ) ; @@v4@@ = stdout ; @@v5@@ = gettext ( String String String ) ; fputs_unlocked ( @@v5@@ , @@v4@@ ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; @@v8@@ = gettext ( String String String String ) ; printf ( @@v8@@ , Number L ) ; @@v9@@ = stdout ; @@v10@@ = gettext ( String String String String String ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; @@v11@@ = stdout ; @@v12@@ = gettext ( String ) ; fputs_unlocked ( @@v12@@ , @@v11@@ ) ; @@v13@@ = stdout ; @@v14@@ = gettext ( String ) ; fputs_unlocked ( @@v14@@ , @@v13@@ ) ; @@v15@@ = stdout ; @@v16@@ = gettext ( String String String String String String String String ) ; fputs_unlocked ( @@v16@@ , @@v15@@ ) ; @@v17@@ = stdout ; @@v18@@ = gettext ( String String String String String String ) ; fputs_unlocked ( @@v18@@ , @@v17@@ ) ; @@v19@@ = stdout ; @@v20@@ = gettext ( String String String String String String String String ) ; fputs_unlocked ( @@v20@@ , @@v19@@ ) ; @@v21@@ = stdout ; @@v22@@ = gettext ( String String String String String ) ; fputs_unlocked ( @@v22@@ , @@v21@@ ) ; @@v23@@ = stdout ; @@v24@@ = gettext ( String String String String String String String String ) ; fputs_unlocked ( @@v24@@ , @@v23@@ ) ; @@v25@@ = stdout ; @@v26@@ = gettext ( String String String ) ; fputs_unlocked ( @@v26@@ , @@v25@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
__int64 __fastcall re_node_set_init_2 ( _QWORD * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { * @@a1@@ = Number L ; @@a1@@ [ Number ] = malloc ( Number ) ; if ( ! @@a1@@ [ Number ] ) return Number L ; if ( @@a2@@ == @@a3@@ ) { @@a1@@ [ Number ] = Number L ; * ( _QWORD * ) @@a1@@ [ Number ] = @@a2@@ ; } else { @@a1@@ [ Number ] = Number L ; if ( @@a2@@ >= @@a3@@ ) { * ( _QWORD * ) @@a1@@ [ Number ] = @@a3@@ ; * ( _QWORD * ) ( @@a1@@ [ Number ] + Number L ) = @@a2@@ ; } else { * ( _QWORD * ) @@a1@@ [ Number ] = @@a2@@ ; * ( _QWORD * ) ( @@a1@@ [ Number ] + Number L ) = @@a3@@ ; } } return Number L ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
_QWORD * __fastcall randint_all_new ( __int64 @@a1@@ , __int64 @@a2@@ ) { _QWORD * @@result@@ ; __int64 @@v3@@ ; @@v3@@ = randread_new ( @@a1@@ , @@a2@@ ) ; if ( @@v3@@ ) @@result@@ = randint_new ( @@v3@@ ) ; else @@result@@ = Number L ; return @@result@@ ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
int raise ( int @@sig@@ ) { return raise ( @@sig@@ ) ; }
void __fastcall randint_free ( void * @@a1@@ ) { memset ( @@a1@@ , Number , Number ) ; free ( @@a1@@ ) ; }
bool __fastcall re_node_set_insert ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { __int64 @@i@@ ; void * @@v4@@ ; if ( ! * ( _QWORD * ) @@a1@@ ) return ( unsigned int ) re_node_set_init_1 ( ( _QWORD * ) @@a1@@ , @@a2@@ ) == Number ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) { * * ( _QWORD * * ) ( @@a1@@ + Number ) = @@a2@@ ; ++ * ( _QWORD * ) ( @@a1@@ + Number ) ; return Number ; } if ( * ( _QWORD * ) @@a1@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ) { * ( _QWORD * ) @@a1@@ *= Number L ; @@v4@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number L * * ( _QWORD * ) @@a1@@ ) ; if ( ! @@v4@@ ) return Number ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v4@@ ; } if ( @@a2@@ >= * * ( _QWORD * * ) ( @@a1@@ + Number ) ) { for ( @@i@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@a2@@ < * ( _QWORD * ) ( Number * @@i@@ - Number + * ( _QWORD * ) ( @@a1@@ + Number ) ) ; -- @@i@@ ) { * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@i@@ ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@i@@ - Number ) ; } } else { for ( @@i@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ ; -- @@i@@ ) * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@i@@ ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@i@@ - Number ) ; } * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@i@@ ) = @@a2@@ ; ++ * ( _QWORD * ) ( @@a1@@ + Number ) ; return Number ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
__int64 __fastcall randint_all_free ( _QWORD * @@a1@@ ) { unsigned int @@v2@@ ; int @@v3@@ ; @@v2@@ = randread_free ( * @@a1@@ ) ; @@v3@@ = * __errno_location ( ) ; randint_free ( @@a1@@ ) ; * __errno_location ( ) = @@v3@@ ; return @@v2@@ ; }
int clock_gettime ( clockid_t @@clock_id@@ , struct timespec * @@tp@@ ) { return clock_gettime ( @@clock_id@@ , @@tp@@ ) ; }
char * __fastcall rpl_re_compile_pattern ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { char * @@result@@ ; int @@v4@@ ; * ( _BYTE * ) ( @@a3@@ + Number ) = ( Number * ( ( rpl_re_syntax_options & Number ) != Number ) ) | * ( _BYTE * ) ( @@a3@@ + Number ) & Number ; * ( _BYTE * ) ( @@a3@@ + Number ) |= Number ; @@v4@@ = re_compile_internal ( @@a3@@ , @@a1@@ , @@a2@@ , rpl_re_syntax_options ) ; if ( @@v4@@ ) @@result@@ = gettext ( & _re_error_msgid [ _re_error_msgid_idx [ @@v4@@ ] ] ) ; else @@result@@ = Number L ; return @@result@@ ; }
_QWORD * __fastcall simple_new ( __int64 @@a1@@ , __int64 @@a2@@ ) { _QWORD * @@result@@ ; @@result@@ = ( _QWORD * ) xmalloc ( Number L ) ; * @@result@@ = @@a1@@ ; @@result@@ [ Number ] = randread_error ; @@result@@ [ Number ] = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
int __fastcall randread_free ( FILE * * @@a1@@ ) { int @@result@@ ; FILE * @@stream@@ ; @@stream@@ = * @@a1@@ ; memset ( @@a1@@ , Number , Number ) ; free ( @@a1@@ ) ; if ( @@stream@@ ) @@result@@ = fclose ( @@stream@@ ) ; else @@result@@ = Number ; return @@result@@ ; }
size_t __fastcall rpl_regerror ( int @@a1@@ , __int64 a2 , _BYTE * @@a3@@ , size_t @@a4@@ ) { size_t @@n@@ ; const char * @@s@@ ; size_t @@v9@@ ; if ( @@a1@@ < Number || @@a1@@ > Number ) abort ( ) ; @@s@@ = gettext ( & _re_error_msgid [ _re_error_msgid_idx [ @@a1@@ ] ] ) ; @@v9@@ = strlen ( @@s@@ ) + Number ; if ( @@a4@@ ) { @@n@@ = @@v9@@ ; if ( @@v9@@ > @@a4@@ ) { @@n@@ = @@a4@@ - Number ; @@a3@@ [ @@a4@@ - Number ] = Number ; } memcpy ( @@a3@@ , @@s@@ , @@n@@ ) ; } return @@v9@@ ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
int __fxstat ( int @@ver@@ , int @@fildes@@ , struct stat * @@stat_buf@@ ) { return _fxstat ( @@ver@@ , @@fildes@@ , @@stat_buf@@ ) ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_207028 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
__int64 __fastcall init_word_char ( __int64 @@a1@@ ) { __int64 @@result@@ ; int @@v2@@ ; int @@i@@ ; int @@v4@@ ; @@result@@ = @@a1@@ ; * ( _BYTE * ) ( @@a1@@ + Number ) |= Number ; @@v2@@ = Number ; @@v4@@ = Number ; while ( @@v2@@ <= Number ) { for ( @@i@@ = Number ; @@i@@ <= Number ; ++ @@i@@ ) { @@result@@ = ( * __ctype_b_loc ( ) ) [ @@v4@@ ] & Number ; if ( ( _DWORD ) @@result@@ || @@v4@@ == Number ) { @@result@@ = @@a1@@ ; * ( _QWORD * ) ( @@a1@@ + Number * ( @@v2@@ + Number L ) + Number ) |= Number L << @@i@@ ; } ++ @@v4@@ ; } ++ @@v2@@ ; } return @@result@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
int feof_unlocked ( FILE * @@stream@@ ) { return feof_unlocked ( @@stream@@ ) ; }
_BYTE * __fastcall dir_len ( _BYTE * @@a1@@ ) { _BYTE * @@i@@ ; unsigned __int64 @@v3@@ ; @@v3@@ = * @@a1@@ == Number ; for ( @@i@@ = ( _BYTE * ) ( last_component ( @@a1@@ ) - @@a1@@ ) ; @@v3@@ < ( unsigned __int64 ) @@i@@ && @@a1@@ [ ( _QWORD ) ( @@i@@ - Number ) ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
int nanosleep ( const struct timespec * @@requested_time@@ , struct timespec * @@remaining@@ ) { return nanosleep ( @@requested_time@@ , @@remaining@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
int sigemptyset ( sigset_t * @@set@@ ) { return sigemptyset ( @@set@@ ) ; }
__int64 __fastcall xtime_make ( __int64 @@a1@@ , __int64 @@a2@@ ) { return Number * @@a1@@ + @@a2@@ ; }
void __fastcall __noreturn die ( const char * @@a1@@ , char * @@a2@@ ) { char * @@v2@@ ; int * @@v3@@ ; if ( @@a2@@ ) @@v2@@ = @@a2@@ ; else @@v2@@ = gettext ( String ) ; @@v3@@ = __errno_location ( ) ; error ( Number , * @@v3@@ , String , @@a1@@ , @@v2@@ ) ; exit ( Number ) ; }
__pid_t waitpid ( __pid_t @@pid@@ , int * @@stat_loc@@ , int @@options@@ ) { return waitpid ( @@pid@@ , @@stat_loc@@ , @@options@@ ) ; }
__int64 gethrxtime ( ) { struct timespec @@tp@@ ; unsigned __int64 @@v2@@ ; @@v2@@ = __readfsqword ( Number ) ; if ( clock_gettime ( Number , & @@tp@@ ) ) gettime ( & @@tp@@ ) ; return xtime_make ( @@tp@@ . tv_sec , @@tp@@ . tv_nsec ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 __fastcall preorder ( _QWORD * @@a1@@ , __int64 ( __fastcall * @@a2@@ ) ( __int64 , _QWORD * ) , __int64 @@a3@@ ) { __int64 @@result@@ ; _QWORD * @@v5@@ ; _QWORD * @@v6@@ ; @@v5@@ = @@a1@@ ; LODWORD ( @@result@@ ) = @@a2@@ ( @@a3@@ , @@a1@@ ) ; while ( ! ( _DWORD ) @@result@@ ) { if ( @@v5@@ [ Number ] ) { @@v5@@ = ( _QWORD * ) @@v5@@ [ Number ] ; LODWORD ( @@result@@ ) = @@a2@@ ( @@a3@@ , @@v5@@ ) ; } else { @@v6@@ = Number L ; while ( @@v6@@ == ( _QWORD * ) @@v5@@ [ Number ] || ! @@v5@@ [ Number ] ) { @@v6@@ = @@v5@@ ; @@v5@@ = ( _QWORD * ) * @@v5@@ ; if ( ! @@v5@@ ) return Number L ; } @@v5@@ = ( _QWORD * ) @@v5@@ [ Number ] ; LODWORD ( @@result@@ ) = @@a2@@ ( @@a3@@ , @@v5@@ ) ; } } return ( unsigned int ) @@result@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_20A0A8 ; @@v4@@ [ Number ] = qword_20A0B0 ; @@v4@@ [ Number ] = qword_20A0B8 ; @@v4@@ [ Number ] = qword_20A0C0 ; @@v4@@ [ Number ] = qword_20A0C8 ; @@v4@@ [ Number ] = qword_20A0D0 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
unsigned __int64 __fastcall update_proc ( int @@a1@@ ) { __int64 @@v2@@ ; int @@v3@@ [ Number ] ; unsigned __int64 @@v4@@ ; @@v4@@ = __readfsqword ( Number ) ; @@v3@@ [ Number ] = @@a1@@ ; @@v2@@ = hash_lookup ( proctab , @@v3@@ ) ; if ( @@v2@@ ) * ( _DWORD * ) ( @@v2@@ + Number ) = Number ; return __readfsqword ( Number ) ^ @@v4@@ ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
char * __fastcall group_number ( char * @@a1@@ , size_t @@a2@@ , unsigned __int8 * @@a3@@ , const char * @@a4@@ ) { char * @@i@@ ; size_t @@v5@@ ; char * @@v6@@ ; unsigned __int8 @@v10@@ ; size_t @@v11@@ ; size_t @@v12@@ ; size_t @@v13@@ ; char @@dest@@ [ Number ] ; unsigned __int64 @@v15@@ ; @@v15@@ = __readfsqword ( Number ) ; @@v11@@ = Number ; @@v13@@ = strlen ( @@a4@@ ) ; @@v12@@ = @@a2@@ ; memcpy ( @@dest@@ , @@a1@@ , @@a2@@ ) ; for ( @@i@@ = & @@a1@@ [ @@a2@@ ] ; ; memcpy ( @@i@@ , @@a4@@ , @@v13@@ ) ) { @@v10@@ = * @@a3@@ ; if ( * @@a3@@ ) { if ( @@v10@@ > Number ) @@v5@@ = @@v12@@ ; else @@v5@@ = @@v10@@ ; @@v11@@ = @@v5@@ ; ++ @@a3@@ ; } if ( @@v12@@ < @@v11@@ ) @@v11@@ = @@v12@@ ; @@v6@@ = & @@i@@ [ - @@v11@@ ] ; @@v12@@ -= @@v11@@ ; memcpy ( @@v6@@ , & @@dest@@ [ @@v12@@ ] , @@v11@@ ) ; if ( ! @@v12@@ ) break ; @@i@@ = & @@v6@@ [ - @@v13@@ ] ; } return @@v6@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 __fastcall lower_subexp ( _DWORD * @@a1@@ , __int64 * @@a2@@ , __int64 @@a3@@ ) { __int64 @@result@@ ; __int64 @@v4@@ ; _BOOL4 @@v5@@ ; _BOOL4 @@v6@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; __int64 @@v12@@ ; __int64 @@v13@@ ; @@v8@@ = * @@a2@@ ; @@v9@@ = * ( _QWORD * ) ( @@a3@@ + Number ) ; if ( ( @@a2@@ [ Number ] & Number ) != Number && * ( _QWORD * ) ( @@a3@@ + Number ) && ( * ( _QWORD * ) ( @@a3@@ + Number ) > Number || ( ( * ( _QWORD * ) ( @@v8@@ + Number ) >> * ( _QWORD * ) ( @@a3@@ + Number ) ) & Number L ) == Number ) ) { return * ( _QWORD * ) ( @@a3@@ + Number ) ; } @@v10@@ = create_tree ( @@v8@@ , Number L , Number L , Number L ) ; @@v11@@ = create_tree ( @@v8@@ , Number L , Number L , Number L ) ; if ( @@v9@@ ) @@v4@@ = create_tree ( @@v8@@ , @@v9@@ , @@v11@@ , Number L ) ; else @@v4@@ = @@v11@@ ; @@v12@@ = @@v4@@ ; @@v13@@ = create_tree ( @@v8@@ , @@v10@@ , @@v4@@ , Number L ) ; @@v5@@ = ! @@v13@@ || ! @@v12@@ ; @@v6@@ = @@v5@@ || ! @@v10@@ ; if ( ! @@v6@@ && @@v11@@ ) { * ( _QWORD * ) ( @@v11@@ + Number ) = * ( _QWORD * ) ( @@a3@@ + Number ) ; * ( _QWORD * ) ( @@v10@@ + Number ) = * ( _QWORD * ) ( @@v11@@ + Number ) ; * ( _BYTE * ) ( @@v11@@ + Number ) = ( Number * ( ( * ( _BYTE * ) ( @@a3@@ + Number ) & Number ) != Number ) ) | * ( _BYTE * ) ( @@v11@@ + Number ) & Number ; * ( _BYTE * ) ( @@v10@@ + Number ) = ( Number * ( ( * ( _BYTE * ) ( @@v11@@ + Number ) & Number ) != Number ) ) | * ( _BYTE * ) ( @@v10@@ + Number ) & Number ; @@result@@ = @@v13@@ ; } else { * @@a1@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
unsigned __int64 __fastcall wait_proc ( unsigned int @@a1@@ ) { _DWORD * @@ptr@@ ; unsigned int @@v3@@ [ Number ] ; unsigned __int64 @@v4@@ ; @@v4@@ = __readfsqword ( Number ) ; @@v3@@ [ Number ] = @@a1@@ ; @@ptr@@ = ( _DWORD * ) hash_lookup ( proctab , @@v3@@ ) ; if ( ! @@ptr@@ [ Number ] ) reap ( @@a1@@ ) ; @@ptr@@ [ Number ] = Number ; if ( ! -- * ( ( _QWORD * ) @@ptr@@ + Number ) ) { hash_delete ( proctab , @@ptr@@ ) ; free ( @@ptr@@ ) ; } return __readfsqword ( Number ) ^ @@v4@@ ; }
bool __fastcall proctab_comparator ( _DWORD * @@a1@@ , _DWORD * @@a2@@ ) { return * @@a1@@ == * @@a2@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
__int64 __fastcall calc_eclosure ( __int64 @@a1@@ ) { char @@v2@@ ; unsigned int @@v3@@ ; __int64 @@i@@ ; char @@v5@@ [ Number ] ; void * @@ptr@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v2@@ = Number ; for ( @@i@@ = Number L ; ; ++ @@i@@ ) { if ( @@i@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ) { if ( @@v2@@ != Number ) return Number L ; @@v2@@ = Number ; @@i@@ = Number L ; } if ( ! * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@i@@ + Number ) ) break ; LABEL_11 : ; } @@v3@@ = calc_eclosure_iter ( @@v5@@ , @@a1@@ , @@i@@ , Number L ) ; if ( ! @@v3@@ ) { if ( ! * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@i@@ + Number ) ) { @@v2@@ = Number ; free ( @@ptr@@ ) ; } goto LABEL_11 ; } return @@v3@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) _frame_dummy_init_array_entry [ @@i@@ ] ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
unsigned __int64 __fastcall register_proc ( int @@a1@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; int @@v4@@ [ Number ] ; unsigned __int64 @@v5@@ ; @@v5@@ = __readfsqword ( Number ) ; if ( ! proctab ) { proctab = hash_initialize ( Number L , Number L , proctab_hasher , proctab_comparator , & free ) ; if ( ! proctab ) xalloc_die ( ) ; } @@v4@@ [ Number ] = @@a1@@ ; @@v2@@ = hash_lookup ( proctab , @@v4@@ ) ; if ( @@v2@@ ) { * ( _DWORD * ) ( @@v2@@ + Number ) = Number ; ++ * ( _QWORD * ) ( @@v2@@ + Number ) ; } else { @@v3@@ = xmalloc ( Number L ) ; * ( _DWORD * ) @@v3@@ = @@a1@@ ; * ( _DWORD * ) ( @@v3@@ + Number ) = Number ; * ( _QWORD * ) ( @@v3@@ + Number ) = Number L ; if ( ! hash_insert ( proctab , @@v3@@ ) ) xalloc_die ( ) ; } return __readfsqword ( Number ) ^ @@v5@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
__int64 __fastcall pipe_fork ( int * @@a1@@ , __int64 @@a2@@ ) { int @@v3@@ ; int @@v4@@ ; int @@v5@@ ; int @@v6@@ ; __int64 @@v8@@ ; __pid_t @@v9@@ ; int @@v10@@ ; int @@v11@@ ; double @@v12@@ ; __int64 @@v13@@ ; char @@v14@@ [ Number ] ; sigset_t @@set@@ ; unsigned __int64 @@v16@@ ; @@v8@@ = @@a2@@ ; @@v16@@ = __readfsqword ( Number ) ; @@v12@@ = Number ; if ( pipe ( @@a1@@ ) < Number ) return Number ; while ( @@v8@@ -- ) { cs_enter ( @@v14@@ ) ; @@v13@@ = temphead ; temphead = Number L ; @@v9@@ = fork ( ) ; @@v10@@ = * __errno_location ( ) ; if ( @@v9@@ ) temphead = @@v13@@ ; cs_leave ( ( int ) @@v14@@ , @@a2@@ , @@v3@@ , @@v4@@ , @@v5@@ , @@v6@@ , @@v14@@ [ Number ] , @@set@@ ) ; * __errno_location ( ) = @@v10@@ ; if ( @@v9@@ >= Number || * __errno_location ( ) != Number ) break ; xnanosleep ( @@v12@@ ) ; @@v12@@ = @@v12@@ + @@v12@@ ; reap_some ( ) ; } if ( @@v9@@ >= Number ) { if ( @@v9@@ ) { ++ nprocs ; } else { close ( Number ) ; close ( Number ) ; } } else { @@v11@@ = * __errno_location ( ) ; close ( * @@a1@@ ) ; close ( @@a1@@ [ Number ] ) ; * __errno_location ( ) = @@v11@@ ; } return ( unsigned int ) @@v9@@ ; }
__int64 __fastcall parse_reg_exp ( __int64 @@a1@@ , __int64 * @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , _DWORD * @@a6@@ ) { __int64 @@v11@@ ; __int64 @@v12@@ ; __int64 @@v13@@ ; @@v13@@ = * @@a2@@ ; @@v11@@ = parse_branch ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( * @@a6@@ && ! @@v11@@ ) return Number L ; while ( * ( _BYTE * ) ( @@a3@@ + Number ) == Number ) { fetch_token ( @@a3@@ , @@a1@@ , @@a4@@ | Number ) ; if ( * ( _BYTE * ) ( @@a3@@ + Number ) == Number || * ( _BYTE * ) ( @@a3@@ + Number ) == Number || @@a5@@ && * ( _BYTE * ) ( @@a3@@ + Number ) == Number ) { @@v12@@ = Number L ; } else { @@v12@@ = parse_branch ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( * @@a6@@ && ! @@v12@@ ) return Number L ; } @@v11@@ = create_tree ( @@v13@@ , @@v11@@ , @@v12@@ , Number L ) ; if ( ! @@v11@@ ) { * @@a6@@ = Number ; return Number L ; } } return @@v11@@ ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
FILE * __fastcall stream_open ( const char * @@a1@@ , _BYTE * @@a2@@ ) { if ( ! @@a1@@ ) return stdout ; if ( strcmp ( @@a1@@ , String ) || * @@a2@@ != Number ) return ( FILE * ) fopen_safer ( @@a1@@ , @@a2@@ ) ; have_read_stdin = Number ; return stdin ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
void * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
void * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
char * strsignal ( int @@sig@@ ) { return strsignal ( @@sig@@ ) ; }
void * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 __fastcall parse_bracket_symbol ( __int64 @@a1@@ , _QWORD * @@a2@@ , char * @@a3@@ ) { __int64 @@v4@@ ; __int64 @@v5@@ ; int @@v6@@ ; char @@v9@@ ; char @@v10@@ ; int @@v11@@ ; @@v10@@ = * @@a3@@ ; @@v11@@ = Number ; if ( @@a2@@ [ Number ] <= @@a2@@ [ Number ] ) return Number L ; while ( Number ) { if ( @@v11@@ > Number ) return Number L ; if ( @@a3@@ [ Number ] == Number ) { @@v9@@ = re_string_fetch_byte_case ( ( __int64 ) @@a2@@ ) ; } else { @@v4@@ = @@a2@@ [ Number ] ; @@v5@@ = @@a2@@ [ Number ] ; @@a2@@ [ Number ] = @@v5@@ + Number ; @@v9@@ = * ( _BYTE * ) ( @@v4@@ + @@v5@@ ) ; } if ( @@a2@@ [ Number ] <= @@a2@@ [ Number ] ) return Number L ; if ( @@v9@@ == @@v10@@ && * ( _BYTE * ) ( @@a2@@ [ Number ] + @@a2@@ [ Number ] ) == Number ) { break ; } * ( _BYTE * ) ( @@v11@@ ++ + * ( _QWORD * ) ( @@a1@@ + Number ) ) = @@v9@@ ; } ++ @@a2@@ [ Number ] ; * ( _BYTE * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@v11@@ ) = Number ; @@v6@@ = ( unsigned __int8 ) @@a3@@ [ Number ] ; switch ( @@v6@@ ) { case Number : * ( _DWORD * ) @@a1@@ = Number ; break ; case Number : * ( _DWORD * ) @@a1@@ = Number ; break ; case Number : * ( _DWORD * ) @@a1@@ = Number ; break ; } return Number L ; }
void __fastcall xfclose ( FILE * @@a1@@ , char * @@a2@@ ) { int @@v2@@ ; char * @@v3@@ ; char * @@v4@@ ; @@v2@@ = fileno ( @@a1@@ ) ; if ( @@v2@@ ) { if ( @@v2@@ == Number ) { if ( fflush_unlocked ( @@a1@@ ) ) { @@v3@@ = gettext ( String ) ; die ( @@v3@@ , @@a2@@ ) ; } } else if ( fclose ( @@a1@@ ) ) { @@v4@@ = gettext ( String ) ; die ( @@v4@@ , @@a2@@ ) ; } } else if ( feof_unlocked ( @@a1@@ ) ) { clearerr_unlocked ( @@a1@@ ) ; } }
unsigned __int64 __fastcall specify_nmerge ( unsigned int @@a1@@ , char @@a2@@ , __int64 @@a3@@ ) { unsigned int @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; char * @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; char * @@v12@@ ; __int64 @@v13@@ ; __int64 @@v14@@ ; char * @@v15@@ ; unsigned int @@v18@@ ; unsigned int @@v19@@ ; __int64 @@v20@@ ; struct rlimit @@rlimits@@ ; char @@v22@@ [ Number ] ; unsigned __int64 @@v23@@ ; @@v23@@ = __readfsqword ( Number ) ; @@v18@@ = xstrtoumax ( @@a3@@ , Number L , Number L , & @@v20@@ , Number L ) ; if ( getrlimit ( RLIMIT_NOFILE , & @@rlimits@@ ) ) @@v3@@ = Number ; else @@v3@@ = LODWORD ( @@rlimits@@ . rlim_cur ) - Number ; @@v19@@ = @@v3@@ ; if ( ! @@v18@@ ) { nmerge = @@v20@@ ; if ( ( unsigned int ) @@v20@@ == @@v20@@ ) { if ( ( unsigned int ) nmerge > Number ) { if ( @@v3@@ >= nmerge ) return __readfsqword ( Number ) ^ @@v23@@ ; @@v18@@ = Number ; } else { @@v4@@ = quote ( @@a3@@ ) ; @@v5@@ = * ( ( _QWORD * ) & long_options . name + Number * ( int ) @@a1@@ ) ; @@v6@@ = gettext ( String ) ; error ( Number , Number , @@v6@@ , @@v5@@ , @@v4@@ ) ; @@v7@@ = quote ( String ) ; @@v8@@ = * ( ( _QWORD * ) & long_options . name + Number * ( int ) @@a1@@ ) ; @@v9@@ = gettext ( String ) ; error ( Number , Number , @@v9@@ , @@v8@@ , @@v7@@ ) ; } } else { @@v18@@ = Number ; } } if ( @@v18@@ != Number ) xstrtol_fatal ( @@v18@@ , @@a1@@ , ( unsigned int ) @@a2@@ , & long_options , @@a3@@ ) ; @@v10@@ = quote ( @@a3@@ ) ; @@v11@@ = * ( ( _QWORD * ) & long_options . name + Number * ( int ) @@a1@@ ) ; @@v12@@ = gettext ( String ) ; error ( Number , Number , @@v12@@ , @@v11@@ , @@v10@@ ) ; @@v13@@ = uinttostr ( @@v19@@ , @@v22@@ ) ; @@v14@@ = * ( ( _QWORD * ) & long_options . name + Number * ( int ) @@a1@@ ) ; @@v15@@ = gettext ( String ) ; error ( Number , Number , @@v15@@ , @@v14@@ , @@v13@@ ) ; return __readfsqword ( Number ) ^ @@v23@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
__int64 __fastcall rpl_re_match ( int @@a1@@ , int @@a2@@ , int @@a3@@ , int @@a4@@ , __int64 @@a5@@ ) { return re_search_stub ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , Number , @@a3@@ , @@a5@@ , Number ) ; }
size_t __fastcall write_bytes ( const void * @@a1@@ , size_t @@a2@@ , FILE * @@a3@@ , char * @@a4@@ ) { size_t @@result@@ ; char * @@v5@@ ; @@result@@ = fwrite_unlocked ( @@a1@@ , Number , @@a2@@ , @@a3@@ ) ; if ( @@a2@@ != @@result@@ ) { @@v5@@ = gettext ( String ) ; die ( @@v5@@ , @@a4@@ ) ; } return @@result@@ ; }
void * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__int64 __fastcall rpl_re_search ( int @@a1@@ , int @@a2@@ , int @@a3@@ , int @@a4@@ , int @@a5@@ , __int64 @@a6@@ ) { return re_search_stub ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a3@@ , @@a6@@ , Number ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
__int64 __fastcall rpl_re_match_2 ( int @@a1@@ , int @@a2@@ , int @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ , __int64 @@a7@@ , __int64 @@a8@@ ) { return re_search_2_stub ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ , Number L , @@a7@@ , @@a8@@ , Number ) ; }
unsigned __int64 __fastcall zaptemp ( const char * @@a1@@ , int @@a2@@ ) { int @@v2@@ ; int @@v3@@ ; int @@v4@@ ; char * @@v5@@ ; int @@errnum@@ ; int @@v8@@ ; __int64 * @@i@@ ; __int64 * @@ptr@@ ; __int64 @@v11@@ ; char @@v12@@ [ Number ] ; sigset_t @@set@@ ; unsigned __int64 @@v14@@ ; @@v14@@ = __readfsqword ( Number ) ; for ( @@i@@ = & temphead ; ; @@i@@ = ( __int64 * ) * @@i@@ ) { @@ptr@@ = ( __int64 * ) * @@i@@ ; if ( @@a1@@ == ( const char * ) ( * @@i@@ + Number ) ) break ; } @@v11@@ = * @@ptr@@ ; cs_enter ( @@v12@@ ) ; @@v8@@ = unlink ( @@a1@@ ) ; @@errnum@@ = * __errno_location ( ) ; * @@i@@ = @@v11@@ ; cs_leave ( ( int ) @@a1@@ , @@a2@@ , @@v11@@ , @@v2@@ , @@v3@@ , @@v4@@ , @@v12@@ [ Number ] , @@set@@ ) ; if ( @@v8@@ ) { @@v5@@ = gettext ( String ) ; error ( Number , @@errnum@@ , @@v5@@ , @@a1@@ ) ; } if ( ! @@v11@@ ) temptail = ( __int64 ) @@i@@ ; free ( @@ptr@@ ) ; return __readfsqword ( Number ) ^ @@v14@@ ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
unsigned __int8 * __fastcall limfield ( __int64 @@a1@@ , __int64 @@a2@@ ) { unsigned __int8 * @@v4@@ ; unsigned __int8 * @@v6@@ ; __int64 @@v7@@ ; unsigned __int64 @@v8@@ ; __int64 @@v9@@ ; @@v6@@ = * ( unsigned __int8 * * ) @@a1@@ ; @@v8@@ = * ( _QWORD * ) ( @@a1@@ + Number ) - Number L + * ( _QWORD * ) @@a1@@ ; @@v7@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@v9@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( ! @@v9@@ ) ++ @@v7@@ ; if ( tab == Number ) { while ( ( unsigned __int64 ) @@v6@@ < @@v8@@ ) { if ( ! @@v7@@ -- ) break ; while ( ( unsigned __int64 ) @@v6@@ < @@v8@@ && blanks [ ( unsigned __int8 ) to_uchar ( * @@v6@@ ) ] ) ++ @@v6@@ ; while ( ( unsigned __int64 ) @@v6@@ < @@v8@@ && blanks [ ( unsigned __int8 ) to_uchar ( * @@v6@@ ) ] != Number ) ++ @@v6@@ ; } } else { while ( ( unsigned __int64 ) @@v6@@ < @@v8@@ ) { if ( ! @@v7@@ -- ) break ; while ( ( unsigned __int64 ) @@v6@@ < @@v8@@ && ( char ) * @@v6@@ != tab ) ++ @@v6@@ ; if ( ( unsigned __int64 ) @@v6@@ < @@v8@@ && ( @@v7@@ || @@v9@@ ) ) ++ @@v6@@ ; } } if ( @@v9@@ ) { if ( * ( _BYTE * ) ( @@a2@@ + Number ) ) { while ( ( unsigned __int64 ) @@v6@@ < @@v8@@ && blanks [ ( unsigned __int8 ) to_uchar ( * @@v6@@ ) ] ) ++ @@v6@@ ; } @@v4@@ = & @@v6@@ [ @@v9@@ ] ; if ( @@v8@@ <= ( unsigned __int64 ) & @@v6@@ [ @@v9@@ ] ) @@v4@@ = ( unsigned __int8 * ) @@v8@@ ; @@v6@@ = @@v4@@ ; } return @@v6@@ ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
__int64 __fastcall re_search_2_stub ( int @@a1@@ , const void * @@a2@@ , size_t @@a3@@ , const void * @@a4@@ , size_t @@a5@@ , int @@a6@@ , __int64 @@a7@@ , __int64 @@a8@@ , __int64 @@a9@@ , unsigned __int8 @@a10@@ ) { __int64 @@v11@@ ; char * @@dest@@ ; size_t @@size@@ ; __int64 @@v18@@ ; @@size@@ = @@a3@@ + @@a5@@ ; @@dest@@ = Number L ; if ( @@a3@@ + @@a5@@ < @@a3@@ ) return Number ; if ( @@a5@@ ) { if ( @@a3@@ ) { @@dest@@ = ( char * ) malloc ( @@size@@ ) ; if ( ! @@dest@@ ) return Number ; memcpy ( @@dest@@ , @@a2@@ , @@a3@@ ) ; memcpy ( & @@dest@@ [ @@a3@@ ] , @@a4@@ , @@a5@@ ) ; @@v11@@ = re_search_stub ( @@a1@@ , ( _DWORD ) @@dest@@ , @@size@@ , @@a6@@ , @@a7@@ , @@a9@@ , @@a8@@ , @@a10@@ ) ; } else { @@v11@@ = re_search_stub ( @@a1@@ , ( _DWORD ) @@a4@@ , @@size@@ , @@a6@@ , @@a7@@ , @@a9@@ , @@a8@@ , @@a10@@ ) ; } } else { @@v11@@ = re_search_stub ( @@a1@@ , ( _DWORD ) @@a2@@ , @@size@@ , @@a6@@ , @@a7@@ , @@a9@@ , @@a8@@ , @@a10@@ ) ; } @@v18@@ = @@v11@@ ; free ( @@dest@@ ) ; return @@v18@@ ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
unsigned __int64 __fastcall default_sort_size ( __int64 @@a1@@ , __int64 @@a2@@ ) { double @@v2@@ ; unsigned __int64 @@result@@ ; unsigned __int64 @@v4@@ ; rlim_t @@v5@@ ; double @@v6@@ ; double @@v7@@ ; struct rlimit @@rlimits@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ = physmem_available ( ) ; @@v7@@ = physmem_total ( @@a1@@ , @@a2@@ ) ; if ( @@v6@@ <= @@v7@@ / Number ) @@v2@@ = @@v7@@ / Number ; else @@v2@@ = @@v6@@ ; @@v4@@ = Number ; if ( ( double ) Number + ( double ) Number > @@v2@@ ) { if ( @@v2@@ >= Number ) @@v4@@ = ( unsigned int ) ( int ) ( @@v2@@ - Number ) ^ Number ; else @@v4@@ = ( unsigned int ) ( int ) @@v2@@ ; } if ( ! getrlimit ( RLIMIT_DATA , & @@rlimits@@ ) && @@v4@@ > @@rlimits@@ . rlim_cur ) { @@v4@@ = @@rlimits@@ . rlim_cur ; } if ( ! getrlimit ( RLIMIT_AS , & @@rlimits@@ ) && @@v4@@ > @@rlimits@@ . rlim_cur ) { @@v4@@ = @@rlimits@@ . rlim_cur ; } @@v5@@ = @@v4@@ >> Number ; if ( ! getrlimit ( __RLIMIT_RSS , & @@rlimits@@ ) && @@v5@@ > Number * ( @@rlimits@@ . rlim_cur >> Number ) ) { @@v5@@ = Number * ( @@rlimits@@ . rlim_cur >> Number ) ; } @@result@@ = Number L * ( unsigned int ) nmerge ; if ( @@v5@@ >= @@result@@ ) @@result@@ = @@v5@@ ; return @@result@@ ; }
__int64 __fastcall compare_version ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ ) { __int64 @@result@@ ; char @@v7@@ ; char @@v8@@ ; @@v7@@ = * ( _BYTE * ) ( @@a1@@ + @@a2@@ ) ; @@v8@@ = * ( _BYTE * ) ( @@a3@@ + @@a4@@ ) ; * ( _BYTE * ) ( @@a1@@ + @@a2@@ ) = Number ; * ( _BYTE * ) ( @@a3@@ + @@a4@@ ) = Number ; LODWORD ( @@result@@ ) = filevercmp ( @@a1@@ , @@a3@@ ) ; * ( _BYTE * ) ( @@a2@@ + @@a1@@ ) = @@v7@@ ; * ( _BYTE * ) ( @@a4@@ + @@a3@@ ) = @@v8@@ ; return ( unsigned int ) @@result@@ ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
__int64 __fastcall push_fail_stack ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , const void * @@a5@@ , __int64 @@a6@@ ) { __int64 @@v6@@ ; __int64 @@v8@@ ; __int64 @@v13@@ ; void * @@v14@@ ; @@v6@@ = ( * ( _QWORD * ) @@a1@@ ) ++ ; @@v13@@ = @@v6@@ ; if ( * ( _QWORD * ) @@a1@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ) { @@v14@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number L * * ( _QWORD * ) ( @@a1@@ + Number ) ) ; if ( ! @@v14@@ ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) *= Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v14@@ ; } * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@v13@@ ) = @@a2@@ ; * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@v13@@ + Number ) = @@a3@@ ; @@v8@@ = * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@v13@@ ; * ( _QWORD * ) ( @@v8@@ + Number ) = malloc ( Number * @@a4@@ ) ; if ( ! * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@v13@@ + Number ) ) return Number L ; memcpy ( * ( void * * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@v13@@ + Number ) , @@a5@@ , Number * @@a4@@ ) ; return ( unsigned int ) re_node_set_init_copy ( ( void * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@v13@@ + Number ) , @@a6@@ ) ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall initbuf ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { __int64 @@result@@ ; unsigned __int64 @@sizea@@ ; while ( Number ) { @@sizea@@ = ( @@a3@@ & Number ) + Number ; * ( _QWORD * ) @@a1@@ = malloc ( @@sizea@@ ) ; if ( * ( _QWORD * ) @@a1@@ ) break ; @@a3@@ = @@sizea@@ >> Number ; if ( @@a3@@ <= @@a2@@ + Number ) xalloc_die ( ) ; } * ( _QWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@sizea@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@result@@ = @@a1@@ ; * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; return @@result@@ ; }
__int64 __fastcall open_input_files ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ ) { __int64 @@v3@@ ; int @@i@@ ; __int64 @@v7@@ ; * @@a3@@ = xnmalloc ( @@a2@@ , Number L ) ; @@v7@@ = * @@a3@@ ; for ( @@i@@ = Number ; @@a2@@ > @@i@@ ; ++ @@i@@ ) { @@v3@@ = * ( _DWORD * ) ( Number L * @@i@@ + @@a1@@ + Number ) ? open_temp ( * ( const char * * ) ( Number L * @@i@@ + @@a1@@ ) , * ( _DWORD * ) ( Number L * @@i@@ + @@a1@@ + Number ) ) : stream_open ( * ( const char * * ) ( Number L * @@i@@ + @@a1@@ ) , String ) ; * ( _QWORD * ) ( Number L * @@i@@ + @@v7@@ ) = @@v3@@ ; if ( ! * ( _QWORD * ) ( Number L * @@i@@ + @@v7@@ ) ) break ; } return @@i@@ ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
__int64 __fastcall argmatch ( const char * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { __int64 @@result@@ ; char @@v7@@ ; __int64 @@i@@ ; __int64 @@v9@@ ; size_t @@n@@ ; @@v9@@ = Number ; @@v7@@ = Number ; @@n@@ = strlen ( @@a1@@ ) ; for ( @@i@@ = Number L ; * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; ++ @@i@@ ) { if ( ! strncmp ( * ( const char * * ) ( Number * @@i@@ + @@a2@@ ) , @@a1@@ , @@n@@ ) ) { if ( @@n@@ == strlen ( * ( const char * * ) ( Number * @@i@@ + @@a2@@ ) ) ) return @@i@@ ; if ( @@v9@@ == Number ) { @@v9@@ = @@i@@ ; } else if ( ! @@a3@@ || memcmp ( ( const void * ) ( @@a4@@ * @@v9@@ + @@a3@@ ) , ( const void * ) ( @@i@@ * @@a4@@ + @@a3@@ ) , @@a4@@ ) ) { @@v7@@ = Number ; } } } if ( @@v7@@ ) @@result@@ = Number ; else @@result@@ = @@v9@@ ; return @@result@@ ; }
__int64 __fastcall human_numcompare ( unsigned __int8 * @@a1@@ , unsigned __int8 * @@a2@@ , __int64 @@a3@@ ) { int @@v7@@ ; int @@v8@@ ; while ( blanks [ ( unsigned __int8 ) to_uchar ( * @@a1@@ ) ] ) ++ @@a1@@ ; while ( blanks [ ( unsigned __int8 ) to_uchar ( * @@a2@@ ) ] ) ++ @@a2@@ ; @@v7@@ = find_unit_order ( @@a1@@ , @@a3@@ ) ; @@v8@@ = find_unit_order ( @@a2@@ , @@a3@@ ) ; if ( @@v7@@ > @@v8@@ ) return Number L ; if ( @@v7@@ < @@v8@@ ) return Number ; return strnumcmp ( @@a1@@ , @@a2@@ , ( unsigned int ) decimal_point , ( unsigned int ) thousands_sep ) ; }
__int64 __fastcall build_sifted_states ( __int64 @@a1@@ , _QWORD * @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ ) { int @@v7@@ ; unsigned __int64 @@i@@ ; _QWORD * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; @@v9@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; @@v10@@ = * ( _QWORD * ) ( Number * @@a3@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) + Number L ; for ( @@i@@ = Number L ; @@i@@ < * ( _QWORD * ) ( @@v10@@ + Number ) ; ++ @@i@@ ) { @@v11@@ = * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@v10@@ + Number ) ) ; @@v7@@ = Number ; if ( ( * ( _BYTE * ) ( Number * @@v11@@ + * @@v9@@ + Number ) & Number ) != Number ) @@v7@@ = sift_states_iter_mb ( @@a1@@ , @@a2@@ , @@v11@@ , @@a3@@ , @@a2@@ [ Number ] ) ; if ( ! @@v7@@ && ( unsigned __int8 ) check_node_accept ( @@a1@@ , * @@v9@@ + Number * @@v11@@ , @@a3@@ ) && * ( _QWORD * ) ( Number * ( @@a3@@ + Number ) + * @@a2@@ ) && re_node_set_contains ( * ( _QWORD * ) ( Number * ( @@a3@@ + Number ) + * @@a2@@ ) + Number L , * ( _QWORD * ) ( Number * @@v11@@ + @@v9@@ [ Number ] ) ) ) { @@v7@@ = Number ; } if ( @@v7@@ && ( ! @@a2@@ [ Number ] || ! ( unsigned __int8 ) check_dst_limits ( @@a1@@ , @@a2@@ + Number , * ( _QWORD * ) ( Number * @@v11@@ + @@v9@@ [ Number ] ) , @@v7@@ + @@a3@@ , @@v11@@ , @@a3@@ ) ) && ! re_node_set_insert ( @@a4@@ , @@v11@@ ) ) { return Number L ; } } return Number L ; }
unsigned __int8 * __fastcall sortlines_temp ( unsigned __int8 * * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 * * @@a3@@ ) { int @@v3@@ ; unsigned __int8 * * @@v4@@ ; unsigned __int8 * * @@v5@@ ; unsigned __int8 * @@v6@@ ; unsigned __int8 * @@v7@@ ; unsigned __int8 * * @@v8@@ ; unsigned __int8 * * @@v9@@ ; unsigned __int8 * @@v10@@ ; unsigned __int8 * @@result@@ ; unsigned __int8 * @@v12@@ ; unsigned __int64 @@v14@@ ; unsigned __int8 * * @@v15@@ ; if ( @@a2@@ == Number ) { @@v3@@ = compare ( @@a1@@ - Number , @@a1@@ - Number ) ; @@v4@@ = & @@a1@@ [ Number * ~ ( @@v3@@ > Number ) ] ; @@v5@@ = @@a3@@ - Number ; @@v6@@ = @@v4@@ [ Number ] ; * @@v5@@ = * @@v4@@ ; @@v5@@ [ Number ] = @@v6@@ ; @@v7@@ = @@v4@@ [ Number ] ; @@v5@@ [ Number ] = @@v4@@ [ Number ] ; @@v5@@ [ Number ] = @@v7@@ ; @@v8@@ = & @@a1@@ [ Number * ( @@v3@@ > Number ) - Number ] ; @@v9@@ = @@a3@@ - Number ; @@v10@@ = @@v8@@ [ Number ] ; * @@v9@@ = * @@v8@@ ; @@v9@@ [ Number ] = @@v10@@ ; @@result@@ = @@v8@@ [ Number ] ; @@v12@@ = @@v8@@ [ Number ] ; @@v9@@ [ Number ] = @@result@@ ; @@v9@@ [ Number ] = @@v12@@ ; } else { @@v14@@ = @@a2@@ >> Number ; @@v15@@ = & @@a3@@ [ Number * ( @@a2@@ >> Number ) ] ; sortlines_temp ( & @@a1@@ [ Number * ( @@a2@@ >> Number ) ] , @@a2@@ - ( @@a2@@ >> Number ) , @@v15@@ ) ; if ( @@a2@@ >> Number > Number ) sortlines ( @@a1@@ , @@v14@@ , @@a3@@ ) ; @@result@@ = mergelines ( @@a3@@ , @@a1@@ , @@v14@@ , @@v15@@ , @@a2@@ - ( @@a2@@ >> Number ) ) ; } return @@result@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_207028 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 __fastcall getmonth ( unsigned __int8 * @@a1@@ , __int64 @@a2@@ ) { int @@v3@@ ; int @@v4@@ ; unsigned __int8 * @@v5@@ ; unsigned __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; unsigned __int8 * @@v8@@ ; unsigned __int8 * @@i@@ ; unsigned __int8 * @@v10@@ ; unsigned __int64 @@v11@@ ; @@v5@@ = @@a1@@ ; @@v6@@ = Number L ; @@v7@@ = Number L ; @@v10@@ = & @@a1@@ [ @@a2@@ ] ; while ( Number ) { if ( @@v5@@ == @@v10@@ ) return Number L ; if ( blanks [ ( unsigned __int8 ) to_uchar ( * @@v5@@ ) ] != Number ) break ; ++ @@v5@@ ; } do { @@v11@@ = ( @@v6@@ + @@v7@@ ) >> Number ; @@v8@@ = @@v5@@ ; for ( @@i@@ = ( unsigned __int8 * ) ( & monthtab ) [ Number * @@v11@@ ] ; ; ++ @@i@@ ) { if ( ! * @@i@@ ) return * ( ( unsigned int * ) & unk_21B048 + Number * @@v11@@ ) ; if ( @@v8@@ == @@v10@@ || ( @@v3@@ = ( char ) fold_toupper [ ( unsigned __int8 ) to_uchar ( * @@v8@@ ) ] , @@v3@@ < ( unsigned __int8 ) to_uchar ( * @@i@@ ) ) ) { @@v7@@ = ( @@v6@@ + @@v7@@ ) >> Number ; goto LABEL_15 ; } @@v4@@ = ( char ) fold_toupper [ ( unsigned __int8 ) to_uchar ( * @@v8@@ ) ] ; if ( @@v4@@ > ( unsigned __int8 ) to_uchar ( * @@i@@ ) ) break ; ++ @@v8@@ ; } @@v6@@ = @@v11@@ + Number ; LABEL_15 : ; } while ( @@v6@@ < @@v7@@ ) ; return Number L ; }
__int64 __fastcall check_dst_limits_calc_pos_1 ( __int64 @@a1@@ , int @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ ) { int @@v5@@ ; __int64 @@result@@ ; __int64 @@v7@@ ; int @@v11@@ ; unsigned __int64 @@i@@ ; __int64 @@v13@@ ; _QWORD * @@v14@@ ; __int64 @@v15@@ ; __int64 @@v16@@ ; __int64 @@v17@@ ; @@v14@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; @@v15@@ = @@v14@@ [ Number ] + Number * @@a4@@ ; for ( @@i@@ = Number L ; ; ++ @@i@@ ) { if ( @@i@@ >= * ( _QWORD * ) ( @@v15@@ + Number ) ) return ( @@a2@@ >> Number ) & Number ; @@v16@@ = * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@v15@@ + Number ) ) ; @@v5@@ = * ( unsigned __int8 * ) ( Number * @@v16@@ + * @@v14@@ + Number ) ; if ( @@v5@@ == Number ) { if ( ( @@a2@@ & Number ) != Number && @@a3@@ == * ( _QWORD * ) ( Number * @@v16@@ + * @@v14@@ ) ) { return Number ; } continue ; } if ( @@v5@@ != Number ) break ; if ( ( @@a2@@ & Number ) != Number && @@a3@@ == * ( _QWORD * ) ( Number * @@v16@@ + * @@v14@@ ) ) { return Number L ; } LABEL_29 : ; } if ( @@v5@@ != Number || @@a5@@ == Number ) goto LABEL_29 ; @@v13@@ = * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@a5@@ ; while ( Number ) { if ( @@v16@@ != * ( _QWORD * ) @@v13@@ || @@a3@@ <= Number && ( ( * ( unsigned __int16 * ) ( @@v13@@ + Number ) >> @@a3@@ ) & Number L ) == Number ) { goto LABEL_21 ; } @@v17@@ = * * ( _QWORD * * ) ( @@v14@@ [ Number ] + Number * @@v16@@ + Number ) ; if ( @@v17@@ == @@a4@@ ) break ; @@v11@@ = check_dst_limits_calc_pos_1 ( @@a1@@ , @@a2@@ , @@a3@@ , @@v17@@ , @@a5@@ ) ; if ( @@v11@@ == Number ) return Number ; if ( ! @@v11@@ && ( @@a2@@ & Number ) != Number ) return Number L ; if ( @@a3@@ <= Number ) * ( _WORD * ) ( @@v13@@ + Number ) &= ~ ( unsigned __int16 ) ( Number L << @@a3@@ ) ; LABEL_21 : @@v7@@ = @@v13@@ ; @@v13@@ += Number L ; if ( ! * ( _BYTE * ) ( @@v7@@ + Number ) ) goto LABEL_29 ; } if ( ( @@a2@@ & Number ) != Number ) @@result@@ = Number ; else @@result@@ = Number L ; return @@result@@ ; }
void __fastcall __noreturn badfieldspec ( __int64 @@a1@@ , const char * @@a2@@ ) { __int64 @@v2@@ ; char * @@v3@@ ; char * @@v4@@ ; @@v2@@ = quote ( @@a1@@ ) ; @@v3@@ = gettext ( @@a2@@ ) ; @@v4@@ = gettext ( String ) ; error ( Number , Number , @@v4@@ , @@v3@@ , @@v2@@ ) ; abort ( ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
unsigned __int64 __fastcall mergefiles ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int64 @@a3@@ , FILE * @@a4@@ , char * @@a5@@ ) { char * @@v5@@ ; char * @@v6@@ ; FILE * * @@v11@@ ; unsigned __int64 @@v12@@ ; unsigned __int64 @@v13@@ ; @@v13@@ = __readfsqword ( Number ) ; @@v12@@ = open_input_files ( @@a1@@ , @@a3@@ , ( __int64 * ) & @@v11@@ ) ; if ( @@v12@@ < @@a3@@ && @@v12@@ <= Number ) { @@v5@@ = * ( char * * ) ( Number * @@v12@@ + @@a1@@ ) ; @@v6@@ = gettext ( String ) ; die ( @@v6@@ , @@v5@@ ) ; } mergefps ( @@a1@@ , @@a2@@ , @@v12@@ , @@a4@@ , @@a5@@ , @@v11@@ ) ; return @@v12@@ ; }
int fflush_unlocked ( FILE * @@stream@@ ) { return fflush_unlocked ( @@stream@@ ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
__int64 __fastcall parse_field_count ( __int64 @@a1@@ , _QWORD * @@a2@@ , const char * @@a3@@ ) { __int64 @@v3@@ ; char * @@v4@@ ; char * @@v5@@ ; __int64 @@v8@@ ; __int64 @@v9@@ [ Number ] ; @@v9@@ [ Number ] = __readfsqword ( Number ) ; switch ( ( unsigned int ) xstrtoumax ( @@a1@@ , & @@v8@@ , Number L , @@v9@@ , & locale ) ) { case Number : case Number : * @@a2@@ = @@v9@@ [ Number ] ; if ( * @@a2@@ == @@v9@@ [ Number ] ) return @@v8@@ ; goto LABEL_3 ; case Number : case Number : LABEL_3 : * @@a2@@ = Number ; return @@v8@@ ; case Number : if ( @@a3@@ ) { @@v3@@ = quote ( @@a1@@ ) ; @@v4@@ = gettext ( @@a3@@ ) ; @@v5@@ = gettext ( String ) ; error ( Number , Number , @@v5@@ , @@v4@@ , @@v3@@ ) ; } return Number L ; default : return @@v8@@ ; } }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_207288 ; @@v8@@ [ Number ] = qword_207290 ; @@v8@@ [ Number ] = qword_207298 ; @@v8@@ [ Number ] = qword_2072A0 ; @@v8@@ [ Number ] = qword_2072A8 ; @@v8@@ [ Number ] = qword_2072B0 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
__int64 __fastcall check_arrival_expand_ecl_sub ( _QWORD * @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ , unsigned int @@a5@@ ) { unsigned __int64 @@i@@ ; unsigned int @@v9@@ ; unsigned __int64 @@v10@@ ; @@v10@@ = @@a3@@ ; for ( @@i@@ = re_node_set_contains ( @@a2@@ , @@a3@@ ) ; ! @@i@@ ; @@i@@ = re_node_set_contains ( @@a2@@ , @@v10@@ ) ) { if ( @@a5@@ == * ( unsigned __int8 * ) ( Number * @@v10@@ + * @@a1@@ + Number ) && @@a4@@ == * ( _QWORD * ) ( Number * @@v10@@ + * @@a1@@ ) ) { if ( @@a5@@ == Number && ! re_node_set_insert ( @@a2@@ , @@v10@@ ) ) return Number L ; return Number L ; } if ( ! re_node_set_insert ( @@a2@@ , @@v10@@ ) ) return Number L ; if ( ! * ( _QWORD * ) ( @@a1@@ [ Number ] + Number * @@v10@@ + Number ) ) return Number L ; if ( * ( _QWORD * ) ( @@a1@@ [ Number ] + Number * @@v10@@ + Number ) == Number L ) { @@v9@@ = check_arrival_expand_ecl_sub ( @@a1@@ , @@a2@@ , * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ [ Number ] + Number * @@v10@@ + Number ) + Number L ) , @@a4@@ , @@a5@@ ) ; if ( @@v9@@ ) return @@v9@@ ; } @@v10@@ = * * ( _QWORD * * ) ( @@a1@@ [ Number ] + Number * @@v10@@ + Number ) ; } return Number L ; }
__int64 __fastcall advance ( char @@a1@@ ) { __int64 @@result@@ ; @@result@@ = ( unsigned int ) ++ pos ; if ( @@a1@@ ) { @@result@@ = ( unsigned int ) argc ; if ( pos >= argc ) beyond ( ) ; } return @@result@@ ; }
__int64 __fastcall sortlines ( unsigned __int8 * * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 * * @@a3@@ ) { __int64 @@result@@ ; unsigned __int8 * * @@v4@@ ; unsigned __int8 * @@v5@@ ; unsigned __int8 * @@v6@@ ; unsigned __int8 * * @@v7@@ ; unsigned __int8 * * @@v8@@ ; unsigned __int8 * @@v9@@ ; unsigned __int8 * @@v10@@ ; __int64 @@v12@@ ; __int64 @@v13@@ ; unsigned __int8 * * @@v14@@ ; unsigned __int8 * @@v15@@ ; unsigned __int8 * @@v16@@ ; __int64 @@v17@@ ; unsigned __int8 * @@v18@@ ; if ( @@a2@@ == Number ) { @@result@@ = compare ( @@a1@@ - Number , @@a1@@ - Number ) ; if ( ( int ) @@result@@ > Number ) { @@v15@@ = * ( @@a1@@ - Number ) ; @@v16@@ = * ( @@a1@@ - Number ) ; @@v17@@ = ( __int64 ) * ( @@a1@@ - Number ) ; @@v18@@ = * ( @@a1@@ - Number ) ; @@v4@@ = @@a1@@ - Number ; @@v5@@ = * ( @@a1@@ - Number ) ; * @@v4@@ = * ( @@a1@@ - Number ) ; @@v4@@ [ Number ] = @@v5@@ ; @@v6@@ = * ( @@a1@@ - Number ) ; @@v4@@ [ Number ] = * ( @@a1@@ - Number ) ; @@v4@@ [ Number ] = @@v6@@ ; @@v7@@ = @@a1@@ - Number ; * @@v7@@ = @@v15@@ ; @@v7@@ [ Number ] = @@v16@@ ; @@result@@ = @@v17@@ ; @@v7@@ [ Number ] = ( unsigned __int8 * ) @@v17@@ ; @@v7@@ [ Number ] = @@v18@@ ; } } else { @@v12@@ = @@a2@@ >> Number ; @@v13@@ = @@a2@@ - ( @@a2@@ >> Number ) ; @@v14@@ = & @@a1@@ [ Number * ( @@a2@@ >> Number ) ] ; sortlines ( @@v14@@ , @@v13@@ , @@a3@@ ) ; if ( @@a2@@ >> Number <= Number ) { @@v8@@ = @@a3@@ - Number ; @@v9@@ = * ( @@a1@@ - Number ) ; * @@v8@@ = * ( @@a1@@ - Number ) ; @@v8@@ [ Number ] = @@v9@@ ; @@v10@@ = * ( @@a1@@ - Number ) ; @@v8@@ [ Number ] = * ( @@a1@@ - Number ) ; @@v8@@ [ Number ] = @@v10@@ ; } else { sortlines_temp ( @@a1@@ , @@v12@@ , @@a3@@ ) ; } @@result@@ = ( __int64 ) mergelines ( @@a1@@ , @@a3@@ , @@v12@@ , @@v14@@ , @@v13@@ ) ; } return @@result@@ ; }
__int64 __fastcall key_init ( __int64 @@a1@@ ) { memset ( ( void * ) @@a1@@ , Number , Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number ; * ( _DWORD * ) ( @@a1@@ + Number ) = Number ; return @@a1@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return xmalloc ( @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall extend_buffers ( __int64 @@a1@@ ) { unsigned int @@v2@@ ; unsigned int @@v3@@ ; void * @@v4@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) > Number ) return Number L ; @@v2@@ = re_string_realloc_buffers ( @@a1@@ , Number L * * ( _QWORD * ) ( @@a1@@ + Number ) ) ; if ( @@v2@@ ) return @@v2@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) { @@v4@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number * ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L ) ) ; if ( ! @@v4@@ ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v4@@ ; } if ( * ( _BYTE * ) ( @@a1@@ + Number ) ) { if ( * ( int * ) ( @@a1@@ + Number ) <= Number ) { build_upper_buffer ( ( _QWORD * ) @@a1@@ ) ; } else { @@v3@@ = build_wcs_upper_buffer ( @@a1@@ ) ; if ( @@v3@@ ) return @@v3@@ ; } } else if ( * ( int * ) ( @@a1@@ + Number ) <= Number ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) re_string_translate_buffer ( ( _QWORD * ) @@a1@@ ) ; } else { build_wcs_buffer ( @@a1@@ ) ; } return Number L ; }
__int64 __fastcall test_unop ( _BYTE * @@a1@@ ) { __int64 @@result@@ ; if ( * @@a1@@ != Number ) return Number L ; switch ( @@a1@@ [ Number ] ) { case String : case String : case String : case String : case String : case String : case String : case String : case String : case String : case String : case String : case String : case String : case String : case String : case String : case String : case String : case String : case String : case String : case String : case String : @@result@@ = Number L ; break ; default : @@result@@ = Number L ; break ; } return @@result@@ ; }
void __fastcall __noreturn incompatible_options ( __int64 @@a1@@ ) { char * @@v1@@ ; @@v1@@ = gettext ( String ) ; error ( Number , Number , @@v1@@ , @@a1@@ ) ; abort ( ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
void * __fastcall sift_ctx_init ( _QWORD * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ ) { * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@a3@@ ; @@a1@@ [ Number ] = @@a4@@ ; @@a1@@ [ Number ] = @@a5@@ ; return memset ( @@a1@@ + Number , Number , Number ) ; }
int __fastcall sighandler ( int @@a1@@ ) { cleanup ( ) ; signal ( @@a1@@ , Number L ) ; return raise ( @@a1@@ ) ; }
_BYTE * __fastcall match_suffix ( _BYTE * * @@a1@@ ) { char @@v2@@ ; _BYTE * @@v3@@ ; @@v3@@ = Number L ; @@v2@@ = Number ; while ( * * @@a1@@ ) { if ( @@v2@@ ) { @@v2@@ = Number ; if ( ( unsigned __int8 ) c_isalpha ( ( unsigned int ) ( char ) * * @@a1@@ ) != Number && * * @@a1@@ != Number ) { @@v3@@ = Number L ; } } else if ( * * @@a1@@ == Number ) { @@v2@@ = Number ; if ( ! @@v3@@ ) @@v3@@ = * @@a1@@ ; } else if ( ( unsigned __int8 ) c_isalnum ( ( unsigned int ) ( char ) * * @@a1@@ ) != Number && * * @@a1@@ != Number ) { @@v3@@ = Number L ; } ++ * @@a1@@ ; } return @@v3@@ ; }
_BOOL8 __fastcall posixtest ( int @@a1@@ ) { bool @@v2@@ ; if ( @@a1@@ == Number ) return two_arguments ( ) ; if ( @@a1@@ > Number ) { if ( @@a1@@ == Number ) return ( bool ) three_arguments ( ) ; if ( @@a1@@ == Number ) { if ( ! strcmp ( * ( const char * * ) ( Number L * pos + argv ) , String ) ) { advance ( Number ) ; return ( unsigned __int8 ) three_arguments ( ) == Number ; } if ( ! strcmp ( * ( const char * * ) ( Number L * pos + argv ) , String ) && ! strcmp ( * ( const char * * ) ( Number * ( pos + Number L ) + argv ) , String ) ) { advance ( Number ) ; @@v2@@ = two_arguments ( ) ; advance ( Number ) ; return @@v2@@ ; } } } else if ( @@a1@@ == Number ) { return one_argument ( ) ; } if ( @@a1@@ <= Number ) abort ( ) ; return ( bool ) expr ( ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
_BYTE * __fastcall set_ordering ( _BYTE * @@a1@@ , __int64 @@a2@@ , int @@a3@@ ) { while ( Number ) { if ( * @@a1@@ ) { switch ( * @@a1@@ ) { case String : * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; goto LABEL_21 ; case String : * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; goto LABEL_21 ; case String : * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; goto LABEL_21 ; case String : if ( ! @@a3@@ || @@a3@@ == Number ) * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; if ( @@a3@@ == Number || @@a3@@ == Number ) * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; goto LABEL_21 ; case String : * ( _QWORD * ) ( @@a2@@ + Number ) = nondictionary ; goto LABEL_21 ; case String : * ( _QWORD * ) ( @@a2@@ + Number ) = fold_toupper ; goto LABEL_21 ; case String : * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; goto LABEL_21 ; case String : * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; goto LABEL_21 ; case String : if ( ! * ( _QWORD * ) ( @@a2@@ + Number ) ) * ( _QWORD * ) ( @@a2@@ + Number ) = nonprinting ; goto LABEL_21 ; case String : * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; goto LABEL_21 ; case String : * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; LABEL_21 : ++ @@a1@@ ; continue ; default : return @@a1@@ ; } } return @@a1@@ ; } }
__int64 __fastcall verrevcmp ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , unsigned __int64 @@a4@@ ) { int @@v4@@ ; int @@v5@@ ; unsigned int @@v9@@ ; int @@v10@@ ; unsigned __int64 @@v11@@ ; unsigned __int64 @@v12@@ ; @@v11@@ = Number L ; @@v12@@ = Number L ; while ( @@v11@@ < @@a2@@ || @@v12@@ < @@a4@@ ) { @@v9@@ = Number ; while ( @@v11@@ < @@a2@@ && ( unsigned __int8 ) c_isdigit ( ( unsigned int ) * ( char * ) ( @@a1@@ + @@v11@@ ) ) != Number || @@v12@@ < @@a4@@ && ( unsigned __int8 ) c_isdigit ( ( unsigned int ) * ( char * ) ( @@a3@@ + @@v12@@ ) ) != Number ) { if ( @@v11@@ == @@a2@@ ) @@v4@@ = Number ; else @@v4@@ = order ( * ( _BYTE * ) ( @@a1@@ + @@v11@@ ) ) ; @@v10@@ = @@v4@@ ; if ( @@v12@@ == @@a4@@ ) @@v5@@ = Number ; else @@v5@@ = order ( * ( _BYTE * ) ( @@a3@@ + @@v12@@ ) ) ; if ( @@v10@@ != @@v5@@ ) return ( unsigned int ) ( @@v10@@ - @@v5@@ ) ; ++ @@v11@@ ; ++ @@v12@@ ; } while ( * ( _BYTE * ) ( @@a1@@ + @@v11@@ ) == Number ) ++ @@v11@@ ; while ( * ( _BYTE * ) ( @@a3@@ + @@v12@@ ) == Number ) ++ @@v12@@ ; while ( ( unsigned __int8 ) c_isdigit ( ( unsigned int ) * ( char * ) ( @@a1@@ + @@v11@@ ) ) && ( unsigned __int8 ) c_isdigit ( ( unsigned int ) * ( char * ) ( @@a3@@ + @@v12@@ ) ) ) { if ( ! @@v9@@ ) @@v9@@ = * ( char * ) ( @@a1@@ + @@v11@@ ) - * ( char * ) ( @@a3@@ + @@v12@@ ) ; ++ @@v11@@ ; ++ @@v12@@ ; } if ( ( unsigned __int8 ) c_isdigit ( ( unsigned int ) * ( char * ) ( @@a1@@ + @@v11@@ ) ) ) return Number L ; if ( ( unsigned __int8 ) c_isdigit ( ( unsigned int ) * ( char * ) ( @@a3@@ + @@v12@@ ) ) ) return Number ; if ( @@v9@@ ) return @@v9@@ ; } return Number L ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
void __fastcall __noreturn randread_error ( __int64 @@a1@@ ) { __int64 @@v1@@ ; const char * @@v2@@ ; char * @@v3@@ ; int * @@v4@@ ; if ( @@a1@@ ) { @@v1@@ = quotearg_colon ( @@a1@@ ) ; if ( * __errno_location ( ) ) @@v2@@ = String ; else @@v2@@ = String ; @@v3@@ = gettext ( @@v2@@ ) ; @@v4@@ = __errno_location ( ) ; error ( exit_failure , * @@v4@@ , @@v3@@ , @@v1@@ ) ; } abort ( ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
_QWORD * __fastcall simple_new ( __int64 @@a1@@ , __int64 @@a2@@ ) { _QWORD * @@result@@ ; @@result@@ = ( _QWORD * ) xmalloc ( Number L ) ; * @@result@@ = @@a1@@ ; @@result@@ [ Number ] = randread_error ; @@result@@ [ Number ] = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
__int64 __fastcall next_prime ( unsigned __int64 @@a1@@ ) { __int64 @@v2@@ ; __int64 @@i@@ ; @@v2@@ = @@a1@@ ; if ( @@a1@@ <= Number ) @@v2@@ = Number L ; for ( @@i@@ = @@v2@@ | Number ; @@i@@ != Number && ! is_prime ( @@i@@ ) ; @@i@@ += Number L ) { ; } return @@i@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
int ferror ( FILE * @@stream@@ ) { return ferror ( @@stream@@ ) ; }
size_t __fastcall readsource ( __int64 @@a1@@ , char * @@a2@@ , size_t @@a3@@ ) { size_t @@result@@ ; int @@v4@@ ; int @@v7@@ ; size_t @@v8@@ ; while ( Number ) { @@v8@@ = fread_unlocked ( @@a2@@ , Number , @@a3@@ , * ( FILE * * ) @@a1@@ ) ; @@v7@@ = * __errno_location ( ) ; @@a2@@ += @@v8@@ ; @@result@@ = @@v8@@ ; @@a3@@ -= @@v8@@ ; if ( ! @@a3@@ ) break ; if ( ferror_unlocked ( * ( FILE * * ) @@a1@@ ) ) @@v4@@ = @@v7@@ ; else @@v4@@ = Number ; * __errno_location ( ) = @@v4@@ ; ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@a1@@ + Number ) ) ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ; } return @@result@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
__int64 __fastcall check_tuning ( __int64 @@a1@@ ) { __int64 @@v2@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( ( _UNKNOWN * ) @@v2@@ == & default_tuning ) return Number L ; if ( * ( float * ) ( @@v2@@ + Number ) > Number && ( float ) ( Number - Number ) > * ( float * ) ( @@v2@@ + Number ) && * ( float * ) ( @@v2@@ + Number ) > ( float ) ( Number + Number ) && * ( float * ) @@v2@@ >= Number && * ( float * ) ( @@v2@@ + Number ) > ( float ) ( * ( float * ) @@v2@@ + Number ) && * ( float * ) ( @@v2@@ + Number ) <= Number && * ( float * ) ( @@v2@@ + Number ) > ( float ) ( * ( float * ) @@v2@@ + Number ) ) { return Number L ; } * ( _QWORD * ) ( @@a1@@ + Number ) = & default_tuning ; return Number L ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
int clock_gettime ( clockid_t @@clock_id@@ , struct timespec * @@tp@@ ) { return clock_gettime ( @@clock_id@@ , @@tp@@ ) ; }
size_t * __fastcall readisaac ( size_t * @@a1@@ , char * @@a2@@ , size_t @@a3@@ ) { size_t * @@result@@ ; size_t @@i@@ ; char * @@v7@@ ; for ( @@i@@ = * @@a1@@ ; @@a3@@ > @@i@@ ; @@i@@ = Number L ) { memcpy ( @@a2@@ , ( char * ) @@a1@@ + Number - @@i@@ + Number , @@i@@ ) ; @@a2@@ += @@i@@ ; @@a3@@ -= @@i@@ ; if ( ( ( unsigned __int8 ) @@a2@@ & Number ) == Number ) { @@v7@@ = @@a2@@ ; while ( @@a3@@ > Number ) { isaac_refill ( @@a1@@ + Number , @@v7@@ ) ; @@v7@@ += Number ; @@a3@@ -= Number L ; if ( ! @@a3@@ ) { @@result@@ = @@a1@@ ; * @@a1@@ = Number L ; return @@result@@ ; } } @@a2@@ = @@v7@@ ; } isaac_refill ( @@a1@@ + Number , ( char * ) @@a1@@ + Number ) ; } memcpy ( @@a2@@ , ( char * ) @@a1@@ + Number - @@i@@ + Number , @@a3@@ ) ; @@result@@ = @@a1@@ ; * @@a1@@ = @@i@@ - @@a3@@ ; return @@result@@ ; }
char * nl_langinfo ( nl_item @@item@@ ) { return nl_langinfo ( @@item@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
int __lxstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _lxstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
size_t __fastcall randread ( _QWORD * @@a1@@ , char * @@a2@@ , size_t @@a3@@ ) { size_t @@result@@ ; if ( * @@a1@@ ) @@result@@ = readsource ( ( __int64 ) @@a1@@ , @@a2@@ , @@a3@@ ) ; else @@result@@ = ( size_t ) readisaac ( @@a1@@ + Number , @@a2@@ , @@a3@@ ) ; return @@result@@ ; }
void * malloc ( size_t @@size@@ ) { return __imp_malloc ( @@size@@ ) ; }
void __fastcall hash_free ( __int64 @@a1@@ ) { _QWORD * @@i@@ ; _QWORD * @@j@@ ; _QWORD * @@ptr@@ ; _QWORD * @@ptra@@ ; _QWORD * @@ptrb@@ ; _QWORD * @@v6@@ ; _QWORD * @@v7@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) && * ( _QWORD * ) ( @@a1@@ + Number ) ) { for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@ptr@@ = @@i@@ ; @@ptr@@ ; @@ptr@@ = ( _QWORD * ) @@ptr@@ [ Number ] ) { ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@ptr@@ ) ; } } } } for ( @@j@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@j@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@j@@ += Number ) { for ( @@ptra@@ = ( _QWORD * ) @@j@@ [ Number ] ; @@ptra@@ ; @@ptra@@ = @@v6@@ ) { @@v6@@ = ( _QWORD * ) @@ptra@@ [ Number ] ; free ( @@ptra@@ ) ; } } for ( @@ptrb@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; @@ptrb@@ ; @@ptrb@@ = @@v7@@ ) { @@v7@@ = ( _QWORD * ) @@ptrb@@ [ Number ] ; free ( @@ptrb@@ ) ; } free ( * ( void * * ) @@a1@@ ) ; free ( ( void * ) @@a1@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
int __fastcall randread_free ( FILE * * @@a1@@ ) { int @@result@@ ; FILE * @@stream@@ ; @@stream@@ = * @@a1@@ ; memset ( @@a1@@ , Number , Number ) ; free ( @@a1@@ ) ; if ( @@stream@@ ) @@result@@ = fclose ( @@stream@@ ) ; else @@result@@ = Number ; return @@result@@ ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
int __fxstat ( int @@ver@@ , int @@fildes@@ , struct stat * @@stat_buf@@ ) { return _fxstat ( @@ver@@ , @@fildes@@ , @@stat_buf@@ ) ; }
__int64 __fastcall hash_rehash ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; unsigned __int64 @@nmemb@@ ; void * @@v4@@ ; __int64 @@v5@@ ; unsigned __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; __int64 @@v12@@ ; __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; @@v14@@ = __readfsqword ( Number ) ; @@nmemb@@ = compute_bucket_size ( @@a2@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ; if ( ! @@nmemb@@ ) return Number L ; if ( @@nmemb@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; @@v4@@ = calloc ( @@nmemb@@ , Number ) ; if ( ! @@v4@@ ) return Number L ; @@v6@@ = @@nmemb@@ ; @@v5@@ = ( __int64 ) @@v4@@ + Number * @@nmemb@@ ; @@v7@@ = Number L ; @@v8@@ = Number L ; @@v9@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v10@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v11@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v12@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v13@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( ( unsigned __int8 ) transfer_entries ( ( __int64 ) & @@v4@@ , @@a1@@ , Number ) ) { free ( * ( void * * ) @@a1@@ ) ; * ( _QWORD * ) @@a1@@ = @@v4@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v5@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v6@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v7@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v13@@ ; @@result@@ = Number L ; } else { * ( _QWORD * ) ( @@a1@@ + Number ) = @@v13@@ ; if ( ( unsigned __int8 ) transfer_entries ( @@a1@@ , ( __int64 ) & @@v4@@ , Number ) != Number || ( unsigned __int8 ) transfer_entries ( @@a1@@ , ( __int64 ) & @@v4@@ , Number ) != Number ) { abort ( ) ; } free ( @@v4@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
FILE * __fastcall xfopen ( char * @@a1@@ , _BYTE * @@a2@@ ) { char * @@v2@@ ; FILE * @@v4@@ ; @@v4@@ = stream_open ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) { @@v2@@ = gettext ( String ) ; die ( @@v2@@ , @@a1@@ ) ; } return @@v4@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
_DWORD * __fastcall isaac_seed_data ( _DWORD * @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { _DWORD * @@result@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@j@@ ; unsigned __int64 @@k@@ ; char * @@v9@@ ; char * @@v10@@ ; for ( @@i@@ = Number L - ( unsigned int ) @@a1@@ [ Number ] ; @@a3@@ > @@i@@ ; @@i@@ = Number L ) { @@v9@@ = ( char * ) @@a1@@ + ( unsigned int ) @@a1@@ [ Number ] ; for ( @@j@@ = Number L ; @@j@@ < @@i@@ ; ++ @@j@@ ) @@v9@@ [ @@j@@ ] ^= * ( _BYTE * ) ( @@a2@@ + @@j@@ ) ; @@a2@@ += @@i@@ ; @@a3@@ -= @@i@@ ; isaac_mix ( @@a1@@ , ( __int64 ) @@a1@@ ) ; @@a1@@ [ Number ] = Number ; } @@v10@@ = ( char * ) @@a1@@ + ( unsigned int ) @@a1@@ [ Number ] ; for ( @@k@@ = Number L ; @@k@@ < @@a3@@ ; ++ @@k@@ ) @@v10@@ [ @@k@@ ] ^= * ( _BYTE * ) ( @@a2@@ + @@k@@ ) ; @@result@@ = @@a1@@ ; @@a1@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall umaxtostr ( unsigned __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v4@@ ; @@v4@@ = @@a2@@ + Number ; * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; do { * ( _BYTE * ) -- @@v4@@ = @@a1@@ % Number + Number ; @@a1@@ /= Number ; } while ( @@a1@@ ) ; return @@v4@@ ; }
unsigned __int64 __fastcall md5_process_bytes ( char * @@a1@@ , unsigned __int64 @@a2@@ , unsigned int * @@a3@@ ) { unsigned __int64 @@result@@ ; size_t @@v4@@ ; void * @@v5@@ ; size_t @@v7@@ ; char * @@src@@ ; size_t @@v9@@ ; size_t @@v10@@ ; __int64 @@v11@@ ; size_t @@n@@ ; @@src@@ = @@a1@@ ; @@v7@@ = @@a2@@ ; @@result@@ = @@a3@@ [ Number ] ; if ( ( _DWORD ) @@result@@ ) { @@v11@@ = @@a3@@ [ Number ] ; @@v4@@ = Number - @@v11@@ ; if ( @@a2@@ <= Number - @@v11@@ ) @@v4@@ = @@a2@@ ; @@n@@ = @@v4@@ ; memcpy ( ( char * ) @@a3@@ + @@v11@@ + Number , @@a1@@ , @@v4@@ ) ; @@a3@@ [ Number ] += @@n@@ ; if ( @@a3@@ [ Number ] > Number ) { md5_process_block ( @@a3@@ + Number , @@a3@@ [ Number ] & Number , @@a3@@ ) ; @@a3@@ [ Number ] &= Number ; memcpy ( @@a3@@ + Number , ( char * ) @@a3@@ + ( ( @@v11@@ + @@n@@ ) & Number ) + Number , @@a3@@ [ Number ] ) ; } @@src@@ = & @@a1@@ [ @@n@@ ] ; @@result@@ = @@n@@ ; @@v7@@ = @@a2@@ - @@n@@ ; } if ( @@v7@@ > Number ) { @@result@@ = ( unsigned __int8 ) @@src@@ & Number ; if ( ( ( unsigned __int8 ) @@src@@ & Number ) != Number ) { while ( @@v7@@ > Number ) { @@v5@@ = memcpy ( @@a3@@ + Number , @@src@@ , Number ) ; @@result@@ = md5_process_block ( @@v5@@ , Number L , @@a3@@ ) ; @@src@@ += Number ; @@v7@@ -= Number L ; } } else { md5_process_block ( @@src@@ , @@v7@@ & Number , @@a3@@ ) ; @@result@@ = @@v7@@ & Number ; @@src@@ += @@v7@@ & Number ; @@v7@@ &= Number ; } } if ( @@v7@@ ) { @@v9@@ = @@a3@@ [ Number ] ; memcpy ( ( char * ) @@a3@@ + @@v9@@ + Number , @@src@@ , @@v7@@ ) ; @@v10@@ = @@v7@@ + @@v9@@ ; if ( @@v10@@ > Number ) { md5_process_block ( @@a3@@ + Number , Number L , @@a3@@ ) ; @@v10@@ -= Number L ; memcpy ( @@a3@@ + Number , @@a3@@ + Number , @@v10@@ ) ; } @@result@@ = ( unsigned __int64 ) @@a3@@ ; @@a3@@ [ Number ] = @@v10@@ ; } return @@result@@ ; }
unsigned __int64 __fastcall isaac_seed ( _DWORD * @@a1@@ ) { __int64 @@v2@@ ; unsigned __int64 @@v3@@ ; @@v3@@ = __readfsqword ( Number ) ; isaac_seed_start ( @@a1@@ ) ; LODWORD ( @@v2@@ ) = getpid ( ) ; isaac_seed_data ( @@a1@@ , ( __int64 ) & @@v2@@ , Number ) ; LODWORD ( @@v2@@ ) = getppid ( ) ; isaac_seed_data ( @@a1@@ , ( __int64 ) & @@v2@@ , Number ) ; LODWORD ( @@v2@@ ) = getuid ( ) ; isaac_seed_data ( @@a1@@ , ( __int64 ) & @@v2@@ , Number ) ; LODWORD ( @@v2@@ ) = getgid ( ) ; isaac_seed_data ( @@a1@@ , ( __int64 ) & @@v2@@ , Number ) ; @@v2@@ = gethrxtime ( ) ; isaac_seed_data ( @@a1@@ , ( __int64 ) & @@v2@@ , Number ) ; isaac_seed_finish ( @@a1@@ ) ; return __readfsqword ( Number ) ^ @@v3@@ ; }
__int64 __fastcall open_temp ( const char * @@a1@@ , unsigned int @@a2@@ ) { int @@v3@@ ; char * @@v4@@ ; char * @@v5@@ ; int * @@v6@@ ; char * @@v7@@ ; char * @@v8@@ ; int * @@v9@@ ; int @@fd@@ ; _BYTE @@v11@@ [ Number ] ; int @@v12@@ ; int @@v13@@ ; unsigned __int64 @@v14@@ ; @@v14@@ = __readfsqword ( Number ) ; * ( _QWORD * ) & @@v11@@ [ Number ] = Number L ; wait_proc ( @@a2@@ ) ; @@fd@@ = open ( @@a1@@ , Number ) ; if ( @@fd@@ < Number ) return Number L ; @@v3@@ = pipe_fork ( & @@v12@@ , Number L ) ; if ( @@v3@@ == Number ) { if ( * __errno_location ( ) != Number ) { @@v4@@ = compress_program ; @@v5@@ = gettext ( String ) ; @@v6@@ = __errno_location ( ) ; error ( Number , * @@v6@@ , @@v5@@ , @@v4@@ ) ; } close ( @@fd@@ ) ; * __errno_location ( ) = Number ; } else { if ( ! @@v3@@ ) { close ( @@v12@@ ) ; dup2_or_die ( @@fd@@ , Number ) ; close ( @@fd@@ ) ; dup2_or_die ( @@v13@@ , Number ) ; close ( @@v13@@ ) ; execlp ( compress_program , compress_program , String , Number L ) ; @@v7@@ = compress_program ; @@v8@@ = gettext ( String ) ; @@v9@@ = __errno_location ( ) ; error ( Number , * @@v9@@ , @@v8@@ , @@v7@@ ) ; } close ( @@fd@@ ) ; close ( @@v13@@ ) ; * ( _QWORD * ) & @@v11@@ [ Number ] = fdopen ( @@v12@@ , String ) ; if ( ! * ( _QWORD * ) & @@v11@@ [ Number ] ) { * ( _QWORD * ) @@v11@@ = ( unsigned int ) * __errno_location ( ) ; close ( @@v12@@ ) ; * __errno_location ( ) = * ( _DWORD * ) @@v11@@ ; } } return * ( _QWORD * ) & @@v11@@ [ Number ] ; }
int __fastcall readtokens0_init ( __int64 @@a1@@ ) { * ( _QWORD * ) @@a1@@ = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; _obstack_begin ( ( struct obstack * ) ( @@a1@@ + Number ) , Number , Number , ( void * ( * ) ( __int64 ) ) & malloc , ( void ( * ) ( void * ) ) & free ) ; _obstack_begin ( ( struct obstack * ) ( @@a1@@ + Number ) , Number , Number , ( void * ( * ) ( __int64 ) ) & malloc , ( void ( * ) ( void * ) ) & free ) ; return _obstack_begin ( ( struct obstack * ) ( @@a1@@ + Number ) , Number , Number , ( void * ( * ) ( __int64 ) ) & malloc , ( void ( * ) ( void * ) ) & free ) ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return xmalloc ( @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall dosync ( int @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; char * @@v3@@ ; char * @@v4@@ ; int @@errnum@@ ; int @@errnuma@@ ; if ( ! fdatasync ( @@a1@@ ) ) return Number L ; @@errnum@@ = * __errno_location ( ) ; if ( ! ignorable_sync_errno ( @@errnum@@ ) ) { @@v3@@ = gettext ( String ) ; error ( Number , @@errnum@@ , @@v3@@ , @@a2@@ ) ; * __errno_location ( ) = @@errnum@@ ; @@result@@ = Number ; } else if ( fsync ( @@a1@@ ) ) { @@errnuma@@ = * __errno_location ( ) ; if ( ! ignorable_sync_errno ( @@errnuma@@ ) ) { @@v4@@ = gettext ( String ) ; error ( Number , @@errnuma@@ , @@v4@@ , @@a2@@ ) ; * __errno_location ( ) = @@errnuma@@ ; @@result@@ = Number ; } else { sync ( ) ; @@result@@ = Number L ; } } else { @@result@@ = Number L ; } return @@result@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_21B138 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
__int64 __fastcall sort_buffer_size ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , unsigned __int64 @@a4@@ , __int64 @@a5@@ ) { unsigned int @@v5@@ ; __int64 @@v6@@ ; bool @@v7@@ ; char * @@v8@@ ; char * @@v9@@ ; __int64 @@v14@@ ; unsigned __int64 @@i@@ ; __off_t @@v16@@ ; unsigned __int64 @@v17@@ ; unsigned __int64 @@v18@@ ; struct stat @@v19@@ ; unsigned __int64 @@v20@@ ; @@v20@@ = __readfsqword ( Number ) ; @@v17@@ = @@a5@@ + Number ; @@v14@@ = @@a5@@ + Number ; for ( @@i@@ = Number L ; @@i@@ < @@a4@@ ; ++ @@i@@ ) { if ( @@i@@ >= @@a2@@ ) { if ( ! strcmp ( * ( const char * * ) ( Number * @@i@@ + @@a3@@ ) , String ) ) { @@v6@@ = Number L ; @@v7@@ = ( unsigned int ) fstat ( Number , & @@v19@@ ) != Number ; } else { @@v6@@ = * ( _QWORD * ) ( Number * @@i@@ + @@a3@@ ) ; @@v7@@ = ( unsigned int ) stat ( ( char * ) @@v6@@ , & @@v19@@ ) != Number ; } } else { @@v5@@ = fileno ( * ( FILE * * ) ( Number * @@i@@ + @@a1@@ ) ) ; @@v6@@ = @@v5@@ ; @@v7@@ = ( unsigned int ) fstat ( @@v5@@ , & @@v19@@ ) != Number ; } if ( @@v7@@ ) { @@v8@@ = * ( char * * ) ( Number * @@i@@ + @@a3@@ ) ; @@v9@@ = gettext ( String ) ; die ( @@v9@@ , @@v8@@ ) ; } if ( ( @@v19@@ . st_mode & Number ) == Number ) { @@v16@@ = @@v19@@ . st_size ; } else { if ( sort_size ) return sort_size ; @@v16@@ = Number ; } if ( ! size_bound_6757 ) { size_bound_6757 = sort_size ; if ( ! sort_size ) size_bound_6757 = default_sort_size ( @@v6@@ , ( __int64 ) & @@v19@@ ) ; } @@v18@@ = @@v17@@ * @@v16@@ + Number ; if ( @@v18@@ / @@v17@@ != @@v16@@ || @@v18@@ >= size_bound_6757 - @@v14@@ ) { return size_bound_6757 ; } @@v14@@ += @@v18@@ ; } return @@v14@@ ; }
__int64 __fastcall wipefile ( const char * @@a1@@ , const char * @@a2@@ , __int64 @@a3@@ , _BYTE * @@a4@@ , int @@a5@@ , int @@a6@@ ) { int @@v6@@ ; int @@v7@@ ; int @@v8@@ ; int @@v9@@ ; char * @@v10@@ ; int * @@v11@@ ; __int64 @@result@@ ; char * @@v13@@ ; int * @@v14@@ ; unsigned __int8 @@v17@@ ; int @@fd@@ ; @@fd@@ = open_safer ( ( _DWORD ) @@a1@@ , Number , @@a3@@ , ( _DWORD ) @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( @@fd@@ < Number && * __errno_location ( ) == Number && * @@a4@@ && ! chmod ( @@a1@@ , Number ) ) @@fd@@ = open_safer ( ( _DWORD ) @@a1@@ , Number , @@v6@@ , @@v7@@ , @@v8@@ , @@v9@@ ) ; if ( @@fd@@ >= Number ) { @@v17@@ = do_wipefd ( @@fd@@ , ( __int64 ) @@a2@@ , @@a3@@ , ( __int64 ) @@a4@@ ) ; if ( close ( @@fd@@ ) ) { @@v13@@ = gettext ( String ) ; @@v14@@ = __errno_location ( ) ; error ( Number , * @@v14@@ , @@v13@@ , @@a2@@ ) ; @@v17@@ = Number ; } if ( @@v17@@ ) { if ( @@a4@@ [ Number ] ) @@v17@@ = wipename ( @@a1@@ , @@a2@@ , ( __int64 ) @@a4@@ ) ; } @@result@@ = @@v17@@ ; } else { @@v10@@ = gettext ( String ) ; @@v11@@ = __errno_location ( ) ; error ( Number , * @@v11@@ , @@v10@@ , @@a2@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
unsigned __int64 __fastcall save_token ( __int64 @@a1@@ ) { __int64 @@src@@ [ Number ] ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; struct obstack * @@v6@@ ; struct obstack * @@v7@@ ; struct obstack * @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@src@@ [ Number ] = @@a1@@ + Number ; @@src@@ [ Number ] = ( unsigned int ) ( * ( _DWORD * ) ( @@a1@@ + Number ) - * ( _DWORD * ) ( @@a1@@ + Number ) - Number ) ; @@v3@@ = @@a1@@ + Number ; @@v4@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( @@v4@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ) * ( _BYTE * ) ( @@v3@@ + Number ) |= Number ; * ( _QWORD * ) ( @@v3@@ + Number ) = ( * ( int * ) ( @@v3@@ + Number ) + * ( _QWORD * ) ( @@v3@@ + Number ) ) & ~ * ( _DWORD * ) ( @@v3@@ + Number ) ; if ( * ( _QWORD * ) ( @@v3@@ + Number ) - * ( _QWORD * ) ( @@v3@@ + Number ) > * ( _QWORD * ) ( @@v3@@ + Number ) - * ( _QWORD * ) ( @@v3@@ + Number ) ) * ( _QWORD * ) ( @@v3@@ + Number ) = * ( _QWORD * ) ( @@v3@@ + Number ) ; * ( _QWORD * ) ( @@v3@@ + Number ) = * ( _QWORD * ) ( @@v3@@ + Number ) ; @@v5@@ = @@v4@@ ; @@v6@@ = ( struct obstack * ) ( @@a1@@ + Number ) ; if ( ( unsigned __int64 ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L ) > * ( _QWORD * ) ( @@a1@@ + Number ) ) _obstack_newchunk ( @@v6@@ , Number ) ; @@v7@@ = @@v6@@ ; * ( _QWORD * ) @@v6@@ -> next_free = @@v5@@ ; @@v7@@ -> next_free += Number ; @@v8@@ = ( struct obstack * ) ( @@a1@@ + Number ) ; if ( ( unsigned __int64 ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L ) > * ( _QWORD * ) ( @@a1@@ + Number ) ) _obstack_newchunk ( @@v8@@ , Number ) ; memcpy ( @@v8@@ -> next_free , @@src@@ , Number ) ; @@v8@@ -> next_free += Number ; ++ * ( _QWORD * ) @@a1@@ ; return __readfsqword ( Number ) ^ @@v9@@ ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
__int64 __fastcall fraccompare ( _BYTE * @@a1@@ , _BYTE * @@a2@@ , char @@a3@@ ) { _BYTE * @@v4@@ ; _BYTE * @@v5@@ ; @@v5@@ = @@a1@@ ; @@v4@@ = @@a2@@ ; if ( @@a3@@ == * @@a1@@ && @@a3@@ == * @@a2@@ ) { while ( * ++ @@v5@@ == * ++ @@v4@@ ) { if ( ( unsigned int ) ( ( char ) * @@v5@@ - Number ) > Number ) return Number L ; } if ( ( unsigned int ) ( ( char ) * @@v5@@ - Number ) <= Number && ( unsigned int ) ( ( char ) * @@v4@@ - Number ) <= Number ) { return ( unsigned int ) ( ( char ) * @@v5@@ - ( char ) * @@v4@@ ) ; } if ( ( unsigned int ) ( ( char ) * @@v5@@ - Number ) > Number ) { if ( ( unsigned int ) ( ( char ) * @@v4@@ - Number ) > Number ) return Number L ; LABEL_23 : while ( * @@v4@@ == Number ) ++ @@v4@@ ; return ( unsigned int ) - ( ( unsigned int ) ( ( char ) * @@v4@@ - Number ) <= Number ) ; } } else { @@v5@@ = @@a1@@ + Number ; if ( @@a3@@ != * @@a1@@ ) { @@v4@@ = @@a2@@ + Number ; if ( @@a3@@ != * @@a2@@ ) return Number L ; goto LABEL_23 ; } } while ( * @@v5@@ == Number ) ++ @@v5@@ ; return ( unsigned int ) ( ( char ) * @@v5@@ - Number ) <= Number ; }
__int64 __fastcall numcompare ( unsigned __int8 * @@a1@@ , unsigned __int8 * @@a2@@ ) { while ( blanks [ ( unsigned __int8 ) to_uchar ( * @@a1@@ ) ] ) ++ @@a1@@ ; while ( blanks [ ( unsigned __int8 ) to_uchar ( * @@a2@@ ) ] ) ++ @@a2@@ ; return strnumcmp ( @@a1@@ , @@a2@@ , ( unsigned int ) decimal_point , ( unsigned int ) thousands_sep ) ; }
char * __fastcall randread_new ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { size_t @@v3@@ ; FILE * @@stream@@ ; char * @@v5@@ ; if ( ! @@a2@@ ) return ( char * ) simple_new ( Number L , Number L ) ; @@stream@@ = Number L ; if ( @@a1@@ ) { @@stream@@ = ( FILE * ) fopen_safer ( @@a1@@ , & off_AA73 ) ; if ( ! @@stream@@ ) return Number L ; } @@v5@@ = ( char * ) simple_new ( ( __int64 ) @@stream@@ , @@a1@@ ) ; if ( @@stream@@ ) { @@v3@@ = Number L ; if ( @@a2@@ <= Number ) @@v3@@ = @@a2@@ ; setvbuf ( @@stream@@ , @@v5@@ + Number , Number , @@v3@@ ) ; } else { * ( ( _QWORD * ) @@v5@@ + Number ) = Number L ; isaac_seed ( @@v5@@ + Number ) ; } return @@v5@@ ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
int __fastcall stat ( char * @@filename@@ , struct stat * @@stat_buf@@ ) { return __xstat ( Number , @@filename@@ , @@stat_buf@@ ) ; }
_BOOL8 __fastcall c_isspace ( int @@a1@@ ) { return @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number ; }
int __fastcall lstat ( char * @@filename@@ , struct stat * @@stat_buf@@ ) { return __lxstat ( Number , @@filename@@ , @@stat_buf@@ ) ; }
size_t __fastcall randread ( _QWORD * @@a1@@ , char * @@a2@@ , size_t @@a3@@ ) { size_t @@result@@ ; if ( * @@a1@@ ) @@result@@ = readsource ( ( __int64 ) @@a1@@ , @@a2@@ , @@a3@@ ) ; else @@result@@ = ( size_t ) readisaac ( @@a1@@ + Number , @@a2@@ , @@a3@@ ) ; return @@result@@ ; }
__int64 __fastcall find_unit_order ( unsigned __int8 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; int @@v4@@ ; int @@v5@@ ; unsigned __int8 * @@v6@@ ; @@v6@@ = @@a1@@ ; @@v4@@ = Number ; if ( * @@a1@@ == Number ) { @@v4@@ = Number ; @@v6@@ = @@a1@@ + Number ; } while ( ( unsigned int ) * @@v6@@ - Number <= Number ) { if ( * ++ @@v6@@ == decimal_point && ( unsigned int ) @@v6@@ [ Number ] - Number <= Number ) { @@v6@@ += Number ; } else if ( * @@v6@@ == thousands_sep && ( unsigned int ) @@v6@@ [ Number ] - Number <= Number ) { @@v6@@ += Number ; } } @@v2@@ = * @@v6@@ ; @@v5@@ = orders_6877 [ @@v2@@ ] ; if ( orders_6877 [ @@v2@@ ] ) check_mixed_SI_IEC ( @@v6@@ [ Number ] , @@a2@@ ) ; return ( unsigned int ) ( @@v5@@ * @@v4@@ ) ; }
_BOOL8 __fastcall c_isxdigit ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number || ( int ) ( @@a1@@ & Number ) > Number && ( int ) ( @@a1@@ & Number ) <= Number ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
unsigned __int64 __fastcall isaac_seed ( _DWORD * @@a1@@ ) { __int64 @@v2@@ ; unsigned __int64 @@v3@@ ; @@v3@@ = __readfsqword ( Number ) ; isaac_seed_start ( @@a1@@ ) ; LODWORD ( @@v2@@ ) = getpid ( ) ; isaac_seed_data ( @@a1@@ , ( __int64 ) & @@v2@@ , Number ) ; LODWORD ( @@v2@@ ) = getppid ( ) ; isaac_seed_data ( @@a1@@ , ( __int64 ) & @@v2@@ , Number ) ; LODWORD ( @@v2@@ ) = getuid ( ) ; isaac_seed_data ( @@a1@@ , ( __int64 ) & @@v2@@ , Number ) ; LODWORD ( @@v2@@ ) = getgid ( ) ; isaac_seed_data ( @@a1@@ , ( __int64 ) & @@v2@@ , Number ) ; @@v2@@ = gethrxtime ( ) ; isaac_seed_data ( @@a1@@ , ( __int64 ) & @@v2@@ , Number ) ; isaac_seed_finish ( @@a1@@ ) ; return __readfsqword ( Number ) ^ @@v3@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
__int64 __fastcall compare_random ( void * @@a1@@ , size_t @@a2@@ , void * @@a3@@ , __int64 @@a4@@ ) { size_t @@v4@@ ; char * @@v5@@ ; unsigned int @@v6@@ ; unsigned int @@v11@@ ; char * @@ptr@@ ; size_t @@v13@@ ; __int64 @@v14@@ ; char @@v15@@ [ Number ] ; unsigned __int64 @@v16@@ ; @@v16@@ = __readfsqword ( Number ) ; if ( hard_LC_COLLATE != Number ) return ( unsigned int ) cmp_hashes ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; @@v13@@ = xmemxfrm ( @@v15@@ , Number L , @@a1@@ , @@a2@@ ) ; if ( @@v13@@ > Number ) @@v4@@ = Number L ; else @@v4@@ = Number - @@v13@@ ; if ( @@v13@@ > Number ) @@v5@@ = Number L ; else @@v5@@ = & @@v15@@ [ @@v13@@ ] ; @@v14@@ = xmemxfrm ( @@v5@@ , @@v4@@ , @@a3@@ , @@a4@@ ) ; if ( @@v13@@ > Number || @@v13@@ + @@v14@@ > Number ) { @@ptr@@ = ( char * ) xmalloc ( @@v13@@ + @@v14@@ + Number ) ; xmemxfrm ( @@ptr@@ , @@v13@@ + Number , @@a1@@ , @@a2@@ ) ; xmemxfrm ( & @@ptr@@ [ @@v13@@ ] , @@v14@@ + Number , @@a3@@ , @@a4@@ ) ; @@v6@@ = cmp_hashes ( @@ptr@@ , @@v13@@ , & @@ptr@@ [ @@v13@@ ] , @@v14@@ ) ; } else { @@ptr@@ = @@v15@@ ; @@v6@@ = cmp_hashes ( @@ptr@@ , @@v13@@ , & @@ptr@@ [ @@v13@@ ] , @@v14@@ ) ; } @@v11@@ = @@v6@@ ; if ( @@ptr@@ != @@v15@@ ) free ( @@ptr@@ ) ; return @@v11@@ ; }
int __fastcall print_table_row ( int @@a1@@ , unsigned int @@a2@@ , int @@a3@@ , const char * @@a4@@ ) { const char * @@v4@@ ; char * @@v8@@ ; @@v8@@ = strsignal ( @@a2@@ ) ; if ( @@v8@@ ) @@v4@@ = @@v8@@ ; else @@v4@@ = String ; return printf ( String , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v4@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , off_AF5E , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
unsigned __int8 * __fastcall mergelines ( unsigned __int8 * * @@a1@@ , unsigned __int8 * * @@a2@@ , __int64 @@a3@@ , unsigned __int8 * * @@a4@@ , __int64 @@a5@@ ) { unsigned __int8 * @@v5@@ ; unsigned __int8 * @@result@@ ; unsigned __int8 * @@v7@@ ; unsigned __int8 * @@v8@@ ; unsigned __int8 * @@v9@@ ; unsigned __int8 * @@v10@@ ; unsigned __int8 * @@v11@@ ; do { while ( ( int ) compare ( @@a2@@ - Number , @@a4@@ - Number ) <= Number ) { @@a2@@ -= Number ; @@a1@@ -= Number ; @@v5@@ = @@a2@@ [ Number ] ; * @@a1@@ = * @@a2@@ ; @@a1@@ [ Number ] = @@v5@@ ; @@result@@ = @@a2@@ [ Number ] ; @@v7@@ = @@a2@@ [ Number ] ; @@a1@@ [ Number ] = @@result@@ ; @@a1@@ [ Number ] = @@v7@@ ; if ( ! -- @@a3@@ ) return @@result@@ ; } @@a4@@ -= Number ; @@a1@@ -= Number ; @@v8@@ = @@a4@@ [ Number ] ; * @@a1@@ = * @@a4@@ ; @@a1@@ [ Number ] = @@v8@@ ; @@v9@@ = @@a4@@ [ Number ] ; @@a1@@ [ Number ] = @@a4@@ [ Number ] ; @@a1@@ [ Number ] = @@v9@@ ; -- @@a5@@ ; } while ( @@a5@@ ) ; do { @@a2@@ -= Number ; @@a1@@ -= Number ; @@v10@@ = @@a2@@ [ Number ] ; * @@a1@@ = * @@a2@@ ; @@a1@@ [ Number ] = @@v10@@ ; @@result@@ = @@a2@@ [ Number ] ; @@v11@@ = @@a2@@ [ Number ] ; @@a1@@ [ Number ] = @@result@@ ; @@a1@@ [ Number ] = @@v11@@ ; -- @@a3@@ ; } while ( @@a3@@ ) ; return @@result@@ ; }
long double __fastcall adjust_value ( int @@a1@@ , long double @@a2@@ ) { _BOOL4 @@v7@@ ; unsigned __int64 @@v9@@ ; if ( @@a1@@ != Number && @@a2@@ < Number ) { if ( @@a2@@ >= Number ) @@v9@@ = ( __int64 ) ( @@a2@@ - Number ) ^ Number ; else @@v9@@ = ( __int64 ) @@a2@@ ; @@v7@@ = ! @@a1@@ && @@a2@@ != ( long double ) @@v9@@ ; @@a2@@ = ( long double ) ( @@v7@@ + @@v9@@ ) ; } return @@a2@@ ; }
__int64 __fastcall xmemcoll ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ ) { char * @@v4@@ ; char * @@v5@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; unsigned int @@v12@@ ; int @@errnum@@ ; @@v12@@ = memcoll ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; @@errnum@@ = * __errno_location ( ) ; if ( @@errnum@@ ) { @@v4@@ = gettext ( String ) ; error ( Number , @@errnum@@ , @@v4@@ ) ; @@v5@@ = gettext ( String ) ; error ( Number , Number , @@v5@@ ) ; @@v6@@ = quotearg_n_style_mem ( Number L , Number L , @@a3@@ , @@a4@@ ) ; @@v7@@ = quotearg_n_style_mem ( Number L , Number L , @@a1@@ , @@a2@@ ) ; @@v8@@ = gettext ( String ) ; error ( exit_failure , Number , @@v8@@ , @@v7@@ , @@v6@@ ) ; } return @@v12@@ ; }
__int64 __fastcall operand2sig ( const char * @@a1@@ , __int64 @@a2@@ ) { int @@v2@@ ; char * @@v3@@ ; unsigned int @@v5@@ ; int @@v6@@ ; char * @@endptr@@ ; _BYTE * @@i@@ ; void * @@ptr@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; @@v11@@ = __readfsqword ( Number ) ; if ( ( unsigned int ) ( * @@a1@@ - Number ) > Number ) { @@ptr@@ = ( void * ) xstrdup ( @@a1@@ ) ; for ( @@i@@ = @@ptr@@ ; * @@i@@ ; ++ @@i@@ ) { if ( strchr ( String , ( char ) * @@i@@ ) ) * @@i@@ -= Number ; } if ( ( unsigned int ) str2sig ( @@ptr@@ , & @@v5@@ ) && ( * ( _BYTE * ) @@ptr@@ != Number || * ( ( _BYTE * ) @@ptr@@ + Number ) != Number || * ( ( _BYTE * ) @@ptr@@ + Number ) != Number || ( unsigned int ) str2sig ( ( char * ) @@ptr@@ + Number , & @@v5@@ ) ) ) { @@v5@@ = Number ; } free ( @@ptr@@ ) ; } else { * __errno_location ( ) = Number ; @@v10@@ = strtol ( @@a1@@ , & @@endptr@@ , Number ) ; @@v6@@ = @@v10@@ ; if ( @@a1@@ == @@endptr@@ || * @@endptr@@ || * __errno_location ( ) || @@v10@@ != @@v6@@ ) { @@v2@@ = Number ; } else if ( ( char ) ( ( @@v6@@ & Number ) + Number ) >> Number <= Number ) { @@v2@@ = @@v6@@ ; } else { @@v2@@ = @@v6@@ & Number ; } @@v5@@ = @@v2@@ ; } if ( ( @@v5@@ & Number ) == Number && ! ( unsigned int ) sig2str ( @@v5@@ , @@a2@@ ) ) return @@v5@@ ; @@v3@@ = gettext ( String ) ; error ( Number , Number , @@v3@@ , @@a1@@ ) ; return Number ; }
int puts ( const char * @@s@@ ) { return puts ( @@s@@ ) ; }
__int64 __fastcall open_safer ( const char * @@a1@@ , char @@a2@@ , unsigned int @@a3@@ ) { unsigned int @@v3@@ ; unsigned int @@v5@@ ; @@v5@@ = Number ; if ( ( @@a2@@ & Number ) != Number ) @@v5@@ = @@a3@@ ; @@v3@@ = open ( @@a1@@ , @@a2@@ , @@v5@@ ) ; return fd_safer ( @@v3@@ ) ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( is_mul_ok ( @@a2@@ , * @@a1@@ ) ) { * @@a1@@ *= @@a2@@ ; @@result@@ = Number L ; } else { * @@a1@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
unsigned __int64 __fastcall avoid_trashing_input ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int64 @@a3@@ , char * @@a4@@ ) { bool @@v4@@ ; char @@v5@@ ; unsigned __int64 @@v6@@ ; unsigned __int64 @@v10@@ ; char @@v11@@ ; char @@v12@@ ; bool @@v13@@ ; int @@v14@@ ; FILE * @@v15@@ ; unsigned __int64 @@i@@ ; __int64 @@v17@@ ; char * @@v18@@ ; struct stat @@v19@@ ; struct stat @@v20@@ ; unsigned __int64 @@v21@@ ; @@v10@@ = @@a2@@ ; @@v21@@ = __readfsqword ( Number ) ; @@v11@@ = Number ; for ( @@i@@ = @@a2@@ ; @@i@@ < @@a3@@ ; ++ @@i@@ ) { @@v13@@ = strcmp ( * ( const char * * ) ( Number * @@i@@ + @@a1@@ ) , String ) == Number ; if ( @@a4@@ && ! strcmp ( @@a4@@ , * ( const char * * ) ( Number * @@i@@ + @@a1@@ ) ) && ! @@v13@@ ) { @@v12@@ = Number ; goto LABEL_21 ; } if ( @@v11@@ != Number ) { if ( @@a4@@ ) @@v4@@ = ( unsigned int ) stat ( @@a4@@ , & @@v19@@ ) != Number ; else @@v4@@ = ( unsigned int ) fstat ( Number , & @@v19@@ ) != Number ; if ( @@v4@@ ) return @@a3@@ ; @@v11@@ = Number ; } if ( @@v13@@ ) { if ( ( unsigned int ) fstat ( Number , & @@v20@@ ) ) goto LABEL_19 ; } else if ( ( unsigned int ) stat ( * ( char * * ) ( Number * @@i@@ + @@a1@@ ) , & @@v20@@ ) ) { goto LABEL_19 ; } if ( @@v20@@ . st_ino != @@v19@@ . st_ino || @@v20@@ . st_dev != @@v19@@ . st_dev ) { LABEL_19 : @@v5@@ = Number ; goto LABEL_20 ; } @@v5@@ = Number ; LABEL_20 : @@v12@@ = @@v5@@ & Number ; LABEL_21 : if ( @@v12@@ ) { @@v18@@ = create_temp ( & @@v15@@ , & @@v14@@ ) ; @@v17@@ = Number L ; do { @@v6@@ = mergefiles ( Number * @@i@@ + @@a1@@ , Number L , @@a3@@ - @@i@@ , @@v15@@ , @@v18@@ ) ; @@v17@@ += @@v6@@ ; * ( _QWORD * ) ( @@a1@@ + Number * @@i@@ ) = @@v18@@ ; * ( _DWORD * ) ( @@a1@@ + Number * @@i@@ + Number ) = @@v14@@ ; if ( @@a3@@ > @@i@@ + @@v17@@ ) memmove ( ( void * ) ( Number * ( @@i@@ + Number ) + @@a1@@ ) , ( const void * ) ( @@a1@@ + Number * ( @@i@@ + @@v17@@ ) ) , Number * @@v17@@ ) ; ++ @@v10@@ ; @@a3@@ = @@a3@@ - @@v17@@ + Number ; @@i@@ += @@v17@@ ; } while ( @@i@@ < @@a3@@ ) ; } } return @@a3@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
__int64 __fastcall bkm_scale_by_power ( unsigned __int64 * @@a1@@ , int @@a2@@ , int @@a3@@ ) { unsigned int @@i@@ ; for ( @@i@@ = Number ; @@a3@@ -- ; @@i@@ |= bkm_scale ( @@a1@@ , @@a2@@ ) ) { ; } return @@i@@ ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
__int64 __fastcall order ( unsigned __int8 @@a1@@ ) { if ( ( unsigned __int8 ) c_isdigit ( @@a1@@ ) ) return Number L ; if ( ( unsigned __int8 ) c_isalpha ( @@a1@@ ) ) return @@a1@@ ; if ( @@a1@@ == Number ) return Number ; return ( unsigned int ) @@a1@@ + Number ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
__int64 __fastcall xmemxfrm ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ ) { char * @@v4@@ ; int * @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; __int64 @@v12@@ ; @@v12@@ = memxfrm ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; if ( * __errno_location ( ) ) { @@v4@@ = gettext ( String ) ; @@v5@@ = __errno_location ( ) ; error ( Number , * @@v5@@ , @@v4@@ ) ; @@v6@@ = gettext ( String ) ; error ( Number , Number , @@v6@@ ) ; @@v7@@ = quotearg_n_style_mem ( Number L , Number L , @@a3@@ , @@a4@@ ) ; @@v8@@ = gettext ( String ) ; error ( exit_failure , Number , @@v8@@ , @@v7@@ ) ; } return @@v12@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
__int64 __fastcall argmatch ( const char * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { __int64 @@result@@ ; char @@v7@@ ; __int64 @@i@@ ; __int64 @@v9@@ ; size_t @@n@@ ; @@v9@@ = Number ; @@v7@@ = Number ; @@n@@ = strlen ( @@a1@@ ) ; for ( @@i@@ = Number L ; * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; ++ @@i@@ ) { if ( ! strncmp ( * ( const char * * ) ( Number * @@i@@ + @@a2@@ ) , @@a1@@ , @@n@@ ) ) { if ( @@n@@ == strlen ( * ( const char * * ) ( Number * @@i@@ + @@a2@@ ) ) ) return @@i@@ ; if ( @@v9@@ == Number ) { @@v9@@ = @@i@@ ; } else if ( ! @@a3@@ || memcmp ( ( const void * ) ( @@a4@@ * @@v9@@ + @@a3@@ ) , ( const void * ) ( @@i@@ * @@a4@@ + @@a3@@ ) , @@a4@@ ) ) { @@v7@@ = Number ; } } } if ( @@v7@@ ) @@result@@ = Number ; else @@result@@ = @@v9@@ ; return @@result@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_207288 ; @@v4@@ [ Number ] = qword_207290 ; @@v4@@ [ Number ] = qword_207298 ; @@v4@@ [ Number ] = qword_2072A0 ; @@v4@@ [ Number ] = qword_2072A8 ; @@v4@@ [ Number ] = qword_2072B0 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
void __fastcall argmatch_invalid ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { char * @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; char * @@format@@ ; if ( @@a3@@ == Number ) @@v3@@ = gettext ( String ) ; else @@v3@@ = gettext ( String ) ; @@format@@ = @@v3@@ ; @@v4@@ = quote_n ( Number L , @@a1@@ ) ; @@v5@@ = quotearg_n_style ( Number L , Number L , @@a2@@ ) ; error ( Number , Number , @@format@@ , @@v5@@ , @@v4@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_20D028 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = ( __int64 * ) & slotvec0 ; } nslots = Number ; return @@result@@ ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
int __fastcall argmatch_valid ( __int64 @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { char * @@v3@@ ; __int64 @@i@@ ; void * @@s1@@ ; @@s1@@ = Number L ; @@v3@@ = gettext ( String ) ; fprintf ( stderr , @@v3@@ ) ; for ( @@i@@ = Number L ; * ( _QWORD * ) ( Number * @@i@@ + @@a1@@ ) ; ++ @@i@@ ) { if ( @@i@@ && ! memcmp ( @@s1@@ , ( const void * ) ( @@i@@ * @@a3@@ + @@a2@@ ) , @@a3@@ ) ) { fprintf ( stderr , String , * ( const char * * ) ( Number * @@i@@ + @@a1@@ ) ) ; } else { fprintf ( stderr , String , * ( const char * * ) ( Number * @@i@@ + @@a1@@ ) ) ; @@s1@@ = ( void * ) ( @@i@@ * @@a3@@ + @@a2@@ ) ; } } return putc_unlocked ( Number , stderr ) ; }
__int64 __fastcall filevercmp ( const char * @@a1@@ , const char * @@a2@@ ) { __int64 @@result@@ ; _BYTE * @@v3@@ ; _BYTE * @@v4@@ ; __int64 @@s2@@ ; __int64 @@s1@@ ; unsigned int @@v7@@ ; unsigned int @@v8@@ ; _BYTE * @@v9@@ ; _BYTE * @@v10@@ ; size_t @@n@@ ; _BYTE * @@v12@@ ; _BYTE * @@v13@@ ; _BYTE * @@v14@@ ; unsigned __int64 @@v15@@ ; @@s1@@ = ( __int64 ) @@a1@@ ; @@s2@@ = ( __int64 ) @@a2@@ ; @@v15@@ = __readfsqword ( Number ) ; @@v7@@ = strcmp ( @@a1@@ , @@a2@@ ) ; if ( ! @@v7@@ ) return Number L ; if ( ! * @@a1@@ ) return Number ; if ( ! * @@a2@@ ) return Number L ; if ( ! strcmp ( String , @@a1@@ ) ) return Number ; if ( ! strcmp ( String , @@a2@@ ) ) return Number L ; if ( ! strcmp ( String , @@a1@@ ) ) return Number ; if ( ! strcmp ( String , @@a2@@ ) ) return Number L ; if ( * @@a1@@ == Number && * @@a2@@ != Number ) return Number ; if ( * @@a1@@ != Number && * @@a2@@ == Number ) return Number L ; if ( * @@a1@@ == Number && * @@a2@@ == Number ) { @@s1@@ = ( __int64 ) ( @@a1@@ + Number ) ; @@s2@@ = ( __int64 ) ( @@a2@@ + Number ) ; } @@v9@@ = ( _BYTE * ) @@s1@@ ; @@v10@@ = ( _BYTE * ) @@s2@@ ; @@v13@@ = match_suffix ( & @@v9@@ ) ; @@v14@@ = match_suffix ( & @@v10@@ ) ; if ( @@v13@@ ) @@v3@@ = @@v13@@ ; else @@v3@@ = @@v9@@ ; @@n@@ = ( size_t ) & @@v3@@ [ - @@s1@@ ] ; if ( @@v14@@ ) @@v4@@ = @@v14@@ ; else @@v4@@ = @@v10@@ ; @@v12@@ = & @@v4@@ [ - @@s2@@ ] ; if ( ( @@v13@@ || @@v14@@ ) && ( _BYTE * ) @@n@@ == @@v12@@ && ! strncmp ( ( const char * ) @@s1@@ , ( const char * ) @@s2@@ , @@n@@ ) ) { @@n@@ = ( size_t ) & @@v9@@ [ - @@s1@@ ] ; @@v12@@ = & @@v10@@ [ - @@s2@@ ] ; } @@v8@@ = verrevcmp ( @@s1@@ , @@n@@ , @@s2@@ , ( unsigned __int64 ) @@v12@@ ) ; if ( @@v8@@ ) @@result@@ = @@v8@@ ; else @@result@@ = @@v7@@ ; return @@result@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
void * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_20D0C8 ; @@v4@@ [ Number ] = qword_20D0D0 ; @@v4@@ [ Number ] = qword_20D0D8 ; @@v4@@ [ Number ] = qword_20D0E0 ; @@v4@@ [ Number ] = qword_20D0E8 ; @@v4@@ [ Number ] = qword_20D0F0 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ ) { return xmalloc ( @@a1@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
char * __fastcall randread_new ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { size_t @@v3@@ ; FILE * @@stream@@ ; char * @@v5@@ ; if ( ! @@a2@@ ) return ( char * ) simple_new ( Number L , Number L ) ; @@stream@@ = Number L ; if ( @@a1@@ ) { @@stream@@ = ( FILE * ) fopen_safer ( @@a1@@ , String ) ; if ( ! @@stream@@ ) return Number L ; } @@v5@@ = ( char * ) simple_new ( ( __int64 ) @@stream@@ , @@a1@@ ) ; if ( @@stream@@ ) { @@v3@@ = Number L ; if ( @@a2@@ <= Number ) @@v3@@ = @@a2@@ ; setvbuf ( @@stream@@ , @@v5@@ + Number , Number , @@v3@@ ) ; } else { * ( ( _QWORD * ) @@v5@@ + Number ) = Number L ; isaac_seed ( @@v5@@ + Number ) ; } return @@v5@@ ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
unsigned __int64 __fastcall raw_hasher ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return rotr_sz ( @@a1@@ , Number ) % @@a2@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; char * @@v3@@ ; FILE * @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; @@v1@@ = program_name ; if ( @@a1@@ ) { @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = gettext ( String ) ; printf ( @@v3@@ , @@v1@@ ) ; @@v4@@ = stdout ; @@v5@@ = gettext ( String ) ; fputs_unlocked ( @@v5@@ , @@v4@@ ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; @@v8@@ = stdout ; @@v9@@ = gettext ( String ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
size_t * __fastcall hash_initialize ( __int64 @@a1@@ , void * @@a2@@ , unsigned __int64 ( __fastcall * @@a3@@ ) ( __int64 a1 , unsigned __int64 a2 ) , bool ( __fastcall * @@a4@@ ) ( __int64 a1 , __int64 a2 ) , size_t @@a5@@ ) { size_t * @@result@@ ; bool ( __fastcall * @@v7@@ ) ( __int64 , __int64 ) ; unsigned __int64 ( __fastcall * @@v8@@ ) ( __int64 , unsigned __int64 ) ; void * @@v9@@ ; size_t * @@ptr@@ ; @@v9@@ = @@a2@@ ; @@v8@@ = @@a3@@ ; @@v7@@ = @@a4@@ ; if ( ! @@a3@@ ) @@v8@@ = raw_hasher ; if ( ! @@a4@@ ) @@v7@@ = raw_comparator ; @@ptr@@ = ( size_t * ) malloc ( Number ) ; if ( ! @@ptr@@ ) return Number L ; if ( ! @@a2@@ ) @@v9@@ = & default_tuning ; @@ptr@@ [ Number ] = ( size_t ) @@v9@@ ; if ( ( unsigned __int8 ) check_tuning ( ( __int64 ) @@ptr@@ ) == Number && ( @@ptr@@ [ Number ] = compute_bucket_size ( @@a1@@ , ( __int64 ) @@v9@@ ) ) != Number && ( * @@ptr@@ = ( size_t ) calloc ( @@ptr@@ [ Number ] , Number ) ) != Number ) { @@ptr@@ [ Number ] = Number * @@ptr@@ [ Number ] + * @@ptr@@ ; @@ptr@@ [ Number ] = Number L ; @@ptr@@ [ Number ] = Number L ; @@ptr@@ [ Number ] = ( size_t ) @@v8@@ ; @@ptr@@ [ Number ] = ( size_t ) @@v7@@ ; @@ptr@@ [ Number ] = @@a5@@ ; @@ptr@@ [ Number ] = Number L ; @@result@@ = @@ptr@@ ; } else { free ( @@ptr@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
int unlink ( const char * @@name@@ ) { return unlink ( @@name@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_206028 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
void __fastcall argmatch_invalid ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { char * @@v3@@ ; __int64 @@v4@@ ; void * @@v5@@ ; char * @@format@@ ; if ( @@a3@@ == Number ) @@v3@@ = gettext ( String ) ; else @@v3@@ = gettext ( String ) ; @@format@@ = @@v3@@ ; @@v4@@ = quote_n ( Number L , @@a1@@ ) ; @@v5@@ = quotearg_n_style ( Number , Number , @@a2@@ ) ; error ( Number , Number , @@format@@ , @@v5@@ , @@v4@@ ) ; }
__int64 __fastcall hash_find_entry ( __int64 @@a1@@ , __int64 @@a2@@ , _QWORD * @@a3@@ , char @@a4@@ ) { __int64 @@v4@@ ; __int64 @@result@@ ; __int64 @@v6@@ ; _QWORD * @@i@@ ; _QWORD * @@v10@@ ; __int64 @@v11@@ ; _QWORD * @@v12@@ ; __int64 @@v13@@ ; _QWORD * @@v14@@ ; @@v4@@ = * ( _QWORD * ) @@a1@@ ; @@v10@@ = ( _QWORD * ) ( @@v4@@ + Number * ( * ( __int64 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@a2@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@v10@@ >= * ( _QWORD * ) ( @@a1@@ + Number ) ) abort ( ) ; * @@a3@@ = @@v10@@ ; if ( ! * @@v10@@ ) return Number L ; if ( @@a2@@ == * @@v10@@ || ( * ( unsigned __int8 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@a2@@ , * @@v10@@ ) ) { @@v13@@ = * @@v10@@ ; if ( @@a4@@ ) { if ( @@v10@@ [ Number ] ) { @@v14@@ = ( _QWORD * ) @@v10@@ [ Number ] ; @@v6@@ = @@v14@@ [ Number ] ; * @@v10@@ = * @@v14@@ ; @@v10@@ [ Number ] = @@v6@@ ; free_entry ( @@a1@@ , @@v14@@ ) ; } else { * @@v10@@ = Number L ; } } @@result@@ = @@v13@@ ; } else { for ( @@i@@ = @@v10@@ ; ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { if ( ! @@i@@ [ Number ] ) return Number L ; if ( @@a2@@ == * ( _QWORD * ) @@i@@ [ Number ] || ( * ( unsigned __int8 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@a2@@ , * ( _QWORD * ) @@i@@ [ Number ] ) ) { break ; } } @@v11@@ = * ( _QWORD * ) @@i@@ [ Number ] ; if ( @@a4@@ ) { @@v12@@ = ( _QWORD * ) @@i@@ [ Number ] ; @@i@@ [ Number ] = @@v12@@ [ Number ] ; free_entry ( @@a1@@ , @@v12@@ ) ; } @@result@@ = @@v11@@ ; } return @@result@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
void clearerr_unlocked ( FILE * @@stream@@ ) { clearerr_unlocked ( @@stream@@ ) ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
__int64 __fastcall md5_stream ( FILE * @@a1@@ , _DWORD * @@a2@@ ) { __int64 @@v3@@ ; char * @@ptr@@ ; size_t @@v5@@ ; int @@v6@@ [ Number ] ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@ptr@@ = ( char * ) malloc ( Number ) ; if ( ! @@ptr@@ ) return Number L ; md5_init_ctx ( @@v6@@ ) ; LABEL_4 : @@v3@@ = Number L ; while ( Number ) { @@v5@@ = fread_unlocked ( & @@ptr@@ [ @@v3@@ ] , Number , Number - @@v3@@ , @@a1@@ ) ; @@v3@@ += @@v5@@ ; if ( @@v3@@ == Number ) { md5_process_block ( @@ptr@@ , Number , @@v6@@ ) ; goto LABEL_4 ; } if ( ! @@v5@@ ) break ; if ( feof_unlocked ( @@a1@@ ) ) goto LABEL_12 ; } if ( ferror_unlocked ( @@a1@@ ) ) { free ( @@ptr@@ ) ; return Number L ; } LABEL_12 : if ( @@v3@@ ) md5_process_bytes ( @@ptr@@ , @@v3@@ , @@v6@@ ) ; md5_finish_ctx ( @@v6@@ , @@a2@@ ) ; free ( @@ptr@@ ) ; return Number L ; }
__int64 __fastcall dup_safer ( int @@a1@@ , __m128 @@a2@@ , __m128 @@a3@@ , __m128 @@a4@@ , __m128 @@a5@@ , __m128 @@a6@@ , __m128 @@a7@@ , __m128 @@a8@@ , __m128 @@a9@@ , __int64 a10 , __int64 a11 , __int64 @@a12@@ , __int64 @@a13@@ , __int64 @@a14@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number L , @@a12@@ , @@a13@@ , @@a14@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ , @@a7@@ , @@a8@@ , @@a9@@ ) ; }
int fgetc ( FILE * @@stream@@ ) { return fgetc ( @@stream@@ ) ; }
void * __fastcall quote_n ( int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number , @@a2@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
int fileno ( FILE * @@stream@@ ) { return fileno ( @@stream@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
__int64 posix2_version ( ) { __int64 @@result@@ ; char * @@endptr@@ ; __int64 @@v2@@ ; char * @@nptr@@ ; __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; @@v5@@ = __readfsqword ( Number ) ; @@v2@@ = Number L ; @@nptr@@ = getenv ( String ) ; if ( @@nptr@@ ) { if ( * @@nptr@@ ) { @@v4@@ = strtol ( @@nptr@@ , & @@endptr@@ , Number ) ; if ( ! * @@endptr@@ ) @@v2@@ = @@v4@@ ; } } if ( @@v2@@ < ( __int64 ) Number ) return Number ; @@result@@ = Number ; if ( @@v2@@ <= Number ) @@result@@ = @@v2@@ ; return @@result@@ ; }
void * __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
__int64 sysconf ( int @@name@@ ) { return sysconf ( @@name@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
int __fastcall fstat ( int @@fildes@@ , struct stat * @@stat_buf@@ ) { return __fxstat ( Number , @@fildes@@ , @@stat_buf@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
int fflush_unlocked ( FILE * @@stream@@ ) { return fflush_unlocked ( @@stream@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( is_mul_ok ( @@a2@@ , * @@a1@@ ) ) { * @@a1@@ *= @@a2@@ ; @@result@@ = Number L ; } else { * @@a1@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
void free ( void * @@ptr@@ ) { __imp_free ( @@ptr@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 __fastcall bkm_scale_by_power ( unsigned __int64 * @@a1@@ , int @@a2@@ , int @@a3@@ ) { unsigned int @@i@@ ; for ( @@i@@ = Number ; @@a3@@ -- ; @@i@@ |= bkm_scale ( @@a1@@ , @@a2@@ ) ) ; return @@i@@ ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
_QWORD * __fastcall cs_enter ( _QWORD * @@a1@@ ) { unsigned __int64 @@v1@@ ; unsigned __int64 @@v2@@ ; unsigned __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; unsigned __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; unsigned __int64 @@v8@@ ; __int64 @@v10@@ ; sigset_t @@v11@@ ; unsigned __int64 @@v12@@ ; @@v12@@ = __readfsqword ( Number ) ; LOBYTE ( @@v10@@ ) = sigprocmask ( Number , & caught_signals , & @@v11@@ ) == Number ; @@v1@@ = @@v11@@ . __val [ Number ] ; * @@a1@@ = @@v10@@ ; @@a1@@ [ Number ] = @@v1@@ ; @@v2@@ = @@v11@@ . __val [ Number ] ; @@a1@@ [ Number ] = @@v11@@ . __val [ Number ] ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v11@@ . __val [ Number ] ; @@a1@@ [ Number ] = @@v11@@ . __val [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v11@@ . __val [ Number ] ; @@a1@@ [ Number ] = @@v11@@ . __val [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@v5@@ = @@v11@@ . __val [ Number ] ; @@a1@@ [ Number ] = @@v11@@ . __val [ Number ] ; @@a1@@ [ Number ] = @@v5@@ ; @@v6@@ = @@v11@@ . __val [ Number ] ; @@a1@@ [ Number ] = @@v11@@ . __val [ Number ] ; @@a1@@ [ Number ] = @@v6@@ ; @@v7@@ = @@v11@@ . __val [ Number ] ; @@a1@@ [ Number ] = @@v11@@ . __val [ Number ] ; @@a1@@ [ Number ] = @@v7@@ ; @@v8@@ = @@v11@@ . __val [ Number ] ; @@a1@@ [ Number ] = @@v11@@ . __val [ Number ] ; @@a1@@ [ Number ] = @@v8@@ ; @@a1@@ [ Number ] = @@v11@@ . __val [ Number ] ; return @@a1@@ ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
int __xstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _xstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
char * __fastcall maybe_create_temp ( FILE * * @@a1@@ , _DWORD * @@a2@@ , char @@a3@@ ) { int @@v4@@ ; char * @@v5@@ ; char * @@v6@@ ; int * @@v7@@ ; char * @@v8@@ ; int @@fd@@ ; char * @@v10@@ ; char * @@v11@@ ; int @@v12@@ ; int @@v13@@ ; unsigned __int64 @@v14@@ ; @@v14@@ = __readfsqword ( Number ) ; @@v10@@ = create_temp_file ( & @@fd@@ , @@a3@@ ) ; if ( ! @@v10@@ ) return Number L ; @@v11@@ = @@v10@@ + Number ; if ( compress_program ) { @@v4@@ = pipe_fork ( & @@v12@@ , Number L ) ; * ( ( _DWORD * ) @@v10@@ + Number ) = @@v4@@ ; if ( * ( ( int * ) @@v10@@ + Number ) <= Number ) { if ( * ( ( _DWORD * ) @@v10@@ + Number ) ) { * ( ( _DWORD * ) @@v10@@ + Number ) = Number ; } else { close ( @@v13@@ ) ; dup2_or_die ( @@fd@@ , Number ) ; close ( @@fd@@ ) ; dup2_or_die ( @@v12@@ , Number ) ; close ( @@v12@@ ) ; if ( execlp ( compress_program , compress_program , Number L ) < Number ) { @@v5@@ = compress_program ; @@v6@@ = gettext ( String ) ; @@v7@@ = __errno_location ( ) ; error ( Number , * @@v7@@ , @@v6@@ , @@v5@@ ) ; } } } else { close ( @@fd@@ ) ; close ( @@v12@@ ) ; @@fd@@ = @@v13@@ ; register_proc ( * ( ( _DWORD * ) @@v10@@ + Number ) ) ; } } * @@a1@@ = fdopen ( @@fd@@ , String ) ; if ( ! * @@a1@@ ) { @@v8@@ = gettext ( String ) ; die ( @@v8@@ , @@v11@@ ) ; } if ( @@a2@@ ) * @@a2@@ = * ( ( _DWORD * ) @@v10@@ + Number ) ; return @@v11@@ ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 __fastcall make_node_op_equals ( int @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; @@result@@ = xmalloc ( Number L ) ; * ( _BYTE * ) @@result@@ = Number ; * ( _BYTE * ) ( @@result@@ + Number ) = Number ; * ( _DWORD * ) ( @@result@@ + Number ) = Number ; * ( _DWORD * ) ( @@result@@ + Number ) = @@a1@@ ; * ( _DWORD * ) ( @@result@@ + Number ) = @@a2@@ ; * ( _BYTE * ) ( @@result@@ + Number ) = Number ; return @@result@@ ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
unsigned __int64 __fastcall specify_sort_size ( unsigned int @@a1@@ , char @@a2@@ , __int64 @@a3@@ ) { int @@v4@@ ; double @@v5@@ ; double @@v6@@ ; unsigned __int64 @@v7@@ ; __int64 @@v8@@ ; __int64 @@v10@@ ; unsigned int @@v12@@ ; unsigned __int64 @@v13@@ ; char * @@v14@@ ; double @@v15@@ ; unsigned __int64 @@v16@@ ; @@v10@@ = @@a3@@ ; @@v16@@ = __readfsqword ( Number ) ; @@v12@@ = xstrtoumax ( @@a3@@ , & @@v14@@ , Number L , & @@v13@@ , String ) ; if ( ! @@v12@@ && ( unsigned int ) ( * ( @@v14@@ - Number ) - Number ) <= Number ) { if ( @@v13@@ > Number ) @@v12@@ = Number ; else @@v13@@ <<= Number ; } if ( @@v12@@ == Number && ( unsigned int ) ( * ( @@v14@@ - Number ) - Number ) <= Number && ! @@v14@@ [ Number ] ) { @@v4@@ = * @@v14@@ ; if ( @@v4@@ == Number ) { @@v5@@ = physmem_total ( @@a3@@ , & @@v14@@ ) ; if ( ( @@v13@@ & Number ) != Number L ) @@v6@@ = ( double ) ( int ) ( @@v13@@ & Number | ( @@v13@@ >> Number ) ) + ( double ) ( int ) ( @@v13@@ & Number | ( @@v13@@ >> Number ) ) ; else @@v6@@ = ( double ) ( int ) @@v13@@ ; @@v15@@ = @@v6@@ * @@v5@@ / Number ; if ( @@v15@@ >= Number ) { @@v12@@ = Number ; } else { if ( @@v15@@ >= Number ) @@v7@@ = ( unsigned int ) ( int ) ( @@v15@@ - Number ) ^ Number ; else @@v7@@ = ( unsigned int ) ( int ) @@v15@@ ; @@v13@@ = @@v7@@ ; @@v12@@ = Number ; } } else if ( @@v4@@ == Number ) { @@v12@@ = Number ; } } if ( @@v12@@ ) xstrtol_fatal ( @@v12@@ , @@a1@@ , ( unsigned int ) @@a2@@ , & long_options , @@v10@@ ) ; if ( @@v13@@ >= sort_size ) { sort_size = @@v13@@ ; @@v8@@ = @@v13@@ ; if ( Number * ( unsigned __int64 ) ( unsigned int ) nmerge >= @@v13@@ ) @@v8@@ = Number L * ( unsigned int ) nmerge ; sort_size = @@v8@@ ; } return __readfsqword ( Number ) ^ @@v16@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 __fastcall check_mixed_SI_IEC ( char @@a1@@ , __int64 @@a2@@ ) { char * @@v2@@ ; __int64 @@result@@ ; int @@v4@@ ; @@v4@@ = @@a1@@ == Number ; if ( * ( _DWORD * ) ( @@a2@@ + Number ) != Number && @@v4@@ != * ( _DWORD * ) ( @@a2@@ + Number ) ) { @@v2@@ = gettext ( String ) ; error ( Number , Number , @@v2@@ ) ; } @@result@@ = @@a2@@ ; * ( _DWORD * ) ( @@a2@@ + Number ) = @@v4@@ ; return @@result@@ ; }
int __cdecl __noreturn main ( int @@argc@@ , const char * * @@argv@@ , const char * * @@envp@@ ) { char * @@v3@@ ; __int64 @@v4@@ ; char * @@v5@@ ; bool @@v6@@ ; set_program_name ( * @@argv@@ , @@argv@@ , @@envp@@ ) ; setlocale ( Number , & locale ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; initialize_exit_failure ( Number ) ; atexit ( close_stdout ) ; argv = ( __int64 ) @@argv@@ ; if ( @@argc@@ == Number ) { if ( ! strcmp ( @@argv@@ [ Number ] , String ) ) usage ( Number ) ; if ( ! strcmp ( @@argv@@ [ Number ] , String ) ) { version_etc ( ( _DWORD ) stdout , ( unsigned int ) String , ( unsigned int ) String , ( _DWORD ) Version , ( unsigned int ) String , ( unsigned int ) String , Number ) ; exit ( Number ) ; } } if ( @@argc@@ <= Number || strcmp ( @@argv@@ [ @@argc@@ - Number ] , String ) ) { @@v3@@ = gettext ( String ) ; test_syntax_error ( @@v3@@ , Number L ) ; } argc = @@argc@@ - Number ; pos = Number ; if ( @@argc@@ - Number <= Number ) exit ( Number ) ; @@v6@@ = posixtest ( argc - Number ) ; if ( pos != argc ) { @@v4@@ = quote ( * ( _QWORD * ) ( Number L * pos + argv ) ) ; @@v5@@ = gettext ( String ) ; test_syntax_error ( @@v5@@ , @@v4@@ ) ; } exit ( ! @@v6@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
int __xstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _xstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
int __fastcall general_numcompare ( const char * @@a1@@ , const char * @@a2@@ ) { int @@result@@ ; char * @@endptr@@ ; char * @@v4@@ ; double @@s1@@ ; double @@s2@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@s1@@ = strtod ( @@a1@@ , & @@endptr@@ ) ; @@s2@@ = strtod ( @@a2@@ , & @@v4@@ ) ; if ( @@a1@@ == @@endptr@@ ) { if ( @@a2@@ == @@v4@@ ) @@result@@ = Number ; else @@result@@ = Number ; } else if ( @@a2@@ == @@v4@@ ) { @@result@@ = Number ; } else if ( @@s2@@ <= @@s1@@ ) { if ( @@s1@@ <= @@s2@@ ) { if ( @@s1@@ == @@s2@@ ) @@result@@ = Number ; else @@result@@ = Number ; } else { @@result@@ = Number ; } } else { @@result@@ = Number ; } return @@result@@ ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , off_7C22 , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall compare ( unsigned __int8 * * @@a1@@ , unsigned __int8 * * @@a2@@ ) { __int64 @@result@@ ; size_t @@v3@@ ; int @@v4@@ ; unsigned int @@v5@@ ; unsigned int @@v6@@ ; unsigned __int64 @@v7@@ ; size_t @@n@@ ; if ( keylist ) { @@v5@@ = keycompare ( @@a1@@ , @@a2@@ ) ; if ( @@v5@@ || unique || stable ) return @@v5@@ ; } @@v7@@ = ( unsigned __int64 ) ( @@a1@@ [ Number ] - Number ) ; @@n@@ = ( size_t ) ( @@a2@@ [ Number ] - Number ) ; if ( @@a1@@ [ Number ] == ( _BYTE * ) & dword_0 + Number ) { @@v6@@ = - ( @@a2@@ [ Number ] != ( _BYTE * ) & dword_0 + Number ) ; } else if ( @@a2@@ [ Number ] == ( _BYTE * ) & dword_0 + Number ) { @@v6@@ = Number ; } else if ( hard_LC_COLLATE ) { @@v6@@ = xmemcoll ( * @@a1@@ , @@v7@@ , * @@a2@@ , @@n@@ ) ; } else { @@v3@@ = ( size_t ) ( @@a1@@ [ Number ] - Number ) ; if ( @@n@@ <= @@v7@@ ) @@v3@@ = ( size_t ) ( @@a2@@ [ Number ] - Number ) ; @@v6@@ = memcmp ( * @@a1@@ , * @@a2@@ , @@v3@@ ) ; if ( ! @@v6@@ ) { if ( @@v7@@ < @@n@@ ) @@v4@@ = Number ; else @@v4@@ = @@v7@@ != @@n@@ ; @@v6@@ = @@v4@@ ; } } if ( reverse ) @@result@@ = - @@v6@@ ; else @@result@@ = @@v6@@ ; return @@result@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_20A028 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 __fastcall hash_clear ( __int64 @@a1@@ ) { __int64 @@result@@ ; _QWORD * @@i@@ ; _QWORD * @@j@@ ; _QWORD * @@v4@@ ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = ( _QWORD * ) @@i@@ [ Number ] ; @@j@@ ; @@j@@ = @@v4@@ ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@j@@ ) ; * @@j@@ = Number L ; @@v4@@ = ( _QWORD * ) @@j@@ [ Number ] ; @@j@@ [ Number ] = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@j@@ ; } if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@i@@ ) ; * @@i@@ = Number L ; @@i@@ [ Number ] = Number L ; } } * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; @@result@@ = @@a1@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; return @@result@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_21B708 ; @@v8@@ [ Number ] = qword_21B710 ; @@v8@@ [ Number ] = qword_21B718 ; @@v8@@ [ Number ] = qword_21B720 ; @@v8@@ [ Number ] = qword_21B728 ; @@v8@@ [ Number ] = qword_21B730 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall transfer_entries ( __int64 @@a1@@ , __int64 @@a2@@ , char @@a3@@ ) { __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 * @@i@@ ; _QWORD * @@j@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; _QWORD * @@v11@@ ; _QWORD * @@v12@@ ; _QWORD * @@v13@@ ; _QWORD * @@v14@@ ; for ( @@i@@ = * ( __int64 * * ) @@a2@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a2@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = ( _QWORD * ) @@i@@ [ Number ] ; @@j@@ ; @@j@@ = @@v14@@ ) { @@v9@@ = * @@j@@ ; @@v3@@ = * ( _QWORD * ) @@a1@@ ; @@v11@@ = ( _QWORD * ) ( @@v3@@ + Number * ( * ( __int64 ( __fastcall * * ) ( _QWORD , _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@j@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@v11@@ >= * ( _QWORD * ) ( @@a1@@ + Number ) ) abort ( ) ; @@v14@@ = ( _QWORD * ) @@j@@ [ Number ] ; if ( * @@v11@@ ) { @@j@@ [ Number ] = @@v11@@ [ Number ] ; @@v11@@ [ Number ] = @@j@@ ; } else { * @@v11@@ = @@v9@@ ; ++ * ( _QWORD * ) ( @@a1@@ + Number ) ; free_entry ( @@a1@@ , @@j@@ ) ; } } @@v10@@ = * @@i@@ ; @@i@@ [ Number ] = Number L ; if ( ! @@a3@@ ) { @@v4@@ = * ( _QWORD * ) @@a1@@ ; @@v12@@ = ( _QWORD * ) ( @@v4@@ + Number * ( * ( __int64 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@v10@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@v12@@ >= * ( _QWORD * ) ( @@a1@@ + Number ) ) abort ( ) ; if ( * @@v12@@ ) { @@v13@@ = allocate_entry ( @@a1@@ ) ; if ( ! @@v13@@ ) return Number L ; * @@v13@@ = @@v10@@ ; @@v13@@ [ Number ] = @@v12@@ [ Number ] ; @@v12@@ [ Number ] = @@v13@@ ; } else { * @@v12@@ = @@v10@@ ; ++ * ( _QWORD * ) ( @@a1@@ + Number ) ; } * @@i@@ = Number L ; -- * ( _QWORD * ) ( @@a2@@ + Number ) ; } } } return Number L ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_208028 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ ) { return xmalloc ( @@a1@@ ) ; }
__int64 __fastcall mode_create_from_ref ( char * @@a1@@ ) { __int64 @@result@@ ; struct stat @@v2@@ ; unsigned __int64 @@v3@@ ; @@v3@@ = __readfsqword ( Number ) ; if ( ( unsigned int ) stat ( @@a1@@ , & @@v2@@ ) ) @@result@@ = Number L ; else @@result@@ = make_node_op_equals ( @@v2@@ . st_mode , Number ) ; return @@result@@ ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
_DWORD * __fastcall md5_buffer ( __int64 @@a1@@ , __int64 @@a2@@ , _DWORD * @@a3@@ ) { int @@v5@@ [ Number ] ; unsigned __int64 @@v6@@ ; @@v6@@ = __readfsqword ( Number ) ; md5_init_ctx ( @@v5@@ ) ; md5_process_bytes ( @@a1@@ , @@a2@@ , @@v5@@ ) ; return md5_finish_ctx ( @@v5@@ , @@a3@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@v2@@ ; @@v2@@ = malloc ( @@a1@@ ) ; if ( ! @@v2@@ && @@a1@@ ) xalloc_die ( ) ; return @@v2@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_2080C8 ; @@v4@@ [ Number ] = qword_2080D0 ; @@v4@@ [ Number ] = qword_2080D8 ; @@v4@@ [ Number ] = qword_2080E0 ; @@v4@@ [ Number ] = qword_2080E8 ; @@v4@@ [ Number ] = qword_2080F0 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
__int64 __fastcall list_signals ( char @@a1@@ , char * * @@a2@@ ) { char * * @@v3@@ ; int @@i@@ ; int @@j@@ ; signed int @@v6@@ ; signed int @@k@@ ; int @@v8@@ ; int @@l@@ ; unsigned int @@v10@@ ; unsigned int @@v11@@ ; int @@v12@@ ; size_t @@v13@@ ; char @@s@@ [ Number ] ; unsigned __int64 @@v15@@ ; @@v3@@ = @@a2@@ ; @@v15@@ = __readfsqword ( Number ) ; @@v10@@ = Number ; if ( @@a1@@ ) { @@v11@@ = Number ; @@v12@@ = Number ; for ( @@i@@ = Number ; @@i@@ <= Number ; @@i@@ *= Number ) ++ @@v12@@ ; for ( @@j@@ = Number ; @@j@@ <= Number ; ++ @@j@@ ) { if ( ! ( unsigned int ) sig2str ( ( unsigned int ) @@j@@ , @@s@@ ) ) { @@v13@@ = strlen ( @@s@@ ) ; if ( @@v13@@ > @@v11@@ ) @@v11@@ = @@v13@@ ; } } if ( @@a2@@ ) { while ( * @@v3@@ ) { @@v6@@ = operand2sig ( * @@v3@@ , @@s@@ ) ; if ( @@v6@@ >= Number ) print_table_row ( @@v12@@ , @@v6@@ , @@v11@@ , @@s@@ ) ; else @@v10@@ = Number ; ++ @@v3@@ ; } } else { for ( @@k@@ = Number ; @@k@@ <= Number ; ++ @@k@@ ) { if ( ! ( unsigned int ) sig2str ( ( unsigned int ) @@k@@ , @@s@@ ) ) print_table_row ( @@v12@@ , @@k@@ , @@v11@@ , @@s@@ ) ; } } } else if ( @@a2@@ ) { while ( * @@v3@@ ) { @@v8@@ = operand2sig ( * @@v3@@ , @@s@@ ) ; if ( @@v8@@ >= Number ) { if ( ( unsigned int ) ( * * @@v3@@ - Number ) > Number ) printf ( String , ( unsigned int ) @@v8@@ ) ; else puts ( @@s@@ ) ; } else { @@v10@@ = Number ; } ++ @@v3@@ ; } } else { for ( @@l@@ = Number ; @@l@@ <= Number ; ++ @@l@@ ) { if ( ! ( unsigned int ) sig2str ( ( unsigned int ) @@l@@ , @@s@@ ) ) puts ( @@s@@ ) ; } } return @@v10@@ ; }
__int64 __fastcall memcoll ( const char * @@a1@@ , size_t @@a2@@ , const char * @@a3@@ , __int64 @@a4@@ ) { __int64 @@v4@@ ; __int64 @@v8@@ ; const char * @@s2@@ ; size_t @@n@@ ; const char * @@s1@@ ; char @@v12@@ ; char @@v13@@ ; unsigned int @@v14@@ ; size_t @@v15@@ ; size_t @@v16@@ ; @@s1@@ = @@a1@@ ; @@s2@@ = @@a3@@ ; if ( @@a2@@ == @@a4@@ && ! memcmp ( @@a1@@ , @@a3@@ , @@a2@@ ) ) { * __errno_location ( ) = Number ; @@v14@@ = Number ; } else { @@v12@@ = @@a1@@ [ @@a2@@ ] ; @@v13@@ = @@s2@@ [ @@a4@@ ] ; @@n@@ = @@a2@@ + Number ; @@a1@@ [ @@a2@@ ] = Number ; @@v4@@ = @@a4@@ ; @@v8@@ = @@a4@@ + Number ; @@s2@@ [ @@v4@@ ] = Number ; while ( Number ) { * __errno_location ( ) = Number ; @@v14@@ = strcoll ( @@s1@@ , @@s2@@ ) ; if ( @@v14@@ || * __errno_location ( ) ) break ; @@v15@@ = strlen ( @@s1@@ ) + Number ; @@v16@@ = strlen ( @@s2@@ ) + Number ; @@s1@@ += @@v15@@ ; @@s2@@ += @@v16@@ ; @@n@@ -= @@v15@@ ; @@v8@@ -= @@v16@@ ; if ( ! @@n@@ ) { if ( @@v8@@ ) @@v14@@ = Number ; break ; } if ( ! @@v8@@ ) { @@v14@@ = Number ; break ; } } @@s1@@ [ @@n@@ - Number ] = @@v12@@ ; @@s2@@ [ @@v8@@ - Number ] = @@v13@@ ; } return @@v14@@ ; }
__int64 __fastcall x2realloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ ) { return x2nrealloc ( @@a1@@ , @@a2@@ , Number ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
void * __fastcall xzalloc ( size_t @@a1@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@a1@@ ) ; return memset ( @@v1@@ , Number , @@a1@@ ) ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_21B138 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
__int64 __fastcall xnanosleep ( double @@a1@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; @@v4@@ = __readfsqword ( Number ) ; if ( @@a1@@ < Number ) __assert_fail ( String , String , Number , String ) ; if ( @@a1@@ <= Number ) { @@v2@@ = ( unsigned int ) ( int ) @@a1@@ ; @@v3@@ = ( unsigned int ) ( int ) ( ( @@a1@@ - ( double ) ( int ) @@a1@@ ) * Number ) + ( unsigned __int64 ) ( ( @@a1@@ - ( double ) ( int ) @@a1@@ ) * Number > ( double ) ( int ) ( ( @@a1@@ - ( double ) ( int ) @@a1@@ ) * Number ) ) ; if ( @@v3@@ > Number ) { ++ @@v2@@ ; @@v3@@ -= Number L ; } } while ( Number ) { if ( @@a1@@ > Number ) { @@v2@@ = Number ; @@v3@@ = Number L ; } * __errno_location ( ) = Number ; if ( ! ( unsigned int ) rpl_nanosleep ( & @@v2@@ , Number L ) ) break ; if ( * __errno_location ( ) != Number && * __errno_location ( ) ) return Number ; } return Number L ; }
int __fastcall stat ( char * @@filename@@ , struct stat * @@stat_buf@@ ) { return __xstat ( Number , @@filename@@ , @@stat_buf@@ ) ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
int __fastcall mknod ( char * @@path@@ , __mode_t @@mode@@ , __dev_t @@a3@@ ) { __dev_t @@dev@@ [ Number ] ; @@dev@@ [ Number ] = @@a3@@ ; return __xmknod ( Number , @@path@@ , @@mode@@ , @@dev@@ ) ; }
_BOOL8 __fastcall c_isascii ( int @@a1@@ ) { return @@a1@@ >= Number && @@a1@@ <= Number ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
struct tm * localtime ( const time_t * @@timer@@ ) { return localtime ( @@timer@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
_BOOL8 __fastcall c_isalpha ( int @@a1@@ ) { return ( int ) ( @@a1@@ & Number ) > Number && ( int ) ( @@a1@@ & Number ) <= Number ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
_BOOL8 __fastcall c_isblank ( int @@a1@@ ) { return @@a1@@ == Number || @@a1@@ == Number ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
__int64 __fastcall str2sig ( const char * @@a1@@ , int * @@a2@@ ) { __int64 @@result@@ ; * @@a2@@ = str2signum ( @@a1@@ ) ; if ( * @@a2@@ >= Number ) @@result@@ = Number L ; else @@result@@ = Number ; return @@result@@ ; }
__int64 __fastcall get_stat_mtime ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int64 __fastcall uinttostr ( unsigned int @@a1@@ , __int64 @@a2@@ ) { __int64 @@v4@@ ; @@v4@@ = @@a2@@ + Number ; * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; do { * ( _BYTE * ) -- @@v4@@ = @@a1@@ % Number + Number ; @@a1@@ /= Number ; } while ( @@a1@@ ) ; return @@v4@@ ; }
_BOOL8 __fastcall c_isdigit ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
__int64 __fastcall sig2str ( int @@a1@@ , char * @@a2@@ ) { unsigned int @@i@@ ; int @@v4@@ ; int @@v5@@ ; for ( @@i@@ = Number ; @@i@@ <= Number ; ++ @@i@@ ) { if ( @@a1@@ == * ( ( _DWORD * ) & numname_table + Number * @@i@@ ) ) { strcpy ( @@a2@@ , ( const char * ) & numname_table + Number * @@i@@ + Number ) ; return Number L ; } } @@v4@@ = __libc_current_sigrtmin ( ) ; @@v5@@ = __libc_current_sigrtmax ( ) ; if ( @@v4@@ > @@a1@@ || @@a1@@ > @@v5@@ ) return Number ; if ( @@a1@@ > ( @@v5@@ - @@v4@@ ) / Number + @@v4@@ ) { if ( @@v5@@ == @@a1@@ ) sprintf ( @@a2@@ , String ) ; else sprintf ( @@a2@@ , String , ( unsigned int ) ( @@v5@@ - @@a1@@ ) ) ; } else if ( @@a1@@ == @@v4@@ ) { sprintf ( @@a2@@ , String ) ; } else { sprintf ( @@a2@@ , String , ( unsigned int ) ( @@a1@@ - @@v4@@ ) ) ; } return Number L ; }
_BOOL8 __fastcall c_isgraph ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
int __fxstat ( int @@ver@@ , int @@fildes@@ , struct stat * @@stat_buf@@ ) { return _fxstat ( @@ver@@ , @@fildes@@ , @@stat_buf@@ ) ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v4@@ ; @@v4@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v4@@ >= Number / @@a3@@ ) xalloc_die ( ) ; @@v4@@ += ( @@v4@@ + Number ) >> Number ; } else if ( ! @@v4@@ ) { @@v4@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v4@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v4@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
_BOOL8 __fastcall c_ispunct ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number && ( @@a1@@ <= Number || @@a1@@ > Number ) && ( ( int ) ( @@a1@@ & Number ) <= Number || ( int ) ( @@a1@@ & Number ) > Number ) ; }
int toupper ( int @@c@@ ) { return toupper ( @@c@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
__int64 __fastcall c_tolower ( int @@a1@@ ) { __int64 @@result@@ ; if ( @@a1@@ <= Number || @@a1@@ > Number ) @@result@@ = ( unsigned int ) @@a1@@ ; else @@result@@ = ( unsigned int ) ( @@a1@@ + Number ) ; return @@result@@ ; }
int pipe ( int @@pipedes@@ ( ( orgarrdim ( Number , Number ) ) ) [ Number ] ) { return pipe ( @@pipedes@@ ( ( orgarrdim ( Number , Number ) ) ) ) ; }
__int64 __fastcall apply_relative_time ( __int64 @@a1@@ , int @@a2@@ , __int64 a3 , __int64 a4 , __int64 a5 , __int64 a6 , __int64 @@a7@@ , __int64 @@a8@@ , __int64 @@a9@@ , __int64 @@a10@@ , __int64 @@a11@@ , __int64 @@a12@@ , __int64 @@a13@@ ) { __int64 @@result@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) += @@a2@@ * @@a13@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) += @@a2@@ * @@a12@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) += @@a2@@ * @@a11@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) += @@a2@@ * @@a10@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) += @@a2@@ * @@a9@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) += @@a2@@ * @@a8@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) += @@a2@@ * @@a7@@ ; @@result@@ = @@a1@@ ; * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; return @@result@@ ; }
unsigned __int64 __fastcall memxfrm ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , unsigned __int64 @@a4@@ ) { unsigned __int64 @@v4@@ ; _BYTE @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; char * @@dest@@ ; size_t @@v12@@ ; unsigned __int64 @@v13@@ ; unsigned __int64 @@size@@ ; char @@v15@@ ; unsigned __int64 @@v16@@ ; @@v16@@ = __readfsqword ( Number ) ; @@v8@@ [ Number ] = Number ; @@v9@@ = Number L ; @@v10@@ = Number L ; * ( _QWORD * ) @@v8@@ = * ( unsigned __int8 * ) ( @@a3@@ + @@a4@@ ) ; * ( _BYTE * ) ( @@a3@@ + @@a4@@ ) = Number ; while ( @@v9@@ < @@a4@@ ) { @@v12@@ = strlen ( ( const char * ) ( @@a3@@ + @@v9@@ ) ) ; @@v13@@ = @@v10@@ ; * __errno_location ( ) = Number ; @@v10@@ += strxfrm ( ( char * ) ( * ( _QWORD * ) & @@v8@@ [ Number ] + @@a1@@ ) , ( const char * ) ( @@a3@@ + @@v9@@ ) , @@a2@@ - * ( _QWORD * ) & @@v8@@ [ Number ] ) + Number ; if ( * __errno_location ( ) ) break ; if ( @@v10@@ <= @@v13@@ ) { * __errno_location ( ) = Number ; break ; } if ( @@v10@@ == @@a2@@ + Number && @@a4@@ == @@v9@@ + @@v12@@ ) { @@size@@ = @@a2@@ - * ( _QWORD * ) & @@v8@@ [ Number ] + Number ; @@dest@@ = & @@v15@@ ; if ( @@size@@ > Number ) { @@dest@@ = ( char * ) malloc ( @@size@@ ) ; if ( ! @@dest@@ ) break ; } strxfrm ( @@dest@@ , ( const char * ) ( @@a3@@ + @@v9@@ ) , @@size@@ ) ; memcpy ( ( void * ) ( * ( _QWORD * ) & @@v8@@ [ Number ] + @@a1@@ ) , @@dest@@ , @@a2@@ - * ( _QWORD * ) & @@v8@@ [ Number ] ) ; if ( @@size@@ > Number ) free ( @@dest@@ ) ; * __errno_location ( ) = Number ; } @@v4@@ = @@v10@@ ; if ( @@a2@@ <= @@v10@@ ) @@v4@@ = @@a2@@ ; * ( _QWORD * ) & @@v8@@ [ Number ] = @@v4@@ ; @@v9@@ += @@v12@@ + Number ; } * ( _BYTE * ) ( @@a4@@ + @@a3@@ ) = @@v8@@ [ Number ] ; return @@v10@@ - ( @@v9@@ != @@a4@@ ) ; }
__int64 __fastcall touch ( const char * @@a1@@ ) { bool @@v1@@ ; const char * @@v2@@ ; __int64 @@v3@@ ; char * @@v4@@ ; int * @@v5@@ ; __int64 @@v7@@ ; char * @@v8@@ ; __int64 @@v9@@ ; char * @@v10@@ ; int * @@v11@@ ; bool @@v12@@ ; unsigned int @@v13@@ ; int @@errnum@@ ; time_t * @@v15@@ ; @@v13@@ = Number ; @@errnum@@ = Number ; @@v15@@ = & newtime ; if ( ! strcmp ( @@a1@@ , String ) ) { @@v13@@ = Number ; } else if ( no_create != Number && no_dereference != Number ) { @@v13@@ = fd_reopen ( Number L , @@a1@@ , Number L , Number L ) ; if ( @@v13@@ == Number && * __errno_location ( ) != Number && * __errno_location ( ) != Number && * __errno_location ( ) != Number ) @@errnum@@ = * __errno_location ( ) ; } if ( change_times != Number ) { if ( change_times == Number ) { qword_2100E8 = Number L ; } else { if ( change_times != Number ) __assert_fail ( String , String , Number , String ) ; qword_2100F8 = Number L ; } } if ( amtime_now ) @@v15@@ = Number L ; if ( no_dereference && @@v13@@ == Number ) { @@v1@@ = ( unsigned int ) lutimens ( @@a1@@ , @@v15@@ ) == Number ; } else { if ( @@v13@@ == Number ) @@v2@@ = Number L ; else @@v2@@ = @@a1@@ ; @@v1@@ = ( unsigned int ) gl_futimens ( @@v13@@ , @@v2@@ , @@v15@@ ) == Number ; } @@v12@@ = @@v1@@ ; if ( @@v13@@ ) { if ( @@v13@@ == Number && ! @@v1@@ && * __errno_location ( ) == Number && no_create ) return Number L ; } else if ( close ( Number ) ) { @@v3@@ = quote ( @@a1@@ ) ; @@v4@@ = gettext ( String ) ; @@v5@@ = __errno_location ( ) ; error ( Number , * @@v5@@ , @@v4@@ , @@v3@@ ) ; return Number L ; } if ( @@v12@@ ) return Number L ; if ( @@errnum@@ ) { @@v7@@ = quote ( @@a1@@ ) ; @@v8@@ = gettext ( String ) ; error ( Number , @@errnum@@ , @@v8@@ , @@v7@@ ) ; } else { if ( no_create && * __errno_location ( ) == Number ) return Number L ; @@v9@@ = quote ( @@a1@@ ) ; @@v10@@ = gettext ( String ) ; @@v11@@ = __errno_location ( ) ; error ( Number , * @@v11@@ , @@v10@@ , @@v9@@ ) ; } return Number L ; }
int __xstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _xstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
__int64 __fastcall dup_safer ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall to_year ( __int64 a1 , __int64 a2 , __int64 a3 , __int64 a4 , __int64 a5 , __int64 a6 , int a7 , __int64 @@a8@@ , __int64 @@a9@@ ) { __int64 @@v9@@ ; __int64 @@v11@@ ; @@v11@@ = @@a8@@ ; if ( @@a8@@ < Number ) return - @@a8@@ ; if ( @@a9@@ == Number ) { if ( @@a8@@ > Number ) @@v9@@ = Number L ; else @@v9@@ = Number L ; @@v11@@ = @@v9@@ + @@a8@@ ; } return @@v11@@ ; }
__int64 __fastcall rpl_fcntl ( int @@a1@@ , int @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , __m128 @@a7@@ , __m128 @@a8@@ , __m128 @@a9@@ , __m128 @@a10@@ , __m128 @@a11@@ , __m128 @@a12@@ , __m128 @@a13@@ , __m128 @@a14@@ ) { int @@v14@@ ; int @@v15@@ ; int @@v16@@ ; int @@v18@@ ; int @@v19@@ ; int @@v20@@ ; int @@v21@@ ; __int64 @@v22@@ ; __int64 @@v23@@ ; __int64 @@v24@@ ; __int64 @@v25@@ ; __m128 @@v26@@ ; __m128 @@v27@@ ; __m128 @@v28@@ ; __m128 @@v29@@ ; __m128 @@v30@@ ; __m128 @@v31@@ ; __m128 @@v32@@ ; __m128 @@v33@@ ; @@v22@@ = @@a3@@ ; @@v23@@ = @@a4@@ ; @@v24@@ = @@a5@@ ; @@v25@@ = @@a6@@ ; @@v26@@ = @@a7@@ ; @@v27@@ = @@a8@@ ; @@v28@@ = @@a9@@ ; @@v29@@ = @@a10@@ ; @@v30@@ = @@a11@@ ; @@v31@@ = @@a12@@ ; @@v32@@ = @@a13@@ ; @@v33@@ = @@a14@@ ; if ( @@a2@@ != Number ) return ( unsigned int ) fcntl ( @@a1@@ , @@a2@@ , @@v22@@ ) ; @@v19@@ = @@v22@@ ; if ( have_dupfd_cloexec_2895 < Number ) { @@v18@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v22@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; } else { @@v18@@ = fcntl ( @@a1@@ , Number , ( unsigned int ) @@v22@@ ) ; if ( @@v18@@ < Number && * __errno_location ( ) == Number ) { @@v18@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v19@@ , @@v14@@ , @@v15@@ , @@v16@@ ) ; if ( @@v18@@ < Number ) return ( unsigned int ) @@v18@@ ; have_dupfd_cloexec_2895 = Number ; } else { have_dupfd_cloexec_2895 = Number ; } } if ( @@v18@@ >= Number && have_dupfd_cloexec_2895 == Number ) { @@v20@@ = fcntl ( @@v18@@ , Number ) ; if ( @@v20@@ < Number || fcntl ( @@v18@@ , Number , @@v20@@ | Number ) == Number ) { @@v21@@ = * __errno_location ( ) ; close ( @@v18@@ ) ; * __errno_location ( ) = @@v21@@ ; @@v18@@ = Number ; } } return ( unsigned int ) @@v18@@ ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
bool __fastcall mktime_ok ( _DWORD * @@a1@@ , struct tm * @@a2@@ , time_t @@a3@@ ) { bool @@result@@ ; time_t @@timer@@ ; struct tm * @@v5@@ ; _DWORD * @@v6@@ ; @@v6@@ = @@a1@@ ; @@v5@@ = @@a2@@ ; @@timer@@ = @@a3@@ ; if ( @@a3@@ != Number || ( @@v5@@ = localtime ( & @@timer@@ ) ) != Number L ) @@result@@ = ( @@v6@@ [ Number ] ^ @@v5@@ -> tm_mon | @@v6@@ [ Number ] ^ @@v5@@ -> tm_mday | @@v6@@ [ Number ] ^ @@v5@@ -> tm_hour | @@v6@@ [ Number ] ^ @@v5@@ -> tm_min | @@v5@@ -> tm_sec ^ * @@v6@@ | @@v6@@ [ Number ] ^ @@v5@@ -> tm_year ) == Number ; else @@result@@ = Number ; return @@result@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
int __fastcall rpl_nanosleep ( __time_t * @@a1@@ , struct timespec * @@a2@@ ) { int @@v3@@ ; __time_t @@v4@@ ; struct timespec @@requested_time@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = __readfsqword ( Number ) ; @@v4@@ = * @@a1@@ ; @@requested_time@@ . tv_nsec = Number L ; do { if ( @@v4@@ <= Number ) { @@requested_time@@ . tv_sec = @@v4@@ ; @@requested_time@@ . tv_nsec = @@a1@@ [ Number ] ; return nanosleep ( & @@requested_time@@ , @@a2@@ ) ; } @@requested_time@@ . tv_sec = Number L ; @@v3@@ = nanosleep ( & @@requested_time@@ , @@a2@@ ) ; @@v4@@ -= Number L ; } while ( ! @@v3@@ ) ; if ( @@a2@@ ) { @@a2@@ -> tv_sec += @@v4@@ ; @@a2@@ -> tv_nsec += @@a1@@ [ Number ] ; if ( @@a1@@ [ Number ] > Number ) { ++ @@a2@@ -> tv_sec ; @@a2@@ -> tv_nsec -= Number L ; } } return @@v3@@ ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
unsigned __int64 __fastcall proctab_hasher ( int * @@a1@@ , unsigned __int64 @@a2@@ ) { return * @@a1@@ % @@a2@@ ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
__int64 __fastcall argmatch_to_argument ( const void * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; ++ @@i@@ ) { if ( ! memcmp ( @@a1@@ , ( const void * ) ( @@i@@ * @@a4@@ + @@a3@@ ) , @@a4@@ ) ) return * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; } return Number L ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
__int64 __fastcall reap ( unsigned int @@a1@@ ) { char * @@v1@@ ; char * @@v2@@ ; int * @@v3@@ ; char * @@v4@@ ; char * @@v5@@ ; int @@stat_loc@@ ; __pid_t @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v8@@ = waitpid ( @@a1@@ , & @@stat_loc@@ , @@a1@@ >> Number ) ; if ( @@v8@@ >= Number ) { if ( @@v8@@ > Number ) { if ( ( @@stat_loc@@ & Number ) != Number || BYTE1 ( @@stat_loc@@ ) ) { @@v4@@ = compress_program ; @@v5@@ = gettext ( String ) ; error ( Number , Number , @@v5@@ , @@v4@@ ) ; } -- nprocs ; } } else { @@v1@@ = compress_program ; @@v2@@ = gettext ( String ) ; @@v3@@ = __errno_location ( ) ; error ( Number , * @@v3@@ , @@v2@@ , @@v1@@ ) ; } return ( unsigned int ) @@v8@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
char * __fastcall create_temp_file ( int * @@a1@@ , char @@a2@@ ) { int @@v2@@ ; int @@v3@@ ; int @@v4@@ ; int @@v5@@ ; __int64 @@v6@@ ; char * @@v7@@ ; int * @@v8@@ ; int @@v10@@ ; int @@v11@@ ; char * @@ptr@@ ; char * @@s@@ ; size_t @@n@@ ; void * @@dest@@ ; char @@v16@@ [ Number ] ; sigset_t @@set@@ ; unsigned __int64 @@v18@@ ; @@v18@@ = __readfsqword ( Number ) ; @@s@@ = * ( char * * ) ( Number * temp_dir_index_6606 + temp_dirs ) ; @@n@@ = strlen ( @@s@@ ) ; @@ptr@@ = ( char * ) xmalloc ( @@n@@ + Number ) ; @@dest@@ = @@ptr@@ + Number ; memcpy ( @@ptr@@ + Number , @@s@@ , @@n@@ ) ; strcpy ( & @@ptr@@ [ @@n@@ + Number ] , String ) ; * ( _QWORD * ) @@ptr@@ = Number L ; * ( ( _DWORD * ) @@ptr@@ + Number ) = Number ; if ( ++ temp_dir_index_6606 == temp_dir_count ) temp_dir_index_6606 = Number L ; cs_enter ( @@v16@@ ) ; @@v10@@ = mkstemp_safer ( @@dest@@ ) ; if ( @@v10@@ >= Number ) { * ( _QWORD * ) temptail = @@ptr@@ ; temptail = ( __int64 ) @@ptr@@ ; } @@v11@@ = * __errno_location ( ) ; cs_leave ( ( int ) @@dest@@ , ( int ) @@s@@ , @@v2@@ , @@v3@@ , @@v4@@ , @@v5@@ , @@v16@@ [ Number ] , @@set@@ ) ; * __errno_location ( ) = @@v11@@ ; if ( @@v10@@ < Number ) { if ( @@a2@@ != Number || * __errno_location ( ) != Number ) { @@v6@@ = quote ( @@s@@ ) ; @@v7@@ = gettext ( String ) ; @@v8@@ = __errno_location ( ) ; error ( Number , * @@v8@@ , @@v7@@ , @@v6@@ ) ; } free ( @@ptr@@ ) ; @@ptr@@ = Number L ; } * @@a1@@ = @@v10@@ ; return @@ptr@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_210038 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
int __fastcall struct_month_cmp ( const void * @@a1@@ , const void * @@a2@@ ) { return strcmp ( * ( const char * * ) @@a1@@ , * ( const char * * ) @@a2@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall get_stat_atime_0 ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_210038 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ ) { return xmalloc ( @@a1@@ ) ; }
__int64 __fastcall get_stat_mtime_0 ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
void inittables ( ) { bool @@v0@@ ; unsigned __int64 @@c@@ ; unsigned __int64 @@ca@@ ; size_t @@i@@ ; const char * @@s@@ ; size_t @@v5@@ ; char * @@v6@@ ; for ( @@c@@ = Number L ; @@c@@ <= Number ; ++ @@c@@ ) { blanks [ @@c@@ ] = ( ( * __ctype_b_loc ( ) ) [ ( int ) @@c@@ ] & Number ) != Number ; nonprinting [ @@c@@ ] = ( ( * __ctype_b_loc ( ) ) [ ( int ) @@c@@ ] & Number ) == Number ; @@v0@@ = ( ( * __ctype_b_loc ( ) ) [ ( int ) @@c@@ ] & Number ) == Number && ( ( * __ctype_b_loc ( ) ) [ ( int ) @@c@@ ] & Number ) == Number ; nondictionary [ @@c@@ ] = @@v0@@ ; fold_toupper [ @@c@@ ] = toupper ( @@c@@ ) ; } if ( hard_LC_TIME ) { for ( @@ca@@ = Number L ; @@ca@@ <= Number ; ++ @@ca@@ ) { @@s@@ = nl_langinfo ( ( int ) @@ca@@ + Number ) ; @@v5@@ = strlen ( @@s@@ ) ; @@v6@@ = ( char * ) xmalloc ( @@v5@@ + Number ) ; ( & monthtab ) [ Number * @@ca@@ ] = @@v6@@ ; * ( ( _DWORD * ) & unk_21B048 + Number * @@ca@@ ) = @@ca@@ + Number ; for ( @@i@@ = Number L ; @@i@@ < @@v5@@ ; ++ @@i@@ ) @@v6@@ [ @@i@@ ] = fold_toupper [ ( unsigned __int8 ) to_uchar ( @@s@@ [ @@i@@ ] ) ] ; @@v6@@ [ @@i@@ ] = Number ; } qsort ( & monthtab , Number , Number , struct_month_cmp ) ; } }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 __fastcall update_timespec ( __int64 @@a1@@ , struct timespec * * @@a2@@ ) { __int64 @@result@@ ; __syscall_slong_t @@v3@@ ; __syscall_slong_t @@v4@@ ; struct timespec * @@v5@@ ; @@v5@@ = * @@a2@@ ; if ( ( * @@a2@@ ) -> tv_nsec == Number && @@v5@@ [ Number ] . tv_nsec == Number ) return Number L ; if ( @@v5@@ -> tv_nsec == Number && @@v5@@ [ Number ] . tv_nsec == Number ) { * @@a2@@ = Number L ; @@result@@ = Number L ; } else { if ( @@v5@@ -> tv_nsec == Number ) { @@v5@@ -> tv_sec = get_stat_atime_0 ( @@a1@@ ) ; @@v5@@ -> tv_nsec = @@v3@@ ; } else if ( @@v5@@ -> tv_nsec == Number ) { gettime ( @@v5@@ ) ; } if ( @@v5@@ [ Number ] . tv_nsec == Number ) { @@v5@@ [ Number ] . tv_sec = get_stat_mtime_0 ( @@a1@@ ) ; @@v5@@ [ Number ] . tv_nsec = @@v4@@ ; } else if ( @@v5@@ [ Number ] . tv_nsec == Number ) { gettime ( @@v5@@ + Number ) ; } @@result@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall buffer_linelim ( _QWORD * @@a1@@ ) { return * @@a1@@ + @@a1@@ [ Number ] ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_206028 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_2060C8 ; @@v8@@ [ Number ] = qword_2060D0 ; @@v8@@ [ Number ] = qword_2060D8 ; @@v8@@ [ Number ] = qword_2060E0 ; @@v8@@ [ Number ] = qword_2060E8 ; @@v8@@ [ Number ] = qword_2060F0 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
unsigned __int8 * __fastcall begfield ( __int64 @@a1@@ , __int64 * @@a2@@ ) { unsigned __int8 * @@result@@ ; unsigned __int8 * @@v5@@ ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; __int64 @@v8@@ ; @@v5@@ = * ( unsigned __int8 * * ) @@a1@@ ; @@v7@@ = * ( _QWORD * ) ( @@a1@@ + Number ) - Number L + * ( _QWORD * ) @@a1@@ ; @@v6@@ = * @@a2@@ ; @@v8@@ = @@a2@@ [ Number ] ; if ( tab == Number ) { while ( ( unsigned __int64 ) @@v5@@ < @@v7@@ ) { if ( ! @@v6@@ -- ) break ; while ( ( unsigned __int64 ) @@v5@@ < @@v7@@ && blanks [ ( unsigned __int8 ) to_uchar ( * @@v5@@ ) ] ) ++ @@v5@@ ; while ( ( unsigned __int64 ) @@v5@@ < @@v7@@ && blanks [ ( unsigned __int8 ) to_uchar ( * @@v5@@ ) ] != Number ) ++ @@v5@@ ; } } else { while ( ( unsigned __int64 ) @@v5@@ < @@v7@@ ) { if ( ! @@v6@@ -- ) break ; while ( ( unsigned __int64 ) @@v5@@ < @@v7@@ && ( char ) * @@v5@@ != tab ) ++ @@v5@@ ; if ( ( unsigned __int64 ) @@v5@@ < @@v7@@ ) ++ @@v5@@ ; } } if ( * ( ( _BYTE * ) @@a2@@ + Number ) ) { while ( ( unsigned __int64 ) @@v5@@ < @@v7@@ && blanks [ ( unsigned __int8 ) to_uchar ( * @@v5@@ ) ] ) ++ @@v5@@ ; } @@result@@ = & @@v5@@ [ @@v8@@ ] ; if ( @@v7@@ <= ( unsigned __int64 ) & @@v5@@ [ @@v8@@ ] ) @@result@@ = ( unsigned __int8 * ) @@v7@@ ; return @@result@@ ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
_BOOL8 __fastcall c_isascii ( int @@a1@@ ) { return @@a1@@ >= Number && @@a1@@ <= Number ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_2060C8 ; @@v4@@ [ Number ] = qword_2060D0 ; @@v4@@ [ Number ] = qword_2060D8 ; @@v4@@ [ Number ] = qword_2060E0 ; @@v4@@ [ Number ] = qword_2060E8 ; @@v4@@ [ Number ] = qword_2060F0 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
__int64 __fastcall _xargmatch_internal ( __int64 @@a1@@ , const char * @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ , void ( * @@a6@@ ) ( void ) ) { __int64 @@v11@@ ; @@v11@@ = argmatch ( @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; if ( @@v11@@ >= Number ) return @@v11@@ ; argmatch_invalid ( @@a1@@ , ( __int64 ) @@a2@@ , @@v11@@ ) ; argmatch_valid ( @@a3@@ , @@a4@@ , @@a5@@ ) ; @@a6@@ ( ) ; return Number ; }
__int64 __fastcall fd_reopen ( int @@a1@@ , const char * @@a2@@ , int @@a3@@ , unsigned int @@a4@@ ) { int @@fd@@ ; unsigned int @@v6@@ ; int @@v7@@ ; @@fd@@ = open ( @@a2@@ , @@a3@@ , @@a4@@ ) ; if ( @@fd@@ == @@a1@@ || @@fd@@ < Number ) return ( unsigned int ) @@fd@@ ; @@v6@@ = dup2 ( @@fd@@ , @@a1@@ ) ; @@v7@@ = * __errno_location ( ) ; close ( @@fd@@ ) ; * __errno_location ( ) = @@v7@@ ; return @@v6@@ ; }
_BOOL8 __fastcall c_isalpha ( int @@a1@@ ) { return ( int ) ( @@a1@@ & Number ) > Number && ( int ) ( @@a1@@ & Number ) <= Number ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall argmatch_to_argument ( const void * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; ++ @@i@@ ) { if ( ! memcmp ( @@a1@@ , ( const void * ) ( @@i@@ * @@a4@@ + @@a3@@ ) , @@a4@@ ) ) return * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; } return Number L ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
_BOOL8 __fastcall c_isspace ( int @@a1@@ ) { return @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number ; }
_BOOL8 __fastcall c_islower ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
__int64 __fastcall c_toupper ( int @@a1@@ ) { __int64 @@result@@ ; if ( @@a1@@ <= Number || @@a1@@ > Number ) @@result@@ = ( unsigned int ) @@a1@@ ; else @@result@@ = ( unsigned int ) ( @@a1@@ - Number ) ; return @@result@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
_BOOL8 __fastcall c_ispunct ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number && ( @@a1@@ <= Number || @@a1@@ > Number ) && ( ( int ) ( @@a1@@ & Number ) <= Number || ( int ) ( @@a1@@ & Number ) > Number ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
int __fastcall fstat ( int @@fildes@@ , struct stat * @@stat_buf@@ ) { return __fxstat ( Number , @@fildes@@ , @@stat_buf@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
int rmdir ( const char * @@path@@ ) { return rmdir ( @@path@@ ) ; }
struct dirent * readdir ( DIR * @@dirp@@ ) { return readdir ( @@dirp@@ ) ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
FILE * __fastcall fopen_safer ( const char * @@a1@@ , const char * @@a2@@ ) { int @@v3@@ ; int @@fd@@ ; int @@v5@@ ; int @@v6@@ ; FILE * @@stream@@ ; @@stream@@ = fopen ( @@a1@@ , @@a2@@ ) ; if ( ! @@stream@@ ) return @@stream@@ ; @@v3@@ = fileno ( @@stream@@ ) ; if ( @@v3@@ < Number || @@v3@@ > Number ) return @@stream@@ ; @@fd@@ = dup_safer ( ( unsigned int ) @@v3@@ ) ; if ( @@fd@@ < Number ) { @@v6@@ = * __errno_location ( ) ; fclose ( @@stream@@ ) ; * __errno_location ( ) = @@v6@@ ; return Number L ; } if ( ! fclose ( @@stream@@ ) ) { @@stream@@ = fdopen ( @@fd@@ , @@a2@@ ) ; if ( @@stream@@ ) return @@stream@@ ; } @@v5@@ = * __errno_location ( ) ; close ( @@fd@@ ) ; * __errno_location ( ) = @@v5@@ ; return Number L ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; char * @@v3@@ ; FILE * @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; FILE * @@v10@@ ; char * @@v11@@ ; FILE * @@v12@@ ; char * @@v13@@ ; FILE * @@v14@@ ; char * @@v15@@ ; FILE * @@v16@@ ; char * @@v17@@ ; FILE * @@v18@@ ; char * @@v19@@ ; char * @@v20@@ ; @@v1@@ = program_name ; if ( @@a1@@ ) { @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = gettext ( String ) ; printf ( @@v3@@ , @@v1@@ ) ; @@v4@@ = stdout ; @@v5@@ = gettext ( String ) ; fputs_unlocked ( @@v5@@ , @@v4@@ ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; @@v8@@ = stdout ; @@v9@@ = gettext ( String ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = stdout ; @@v11@@ = gettext ( String ) ; fputs_unlocked ( @@v11@@ , @@v10@@ ) ; @@v12@@ = stdout ; @@v13@@ = gettext ( String ) ; fputs_unlocked ( @@v13@@ , @@v12@@ ) ; @@v14@@ = stdout ; @@v15@@ = gettext ( String ) ; fputs_unlocked ( @@v15@@ , @@v14@@ ) ; @@v16@@ = stdout ; @@v17@@ = gettext ( String String String String String ) ; fputs_unlocked ( @@v17@@ , @@v16@@ ) ; @@v18@@ = stdout ; @@v19@@ = gettext ( String String String String ) ; fputs_unlocked ( @@v19@@ , @@v18@@ ) ; @@v20@@ = gettext ( String String String String ) ; printf ( @@v20@@ , String ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
char * nl_langinfo ( nl_item @@item@@ ) { return nl_langinfo ( @@item@@ ) ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
__int64 __fastcall xtime_make ( __int64 @@a1@@ , __int64 @@a2@@ ) { return Number * @@a1@@ + @@a2@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
struct dirent * __fastcall readdir_ignoring_dot_and_dotdot ( DIR * @@a1@@ ) { struct dirent * @@v2@@ ; do @@v2@@ = readdir ( @@a1@@ ) ; while ( @@v2@@ && dot_or_dotdot ( @@v2@@ -> d_name ) ) ; return @@v2@@ ; }
__int64 gethrxtime ( ) { struct timespec @@tp@@ ; unsigned __int64 @@v2@@ ; @@v2@@ = __readfsqword ( Number ) ; if ( clock_gettime ( Number , & @@tp@@ ) ) gettime ( & @@tp@@ ) ; return xtime_make ( @@tp@@ . tv_sec , @@tp@@ . tv_nsec ) ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
__int64 __fastcall errno_may_be_empty ( int @@a1@@ ) { __int64 @@result@@ ; switch ( @@a1@@ ) { case Number : case Number : case Number : case Number : case Number : @@result@@ = Number L ; break ; default : @@result@@ = Number L ; break ; } return @@result@@ ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
__int64 __fastcall hard_locale ( int @@a1@@ ) { unsigned __int8 @@v2@@ ; const char * @@s1@@ ; @@v2@@ = Number ; @@s1@@ = setlocale ( @@a1@@ , Number L ) ; if ( @@s1@@ && ( ! strcmp ( @@s1@@ , String ) || ! strcmp ( @@s1@@ , String ) ) ) @@v2@@ = Number ; return @@v2@@ ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
__int64 __fastcall hash_get_n_buckets ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
int __cdecl __noreturn main ( int @@argc@@ , const char * * @@argv@@ , const char * * @@envp@@ ) { char * @@v3@@ ; int @@v4@@ ; unsigned int @@v5@@ ; int @@v6@@ ; int @@v7@@ ; int * @@v8@@ ; __int64 @@v9@@ ; char * @@v10@@ ; int * @@v11@@ ; char @@v13@@ ; int @@v14@@ ; char * @@path@@ ; @@v13@@ = Number ; set_program_name ( * @@argv@@ , @@argv@@ , @@envp@@ ) ; setlocale ( Number , & locale ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; remove_empty_parents = Number ; while ( Number ) { while ( Number ) { @@v14@@ = getopt_long ( @@argc@@ , ( char * const * ) @@argv@@ , String , & longopts , Number L ) ; if ( @@v14@@ == Number ) { if ( @@argc@@ == optind ) { @@v3@@ = gettext ( String ) ; error ( Number , Number , @@v3@@ ) ; usage ( Number ) ; } while ( @@argc@@ > optind ) { @@path@@ = ( char * ) @@argv@@ [ optind ] ; if ( verbose ) { @@v4@@ = quote ( @@path@@ ) ; @@v5@@ = ( unsigned int ) gettext ( String ) ; prog_fprintf ( ( _DWORD ) stdout , @@v5@@ , @@v4@@ , @@v5@@ , @@v6@@ , @@v7@@ , ( char ) @@argv@@ ) ; } if ( rmdir ( @@path@@ ) ) { @@v8@@ = __errno_location ( ) ; if ( ! ignorable_failure ( * @@v8@@ , @@path@@ ) ) { @@v9@@ = quote ( @@path@@ ) ; @@v10@@ = gettext ( String ) ; @@v11@@ = __errno_location ( ) ; error ( Number , * @@v11@@ , @@v10@@ , @@v9@@ ) ; @@v13@@ = Number ; } } else if ( remove_empty_parents ) { @@v13@@ &= remove_parents ( @@path@@ ) ; } ++ optind ; } exit ( ( unsigned __int8 ) @@v13@@ ^ Number ) ; } if ( @@v14@@ != Number ) break ; remove_empty_parents = Number ; } if ( @@v14@@ <= Number ) break ; if ( @@v14@@ == Number ) { verbose = Number ; } else { if ( @@v14@@ != Number ) goto LABEL_15 ; ignore_fail_on_non_empty = Number ; } } if ( @@v14@@ == Number ) { version_etc ( ( _DWORD ) stdout , ( unsigned int ) String , ( unsigned int ) String , ( _DWORD ) Version , ( unsigned int ) String , Number , ( char ) @@argv@@ ) ; exit ( Number ) ; } if ( @@v14@@ == Number ) usage ( Number ) ; LABEL_15 : usage ( Number ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall hash_get_n_buckets_used ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
__int64 __fastcall hash_get_n_entries ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_208028 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_20C028 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
unsigned __int64 __fastcall hash_get_max_bucket_length ( __int64 @@a1@@ ) { _QWORD * @@i@@ ; unsigned __int64 @@v3@@ ; _QWORD * @@v4@@ ; unsigned __int64 @@j@@ ; @@v3@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { @@v4@@ = @@i@@ ; for ( @@j@@ = Number L ; ; ++ @@j@@ ) { @@v4@@ = ( _QWORD * ) @@v4@@ [ Number ] ; if ( ! @@v4@@ ) break ; } if ( @@j@@ > @@v3@@ ) @@v3@@ = @@j@@ ; } } return @@v3@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
int __lxstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _lxstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
_BOOL8 __fastcall hash_table_ok ( __int64 @@a1@@ ) { _QWORD * @@i@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; _QWORD * @@v5@@ ; @@v3@@ = Number L ; @@v4@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { @@v5@@ = @@i@@ ; ++ @@v3@@ ; ++ @@v4@@ ; while ( Number ) { @@v5@@ = ( _QWORD * ) @@v5@@ [ Number ] ; if ( ! @@v5@@ ) break ; ++ @@v4@@ ; } } } return @@v3@@ == * ( _QWORD * ) ( @@a1@@ + Number ) && @@v4@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
int __xstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _xstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
int __fastcall hash_print_statistics ( __int64 @@a1@@ , FILE * @@a2@@ ) { double @@v2@@ ; double @@v3@@ ; double @@v4@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v6@@ = hash_get_n_entries ( @@a1@@ ) ; @@v7@@ = hash_get_n_buckets ( @@a1@@ ) ; @@v8@@ = hash_get_n_buckets_used ( @@a1@@ ) ; @@v9@@ = hash_get_max_bucket_length ( @@a1@@ ) ; fprintf ( @@a2@@ , String , @@v6@@ ) ; fprintf ( @@a2@@ , String , @@v7@@ ) ; if ( @@v8@@ < Number ) @@v2@@ = ( double ) ( int ) ( @@v8@@ & Number | ( ( unsigned __int64 ) @@v8@@ >> Number ) ) + ( double ) ( int ) ( @@v8@@ & Number | ( ( unsigned __int64 ) @@v8@@ >> Number ) ) ; else @@v2@@ = ( double ) ( int ) @@v8@@ ; @@v3@@ = Number * @@v2@@ ; if ( @@v7@@ < Number ) @@v4@@ = ( double ) ( int ) ( @@v7@@ & Number | ( ( unsigned __int64 ) @@v7@@ >> Number ) ) + ( double ) ( int ) ( @@v7@@ & Number | ( ( unsigned __int64 ) @@v7@@ >> Number ) ) ; else @@v4@@ = ( double ) ( int ) @@v7@@ ; fprintf ( @@a2@@ , String , @@v8@@ , @@v3@@ / @@v4@@ ) ; return fprintf ( @@a2@@ , String , @@v9@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__int64 __fastcall hash_lookup ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; _QWORD * @@i@@ ; _QWORD * @@v5@@ ; @@v2@@ = * @@a1@@ ; @@v5@@ = ( _QWORD * ) ( @@v2@@ + Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) ) ; if ( ( unsigned __int64 ) @@v5@@ >= @@a1@@ [ Number ] ) abort ( ) ; if ( ! * @@v5@@ ) return Number L ; for ( @@i@@ = @@v5@@ ; @@i@@ ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { if ( @@a2@@ == * @@i@@ || ( ( unsigned __int8 ( __fastcall * ) ( __int64 , _QWORD ) ) @@a1@@ [ Number ] ) ( @@a2@@ , * @@i@@ ) ) { return * @@i@@ ; } } return Number L ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
int unsetenv ( const char * @@name@@ ) { return unsetenv ( @@name@@ ) ; }
size_t __fastcall rpl_vfprintf ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { size_t @@result@@ ; size_t @@v4@@ ; int @@v5@@ ; size_t @@v6@@ ; void * @@ptr@@ ; size_t @@n@@ ; char @@v9@@ [ Number ] ; unsigned __int64 @@v10@@ ; @@v10@@ = __readfsqword ( Number ) ; @@v6@@ = Number L ; @@ptr@@ = ( void * ) vasnprintf ( @@v9@@ , & @@v6@@ , @@a2@@ , @@a3@@ ) ; @@n@@ = @@v6@@ ; if ( @@ptr@@ ) { @@v4@@ = fwrite ( @@ptr@@ , Number , @@n@@ , @@a1@@ ) ; if ( @@n@@ <= @@v4@@ ) { if ( @@ptr@@ != @@v9@@ ) free ( @@ptr@@ ) ; if ( @@n@@ <= Number ) { @@result@@ = @@n@@ ; } else { * __errno_location ( ) = Number ; fseterr ( @@a1@@ ) ; @@result@@ = Number ; } } else { if ( @@ptr@@ != @@v9@@ ) { @@v5@@ = * __errno_location ( ) ; free ( @@ptr@@ ) ; * __errno_location ( ) = @@v5@@ ; } @@result@@ = Number ; } } else { fseterr ( @@a1@@ ) ; @@result@@ = Number ; } return @@result@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int64 __fastcall hash_get_first ( unsigned __int64 * @@a1@@ ) { unsigned __int64 @@i@@ ; if ( ! @@a1@@ [ Number ] ) return Number L ; for ( @@i@@ = * @@a1@@ ; ; @@i@@ += Number L ) { if ( @@i@@ >= @@a1@@ [ Number ] ) abort ( ) ; if ( * ( _QWORD * ) @@i@@ ) break ; } return * ( _QWORD * ) @@i@@ ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_20C0A8 ; @@v8@@ [ Number ] = qword_20C0B0 ; @@v8@@ [ Number ] = qword_20C0B8 ; @@v8@@ [ Number ] = qword_20C0C0 ; @@v8@@ [ Number ] = qword_20C0C8 ; @@v8@@ [ Number ] = qword_20C0D0 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
unsigned __int64 __fastcall xmax ( unsigned __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { unsigned __int64 @@result@@ ; @@result@@ = @@a2@@ ; if ( @@a1@@ >= @@a2@@ ) @@result@@ = @@a1@@ ; return @@result@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
__int64 __fastcall hash_get_next ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; _QWORD * @@v4@@ ; _QWORD * @@i@@ ; @@v2@@ = * @@a1@@ ; @@v4@@ = ( _QWORD * ) ( @@v2@@ + Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) ) ; if ( ( unsigned __int64 ) @@v4@@ >= @@a1@@ [ Number ] ) abort ( ) ; for ( @@i@@ = @@v4@@ ; @@i@@ ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { if ( @@a2@@ == * @@i@@ && @@i@@ [ Number ] ) return * ( _QWORD * ) @@i@@ [ Number ] ; } while ( Number ) { @@v4@@ += Number ; if ( ( unsigned __int64 ) @@v4@@ >= @@a1@@ [ Number ] ) break ; if ( * @@v4@@ ) return * @@v4@@ ; } return Number L ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 __fastcall xsum_0 ( unsigned __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; if ( @@a1@@ + @@a2@@ < @@a1@@ ) @@result@@ = Number ; else @@result@@ = @@a1@@ + @@a2@@ ; return @@result@@ ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
unsigned __int64 __fastcall hash_get_entries ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; _QWORD * @@i@@ ; _QWORD * @@j@@ ; @@v5@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = @@i@@ ; @@j@@ ; @@j@@ = ( _QWORD * ) @@j@@ [ Number ] ) { if ( @@v5@@ >= @@a3@@ ) return @@v5@@ ; @@v4@@ = @@v5@@ ++ ; * ( _QWORD * ) ( @@a2@@ + Number * @@v4@@ ) = * @@j@@ ; } } } return @@v5@@ ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
__int64 __fastcall to_hour ( __int64 @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( @@a2@@ ) { if ( @@a2@@ == Number ) { if ( @@a1@@ <= Number || @@a1@@ > Number ) { if ( @@a1@@ == Number ) @@result@@ = Number L ; else @@result@@ = Number ; } else { @@result@@ = ( unsigned int ) ( @@a1@@ + Number ) ; } } else if ( @@a1@@ < Number || @@a1@@ > Number ) { @@result@@ = Number ; } else { @@result@@ = @@a1@@ ; } } else if ( @@a1@@ > Number && @@a1@@ <= Number ) { @@result@@ = @@a1@@ ; } else if ( @@a1@@ == Number ) { @@result@@ = Number L ; } else { @@result@@ = Number ; } return @@result@@ ; }
struct tm * localtime ( const time_t * @@timer@@ ) { return localtime ( @@timer@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
const char * __fastcall get_tz ( void * @@a1@@ ) { const char * @@v1@@ ; const char * @@s@@ ; size_t @@n@@ ; @@s@@ = getenv ( String ) ; if ( @@s@@ ) { @@n@@ = strlen ( @@s@@ ) + Number ; if ( @@n@@ > Number ) @@v1@@ = ( const char * ) xmemdup ( @@s@@ , @@n@@ ) ; else @@v1@@ = ( const char * ) memcpy ( @@a1@@ , @@s@@ , @@n@@ ) ; @@s@@ = @@v1@@ ; } return @@s@@ ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall hash_do_for_each ( __int64 @@a1@@ , unsigned __int8 ( __fastcall * @@a2@@ ) ( _QWORD , __int64 ) , __int64 @@a3@@ ) { __int64 @@v5@@ ; _QWORD * @@i@@ ; _QWORD * @@j@@ ; @@v5@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = @@i@@ ; @@j@@ ; @@j@@ = ( _QWORD * ) @@j@@ [ Number ] ) { if ( @@a2@@ ( * @@j@@ , @@a3@@ ) != Number ) return @@v5@@ ; ++ @@v5@@ ; } } } return @@v5@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ ) { return xmalloc ( @@a1@@ ) ; }
__int64 __fastcall xsum ( unsigned __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; if ( @@a1@@ + @@a2@@ < @@a1@@ ) @@result@@ = Number ; else @@result@@ = @@a1@@ + @@a2@@ ; return @@result@@ ; }
__int64 __fastcall argmatch ( const char * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { __int64 @@result@@ ; char @@v7@@ ; __int64 @@i@@ ; __int64 @@v9@@ ; size_t @@n@@ ; @@v9@@ = Number ; @@v7@@ = Number ; @@n@@ = strlen ( @@a1@@ ) ; for ( @@i@@ = Number L ; * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; ++ @@i@@ ) { if ( ! strncmp ( * ( const char * * ) ( Number * @@i@@ + @@a2@@ ) , @@a1@@ , @@n@@ ) ) { if ( @@n@@ == strlen ( * ( const char * * ) ( Number * @@i@@ + @@a2@@ ) ) ) return @@i@@ ; if ( @@v9@@ == Number ) { @@v9@@ = @@i@@ ; } else if ( ! @@a3@@ || memcmp ( ( const void * ) ( @@a4@@ * @@v9@@ + @@a3@@ ) , ( const void * ) ( @@i@@ * @@a4@@ + @@a3@@ ) , @@a4@@ ) ) { @@v7@@ = Number ; } } } if ( @@v7@@ ) @@result@@ = Number ; else @@result@@ = @@v9@@ ; return @@result@@ ; }
unsigned __int64 __fastcall hash_string ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ ) { unsigned __int64 @@v4@@ ; @@v4@@ = Number L ; while ( * @@a1@@ ) @@v4@@ = ( Number * @@v4@@ + ( unsigned __int8 ) * @@a1@@ ++ ) % @@a2@@ ; return @@v4@@ ; }
int __fxstatat ( int @@ver@@ , int @@fildes@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ , int @@flag@@ ) { return _fxstatat ( @@ver@@ , @@fildes@@ , @@filename@@ , @@stat_buf@@ , @@flag@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
__int64 decimal_point_char ( ) { __int64 @@result@@ ; char * @@v1@@ ; @@v1@@ = nl_langinfo ( Number ) ; if ( * @@v1@@ ) @@result@@ = ( unsigned __int8 ) * @@v1@@ ; else @@result@@ = Number L ; return @@result@@ ; }
int feof ( FILE * @@stream@@ ) { return feof ( @@stream@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
int tolower ( int @@c@@ ) { return tolower ( @@c@@ ) ; }
bool __fastcall is_prime ( unsigned __int64 @@a1@@ ) { unsigned __int64 @@v2@@ ; unsigned __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; @@v2@@ = Number L ; @@v4@@ = Number L ; while ( @@v4@@ < @@a1@@ && @@a1@@ % @@v2@@ ) { @@v3@@ = @@v2@@ + Number ; @@v4@@ += Number * @@v3@@ ; @@v2@@ = @@v3@@ + Number ; } return @@a1@@ % @@v2@@ != Number ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
time_t mktime ( struct tm * @@tp@@ ) { return mktime ( @@tp@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
unsigned __int64 __fastcall compute_bucket_size ( __int64 @@a1@@ , __int64 @@a2@@ ) { float @@v2@@ ; unsigned __int64 @@result@@ ; unsigned __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; float @@v6@@ ; @@v4@@ = @@a1@@ ; if ( * ( _BYTE * ) ( @@a2@@ + Number ) != Number ) { if ( @@a1@@ < Number ) @@v2@@ = ( float ) ( @@a1@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@a1@@ >> Number ) ) + ( float ) ( @@a1@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@a1@@ >> Number ) ) ; else @@v2@@ = ( float ) ( int ) @@a1@@ ; @@v6@@ = @@v2@@ / * ( float * ) ( @@a2@@ + Number ) ; if ( @@v6@@ >= Number ) return Number L ; if ( @@v6@@ >= Number ) @@v4@@ = ( unsigned int ) ( int ) ( float ) ( @@v6@@ - Number ) ^ Number ; else @@v4@@ = ( unsigned int ) ( int ) @@v6@@ ; } @@v5@@ = next_prime ( @@v4@@ ) ; if ( @@v5@@ <= Number ) @@result@@ = @@v5@@ ; else @@result@@ = Number L ; return @@result@@ ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
int toupper ( int @@c@@ ) { return toupper ( @@c@@ ) ; }
void free ( void * @@ptr@@ ) { __imp_free ( @@ptr@@ ) ; }
__int64 __fastcall posixtime ( time_t * @@a1@@ , const char * @@a2@@ , unsigned int @@a3@@ ) { time_t @@timer@@ ; char @@v6@@ [ Number ] ; struct tm * @@v7@@ ; char * @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; __int64 @@v12@@ ; __int64 @@v13@@ ; __int64 @@v14@@ ; const char * @@v15@@ ; struct tm @@tp@@ ; char @@dest@@ [ Number ] ; unsigned __int64 @@v18@@ ; @@v18@@ = __readfsqword ( Number ) ; if ( ( unsigned int ) posix_time_parse ( & @@v9@@ , @@a2@@ , @@a3@@ ) ) return Number L ; * ( _QWORD * ) & @@tp@@ . tm_sec = @@v9@@ ; * ( _QWORD * ) & @@tp@@ . tm_hour = @@v10@@ ; * ( _QWORD * ) & @@tp@@ . tm_mon = @@v11@@ ; * ( _QWORD * ) & @@tp@@ . tm_wday = @@v12@@ ; * ( & @@tp@@ . tm_isdst + Number ) = HIDWORD ( @@v13@@ ) ; @@tp@@ . tm_gmtoff = @@v14@@ ; @@tp@@ . tm_zone = @@v15@@ ; @@tp@@ . tm_isdst = Number ; @@timer@@ = mktime ( & @@tp@@ ) ; if ( @@timer@@ == Number ) { @@v7@@ = localtime ( & @@timer@@ ) ; if ( ! @@v7@@ ) return Number L ; } else { @@v7@@ = & @@tp@@ ; } if ( ! ( HIDWORD ( @@v9@@ ) ^ @@v7@@ -> tm_min | ( unsigned int ) @@v10@@ ^ @@v7@@ -> tm_hour | HIDWORD ( @@v10@@ ) ^ @@v7@@ -> tm_mday | ( unsigned int ) @@v11@@ ^ @@v7@@ -> tm_mon | @@v7@@ -> tm_year ^ HIDWORD ( @@v11@@ ) | ( unsigned int ) @@v9@@ ^ @@v7@@ -> tm_sec ) ) goto LABEL_12 ; if ( ( _DWORD ) @@v9@@ != Number ) return Number L ; @@v8@@ = stpcpy ( @@dest@@ , @@a2@@ ) ; strcpy ( @@v8@@ - Number , String ) ; if ( ( unsigned __int8 ) posixtime ( ( time_t * ) @@v6@@ , @@dest@@ , @@a3@@ ) != Number ) return Number L ; LABEL_12 : * @@a1@@ = @@timer@@ ; return Number L ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
DIR * opendir ( const char * @@name@@ ) { return opendir ( @@name@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
void * __fastcall allocate_entry ( __int64 @@a1@@ ) { __int64 @@v2@@ ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return malloc ( Number ) ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = * ( _QWORD * ) ( @@v2@@ + Number ) ; return ( void * ) @@v2@@ ; }
__int64 __fastcall bad_cast ( __int64 @@a1@@ ) { return @@a1@@ ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
int clock_gettime ( clockid_t @@clock_id@@ , struct timespec * @@tp@@ ) { return clock_gettime ( @@clock_id@@ , @@tp@@ ) ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
__int64 __fastcall free_entry ( __int64 @@a1@@ , _QWORD * @@a2@@ ) { __int64 @@result@@ ; * @@a2@@ = Number L ; @@a2@@ [ Number ] = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@result@@ = @@a1@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall duinfo_set ( _QWORD * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ ) { __int64 @@result@@ ; * @@a1@@ = @@a2@@ ; @@result@@ = @@a3@@ ; @@a1@@ [ Number ] = @@a3@@ ; @@a1@@ [ Number ] = @@a4@@ ; return @@result@@ ; }
int fileno ( FILE * @@stream@@ ) { return fileno ( @@stream@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
_DWORD * __fastcall md5_read_ctx ( int * @@a1@@ , _DWORD * @@a2@@ ) { set_uint32 ( @@a2@@ , * @@a1@@ ) ; set_uint32 ( @@a2@@ + Number , @@a1@@ [ Number ] ) ; set_uint32 ( @@a2@@ + Number , @@a1@@ [ Number ] ) ; set_uint32 ( @@a2@@ + Number , @@a1@@ [ Number ] ) ; return @@a2@@ ; }
unsigned __int64 __fastcall print_only_size ( __int64 @@a1@@ ) { FILE * @@v1@@ ; const char * @@v2@@ ; char @@v4@@ [ Number ] ; unsigned __int64 @@v5@@ ; @@v5@@ = __readfsqword ( Number ) ; @@v1@@ = stdout ; @@v2@@ = ( const char * ) human_readable ( @@a1@@ , @@v4@@ , ( unsigned int ) human_output_opts , Number L , output_block_size ) ; fputs_unlocked ( @@v2@@ , @@v1@@ ) ; return __readfsqword ( Number ) ^ @@v5@@ ; }
int __fxstat ( int @@ver@@ , int @@fildes@@ , struct stat * @@stat_buf@@ ) { return _fxstat ( @@ver@@ , @@fildes@@ , @@stat_buf@@ ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
wint_t towlower ( wint_t @@wc@@ ) { return towlower ( @@wc@@ ) ; }
__int64 __fastcall argv_iter ( __int64 @@a1@@ , int * @@a2@@ ) { int @@v2@@ ; __int64 @@result@@ ; __int64 * @@v4@@ ; if ( * ( _QWORD * ) @@a1@@ ) { if ( getdelim ( ( char * * ) ( @@a1@@ + Number ) , ( size_t * ) ( @@a1@@ + Number ) , Number , * ( FILE * * ) @@a1@@ ) >= Number ) { * @@a2@@ = Number ; ++ * ( _QWORD * ) ( @@a1@@ + Number ) ; @@result@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; } else { if ( feof ( * ( FILE * * ) @@a1@@ ) ) @@v2@@ = Number ; else @@v2@@ = Number ; * @@a2@@ = @@v2@@ ; @@result@@ = Number L ; } } else if ( * * ( _QWORD * * ) ( @@a1@@ + Number ) ) { * @@a2@@ = Number ; @@v4@@ = * ( __int64 * * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v4@@ + Number ; @@result@@ = * @@v4@@ ; } else { * @@a2@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
_DWORD * __fastcall md5_finish_ctx ( int * @@a1@@ , _DWORD * @@a2@@ ) { __int64 @@v2@@ ; unsigned int @@v4@@ ; __int64 @@v5@@ ; @@v4@@ = @@a1@@ [ Number ] ; if ( @@v4@@ > Number ) @@v2@@ = Number L ; else @@v2@@ = Number L ; @@v5@@ = @@v2@@ ; @@a1@@ [ Number ] += @@v4@@ ; if ( @@v4@@ > @@a1@@ [ Number ] ) ++ @@a1@@ [ Number ] ; @@a1@@ [ @@v2@@ + Number ] = Number * @@a1@@ [ Number ] ; @@a1@@ [ @@v2@@ + Number ] = * ( ( __int64 * ) @@a1@@ + Number ) >> Number ; memcpy ( ( char * ) @@a1@@ + @@v4@@ + Number , & fillbuf_0 , Number * @@v2@@ - @@v4@@ - Number ) ; md5_process_block ( @@a1@@ + Number , Number * @@v5@@ , @@a1@@ ) ; return md5_read_ctx ( @@a1@@ , @@a2@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; char * @@v3@@ ; FILE * @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; FILE * @@v10@@ ; char * @@v11@@ ; FILE * @@v12@@ ; char * @@v13@@ ; FILE * @@v14@@ ; char * @@v15@@ ; FILE * @@v16@@ ; char * @@v17@@ ; FILE * @@v18@@ ; char * @@v19@@ ; @@v1@@ = program_name ; if ( @@a1@@ ) { @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = gettext ( String ) ; printf ( @@v3@@ , @@v1@@ ) ; @@v4@@ = stdout ; @@v5@@ = gettext ( String String String String String String String String ) ; fputs_unlocked ( @@v5@@ , @@v4@@ ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; @@v8@@ = stdout ; @@v9@@ = gettext ( String String String String ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = stdout ; @@v11@@ = gettext ( String String String String ) ; fputs_unlocked ( @@v11@@ , @@v10@@ ) ; @@v12@@ = stdout ; @@v13@@ = gettext ( String String String String String ) ; fputs_unlocked ( @@v13@@ , @@v12@@ ) ; @@v14@@ = stdout ; @@v15@@ = gettext ( String ) ; fputs_unlocked ( @@v15@@ , @@v14@@ ) ; @@v16@@ = stdout ; @@v17@@ = gettext ( String ) ; fputs_unlocked ( @@v17@@ , @@v16@@ ) ; @@v18@@ = stdout ; @@v19@@ = gettext ( String ) ; fputs_unlocked ( @@v19@@ , @@v18@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall mkstemp_safer ( char * @@a1@@ ) { unsigned int @@v1@@ ; @@v1@@ = mkstemp ( @@a1@@ ) ; return fd_safer ( @@v1@@ ) ; }
int __fastcall emit_blocksize_note ( __int64 @@a1@@ ) { char * @@v1@@ ; @@v1@@ = gettext ( String String String String ) ; return printf ( @@v1@@ , @@a1@@ ) ; }
__int64 __fastcall argmatch ( const char * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { __int64 @@result@@ ; char @@v7@@ ; __int64 @@i@@ ; __int64 @@v9@@ ; size_t @@n@@ ; @@v9@@ = Number ; @@v7@@ = Number ; @@n@@ = strlen ( @@a1@@ ) ; for ( @@i@@ = Number L ; * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; ++ @@i@@ ) { if ( ! strncmp ( * ( const char * * ) ( Number * @@i@@ + @@a2@@ ) , @@a1@@ , @@n@@ ) ) { if ( @@n@@ == strlen ( * ( const char * * ) ( Number * @@i@@ + @@a2@@ ) ) ) return @@i@@ ; if ( @@v9@@ == Number ) { @@v9@@ = @@i@@ ; } else if ( ! @@a3@@ || memcmp ( ( const void * ) ( @@a4@@ * @@v9@@ + @@a3@@ ) , ( const void * ) ( @@i@@ * @@a4@@ + @@a3@@ ) , @@a4@@ ) ) { @@v7@@ = Number ; } } } if ( @@v7@@ ) @@result@@ = Number ; else @@result@@ = @@v9@@ ; return @@result@@ ; }
double physmem_total ( ) { double @@result@@ ; double @@v1@@ ; double @@v2@@ ; @@v1@@ = ( double ) ( int ) sysconf ( Number ) ; @@v2@@ = ( double ) ( int ) sysconf ( Number ) ; if ( @@v1@@ < Number || @@v2@@ < Number ) @@result@@ = Number ; else @@result@@ = @@v1@@ * @@v2@@ ; return @@result@@ ; }
__int64 __fastcall get_stat_atime ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
__int64 __fastcall fnmatch_pattern_has_wildcards ( const char * @@a1@@ , char @@a2@@ ) { char * @@reject@@ ; size_t @@v5@@ ; @@reject@@ = String ; if ( ( @@a2@@ & Number ) != Number ) @@reject@@ = String ; while ( * @@a1@@ ) { @@v5@@ = strcspn ( @@a1@@ , @@reject@@ ) ; if ( ! @@a1@@ [ @@v5@@ ] ) break ; if ( @@a1@@ [ @@v5@@ ] != Number ) return Number L ; @@a1@@ += @@v5@@ + Number ; if ( * @@a1@@ ) ++ @@a1@@ ; } return Number L ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; FILE * @@v10@@ ; char * @@v11@@ ; FILE * @@v12@@ ; char * @@v13@@ ; FILE * @@v14@@ ; char * @@v15@@ ; FILE * @@v16@@ ; char * @@v17@@ ; FILE * @@v18@@ ; char * @@v19@@ ; FILE * @@v20@@ ; char * @@v21@@ ; FILE * @@v22@@ ; char * @@v23@@ ; FILE * @@v24@@ ; char * @@v25@@ ; FILE * @@v26@@ ; char * @@v27@@ ; if ( @@a1@@ ) { @@v1@@ = program_name ; @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = program_name ; @@v4@@ = program_name ; @@v5@@ = gettext ( String ) ; printf ( @@v5@@ , @@v4@@ , @@v3@@ ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; @@v8@@ = stdout ; @@v9@@ = gettext ( String ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = stdout ; @@v11@@ = gettext ( String String String String String ) ; fputs_unlocked ( @@v11@@ , @@v10@@ ) ; @@v12@@ = stdout ; @@v13@@ = gettext ( String String String String String ) ; fputs_unlocked ( @@v13@@ , @@v12@@ ) ; @@v14@@ = stdout ; @@v15@@ = gettext ( String String String String String String ) ; fputs_unlocked ( @@v15@@ , @@v14@@ ) ; @@v16@@ = stdout ; @@v17@@ = gettext ( String String String ) ; fputs_unlocked ( @@v17@@ , @@v16@@ ) ; @@v18@@ = stdout ; @@v19@@ = gettext ( String String String String String ) ; fputs_unlocked ( @@v19@@ , @@v18@@ ) ; @@v20@@ = stdout ; @@v21@@ = gettext ( String String String String String String String ) ; fputs_unlocked ( @@v21@@ , @@v20@@ ) ; @@v22@@ = stdout ; @@v23@@ = gettext ( String String String String String String String ) ; fputs_unlocked ( @@v23@@ , @@v22@@ ) ; @@v24@@ = stdout ; @@v25@@ = gettext ( String ) ; fputs_unlocked ( @@v25@@ , @@v24@@ ) ; @@v26@@ = stdout ; @@v27@@ = gettext ( String ) ; fputs_unlocked ( @@v27@@ , @@v26@@ ) ; emit_blocksize_note ( ( __int64 ) String ) ; emit_size_note ( ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
int __fastcall argmatch_valid ( __int64 @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { char * @@v3@@ ; __int64 @@i@@ ; void * @@s1@@ ; @@s1@@ = Number L ; @@v3@@ = gettext ( String ) ; fprintf ( stderr , @@v3@@ ) ; for ( @@i@@ = Number L ; * ( _QWORD * ) ( Number * @@i@@ + @@a1@@ ) ; ++ @@i@@ ) { if ( @@i@@ && ! memcmp ( @@s1@@ , ( const void * ) ( @@i@@ * @@a3@@ + @@a2@@ ) , @@a3@@ ) ) { fprintf ( stderr , String , * ( const char * * ) ( Number * @@i@@ + @@a1@@ ) ) ; } else { fprintf ( stderr , String , * ( const char * * ) ( Number * @@i@@ + @@a1@@ ) ) ; @@s1@@ = ( void * ) ( @@i@@ * @@a3@@ + @@a2@@ ) ; } } return putc_unlocked ( Number , stderr ) ; }
__int64 __fastcall validate_timespec ( _QWORD * @@a1@@ ) { __int64 @@result@@ ; int @@v2@@ ; int @@v3@@ ; @@v2@@ = Number ; @@v3@@ = Number ; if ( ! @@a1@@ ) __assert_fail ( String , String , Number , String ) ; if ( ( @@a1@@ [ Number ] == Number || @@a1@@ [ Number ] == Number L || ( __int64 ) @@a1@@ [ Number ] >= Number && ( __int64 ) @@a1@@ [ Number ] <= Number ) && ( @@a1@@ [ Number ] == Number || @@a1@@ [ Number ] == Number L || ( __int64 ) @@a1@@ [ Number ] >= Number && ( __int64 ) @@a1@@ [ Number ] <= Number ) ) { if ( @@a1@@ [ Number ] == Number || @@a1@@ [ Number ] == Number L ) { * @@a1@@ = Number L ; @@v2@@ = Number ; if ( @@a1@@ [ Number ] == Number L ) @@v3@@ = Number ; } if ( @@a1@@ [ Number ] == Number || @@a1@@ [ Number ] == Number L ) { @@a1@@ [ Number ] = Number L ; @@v2@@ = Number ; if ( @@a1@@ [ Number ] == Number L ) ++ @@v3@@ ; } @@result@@ = ( unsigned int ) ( @@v3@@ == Number ) + @@v2@@ ; } else { * __errno_location ( ) = Number ; @@result@@ = Number ; } return @@result@@ ; }
_BOOL8 __fastcall excluded_file_name_p ( __int64 @@a1@@ , char * @@a2@@ , char * @@a3@@ ) { int @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; @@v6@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; @@v7@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; do { strcpy ( @@a3@@ , @@a2@@ ) ; while ( Number ) { if ( hash_lookup ( @@v7@@ , @@a3@@ ) ) return ( @@v6@@ & Number ) == Number ; if ( ( @@v6@@ & Number ) == Number ) break ; @@v8@@ = strrchr ( @@a3@@ , Number ) ; if ( ! @@v8@@ ) break ; * @@v8@@ = Number ; } if ( ( @@v6@@ & Number ) != Number ) break ; @@a2@@ = strchr ( @@a2@@ , Number ) ; if ( @@a2@@ ) ++ @@a2@@ ; } while ( @@a2@@ ) ; return ( @@v6@@ & Number ) != Number ; }
__int64 __fastcall xstr_cd_iconv ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v3@@ ; @@v3@@ = str_cd_iconv ( @@a1@@ , @@a2@@ ) ; if ( ! @@v3@@ && * __errno_location ( ) == Number ) xalloc_die ( ) ; return @@v3@@ ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 __fastcall fwrite_uppcase ( FILE * @@a1@@ , unsigned __int8 * @@a2@@ , __int64 @@a3@@ ) { int @@v3@@ ; __int64 @@result@@ ; while ( Number ) { @@result@@ = @@a3@@ -- ; if ( ! @@result@@ ) break ; @@v3@@ = toupper ( * @@a2@@ ) ; fputc ( @@v3@@ , @@a1@@ ) ; ++ @@a2@@ ; } return @@result@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
_BOOL8 __fastcall AD_compare ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { return @@a1@@ [ Number ] == @@a2@@ [ Number ] && * @@a1@@ == * @@a2@@ ; }
void __fastcall argmatch_invalid ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { char * @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; char * @@format@@ ; if ( @@a3@@ == Number ) @@v3@@ = gettext ( String ) ; else @@v3@@ = gettext ( String ) ; @@format@@ = @@v3@@ ; @@v4@@ = quote_n ( Number L , @@a1@@ ) ; @@v5@@ = quotearg_n_style ( Number L , Number L , @@a2@@ ) ; error ( Number , Number , @@format@@ , @@v5@@ , @@v4@@ ) ; }
_BOOL8 __fastcall c_isalnum ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number || ( int ) ( @@a1@@ & Number ) > Number && ( int ) ( @@a1@@ & Number ) <= Number ; }
__int64 posix2_version ( ) { __int64 @@result@@ ; char * @@endptr@@ ; __int64 @@v2@@ ; char * @@nptr@@ ; __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; @@v5@@ = __readfsqword ( Number ) ; @@v2@@ = Number L ; @@nptr@@ = getenv ( String ) ; if ( @@nptr@@ ) { if ( * @@nptr@@ ) { @@v4@@ = strtol ( @@nptr@@ , & @@endptr@@ , Number ) ; if ( ! * @@endptr@@ ) @@v2@@ = @@v4@@ ; } } if ( @@v2@@ < ( __int64 ) Number ) return Number ; @@result@@ = Number ; if ( @@v2@@ <= Number ) @@result@@ = @@v2@@ ; return @@result@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
__int64 __fastcall _xargmatch_internal ( __int64 @@a1@@ , const char * @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ , void ( * @@a6@@ ) ( void ) ) { __int64 @@v11@@ ; @@v11@@ = argmatch ( @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; if ( @@v11@@ >= Number ) return @@v11@@ ; argmatch_invalid ( @@a1@@ , ( __int64 ) @@a2@@ , @@v11@@ ) ; argmatch_valid ( @@a3@@ , @@a4@@ , @@a5@@ ) ; @@a6@@ ( ) ; return Number ; }
__int64 __fastcall enter_dir ( __int64 @@a1@@ , __int64 @@a2@@ ) { _QWORD * @@ptr@@ ; __int64 @@v4@@ ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { @@ptr@@ = malloc ( Number ) ; if ( ! @@ptr@@ ) return Number L ; * @@ptr@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@ptr@@ [ Number ] = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@ptr@@ [ Number ] = @@a2@@ ; @@v4@@ = hash_insert ( * ( _QWORD * ) ( @@a1@@ + Number ) , @@ptr@@ ) ; if ( ( _QWORD * ) @@v4@@ != @@ptr@@ ) { free ( @@ptr@@ ) ; if ( ! @@v4@@ ) return Number L ; * ( _QWORD * ) @@a2@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; * ( _WORD * ) ( @@a2@@ + Number ) = Number ; } } else if ( ( unsigned __int8 ) cycle_check ( * ( _QWORD * ) ( @@a1@@ + Number ) , @@a2@@ + Number ) ) { * ( _QWORD * ) @@a2@@ = @@a2@@ ; * ( _WORD * ) ( @@a2@@ + Number ) = Number ; } return Number L ; }
_BOOL8 __fastcall c_iscntrl ( int @@a1@@ ) { return ( @@a1@@ & Number ) == Number || @@a1@@ == Number ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall cwd_advance_fd ( __int64 @@a1@@ , int @@a2@@ , char @@a3@@ ) { __int64 @@result@@ ; int @@v4@@ ; int @@fd@@ ; @@v4@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; if ( @@v4@@ == @@a2@@ && @@v4@@ != Number ) abort ( ) ; if ( @@a3@@ ) { @@fd@@ = i_ring_push ( @@a1@@ + Number , ( unsigned int ) @@v4@@ ) ; if ( @@fd@@ >= Number ) close ( @@fd@@ ) ; } else if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) == Number && @@v4@@ >= Number ) { close ( @@v4@@ ) ; } @@result@@ = @@a1@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
bool __fastcall LCO_compare ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { return * @@a1@@ == * @@a2@@ ; }
_BOOL8 __fastcall c_isgraph ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
_BOOL8 __fastcall c_isupper ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , off_16EB4 , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
__int64 __fastcall fts_children ( __int64 @@a1@@ , int @@a2@@ ) { __int64 @@v3@@ ; __int64 @@v4@@ ; int @@v5@@ ; int @@v6@@ ; int @@v7@@ ; int @@v8@@ ; unsigned int @@v9@@ ; int @@fd@@ ; int @@v11@@ ; if ( @@a2@@ && @@a2@@ != Number ) { * __errno_location ( ) = Number ; return Number L ; } @@v3@@ = * ( _QWORD * ) @@a1@@ ; * __errno_location ( ) = Number ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) return Number L ; if ( * ( _WORD * ) ( @@v3@@ + Number ) == Number ) return * ( _QWORD * ) ( @@v3@@ + Number ) ; if ( * ( _WORD * ) ( @@v3@@ + Number ) != Number ) return Number L ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) fts_lfree ( * ( void * * ) ( @@a1@@ + Number ) ) ; if ( @@a2@@ == Number ) { @@v8@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; BYTE1 ( @@v8@@ ) |= Number ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@v8@@ ; @@v9@@ = Number ; } else { @@v9@@ = Number ; } if ( * ( _QWORD * ) ( @@v3@@ + Number ) || * * ( _BYTE * * ) ( @@v3@@ + Number ) == Number || ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { * ( _QWORD * ) ( @@a1@@ + Number ) = fts_build ( @@a1@@ , @@v9@@ ) ; return * ( _QWORD * ) ( @@a1@@ + Number ) ; } @@fd@@ = diropen ( @@a1@@ , ( int ) String , @@v4@@ , @@v5@@ , @@v6@@ , @@v7@@ ) ; if ( @@fd@@ < Number ) { * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; return Number L ; } * ( _QWORD * ) ( @@a1@@ + Number ) = fts_build ( @@a1@@ , @@v9@@ ) ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { cwd_advance_fd ( @@a1@@ , @@fd@@ , Number ) ; } else { if ( fchdir ( @@fd@@ ) ) { @@v11@@ = * __errno_location ( ) ; close ( @@fd@@ ) ; * __errno_location ( ) = @@v11@@ ; return Number L ; } close ( @@fd@@ ) ; } return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int64 __fastcall c_tolower ( int @@a1@@ ) { __int64 @@result@@ ; if ( @@a1@@ <= Number || @@a1@@ > Number ) @@result@@ = ( unsigned int ) @@a1@@ ; else @@result@@ = ( unsigned int ) ( @@a1@@ + Number ) ; return @@result@@ ; }
__int64 __fastcall hash_get_n_buckets_used ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
int __fastcall stat ( char * @@filename@@ , struct stat * @@stat_buf@@ ) { return __xstat ( Number , @@filename@@ , @@stat_buf@@ ) ; }
int __fastcall fnmatch_no_wildcards ( const char * @@a1@@ , const char * @@a2@@ , char @@a3@@ ) { int @@result@@ ; char * @@v4@@ ; int @@v5@@ ; int @@v6@@ ; char * @@s@@ ; char * @@sa@@ ; char * @@ptr@@ ; size_t @@n@@ ; if ( ( @@a3@@ & Number ) != Number ) { if ( ( @@a3@@ & Number ) != Number ) { @@ptr@@ = ( char * ) xstrdup ( @@a2@@ ) ; @@s@@ = @@ptr@@ ; while ( Number ) { @@sa@@ = strchr ( @@s@@ , Number ) ; if ( @@sa@@ ) * @@sa@@ = Number ; @@v6@@ = mbscasecmp ( @@a1@@ , @@ptr@@ ) ; if ( ! @@sa@@ || @@v6@@ <= Number ) break ; @@v4@@ = @@sa@@ ; @@s@@ = @@sa@@ + Number ; * @@v4@@ = Number ; } free ( @@ptr@@ ) ; @@result@@ = @@v6@@ ; } else { @@n@@ = strlen ( @@a1@@ ) ; @@v5@@ = strncmp ( @@a1@@ , @@a2@@ , @@n@@ ) ; if ( ! @@v5@@ ) { @@v5@@ = @@a2@@ [ @@n@@ ] ; if ( @@v5@@ == Number ) @@v5@@ = Number ; } @@result@@ = @@v5@@ ; } } else if ( ( @@a3@@ & Number ) != Number ) { @@result@@ = mbscasecmp ( @@a1@@ , @@a2@@ ) ; } else { @@result@@ = strcmp ( @@a1@@ , @@a2@@ ) ; } return @@result@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
int __fastcall lstat ( char * @@filename@@ , struct stat * @@stat_buf@@ ) { return __lxstat ( Number , @@filename@@ , @@stat_buf@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_21B708 ; @@v4@@ [ Number ] = qword_21B710 ; @@v4@@ [ Number ] = qword_21B718 ; @@v4@@ [ Number ] = qword_21B720 ; @@v4@@ [ Number ] = qword_21B728 ; @@v4@@ [ Number ] = qword_21B730 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
_BOOL8 __fastcall hash_table_ok ( __int64 @@a1@@ ) { _QWORD * @@i@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; _QWORD * @@v5@@ ; @@v3@@ = Number L ; @@v4@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { @@v5@@ = @@i@@ ; ++ @@v3@@ ; ++ @@v4@@ ; while ( Number ) { @@v5@@ = ( _QWORD * ) @@v5@@ [ Number ] ; if ( ! @@v5@@ ) break ; ++ @@v4@@ ; } } } return @@v3@@ == * ( _QWORD * ) ( @@a1@@ + Number ) && @@v4@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_210128 ; @@v8@@ [ Number ] = qword_210130 ; @@v8@@ [ Number ] = qword_210138 ; @@v8@@ [ Number ] = qword_210140 ; @@v8@@ [ Number ] = qword_210148 ; @@v8@@ [ Number ] = qword_210150 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 __fastcall umaxtostr ( unsigned __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v4@@ ; @@v4@@ = @@a2@@ + Number ; * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; do { * ( _BYTE * ) -- @@v4@@ = @@a1@@ % Number + Number ; @@a1@@ /= Number ; } while ( @@a1@@ ) ; return @@v4@@ ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 __fastcall add_exclude_file ( void ( __fastcall * @@a1@@ ( ) ( exclude , constchar , int ) ) ( __int64 , _BYTE * , _QWORD ) , __int64 @@a2@@ , __int64 @@a3@@ , unsigned int @@a4@@ , unsigned __int8 @@a5@@ ) { bool @@v5@@ ; __int64 @@result@@ ; __int64 @@v7@@ ; _BOOL4 @@v8@@ ; bool @@v11@@ ; int @@v12@@ ; int @@v13@@ ; __int64 @@v14@@ ; FILE * @@stream@@ ; _BYTE * @@v16@@ ; _BYTE * @@i@@ ; _BYTE * @@v18@@ ; __int64 @@v19@@ ; _BYTE * @@v20@@ ; unsigned __int64 @@v21@@ ; unsigned __int64 @@v22@@ ; @@v22@@ = __readfsqword ( Number ) ; @@v5@@ = * ( _BYTE * ) @@a3@@ == Number && ! * ( _BYTE * ) ( @@a3@@ + Number ) ; @@v11@@ = @@v5@@ ; @@v16@@ = Number L ; @@v14@@ = Number L ; @@v19@@ = Number L ; @@v12@@ = Number ; if ( @@v5@@ ) { @@stream@@ = stdin ; } else { @@stream@@ = fopen ( ( const char * ) @@a3@@ , String ) ; if ( ! @@stream@@ ) return Number ; } while ( Number ) { @@v13@@ = getc_unlocked ( @@stream@@ ) ; if ( @@v13@@ == Number ) break ; if ( @@v19@@ == @@v14@@ ) @@v16@@ = ( _BYTE * ) x2realloc ( @@v16@@ , & @@v14@@ ) ; @@v7@@ = @@v19@@ ++ ; @@v16@@ [ @@v7@@ ] = @@v13@@ ; } if ( ferror_unlocked ( @@stream@@ ) ) @@v12@@ = * __errno_location ( ) ; if ( ! @@v11@@ && fclose ( @@stream@@ ) ) @@v12@@ = * __errno_location ( ) ; @@v16@@ = ( _BYTE * ) xrealloc ( @@v16@@ , @@v19@@ + Number ) ; @@v16@@ [ @@v19@@ ] = @@a5@@ ; @@v8@@ = @@v19@@ && @@a5@@ != @@v16@@ [ @@v19@@ - Number ] ; @@v21@@ = ( unsigned __int64 ) & @@v16@@ [ @@v19@@ + @@v8@@ ] ; @@v18@@ = @@v16@@ ; for ( @@i@@ = @@v16@@ ; ( unsigned __int64 ) @@i@@ < @@v21@@ ; ++ @@i@@ ) { if ( @@a5@@ == * @@i@@ ) { @@v20@@ = @@i@@ ; if ( ( ( * __ctype_b_loc ( ) ) [ @@a5@@ ] & Number ) != Number ) { while ( @@v20@@ != @@v18@@ ) { if ( ( ( * __ctype_b_loc ( ) ) [ ( unsigned __int8 ) * ( @@v20@@ - Number ) ] & Number ) == Number ) goto LABEL_28 ; -- @@v20@@ ; } } else { LABEL_28 : * @@v20@@ = Number ; @@a1@@ ( ) ( exclude , constchar , int ) ( @@a2@@ , @@v18@@ , @@a4@@ ) ; } @@v18@@ = @@i@@ + Number ; } } * __errno_location ( ) = @@v12@@ ; if ( @@v12@@ ) @@result@@ = Number ; else @@result@@ = Number L ; return @@result@@ ; }
__int64 __fastcall hash_get_next ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; _QWORD * @@v4@@ ; _QWORD * @@i@@ ; @@v2@@ = * @@a1@@ ; @@v4@@ = ( _QWORD * ) ( @@v2@@ + Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) ) ; if ( ( unsigned __int64 ) @@v4@@ >= @@a1@@ [ Number ] ) abort ( ) ; for ( @@i@@ = @@v4@@ ; @@i@@ ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { if ( @@a2@@ == * @@i@@ && @@i@@ [ Number ] ) return * ( _QWORD * ) @@i@@ [ Number ] ; } while ( Number ) { @@v4@@ += Number ; if ( ( unsigned __int64 ) @@v4@@ >= @@a1@@ [ Number ] ) break ; if ( * @@v4@@ ) return * @@v4@@ ; } return Number L ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( ) ; return @@ptr@@ ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
_BOOL8 __fastcall dirent_inode_sort_may_be_useful ( int @@a1@@ ) { struct statfs @@buf@@ ; unsigned __int64 @@v3@@ ; @@v3@@ = __readfsqword ( Number ) ; if ( fstatfs ( @@a1@@ , & @@buf@@ ) ) return Number L ; return @@buf@@ . f_type != Number && @@buf@@ . f_type != Number ; }
int __fastcall lutimens ( char * @@a1@@ , __int64 * @@a2@@ ) { struct timespec * @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; struct timespec * @@v6@@ ; __syscall_slong_t @@v7@@ ; struct timespec * @@v8@@ ; __syscall_slong_t @@v9@@ ; int @@v10@@ ; int @@v11@@ ; struct timespec * @@times@@ ; __int64 @@v13@@ [ Number ] ; struct stat @@v14@@ ; unsigned __int64 @@v15@@ ; @@v15@@ = __readfsqword ( Number ) ; if ( @@a2@@ ) @@v2@@ = ( struct timespec * ) @@v13@@ ; else @@v2@@ = Number L ; @@times@@ = @@v2@@ ; @@v10@@ = Number ; if ( @@v2@@ ) { @@v3@@ = @@a2@@ [ Number ] ; @@v13@@ [ Number ] = * @@a2@@ ; @@v13@@ [ Number ] = @@v3@@ ; @@v4@@ = @@a2@@ [ Number ] ; @@v13@@ [ Number ] = @@a2@@ [ Number ] ; @@v13@@ [ Number ] = @@v4@@ ; @@v10@@ = validate_timespec ( @@times@@ ) ; } if ( @@v10@@ < Number ) return Number ; if ( lutimensat_works_really >= Number ) { if ( @@v10@@ == Number ) { if ( ( unsigned int ) lstat ( @@a1@@ , & @@v14@@ ) ) return Number ; if ( @@times@@ -> tv_nsec == Number ) { @@v6@@ = @@times@@ ; @@times@@ -> tv_sec = get_stat_atime_0 ( ( __int64 ) & @@v14@@ ) ; @@v6@@ -> tv_nsec = @@v7@@ ; } else if ( @@times@@ [ Number ] . tv_nsec == Number ) { @@v8@@ = @@times@@ + Number ; @@times@@ [ Number ] . tv_sec = get_stat_mtime_0 ( ( __int64 ) & @@v14@@ ) ; @@v8@@ -> tv_nsec = @@v9@@ ; } @@v10@@ = Number ; } @@v11@@ = utimensat ( Number , @@a1@@ , @@times@@ , Number ) ; if ( @@v11@@ > Number ) * __errno_location ( ) = Number ; if ( ! @@v11@@ || * __errno_location ( ) != Number ) { utimensat_works_really = Number ; lutimensat_works_really = Number ; return @@v11@@ ; } } lutimensat_works_really = Number ; if ( ! @@v10@@ ) goto LABEL_37 ; if ( @@v10@@ != Number && ( unsigned int ) lstat ( @@a1@@ , & @@v14@@ ) ) return Number ; if ( @@times@@ && ( unsigned __int8 ) update_timespec ( ( __int64 ) & @@v14@@ , & @@times@@ ) ) { return Number ; } LABEL_37 : if ( ! @@v10@@ && ( unsigned int ) lstat ( @@a1@@ , & @@v14@@ ) ) return Number ; if ( ( @@v14@@ . st_mode & Number ) != Number ) return fdutimens ( @@a1@@ , Number , & @@times@@ -> tv_sec ) ; * __errno_location ( ) = Number ; return Number ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
bool __fastcall is_empty_dir ( int @@a1@@ , const char * @@a2@@ ) { bool @@result@@ ; int @@v3@@ ; int @@v4@@ ; DIR * @@dirp@@ ; struct dirent * @@v6@@ ; @@v3@@ = openat ( @@a1@@ , @@a2@@ , Number ) ; if ( @@v3@@ < Number ) return Number ; @@dirp@@ = fdopendir ( @@v3@@ ) ; if ( @@dirp@@ ) { * __errno_location ( ) = Number ; @@v6@@ = readdir_ignoring_dot_and_dotdot ( @@dirp@@ ) ; @@v4@@ = * __errno_location ( ) ; closedir ( @@dirp@@ ) ; if ( @@v6@@ ) @@result@@ = Number ; else @@result@@ = @@v4@@ == Number ; } else { close ( @@v3@@ ) ; @@result@@ = Number ; } return @@result@@ ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
__int64 __fastcall link_count_optimize_ok ( __int64 @@a1@@ ) { __int64 @@result@@ ; bool @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; _BYTE * @@ptr@@ ; __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v3@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; if ( ( * ( _DWORD * ) ( @@v4@@ + Number ) & Number ) == Number ) return Number L ; if ( ! @@v3@@ ) { * ( _QWORD * ) ( @@v4@@ + Number ) = hash_initialize ( Number L , Number L , LCO_hash , LCO_compare , & free ) ; @@v3@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; if ( ! @@v3@@ ) return Number L ; } @@v8@@ [ Number ] = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v5@@ = hash_lookup ( @@v3@@ , @@v8@@ ) ; if ( @@v5@@ ) return * ( unsigned __int8 * ) ( @@v5@@ + Number ) ; @@ptr@@ = malloc ( Number ) ; if ( ! @@ptr@@ ) return Number L ; @@v2@@ = leaf_optimization_applies ( * ( _DWORD * ) ( @@v4@@ + Number ) ) ; @@ptr@@ [ Number ] = @@v2@@ ; * ( _QWORD * ) @@ptr@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v6@@ = hash_insert ( @@v3@@ , @@ptr@@ ) ; if ( @@v6@@ ) { if ( ( _BYTE * ) @@v6@@ != @@ptr@@ ) abort ( ) ; @@result@@ = @@v2@@ ; } else { free ( @@ptr@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
bool __fastcall is_prime ( unsigned __int64 @@a1@@ ) { unsigned __int64 @@v2@@ ; unsigned __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; @@v2@@ = Number L ; @@v4@@ = Number L ; while ( @@v4@@ < @@a1@@ && @@a1@@ % @@v2@@ ) { @@v3@@ = @@v2@@ + Number ; @@v4@@ += Number * @@v3@@ ; @@v2@@ = @@v3@@ + Number ; } return @@a1@@ % @@v2@@ != Number ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
unsigned __int64 __fastcall xstrtol_error ( unsigned int @@a1@@ , int @@a2@@ , char @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , int @@a6@@ ) { char * @@v6@@ ; char * @@v10@@ ; char * @@msgid@@ ; char * @@v12@@ ; char @@v13@@ [ Number ] ; unsigned __int64 @@v14@@ ; @@v14@@ = __readfsqword ( Number ) ; @@v10@@ = ( char * ) & unk_17478 ; if ( @@a1@@ > Number ) { if ( @@a1@@ != Number ) goto LABEL_6 ; @@msgid@@ = String ; } else if ( @@a1@@ >= Number ) { @@msgid@@ = String ; } else { if ( @@a1@@ != Number ) LABEL_6 : abort ( ) ; @@msgid@@ = String ; } if ( @@a2@@ >= Number ) { @@v12@@ = * ( char * * ) ( Number L * @@a2@@ + @@a4@@ ) ; } else { @@v10@@ = ( char * ) & unk_17478 - @@a2@@ ; @@v13@@ [ Number ] = @@a3@@ ; @@v13@@ [ Number ] = Number ; @@v12@@ = @@v13@@ ; } @@v6@@ = gettext ( @@msgid@@ ) ; error ( @@a6@@ , Number , @@v6@@ , @@v10@@ , @@v12@@ , @@a5@@ ) ; return __readfsqword ( Number ) ^ @@v14@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
_BOOL8 __fastcall dot_or_dotdot ( _BYTE * @@a1@@ ) { __int64 @@v1@@ ; char @@v4@@ ; if ( * @@a1@@ != Number ) return Number L ; if ( @@a1@@ [ Number ] == Number ) @@v1@@ = Number L ; else @@v1@@ = Number L ; @@v4@@ = @@a1@@ [ @@v1@@ ] ; return ! @@v4@@ || @@v4@@ == Number ; }
__int64 __fastcall fts_padjust ( __int64 @@a1@@ , _QWORD * @@a2@@ ) { _QWORD * @@v2@@ ; __int64 @@result@@ ; _QWORD * @@i@@ ; __int64 @@v6@@ ; @@v6@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; for ( @@i@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; @@i@@ ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { if ( ( _QWORD * ) @@i@@ [ Number ] != @@i@@ + Number ) @@i@@ [ Number ] = @@v6@@ + @@i@@ [ Number ] - @@i@@ [ Number ] ; @@i@@ [ Number ] = @@v6@@ ; } while ( Number ) { @@result@@ = @@a2@@ [ Number ] ; if ( @@result@@ < Number ) break ; if ( ( _QWORD * ) @@a2@@ [ Number ] != @@a2@@ + Number ) @@a2@@ [ Number ] = @@v6@@ + @@a2@@ [ Number ] - @@a2@@ [ Number ] ; @@a2@@ [ Number ] = @@v6@@ ; if ( @@a2@@ [ Number ] ) @@v2@@ = ( _QWORD * ) @@a2@@ [ Number ] ; else @@v2@@ = ( _QWORD * ) @@a2@@ [ Number ] ; @@a2@@ = @@v2@@ ; } return @@result@@ ; }
_BOOL8 __fastcall c_isalnum ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number || ( int ) ( @@a1@@ & Number ) > Number && ( int ) ( @@a1@@ & Number ) <= Number ; }
void __fastcall hash_free ( __int64 @@a1@@ ) { _QWORD * @@i@@ ; _QWORD * @@j@@ ; _QWORD * @@ptr@@ ; _QWORD * @@ptra@@ ; _QWORD * @@ptrb@@ ; _QWORD * @@v6@@ ; _QWORD * @@v7@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) && * ( _QWORD * ) ( @@a1@@ + Number ) ) { for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@ptr@@ = @@i@@ ; @@ptr@@ ; @@ptr@@ = ( _QWORD * ) @@ptr@@ [ Number ] ) { ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@ptr@@ ) ; } } } } for ( @@j@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@j@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@j@@ += Number ) { for ( @@ptra@@ = ( _QWORD * ) @@j@@ [ Number ] ; @@ptra@@ ; @@ptra@@ = @@v6@@ ) { @@v6@@ = ( _QWORD * ) @@ptra@@ [ Number ] ; free ( @@ptra@@ ) ; } } for ( @@ptrb@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; @@ptrb@@ ; @@ptrb@@ = @@v7@@ ) { @@v7@@ = ( _QWORD * ) @@ptrb@@ [ Number ] ; free ( @@ptrb@@ ) ; } free ( * ( void * * ) @@a1@@ ) ; free ( ( void * ) @@a1@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
_BOOL8 __fastcall ignorable_failure ( int @@a1@@ , const char * @@a2@@ ) { return ignore_fail_on_non_empty && ( errno_rmdir_non_empty ( @@a1@@ ) || ( unsigned __int8 ) errno_may_be_empty ( @@a1@@ ) && is_empty_dir ( Number , @@a2@@ ) ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
__int64 __fastcall hash_lookup ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; _QWORD * @@i@@ ; _QWORD * @@v5@@ ; @@v2@@ = * @@a1@@ ; @@v5@@ = ( _QWORD * ) ( @@v2@@ + Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) ) ; if ( ( unsigned __int64 ) @@v5@@ >= @@a1@@ [ Number ] ) abort ( ) ; if ( ! * @@v5@@ ) return Number L ; for ( @@i@@ = @@v5@@ ; @@i@@ ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { if ( @@a2@@ == * @@i@@ || ( ( unsigned __int8 ( __fastcall * ) ( __int64 , _QWORD ) ) @@a1@@ [ Number ] ) ( @@a2@@ , * @@i@@ ) ) { return * @@i@@ ; } } return Number L ; }
_BOOL8 __fastcall c_iscntrl ( int @@a1@@ ) { return ( @@a1@@ & Number ) == Number || @@a1@@ == Number ; }
long double __fastcall adjust_value ( int @@a1@@ , long double @@a2@@ ) { _BOOL4 @@v7@@ ; unsigned __int64 @@v9@@ ; if ( @@a1@@ != Number && @@a2@@ < Number ) { if ( @@a2@@ >= Number ) @@v9@@ = ( __int64 ) ( @@a2@@ - Number ) ^ Number ; else @@v9@@ = ( __int64 ) @@a2@@ ; @@v7@@ = ! @@a1@@ && @@a2@@ != ( long double ) @@v9@@ ; @@a2@@ = ( long double ) ( @@v7@@ + @@v9@@ ) ; } return @@a2@@ ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { char * @@v1@@ ; char * @@v2@@ ; char * @@v3@@ ; FILE * @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; FILE * @@v10@@ ; char * @@v11@@ ; @@v1@@ = program_name ; if ( @@a1@@ ) { @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = gettext ( String ) ; printf ( @@v3@@ , @@v1@@ ) ; @@v4@@ = stdout ; @@v5@@ = gettext ( String String String String String ) ; fputs_unlocked ( @@v5@@ , @@v4@@ ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String String String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; @@v8@@ = stdout ; @@v9@@ = gettext ( String ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = stdout ; @@v11@@ = gettext ( String ) ; fputs_unlocked ( @@v11@@ , @@v10@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
_BOOL8 __fastcall c_islower ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
__int64 default_block_size ( ) { __int64 @@result@@ ; if ( getenv ( String ) ) @@result@@ = Number L ; else @@result@@ = Number L ; return @@result@@ ; }
__int64 __fastcall hash_do_for_each ( __int64 @@a1@@ , unsigned __int8 ( __fastcall * @@a2@@ ) ( _QWORD , __int64 ) , __int64 @@a3@@ ) { __int64 @@v5@@ ; _QWORD * @@i@@ ; _QWORD * @@j@@ ; @@v5@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = @@i@@ ; @@j@@ ; @@j@@ = ( _QWORD * ) @@j@@ [ Number ] ) { if ( @@a2@@ ( * @@j@@ , @@a3@@ ) != Number ) return @@v5@@ ; ++ @@v5@@ ; } } } return @@v5@@ ; }
_BOOL8 __fastcall c_isprint ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , off_A582 , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
__int64 __fastcall humblock ( char * @@a1@@ , _QWORD * @@a2@@ , int * @@a3@@ ) { char * @@v5@@ ; int @@v6@@ ; int @@v7@@ ; unsigned int @@v8@@ ; __int64 @@v9@@ [ Number ] ; @@v5@@ = @@a1@@ ; @@v9@@ [ Number ] = __readfsqword ( Number ) ; @@v6@@ = Number ; if ( @@a1@@ || ( @@v5@@ = getenv ( String ) ) != Number L || ( @@v5@@ = getenv ( String ) ) != Number L ) { if ( * @@v5@@ == Number ) { @@v6@@ = Number ; ++ @@v5@@ ; } @@v7@@ = argmatch ( @@v5@@ , ( __int64 ) & block_size_args , ( __int64 ) block_size_opts , Number ) ; if ( @@v7@@ < Number ) { @@v8@@ = xstrtoumax ( @@v5@@ , @@v9@@ , Number L , @@a2@@ , String ) ; if ( @@v8@@ ) { * @@a3@@ = Number ; return @@v8@@ ; } while ( * @@v5@@ <= Number || * @@v5@@ > Number ) { if ( @@v5@@ == ( char * ) @@v9@@ [ Number ] ) { @@v6@@ |= Number ; if ( * ( _BYTE * ) ( @@v9@@ [ Number ] - Number ) == Number ) @@v6@@ |= Number ; if ( * ( _BYTE * ) ( @@v9@@ [ Number ] - Number ) != Number || * ( _BYTE * ) ( @@v9@@ [ Number ] - Number ) == Number ) @@v6@@ |= Number ; break ; } ++ @@v5@@ ; } } else { @@v6@@ |= block_size_opts [ @@v7@@ ] ; * @@a2@@ = Number L ; } } else { * @@a2@@ = default_block_size ( ) ; } * @@a3@@ = @@v6@@ ; return Number L ; }
_BOOL8 __fastcall c_isupper ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
unsigned __int64 __fastcall compute_bucket_size ( __int64 @@a1@@ , __int64 @@a2@@ ) { float @@v2@@ ; unsigned __int64 @@result@@ ; unsigned __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; float @@v6@@ ; @@v4@@ = @@a1@@ ; if ( * ( _BYTE * ) ( @@a2@@ + Number ) != Number ) { if ( @@a1@@ < Number ) @@v2@@ = ( float ) ( @@a1@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@a1@@ >> Number ) ) + ( float ) ( @@a1@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@a1@@ >> Number ) ) ; else @@v2@@ = ( float ) ( int ) @@a1@@ ; @@v6@@ = @@v2@@ / * ( float * ) ( @@a2@@ + Number ) ; if ( @@v6@@ >= Number ) return Number L ; if ( @@v6@@ >= Number ) @@v4@@ = ( unsigned int ) ( int ) ( float ) ( @@v6@@ - Number ) ^ Number ; else @@v4@@ = ( unsigned int ) ( int ) @@v6@@ ; } @@v5@@ = next_prime ( @@v4@@ ) ; if ( @@v5@@ <= Number ) @@result@@ = @@v5@@ ; else @@result@@ = Number L ; return @@result@@ ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
__int64 __fastcall openat_safer ( int @@a1@@ , const char * @@a2@@ , char @@a3@@ , unsigned int @@a4@@ ) { unsigned int @@v4@@ ; unsigned int @@v6@@ ; @@v6@@ = Number ; if ( ( @@a3@@ & Number ) != Number ) @@v6@@ = @@a4@@ ; @@v4@@ = openat ( @@a1@@ , @@a2@@ , @@a3@@ , @@v6@@ ) ; return fd_safer ( @@v4@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
void * __fastcall allocate_entry ( __int64 @@a1@@ ) { __int64 @@v2@@ ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return malloc ( Number ) ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = * ( _QWORD * ) ( @@v2@@ + Number ) ; return ( void * ) @@v2@@ ; }
__int64 __fastcall c_toupper ( int @@a1@@ ) { __int64 @@result@@ ; if ( @@a1@@ <= Number || @@a1@@ > Number ) @@result@@ = ( unsigned int ) @@a1@@ ; else @@result@@ = ( unsigned int ) ( @@a1@@ - Number ) ; return @@result@@ ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall fd_safer ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { unsigned int @@fd@@ ; unsigned int @@v8@@ ; int @@v9@@ ; @@fd@@ = @@a1@@ ; if ( @@a1@@ >= Number && @@a1@@ <= Number ) { @@v8@@ = dup_safer ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; @@v9@@ = * __errno_location ( ) ; close ( @@a1@@ ) ; * __errno_location ( ) = @@v9@@ ; @@fd@@ = @@v8@@ ; } return @@fd@@ ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_20C028 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_20C0A8 ; @@v4@@ [ Number ] = qword_20C0B0 ; @@v4@@ [ Number ] = qword_20C0B8 ; @@v4@@ [ Number ] = qword_20C0C0 ; @@v4@@ [ Number ] = qword_20C0C8 ; @@v4@@ [ Number ] = qword_20C0D0 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
int __fastcall stat ( char * @@filename@@ , struct stat * @@stat_buf@@ ) { return __xstat ( Number , @@filename@@ , @@stat_buf@@ ) ; }
_BOOL8 __fastcall is_infinite_or_zerol ( long double @@a1@@ ) { return ( unsigned int ) rpl_isnanl ( * ( _TBYTE * ) & @@a1@@ ) || @@a1@@ == @@a1@@ + @@a1@@ ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_21B038 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
__int64 __fastcall hash_find_entry ( __int64 @@a1@@ , __int64 @@a2@@ , _QWORD * @@a3@@ , char @@a4@@ ) { __int64 @@v4@@ ; __int64 @@result@@ ; __int64 @@v6@@ ; _QWORD * @@i@@ ; _QWORD * @@v10@@ ; __int64 @@v11@@ ; _QWORD * @@v12@@ ; __int64 @@v13@@ ; _QWORD * @@v14@@ ; @@v4@@ = * ( _QWORD * ) @@a1@@ ; @@v10@@ = ( _QWORD * ) ( @@v4@@ + Number * ( * ( __int64 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@a2@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@v10@@ >= * ( _QWORD * ) ( @@a1@@ + Number ) ) abort ( ) ; * @@a3@@ = @@v10@@ ; if ( ! * @@v10@@ ) return Number L ; if ( @@a2@@ == * @@v10@@ || ( * ( unsigned __int8 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@a2@@ , * @@v10@@ ) ) { @@v13@@ = * @@v10@@ ; if ( @@a4@@ ) { if ( @@v10@@ [ Number ] ) { @@v14@@ = ( _QWORD * ) @@v10@@ [ Number ] ; @@v6@@ = @@v14@@ [ Number ] ; * @@v10@@ = * @@v14@@ ; @@v10@@ [ Number ] = @@v6@@ ; free_entry ( @@a1@@ , @@v14@@ ) ; } else { * @@v10@@ = Number L ; } } @@result@@ = @@v13@@ ; } else { for ( @@i@@ = @@v10@@ ; ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { if ( ! @@i@@ [ Number ] ) return Number L ; if ( @@a2@@ == * ( _QWORD * ) @@i@@ [ Number ] || ( * ( unsigned __int8 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@a2@@ , * ( _QWORD * ) @@i@@ [ Number ] ) ) { break ; } } @@v11@@ = * ( _QWORD * ) @@i@@ [ Number ] ; if ( @@a4@@ ) { @@v12@@ = ( _QWORD * ) @@i@@ [ Number ] ; @@i@@ [ Number ] = @@v12@@ [ Number ] ; free_entry ( @@a1@@ , @@v12@@ ) ; } @@result@@ = @@v11@@ ; } return @@result@@ ; }
int __fastcall fstat ( int @@fildes@@ , struct stat * @@stat_buf@@ ) { return __fxstat ( Number , @@fildes@@ , @@stat_buf@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
int __lxstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _lxstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
__int64 __fastcall i_ring_pop ( __int64 @@a1@@ ) { unsigned int @@v2@@ ; if ( ( unsigned __int8 ) i_ring_empty ( @@a1@@ ) ) abort ( ) ; @@v2@@ = * ( _DWORD * ) ( @@a1@@ + Number L * * ( unsigned int * ) ( @@a1@@ + Number ) ) ; * ( _DWORD * ) ( @@a1@@ + Number L * * ( unsigned int * ) ( @@a1@@ + Number ) ) = * ( _DWORD * ) ( @@a1@@ + Number ) ; if ( * ( _DWORD * ) ( @@a1@@ + Number ) == * ( _DWORD * ) ( @@a1@@ + Number ) ) * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; else * ( _DWORD * ) ( @@a1@@ + Number ) = ( ( unsigned __int8 ) * ( _DWORD * ) ( @@a1@@ + Number ) + Number ) & Number ; return @@v2@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
int closedir ( DIR * @@dirp@@ ) { return closedir ( @@dirp@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
int putchar_unlocked ( int @@c@@ ) { return putchar_unlocked ( @@c@@ ) ; }
struct passwd * getpwuid ( __uid_t @@uid@@ ) { return getpwuid ( @@uid@@ ) ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
__int64 __fastcall xsum4 ( unsigned __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ ) { __int64 @@v4@@ ; __int64 @@v5@@ ; @@v4@@ = xsum ( @@a1@@ , @@a2@@ ) ; @@v5@@ = xsum ( @@v4@@ , @@a3@@ ) ; return xsum ( @@v5@@ , @@a4@@ ) ; }
int iswalnum ( wint_t @@wc@@ ) { return iswalnum ( @@wc@@ ) ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
int fchdir ( int @@fd@@ ) { return fchdir ( @@fd@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
int fflush_unlocked ( FILE * @@stream@@ ) { return fflush_unlocked ( @@stream@@ ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v4@@ ; @@v4@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v4@@ >= Number / @@a3@@ ) xalloc_die ( ) ; @@v4@@ += ( @@v4@@ + Number ) >> Number ; } else if ( ! @@v4@@ ) { @@v4@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v4@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v4@@ ) ; }
_BOOL8 __fastcall rpl_isnanl ( __int64 a1 , __int64 a2 , __int64 a3 , __int64 a4 , __int64 a5 , __int64 a6 , __int128 @@a7@@ ) { if ( ( WORD4 ( @@a7@@ ) & Number ) == Number ) return DWORD1 ( @@a7@@ ) >> Number ; if ( ( WORD4 ( @@a7@@ ) & Number ) == Number ) return ( DWORD1 ( @@a7@@ ) ^ Number | ( unsigned int ) @@a7@@ ) != Number ; return ( DWORD1 ( @@a7@@ ) & Number ) == Number ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
bool __fastcall is_basic_2 ( unsigned __int8 @@a1@@ ) { return ( ( is_basic_table [ @@a1@@ >> Number ] >> ( @@a1@@ & Number ) ) & Number ) != Number ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
int __cdecl __noreturn main ( int @@argc@@ , const char * * @@argv@@ , const char * * @@envp@@ ) { __int64 @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __uid_t @@uid@@ ; struct passwd * @@v8@@ ; set_program_name ( * @@argv@@ , @@argv@@ , @@envp@@ ) ; setlocale ( Number , & shortopts ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; parse_long_options ( @@argc@@ , ( _DWORD ) @@argv@@ , ( unsigned int ) String , ( unsigned int ) String , ( _DWORD ) Version , ( unsigned int ) usage , String , Number L ) ; if ( getopt_long ( @@argc@@ , ( char * const * ) @@argv@@ , & shortopts , Number L , Number L ) != Number ) usage ( Number ) ; if ( @@argc@@ != optind ) { @@v3@@ = quote ( @@argv@@ [ optind ] ) ; @@v4@@ = gettext ( String ) ; error ( Number , Number , @@v4@@ , @@v3@@ ) ; usage ( Number ) ; } @@uid@@ = geteuid ( ) ; @@v8@@ = getpwuid ( @@uid@@ ) ; if ( @@v8@@ ) { puts ( @@v8@@ -> pw_name ) ; exit ( Number ) ; } @@v5@@ = program_name ; @@v6@@ = gettext ( String ) ; fprintf ( stderr , @@v6@@ , @@v5@@ , @@uid@@ ) ; exit ( Number ) ; }
bool __fastcall is_basic_3 ( unsigned __int8 @@a1@@ ) { return ( ( is_basic_table [ @@a1@@ >> Number ] >> ( @@a1@@ & Number ) ) & Number ) != Number ; }
__int64 __fastcall get_stat_ctime ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
int dirfd ( DIR * @@dirp@@ ) { return dirfd ( @@dirp@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
unsigned __int64 __fastcall entry_hash ( _QWORD * @@a1@@ , unsigned __int64 @@a2@@ ) { return * @@a1@@ % @@a2@@ ; }
char * __fastcall str_iconv ( char * @@a1@@ , char * @@a2@@ , char * @@a3@@ ) { char * @@result@@ ; int @@v5@@ ; int @@v6@@ ; iconv_t @@cd@@ ; void * @@ptr@@ ; char * @@v9@@ ; if ( * @@a1@@ && ( unsigned int ) c_strcasecmp ( ( unsigned __int8 * ) @@a2@@ , ( unsigned __int8 * ) @@a3@@ ) ) { @@cd@@ = iconv_open ( @@a3@@ , @@a2@@ ) ; if ( @@cd@@ == ( iconv_t ) Number ) return Number L ; @@ptr@@ = str_cd_iconv ( @@a1@@ , @@cd@@ ) ; if ( @@ptr@@ ) { if ( iconv_close ( @@cd@@ ) < Number ) { @@v5@@ = * __errno_location ( ) ; free ( @@ptr@@ ) ; * __errno_location ( ) = @@v5@@ ; return Number L ; } } else { @@v6@@ = * __errno_location ( ) ; iconv_close ( @@cd@@ ) ; * __errno_location ( ) = @@v6@@ ; } @@result@@ = ( char * ) @@ptr@@ ; } else { @@v9@@ = strdup ( @@a1@@ ) ; if ( ! @@v9@@ ) * __errno_location ( ) = Number ; @@result@@ = @@v9@@ ; } return @@result@@ ; }
struct dirent * readdir ( DIR * @@dirp@@ ) { return readdir ( @@dirp@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
char * nl_langinfo ( nl_item @@item@@ ) { return nl_langinfo ( @@item@@ ) ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
__int64 __fastcall hash_ins ( __int64 @@a1@@ , __int64 @@a2@@ ) { _QWORD * @@ptr@@ ; __int64 @@v4@@ ; @@ptr@@ = ( _QWORD * ) xmalloc ( Number L ) ; * @@ptr@@ = @@a1@@ ; @@ptr@@ [ Number ] = @@a2@@ ; @@v4@@ = hash_insert ( htab , @@ptr@@ ) ; if ( ! @@v4@@ ) xalloc_die ( ) ; if ( ( _QWORD * ) @@v4@@ == @@ptr@@ ) return Number L ; free ( @@ptr@@ ) ; return Number L ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
bool __fastcall is_zero_or_power_of_two ( __int64 @@a1@@ ) { return ( @@a1@@ & ( @@a1@@ - Number ) ) == Number ; }
int iconv_close ( iconv_t @@cd@@ ) { return iconv_close ( @@cd@@ ) ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
DIR * fdopendir ( int @@fd@@ ) { return fdopendir ( @@fd@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
int __fastcall print_size ( __int64 * @@a1@@ , const char * @@a2@@ ) { __int64 @@v2@@ ; print_only_size ( * @@a1@@ ) ; if ( opt_time ) { putchar_unlocked ( Number ) ; show_date ( time_format , @@a1@@ [ Number ] , @@a1@@ [ Number ] ) ; } if ( opt_nul_terminate_output ) @@v2@@ = Number L ; else @@v2@@ = Number L ; printf ( String , @@a2@@ , @@v2@@ ) ; return fflush_unlocked ( stdout ) ; }
char * strdup ( const char * @@s@@ ) { return strdup ( @@s@@ ) ; }
__int64 __fastcall cycle_check ( __int64 @@a1@@ , _QWORD * @@a2@@ ) { if ( * ( _DWORD * ) ( @@a1@@ + Number ) != Number ) __assert_fail ( String , String , Number , String ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) && @@a2@@ [ Number ] == * ( _QWORD * ) @@a1@@ && * @@a2@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ) { return Number L ; } if ( is_zero_or_power_of_two ( ++ * ( _QWORD * ) ( @@a1@@ + Number ) ) ) { if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = * @@a2@@ ; * ( _QWORD * ) @@a1@@ = @@a2@@ [ Number ] ; } return Number L ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
_QWORD * __fastcall argv_iter_init_stream ( __int64 @@a1@@ ) { _QWORD * @@v2@@ ; @@v2@@ = malloc ( Number ) ; if ( ! @@v2@@ ) return Number L ; * @@v2@@ = @@a1@@ ; @@v2@@ [ Number ] = Number L ; @@v2@@ [ Number ] = Number L ; @@v2@@ [ Number ] = Number L ; @@v2@@ [ Number ] = Number L ; return @@v2@@ ; }
__int64 __fastcall get_stat_mtime ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
_BOOL8 __fastcall c_islower ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
_BOOL8 __fastcall c_isprint ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
_BOOL8 __fastcall entry_compare ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { return * @@a1@@ == * @@a2@@ && @@a1@@ [ Number ] == @@a2@@ [ Number ] ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return xmalloc ( @@a1@@ , @@a2@@ , @@a3@@ ) ; }
_BOOL8 __fastcall c_isxdigit ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number || ( int ) ( @@a1@@ & Number ) > Number && ( int ) ( @@a1@@ & Number ) <= Number ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_21B168 ; @@v8@@ [ Number ] = qword_21B170 ; @@v8@@ [ Number ] = qword_21B178 ; @@v8@@ [ Number ] = qword_21B180 ; @@v8@@ [ Number ] = qword_21B188 ; @@v8@@ [ Number ] = qword_21B190 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
void __fastcall freea ( unsigned __int64 @@a1@@ ) { _QWORD * @@i@@ ; if ( @@a1@@ && * ( _DWORD * ) ( @@a1@@ - Number ) == Number ) { for ( @@i@@ = & mmalloca_results [ @@a1@@ % Number ] ; * @@i@@ ; @@i@@ = ( _QWORD * ) ( * @@i@@ - Number L ) ) { if ( @@a1@@ == * @@i@@ ) { * @@i@@ = * ( _QWORD * ) ( @@a1@@ - Number ) ; free ( ( void * ) ( @@a1@@ - Number ) ) ; return ; } } } }
unsigned __int64 __fastcall show_date ( __int64 @@a1@@ , time_t @@a2@@ , __int64 @@a3@@ ) { __int64 @@v3@@ ; char * @@v4@@ ; time_t @@timer@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; struct tm * @@v9@@ ; char @@s@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v8@@ = @@a1@@ ; @@timer@@ = @@a2@@ ; @@v7@@ = @@a3@@ ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = localtime ( & @@timer@@ ) ; if ( @@v9@@ ) { fprintftime ( stdout , @@v8@@ , @@v9@@ , Number L , ( unsigned int ) @@v7@@ ) ; } else { @@v3@@ = timetostr ( @@timer@@ , ( __int64 ) @@s@@ ) ; @@v4@@ = gettext ( String ) ; error ( Number , Number , @@v4@@ , @@v3@@ ) ; fputs_unlocked ( @@s@@ , stdout ) ; } return __readfsqword ( Number ) ^ @@v11@@ ; }
char * __fastcall proper_name_utf8 ( const char * @@a1@@ , __int64 @@a2@@ ) { char * @@v2@@ ; char * @@result@@ ; size_t @@v4@@ ; size_t @@v5@@ ; char * @@ptr@@ ; char * @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; char * @@s1@@ ; char * @@s@@ ; size_t @@n@@ ; char * @@dest@@ ; char * @@v14@@ ; char * @@v15@@ ; char * @@v16@@ ; @@s1@@ = gettext ( @@a1@@ ) ; @@s@@ = ( char * ) locale_charset ( ) ; @@ptr@@ = Number L ; @@v7@@ = Number L ; @@v9@@ = Number L ; if ( ( unsigned int ) c_strcasecmp ( @@s@@ , String ) ) { @@ptr@@ = ( char * ) xstr_iconv ( @@a2@@ , String , @@s@@ ) ; @@v8@@ = ( __int64 ) @@ptr@@ ; @@n@@ = strlen ( @@s@@ ) ; @@dest@@ = ( char * ) xmalloc ( @@n@@ + Number ) ; memcpy ( @@dest@@ , @@s@@ , @@n@@ ) ; memcpy ( & @@dest@@ [ @@n@@ ] , String , Number ) ; @@v14@@ = ( char * ) xstr_iconv ( @@a2@@ , String , @@dest@@ ) ; free ( @@dest@@ ) ; if ( @@v14@@ ) { if ( strchr ( @@v14@@ , Number ) ) { free ( @@v14@@ ) ; } else { @@v7@@ = @@v14@@ ; @@v9@@ = ( __int64 ) @@v14@@ ; } } } else { @@v8@@ = @@a2@@ ; @@v9@@ = @@a2@@ ; } if ( @@v8@@ ) { @@v2@@ = ( char * ) @@v8@@ ; } else if ( @@v9@@ ) { @@v2@@ = ( char * ) @@v9@@ ; } else { @@v2@@ = ( char * ) @@a1@@ ; } @@v15@@ = @@v2@@ ; if ( ! strcmp ( @@s1@@ , @@a1@@ ) ) { if ( @@ptr@@ && @@ptr@@ != @@v15@@ ) free ( @@ptr@@ ) ; if ( @@v7@@ && @@v7@@ != @@v15@@ ) free ( @@v7@@ ) ; @@result@@ = @@v15@@ ; } else if ( ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@s1@@ , ( __int64 ) @@a1@@ ) || @@v8@@ && ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@s1@@ , @@v8@@ ) || @@v9@@ && ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@s1@@ , @@v9@@ ) ) { if ( @@ptr@@ ) free ( @@ptr@@ ) ; if ( @@v7@@ ) free ( @@v7@@ ) ; @@result@@ = @@s1@@ ; } else { @@v4@@ = strlen ( @@s1@@ ) ; @@v5@@ = strlen ( @@v15@@ ) ; @@v16@@ = ( char * ) xmalloc ( @@v4@@ + @@v5@@ + Number ) ; sprintf ( @@v16@@ , String , @@s1@@ , @@v15@@ ) ; if ( @@ptr@@ ) free ( @@ptr@@ ) ; if ( @@v7@@ ) free ( @@v7@@ ) ; @@result@@ = @@v16@@ ; } return @@result@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( ) ; return @@ptr@@ ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
int __fastcall lstat ( char * @@filename@@ , struct stat * @@stat_buf@@ ) { return __lxstat ( Number , @@filename@@ , @@stat_buf@@ ) ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
_QWORD * __fastcall argv_iter_init_argv ( __int64 @@a1@@ ) { _QWORD * @@v2@@ ; @@v2@@ = malloc ( Number ) ; if ( ! @@v2@@ ) return Number L ; * @@v2@@ = Number L ; @@v2@@ [ Number ] = @@a1@@ ; @@v2@@ [ Number ] = @@a1@@ ; return @@v2@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
void __fastcall free_exclude_segment ( __int64 @@a1@@ ) { int @@v1@@ ; @@v1@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; if ( @@v1@@ ) { if ( @@v1@@ == Number ) free ( * ( void * * ) ( @@a1@@ + Number ) ) ; } else { hash_free ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ; } free ( ( void * ) @@a1@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
int nanosleep ( const struct timespec * @@requested_time@@ , struct timespec * @@remaining@@ ) { return nanosleep ( @@requested_time@@ , @@remaining@@ ) ; }
__int64 __fastcall argv_iter_n_args ( _QWORD * @@a1@@ ) { __int64 @@result@@ ; if ( * @@a1@@ ) @@result@@ = @@a1@@ [ Number ] ; else @@result@@ = ( __int64 ) ( @@a1@@ [ Number ] - @@a1@@ [ Number ] ) >> Number ; return @@result@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__mode_t umask ( __mode_t @@mask@@ ) { return umask ( @@mask@@ ) ; }
_BOOL8 __fastcall excluded_file_pattern_p ( __int64 @@a1@@ , _BYTE * @@a2@@ ) { bool @@v3@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@v5@@ ; __int64 @@v6@@ ; @@v5@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v6@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v3@@ = ( * ( _DWORD * ) ( @@v6@@ + Number ) & Number ) != Number ; for ( @@i@@ = Number L ; @@i@@ < @@v5@@ ; ++ @@i@@ ) { if ( @@v3@@ != exclude_fnmatch ( * ( _QWORD * ) ( Number * @@i@@ + @@v6@@ ) , @@a2@@ , * ( _DWORD * ) ( Number * @@i@@ + @@v6@@ + Number ) ) ) return ! @@v3@@ ; } return @@v3@@ ; }
unsigned __int64 __fastcall xstrtol_error ( unsigned int @@a1@@ , int @@a2@@ , char @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , int @@a6@@ ) { char * @@v6@@ ; char * @@v10@@ ; char * @@msgid@@ ; char * @@v12@@ ; char @@v13@@ [ Number ] ; unsigned __int64 @@v14@@ ; @@v14@@ = __readfsqword ( Number ) ; @@v10@@ = ( char * ) & unk_17688 ; if ( @@a1@@ > Number ) { if ( @@a1@@ != Number ) goto LABEL_6 ; @@msgid@@ = String ; } else if ( @@a1@@ >= Number ) { @@msgid@@ = String ; } else { if ( @@a1@@ != Number ) LABEL_6 : abort ( ) ; @@msgid@@ = String ; } if ( @@a2@@ >= Number ) { @@v12@@ = * ( char * * ) ( Number L * @@a2@@ + @@a4@@ ) ; } else { @@v10@@ = ( char * ) & unk_17688 - @@a2@@ ; @@v13@@ [ Number ] = @@a3@@ ; @@v13@@ [ Number ] = Number ; @@v12@@ = @@v13@@ ; } @@v6@@ = gettext ( @@msgid@@ ) ; error ( @@a6@@ , Number , @@v6@@ , @@v10@@ , @@v12@@ , @@a5@@ ) ; return __readfsqword ( Number ) ^ @@v14@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
void __fastcall add_exclude ( __int64 @@a1@@ , const char * @@a2@@ , int @@a3@@ ) { __int64 @@v3@@ ; __int64 @@v4@@ ; _QWORD * @@v7@@ ; __int64 @@v8@@ ; __int64 * @@v9@@ ; void * @@ptr@@ ; if ( ( @@a3@@ & Number ) != Number && ( unsigned __int8 ) fnmatch_pattern_has_wildcards ( @@a2@@ , @@a3@@ ) ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) && * ( _DWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L ) == Number && ( ( @@a3@@ ^ * ( _DWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L ) ) & Number ) == Number ) { @@v7@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; } else { @@v7@@ = ( _QWORD * ) new_exclude_segment ( @@a1@@ , Number , @@a3@@ ) ; } @@v9@@ = @@v7@@ + Number ; if ( @@v7@@ [ Number ] == @@v7@@ [ Number ] ) * @@v9@@ = x2nrealloc ( @@v7@@ [ Number ] , @@v7@@ + Number , Number L ) ; @@v3@@ = * @@v9@@ ; @@v4@@ = @@v7@@ [ Number ] ; @@v7@@ [ Number ] = @@v4@@ + Number ; @@v4@@ *= Number L ; * ( _QWORD * ) ( @@v3@@ + @@v4@@ ) = @@a2@@ ; * ( _DWORD * ) ( @@v3@@ + @@v4@@ + Number ) = @@a3@@ ; } else { if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) || * ( _DWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L ) || ( ( @@a3@@ ^ * ( _DWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L ) ) & Number ) != Number ) { @@v8@@ = new_exclude_segment ( @@a1@@ , Number , @@a3@@ ) ; } else { @@v8@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; } @@ptr@@ = ( void * ) xstrdup ( @@a2@@ ) ; if ( ( void * ) hash_insert ( * ( _QWORD * ) ( @@v8@@ + Number ) , @@ptr@@ ) != @@ptr@@ ) free ( @@ptr@@ ) ; } }
bool __fastcall is_basic_0 ( unsigned __int8 @@a1@@ ) { return ( ( is_basic_table [ @@a1@@ >> Number ] >> ( @@a1@@ & Number ) ) & Number ) != Number ; }
struct __locale_struct * __fastcall c_strtod ( const char * @@a1@@ , char * * @@a2@@ ) { struct __locale_struct * @@result@@ ; @@result@@ = ( struct __locale_struct * ) c_locale ( ) ; if ( @@result@@ ) return COERCE_STRUCT_LOCALE_STRUCT_ ( strtod_l ( @@a1@@ , @@a2@@ , @@result@@ ) ) ; if ( @@a2@@ ) { @@result@@ = ( struct __locale_struct * ) @@a2@@ ; * @@a2@@ = ( char * ) @@a1@@ ; } return @@result@@ ; }
__int64 __fastcall mem_cd_iconv ( char * @@a1@@ , size_t @@a2@@ , void * @@a3@@ , void * * @@a4@@ , size_t * @@a5@@ ) { int @@v9@@ ; char * @@inbuf@@ ; size_t @@inbytesleft@@ ; char * @@outbuf@@ ; size_t @@outbytesleft@@ ; void * @@ptr@@ ; size_t @@v15@@ ; size_t @@v16@@ ; size_t @@v17@@ ; size_t @@size@@ ; size_t @@v19@@ ; size_t @@v20@@ ; char @@v21@@ $D1F1B2789FC85C59BE59CF61C76BFA1E [ Number ] ; unsigned __int64 @@v22@@ ; @@v22@@ = __readfsqword ( Number ) ; iconv ( @@a3@@ , Number L , Number L , Number L , Number L ) ; @@v15@@ = Number L ; @@inbuf@@ = @@a1@@ ; @@inbytesleft@@ = @@a2@@ ; while ( @@inbytesleft@@ ) { @@outbuf@@ = @@v21@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; @@outbytesleft@@ = Number L ; @@v16@@ = iconv ( @@a3@@ , & @@inbuf@@ , & @@inbytesleft@@ , & @@outbuf@@ , & @@outbytesleft@@ ) ; if ( @@v16@@ == Number && * __errno_location ( ) != Number ) { if ( * __errno_location ( ) != Number ) return Number ; break ; } @@v15@@ += @@outbuf@@ - @@v21@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; } @@outbuf@@ = @@v21@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; @@outbytesleft@@ = Number L ; @@v17@@ = iconv ( @@a3@@ , Number L , Number L , & @@outbuf@@ , & @@outbytesleft@@ ) ; if ( @@v17@@ == Number ) return Number ; @@v15@@ += @@outbuf@@ - @@v21@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; @@size@@ = @@v15@@ ; if ( ! @@v15@@ ) { * @@a5@@ = Number L ; return Number L ; } if ( * @@a4@@ && @@size@@ <= * @@a5@@ ) { @@ptr@@ = * @@a4@@ ; } else { @@ptr@@ = malloc ( @@size@@ ) ; if ( ! @@ptr@@ ) { * __errno_location ( ) = Number ; return Number ; } } iconv ( @@a3@@ , Number L , Number L , Number L , Number L ) ; @@inbuf@@ = @@a1@@ ; @@inbytesleft@@ = @@a2@@ ; @@outbuf@@ = ( char * ) @@ptr@@ ; @@outbytesleft@@ = @@size@@ ; while ( @@inbytesleft@@ ) { @@v19@@ = iconv ( @@a3@@ , & @@inbuf@@ , & @@inbytesleft@@ , & @@outbuf@@ , & @@outbytesleft@@ ) ; if ( @@v19@@ == Number ) { if ( * __errno_location ( ) != Number ) goto LABEL_26 ; break ; } } @@v20@@ = iconv ( @@a3@@ , Number L , Number L , & @@outbuf@@ , & @@outbytesleft@@ ) ; if ( @@v20@@ != Number ) { if ( @@outbytesleft@@ ) abort ( ) ; * @@a4@@ = @@ptr@@ ; * @@a5@@ = @@size@@ ; return Number L ; } LABEL_26 : if ( @@ptr@@ != * @@a4@@ ) { @@v9@@ = * __errno_location ( ) ; free ( @@ptr@@ ) ; * __errno_location ( ) = @@v9@@ ; } return Number ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
__int64 __fastcall fprintftime ( FILE * @@a1@@ , char * @@a2@@ , __int64 @@a3@@ , unsigned int @@a4@@ , unsigned int @@a5@@ ) { return strftime_case_ ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
_BOOL8 __fastcall c_isalnum ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number || ( int ) ( @@a1@@ & Number ) > Number && ( int ) ( @@a1@@ & Number ) <= Number ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
unsigned __int64 __fastcall AD_hash ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) % @@a2@@ ; }
_BOOL8 __fastcall c_iscntrl ( int @@a1@@ ) { return ( @@a1@@ & Number ) == Number || @@a1@@ == Number ; }
bool __fastcall is_basic_1 ( unsigned __int8 @@a1@@ ) { return ( ( is_basic_table [ @@a1@@ >> Number ] >> ( @@a1@@ & Number ) ) & Number ) != Number ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
void __fastcall string_free ( void * @@a1@@ ) { free ( @@a1@@ ) ; }
_BOOL8 __fastcall c_ispunct ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number && ( @@a1@@ <= Number || @@a1@@ > Number ) && ( ( int ) ( @@a1@@ & Number ) <= Number || ( int ) ( @@a1@@ & Number ) > Number ) ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
__int64 __fastcall setup_dir ( __int64 @@a1@@ ) { if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { * ( _QWORD * ) ( @@a1@@ + Number ) = hash_initialize ( Number L , Number L , AD_hash , AD_compare , & free ) ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; } else { * ( _QWORD * ) ( @@a1@@ + Number ) = malloc ( Number ) ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; cycle_check_init ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ; } return Number L ; }
unsigned __int64 __fastcall mmalloca ( unsigned __int64 @@a1@@ ) { char * @@v2@@ ; unsigned __int64 @@v3@@ ; if ( @@a1@@ + Number < @@a1@@ ) return Number L ; @@v2@@ = ( char * ) malloc ( @@a1@@ + Number ) ; if ( ! @@v2@@ ) return Number L ; @@v3@@ = ( unsigned __int64 ) ( @@v2@@ + Number ) ; * ( _DWORD * ) ( @@v3@@ - Number ) = Number ; * ( _QWORD * ) ( @@v3@@ - Number ) = mmalloca_results [ @@v3@@ % Number ] ; mmalloca_results [ @@v3@@ % Number ] = @@v3@@ ; return @@v3@@ ; }
__int64 __fastcall new_exclude_segment ( __int64 @@a1@@ , int @@a2@@ , int @@a3@@ ) { void * @@v3@@ ; void * @@v4@@ ; __int64 @@v7@@ ; @@v7@@ = xzalloc ( Number L ) ; * ( _DWORD * ) ( @@v7@@ + Number ) = @@a2@@ ; * ( _DWORD * ) ( @@v7@@ + Number ) = @@a3@@ ; if ( ! @@a2@@ ) { if ( ( @@a3@@ & Number ) != Number ) @@v3@@ = string_compare_ci ; else @@v3@@ = string_compare ; if ( ( @@a3@@ & Number ) != Number ) @@v4@@ = string_hasher_ci ; else @@v4@@ = string_hasher ; * ( _QWORD * ) ( @@v7@@ + Number ) = hash_initialize ( Number L , Number L , @@v4@@ , @@v3@@ , string_free ) ; } if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) * * ( _QWORD * * ) ( @@a1@@ + Number ) = @@v7@@ ; else * ( _QWORD * ) @@a1@@ = @@v7@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v7@@ ; return @@v7@@ ; }
void __fastcall free_dir ( __int64 @@a1@@ ) { if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) hash_free ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ; } else { free ( * ( void * * ) ( @@a1@@ + Number ) ) ; } }
__int64 __fastcall mode_adjust ( __int16 @@a1@@ , unsigned __int8 @@a2@@ , int @@a3@@ , char * @@a4@@ , _DWORD * @@a5@@ ) { int @@v5@@ ; int @@v6@@ ; int @@v7@@ ; int @@v8@@ ; int @@v9@@ ; int @@v10@@ ; int @@v11@@ ; int @@v12@@ ; int @@v13@@ ; unsigned int @@v17@@ ; int @@v18@@ ; int @@v19@@ ; int @@v20@@ ; int @@v21@@ ; int @@v22@@ ; int @@v23@@ ; @@v17@@ = @@a1@@ & Number ; @@v18@@ = Number ; while ( @@a4@@ [ Number ] ) { @@v22@@ = * ( ( _DWORD * ) @@a4@@ + Number ) ; if ( @@a2@@ ) @@v5@@ = Number ; else @@v5@@ = Number ; @@v23@@ = @@v5@@ & ~ * ( ( _DWORD * ) @@a4@@ + Number ) ; @@v19@@ = * ( ( _DWORD * ) @@a4@@ + Number ) ; @@v6@@ = @@a4@@ [ Number ] ; if ( @@v6@@ == Number ) { if ( @@v17@@ & Number | @@a2@@ ) @@v19@@ |= Number ; } else if ( @@v6@@ == Number ) { @@v20@@ = @@v17@@ & @@v19@@ ; if ( ( @@v20@@ & Number ) != Number ) @@v7@@ = Number ; else @@v7@@ = Number ; if ( ( @@v20@@ & Number ) != Number ) @@v8@@ = Number ; else @@v8@@ = Number ; @@v9@@ = @@v8@@ | @@v7@@ ; if ( ( @@v20@@ & Number ) != Number ) @@v10@@ = Number ; else @@v10@@ = Number ; @@v19@@ = @@v9@@ | @@v10@@ | @@v20@@ ; } if ( @@v22@@ ) @@v11@@ = * ( ( _DWORD * ) @@a4@@ + Number ) ; else @@v11@@ = ~ @@a3@@ ; @@v21@@ = ~ @@v23@@ & @@v11@@ & @@v19@@ ; @@v12@@ = * @@a4@@ ; switch ( @@v12@@ ) { case String : @@v18@@ |= @@v21@@ ; @@v17@@ &= ~ @@v21@@ ; break ; case String : if ( @@v22@@ ) @@v13@@ = ~ @@v22@@ ; else @@v13@@ = Number ; @@v18@@ |= ~ ( ( unsigned __int16 ) @@v23@@ | ( unsigned __int16 ) @@v13@@ ) & Number ; @@v17@@ = @@v21@@ | ( @@v23@@ | @@v13@@ ) & @@v17@@ ; break ; case String : @@v18@@ |= @@v21@@ ; @@v17@@ |= @@v21@@ ; break ; } @@a4@@ += Number ; } if ( @@a5@@ ) * @@a5@@ = @@v18@@ ; return @@v17@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
int __fastcall fstat ( int @@fildes@@ , struct stat * @@stat_buf@@ ) { return __fxstat ( Number , @@fildes@@ , @@stat_buf@@ ) ; }
__int64 __fastcall fd_ring_clear ( __int64 @@a1@@ ) { __int64 @@result@@ ; int @@fd@@ ; while ( Number ) { @@result@@ = ( unsigned int ) i_ring_empty ( @@a1@@ ) ^ Number ; if ( ! ( _BYTE ) @@result@@ ) break ; @@fd@@ = i_ring_pop ( @@a1@@ ) ; if ( @@fd@@ >= Number ) close ( @@fd@@ ) ; } return @@result@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall excluded_file_name ( __int64 * @@a1@@ , char * @@a2@@ ) { int @@v3@@ ; size_t @@v4@@ ; unsigned __int8 @@v5@@ ; unsigned __int8 @@v6@@ ; __int64 @@i@@ ; char * @@ptr@@ ; @@ptr@@ = Number L ; if ( ! * @@a1@@ ) return Number L ; @@v5@@ = ( * ( _DWORD * ) ( * @@a1@@ + Number ) & Number ) != Number ; for ( @@i@@ = * @@a1@@ ; @@i@@ ; @@i@@ = * ( _QWORD * ) @@i@@ ) { @@v3@@ = * ( _DWORD * ) ( @@i@@ + Number ) ; if ( @@v3@@ ) { if ( @@v3@@ != Number ) abort ( ) ; @@v6@@ = excluded_file_pattern_p ( @@i@@ , @@a2@@ ) ; } else { if ( ! @@ptr@@ ) { @@v4@@ = strlen ( @@a2@@ ) ; @@ptr@@ = ( char * ) xmalloc ( @@v4@@ + Number ) ; } @@v6@@ = excluded_file_name_p ( @@i@@ , @@a2@@ , @@ptr@@ ) ; } if ( @@v6@@ != @@v5@@ ) { @@v5@@ = @@v6@@ ; break ; } } free ( @@ptr@@ ) ; return @@v5@@ ; }
__locale_t newlocale ( int @@category_mask@@ , const char * @@locale@@ , __locale_t @@base@@ ) { return newlocale ( @@category_mask@@ , @@locale@@ , @@base@@ ) ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_2080C8 ; @@v8@@ [ Number ] = qword_2080D0 ; @@v8@@ [ Number ] = qword_2080D8 ; @@v8@@ [ Number ] = qword_2080E0 ; @@v8@@ [ Number ] = qword_2080E8 ; @@v8@@ [ Number ] = qword_2080F0 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
__int64 __fastcall fts_set_stat_required ( __int64 @@a1@@ , char @@a2@@ ) { __int64 @@v2@@ ; __int64 @@result@@ ; if ( * ( _WORD * ) ( @@a1@@ + Number ) != Number ) abort ( ) ; if ( @@a2@@ ) @@v2@@ = Number L ; else @@v2@@ = Number L ; @@result@@ = @@a1@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v2@@ ; return @@result@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_2070C8 ; @@v4@@ [ Number ] = qword_2070D0 ; @@v4@@ [ Number ] = qword_2070D8 ; @@v4@@ [ Number ] = qword_2070E0 ; @@v4@@ [ Number ] = qword_2070E8 ; @@v4@@ [ Number ] = qword_2070F0 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
__int64 __fastcall iso_week_days ( int @@a1@@ , int @@a2@@ ) { return ( unsigned int ) ( @@a1@@ - ( @@a1@@ - @@a2@@ + Number ) % Number + Number ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
__int64 __fastcall diropen ( __int64 @@a1@@ , int @@a2@@ , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { int @@v6@@ ; int @@v8@@ ; unsigned int @@v9@@ ; @@v8@@ = ( * ( _DWORD * ) ( @@a1@@ + Number ) << Number ) & Number | Number ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) @@v6@@ = openat_safer ( * ( _DWORD * ) ( @@a1@@ + Number ) , @@a2@@ , @@v8@@ , @@a2@@ , @@a5@@ , @@a6@@ , @@a2@@ ) ; else @@v6@@ = open_safer ( @@a2@@ , @@v8@@ , @@v8@@ , @@a4@@ , @@a5@@ , @@a6@@ , @@a2@@ ) ; @@v9@@ = @@v6@@ ; if ( @@v6@@ >= Number ) set_cloexec_flag ( ( unsigned int ) @@v6@@ , Number L ) ; return @@v9@@ ; }
FILE * __fastcall freopen_safer ( const char * @@a1@@ , const char * @@a2@@ , FILE * @@a3@@ ) { int @@v3@@ ; FILE * @@streama@@ ; char @@v7@@ ; char @@v8@@ ; char @@v9@@ ; int @@v10@@ ; @@v7@@ = Number ; @@v8@@ = Number ; @@v9@@ = Number ; @@v3@@ = fileno ( @@a3@@ ) ; if ( @@v3@@ != Number ) { if ( @@v3@@ != Number ) { if ( ! @@v3@@ ) goto LABEL_10 ; if ( dup2 ( Number , Number ) != Number ) @@v9@@ = Number ; } if ( dup2 ( Number , Number ) != Number ) @@v8@@ = Number ; } if ( dup2 ( Number , Number ) ) @@v7@@ = Number ; LABEL_10 : if ( @@v7@@ && ( unsigned __int8 ) protect_fd ( Number ) != Number ) { @@streama@@ = Number L ; } else if ( @@v8@@ && ( unsigned __int8 ) protect_fd ( Number ) != Number ) { @@streama@@ = Number L ; } else if ( @@v9@@ && ( unsigned __int8 ) protect_fd ( Number ) != Number ) { @@streama@@ = Number L ; } else { @@streama@@ = freopen ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } @@v10@@ = * __errno_location ( ) ; if ( @@v9@@ ) close ( Number ) ; if ( @@v8@@ ) close ( Number ) ; if ( @@v7@@ ) close ( Number ) ; if ( ! @@streama@@ ) * __errno_location ( ) = @@v10@@ ; return @@streama@@ ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
unsigned __int64 __fastcall LCO_hash ( _QWORD * @@a1@@ , unsigned __int64 @@a2@@ ) { return * @@a1@@ % @@a2@@ ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
__int64 __fastcall opendirat ( int @@a1@@ , int @@a2@@ , __int64 a3 , __int64 a4 , int @@a5@@ , int @@a6@@ ) { int @@fd@@ ; _BYTE @@v8@@ [ Number ] ; @@fd@@ = openat_safer ( @@a1@@ , @@a2@@ , Number , @@a2@@ , @@a5@@ , @@a6@@ , @@a2@@ ) ; if ( @@fd@@ < Number ) return Number L ; set_cloexec_flag ( ( unsigned int ) @@fd@@ , Number L ) ; * ( _QWORD * ) & @@v8@@ [ Number ] = fdopendir ( @@fd@@ ) ; if ( ! * ( _QWORD * ) & @@v8@@ [ Number ] ) { * ( _QWORD * ) @@v8@@ = ( unsigned int ) * __errno_location ( ) ; close ( @@fd@@ ) ; * __errno_location ( ) = * ( _DWORD * ) @@v8@@ ; } return * ( _QWORD * ) & @@v8@@ [ Number ] ; }
__int64 __fastcall xstrtod ( _BYTE * @@a1@@ , _QWORD * @@a2@@ , double * @@a3@@ , double ( __fastcall * @@a4@@ ( ) ( constchar , char ) ) ( _BYTE * , _BYTE * * ) ) { unsigned __int8 @@v7@@ ; _BYTE * @@v8@@ ; double @@v9@@ ; unsigned __int64 @@v10@@ ; @@v10@@ = __readfsqword ( Number ) ; @@v7@@ = Number ; * __errno_location ( ) = Number ; @@v9@@ = @@a4@@ ( ) ( constchar , char ) ( @@a1@@ , & @@v8@@ ) ; if ( @@a1@@ == @@v8@@ || ! @@a2@@ && * @@v8@@ ) { @@v7@@ = Number ; } else if ( @@v9@@ != Number && * __errno_location ( ) == Number ) { @@v7@@ = Number ; } if ( @@a2@@ ) * @@a2@@ = @@v8@@ ; * @@a3@@ = @@v9@@ ; return @@v7@@ ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
__int64 __fastcall fts_set ( __int64 a1 , __int64 @@a2@@ , int @@a3@@ ) { __int64 @@result@@ ; if ( ! @@a3@@ || @@a3@@ == Number || @@a3@@ == Number || @@a3@@ == Number || @@a3@@ == Number ) { * ( _WORD * ) ( @@a2@@ + Number ) = @@a3@@ ; @@result@@ = Number L ; } else { * __errno_location ( ) = Number ; @@result@@ = Number L ; } return @@result@@ ; }
_BOOL8 __fastcall leaf_optimization_applies ( int @@a1@@ ) { _BOOL8 @@result@@ ; struct statfs @@buf@@ ; unsigned __int64 @@v3@@ ; @@v3@@ = __readfsqword ( Number ) ; if ( fstatfs ( @@a1@@ , & @@buf@@ ) ) @@result@@ = Number L ; else @@result@@ = @@buf@@ . f_type == Number ; return @@result@@ ; }
time_t time ( time_t * @@timer@@ ) { return time ( @@timer@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
time_t mktime ( struct tm * @@tp@@ ) { return mktime ( @@tp@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
int remove ( const char * @@filename@@ ) { return remove ( @@filename@@ ) ; }
__int64 __fastcall set_stat_type ( __int64 @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; int @@v3@@ ; switch ( @@a2@@ ) { case Number : @@v3@@ = Number ; break ; case Number : @@v3@@ = Number ; break ; case Number : @@v3@@ = Number ; break ; case Number : @@v3@@ = Number ; break ; case Number : @@v3@@ = Number ; break ; case Number : @@v3@@ = Number ; break ; case Number : @@v3@@ = Number ; break ; default : @@v3@@ = Number ; break ; } @@result@@ = @@a1@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@v3@@ ; return @@result@@ ; }
__int64 __fastcall fts_compare_ino ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; if ( * ( _QWORD * ) ( * ( _QWORD * ) @@a1@@ + Number L ) < * ( _QWORD * ) ( * ( _QWORD * ) @@a2@@ + Number L ) ) @@result@@ = Number ; else @@result@@ = * ( _QWORD * ) ( * ( _QWORD * ) @@a2@@ + Number L ) < * ( _QWORD * ) ( * ( _QWORD * ) @@a1@@ + Number L ) ; return @@result@@ ; }
__int64 __fastcall get_stat_atime ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
__int64 __fastcall fts_palloc ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; unsigned __int64 @@v3@@ ; void * @@v4@@ ; @@v3@@ = * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ + Number ; if ( @@v3@@ >= * ( _QWORD * ) ( @@a1@@ + Number ) ) { * ( _QWORD * ) ( @@a1@@ + Number ) = @@v3@@ ; @@v4@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , * ( _QWORD * ) ( @@a1@@ + Number ) ) ; if ( @@v4@@ ) { * ( _QWORD * ) ( @@a1@@ + Number ) = @@v4@@ ; @@result@@ = Number L ; } else { free ( * ( void * * ) ( @@a1@@ + Number ) ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; @@result@@ = Number L ; } } else { free ( * ( void * * ) ( @@a1@@ + Number ) ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * __errno_location ( ) = Number ; @@result@@ = Number L ; } return @@result@@ ; }
void __fastcall get_reldate ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v3@@ ; char * @@v4@@ ; if ( ( unsigned __int8 ) get_date ( @@a1@@ , @@a2@@ , @@a3@@ ) != Number ) { @@v3@@ = quote ( @@a2@@ ) ; @@v4@@ = gettext ( String ) ; error ( Number , Number , @@v4@@ , @@v3@@ ) ; } }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
__int64 __fastcall fts_stat ( __int64 @@a1@@ , __int64 @@a2@@ , char @@a3@@ ) { __int64 @@result@@ ; __int64 @@v4@@ ; int @@v6@@ ; struct stat * @@s@@ ; @@s@@ = ( struct stat * ) ( @@a2@@ + Number ) ; if ( ! * ( _QWORD * ) ( @@a2@@ + Number ) && ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) @@a3@@ = Number ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number || @@a3@@ ) { if ( ( unsigned int ) stat ( * ( char * * ) ( @@a2@@ + Number ) , @@s@@ ) ) { @@v6@@ = * __errno_location ( ) ; if ( * __errno_location ( ) == Number && ! ( unsigned int ) lstat ( * ( char * * ) ( @@a2@@ + Number ) , @@s@@ ) ) { * __errno_location ( ) = Number ; return Number L ; } * ( _DWORD * ) ( @@a2@@ + Number ) = @@v6@@ ; goto LABEL_13 ; } } else if ( ( unsigned int ) fstatat ( * ( _DWORD * ) ( @@a1@@ + Number ) , * ( char * * ) ( @@a2@@ + Number ) , @@s@@ , Number ) ) { * ( _DWORD * ) ( @@a2@@ + Number ) = * __errno_location ( ) ; LABEL_13 : memset ( @@s@@ , Number , sizeof ( struct stat ) ) ; return Number L ; } switch ( * ( _DWORD * ) ( @@a2@@ + Number ) & Number ) { case Number : if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) @@v4@@ = Number L ; else @@v4@@ = Number L ; * ( _QWORD * ) ( @@a2@@ + Number ) = * ( _QWORD * ) ( @@a2@@ + Number ) - @@v4@@ ; if ( * ( _BYTE * ) ( @@a2@@ + Number ) != Number || * ( _BYTE * ) ( @@a2@@ + Number ) && ( * ( _BYTE * ) ( @@a2@@ + Number ) != Number || * ( _BYTE * ) ( @@a2@@ + Number ) ) ) { @@result@@ = Number L ; } else if ( * ( _QWORD * ) ( @@a2@@ + Number ) ) { @@result@@ = Number L ; } else { @@result@@ = Number L ; } break ; case Number : @@result@@ = Number L ; break ; case Number : @@result@@ = Number L ; break ; default : @@result@@ = Number L ; break ; } return @@result@@ ; }
size_t __fastcall fts_maxarglen ( const char * * @@a1@@ ) { size_t @@v3@@ ; size_t @@v4@@ ; @@v3@@ = Number L ; while ( * @@a1@@ ) { @@v4@@ = strlen ( * @@a1@@ ) ; if ( @@v4@@ > @@v3@@ ) @@v3@@ = @@v4@@ ; ++ @@a1@@ ; } return @@v3@@ + Number ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
_QWORD * __fastcall set_hhmmss ( _QWORD * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ ) { _QWORD * @@result@@ ; @@a1@@ [ Number ] = @@a2@@ ; @@a1@@ [ Number ] = @@a3@@ ; @@a1@@ [ Number ] = @@a4@@ ; @@result@@ = @@a1@@ ; @@a1@@ [ Number ] = @@a5@@ ; return @@result@@ ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_207028 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
__int64 __fastcall hash_get_n_buckets ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 __fastcall hash_get_n_entries ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
__int64 __fastcall mkdtemp_len ( __int64 @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , char @@a4@@ ) { __int64 @@v4@@ ; if ( @@a4@@ ) @@v4@@ = Number L ; else @@v4@@ = Number L ; return gen_tempname_len ( @@a1@@ , @@a2@@ , Number L , @@v4@@ , @@a3@@ ) ; }
__int64 __fastcall time_zone_hhmm ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 a3 , __int64 a4 , __int64 a5 , __int64 a6 , char @@a7@@ , __int64 @@a8@@ , unsigned __int64 @@a9@@ ) { __int64 @@v9@@ ; __int64 @@v11@@ ; if ( @@a9@@ <= Number && @@a2@@ < Number ) @@a8@@ *= Number L ; if ( @@a2@@ >= Number ) { if ( @@a7@@ ) @@v9@@ = - @@a2@@ ; else @@v9@@ = @@a2@@ ; @@v11@@ = Number * @@a8@@ + @@v9@@ ; } else { @@v11@@ = Number * ( @@a8@@ / Number ) + @@a8@@ % Number ; } if ( ( int ) abs32 ( @@v11@@ ) > Number ) ++ * ( _QWORD * ) ( @@a1@@ + Number ) ; return @@v11@@ ; }
int __fastcall hash_print_statistics ( __int64 @@a1@@ , FILE * @@a2@@ ) { double @@v2@@ ; double @@v3@@ ; double @@v4@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v6@@ = hash_get_n_entries ( @@a1@@ ) ; @@v7@@ = hash_get_n_buckets ( @@a1@@ ) ; @@v8@@ = hash_get_n_buckets_used ( @@a1@@ ) ; @@v9@@ = hash_get_max_bucket_length ( @@a1@@ ) ; fprintf ( @@a2@@ , String , @@v6@@ ) ; fprintf ( @@a2@@ , String , @@v7@@ ) ; if ( @@v8@@ < Number ) @@v2@@ = ( double ) ( int ) ( @@v8@@ & Number | ( ( unsigned __int64 ) @@v8@@ >> Number ) ) + ( double ) ( int ) ( @@v8@@ & Number | ( ( unsigned __int64 ) @@v8@@ >> Number ) ) ; else @@v2@@ = ( double ) ( int ) @@v8@@ ; @@v3@@ = Number * @@v2@@ ; if ( @@v7@@ < Number ) @@v4@@ = ( double ) ( int ) ( @@v7@@ & Number | ( ( unsigned __int64 ) @@v7@@ >> Number ) ) + ( double ) ( int ) ( @@v7@@ & Number | ( ( unsigned __int64 ) @@v7@@ >> Number ) ) ; else @@v4@@ = ( double ) ( int ) @@v7@@ ; fprintf ( @@a2@@ , String , @@v8@@ , @@v3@@ / @@v4@@ ) ; return fprintf ( @@a2@@ , String , @@v9@@ ) ; }
unsigned __int64 __fastcall hash_get_max_bucket_length ( __int64 @@a1@@ ) { _QWORD * @@i@@ ; unsigned __int64 @@v3@@ ; _QWORD * @@v4@@ ; unsigned __int64 @@j@@ ; @@v3@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { @@v4@@ = @@i@@ ; for ( @@j@@ = Number L ; ; ++ @@j@@ ) { @@v4@@ = ( _QWORD * ) @@v4@@ [ Number ] ; if ( ! @@v4@@ ) break ; } if ( @@j@@ > @@v3@@ ) @@v3@@ = @@j@@ ; } } return @@v3@@ ; }
unsigned __int64 __fastcall hash_string ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ ) { unsigned __int64 @@v4@@ ; @@v4@@ = Number L ; while ( * @@a1@@ ) @@v4@@ = ( Number * @@v4@@ + ( unsigned __int8 ) * @@a1@@ ++ ) % @@a2@@ ; return @@v4@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
const char * * __fastcall lookup_zone ( __int64 @@a1@@ , const char * @@a2@@ ) { const char * * @@i@@ ; const char * * @@j@@ ; const char * * @@k@@ ; for ( @@i@@ = ( const char * * ) & universal_time_zone_table ; * @@i@@ ; @@i@@ += Number ) { if ( ! strcmp ( @@a2@@ , * @@i@@ ) ) return @@i@@ ; } for ( @@j@@ = ( const char * * ) ( @@a1@@ + Number ) ; * @@j@@ ; @@j@@ += Number ) { if ( ! strcmp ( @@a2@@ , * @@j@@ ) ) return @@j@@ ; } for ( @@k@@ = ( const char * * ) & time_zone_table ; * @@k@@ ; @@k@@ += Number ) { if ( ! strcmp ( @@a2@@ , * @@k@@ ) ) return @@k@@ ; } return Number L ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__int64 __fastcall hash_get_first ( unsigned __int64 * @@a1@@ ) { unsigned __int64 @@i@@ ; if ( ! @@a1@@ [ Number ] ) return Number L ; for ( @@i@@ = * @@a1@@ ; ; @@i@@ += Number L ) { if ( @@i@@ >= @@a1@@ [ Number ] ) abort ( ) ; if ( * ( _QWORD * ) @@i@@ ) break ; } return * ( _QWORD * ) @@i@@ ; }
_BYTE * __fastcall longest_relative_suffix ( _BYTE * @@a1@@ ) { while ( * @@a1@@ == Number ) ++ @@a1@@ ; return @@a1@@ ; }
__int64 __fastcall next_prime ( unsigned __int64 @@a1@@ ) { __int64 @@v2@@ ; __int64 @@i@@ ; @@v2@@ = @@a1@@ ; if ( @@a1@@ <= Number ) @@v2@@ = Number L ; for ( @@i@@ = @@v2@@ | Number ; @@i@@ != Number && ! is_prime ( @@i@@ ) ; @@i@@ += Number L ) { ; } return @@i@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return xmalloc ( @@a1@@ , @@a2@@ , @@a3@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
void * __fastcall mfile_name_concat ( _BYTE * @@a1@@ , _BYTE * @@a2@@ , _QWORD * @@a3@@ ) { _BOOL4 @@v3@@ ; const char * @@v6@@ ; size_t @@v7@@ ; size_t @@n@@ ; _BOOL8 @@v9@@ ; char * @@s@@ ; size_t @@v11@@ ; void * @@dest@@ ; _BYTE * @@v13@@ ; char * @@v14@@ ; @@v6@@ = last_component ( @@a1@@ ) ; @@v7@@ = base_len ( @@v6@@ ) ; @@n@@ = @@v6@@ - @@a1@@ + @@v7@@ ; @@v3@@ = @@v7@@ && @@v6@@ [ @@v7@@ - Number ] != Number ; @@v9@@ = @@v3@@ ; @@s@@ = longest_relative_suffix ( @@a2@@ ) ; @@v11@@ = strlen ( @@s@@ ) ; @@dest@@ = malloc ( @@v9@@ + @@n@@ + @@v11@@ + Number ) ; if ( ! @@dest@@ ) return Number L ; @@v13@@ = mempcpy ( @@dest@@ , @@a1@@ , @@n@@ ) ; * @@v13@@ = Number ; @@v14@@ = & @@v13@@ [ @@v9@@ ] ; if ( @@a3@@ ) * @@a3@@ = & @@v14@@ [ - ( * @@a2@@ == Number ) ] ; * ( _BYTE * ) mempcpy ( @@v14@@ , @@s@@ , @@v11@@ ) = Number ; return @@dest@@ ; }
unsigned __int64 __fastcall hash_get_entries ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; _QWORD * @@i@@ ; _QWORD * @@j@@ ; @@v5@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = @@i@@ ; @@j@@ ; @@j@@ = ( _QWORD * ) @@j@@ [ Number ] ) { if ( @@v5@@ >= @@a3@@ ) return @@v5@@ ; @@v4@@ = @@v5@@ ++ ; * ( _QWORD * ) ( @@a2@@ + Number * @@v4@@ ) = * @@j@@ ; } } } return @@v5@@ ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
void __fastcall argmatch_invalid ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { char * @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; char * @@format@@ ; if ( @@a3@@ == Number ) @@v3@@ = gettext ( String ) ; else @@v3@@ = gettext ( String ) ; @@format@@ = @@v3@@ ; @@v4@@ = quote_n ( Number L , @@a1@@ ) ; @@v5@@ = quotearg_n_style ( Number L , Number L , @@a2@@ ) ; error ( Number , Number , @@format@@ , @@v5@@ , @@v4@@ ) ; }
size_t * __fastcall hash_initialize ( __int64 @@a1@@ , void * @@a2@@ , unsigned __int64 ( __fastcall * @@a3@@ ) ( __int64 a1 , unsigned __int64 a2 ) , bool ( __fastcall * @@a4@@ ) ( __int64 a1 , __int64 a2 ) , size_t @@a5@@ ) { size_t * @@result@@ ; bool ( __fastcall * @@v7@@ ) ( __int64 , __int64 ) ; unsigned __int64 ( __fastcall * @@v8@@ ) ( __int64 , unsigned __int64 ) ; void * @@v9@@ ; size_t * @@ptr@@ ; @@v9@@ = @@a2@@ ; @@v8@@ = @@a3@@ ; @@v7@@ = @@a4@@ ; if ( ! @@a3@@ ) @@v8@@ = raw_hasher ; if ( ! @@a4@@ ) @@v7@@ = raw_comparator ; @@ptr@@ = ( size_t * ) malloc ( Number ) ; if ( ! @@ptr@@ ) return Number L ; if ( ! @@a2@@ ) @@v9@@ = & default_tuning ; @@ptr@@ [ Number ] = ( size_t ) @@v9@@ ; if ( ( unsigned __int8 ) check_tuning ( ( __int64 ) @@ptr@@ ) == Number && ( @@ptr@@ [ Number ] = compute_bucket_size ( @@a1@@ , ( __int64 ) @@v9@@ ) ) != Number && ( * @@ptr@@ = ( size_t ) calloc ( @@ptr@@ [ Number ] , Number ) ) != Number ) { @@ptr@@ [ Number ] = Number * @@ptr@@ [ Number ] + * @@ptr@@ ; @@ptr@@ [ Number ] = Number L ; @@ptr@@ [ Number ] = Number L ; @@ptr@@ [ Number ] = ( size_t ) @@v8@@ ; @@ptr@@ [ Number ] = ( size_t ) @@v7@@ ; @@ptr@@ [ Number ] = @@a5@@ ; @@ptr@@ [ Number ] = Number L ; @@result@@ = @@ptr@@ ; } else { free ( @@ptr@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
unsigned __int64 __fastcall raw_hasher ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return rotr_sz ( @@a1@@ , Number ) % @@a2@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 __fastcall _xargmatch_internal ( __int64 @@a1@@ , const char * @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ , void ( * @@a6@@ ) ( void ) ) { __int64 @@v11@@ ; @@v11@@ = argmatch ( @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; if ( @@v11@@ >= Number ) return @@v11@@ ; argmatch_invalid ( @@a1@@ , ( __int64 ) @@a2@@ , @@v11@@ ) ; argmatch_valid ( @@a3@@ , @@a4@@ , @@a5@@ ) ; @@a6@@ ( ) ; return Number ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
__int64 __fastcall check_tuning ( __int64 @@a1@@ ) { __int64 @@v2@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( ( _UNKNOWN * ) @@v2@@ == & default_tuning ) return Number L ; if ( * ( float * ) ( @@v2@@ + Number ) > Number && ( float ) ( Number - Number ) > * ( float * ) ( @@v2@@ + Number ) && * ( float * ) ( @@v2@@ + Number ) > ( float ) ( Number + Number ) && * ( float * ) @@v2@@ >= Number && * ( float * ) ( @@v2@@ + Number ) > ( float ) ( * ( float * ) @@v2@@ + Number ) && * ( float * ) ( @@v2@@ + Number ) <= Number && * ( float * ) ( @@v2@@ + Number ) > ( float ) ( * ( float * ) @@v2@@ + Number ) ) { return Number L ; } * ( _QWORD * ) ( @@a1@@ + Number ) = & default_tuning ; return Number L ; }
__int64 __fastcall hash_rehash ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; unsigned __int64 @@nmemb@@ ; void * @@v4@@ ; __int64 @@v5@@ ; unsigned __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; __int64 @@v12@@ ; __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; @@v14@@ = __readfsqword ( Number ) ; @@nmemb@@ = compute_bucket_size ( @@a2@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ; if ( ! @@nmemb@@ ) return Number L ; if ( @@nmemb@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; @@v4@@ = calloc ( @@nmemb@@ , Number ) ; if ( ! @@v4@@ ) return Number L ; @@v6@@ = @@nmemb@@ ; @@v5@@ = ( __int64 ) @@v4@@ + Number * @@nmemb@@ ; @@v7@@ = Number L ; @@v8@@ = Number L ; @@v9@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v10@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v11@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v12@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v13@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( ( unsigned __int8 ) transfer_entries ( ( __int64 ) & @@v4@@ , @@a1@@ , Number ) ) { free ( * ( void * * ) @@a1@@ ) ; * ( _QWORD * ) @@a1@@ = @@v4@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v5@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v6@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v7@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v13@@ ; @@result@@ = Number L ; } else { * ( _QWORD * ) ( @@a1@@ + Number ) = @@v13@@ ; if ( ( unsigned __int8 ) transfer_entries ( @@a1@@ , ( __int64 ) & @@v4@@ , Number ) != Number || ( unsigned __int8 ) transfer_entries ( @@a1@@ , ( __int64 ) & @@v4@@ , Number ) != Number ) { abort ( ) ; } free ( @@v4@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall transfer_entries ( __int64 @@a1@@ , __int64 @@a2@@ , char @@a3@@ ) { __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 * @@i@@ ; _QWORD * @@j@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; _QWORD * @@v11@@ ; _QWORD * @@v12@@ ; _QWORD * @@v13@@ ; _QWORD * @@v14@@ ; for ( @@i@@ = * ( __int64 * * ) @@a2@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a2@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = ( _QWORD * ) @@i@@ [ Number ] ; @@j@@ ; @@j@@ = @@v14@@ ) { @@v9@@ = * @@j@@ ; @@v3@@ = * ( _QWORD * ) @@a1@@ ; @@v11@@ = ( _QWORD * ) ( @@v3@@ + Number * ( * ( __int64 ( __fastcall * * ) ( _QWORD , _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@j@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@v11@@ >= * ( _QWORD * ) ( @@a1@@ + Number ) ) abort ( ) ; @@v14@@ = ( _QWORD * ) @@j@@ [ Number ] ; if ( * @@v11@@ ) { @@j@@ [ Number ] = @@v11@@ [ Number ] ; @@v11@@ [ Number ] = @@j@@ ; } else { * @@v11@@ = @@v9@@ ; ++ * ( _QWORD * ) ( @@a1@@ + Number ) ; free_entry ( @@a1@@ , @@j@@ ) ; } } @@v10@@ = * @@i@@ ; @@i@@ [ Number ] = Number L ; if ( ! @@a3@@ ) { @@v4@@ = * ( _QWORD * ) @@a1@@ ; @@v12@@ = ( _QWORD * ) ( @@v4@@ + Number * ( * ( __int64 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@v10@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@v12@@ >= * ( _QWORD * ) ( @@a1@@ + Number ) ) abort ( ) ; if ( * @@v12@@ ) { @@v13@@ = allocate_entry ( @@a1@@ ) ; if ( ! @@v13@@ ) return Number L ; * @@v13@@ = @@v10@@ ; @@v13@@ [ Number ] = @@v12@@ [ Number ] ; @@v12@@ [ Number ] = @@v13@@ ; } else { * @@v12@@ = @@v10@@ ; ++ * ( _QWORD * ) ( @@a1@@ + Number ) ; } * @@i@@ = Number L ; -- * ( _QWORD * ) ( @@a2@@ + Number ) ; } } } return Number L ; }
__int64 __fastcall xnanosleep ( double @@a1@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; @@v4@@ = __readfsqword ( Number ) ; if ( @@a1@@ < Number ) __assert_fail ( String , String , Number , String ) ; if ( @@a1@@ <= Number ) { @@v2@@ = ( unsigned int ) ( int ) @@a1@@ ; @@v3@@ = ( unsigned int ) ( int ) ( ( @@a1@@ - ( double ) ( int ) @@a1@@ ) * Number ) + ( unsigned __int64 ) ( ( @@a1@@ - ( double ) ( int ) @@a1@@ ) * Number > ( double ) ( int ) ( ( @@a1@@ - ( double ) ( int ) @@a1@@ ) * Number ) ) ; if ( @@v3@@ > Number ) { ++ @@v2@@ ; @@v3@@ -= Number L ; } } while ( Number ) { if ( @@a1@@ > Number ) { @@v2@@ = Number ; @@v3@@ = Number L ; } * __errno_location ( ) = Number ; if ( ! ( unsigned int ) rpl_nanosleep ( & @@v2@@ , Number L ) ) break ; if ( * __errno_location ( ) != Number && * __errno_location ( ) ) return Number ; } return Number L ; }
__int64 __fastcall i_ring_empty ( __int64 @@a1@@ ) { return * ( unsigned __int8 * ) ( @@a1@@ + Number ) ; }
__int64 __fastcall year ( __int64 @@a1@@ , _DWORD * @@a2@@ , __int64 @@a3@@ , char @@a4@@ ) { time_t @@timer@@ ; struct tm * @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; if ( @@a3@@ == Number ) { * ( _DWORD * ) ( @@a1@@ + Number ) = * @@a2@@ ; if ( ( int ) * @@a2@@ <= Number ) { if ( ( @@a4@@ & Number ) != Number ) return Number L ; * ( _DWORD * ) ( @@a1@@ + Number ) += Number ; } } else if ( @@a3@@ ) { if ( @@a3@@ != Number ) abort ( ) ; if ( ( @@a4@@ & Number ) == Number ) return Number L ; * ( _DWORD * ) ( @@a1@@ + Number ) = Number * * @@a2@@ + @@a2@@ [ Number ] - Number ; } else { time ( & @@timer@@ ) ; @@v6@@ = localtime ( & @@timer@@ ) ; if ( ! @@v6@@ ) return Number L ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@v6@@ -> tm_year ; } return Number L ; }
__int64 __fastcall open_safer ( const char * @@a1@@ , char @@a2@@ , unsigned int @@a3@@ ) { unsigned int @@v3@@ ; unsigned int @@v5@@ ; @@v5@@ = Number ; if ( ( @@a2@@ & Number ) != Number ) @@v5@@ = @@a3@@ ; @@v3@@ = open ( @@a1@@ , @@a2@@ , @@v5@@ ) ; return fd_safer ( @@v3@@ ) ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_20A038 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
int fileno ( FILE * @@stream@@ ) { return fileno ( @@stream@@ ) ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
__int64 __fastcall i_ring_push ( __int64 @@a1@@ , int @@a2@@ ) { int @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = ( ( unsigned __int8 ) * ( _DWORD * ) ( @@a1@@ + Number ) + ( * ( _BYTE * ) ( @@a1@@ + Number ) ^ Number ) ) & Number ; @@v4@@ = * ( _DWORD * ) ( @@a1@@ + Number L * ( ( ( unsigned __int8 ) * ( _DWORD * ) ( @@a1@@ + Number ) + ( * ( _BYTE * ) ( @@a1@@ + Number ) ^ Number ) ) & Number ) ) ; * ( _DWORD * ) ( @@a1@@ + Number L * ( ( ( unsigned __int8 ) * ( _DWORD * ) ( @@a1@@ + Number ) + ( * ( _BYTE * ) ( @@a1@@ + Number ) ^ Number ) ) & Number ) ) = @@a2@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@v3@@ ; if ( @@v3@@ == * ( _DWORD * ) ( @@a1@@ + Number ) ) * ( _DWORD * ) ( @@a1@@ + Number ) = ( ( unsigned __int8 ) * ( _DWORD * ) ( @@a1@@ + Number ) + ( * ( _BYTE * ) ( @@a1@@ + Number ) ^ Number ) ) & Number ; * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; return @@v4@@ ; }
DIR * __fastcall opendir_safer ( const char * @@a1@@ ) { int @@v2@@ ; int @@fd@@ ; int @@v4@@ ; DIR * @@dirp@@ ; DIR * @@v6@@ ; @@dirp@@ = opendir ( @@a1@@ ) ; if ( @@dirp@@ ) { @@v2@@ = dirfd ( @@dirp@@ ) ; if ( @@v2@@ >= Number && @@v2@@ <= Number ) { @@fd@@ = dup_safer ( ( unsigned int ) @@v2@@ ) ; @@v6@@ = fdopendir ( @@fd@@ ) ; @@v4@@ = * __errno_location ( ) ; if ( ! @@v6@@ ) close ( @@fd@@ ) ; closedir ( @@dirp@@ ) ; * __errno_location ( ) = @@v4@@ ; @@dirp@@ = @@v6@@ ; } } return @@dirp@@ ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
size_t __fastcall randread ( _QWORD * @@a1@@ , char * @@a2@@ , size_t @@a3@@ ) { size_t @@result@@ ; if ( * @@a1@@ ) @@result@@ = readsource ( ( __int64 ) @@a1@@ , @@a2@@ , @@a3@@ ) ; else @@result@@ = ( size_t ) readisaac ( @@a1@@ + Number , @@a2@@ , @@a3@@ ) ; return @@result@@ ; }
__int64 __fastcall count_consecutive_X_s ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v4@@ ; @@v4@@ = Number L ; while ( @@a2@@ && * ( _BYTE * ) ( @@a2@@ - Number + @@a1@@ ) == Number ) { ++ @@v4@@ ; -- @@a2@@ ; } return @@v4@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
_DWORD * __fastcall isaac_seed_data ( _DWORD * @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { _DWORD * @@result@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@j@@ ; unsigned __int64 @@k@@ ; char * @@v9@@ ; char * @@v10@@ ; for ( @@i@@ = Number L - ( unsigned int ) @@a1@@ [ Number ] ; @@a3@@ > @@i@@ ; @@i@@ = Number L ) { @@v9@@ = ( char * ) @@a1@@ + ( unsigned int ) @@a1@@ [ Number ] ; for ( @@j@@ = Number L ; @@j@@ < @@i@@ ; ++ @@j@@ ) @@v9@@ [ @@j@@ ] ^= * ( _BYTE * ) ( @@a2@@ + @@j@@ ) ; @@a2@@ += @@i@@ ; @@a3@@ -= @@i@@ ; isaac_mix ( @@a1@@ , ( __int64 ) @@a1@@ ) ; @@a1@@ [ Number ] = Number ; } @@v10@@ = ( char * ) @@a1@@ + ( unsigned int ) @@a1@@ [ Number ] ; for ( @@k@@ = Number L ; @@k@@ < @@a3@@ ; ++ @@k@@ ) @@v10@@ [ @@k@@ ] ^= * ( _BYTE * ) ( @@a2@@ + @@k@@ ) ; @@result@@ = @@a1@@ ; @@a1@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_21B038 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 __fastcall file_name_concat ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v4@@ ; @@v4@@ = mfile_name_concat ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( ! @@v4@@ ) xalloc_die ( ) ; return @@v4@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_210128 ; @@v4@@ [ Number ] = qword_210130 ; @@v4@@ [ Number ] = qword_210138 ; @@v4@@ [ Number ] = qword_210140 ; @@v4@@ [ Number ] = qword_210148 ; @@v4@@ [ Number ] = qword_210150 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
_BOOL8 __fastcall cycle_warning_required ( __int64 @@a1@@ , __int64 @@a2@@ ) { return ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number && ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) == Number || ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number && ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number && * ( _QWORD * ) ( @@a2@@ + Number ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
int __lxstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _lxstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
int __fastcall gl_futimens ( int @@a1@@ , char * @@a2@@ , __int64 * @@a3@@ ) { return fdutimens ( @@a2@@ , @@a1@@ , @@a3@@ ) ; }
int closedir ( DIR * @@dirp@@ ) { return closedir ( @@dirp@@ ) ; }
__int64 __fastcall protect_fd ( int @@a1@@ ) { int @@fd@@ ; @@fd@@ = open ( String , Number ) ; if ( @@fd@@ == @@a1@@ ) return Number L ; if ( @@fd@@ >= Number ) { close ( @@fd@@ ) ; * __errno_location ( ) = Number ; } return Number L ; }
int __fastcall utimens ( char * @@a1@@ , __int64 * @@a2@@ ) { return fdutimens ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_21B168 ; @@v4@@ [ Number ] = qword_21B170 ; @@v4@@ [ Number ] = qword_21B178 ; @@v4@@ [ Number ] = qword_21B180 ; @@v4@@ [ Number ] = qword_21B188 ; @@v4@@ [ Number ] = qword_21B190 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
const char * locale_charset ( ) { const char * @@s1@@ ; char * @@s2@@ ; char * @@s2a@@ ; @@s1@@ = nl_langinfo ( Number ) ; if ( ! @@s1@@ ) @@s1@@ = ( const char * ) & unk_1785F ; for ( @@s2@@ = ( char * ) get_charset_aliases ( ) ; * @@s2@@ ; @@s2@@ = & @@s2a@@ [ strlen ( @@s2a@@ ) + Number ] ) { if ( ! strcmp ( @@s1@@ , @@s2@@ ) || * @@s2@@ == Number && ! @@s2@@ [ Number ] ) { @@s1@@ = & @@s2@@ [ strlen ( @@s2@@ ) + Number ] ; break ; } @@s2a@@ = & @@s2@@ [ strlen ( @@s2@@ ) + Number ] ; } if ( ! * @@s1@@ ) @@s1@@ = String ; return @@s1@@ ; }
__mode_t umask ( __mode_t @@mask@@ ) { return umask ( @@mask@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall xnrealloc ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { if ( ! is_mul_ok ( @@a3@@ , @@a2@@ ) ) xalloc_die ( ) ; return xrealloc ( @@a1@@ , @@a3@@ * @@a2@@ ) ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
__int64 __fastcall bkm_scale_0 ( unsigned __int64 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( is_mul_ok ( @@a2@@ , * @@a1@@ ) ) { * @@a1@@ *= @@a2@@ ; @@result@@ = Number L ; } else { * @@a1@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
_BOOL8 __fastcall c_isblank ( int @@a1@@ ) { return @@a1@@ == Number || @@a1@@ == Number ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ ) { return xmalloc ( @@a1@@ ) ; }
_BOOL8 __fastcall c_isdigit ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
__int64 __fastcall set_cloexec_flag ( int @@a1@@ , char @@a2@@ , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { int @@v6@@ ; int @@v7@@ ; int @@v8@@ ; unsigned int @@v9@@ ; __int64 @@result@@ ; int @@v11@@ ; @@v11@@ = rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( @@v11@@ < Number || ( ! @@a2@@ ? ( @@v9@@ = @@v11@@ & Number ) : ( @@v9@@ = @@v11@@ | Number ) , @@v11@@ != @@v9@@ && ( unsigned int ) rpl_fcntl ( @@a1@@ , Number , @@v9@@ , @@v6@@ , @@v7@@ , @@v8@@ ) == Number ) ) { @@result@@ = Number ; } else { @@result@@ = Number L ; } return @@result@@ ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
_BOOL8 __fastcall c_isprint ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@v2@@ ; @@v2@@ = malloc ( @@a1@@ ) ; if ( ! @@v2@@ && @@a1@@ ) xalloc_die ( ) ; return @@v2@@ ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
__int64 __fastcall dup_safer ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
_BOOL8 __fastcall c_isxdigit ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number || ( int ) ( @@a1@@ & Number ) > Number && ( int ) ( @@a1@@ & Number ) <= Number ; }
void * __fastcall xzalloc ( size_t @@a1@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@a1@@ ) ; return memset ( @@v1@@ , Number , @@a1@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
__int64 __fastcall fd_safer ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { unsigned int @@fd@@ ; unsigned int @@v8@@ ; int @@v9@@ ; @@fd@@ = @@a1@@ ; if ( @@a1@@ >= Number && @@a1@@ <= Number ) { @@v8@@ = dup_safer ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; @@v9@@ = * __errno_location ( ) ; close ( @@a1@@ ) ; * __errno_location ( ) = @@v9@@ ; @@fd@@ = @@v8@@ ; } return @@fd@@ ; }
__int64 __fastcall ftypelet ( __int16 @@a1@@ ) { switch ( @@a1@@ & Number ) { case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; } return Number L ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
_BOOL8 __fastcall c_isgraph ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
_BYTE * __fastcall filemodestring ( __int64 @@a1@@ , _BYTE * @@a2@@ ) { return strmode ( * ( _DWORD * ) ( @@a1@@ + Number ) , @@a2@@ ) ; }
__int64 __fastcall bkm_scale_by_power ( unsigned __int64 * @@a1@@ , int @@a2@@ , int @@a3@@ ) { unsigned int @@i@@ ; for ( @@i@@ = Number ; @@a3@@ -- ; @@i@@ |= bkm_scale ( @@a1@@ , @@a2@@ ) ) { ; } return @@i@@ ; }
int closedir ( DIR * @@dirp@@ ) { return closedir ( @@dirp@@ ) ; }
unsigned __int64 __fastcall AD_hash ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) % @@a2@@ ; }
_BOOL8 __fastcall c_isspace ( int @@a1@@ ) { return @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number ; }
DIR * fdopendir ( int @@fd@@ ) { return fdopendir ( @@fd@@ ) ; }
__int64 __fastcall gen_tempname_len ( char * @@a1@@ , int @@a2@@ , int @@a3@@ , int @@a4@@ , size_t @@a5@@ ) { int @@v6@@ ; unsigned int @@i@@ ; int @@v11@@ ; int @@v12@@ ; int @@v13@@ ; size_t @@j@@ ; size_t @@v15@@ ; __int64 @@v16@@ ; struct stat @@stat_buf@@ ; unsigned __int64 @@v18@@ ; @@v18@@ = __readfsqword ( Number ) ; @@v12@@ = * __errno_location ( ) ; @@v15@@ = strlen ( @@a1@@ ) ; if ( @@v15@@ < @@a2@@ + @@a5@@ || ! check_x_suffix ( & @@a1@@ [ @@v15@@ - @@a5@@ - @@a2@@ ] , @@a5@@ ) ) { * __errno_location ( ) = Number ; return Number ; } @@v16@@ = randint_all_new ( Number L , Number L ) ; if ( ! @@v16@@ ) return Number ; for ( @@i@@ = Number ; ; ++ @@i@@ ) { if ( @@i@@ >= Number ) { randint_all_free ( @@v16@@ ) ; * __errno_location ( ) = Number ; return Number ; } for ( @@j@@ = Number L ; @@j@@ < @@a5@@ ; ++ @@j@@ ) @@a1@@ [ @@v15@@ - @@a5@@ - @@a2@@ + @@j@@ ] = letters [ randint_genmax ( @@v16@@ , Number L ) ] ; if ( @@a4@@ == Number ) { @@v11@@ = mkdir ( @@a1@@ , Number ) ; goto LABEL_20 ; } if ( @@a4@@ == Number ) break ; if ( @@a4@@ ) __assert_fail ( String , String , Number , String ) ; @@v6@@ = @@a3@@ ; LOBYTE ( @@v6@@ ) = @@a3@@ & Number | Number ; @@v11@@ = open ( @@a1@@ , @@v6@@ , Number L ) ; LABEL_20 : if ( @@v11@@ >= Number ) { * __errno_location ( ) = @@v12@@ ; goto LABEL_27 ; } if ( * __errno_location ( ) != Number ) { @@v11@@ = Number ; goto LABEL_27 ; } LABEL_24 : ; } if ( ( int ) lstat ( @@a1@@ , & @@stat_buf@@ ) >= Number ) goto LABEL_24 ; if ( * __errno_location ( ) == Number ) { * __errno_location ( ) = @@v12@@ ; @@v11@@ = Number ; } else { @@v11@@ = Number ; } LABEL_27 : @@v13@@ = * __errno_location ( ) ; randint_all_free ( @@v16@@ ) ; * __errno_location ( ) = @@v13@@ ; return ( unsigned int ) @@v11@@ ; }
__int64 __fastcall c_strcasecmp ( unsigned __int8 * @@a1@@ , unsigned __int8 * @@a2@@ ) { unsigned __int8 * @@v2@@ ; unsigned __int8 * @@v3@@ ; unsigned __int8 @@v5@@ ; unsigned __int8 @@v6@@ ; @@v2@@ = @@a1@@ ; @@v3@@ = @@a2@@ ; if ( @@a1@@ == @@a2@@ ) return Number L ; do { @@v5@@ = c_tolower ( * @@v2@@ ) ; @@v6@@ = c_tolower ( * @@v3@@ ) ; if ( ! @@v5@@ ) break ; ++ @@v2@@ ; ++ @@v3@@ ; } while ( @@v5@@ == @@v6@@ ) ; return @@v5@@ - ( unsigned int ) @@v6@@ ; }
__int64 __fastcall c_toupper ( int @@a1@@ ) { __int64 @@result@@ ; if ( @@a1@@ <= Number || @@a1@@ > Number ) @@result@@ = ( unsigned int ) @@a1@@ ; else @@result@@ = ( unsigned int ) ( @@a1@@ - Number ) ; return @@result@@ ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 __fastcall enter_dir ( __int64 @@a1@@ , __int64 @@a2@@ ) { _QWORD * @@ptr@@ ; __int64 @@v4@@ ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { @@ptr@@ = malloc ( Number ) ; if ( ! @@ptr@@ ) return Number L ; * @@ptr@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@ptr@@ [ Number ] = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@ptr@@ [ Number ] = @@a2@@ ; @@v4@@ = hash_insert ( * ( _QWORD * ) ( @@a1@@ + Number ) , @@ptr@@ ) ; if ( ( _QWORD * ) @@v4@@ != @@ptr@@ ) { free ( @@ptr@@ ) ; if ( ! @@v4@@ ) return Number L ; * ( _QWORD * ) @@a2@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; * ( _WORD * ) ( @@a2@@ + Number ) = Number ; } } else if ( ( unsigned __int8 ) cycle_check ( * ( _QWORD * ) ( @@a1@@ + Number ) , @@a2@@ + Number ) ) { * ( _QWORD * ) @@a2@@ = @@a2@@ ; * ( _WORD * ) ( @@a2@@ + Number ) = Number ; } return Number L ; }
_BOOL8 __fastcall errno_rmdir_non_empty ( int @@a1@@ ) { return @@a1@@ == Number || @@a1@@ == Number ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
__int64 __fastcall diropen ( __int64 @@a1@@ , int @@a2@@ , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { int @@v6@@ ; int @@v8@@ ; unsigned int @@v9@@ ; @@v8@@ = ( * ( _DWORD * ) ( @@a1@@ + Number ) << Number ) & Number | Number ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) @@v6@@ = openat_safer ( * ( _DWORD * ) ( @@a1@@ + Number ) , @@a2@@ , @@v8@@ , @@a2@@ , @@a5@@ , @@a6@@ , @@a2@@ ) ; else @@v6@@ = open_safer ( @@a2@@ , @@v8@@ , @@v8@@ , @@a4@@ , @@a5@@ , @@a6@@ , @@a2@@ ) ; @@v9@@ = @@v6@@ ; if ( @@v6@@ >= Number ) set_cloexec_flag ( ( unsigned int ) @@v6@@ , Number L ) ; return @@v9@@ ; }
size_t * __fastcall readisaac ( size_t * @@a1@@ , char * @@a2@@ , size_t @@a3@@ ) { size_t * @@result@@ ; size_t @@i@@ ; char * @@v7@@ ; for ( @@i@@ = * @@a1@@ ; @@a3@@ > @@i@@ ; @@i@@ = Number L ) { memcpy ( @@a2@@ , ( char * ) @@a1@@ + Number - @@i@@ + Number , @@i@@ ) ; @@a2@@ += @@i@@ ; @@a3@@ -= @@i@@ ; if ( ( ( unsigned __int8 ) @@a2@@ & Number ) == Number ) { @@v7@@ = @@a2@@ ; while ( @@a3@@ > Number ) { isaac_refill ( @@a1@@ + Number , @@v7@@ ) ; @@v7@@ += Number ; @@a3@@ -= Number L ; if ( ! @@a3@@ ) { @@result@@ = @@a1@@ ; * @@a1@@ = Number L ; return @@result@@ ; } } @@a2@@ = @@v7@@ ; } isaac_refill ( @@a1@@ + Number , ( char * ) @@a1@@ + Number ) ; } memcpy ( @@a2@@ , ( char * ) @@a1@@ + Number - @@i@@ + Number , @@a3@@ ) ; @@result@@ = @@a1@@ ; * @@a1@@ = @@i@@ - @@a3@@ ; return @@result@@ ; }
__int64 __fastcall knuth_morris_pratt_unibyte ( _BYTE * @@a1@@ , char * @@a2@@ , _QWORD * @@a3@@ ) { void * @@v3@@ ; unsigned __int64 @@v4@@ ; _QWORD * @@v6@@ ; char * @@s@@ ; _BYTE * @@v8@@ ; char @@v9@@ ; unsigned __int64 @@i@@ ; __int64 @@v11@@ ; __int64 @@v12@@ ; _BYTE * @@v13@@ ; _BYTE * @@v14@@ ; size_t @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v8@@ = @@a1@@ ; @@s@@ = @@a2@@ ; @@v6@@ = @@a3@@ ; @@v17@@ = __readfsqword ( Number ) ; @@v15@@ = strlen ( @@a2@@ ) ; if ( @@v15@@ > Number ) { @@v4@@ = Number L ; } else if ( Number * @@v15@@ > Number ) { @@v4@@ = mmalloca ( Number * @@v15@@ ) ; } else { @@v3@@ = alloca ( Number * ( ( Number * ( @@v15@@ + Number ) + Number ) / Number ) ) ; @@v4@@ = Number * ( ( ( unsigned __int64 ) & @@v6@@ + Number ) >> Number ) + Number ; } @@v16@@ = @@v4@@ ; if ( ! @@v4@@ ) return Number L ; * ( _QWORD * ) ( @@v16@@ + Number ) = Number L ; @@v11@@ = Number L ; for ( @@i@@ = Number L ; @@i@@ < @@v15@@ ; ++ @@i@@ ) { @@v9@@ = @@s@@ [ @@i@@ - Number ] ; while ( Number ) { if ( @@v9@@ == @@s@@ [ @@v11@@ ] ) { ++ @@v11@@ ; * ( _QWORD * ) ( @@v16@@ + Number * @@i@@ ) = @@i@@ - @@v11@@ ; goto LABEL_15 ; } if ( ! @@v11@@ ) break ; @@v11@@ -= * ( _QWORD * ) ( Number * @@v11@@ + @@v16@@ ) ; } * ( _QWORD * ) ( @@v16@@ + Number * @@i@@ ) = @@i@@ ; LABEL_15 : ; } * @@v6@@ = Number L ; @@v12@@ = Number L ; @@v13@@ = @@v8@@ ; @@v14@@ = @@v8@@ ; while ( * @@v14@@ ) { if ( @@s@@ [ @@v12@@ ] == * @@v14@@ ) { ++ @@v12@@ ; ++ @@v14@@ ; if ( @@v12@@ == @@v15@@ ) { * @@v6@@ = @@v13@@ ; break ; } } else if ( @@v12@@ ) { @@v13@@ += * ( _QWORD * ) ( Number * @@v12@@ + @@v16@@ ) ; @@v12@@ -= * ( _QWORD * ) ( Number * @@v12@@ + @@v16@@ ) ; } else { ++ @@v13@@ ; ++ @@v14@@ ; } } freea ( @@v16@@ ) ; return Number L ; }
int __fastcall fstatat ( int @@fildes@@ , char * @@filename@@ , struct stat * @@stat_buf@@ , int @@flag@@ ) { return __fxstatat ( Number , @@fildes@@ , @@filename@@ , @@stat_buf@@ , @@flag@@ ) ; }
_BOOL8 __fastcall remove_parents ( const char * @@a1@@ ) { int @@v1@@ ; unsigned int @@v2@@ ; int @@v3@@ ; int @@v4@@ ; int @@v5@@ ; int * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; int * @@v9@@ ; char @@v11@@ ; bool @@v12@@ ; char * @@v13@@ ; @@v12@@ = Number ; strip_trailing_slashes ( @@a1@@ ) ; while ( Number ) { @@v13@@ = strrchr ( @@a1@@ , Number ) ; if ( ! @@v13@@ ) break ; while ( @@v13@@ > @@a1@@ && * @@v13@@ == Number ) -- @@v13@@ ; @@v13@@ [ Number ] = Number ; if ( verbose ) { @@v1@@ = quote ( @@a1@@ ) ; @@v2@@ = ( unsigned int ) gettext ( String ) ; prog_fprintf ( ( _DWORD ) stdout , @@v2@@ , @@v1@@ , @@v2@@ , @@v3@@ , @@v4@@ , @@v11@@ ) ; } @@v5@@ = rmdir ( @@a1@@ ) ; @@v12@@ = @@v5@@ == Number ; if ( @@v5@@ ) { @@v6@@ = __errno_location ( ) ; if ( ignorable_failure ( * @@v6@@ , @@a1@@ ) ) return Number ; @@v7@@ = quote ( @@a1@@ ) ; @@v8@@ = gettext ( String ) ; @@v9@@ = __errno_location ( ) ; error ( Number , * @@v9@@ , @@v8@@ , @@v7@@ ) ; return @@v12@@ ; } } return @@v12@@ ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
_BOOL8 __fastcall leaf_optimization_applies ( int @@a1@@ ) { _BOOL8 @@result@@ ; struct statfs @@buf@@ ; unsigned __int64 @@v3@@ ; @@v3@@ = __readfsqword ( Number ) ; if ( fstatfs ( @@a1@@ , & @@buf@@ ) ) @@result@@ = Number L ; else @@result@@ = @@buf@@ . f_type == Number ; return @@result@@ ; }
__int64 __fastcall rpl_fcntl ( int @@a1@@ , int @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , __m128 @@a7@@ , __m128 @@a8@@ , __m128 @@a9@@ , __m128 @@a10@@ , __m128 @@a11@@ , __m128 @@a12@@ , __m128 @@a13@@ , __m128 @@a14@@ ) { int @@v14@@ ; int @@v15@@ ; int @@v16@@ ; int @@v18@@ ; int @@v19@@ ; int @@v20@@ ; int @@v21@@ ; __int64 @@v22@@ ; __int64 @@v23@@ ; __int64 @@v24@@ ; __int64 @@v25@@ ; __m128 @@v26@@ ; __m128 @@v27@@ ; __m128 @@v28@@ ; __m128 @@v29@@ ; __m128 @@v30@@ ; __m128 @@v31@@ ; __m128 @@v32@@ ; __m128 @@v33@@ ; @@v22@@ = @@a3@@ ; @@v23@@ = @@a4@@ ; @@v24@@ = @@a5@@ ; @@v25@@ = @@a6@@ ; @@v26@@ = @@a7@@ ; @@v27@@ = @@a8@@ ; @@v28@@ = @@a9@@ ; @@v29@@ = @@a10@@ ; @@v30@@ = @@a11@@ ; @@v31@@ = @@a12@@ ; @@v32@@ = @@a13@@ ; @@v33@@ = @@a14@@ ; if ( @@a2@@ != Number ) return ( unsigned int ) fcntl ( @@a1@@ , @@a2@@ , @@v22@@ ) ; @@v19@@ = @@v22@@ ; if ( have_dupfd_cloexec_2895 < Number ) { @@v18@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v22@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; } else { @@v18@@ = fcntl ( @@a1@@ , Number , ( unsigned int ) @@v22@@ ) ; if ( @@v18@@ < Number && * __errno_location ( ) == Number ) { @@v18@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v19@@ , @@v14@@ , @@v15@@ , @@v16@@ ) ; if ( @@v18@@ < Number ) return ( unsigned int ) @@v18@@ ; have_dupfd_cloexec_2895 = Number ; } else { have_dupfd_cloexec_2895 = Number ; } } if ( @@v18@@ >= Number && have_dupfd_cloexec_2895 == Number ) { @@v20@@ = fcntl ( @@v18@@ , Number ) ; if ( @@v20@@ < Number || fcntl ( @@v18@@ , Number , @@v20@@ | Number ) == Number ) { @@v21@@ = * __errno_location ( ) ; close ( @@v18@@ ) ; * __errno_location ( ) = @@v21@@ ; @@v18@@ = Number ; } } return ( unsigned int ) @@v18@@ ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
__int64 __fastcall rpl_fcntl ( int @@a1@@ , int @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , __m128 @@a7@@ , __m128 @@a8@@ , __m128 @@a9@@ , __m128 @@a10@@ , __m128 @@a11@@ , __m128 @@a12@@ , __m128 @@a13@@ , __m128 @@a14@@ ) { int @@v14@@ ; int @@v15@@ ; int @@v16@@ ; int @@v18@@ ; int @@v19@@ ; int @@v20@@ ; int @@v21@@ ; __int64 @@v22@@ ; __int64 @@v23@@ ; __int64 @@v24@@ ; __int64 @@v25@@ ; __m128 @@v26@@ ; __m128 @@v27@@ ; __m128 @@v28@@ ; __m128 @@v29@@ ; __m128 @@v30@@ ; __m128 @@v31@@ ; __m128 @@v32@@ ; __m128 @@v33@@ ; @@v22@@ = @@a3@@ ; @@v23@@ = @@a4@@ ; @@v24@@ = @@a5@@ ; @@v25@@ = @@a6@@ ; @@v26@@ = @@a7@@ ; @@v27@@ = @@a8@@ ; @@v28@@ = @@a9@@ ; @@v29@@ = @@a10@@ ; @@v30@@ = @@a11@@ ; @@v31@@ = @@a12@@ ; @@v32@@ = @@a13@@ ; @@v33@@ = @@a14@@ ; if ( @@a2@@ != Number ) return ( unsigned int ) fcntl ( @@a1@@ , @@a2@@ , @@v22@@ ) ; @@v19@@ = @@v22@@ ; if ( have_dupfd_cloexec_2895 < Number ) { @@v18@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v22@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; } else { @@v18@@ = fcntl ( @@a1@@ , Number , ( unsigned int ) @@v22@@ ) ; if ( @@v18@@ < Number && * __errno_location ( ) == Number ) { @@v18@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v19@@ , @@v14@@ , @@v15@@ , @@v16@@ ) ; if ( @@v18@@ < Number ) return ( unsigned int ) @@v18@@ ; have_dupfd_cloexec_2895 = Number ; } else { have_dupfd_cloexec_2895 = Number ; } } if ( @@v18@@ >= Number && have_dupfd_cloexec_2895 == Number ) { @@v20@@ = fcntl ( @@v18@@ , Number ) ; if ( @@v20@@ < Number || fcntl ( @@v18@@ , Number , @@v20@@ | Number ) == Number ) { @@v21@@ = * __errno_location ( ) ; close ( @@v18@@ ) ; * __errno_location ( ) = @@v21@@ ; @@v18@@ = Number ; } } return ( unsigned int ) @@v18@@ ; }
__int64 __fastcall fts_children ( __int64 @@a1@@ , int @@a2@@ ) { __int64 @@v3@@ ; __int64 @@v4@@ ; int @@v5@@ ; int @@v6@@ ; int @@v7@@ ; int @@v8@@ ; unsigned int @@v9@@ ; int @@fd@@ ; int @@v11@@ ; if ( @@a2@@ && @@a2@@ != Number ) { * __errno_location ( ) = Number ; return Number L ; } @@v3@@ = * ( _QWORD * ) @@a1@@ ; * __errno_location ( ) = Number ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) return Number L ; if ( * ( _WORD * ) ( @@v3@@ + Number ) == Number ) return * ( _QWORD * ) ( @@v3@@ + Number ) ; if ( * ( _WORD * ) ( @@v3@@ + Number ) != Number ) return Number L ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) fts_lfree ( * ( void * * ) ( @@a1@@ + Number ) ) ; if ( @@a2@@ == Number ) { @@v8@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; BYTE1 ( @@v8@@ ) |= Number ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@v8@@ ; @@v9@@ = Number ; } else { @@v9@@ = Number ; } if ( * ( _QWORD * ) ( @@v3@@ + Number ) || * * ( _BYTE * * ) ( @@v3@@ + Number ) == Number || ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { * ( _QWORD * ) ( @@a1@@ + Number ) = fts_build ( @@a1@@ , @@v9@@ ) ; return * ( _QWORD * ) ( @@a1@@ + Number ) ; } @@fd@@ = diropen ( @@a1@@ , ( int ) & unk_B849 , @@v4@@ , @@v5@@ , @@v6@@ , @@v7@@ ) ; if ( @@fd@@ < Number ) { * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; return Number L ; } * ( _QWORD * ) ( @@a1@@ + Number ) = fts_build ( @@a1@@ , @@v9@@ ) ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { cwd_advance_fd ( @@a1@@ , @@fd@@ , Number ) ; } else { if ( fchdir ( @@fd@@ ) ) { @@v11@@ = * __errno_location ( ) ; close ( @@fd@@ ) ; * __errno_location ( ) = @@v11@@ ; return Number L ; } close ( @@fd@@ ) ; } return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
size_t __fastcall mbslen ( const char * @@a1@@ ) { __int64 @@v3@@ ; char @@v4@@ [ Number ] ; int @@v5@@ ; char @@i@@ ; const char * @@v7@@ ; __int64 @@v8@@ ; char @@v9@@ ; int @@v10@@ ; unsigned __int64 @@v11@@ ; @@v11@@ = __readfsqword ( Number ) ; if ( __ctype_get_mb_cur_max ( ) <= Number ) return strlen ( @@a1@@ ) ; @@v3@@ = Number L ; @@v7@@ = @@a1@@ ; @@v4@@ [ Number ] = Number ; memset ( & @@v5@@ , Number , Number ) ; for ( @@i@@ = Number ; ; @@i@@ = Number ) { mbuiter_multi_next_3 ( ( __int64 ) @@v4@@ ) ; if ( @@v9@@ == Number && ! @@v10@@ ) break ; ++ @@v3@@ ; @@v7@@ += @@v8@@ ; } return @@v3@@ ; }
size_t __fastcall fts_maxarglen ( const char * * @@a1@@ ) { size_t @@v3@@ ; size_t @@v4@@ ; @@v3@@ = Number L ; while ( * @@a1@@ ) { @@v4@@ = strlen ( * @@a1@@ ) ; if ( @@v4@@ > @@v3@@ ) @@v3@@ = @@v4@@ ; ++ @@a1@@ ; } return @@v3@@ + Number ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; if ( @@a1@@ ) { @@v1@@ = program_name ; @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = program_name ; @@v4@@ = program_name ; @@v5@@ = gettext ( String String String String String String String String ) ; printf ( @@v5@@ , @@v4@@ , @@v3@@ ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; @@v8@@ = stdout ; @@v9@@ = gettext ( String ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
_BYTE * __fastcall strmode ( __int16 @@a1@@ , _BYTE * @@a2@@ ) { char @@v2@@ ; char @@v3@@ ; char @@v4@@ ; char @@v5@@ ; char @@v6@@ ; char @@v7@@ ; char @@v8@@ ; char @@v9@@ ; char @@v10@@ ; _BYTE * @@result@@ ; * @@a2@@ = ftypelet ( @@a1@@ ) ; if ( ( @@a1@@ & Number ) != Number ) @@v2@@ = Number ; else @@v2@@ = Number ; @@a2@@ [ Number ] = @@v2@@ ; if ( ( @@a1@@ & Number ) != Number ) @@v3@@ = Number ; else @@v3@@ = Number ; @@a2@@ [ Number ] = @@v3@@ ; if ( ( @@a1@@ & Number ) != Number ) { if ( ( @@a1@@ & Number ) != Number ) @@v4@@ = Number ; else @@v4@@ = Number ; } else if ( ( @@a1@@ & Number ) != Number ) { @@v4@@ = Number ; } else { @@v4@@ = Number ; } @@a2@@ [ Number ] = @@v4@@ ; if ( ( @@a1@@ & Number ) != Number ) @@v5@@ = Number ; else @@v5@@ = Number ; @@a2@@ [ Number ] = @@v5@@ ; if ( ( @@a1@@ & Number ) != Number ) @@v6@@ = Number ; else @@v6@@ = Number ; @@a2@@ [ Number ] = @@v6@@ ; if ( ( @@a1@@ & Number ) != Number ) { if ( ( @@a1@@ & Number ) != Number ) @@v7@@ = Number ; else @@v7@@ = Number ; } else if ( ( @@a1@@ & Number ) != Number ) { @@v7@@ = Number ; } else { @@v7@@ = Number ; } @@a2@@ [ Number ] = @@v7@@ ; if ( ( @@a1@@ & Number ) != Number ) @@v8@@ = Number ; else @@v8@@ = Number ; @@a2@@ [ Number ] = @@v8@@ ; if ( ( @@a1@@ & Number ) != Number ) @@v9@@ = Number ; else @@v9@@ = Number ; @@a2@@ [ Number ] = @@v9@@ ; if ( ( @@a1@@ & Number ) != Number ) { if ( ( @@a1@@ & Number ) != Number ) @@v10@@ = Number ; else @@v10@@ = Number ; } else if ( ( @@a1@@ & Number ) != Number ) { @@v10@@ = Number ; } else { @@v10@@ = Number ; } @@a2@@ [ Number ] = @@v10@@ ; @@a2@@ [ Number ] = Number ; @@result@@ = @@a2@@ + Number ; @@a2@@ [ Number ] = Number ; return @@result@@ ; }
__int64 __fastcall hash_get_n_buckets ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
__int64 __fastcall hash_get_n_buckets_used ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
__int64 __fastcall hash_get_n_entries ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
unsigned __int64 __fastcall hash_get_max_bucket_length ( __int64 @@a1@@ ) { _QWORD * @@i@@ ; unsigned __int64 @@v3@@ ; _QWORD * @@v4@@ ; unsigned __int64 @@j@@ ; @@v3@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { @@v4@@ = @@i@@ ; for ( @@j@@ = Number L ; ; ++ @@j@@ ) { @@v4@@ = ( _QWORD * ) @@v4@@ [ Number ] ; if ( ! @@v4@@ ) break ; } if ( @@j@@ > @@v3@@ ) @@v3@@ = @@j@@ ; } } return @@v3@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
__int64 __fastcall fts_stat ( __int64 @@a1@@ , __int64 @@a2@@ , char @@a3@@ ) { __int64 @@result@@ ; __int64 @@v4@@ ; int @@v6@@ ; struct stat * @@s@@ ; @@s@@ = ( struct stat * ) ( @@a2@@ + Number ) ; if ( ! * ( _QWORD * ) ( @@a2@@ + Number ) && ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) @@a3@@ = Number ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number || @@a3@@ ) { if ( ( unsigned int ) stat ( * ( char * * ) ( @@a2@@ + Number ) , @@s@@ ) ) { @@v6@@ = * __errno_location ( ) ; if ( * __errno_location ( ) == Number && ! ( unsigned int ) lstat ( * ( char * * ) ( @@a2@@ + Number ) , @@s@@ ) ) { * __errno_location ( ) = Number ; return Number L ; } * ( _DWORD * ) ( @@a2@@ + Number ) = @@v6@@ ; goto LABEL_13 ; } } else if ( ( unsigned int ) fstatat ( * ( _DWORD * ) ( @@a1@@ + Number ) , * ( char * * ) ( @@a2@@ + Number ) , @@s@@ , Number ) ) { * ( _DWORD * ) ( @@a2@@ + Number ) = * __errno_location ( ) ; LABEL_13 : memset ( @@s@@ , Number , sizeof ( struct stat ) ) ; return Number L ; } switch ( * ( _DWORD * ) ( @@a2@@ + Number ) & Number ) { case Number : if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) @@v4@@ = Number L ; else @@v4@@ = Number L ; * ( _QWORD * ) ( @@a2@@ + Number ) = * ( _QWORD * ) ( @@a2@@ + Number ) - @@v4@@ ; if ( * ( _BYTE * ) ( @@a2@@ + Number ) != Number || * ( _BYTE * ) ( @@a2@@ + Number ) && ( * ( _BYTE * ) ( @@a2@@ + Number ) != Number || * ( _BYTE * ) ( @@a2@@ + Number ) ) ) { @@result@@ = Number L ; } else if ( * ( _QWORD * ) ( @@a2@@ + Number ) ) { @@result@@ = Number L ; } else { @@result@@ = Number L ; } break ; case Number : @@result@@ = Number L ; break ; case Number : @@result@@ = Number L ; break ; default : @@result@@ = Number L ; break ; } return @@result@@ ; }
int __cdecl __noreturn main ( int @@argc@@ , const char * * @@argv@@ , const char * * @@envp@@ ) { char * @@v3@@ ; __int64 @@v4@@ ; char * @@v5@@ ; char * @@v6@@ ; int * @@v7@@ ; char @@v8@@ ; int @@i@@ ; double @@v10@@ ; char * @@v11@@ ; double @@v12@@ ; unsigned __int64 @@v13@@ ; @@v13@@ = __readfsqword ( Number ) ; @@v12@@ = Number ; @@v8@@ = Number ; set_program_name ( * @@argv@@ , @@argv@@ , @@envp@@ ) ; setlocale ( Number , & shortopts ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; parse_long_options ( @@argc@@ , ( _DWORD ) @@argv@@ , ( unsigned int ) String , ( unsigned int ) String , ( _DWORD ) Version , ( unsigned int ) usage , String , String , Number L ) ; if ( getopt_long ( @@argc@@ , ( char * const * ) @@argv@@ , & shortopts , Number L , Number L ) != Number ) usage ( Number ) ; if ( @@argc@@ == Number ) { @@v3@@ = gettext ( String ) ; error ( Number , Number , @@v3@@ ) ; usage ( Number ) ; } for ( @@i@@ = optind ; @@i@@ < @@argc@@ ; ++ @@i@@ ) { if ( ( unsigned __int8 ) xstrtod ( @@argv@@ [ @@i@@ ] , & @@v11@@ , & @@v10@@ , c_strtod ) != Number || @@v10@@ < Number || * @@v11@@ && @@v11@@ [ Number ] || ( unsigned __int8 ) apply_suffix ( & @@v10@@ , * @@v11@@ ) != Number ) { @@v4@@ = quote ( @@argv@@ [ @@i@@ ] ) ; @@v5@@ = gettext ( String ) ; error ( Number , Number , @@v5@@ , @@v4@@ ) ; @@v8@@ = Number ; } @@v12@@ = @@v10@@ + @@v12@@ ; } if ( @@v8@@ != Number ) usage ( Number ) ; if ( ( unsigned int ) xnanosleep ( @@v12@@ ) ) { @@v6@@ = gettext ( String ) ; @@v7@@ = __errno_location ( ) ; error ( Number , * @@v7@@ , @@v6@@ ) ; } exit ( Number ) ; }
__int64 __fastcall hash_get_first ( unsigned __int64 * @@a1@@ ) { unsigned __int64 @@i@@ ; if ( ! @@a1@@ [ Number ] ) return Number L ; for ( @@i@@ = * @@a1@@ ; ; @@i@@ += Number L ) { if ( @@i@@ >= @@a1@@ [ Number ] ) abort ( ) ; if ( * ( _QWORD * ) @@i@@ ) break ; } return * ( _QWORD * ) @@i@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
_BOOL8 __fastcall strip_trailing_slashes ( char * @@a1@@ ) { char @@v1@@ ; const char * @@v3@@ ; const char * @@v4@@ ; @@v3@@ = last_component ( @@a1@@ ) ; if ( ! * @@v3@@ ) @@v3@@ = @@a1@@ ; @@v4@@ = & @@v3@@ [ base_len ( @@v3@@ ) ] ; @@v1@@ = * @@v4@@ ; * @@v4@@ = Number ; return @@v1@@ != Number ; }
_BOOL8 __fastcall hash_table_ok ( __int64 @@a1@@ ) { _QWORD * @@i@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; _QWORD * @@v5@@ ; @@v3@@ = Number L ; @@v4@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { @@v5@@ = @@i@@ ; ++ @@v3@@ ; ++ @@v4@@ ; while ( Number ) { @@v5@@ = ( _QWORD * ) @@v5@@ [ Number ] ; if ( ! @@v5@@ ) break ; ++ @@v4@@ ; } } } return @@v3@@ == * ( _QWORD * ) ( @@a1@@ + Number ) && @@v4@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return xmalloc ( @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall hash_get_next ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; _QWORD * @@v4@@ ; _QWORD * @@i@@ ; @@v2@@ = * @@a1@@ ; @@v4@@ = ( _QWORD * ) ( @@v2@@ + Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) ) ; if ( ( unsigned __int64 ) @@v4@@ >= @@a1@@ [ Number ] ) abort ( ) ; for ( @@i@@ = @@v4@@ ; @@i@@ ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { if ( @@a2@@ == * @@i@@ && @@i@@ [ Number ] ) return * ( _QWORD * ) @@i@@ [ Number ] ; } while ( Number ) { @@v4@@ += Number ; if ( ( unsigned __int64 ) @@v4@@ >= @@a1@@ [ Number ] ) break ; if ( * @@v4@@ ) return * @@v4@@ ; } return Number L ; }
__int64 __fastcall hash_do_for_each ( __int64 @@a1@@ , unsigned __int8 ( __fastcall * @@a2@@ ) ( _QWORD , __int64 ) , __int64 @@a3@@ ) { __int64 @@v5@@ ; _QWORD * @@i@@ ; _QWORD * @@j@@ ; @@v5@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = @@i@@ ; @@j@@ ; @@j@@ = ( _QWORD * ) @@j@@ [ Number ] ) { if ( @@a2@@ ( * @@j@@ , @@a3@@ ) != Number ) return @@v5@@ ; ++ @@v5@@ ; } } } return @@v5@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
__int64 __fastcall next_prime ( unsigned __int64 @@a1@@ ) { __int64 @@v2@@ ; __int64 @@i@@ ; @@v2@@ = @@a1@@ ; if ( @@a1@@ <= Number ) @@v2@@ = Number L ; for ( @@i@@ = @@v2@@ | Number ; @@i@@ != Number && ! is_prime ( @@i@@ ) ; @@i@@ += Number L ) { ; } return @@i@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
bool __fastcall is_prime ( unsigned __int64 @@a1@@ ) { unsigned __int64 @@v2@@ ; unsigned __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; @@v2@@ = Number L ; @@v4@@ = Number L ; while ( @@v4@@ < @@a1@@ && @@a1@@ % @@v2@@ ) { @@v3@@ = @@v2@@ + Number ; @@v4@@ += Number * @@v3@@ ; @@v2@@ = @@v3@@ + Number ; } return @@a1@@ % @@v2@@ != Number ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_2070C8 ; @@v8@@ [ Number ] = qword_2070D0 ; @@v8@@ [ Number ] = qword_2070D8 ; @@v8@@ [ Number ] = qword_2070E0 ; @@v8@@ [ Number ] = qword_2070E8 ; @@v8@@ [ Number ] = qword_2070F0 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
unsigned __int64 __fastcall compute_bucket_size ( __int64 @@a1@@ , __int64 @@a2@@ ) { float @@v2@@ ; unsigned __int64 @@result@@ ; unsigned __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; float @@v6@@ ; @@v4@@ = @@a1@@ ; if ( * ( _BYTE * ) ( @@a2@@ + Number ) != Number ) { if ( @@a1@@ < Number ) @@v2@@ = ( float ) ( @@a1@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@a1@@ >> Number ) ) + ( float ) ( @@a1@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@a1@@ >> Number ) ) ; else @@v2@@ = ( float ) ( int ) @@a1@@ ; @@v6@@ = @@v2@@ / * ( float * ) ( @@a2@@ + Number ) ; if ( @@v6@@ >= Number ) return Number L ; if ( @@v6@@ >= Number ) @@v4@@ = ( unsigned int ) ( int ) ( float ) ( @@v6@@ - Number ) ^ Number ; else @@v4@@ = ( unsigned int ) ( int ) @@v6@@ ; } @@v5@@ = next_prime ( @@v4@@ ) ; if ( @@v5@@ <= Number ) @@result@@ = @@v5@@ ; else @@result@@ = Number L ; return @@result@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
size_t * __fastcall hash_initialize ( __int64 @@a1@@ , void * @@a2@@ , unsigned __int64 ( __fastcall * @@a3@@ ) ( __int64 a1 , unsigned __int64 a2 ) , bool ( __fastcall * @@a4@@ ) ( __int64 a1 , __int64 a2 ) , size_t @@a5@@ ) { size_t * @@result@@ ; bool ( __fastcall * @@v7@@ ) ( __int64 , __int64 ) ; unsigned __int64 ( __fastcall * @@v8@@ ) ( __int64 , unsigned __int64 ) ; void * @@v9@@ ; size_t * @@ptr@@ ; @@v9@@ = @@a2@@ ; @@v8@@ = @@a3@@ ; @@v7@@ = @@a4@@ ; if ( ! @@a3@@ ) @@v8@@ = raw_hasher ; if ( ! @@a4@@ ) @@v7@@ = raw_comparator ; @@ptr@@ = ( size_t * ) malloc ( Number ) ; if ( ! @@ptr@@ ) return Number L ; if ( ! @@a2@@ ) @@v9@@ = & default_tuning ; @@ptr@@ [ Number ] = ( size_t ) @@v9@@ ; if ( ( unsigned __int8 ) check_tuning ( ( __int64 ) @@ptr@@ ) == Number && ( @@ptr@@ [ Number ] = compute_bucket_size ( @@a1@@ , ( __int64 ) @@v9@@ ) ) != Number && ( * @@ptr@@ = ( size_t ) calloc ( @@ptr@@ [ Number ] , Number ) ) != Number ) { @@ptr@@ [ Number ] = Number * @@ptr@@ [ Number ] + * @@ptr@@ ; @@ptr@@ [ Number ] = Number L ; @@ptr@@ [ Number ] = Number L ; @@ptr@@ [ Number ] = ( size_t ) @@v8@@ ; @@ptr@@ [ Number ] = ( size_t ) @@v7@@ ; @@ptr@@ [ Number ] = @@a5@@ ; @@ptr@@ [ Number ] = Number L ; @@result@@ = @@ptr@@ ; } else { free ( @@ptr@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
__int64 __fastcall free_entry ( __int64 @@a1@@ , _QWORD * @@a2@@ ) { __int64 @@result@@ ; * @@a2@@ = Number L ; @@a2@@ [ Number ] = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@result@@ = @@a1@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
int clock_gettime ( clockid_t @@clock_id@@ , struct timespec * @@tp@@ ) { return clock_gettime ( @@clock_id@@ , @@tp@@ ) ; }
__int64 __fastcall i_ring_pop ( __int64 @@a1@@ ) { unsigned int @@v2@@ ; if ( ( unsigned __int8 ) i_ring_empty ( @@a1@@ ) ) abort ( ) ; @@v2@@ = * ( _DWORD * ) ( @@a1@@ + Number L * * ( unsigned int * ) ( @@a1@@ + Number ) ) ; * ( _DWORD * ) ( @@a1@@ + Number L * * ( unsigned int * ) ( @@a1@@ + Number ) ) = * ( _DWORD * ) ( @@a1@@ + Number ) ; if ( * ( _DWORD * ) ( @@a1@@ + Number ) == * ( _DWORD * ) ( @@a1@@ + Number ) ) * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; else * ( _DWORD * ) ( @@a1@@ + Number ) = ( ( unsigned __int8 ) * ( _DWORD * ) ( @@a1@@ + Number ) + Number ) & Number ; return @@v2@@ ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
int getc_unlocked ( FILE * @@stream@@ ) { return getc_unlocked ( @@stream@@ ) ; }
int __fastcall rpl_nanosleep ( __time_t * @@a1@@ , struct timespec * @@a2@@ ) { int @@v3@@ ; __time_t @@v4@@ ; struct timespec @@requested_time@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = __readfsqword ( Number ) ; @@v4@@ = * @@a1@@ ; @@requested_time@@ . tv_nsec = Number L ; do { if ( @@v4@@ <= Number ) { @@requested_time@@ . tv_sec = @@v4@@ ; @@requested_time@@ . tv_nsec = @@a1@@ [ Number ] ; return nanosleep ( & @@requested_time@@ , @@a2@@ ) ; } @@requested_time@@ . tv_sec = Number L ; @@v3@@ = nanosleep ( & @@requested_time@@ , @@a2@@ ) ; @@v4@@ -= Number L ; } while ( ! @@v3@@ ) ; if ( @@a2@@ ) { @@a2@@ -> tv_sec += @@v4@@ ; @@a2@@ -> tv_nsec += @@a1@@ [ Number ] ; if ( @@a1@@ [ Number ] > Number ) { ++ @@a2@@ -> tv_sec ; @@a2@@ -> tv_nsec -= Number L ; } } return @@v3@@ ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
__int64 __fastcall hash_rehash ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; unsigned __int64 @@nmemb@@ ; void * @@v4@@ ; __int64 @@v5@@ ; unsigned __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; __int64 @@v12@@ ; __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; @@v14@@ = __readfsqword ( Number ) ; @@nmemb@@ = compute_bucket_size ( @@a2@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ; if ( ! @@nmemb@@ ) return Number L ; if ( @@nmemb@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; @@v4@@ = calloc ( @@nmemb@@ , Number ) ; if ( ! @@v4@@ ) return Number L ; @@v6@@ = @@nmemb@@ ; @@v5@@ = ( __int64 ) @@v4@@ + Number * @@nmemb@@ ; @@v7@@ = Number L ; @@v8@@ = Number L ; @@v9@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v10@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v11@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v12@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v13@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( ( unsigned __int8 ) transfer_entries ( ( __int64 ) & @@v4@@ , @@a1@@ , Number ) ) { free ( * ( void * * ) @@a1@@ ) ; * ( _QWORD * ) @@a1@@ = @@v4@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v5@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v6@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v7@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v13@@ ; @@result@@ = Number L ; } else { * ( _QWORD * ) ( @@a1@@ + Number ) = @@v13@@ ; if ( ( unsigned __int8 ) transfer_entries ( @@a1@@ , ( __int64 ) & @@v4@@ , Number ) != Number || ( unsigned __int8 ) transfer_entries ( @@a1@@ , ( __int64 ) & @@v4@@ , Number ) != Number ) { abort ( ) ; } free ( @@v4@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
__int64 __fastcall mode_create_from_ref ( char * @@a1@@ ) { __int64 @@result@@ ; struct stat @@v2@@ ; unsigned __int64 @@v3@@ ; @@v3@@ = __readfsqword ( Number ) ; if ( ( unsigned int ) stat ( @@a1@@ , & @@v2@@ ) ) @@result@@ = Number L ; else @@result@@ = make_node_op_equals ( @@v2@@ . st_mode , Number ) ; return @@result@@ ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; char * @@v3@@ ; FILE * @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; FILE * @@v10@@ ; char * @@v11@@ ; FILE * @@v12@@ ; char * @@v13@@ ; FILE * @@v14@@ ; char * @@v15@@ ; FILE * @@v16@@ ; char * @@v17@@ ; @@v1@@ = program_name ; if ( @@a1@@ ) { @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = gettext ( String ) ; printf ( @@v3@@ , @@v1@@ ) ; @@v4@@ = stdout ; @@v5@@ = gettext ( String String String ) ; fputs_unlocked ( @@v5@@ , @@v4@@ ) ; fputc_unlocked ( Number , stdout ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String String String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; @@v8@@ = stdout ; @@v9@@ = gettext ( String String ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = stdout ; @@v11@@ = gettext ( String String String String String ) ; fputs_unlocked ( @@v11@@ , @@v10@@ ) ; fputc_unlocked ( Number , stdout ) ; @@v12@@ = stdout ; @@v13@@ = gettext ( String String String String ) ; fputs_unlocked ( @@v13@@ , @@v12@@ ) ; fputc_unlocked ( Number , stdout ) ; @@v14@@ = stdout ; @@v15@@ = gettext ( String ) ; fputs_unlocked ( @@v15@@ , @@v14@@ ) ; @@v16@@ = stdout ; @@v17@@ = gettext ( String ) ; fputs_unlocked ( @@v17@@ , @@v16@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
int __xstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _xstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
__int64 __fastcall openat_safer ( int @@a1@@ , const char * @@a2@@ , char @@a3@@ , unsigned int @@a4@@ ) { unsigned int @@v4@@ ; unsigned int @@v6@@ ; @@v6@@ = Number ; if ( ( @@a3@@ & Number ) != Number ) @@v6@@ = @@a4@@ ; @@v4@@ = openat ( @@a1@@ , @@a2@@ , @@a3@@ , @@v6@@ ) ; return fd_safer ( @@v4@@ ) ; }
__int64 __fastcall open_safer ( const char * @@a1@@ , char @@a2@@ , unsigned int @@a3@@ ) { unsigned int @@v3@@ ; unsigned int @@v5@@ ; @@v5@@ = Number ; if ( ( @@a2@@ & Number ) != Number ) @@v5@@ = @@a3@@ ; @@v3@@ = open ( @@a1@@ , @@a2@@ , @@v5@@ ) ; return fd_safer ( @@v3@@ ) ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
int iswspace ( wint_t @@wc@@ ) { return iswspace ( @@wc@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
_BOOL8 __fastcall du_files ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { char * @@v2@@ ; int * @@v3@@ ; char * @@v4@@ ; int * @@v5@@ ; bool @@v7@@ ; __int64 @@i@@ ; __int64 @@v9@@ ; @@v7@@ = Number ; if ( * @@a1@@ ) { for ( @@i@@ = xfts_open ( @@a1@@ , @@a2@@ , Number L ) ; ; @@v7@@ = ( @@v7@@ & ( unsigned __int8 ) process_file ( @@i@@ , @@v9@@ ) ) != Number ) { @@v9@@ = fts_read ( @@i@@ ) ; if ( ! @@v9@@ ) break ; } if ( * __errno_location ( ) ) { @@v2@@ = gettext ( String ) ; @@v3@@ = __errno_location ( ) ; error ( Number , * @@v3@@ , @@v2@@ ) ; @@v7@@ = Number ; } if ( ( unsigned int ) fts_close ( @@i@@ ) ) { @@v4@@ = gettext ( String ) ; @@v5@@ = __errno_location ( ) ; error ( Number , * @@v5@@ , @@v4@@ ) ; @@v7@@ = Number ; } } return @@v7@@ ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_20E038 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_20A038 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
bool __fastcall is_basic ( unsigned __int8 @@a1@@ ) { return ( ( is_basic_table [ @@a1@@ >> Number ] >> ( @@a1@@ & Number ) ) & Number ) != Number ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_20A0E8 ; @@v4@@ [ Number ] = qword_20A0F0 ; @@v4@@ [ Number ] = qword_20A0F8 ; @@v4@@ [ Number ] = qword_20A100 ; @@v4@@ [ Number ] = qword_20A108 ; @@v4@@ [ Number ] = qword_20A110 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
const char * __fastcall proper_name ( const char * @@a1@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; char * @@s@@ ; char * @@v5@@ ; @@s@@ = gettext ( @@a1@@ ) ; if ( @@s@@ == @@a1@@ ) return @@a1@@ ; if ( ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@s@@ , ( __int64 ) @@a1@@ ) ) return @@s@@ ; @@v2@@ = strlen ( @@s@@ ) ; @@v3@@ = strlen ( @@a1@@ ) ; @@v5@@ = ( char * ) xmalloc ( @@v2@@ + @@v3@@ + Number ) ; sprintf ( @@v5@@ , String , @@s@@ , @@a1@@ ) ; return @@v5@@ ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_20E108 ; @@v8@@ [ Number ] = qword_20E110 ; @@v8@@ [ Number ] = qword_20E118 ; @@v8@@ [ Number ] = qword_20E120 ; @@v8@@ [ Number ] = qword_20E128 ; @@v8@@ [ Number ] = qword_20E130 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return xmalloc ( @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall strnlen1 ( const void * @@a1@@ , size_t @@a2@@ ) { __int64 @@result@@ ; _BYTE * @@v3@@ ; @@v3@@ = memchr ( @@a1@@ , Number , @@a2@@ ) ; if ( @@v3@@ ) @@result@@ = @@v3@@ - ( _BYTE * ) @@a1@@ + Number ; else @@result@@ = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall xfts_open ( const char * * @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { unsigned int @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; __int64 @@v7@@ ; @@v3@@ = @@a2@@ ; BYTE1 ( @@v3@@ ) = BYTE1 ( @@a2@@ ) | Number ; @@v4@@ = @@v3@@ ; @@v7@@ = fts_open ( @@a1@@ , @@v3@@ , @@a3@@ ) ; if ( ! @@v7@@ ) { if ( * __errno_location ( ) == Number ) __assert_fail ( String , String , Number , String ) ; xalloc_die ( @@a1@@ , @@v4@@ , @@v5@@ ) ; } return @@v7@@ ; }
__int64 __fastcall xstr_iconv ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v4@@ ; @@v4@@ = str_iconv ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( ! @@v4@@ && * __errno_location ( ) == Number ) xalloc_die ( ) ; return @@v4@@ ; }
bool __fastcall check_x_suffix ( const char * @@a1@@ , size_t @@a2@@ ) { return @@a2@@ <= strspn ( @@a1@@ , String ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
bool __fastcall is_zero_or_power_of_two ( __int64 @@a1@@ ) { return ( @@a1@@ & ( @@a1@@ - Number ) ) == Number ; }
int __fastcall argmatch_valid ( __int64 @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { char * @@v3@@ ; __int64 @@i@@ ; void * @@s1@@ ; @@s1@@ = Number L ; @@v3@@ = gettext ( String ) ; fprintf ( stderr , @@v3@@ ) ; for ( @@i@@ = Number L ; * ( _QWORD * ) ( Number * @@i@@ + @@a1@@ ) ; ++ @@i@@ ) { if ( @@i@@ && ! memcmp ( @@s1@@ , ( const void * ) ( @@i@@ * @@a3@@ + @@a2@@ ) , @@a3@@ ) ) { fprintf ( stderr , String , * ( const char * * ) ( Number * @@i@@ + @@a1@@ ) ) ; } else { fprintf ( stderr , String , * ( const char * * ) ( Number * @@i@@ + @@a1@@ ) ) ; @@s1@@ = ( void * ) ( @@i@@ * @@a3@@ + @@a2@@ ) ; } } return putc_unlocked ( Number , stderr ) ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall dup_safer ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
__int64 __fastcall argmatch_to_argument ( const void * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; ++ @@i@@ ) { if ( ! memcmp ( @@a1@@ , ( const void * ) ( @@i@@ * @@a4@@ + @@a3@@ ) , @@a4@@ ) ) return * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; } return Number L ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
int __fastcall stat ( char * @@filename@@ , struct stat * @@stat_buf@@ ) { return __xstat ( Number , @@filename@@ , @@stat_buf@@ ) ; }
__int64 __fastcall randint_get_source ( __int64 @@a1@@ ) { return * ( _QWORD * ) @@a1@@ ; }
_QWORD * __fastcall randint_all_new ( __int64 @@a1@@ , __int64 @@a2@@ ) { _QWORD * @@result@@ ; __int64 @@v3@@ ; @@v3@@ = randread_new ( @@a1@@ , @@a2@@ ) ; if ( @@v3@@ ) @@result@@ = randint_new ( @@v3@@ , @@a2@@ ) ; else @@result@@ = Number L ; return @@result@@ ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
__int64 __fastcall shift_left ( __int64 @@a1@@ ) { return @@a1@@ << Number ; }
int __fastcall fstat ( int @@fildes@@ , struct stat * @@stat_buf@@ ) { return __fxstat ( Number , @@fildes@@ , @@stat_buf@@ ) ; }
__int64 __fastcall randint_all_free ( _QWORD * @@a1@@ ) { unsigned int @@v2@@ ; int @@v3@@ ; @@v2@@ = randread_free ( * @@a1@@ ) ; @@v3@@ = * __errno_location ( ) ; randint_free ( @@a1@@ ) ; * __errno_location ( ) = @@v3@@ ; return @@v2@@ ; }
__int64 __fastcall set_cloexec_flag ( int @@a1@@ , char @@a2@@ , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { int @@v6@@ ; int @@v7@@ ; int @@v8@@ ; unsigned int @@v9@@ ; __int64 @@result@@ ; int @@v11@@ ; @@v11@@ = rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( @@v11@@ < Number || ( ! @@a2@@ ? ( @@v9@@ = @@v11@@ & Number ) : ( @@v9@@ = @@v11@@ | Number ) , @@v11@@ != @@v9@@ && ( unsigned int ) rpl_fcntl ( @@a1@@ , Number , @@v9@@ , @@v6@@ , @@v7@@ , @@v8@@ ) == Number ) ) { @@result@@ = Number ; } else { @@result@@ = Number L ; } return @@result@@ ; }
int __fastcall lstat ( char * @@filename@@ , struct stat * @@stat_buf@@ ) { return __lxstat ( Number , @@filename@@ , @@stat_buf@@ ) ; }
_QWORD * __fastcall simple_new ( __int64 @@a1@@ , __int64 @@a2@@ ) { _QWORD * @@result@@ ; @@result@@ = xmalloc ( Number , @@a2@@ ) ; * @@result@@ = @@a1@@ ; @@result@@ [ Number ] = randread_error ; @@result@@ [ Number ] = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall fd_safer ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { unsigned int @@fd@@ ; unsigned int @@v8@@ ; int @@v9@@ ; @@fd@@ = @@a1@@ ; if ( @@a1@@ >= Number && @@a1@@ <= Number ) { @@v8@@ = dup_safer ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; @@v9@@ = * __errno_location ( ) ; close ( @@a1@@ ) ; * __errno_location ( ) = @@v9@@ ; @@fd@@ = @@v8@@ ; } return @@fd@@ ; }
unsigned __int64 __fastcall randint_genmax ( __int64 * @@a1@@ , unsigned __int64 @@a2@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; char @@v11@@ [ Number ] ; unsigned __int64 @@v12@@ ; @@v12@@ = __readfsqword ( Number ) ; @@v8@@ = * @@a1@@ ; @@v3@@ = @@a1@@ [ Number ] ; @@v4@@ = @@a1@@ [ Number ] ; @@v9@@ = @@a2@@ + Number ; while ( Number ) { if ( @@v4@@ < @@a2@@ ) { @@v5@@ = Number L ; @@v7@@ = @@v4@@ ; do { @@v7@@ = shift_left ( @@v7@@ ) + Number ; ++ @@v5@@ ; } while ( @@v7@@ < @@a2@@ ) ; randread ( @@v8@@ , @@v11@@ , @@v5@@ ) ; @@v6@@ = Number L ; do { @@v3@@ = shift_left ( @@v3@@ ) + ( unsigned __int8 ) @@v11@@ [ @@v6@@ ] ; @@v4@@ = shift_left ( @@v4@@ ) + Number ; ++ @@v6@@ ; } while ( @@v4@@ < @@a2@@ ) ; } if ( @@v4@@ == @@a2@@ ) { @@a1@@ [ Number ] = Number L ; @@a1@@ [ Number ] = @@a1@@ [ Number ] ; return @@v3@@ ; } @@v10@@ = ( @@v4@@ - @@a2@@ ) % @@v9@@ ; if ( @@v3@@ <= @@v4@@ - @@v10@@ ) break ; @@v3@@ %= @@v9@@ ; @@v4@@ = @@v10@@ - Number ; } @@a1@@ [ Number ] = @@v3@@ / @@v9@@ ; @@a1@@ [ Number ] = ( @@v4@@ - @@a2@@ ) / @@v9@@ ; return @@v3@@ % @@v9@@ ; }
int __fastcall fstatat ( int @@fildes@@ , char * @@filename@@ , struct stat * @@stat_buf@@ , int @@flag@@ ) { return __fxstatat ( Number , @@fildes@@ , @@filename@@ , @@stat_buf@@ , @@flag@@ ) ; }
unsigned __int64 __fastcall string_hasher_ci ( char * @@a1@@ , unsigned __int64 @@a2@@ ) { signed int @@v4@@ ; unsigned __int64 @@v5@@ ; char @@v6@@ [ Number ] ; int @@v7@@ ; char @@i@@ ; char * @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; unsigned __int64 @@v12@@ ; @@v12@@ = __readfsqword ( Number ) ; @@v5@@ = Number L ; @@v9@@ = @@a1@@ ; @@v6@@ [ Number ] = Number ; memset ( & @@v7@@ , Number , Number ) ; for ( @@i@@ = Number ; ; @@i@@ = Number ) { mbuiter_multi_next_0 ( ( __int64 ) @@v6@@ ) ; if ( ( unsigned __int8 ) @@v11@@ == Number && ! HIDWORD ( @@v11@@ ) ) break ; if ( ( _BYTE ) @@v11@@ ) @@v4@@ = towlower ( HIDWORD ( @@v11@@ ) ) ; else @@v4@@ = * @@v9@@ ; @@v5@@ = ( Number * @@v5@@ + @@v4@@ ) % @@a2@@ ; @@v9@@ += @@v10@@ ; } return @@v5@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
char * __fastcall randread_new ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { size_t @@v3@@ ; FILE * @@stream@@ ; char * @@v5@@ ; if ( ! @@a2@@ ) return ( char * ) simple_new ( Number L , Number L ) ; @@stream@@ = Number L ; if ( @@a1@@ ) { @@stream@@ = ( FILE * ) fopen_safer ( @@a1@@ , & off_7CD0 ) ; if ( ! @@stream@@ ) return Number L ; } @@v5@@ = ( char * ) simple_new ( ( __int64 ) @@stream@@ , @@a1@@ ) ; if ( @@stream@@ ) { @@v3@@ = Number L ; if ( @@a2@@ <= Number ) @@v3@@ = @@a2@@ ; setvbuf ( @@stream@@ , @@v5@@ + Number , Number , @@v3@@ ) ; } else { * ( ( _QWORD * ) @@v5@@ + Number ) = Number L ; isaac_seed ( @@v5@@ + Number ) ; } return @@v5@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
void __fastcall free_exclude ( _QWORD * * @@a1@@ ) { _QWORD * @@i@@ ; _QWORD * @@v2@@ ; for ( @@i@@ = * @@a1@@ ; @@i@@ ; @@i@@ = @@v2@@ ) { @@v2@@ = ( _QWORD * ) * @@i@@ ; free_exclude_segment ( ( __int64 ) @@i@@ ) ; } free ( @@a1@@ ) ; }
FILE * __fastcall fopen_safer ( const char * @@a1@@ , const char * @@a2@@ ) { int @@v3@@ ; int @@fd@@ ; int @@v5@@ ; int @@v6@@ ; FILE * @@stream@@ ; @@stream@@ = fopen ( @@a1@@ , @@a2@@ ) ; if ( ! @@stream@@ ) return @@stream@@ ; @@v3@@ = fileno ( @@stream@@ ) ; if ( @@v3@@ < Number || @@v3@@ > Number ) return @@stream@@ ; @@fd@@ = dup_safer ( ( unsigned int ) @@v3@@ ) ; if ( @@fd@@ < Number ) { @@v6@@ = * __errno_location ( ) ; fclose ( @@stream@@ ) ; * __errno_location ( ) = @@v6@@ ; return Number L ; } if ( ! fclose ( @@stream@@ ) ) { @@stream@@ = fdopen ( @@fd@@ , @@a2@@ ) ; if ( @@stream@@ ) return @@stream@@ ; } @@v5@@ = * __errno_location ( ) ; close ( @@fd@@ ) ; * __errno_location ( ) = @@v5@@ ; return Number L ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
DIR * opendir ( const char * @@name@@ ) { return opendir ( @@name@@ ) ; }
unsigned __int64 __fastcall isaac_seed ( _DWORD * @@a1@@ ) { __int64 @@v2@@ ; unsigned __int64 @@v3@@ ; @@v3@@ = __readfsqword ( Number ) ; isaac_seed_start ( @@a1@@ ) ; LODWORD ( @@v2@@ ) = getpid ( ) ; isaac_seed_data ( @@a1@@ , ( __int64 ) & @@v2@@ , Number ) ; LODWORD ( @@v2@@ ) = getppid ( ) ; isaac_seed_data ( @@a1@@ , ( __int64 ) & @@v2@@ , Number ) ; LODWORD ( @@v2@@ ) = getuid ( ) ; isaac_seed_data ( @@a1@@ , ( __int64 ) & @@v2@@ , Number ) ; LODWORD ( @@v2@@ ) = getgid ( ) ; isaac_seed_data ( @@a1@@ , ( __int64 ) & @@v2@@ , Number ) ; @@v2@@ = gethrxtime ( ) ; isaac_seed_data ( @@a1@@ , ( __int64 ) & @@v2@@ , Number ) ; isaac_seed_finish ( @@a1@@ ) ; return __readfsqword ( Number ) ^ @@v3@@ ; }
_BOOL8 __fastcall exclude_fnmatch ( __int64 @@a1@@ , _BYTE * @@a2@@ , unsigned int @@a3@@ ) { void * @@v3@@ ; bool @@v6@@ ; _BYTE * @@i@@ ; unsigned int ( __fastcall * @@v8@@ ( ) ( constchar , constchar , int ) ) ( __int64 , _BYTE * , _QWORD ) ; if ( ( @@a3@@ & Number ) != Number ) @@v3@@ = & fnmatch ; else @@v3@@ = fnmatch_no_wildcards ; @@v8@@ ( ) ( constchar , constchar , int ) = ( unsigned int ( __fastcall * ) ( __int64 , _BYTE * , _QWORD ) ) @@v3@@ ; @@v6@@ = ( ( unsigned int ( __fastcall * ) ( __int64 , _BYTE * , _QWORD ) ) @@v3@@ ) ( @@a1@@ , @@a2@@ , @@a3@@ ) == Number ; if ( ( @@a3@@ & Number ) == Number ) { for ( @@i@@ = @@a2@@ ; * @@i@@ && ! @@v6@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number && @@i@@ [ Number ] != Number ) @@v6@@ = @@v8@@ ( ) ( constchar , constchar , int ) ( @@a1@@ , @@i@@ + Number , @@a3@@ ) == Number ; } } return @@v6@@ ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
int __fastcall lstat ( char * @@filename@@ , struct stat * @@stat_buf@@ ) { return __lxstat ( Number , @@filename@@ , @@stat_buf@@ ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
__int64 __fastcall fwrite_lowcase ( FILE * @@a1@@ , unsigned __int8 * @@a2@@ , __int64 @@a3@@ ) { int @@v3@@ ; __int64 @@result@@ ; while ( Number ) { @@result@@ = @@a3@@ -- ; if ( ! @@result@@ ) break ; @@v3@@ = tolower ( * @@a2@@ ) ; fputc ( @@v3@@ , @@a1@@ ) ; ++ @@a2@@ ; } return @@result@@ ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
struct dirent * readdir ( DIR * @@dirp@@ ) { return readdir ( @@dirp@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
int __cdecl __noreturn main ( int @@argc@@ , const char * * @@argv@@ , const char * * @@envp@@ ) { int * @@v3@@ ; char @@v4@@ ; int @@i@@ ; set_program_name ( * @@argv@@ , @@argv@@ , @@envp@@ ) ; setlocale ( Number , & shortopts ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; parse_long_options ( @@argc@@ , ( _DWORD ) @@argv@@ , ( unsigned int ) String , ( unsigned int ) String , ( _DWORD ) Version , ( unsigned int ) usage , String , Number L ) ; if ( getopt_long ( @@argc@@ , ( char * const * ) @@argv@@ , & shortopts , Number L , Number L ) != Number ) usage ( Number ) ; have_read_stdin = Number ; if ( @@argc@@ == optind ) { @@v4@@ = cksum ( String , Number ) ; } else { @@v4@@ = Number ; for ( @@i@@ = optind ; @@i@@ < @@argc@@ ; ++ @@i@@ ) @@v4@@ = ( unsigned __int8 ) ( @@v4@@ & cksum ( @@argv@@ [ @@i@@ ] , Number ) ) != Number ; } if ( have_read_stdin ) { if ( fclose ( stdin ) == Number ) { @@v3@@ = __errno_location ( ) ; error ( Number , * @@v3@@ , String ) ; } } exit ( ( unsigned __int8 ) @@v4@@ ^ Number ) ; }
__int64 __fastcall protect_fd ( int @@a1@@ ) { int @@fd@@ ; @@fd@@ = open ( String , Number ) ; if ( @@fd@@ == @@a1@@ ) return Number L ; if ( @@fd@@ >= Number ) { close ( @@fd@@ ) ; * __errno_location ( ) = Number ; } return Number L ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
DIR * fdopendir ( int @@fd@@ ) { return fdopendir ( @@fd@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
void free ( void * @@ptr@@ ) { __imp_free ( @@ptr@@ ) ; }
int __fxstatat ( int @@ver@@ , int @@fildes@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ , int @@flag@@ ) { return _fxstatat ( @@ver@@ , @@fildes@@ , @@filename@@ , @@stat_buf@@ , @@flag@@ ) ; }
unsigned __int64 __fastcall leave_dir ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 * @@v3@@ ; __int64 * @@v4@@ ; void * @@ptr@@ ; __int64 @@v6@@ [ Number ] ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v3@@ = ( __int64 * ) ( @@a2@@ + Number ) ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { @@v6@@ [ Number ] = * @@v3@@ ; @@v6@@ [ Number ] = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@ptr@@ = ( void * ) hash_delete ( * ( _QWORD * ) ( @@a1@@ + Number ) , @@v6@@ ) ; if ( ! @@ptr@@ ) abort ( ) ; free ( @@ptr@@ ) ; } else { @@v4@@ = * ( __int64 * * ) ( @@a2@@ + Number ) ; if ( @@v4@@ && @@v4@@ [ Number ] >= Number ) { if ( ! * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L ) ) abort ( ) ; if ( * * ( _QWORD * * ) ( @@a1@@ + Number ) == * ( _QWORD * ) ( @@a2@@ + Number ) && * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L ) == * @@v3@@ ) { * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L ) = @@v4@@ [ Number ] ; * * ( _QWORD * * ) ( @@a1@@ + Number ) = @@v4@@ [ Number ] ; } } } return __readfsqword ( Number ) ^ @@v7@@ ; }
int __xstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _xstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
bool __fastcall mode_changed ( char * @@a1@@ , unsigned __int16 @@a2@@ , unsigned __int16 @@a3@@ ) { __int64 @@v3@@ ; char * @@v4@@ ; int * @@v5@@ ; unsigned __int16 @@v7@@ ; struct stat @@v8@@ ; unsigned __int64 @@v9@@ ; @@v7@@ = @@a3@@ ; @@v9@@ = __readfsqword ( Number ) ; if ( ( @@a3@@ & Number ) == Number ) return ( ( @@v7@@ ^ @@a2@@ ) & Number ) != Number ; if ( ! ( unsigned int ) stat ( @@a1@@ , & @@v8@@ ) ) { @@v7@@ = @@v8@@ . st_mode ; return ( ( @@v7@@ ^ @@a2@@ ) & Number ) != Number ; } if ( force_silent != Number ) { @@v3@@ = quote ( @@a1@@ ) ; @@v4@@ = gettext ( String ) ; @@v5@@ = __errno_location ( ) ; error ( Number , * @@v5@@ , @@v4@@ , @@v3@@ ) ; } return Number ; }
int fchdir ( int @@fd@@ ) { return fchdir ( @@fd@@ ) ; }
__int64 __fastcall fts_close ( __int64 @@a1@@ ) { _QWORD * @@v1@@ ; void * @@v2@@ ; _QWORD * @@v3@@ ; int @@v5@@ ; @@v5@@ = Number ; if ( * ( _QWORD * ) @@a1@@ ) { @@v1@@ = * ( _QWORD * * ) @@a1@@ ; while ( ( __int64 ) @@v1@@ [ Number ] >= Number ) { @@v2@@ = @@v1@@ ; if ( @@v1@@ [ Number ] ) @@v3@@ = ( _QWORD * ) @@v1@@ [ Number ] ; else @@v3@@ = ( _QWORD * ) @@v1@@ [ Number ] ; @@v1@@ = @@v3@@ ; free ( @@v2@@ ) ; } free ( @@v1@@ ) ; } if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) fts_lfree ( * ( void * * ) ( @@a1@@ + Number ) ) ; free ( * ( void * * ) ( @@a1@@ + Number ) ) ; free ( * ( void * * ) ( @@a1@@ + Number ) ) ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { if ( * ( int * ) ( @@a1@@ + Number ) >= Number && close ( * ( _DWORD * ) ( @@a1@@ + Number ) ) ) { LABEL_20 : @@v5@@ = * __errno_location ( ) ; goto LABEL_21 ; } } else if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) == Number ) { if ( fchdir ( * ( _DWORD * ) ( @@a1@@ + Number ) ) ) @@v5@@ = * __errno_location ( ) ; if ( close ( * ( _DWORD * ) ( @@a1@@ + Number ) ) && ! @@v5@@ ) goto LABEL_20 ; } LABEL_21 : fd_ring_clear ( @@a1@@ + Number ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) hash_free ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ; free_dir ( @@a1@@ ) ; free ( ( void * ) @@a1@@ ) ; if ( ! @@v5@@ ) return Number L ; * __errno_location ( ) = @@v5@@ ; return Number ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_207028 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; FILE * @@v11@@ ; char * @@v12@@ ; FILE * @@v13@@ ; char * @@v14@@ ; FILE * @@v15@@ ; char * @@v16@@ ; FILE * @@v17@@ ; char * @@v18@@ ; if ( @@a1@@ ) { @@v1@@ = program_name ; @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = program_name ; @@v4@@ = program_name ; @@v5@@ = program_name ; @@v6@@ = gettext ( String String String ) ; printf ( @@v6@@ , @@v5@@ , @@v4@@ , @@v3@@ ) ; @@v7@@ = stdout ; @@v8@@ = gettext ( String String String ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = stdout ; @@v10@@ = gettext ( String String ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; @@v11@@ = stdout ; @@v12@@ = gettext ( String String String String ) ; fputs_unlocked ( @@v12@@ , @@v11@@ ) ; @@v13@@ = stdout ; @@v14@@ = gettext ( String ) ; fputs_unlocked ( @@v14@@ , @@v13@@ ) ; @@v15@@ = stdout ; @@v16@@ = gettext ( String ) ; fputs_unlocked ( @@v16@@ , @@v15@@ ) ; @@v17@@ = stdout ; @@v18@@ = gettext ( String ) ; fputs_unlocked ( @@v18@@ , @@v17@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 __fastcall fts_sort ( __int64 @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { size_t @@v3@@ ; _QWORD * @@v5@@ ; __int64 @@i@@ ; _QWORD * @@v7@@ ; _QWORD * @@v8@@ ; __int64 @@v9@@ ; int ( * @@compar@@ ( ) ( constvoid , constvoid ) ) ( const void * , const void * ) ; void * @@v11@@ ; @@v3@@ = @@a3@@ ; @@compar@@ ( ) ( constvoid , constvoid ) = * ( int ( * * ) ( const void * , const void * ) ) ( @@a1@@ + Number ) ; if ( @@a3@@ > * ( _QWORD * ) ( @@a1@@ + Number ) ) { * ( _QWORD * ) ( @@a1@@ + Number ) = @@a3@@ + Number ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) > Number || ( @@v11@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number L * * ( _QWORD * ) ( @@a1@@ + Number ) ) ) == Number L ) { free ( * ( void * * ) ( @@a1@@ + Number ) ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; return @@a2@@ ; } * ( _QWORD * ) ( @@a1@@ + Number ) = @@v11@@ ; } @@v5@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; for ( @@i@@ = @@a2@@ ; @@i@@ ; @@i@@ = * ( _QWORD * ) ( @@i@@ + Number ) ) { @@v7@@ = @@v5@@ ++ ; * @@v7@@ = @@i@@ ; } qsort ( * ( void * * ) ( @@a1@@ + Number ) , @@v3@@ , Number , @@compar@@ ( ) ( constvoid , constvoid ) ) ; @@v8@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; @@v9@@ = * @@v8@@ ; while ( -- @@v3@@ ) { * ( _QWORD * ) ( * @@v8@@ + Number L ) = @@v8@@ [ Number ] ; ++ @@v8@@ ; } * ( _QWORD * ) ( * @@v8@@ + Number L ) = Number L ; return @@v9@@ ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
unsigned __int64 __fastcall leave_dir ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 * @@v3@@ ; __int64 * @@v4@@ ; void * @@ptr@@ ; __int64 @@v6@@ [ Number ] ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v3@@ = ( __int64 * ) ( @@a2@@ + Number ) ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { @@v6@@ [ Number ] = * @@v3@@ ; @@v6@@ [ Number ] = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@ptr@@ = ( void * ) hash_delete ( * ( _QWORD * ) ( @@a1@@ + Number ) , @@v6@@ ) ; if ( ! @@ptr@@ ) abort ( ) ; free ( @@ptr@@ ) ; } else { @@v4@@ = * ( __int64 * * ) ( @@a2@@ + Number ) ; if ( @@v4@@ && @@v4@@ [ Number ] >= Number ) { if ( ! * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L ) ) abort ( ) ; if ( * * ( _QWORD * * ) ( @@a1@@ + Number ) == * ( _QWORD * ) ( @@a2@@ + Number ) && * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L ) == * @@v3@@ ) { * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L ) = @@v4@@ [ Number ] ; * * ( _QWORD * * ) ( @@a1@@ + Number ) = @@v4@@ [ Number ] ; } } } return __readfsqword ( Number ) ^ @@v7@@ ; }
__int64 __fastcall fts_safe_changedir ( __int64 @@a1@@ , __int64 @@a2@@ , int @@a3@@ , const char * @@a4@@ , int @@a5@@ , int @@a6@@ ) { bool @@v6@@ ; char * @@s1@@ ; char @@v10@@ ; unsigned int @@v11@@ ; int @@fildes@@ ; int @@v13@@ ; int @@v14@@ ; struct stat @@v15@@ ; unsigned __int64 @@v16@@ ; @@s1@@ = ( char * ) @@a4@@ ; @@v16@@ = __readfsqword ( Number ) ; @@v6@@ = @@a4@@ && ! strcmp ( @@a4@@ , off_17153 ) ; @@v10@@ = @@v6@@ ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number && @@a3@@ >= Number ) close ( @@a3@@ ) ; return Number L ; } if ( @@a3@@ < Number ) { if ( @@v10@@ ) { if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number && ( unsigned __int8 ) i_ring_empty ( @@a1@@ + Number ) != Number ) { @@v13@@ = i_ring_pop ( @@a1@@ + Number ) ; @@v10@@ = Number ; if ( @@v13@@ >= Number ) { @@a3@@ = @@v13@@ ; @@s1@@ = Number L ; } } } } @@fildes@@ = @@a3@@ ; if ( @@a3@@ < Number ) { @@fildes@@ = diropen ( @@a1@@ , ( int ) @@s1@@ , ( __int64 ) @@s1@@ , ( int ) @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( @@fildes@@ < Number ) return Number ; } if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) == Number && ( ! @@s1@@ || strcmp ( @@s1@@ , off_17153 ) ) ) goto LABEL_27 ; if ( ! ( unsigned int ) fstat ( @@fildes@@ , & @@v15@@ ) ) { if ( * ( _QWORD * ) ( @@a2@@ + Number ) != @@v15@@ . st_dev || * ( _QWORD * ) ( @@a2@@ + Number ) != @@v15@@ . st_ino ) { * __errno_location ( ) = Number ; @@v11@@ = Number ; goto LABEL_30 ; } LABEL_27 : if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { cwd_advance_fd ( @@a1@@ , @@fildes@@ , @@v10@@ == Number ) ; return Number L ; } @@v11@@ = fchdir ( @@fildes@@ ) ; goto LABEL_30 ; } @@v11@@ = Number ; LABEL_30 : if ( @@a3@@ < Number ) { @@v14@@ = * __errno_location ( ) ; close ( @@fildes@@ ) ; * __errno_location ( ) = @@v14@@ ; } return @@v11@@ ; }
_BOOL8 __fastcall process_files ( __int64 @@a1@@ , unsigned int @@a2@@ ) { char * @@v2@@ ; int * @@v3@@ ; char * @@v4@@ ; int * @@v5@@ ; bool @@v7@@ ; __int64 @@i@@ ; __int64 @@v9@@ ; @@v7@@ = Number ; for ( @@i@@ = xfts_open ( @@a1@@ , @@a2@@ , Number L ) ; ; @@v7@@ = ( @@v7@@ & ( unsigned __int8 ) process_file ( @@i@@ , @@v9@@ ) ) != Number ) { @@v9@@ = fts_read ( @@i@@ ) ; if ( ! @@v9@@ ) break ; } if ( * __errno_location ( ) ) { if ( force_silent != Number ) { @@v2@@ = gettext ( String ) ; @@v3@@ = __errno_location ( ) ; error ( Number , * @@v3@@ , @@v2@@ ) ; } @@v7@@ = Number ; } if ( ( unsigned int ) fts_close ( @@i@@ ) ) { @@v4@@ = gettext ( String ) ; @@v5@@ = __errno_location ( ) ; error ( Number , * @@v5@@ , @@v4@@ ) ; @@v7@@ = Number ; } return @@v7@@ ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_2070E8 ; @@v8@@ [ Number ] = qword_2070F0 ; @@v8@@ [ Number ] = qword_2070F8 ; @@v8@@ [ Number ] = qword_207100 ; @@v8@@ [ Number ] = qword_207108 ; @@v8@@ [ Number ] = qword_207110 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
__int64 __fastcall fts_set ( __int64 a1 , __int64 @@a2@@ , int @@a3@@ ) { __int64 @@result@@ ; if ( ! @@a3@@ || @@a3@@ == Number || @@a3@@ == Number || @@a3@@ == Number || @@a3@@ == Number ) { * ( _WORD * ) ( @@a2@@ + Number ) = @@a3@@ ; @@result@@ = Number L ; } else { * __errno_location ( ) = Number ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_207028 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
__int64 __fastcall fts_compare_ino ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; if ( * ( _QWORD * ) ( * ( _QWORD * ) @@a1@@ + Number L ) < * ( _QWORD * ) ( * ( _QWORD * ) @@a2@@ + Number L ) ) @@result@@ = Number ; else @@result@@ = * ( _QWORD * ) ( * ( _QWORD * ) @@a2@@ + Number L ) < * ( _QWORD * ) ( * ( _QWORD * ) @@a1@@ + Number L ) ; return @@result@@ ; }
__int64 __fastcall hash_clear ( __int64 @@a1@@ ) { __int64 @@result@@ ; _QWORD * @@i@@ ; _QWORD * @@j@@ ; _QWORD * @@v4@@ ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = ( _QWORD * ) @@i@@ [ Number ] ; @@j@@ ; @@j@@ = @@v4@@ ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@j@@ ) ; * @@j@@ = Number L ; @@v4@@ = ( _QWORD * ) @@j@@ [ Number ] ; @@j@@ [ Number ] = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@j@@ ; } if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@i@@ ) ; * @@i@@ = Number L ; @@i@@ [ Number ] = Number L ; } } * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; @@result@@ = @@a1@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; return @@result@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
__int64 __fastcall free_entry ( __int64 @@a1@@ , _QWORD * @@a2@@ ) { __int64 @@result@@ ; * @@a2@@ = Number L ; @@a2@@ [ Number ] = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@result@@ = @@a1@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall set_stat_type ( __int64 @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; int @@v3@@ ; switch ( @@a2@@ ) { case Number : @@v3@@ = Number ; break ; case Number : @@v3@@ = Number ; break ; case Number : @@v3@@ = Number ; break ; case Number : @@v3@@ = Number ; break ; case Number : @@v3@@ = Number ; break ; case Number : @@v3@@ = Number ; break ; case Number : @@v3@@ = Number ; break ; default : @@v3@@ = Number ; break ; } @@result@@ = @@a1@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@v3@@ ; return @@result@@ ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , off_B842 , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
int toupper ( int @@c@@ ) { return toupper ( @@c@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
__int64 __fastcall fts_compar ( __int64 @@a1@@ , __int64 @@a2@@ ) { return ( * ( __int64 ( __fastcall * * ) ( __int64 , __int64 ) ) ( * ( _QWORD * ) ( * ( _QWORD * ) @@a1@@ + Number L ) + Number L ) ) ( @@a1@@ , @@a2@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
void __fastcall free_dir ( __int64 @@a1@@ ) { if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) hash_free ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ; } else { free ( * ( void * * ) ( @@a1@@ + Number ) ) ; } }
char * __fastcall group_number ( char * @@a1@@ , size_t @@a2@@ , unsigned __int8 * @@a3@@ , const char * @@a4@@ ) { char * @@i@@ ; size_t @@v5@@ ; char * @@v6@@ ; unsigned __int8 @@v10@@ ; size_t @@v11@@ ; size_t @@v12@@ ; size_t @@v13@@ ; char @@dest@@ [ Number ] ; unsigned __int64 @@v15@@ ; @@v15@@ = __readfsqword ( Number ) ; @@v11@@ = Number ; @@v13@@ = strlen ( @@a4@@ ) ; @@v12@@ = @@a2@@ ; memcpy ( @@dest@@ , @@a1@@ , @@a2@@ ) ; for ( @@i@@ = & @@a1@@ [ @@a2@@ ] ; ; memcpy ( @@i@@ , @@a4@@ , @@v13@@ ) ) { @@v10@@ = * @@a3@@ ; if ( * @@a3@@ ) { if ( @@v10@@ > Number ) @@v5@@ = @@v12@@ ; else @@v5@@ = @@v10@@ ; @@v11@@ = @@v5@@ ; ++ @@a3@@ ; } if ( @@v12@@ < @@v11@@ ) @@v11@@ = @@v12@@ ; @@v6@@ = & @@i@@ [ - @@v11@@ ] ; @@v12@@ -= @@v11@@ ; memcpy ( @@v6@@ , & @@dest@@ [ @@v12@@ ] , @@v11@@ ) ; if ( ! @@v12@@ ) break ; @@i@@ = & @@v6@@ [ - @@v13@@ ] ; } return @@v6@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall fd_ring_clear ( __int64 @@a1@@ ) { __int64 @@result@@ ; int @@fd@@ ; while ( Number ) { @@result@@ = ( unsigned int ) i_ring_empty ( @@a1@@ ) ^ Number ; if ( ! ( _BYTE ) @@result@@ ) break ; @@fd@@ = i_ring_pop ( @@a1@@ ) ; if ( @@fd@@ >= Number ) close ( @@fd@@ ) ; } return @@result@@ ; }
__int64 __fastcall fts_palloc ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; unsigned __int64 @@v3@@ ; void * @@v4@@ ; @@v3@@ = * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ + Number ; if ( @@v3@@ >= * ( _QWORD * ) ( @@a1@@ + Number ) ) { * ( _QWORD * ) ( @@a1@@ + Number ) = @@v3@@ ; @@v4@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , * ( _QWORD * ) ( @@a1@@ + Number ) ) ; if ( @@v4@@ ) { * ( _QWORD * ) ( @@a1@@ + Number ) = @@v4@@ ; @@result@@ = Number L ; } else { free ( * ( void * * ) ( @@a1@@ + Number ) ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; @@result@@ = Number L ; } } else { free ( * ( void * * ) ( @@a1@@ + Number ) ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * __errno_location ( ) = Number ; @@result@@ = Number L ; } return @@result@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 __fastcall human_options ( char * @@a1@@ , int * @@a2@@ , _QWORD * @@a3@@ ) { unsigned int @@v5@@ ; @@v5@@ = humblock ( @@a1@@ , @@a3@@ , @@a2@@ ) ; if ( ! * @@a3@@ ) { * @@a3@@ = default_block_size ( ) ; @@v5@@ = Number ; } return @@v5@@ ; }
__int64 __fastcall opendirat ( int @@a1@@ , int @@a2@@ , __int64 a3 , __int64 a4 , int @@a5@@ , int @@a6@@ ) { int @@fd@@ ; _BYTE @@v8@@ [ Number ] ; @@fd@@ = openat_safer ( @@a1@@ , @@a2@@ , Number , @@a2@@ , @@a5@@ , @@a6@@ , @@a2@@ ) ; if ( @@fd@@ < Number ) return Number L ; set_cloexec_flag ( ( unsigned int ) @@fd@@ , Number L ) ; * ( _QWORD * ) & @@v8@@ [ Number ] = fdopendir ( @@fd@@ ) ; if ( ! * ( _QWORD * ) & @@v8@@ [ Number ] ) { * ( _QWORD * ) @@v8@@ = ( unsigned int ) * __errno_location ( ) ; close ( @@fd@@ ) ; * __errno_location ( ) = * ( _DWORD * ) @@v8@@ ; } return * ( _QWORD * ) & @@v8@@ [ Number ] ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
__int64 __fastcall select_plural ( __int64 @@a1@@ ) { return @@a1@@ ; }
__int64 __fastcall fts_safe_changedir ( __int64 @@a1@@ , __int64 @@a2@@ , int @@a3@@ , const char * @@a4@@ , int @@a5@@ , int @@a6@@ ) { bool @@v6@@ ; char * @@s1@@ ; char @@v10@@ ; unsigned int @@v11@@ ; int @@fildes@@ ; int @@v13@@ ; int @@v14@@ ; struct stat @@v15@@ ; unsigned __int64 @@v16@@ ; @@s1@@ = ( char * ) @@a4@@ ; @@v16@@ = __readfsqword ( Number ) ; @@v6@@ = @@a4@@ && ! strcmp ( @@a4@@ , String ) ; @@v10@@ = @@v6@@ ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number && @@a3@@ >= Number ) close ( @@a3@@ ) ; return Number L ; } if ( @@a3@@ < Number ) { if ( @@v10@@ ) { if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number && ( unsigned __int8 ) i_ring_empty ( @@a1@@ + Number ) != Number ) { @@v13@@ = i_ring_pop ( @@a1@@ + Number ) ; @@v10@@ = Number ; if ( @@v13@@ >= Number ) { @@a3@@ = @@v13@@ ; @@s1@@ = Number L ; } } } } @@fildes@@ = @@a3@@ ; if ( @@a3@@ < Number ) { @@fildes@@ = diropen ( @@a1@@ , ( int ) @@s1@@ , ( __int64 ) @@s1@@ , ( int ) @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( @@fildes@@ < Number ) return Number ; } if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) == Number && ( ! @@s1@@ || strcmp ( @@s1@@ , String ) ) ) goto LABEL_27 ; if ( ! ( unsigned int ) fstat ( @@fildes@@ , & @@v15@@ ) ) { if ( * ( _QWORD * ) ( @@a2@@ + Number ) != @@v15@@ . st_dev || * ( _QWORD * ) ( @@a2@@ + Number ) != @@v15@@ . st_ino ) { * __errno_location ( ) = Number ; @@v11@@ = Number ; goto LABEL_30 ; } LABEL_27 : if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { cwd_advance_fd ( @@a1@@ , @@fildes@@ , @@v10@@ == Number ) ; return Number L ; } @@v11@@ = fchdir ( @@fildes@@ ) ; goto LABEL_30 ; } @@v11@@ = Number ; LABEL_30 : if ( @@a3@@ < Number ) { @@v14@@ = * __errno_location ( ) ; close ( @@fildes@@ ) ; * __errno_location ( ) = @@v14@@ ; } return @@v11@@ ; }
__int64 __fastcall i_ring_init ( __int64 @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; int @@i@@ ; * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; * ( _DWORD * ) ( @@a1@@ + Number ) = Number ; * ( _DWORD * ) ( @@a1@@ + Number ) = Number ; for ( @@i@@ = Number ; @@i@@ <= Number ; ++ @@i@@ ) * ( _DWORD * ) ( @@a1@@ + Number L * @@i@@ ) = @@a2@@ ; @@result@@ = @@a1@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
int putchar_unlocked ( int @@c@@ ) { return putchar_unlocked ( @@c@@ ) ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; char * @@v3@@ ; char * @@v4@@ ; char * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; @@v1@@ = program_name ; if ( @@a1@@ ) { @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = gettext ( String ) ; printf ( @@v3@@ , @@v1@@ ) ; @@v4@@ = gettext ( String String String ) ; printf ( @@v4@@ ) ; @@v5@@ = gettext ( String ) ; printf ( @@v5@@ ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , String , String ) ; @@v7@@ = stdout ; @@v8@@ = gettext ( String ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = stdout ; @@v10@@ = gettext ( String ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
__int64 __fastcall fts_close ( __int64 @@a1@@ ) { _QWORD * @@v1@@ ; void * @@v2@@ ; _QWORD * @@v3@@ ; int @@v5@@ ; @@v5@@ = Number ; if ( * ( _QWORD * ) @@a1@@ ) { @@v1@@ = * ( _QWORD * * ) @@a1@@ ; while ( ( __int64 ) @@v1@@ [ Number ] >= Number ) { @@v2@@ = @@v1@@ ; if ( @@v1@@ [ Number ] ) @@v3@@ = ( _QWORD * ) @@v1@@ [ Number ] ; else @@v3@@ = ( _QWORD * ) @@v1@@ [ Number ] ; @@v1@@ = @@v3@@ ; free ( @@v2@@ ) ; } free ( @@v1@@ ) ; } if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) fts_lfree ( * ( void * * ) ( @@a1@@ + Number ) ) ; free ( * ( void * * ) ( @@a1@@ + Number ) ) ; free ( * ( void * * ) ( @@a1@@ + Number ) ) ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { if ( * ( int * ) ( @@a1@@ + Number ) >= Number && close ( * ( _DWORD * ) ( @@a1@@ + Number ) ) ) { LABEL_20 : @@v5@@ = * __errno_location ( ) ; goto LABEL_21 ; } } else if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) == Number ) { if ( fchdir ( * ( _DWORD * ) ( @@a1@@ + Number ) ) ) @@v5@@ = * __errno_location ( ) ; if ( close ( * ( _DWORD * ) ( @@a1@@ + Number ) ) && ! @@v5@@ ) goto LABEL_20 ; } LABEL_21 : fd_ring_clear ( @@a1@@ + Number ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) hash_free ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ; free_dir ( @@a1@@ ) ; free ( ( void * ) @@a1@@ ) ; if ( ! @@v5@@ ) return Number L ; * __errno_location ( ) = @@v5@@ ; return Number ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
struct __locale_struct * __fastcall c_strtod ( const char * @@a1@@ , char * * @@a2@@ ) { struct __locale_struct * @@result@@ ; @@result@@ = ( struct __locale_struct * ) c_locale ( ) ; if ( @@result@@ ) return COERCE_STRUCT_LOCALE_STRUCT_ ( strtod_l ( @@a1@@ , @@a2@@ , @@result@@ ) ) ; if ( @@a2@@ ) { @@result@@ = ( struct __locale_struct * ) @@a2@@ ; * @@a2@@ = ( char * ) @@a1@@ ; } return @@result@@ ; }
__int64 __fastcall imaxtostr ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = @@a1@@ ; @@v4@@ = @@a2@@ + Number ; * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; if ( @@a1@@ >= Number ) { do { * ( _BYTE * ) -- @@v4@@ = ( char ) @@v3@@ % Number + Number ; @@v3@@ /= Number L ; } while ( @@v3@@ ) ; } else { do { * ( _BYTE * ) -- @@v4@@ = Number - ( char ) @@v3@@ % Number ; @@v3@@ /= Number L ; } while ( @@v3@@ ) ; * ( _BYTE * ) -- @@v4@@ = Number ; } return @@v4@@ ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
unsigned __int64 __fastcall uptime ( __int64 @@a1@@ , unsigned int @@a2@@ ) { int * @@v2@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = __readfsqword ( Number ) ; if ( ( unsigned int ) read_utmp ( @@a1@@ , & @@v4@@ , & @@v5@@ , @@a2@@ ) ) { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , off_787A , @@a1@@ ) ; } print_uptime ( @@v4@@ , @@v5@@ ) ; return __readfsqword ( Number ) ^ @@v6@@ ; }
__int64 __fastcall fts_padjust ( __int64 @@a1@@ , _QWORD * @@a2@@ ) { _QWORD * @@v2@@ ; __int64 @@result@@ ; _QWORD * @@i@@ ; __int64 @@v6@@ ; @@v6@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; for ( @@i@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; @@i@@ ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { if ( ( _QWORD * ) @@i@@ [ Number ] != @@i@@ + Number ) @@i@@ [ Number ] = @@v6@@ + @@i@@ [ Number ] - @@i@@ [ Number ] ; @@i@@ [ Number ] = @@v6@@ ; } while ( Number ) { @@result@@ = @@a2@@ [ Number ] ; if ( @@result@@ < Number ) break ; if ( ( _QWORD * ) @@a2@@ [ Number ] != @@a2@@ + Number ) @@a2@@ [ Number ] = @@v6@@ + @@a2@@ [ Number ] - @@a2@@ [ Number ] ; @@a2@@ [ Number ] = @@v6@@ ; if ( @@a2@@ [ Number ] ) @@v2@@ = ( _QWORD * ) @@a2@@ [ Number ] ; else @@v2@@ = ( _QWORD * ) @@a2@@ [ Number ] ; @@a2@@ = @@v2@@ ; } return @@result@@ ; }
__int64 __fastcall hash_clear ( __int64 @@a1@@ ) { __int64 @@result@@ ; _QWORD * @@i@@ ; _QWORD * @@j@@ ; _QWORD * @@v4@@ ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = ( _QWORD * ) @@i@@ [ Number ] ; @@j@@ ; @@j@@ = @@v4@@ ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@j@@ ) ; * @@j@@ = Number L ; @@v4@@ = ( _QWORD * ) @@j@@ [ Number ] ; @@j@@ [ Number ] = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@j@@ ; } if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@i@@ ) ; * @@i@@ = Number L ; @@i@@ [ Number ] = Number L ; } } * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; @@result@@ = @@a1@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; return @@result@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
int __fastcall hash_print_statistics ( __int64 @@a1@@ , FILE * @@a2@@ ) { double @@v2@@ ; double @@v3@@ ; double @@v4@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v6@@ = hash_get_n_entries ( @@a1@@ ) ; @@v7@@ = hash_get_n_buckets ( @@a1@@ ) ; @@v8@@ = hash_get_n_buckets_used ( @@a1@@ ) ; @@v9@@ = hash_get_max_bucket_length ( @@a1@@ ) ; fprintf ( @@a2@@ , String , @@v6@@ ) ; fprintf ( @@a2@@ , String , @@v7@@ ) ; if ( @@v8@@ < Number ) @@v2@@ = ( double ) ( int ) ( @@v8@@ & Number | ( ( unsigned __int64 ) @@v8@@ >> Number ) ) + ( double ) ( int ) ( @@v8@@ & Number | ( ( unsigned __int64 ) @@v8@@ >> Number ) ) ; else @@v2@@ = ( double ) ( int ) @@v8@@ ; @@v3@@ = Number * @@v2@@ ; if ( @@v7@@ < Number ) @@v4@@ = ( double ) ( int ) ( @@v7@@ & Number | ( ( unsigned __int64 ) @@v7@@ >> Number ) ) + ( double ) ( int ) ( @@v7@@ & Number | ( ( unsigned __int64 ) @@v7@@ >> Number ) ) ; else @@v4@@ = ( double ) ( int ) @@v7@@ ; fprintf ( @@a2@@ , String , @@v8@@ , @@v3@@ / @@v4@@ ) ; return fprintf ( @@a2@@ , String , @@v9@@ ) ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
__int64 __fastcall transfer_entries ( __int64 @@a1@@ , __int64 @@a2@@ , char @@a3@@ ) { __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 * @@i@@ ; _QWORD * @@j@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; _QWORD * @@v11@@ ; _QWORD * @@v12@@ ; _QWORD * @@v13@@ ; _QWORD * @@v14@@ ; for ( @@i@@ = * ( __int64 * * ) @@a2@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a2@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = ( _QWORD * ) @@i@@ [ Number ] ; @@j@@ ; @@j@@ = @@v14@@ ) { @@v9@@ = * @@j@@ ; @@v3@@ = * ( _QWORD * ) @@a1@@ ; @@v11@@ = ( _QWORD * ) ( @@v3@@ + Number * ( * ( __int64 ( __fastcall * * ) ( _QWORD , _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@j@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@v11@@ >= * ( _QWORD * ) ( @@a1@@ + Number ) ) abort ( ) ; @@v14@@ = ( _QWORD * ) @@j@@ [ Number ] ; if ( * @@v11@@ ) { @@j@@ [ Number ] = @@v11@@ [ Number ] ; @@v11@@ [ Number ] = @@j@@ ; } else { * @@v11@@ = @@v9@@ ; ++ * ( _QWORD * ) ( @@a1@@ + Number ) ; free_entry ( @@a1@@ , @@j@@ ) ; } } @@v10@@ = * @@i@@ ; @@i@@ [ Number ] = Number L ; if ( ! @@a3@@ ) { @@v4@@ = * ( _QWORD * ) @@a1@@ ; @@v12@@ = ( _QWORD * ) ( @@v4@@ + Number * ( * ( __int64 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@v10@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@v12@@ >= * ( _QWORD * ) ( @@a1@@ + Number ) ) abort ( ) ; if ( * @@v12@@ ) { @@v13@@ = allocate_entry ( @@a1@@ ) ; if ( ! @@v13@@ ) return Number L ; * @@v13@@ = @@v10@@ ; @@v13@@ [ Number ] = @@v12@@ [ Number ] ; @@v12@@ [ Number ] = @@v13@@ ; } else { * @@v12@@ = @@v10@@ ; ++ * ( _QWORD * ) ( @@a1@@ + Number ) ; } * @@i@@ = Number L ; -- * ( _QWORD * ) ( @@a2@@ + Number ) ; } } } return Number L ; }
unsigned __int64 __fastcall hash_string ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ ) { unsigned __int64 @@v4@@ ; @@v4@@ = Number L ; while ( * @@a1@@ ) @@v4@@ = ( Number * @@v4@@ + ( unsigned __int8 ) * @@a1@@ ++ ) % @@a2@@ ; return @@v4@@ ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
unsigned __int64 __fastcall raw_hasher ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return rotr_sz ( @@a1@@ , Number ) % @@a2@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@v3@@ ; @@v3@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v3@@ ) xalloc_die ( ) ; return @@v3@@ ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( is_mul_ok ( @@a2@@ , * @@a1@@ ) ) { * @@a1@@ *= @@a2@@ ; @@result@@ = Number L ; } else { * @@a1@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
DIR * __fastcall opendir_safer ( const char * @@a1@@ ) { int @@v2@@ ; int @@fd@@ ; int @@v4@@ ; DIR * @@dirp@@ ; DIR * @@v6@@ ; @@dirp@@ = opendir ( @@a1@@ ) ; if ( @@dirp@@ ) { @@v2@@ = dirfd ( @@dirp@@ ) ; if ( @@v2@@ >= Number && @@v2@@ <= Number ) { @@fd@@ = dup_safer ( ( unsigned int ) @@v2@@ ) ; @@v6@@ = fdopendir ( @@fd@@ ) ; @@v4@@ = * __errno_location ( ) ; if ( ! @@v6@@ ) close ( @@fd@@ ) ; closedir ( @@dirp@@ ) ; * __errno_location ( ) = @@v4@@ ; @@dirp@@ = @@v6@@ ; } } return @@dirp@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall xfts_open ( const char * * @@a1@@ , int @@a2@@ , __int64 @@a3@@ ) { int @@v3@@ ; __int64 @@v5@@ ; @@v3@@ = @@a2@@ ; BYTE1 ( @@v3@@ ) = BYTE1 ( @@a2@@ ) | Number ; @@v5@@ = fts_open ( @@a1@@ , @@v3@@ , @@a3@@ ) ; if ( ! @@v5@@ ) { if ( * __errno_location ( ) == Number ) __assert_fail ( String , String , Number , String ) ; xalloc_die ( ) ; } return @@v5@@ ; }
__int64 __fastcall check_tuning ( __int64 @@a1@@ ) { __int64 @@v2@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( ( _UNKNOWN * ) @@v2@@ == & default_tuning ) return Number L ; if ( * ( float * ) ( @@v2@@ + Number ) > Number && ( float ) ( Number - Number ) > * ( float * ) ( @@v2@@ + Number ) && * ( float * ) ( @@v2@@ + Number ) > ( float ) ( Number + Number ) && * ( float * ) @@v2@@ >= Number && * ( float * ) ( @@v2@@ + Number ) > ( float ) ( * ( float * ) @@v2@@ + Number ) && * ( float * ) ( @@v2@@ + Number ) <= Number && * ( float * ) ( @@v2@@ + Number ) > ( float ) ( * ( float * ) @@v2@@ + Number ) ) { return Number L ; } * ( _QWORD * ) ( @@a1@@ + Number ) = & default_tuning ; return Number L ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
__int64 __fastcall mb_copy ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; if ( * ( _QWORD * ) @@a2@@ == @@a2@@ + Number ) { memcpy ( ( void * ) ( @@a1@@ + Number ) , ( const void * ) ( @@a2@@ + Number ) , * ( _QWORD * ) ( @@a2@@ + Number ) ) ; * ( _QWORD * ) @@a1@@ = @@a1@@ + Number ; } else { * ( _QWORD * ) @@a1@@ = * ( _QWORD * ) @@a2@@ ; } * ( _QWORD * ) ( @@a1@@ + Number ) = * ( _QWORD * ) ( @@a2@@ + Number ) ; * ( _BYTE * ) ( @@a1@@ + Number ) = * ( _BYTE * ) ( @@a2@@ + Number ) ; @@result@@ = * ( unsigned __int8 * ) ( @@a1@@ + Number ) ; if ( ( _BYTE ) @@result@@ ) { @@result@@ = @@a1@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = * ( _DWORD * ) ( @@a2@@ + Number ) ; } return @@result@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
void * __fastcall allocate_entry ( __int64 @@a1@@ ) { __int64 @@v2@@ ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return malloc ( Number ) ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = * ( _QWORD * ) ( @@v2@@ + Number ) ; return ( void * ) @@v2@@ ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_20A0C8 ; @@v8@@ [ Number ] = qword_20A0D0 ; @@v8@@ [ Number ] = qword_20A0D8 ; @@v8@@ [ Number ] = qword_20A0E0 ; @@v8@@ [ Number ] = qword_20A0E8 ; @@v8@@ [ Number ] = qword_20A0F0 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
__int64 __fastcall bkm_scale_by_power_0 ( unsigned __int64 * @@a1@@ , int @@a2@@ , int @@a3@@ ) { unsigned int @@i@@ ; for ( @@i@@ = Number ; @@a3@@ -- ; @@i@@ |= bkm_scale_0 ( @@a1@@ , @@a2@@ ) ) { ; } return @@i@@ ; }
char * __fastcall extract_trimmed_name ( __int64 @@a1@@ ) { char * @@i@@ ; char * @@dest@@ ; @@dest@@ = ( char * ) xmalloc ( Number L ) ; strncpy ( @@dest@@ , ( const char * ) ( @@a1@@ + Number ) , Number ) ; @@dest@@ [ Number ] = Number ; for ( @@i@@ = & @@dest@@ [ strlen ( @@dest@@ ) ] ; @@dest@@ < @@i@@ && * ( @@i@@ - Number ) == Number ; * @@i@@ = Number ) { -- @@i@@ ; } return @@dest@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ ) { return xmalloc ( @@a1@@ ) ; }
__int64 __fastcall dup_cloexec ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_20E038 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
__int64 __fastcall hash_find_entry ( __int64 @@a1@@ , __int64 @@a2@@ , _QWORD * @@a3@@ , char @@a4@@ ) { __int64 @@v4@@ ; __int64 @@result@@ ; __int64 @@v6@@ ; _QWORD * @@i@@ ; _QWORD * @@v10@@ ; __int64 @@v11@@ ; _QWORD * @@v12@@ ; __int64 @@v13@@ ; _QWORD * @@v14@@ ; @@v4@@ = * ( _QWORD * ) @@a1@@ ; @@v10@@ = ( _QWORD * ) ( @@v4@@ + Number * ( * ( __int64 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@a2@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@v10@@ >= * ( _QWORD * ) ( @@a1@@ + Number ) ) abort ( ) ; * @@a3@@ = @@v10@@ ; if ( ! * @@v10@@ ) return Number L ; if ( @@a2@@ == * @@v10@@ || ( * ( unsigned __int8 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@a2@@ , * @@v10@@ ) ) { @@v13@@ = * @@v10@@ ; if ( @@a4@@ ) { if ( @@v10@@ [ Number ] ) { @@v14@@ = ( _QWORD * ) @@v10@@ [ Number ] ; @@v6@@ = @@v14@@ [ Number ] ; * @@v10@@ = * @@v14@@ ; @@v10@@ [ Number ] = @@v6@@ ; free_entry ( @@a1@@ , @@v14@@ ) ; } else { * @@v10@@ = Number L ; } } @@result@@ = @@v13@@ ; } else { for ( @@i@@ = @@v10@@ ; ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { if ( ! @@i@@ [ Number ] ) return Number L ; if ( @@a2@@ == * ( _QWORD * ) @@i@@ [ Number ] || ( * ( unsigned __int8 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@a2@@ , * ( _QWORD * ) @@i@@ [ Number ] ) ) { break ; } } @@v11@@ = * ( _QWORD * ) @@i@@ [ Number ] ; if ( @@a4@@ ) { @@v12@@ = ( _QWORD * ) @@i@@ [ Number ] ; @@i@@ [ Number ] = @@v12@@ [ Number ] ; free_entry ( @@a1@@ , @@v12@@ ) ; } @@result@@ = @@v11@@ ; } return @@result@@ ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
_BOOL8 __fastcall c_isascii ( int @@a1@@ ) { return @@a1@@ >= Number && @@a1@@ <= Number ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall make_node_op_equals ( int @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; @@result@@ = xmalloc ( Number L ) ; * ( _BYTE * ) @@result@@ = Number ; * ( _BYTE * ) ( @@result@@ + Number ) = Number ; * ( _DWORD * ) ( @@result@@ + Number ) = Number ; * ( _DWORD * ) ( @@result@@ + Number ) = @@a1@@ ; * ( _DWORD * ) ( @@result@@ + Number ) = @@a2@@ ; * ( _BYTE * ) ( @@result@@ + Number ) = Number ; return @@result@@ ; }
_BOOL8 __fastcall c_isalpha ( int @@a1@@ ) { return ( int ) ( @@a1@@ & Number ) > Number && ( int ) ( @@a1@@ & Number ) <= Number ; }
__int64 __fastcall rpl_fcntl ( int @@a1@@ , int @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , __m128 @@a7@@ , __m128 @@a8@@ , __m128 @@a9@@ , __m128 @@a10@@ , __m128 @@a11@@ , __m128 @@a12@@ , __m128 @@a13@@ , __m128 @@a14@@ ) { int @@v14@@ ; int @@v15@@ ; int @@v16@@ ; int @@v18@@ ; int @@v19@@ ; int @@v20@@ ; int @@v21@@ ; __int64 @@v22@@ ; __int64 @@v23@@ ; __int64 @@v24@@ ; __int64 @@v25@@ ; __m128 @@v26@@ ; __m128 @@v27@@ ; __m128 @@v28@@ ; __m128 @@v29@@ ; __m128 @@v30@@ ; __m128 @@v31@@ ; __m128 @@v32@@ ; __m128 @@v33@@ ; @@v22@@ = @@a3@@ ; @@v23@@ = @@a4@@ ; @@v24@@ = @@a5@@ ; @@v25@@ = @@a6@@ ; @@v26@@ = @@a7@@ ; @@v27@@ = @@a8@@ ; @@v28@@ = @@a9@@ ; @@v29@@ = @@a10@@ ; @@v30@@ = @@a11@@ ; @@v31@@ = @@a12@@ ; @@v32@@ = @@a13@@ ; @@v33@@ = @@a14@@ ; if ( @@a2@@ != Number ) return ( unsigned int ) fcntl ( @@a1@@ , @@a2@@ , @@v22@@ ) ; @@v19@@ = @@v22@@ ; if ( have_dupfd_cloexec_2895 < Number ) { @@v18@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v22@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; } else { @@v18@@ = fcntl ( @@a1@@ , Number , ( unsigned int ) @@v22@@ ) ; if ( @@v18@@ < Number && * __errno_location ( ) == Number ) { @@v18@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v19@@ , @@v14@@ , @@v15@@ , @@v16@@ ) ; if ( @@v18@@ < Number ) return ( unsigned int ) @@v18@@ ; have_dupfd_cloexec_2895 = Number ; } else { have_dupfd_cloexec_2895 = Number ; } } if ( @@v18@@ >= Number && have_dupfd_cloexec_2895 == Number ) { @@v20@@ = fcntl ( @@v18@@ , Number ) ; if ( @@v20@@ < Number || fcntl ( @@v18@@ , Number , @@v20@@ | Number ) == Number ) { @@v21@@ = * __errno_location ( ) ; close ( @@v18@@ ) ; * __errno_location ( ) = @@v21@@ ; @@v18@@ = Number ; } } return ( unsigned int ) @@v18@@ ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
_BOOL8 __fastcall c_isblank ( int @@a1@@ ) { return @@a1@@ == Number || @@a1@@ == Number ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
_BOOL8 __fastcall c_isdigit ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
int tolower ( int @@c@@ ) { return tolower ( @@c@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
_BOOL8 __fastcall c_isupper ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
__int64 __fastcall c_tolower ( int @@a1@@ ) { __int64 @@result@@ ; if ( @@a1@@ <= Number || @@a1@@ > Number ) @@result@@ = ( unsigned int ) @@a1@@ ; else @@result@@ = ( unsigned int ) ( @@a1@@ + Number ) ; return @@result@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
void __fastcall __noreturn quit ( int @@a1@@ ) { cleanup ( ) ; print_stats ( ) ; process_signals ( ) ; exit ( @@a1@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
bool __fastcall multiple_bits_set ( int @@a1@@ ) { return ( @@a1@@ & ( @@a1@@ - Number ) ) != Number ; }
unsigned __int64 process_signals ( ) { int @@sig@@ ; sigset_t @@oset@@ ; unsigned __int64 @@v3@@ ; @@v3@@ = __readfsqword ( Number ) ; while ( interrupt_signal || info_signal_count ) { sigprocmask ( Number , & caught_signals , & @@oset@@ ) ; @@sig@@ = interrupt_signal ; if ( info_signal_count ) -- info_signal_count ; sigprocmask ( Number , & @@oset@@ , Number L ) ; if ( @@sig@@ ) cleanup ( ) ; print_stats ( ) ; if ( @@sig@@ ) raise ( @@sig@@ ) ; } return __readfsqword ( Number ) ^ @@v3@@ ; }
bool __fastcall is_basic_4 ( unsigned __int8 @@a1@@ ) { return ( ( is_basic_table [ @@a1@@ >> Number ] >> ( @@a1@@ & Number ) ) & Number ) != Number ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
int __fastcall stat ( char * @@filename@@ , struct stat * @@stat_buf@@ ) { return __xstat ( Number , @@filename@@ , @@stat_buf@@ ) ; }
unsigned __int64 install_signal_handlers ( ) { bool @@v1@@ ; struct sigaction @@v2@@ ; unsigned __int64 @@v3@@ ; @@v3@@ = __readfsqword ( Number ) ; @@v1@@ = getenv ( String ) == Number L ; sigemptyset ( & caught_signals ) ; if ( @@v1@@ ) { sigaction ( Number , Number L , & @@v2@@ ) ; if ( @@v2@@ . sa_handler != ( __sighandler_t ) ( ( char * ) & dword_0 + Number ) ) sigaddset ( & caught_signals , Number ) ; } sigaction ( Number , Number L , & @@v2@@ ) ; if ( @@v2@@ . sa_handler != ( __sighandler_t ) ( ( char * ) & dword_0 + Number ) ) sigaddset ( & caught_signals , Number ) ; @@v2@@ . sa_mask = caught_signals ; if ( sigismember ( & caught_signals , Number ) ) { @@v2@@ . sa_handler = ( __sighandler_t ) siginfo_handler ; @@v2@@ . sa_flags = Number ; sigaction ( Number , & @@v2@@ , Number L ) ; } if ( sigismember ( & caught_signals , Number ) ) { @@v2@@ . sa_handler = ( __sighandler_t ) interrupt_handler ; @@v2@@ . sa_flags = Number ; sigaction ( Number , & @@v2@@ , Number L ) ; } return __readfsqword ( Number ) ^ @@v3@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
size_t __fastcall iwrite ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { int @@v6@@ ; int @@v7@@ ; int @@v8@@ ; int @@v9@@ ; __int64 @@v10@@ ; char * @@v11@@ ; int * @@v12@@ ; int @@v13@@ ; size_t @@v16@@ ; __off_t @@offset@@ ; ssize_t @@v18@@ ; @@v16@@ = Number L ; if ( ( output_flags & Number ) != Number && @@a3@@ < output_blocksize ) { @@v6@@ = rpl_fcntl ( Number , Number , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; BYTE1 ( @@v6@@ ) &= Number ; if ( ( unsigned int ) rpl_fcntl ( Number , Number , @@v6@@ , @@v7@@ , @@v8@@ , @@v9@@ ) ) { @@v10@@ = quote ( output_file ) ; @@v11@@ = gettext ( String ) ; @@v12@@ = __errno_location ( ) ; error ( Number , * @@v12@@ , @@v11@@ , @@v10@@ ) ; } @@offset@@ = lseek ( Number , Number L , Number ) ; if ( @@offset@@ >= Number ) { posix_fadvise ( Number , @@offset@@ , Number L , Number ) ; ignore_value ( ) ; } @@v13@@ = conversions_mask ; BYTE1 ( @@v13@@ ) = BYTE1 ( conversions_mask ) | Number ; conversions_mask = @@v13@@ ; } while ( @@v16@@ < @@a3@@ ) { process_signals ( ) ; @@v18@@ = write ( @@a1@@ , ( const void * ) ( @@v16@@ + @@a2@@ ) , @@a3@@ - @@v16@@ ) ; if ( @@v18@@ >= Number ) { if ( ! @@v18@@ ) { * __errno_location ( ) = Number ; return @@v16@@ ; } @@v16@@ += @@v18@@ ; } else if ( * __errno_location ( ) != Number ) { return @@v16@@ ; } } return @@v16@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
__int64 __fastcall parse_symbols ( const char * @@a1@@ , _BYTE * @@a2@@ , const char * @@a3@@ ) { char * @@i@@ ; bool @@j@@ ; size_t @@v5@@ ; const char * @@v6@@ ; char * @@v7@@ ; char * @@s@@ ; unsigned int @@v11@@ ; _BYTE * @@v12@@ ; char * @@v13@@ ; @@s@@ = ( char * ) @@a1@@ ; @@v11@@ = Number ; for ( @@i@@ = strchr ( @@a1@@ , Number ) ; ; @@i@@ = strchr ( @@v13@@ + Number , Number ) ) { @@v13@@ = @@i@@ ; @@v12@@ = @@a2@@ ; for ( @@j@@ = operand_matches ( @@s@@ , @@a2@@ , Number ) ; ! @@j@@ || ! * ( ( _DWORD * ) @@v12@@ + Number ) ; @@j@@ = operand_matches ( @@s@@ , @@v12@@ , Number ) ) { if ( ! * @@v12@@ ) { if ( @@v13@@ ) @@v5@@ = @@v13@@ - @@s@@ ; else @@v5@@ = strlen ( @@s@@ ) ; @@v6@@ = ( const char * ) quotearg_n_style_mem ( Number L , Number L , @@s@@ , @@v5@@ ) ; @@v7@@ = gettext ( @@a3@@ ) ; error ( Number , Number , String , @@v7@@ , @@v6@@ ) ; usage ( Number ) ; } @@v12@@ += Number ; } @@v11@@ |= * ( ( _DWORD * ) @@v12@@ + Number ) ; if ( ! @@v13@@ ) break ; @@s@@ = @@v13@@ + Number ; } return @@v11@@ ; }
__int64 apply_translations ( ) { __int64 @@result@@ ; int @@i@@ ; int @@j@@ ; if ( ( conversions_mask & Number ) != Number ) translate_charset ( ( __int64 ) & ebcdic_to_ascii ) ; if ( ( conversions_mask & Number ) != Number ) { for ( @@i@@ = Number ; @@i@@ <= Number ; ++ @@i@@ ) trans_table [ @@i@@ ] = toupper ( trans_table [ @@i@@ ] ) ; translation_needed = Number ; } else if ( ( conversions_mask & Number ) != Number ) { for ( @@j@@ = Number ; @@j@@ <= Number ; ++ @@j@@ ) trans_table [ @@j@@ ] = tolower ( trans_table [ @@j@@ ] ) ; translation_needed = Number ; } if ( ( conversions_mask & Number ) != Number ) { translate_charset ( ( __int64 ) & ascii_to_ebcdic ) ; newline_character = Number ; @@result@@ = Number L ; space_character = Number ; } else { @@result@@ = conversions_mask & Number ; if ( ( conversions_mask & Number ) != Number ) { translate_charset ( ( __int64 ) & ascii_to_ibm ) ; newline_character = Number ; @@result@@ = Number L ; space_character = Number ; } } return @@result@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_2070E8 ; @@v4@@ [ Number ] = qword_2070F0 ; @@v4@@ [ Number ] = qword_2070F8 ; @@v4@@ [ Number ] = qword_207100 ; @@v4@@ [ Number ] = qword_207108 ; @@v4@@ [ Number ] = qword_207110 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
__int64 __fastcall advance_input_after_read_error ( unsigned __int64 @@a1@@ ) { __int64 @@v2@@ ; char * @@v3@@ ; char * @@v4@@ ; char * @@v5@@ ; __int64 @@v6@@ ; char * @@v7@@ ; int * @@v8@@ ; __off_t @@v9@@ ; unsigned __int64 @@v10@@ ; if ( input_seekable != Number ) { if ( input_seek_errno == Number ) return Number L ; * __errno_location ( ) = input_seek_errno ; } else { advance_input_offset ( @@a1@@ ) ; input_offset_overflow = ( ( unsigned __int8 ) input_offset_overflow | ( input_offset < Number ) ) != Number ; if ( input_offset_overflow ) { @@v2@@ = quote ( input_file ) ; @@v3@@ = gettext ( String ) ; error ( Number , Number , @@v3@@ , @@v2@@ ) ; return Number L ; } @@v9@@ = lseek ( Number , Number L , Number ) ; if ( @@v9@@ >= Number ) { if ( @@v9@@ == input_offset ) return Number L ; @@v10@@ = input_offset - @@v9@@ ; if ( input_offset - @@v9@@ < Number || @@a1@@ < @@v10@@ ) { @@v4@@ = gettext ( String ) ; error ( Number , Number , @@v4@@ ) ; } if ( skip_via_lseek ( input_file , Number , @@v10@@ , Number ) >= Number ) return Number L ; if ( ! * __errno_location ( ) ) { @@v5@@ = gettext ( String ) ; error ( Number , Number , @@v5@@ ) ; } } } @@v6@@ = quote ( input_file ) ; @@v7@@ = gettext ( String ) ; @@v8@@ = __errno_location ( ) ; error ( Number , * @@v8@@ , @@v7@@ , @@v6@@ ) ; return Number L ; }
__ino_t * __fastcall get_root_dev_ino ( __ino_t * @@a1@@ ) { struct stat @@v2@@ ; unsigned __int64 @@v3@@ ; @@v3@@ = __readfsqword ( Number ) ; if ( ( unsigned int ) lstat ( String , & @@v2@@ ) ) return Number L ; * @@a1@@ = @@v2@@ . st_ino ; @@a1@@ [ Number ] = @@v2@@ . st_dev ; return @@a1@@ ; }
__int64 __fastcall apply_suffix ( double * @@a1@@ , char @@a2@@ ) { int @@v3@@ ; if ( @@a2@@ == Number ) { @@v3@@ = Number ; goto LABEL_13 ; } if ( @@a2@@ > Number ) { if ( @@a2@@ == Number ) { @@v3@@ = Number ; goto LABEL_13 ; } if ( @@a2@@ != Number ) return Number L ; goto LABEL_8 ; } if ( ! @@a2@@ ) { LABEL_8 : @@v3@@ = Number ; goto LABEL_13 ; } if ( @@a2@@ != Number ) return Number L ; @@v3@@ = Number ; LABEL_13 : * @@a1@@ = ( double ) @@v3@@ * * @@a1@@ ; return Number L ; }
__int64 __fastcall copy_with_block ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 a3 , __int64 a4 , int @@a5@@ , int @@a6@@ ) { __int64 @@result@@ ; int @@v7@@ ; __int64 @@v8@@ ; int @@v9@@ ; __int64 @@v10@@ ; _BYTE * @@v11@@ ; __int64 @@i@@ ; unsigned __int64 @@j@@ ; @@v11@@ = ( _BYTE * ) @@a1@@ ; @@result@@ = @@a2@@ ; for ( @@i@@ = @@a2@@ ; @@i@@ ; -- @@i@@ ) { if ( * @@v11@@ == newline_character ) { @@result@@ = conversion_blocksize ; if ( col < ( unsigned __int64 ) conversion_blocksize ) { for ( @@j@@ = col ; ; ++ @@j@@ ) { @@result@@ = conversion_blocksize ; if ( @@j@@ >= conversion_blocksize ) break ; @@v7@@ = ( int ) obuf ; @@v8@@ = oc ++ ; * ( ( _BYTE * ) obuf + @@v8@@ ) = space_character ; if ( oc >= output_blocksize ) write_output ( @@a1@@ , @@a2@@ , oc , @@v7@@ , @@a5@@ , @@a6@@ ) ; } } col = Number L ; } else { if ( col == conversion_blocksize ) { ++ r_truncate ; } else if ( col < ( unsigned __int64 ) conversion_blocksize ) { @@v9@@ = ( int ) obuf ; @@v10@@ = oc ++ ; * ( ( _BYTE * ) obuf + @@v10@@ ) = * @@v11@@ ; if ( oc >= output_blocksize ) write_output ( @@a1@@ , @@a2@@ , oc , @@v9@@ , @@a5@@ , @@a6@@ ) ; } @@result@@ = ++ col ; } ++ @@v11@@ ; } return @@result@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ ) { return xmalloc ( @@a1@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
unsigned __int64 __fastcall set_fd_flags ( int @@a1@@ , int @@a2@@ , __int64 @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { int @@v6@@ ; int @@v7@@ ; int @@v8@@ ; __int64 @@v9@@ ; char * @@v10@@ ; int * @@v11@@ ; char @@v14@@ ; unsigned int @@v15@@ ; int @@v16@@ ; struct stat @@stat_buf@@ ; unsigned __int64 @@v18@@ ; @@v18@@ = __readfsqword ( Number ) ; if ( ( @@a2@@ & Number ) != Number ) { @@v16@@ = rpl_fcntl ( @@a1@@ , Number , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; @@v15@@ = @@a2@@ & Number | @@v16@@ ; @@v14@@ = Number ; if ( @@v16@@ >= Number ) { if ( @@v16@@ != @@v15@@ ) { if ( ( @@v15@@ & Number ) != Number ) { if ( ( unsigned int ) fstat ( @@a1@@ , & @@stat_buf@@ ) ) { @@v14@@ = Number ; } else if ( ( @@v15@@ & Number ) != Number && ( @@stat_buf@@ . st_mode & Number ) != Number ) { * __errno_location ( ) = Number ; @@v14@@ = Number ; } @@v15@@ &= Number ; } if ( @@v14@@ && @@v16@@ != @@v15@@ && ( unsigned int ) rpl_fcntl ( @@a1@@ , Number , @@v15@@ , @@v6@@ , @@v7@@ , @@v8@@ ) == Number ) { @@v14@@ = Number ; } } } else { @@v14@@ = Number ; } if ( @@v14@@ != Number ) { @@v9@@ = quote ( @@a3@@ ) ; @@v10@@ = gettext ( String ) ; @@v11@@ = __errno_location ( ) ; error ( Number , * @@v11@@ , @@v10@@ , @@v9@@ ) ; } } return __readfsqword ( Number ) ^ @@v18@@ ; }
__int64 __fastcall bkm_scale_by_power ( unsigned __int64 * @@a1@@ , int @@a2@@ , int @@a3@@ ) { unsigned int @@i@@ ; for ( @@i@@ = Number ; @@a3@@ -- ; @@i@@ |= bkm_scale ( @@a1@@ , @@a2@@ ) ) ; return @@i@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
__int64 __fastcall xtime_make ( __int64 @@a1@@ , __int64 @@a2@@ ) { return Number * @@a1@@ + @@a2@@ ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
_BOOL8 __fastcall cycle_warning_required ( __int64 @@a1@@ , __int64 @@a2@@ ) { return ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number && ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) == Number || ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number && ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number && * ( _QWORD * ) ( @@a2@@ + Number ) ; }
int tolower ( int @@c@@ ) { return tolower ( @@c@@ ) ; }
__int64 __fastcall cycle_check ( __int64 @@a1@@ , _QWORD * @@a2@@ ) { if ( * ( _DWORD * ) ( @@a1@@ + Number ) != Number ) __assert_fail ( String , String , Number , String ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) && @@a2@@ [ Number ] == * ( _QWORD * ) @@a1@@ && * @@a2@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ) { return Number L ; } if ( is_zero_or_power_of_two ( ++ * ( _QWORD * ) ( @@a1@@ + Number ) ) ) { if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = * @@a2@@ ; * ( _QWORD * ) @@a1@@ = @@a2@@ [ Number ] ; } return Number L ; }
char * __fastcall group_number ( char * @@a1@@ , size_t @@a2@@ , unsigned __int8 * @@a3@@ , const char * @@a4@@ ) { char * @@i@@ ; size_t @@v5@@ ; char * @@v6@@ ; unsigned __int8 @@v10@@ ; size_t @@v11@@ ; size_t @@v12@@ ; size_t @@v13@@ ; char @@dest@@ [ Number ] ; unsigned __int64 @@v15@@ ; @@v15@@ = __readfsqword ( Number ) ; @@v11@@ = Number ; @@v13@@ = strlen ( @@a4@@ ) ; @@v12@@ = @@a2@@ ; memcpy ( @@dest@@ , @@a1@@ , @@a2@@ ) ; for ( @@i@@ = & @@a1@@ [ @@a2@@ ] ; ; memcpy ( @@i@@ , @@a4@@ , @@v13@@ ) ) { @@v10@@ = * @@a3@@ ; if ( * @@a3@@ ) { if ( @@v10@@ > Number ) @@v5@@ = @@v12@@ ; else @@v5@@ = @@v10@@ ; @@v11@@ = @@v5@@ ; ++ @@a3@@ ; } if ( @@v12@@ < @@v11@@ ) @@v11@@ = @@v12@@ ; @@v6@@ = & @@i@@ [ - @@v11@@ ] ; @@v12@@ -= @@v11@@ ; memcpy ( @@v6@@ , & @@dest@@ [ @@v12@@ ] , @@v11@@ ) ; if ( ! @@v12@@ ) break ; @@i@@ = & @@v6@@ [ - @@v13@@ ] ; } return @@v6@@ ; }
__int64 __fastcall rpl_fcntl ( int @@a1@@ , int @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , __m128 @@a7@@ , __m128 @@a8@@ , __m128 @@a9@@ , __m128 @@a10@@ , __m128 @@a11@@ , __m128 @@a12@@ , __m128 @@a13@@ , __m128 @@a14@@ ) { int @@v14@@ ; int @@v15@@ ; int @@v16@@ ; int @@v18@@ ; int @@v19@@ ; int @@v20@@ ; int @@v21@@ ; __int64 @@v22@@ ; __int64 @@v23@@ ; __int64 @@v24@@ ; __int64 @@v25@@ ; __m128 @@v26@@ ; __m128 @@v27@@ ; __m128 @@v28@@ ; __m128 @@v29@@ ; __m128 @@v30@@ ; __m128 @@v31@@ ; __m128 @@v32@@ ; __m128 @@v33@@ ; @@v22@@ = @@a3@@ ; @@v23@@ = @@a4@@ ; @@v24@@ = @@a5@@ ; @@v25@@ = @@a6@@ ; @@v26@@ = @@a7@@ ; @@v27@@ = @@a8@@ ; @@v28@@ = @@a9@@ ; @@v29@@ = @@a10@@ ; @@v30@@ = @@a11@@ ; @@v31@@ = @@a12@@ ; @@v32@@ = @@a13@@ ; @@v33@@ = @@a14@@ ; if ( @@a2@@ != Number ) return ( unsigned int ) fcntl ( @@a1@@ , @@a2@@ , @@v22@@ ) ; @@v19@@ = @@v22@@ ; if ( have_dupfd_cloexec_2895 < Number ) { @@v18@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v22@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; } else { @@v18@@ = fcntl ( @@a1@@ , Number , ( unsigned int ) @@v22@@ ) ; if ( @@v18@@ < Number && * __errno_location ( ) == Number ) { @@v18@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v19@@ , @@v14@@ , @@v15@@ , @@v16@@ ) ; if ( @@v18@@ < Number ) return ( unsigned int ) @@v18@@ ; have_dupfd_cloexec_2895 = Number ; } else { have_dupfd_cloexec_2895 = Number ; } } if ( @@v18@@ >= Number && have_dupfd_cloexec_2895 == Number ) { @@v20@@ = fcntl ( @@v18@@ , Number ) ; if ( @@v20@@ < Number || fcntl ( @@v18@@ , Number , @@v20@@ | Number ) == Number ) { @@v21@@ = * __errno_location ( ) ; close ( @@v18@@ ) ; * __errno_location ( ) = @@v21@@ ; @@v18@@ = Number ; } } return ( unsigned int ) @@v18@@ ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_207028 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
__int64 __fastcall fwrite_lowcase ( FILE * @@a1@@ , unsigned __int8 * @@a2@@ , __int64 @@a3@@ ) { int @@v3@@ ; __int64 @@result@@ ; while ( Number ) { @@result@@ = @@a3@@ -- ; if ( ! @@result@@ ) break ; @@v3@@ = tolower ( * @@a2@@ ) ; fputc ( @@v3@@ , @@a1@@ ) ; ++ @@a2@@ ; } return @@result@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; FILE * @@v10@@ ; char * @@v11@@ ; if ( @@a1@@ ) { @@v1@@ = program_name ; @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = program_name ; @@v4@@ = program_name ; @@v5@@ = gettext ( String ) ; printf ( @@v5@@ , @@v4@@ , @@v3@@ ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; @@v8@@ = stdout ; @@v9@@ = gettext ( String ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = stdout ; @@v11@@ = gettext ( String ) ; fputs_unlocked ( @@v11@@ , @@v10@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
void * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
void * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * @@v4@@ ; void * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * @@v12@@ ; void * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == ( __int64 * ) & slotvec0 ; if ( slotvec == ( __int64 * ) & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = off_20E038 ; * @@v12@@ = ( __int64 ) slotvec0 ; @@v12@@ [ Number ] = ( __int64 ) @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = ( void * ) @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = @@v17@@ + Number ; if ( @@ptr@@ != & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( void * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = ( __int64 ) @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
int puts ( const char * @@s@@ ) { return puts ( @@s@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ ) { return xmalloc ( @@a1@@ ) ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
int __lxstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _lxstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_20A028 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall mkstemp_len ( __int64 @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , char @@a4@@ ) { __int64 @@v4@@ ; if ( @@a4@@ ) @@v4@@ = Number L ; else @@v4@@ = Number L ; return gen_tempname_len ( @@a1@@ , @@a2@@ , Number L , @@v4@@ , @@a3@@ ) ; }
void __fastcall argmatch_invalid ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { char * @@v3@@ ; __int64 @@v4@@ ; void * @@v5@@ ; char * @@format@@ ; if ( @@a3@@ == Number ) @@v3@@ = gettext ( String ) ; else @@v3@@ = gettext ( String ) ; @@format@@ = @@v3@@ ; @@v4@@ = quote_n ( Number , @@a1@@ ) ; @@v5@@ = quotearg_n_style ( Number , Number , @@a2@@ ) ; error ( Number , Number , @@format@@ , @@v5@@ , @@v4@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_20A0C8 ; @@v4@@ [ Number ] = qword_20A0D0 ; @@v4@@ [ Number ] = qword_20A0D8 ; @@v4@@ [ Number ] = qword_20A0E0 ; @@v4@@ [ Number ] = qword_20A0E8 ; @@v4@@ [ Number ] = qword_20A0F0 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
__int64 __fastcall _xargmatch_internal ( __int64 @@a1@@ , const char * @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ , void ( * @@a6@@ ) ( void ) ) { __int64 @@v11@@ ; @@v11@@ = argmatch ( @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; if ( @@v11@@ >= Number ) return @@v11@@ ; argmatch_invalid ( @@a1@@ , ( __int64 ) @@a2@@ , @@v11@@ ) ; argmatch_valid ( @@a3@@ , @@a4@@ , @@a5@@ ) ; @@a6@@ ( ) ; return Number ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
int __fastcall fstat ( int @@fildes@@ , struct stat * @@stat_buf@@ ) { return __fxstat ( Number , @@fildes@@ , @@stat_buf@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return xmalloc ( @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 __fastcall read_utmp ( const char * @@a1@@ , _QWORD * @@a2@@ , _QWORD * @@a3@@ , char @@a4@@ ) { __int64 @@v4@@ ; _QWORD * @@v5@@ ; struct utmpx * @@v6@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; __int64 @@v12@@ ; struct utmpx * @@v13@@ ; unsigned __int64 @@v14@@ ; @@v14@@ = __readfsqword ( Number ) ; @@v11@@ = Number L ; @@v10@@ = Number L ; @@v12@@ = Number L ; utmpxname ( @@a1@@ ) ; setutxent ( ) ; while ( Number ) { @@v13@@ = getutxent ( ) ; if ( ! @@v13@@ ) break ; if ( desirable_utmp_entry ( ( __int64 ) @@v13@@ , @@a4@@ ) ) { if ( @@v11@@ == @@v10@@ ) @@v12@@ = x2nrealloc ( @@v12@@ , & @@v10@@ , Number L ) ; @@v4@@ = @@v11@@ ++ ; @@v5@@ = ( _QWORD * ) ( Number * @@v4@@ + @@v12@@ ) ; @@v6@@ = @@v13@@ ; * @@v5@@ = * ( _QWORD * ) & @@v13@@ -> ut_type ; @@v5@@ [ Number ] = * ( _QWORD * ) & @@v6@@ -> __unused [ Number ] ; qmemcpy ( ( void * ) ( ( unsigned __int64 ) ( @@v5@@ + Number ) & Number ) , ( const void * ) ( ( char * ) @@v6@@ - ( ( char * ) @@v5@@ - ( ( unsigned __int64 ) ( @@v5@@ + Number ) & Number ) ) ) , Number L * ( ( ( ( _DWORD ) @@v5@@ - ( ( ( _DWORD ) @@v5@@ + Number ) & Number ) + Number ) & Number ) >> Number ) ) ; } } endutxent ( ) ; * @@a2@@ = @@v11@@ ; * @@a3@@ = @@v12@@ ; return Number L ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
int raise ( int @@sig@@ ) { return raise ( @@sig@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
__int64 __fastcall umaxtostr ( unsigned __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v4@@ ; @@v4@@ = @@a2@@ + Number ; * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; do { * ( _BYTE * ) -- @@v4@@ = @@a1@@ % Number + Number ; @@a1@@ /= Number ; } while ( @@a1@@ ) ; return @@v4@@ ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return xmalloc ( @@a1@@ , @@a2@@ , @@a3@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
FILE * __fastcall freopen_safer ( const char * @@a1@@ , const char * @@a2@@ , FILE * @@a3@@ ) { int @@v3@@ ; FILE * @@streama@@ ; char @@v7@@ ; char @@v8@@ ; char @@v9@@ ; int @@v10@@ ; @@v7@@ = Number ; @@v8@@ = Number ; @@v9@@ = Number ; @@v3@@ = fileno ( @@a3@@ ) ; if ( @@v3@@ != Number ) { if ( @@v3@@ != Number ) { if ( ! @@v3@@ ) goto LABEL_10 ; if ( dup2 ( Number , Number ) != Number ) @@v9@@ = Number ; } if ( dup2 ( Number , Number ) != Number ) @@v8@@ = Number ; } if ( dup2 ( Number , Number ) ) @@v7@@ = Number ; LABEL_10 : if ( @@v7@@ && ( unsigned __int8 ) protect_fd ( Number ) != Number ) { @@streama@@ = Number L ; } else if ( @@v8@@ && ( unsigned __int8 ) protect_fd ( Number ) != Number ) { @@streama@@ = Number L ; } else if ( @@v9@@ && ( unsigned __int8 ) protect_fd ( Number ) != Number ) { @@streama@@ = Number L ; } else { @@streama@@ = freopen ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } @@v10@@ = * __errno_location ( ) ; if ( @@v9@@ ) close ( Number ) ; if ( @@v8@@ ) close ( Number ) ; if ( @@v7@@ ) close ( Number ) ; if ( ! @@streama@@ ) * __errno_location ( ) = @@v10@@ ; return @@streama@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
int utmpxname ( const char * @@file@@ ) { return utmpxname ( @@file@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
struct tm * localtime ( const time_t * @@timer@@ ) { return localtime ( @@timer@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
__int64 __fastcall select_plural ( __int64 @@a1@@ ) { return @@a1@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
time_t time ( time_t * @@timer@@ ) { return time ( @@timer@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
unsigned __int8 * __fastcall translate_charset ( __int64 @@a1@@ ) { unsigned __int8 * @@result@@ ; int @@i@@ ; for ( @@i@@ = Number ; @@i@@ <= Number ; ++ @@i@@ ) { @@result@@ = trans_table ; trans_table [ @@i@@ ] = * ( _BYTE * ) ( trans_table [ @@i@@ ] + @@a1@@ ) ; } translation_needed = Number ; return @@result@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_20A0E8 ; @@v8@@ [ Number ] = qword_20A0F0 ; @@v8@@ [ Number ] = qword_20A0F8 ; @@v8@@ [ Number ] = qword_20A100 ; @@v8@@ [ Number ] = qword_20A108 ; @@v8@@ [ Number ] = qword_20A110 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
ssize_t __fastcall iread ( int @@a1@@ , void * @@a2@@ , size_t @@a3@@ ) { ssize_t @@v5@@ ; do { process_signals ( ) ; @@v5@@ = read ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } while ( @@v5@@ < Number && * __errno_location ( ) == Number ) ; return @@v5@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
int __cdecl __noreturn main ( int @@argc@@ , const char * * @@argv@@ , const char * * @@envp@@ ) { __int64 @@v3@@ ; char * @@v4@@ ; set_program_name ( * @@argv@@ , @@argv@@ , @@envp@@ ) ; setlocale ( Number , & shortopts ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; parse_long_options ( @@argc@@ , ( _DWORD ) @@argv@@ , ( unsigned int ) String , ( unsigned int ) String , ( _DWORD ) Version , ( unsigned int ) usage , String , String , String , Number L ) ; if ( getopt_long ( @@argc@@ , ( char * const * ) @@argv@@ , & shortopts , Number L , Number L ) != Number ) usage ( Number ) ; if ( @@argc@@ == optind ) { uptime ( ( __int64 ) String , Number ) ; } else { if ( @@argc@@ - optind != Number ) { @@v3@@ = quote ( @@argv@@ [ optind + Number ] ) ; @@v4@@ = gettext ( String ) ; error ( Number , Number , @@v4@@ , @@v3@@ ) ; usage ( Number ) ; } uptime ( ( __int64 ) @@argv@@ [ optind ] , Number ) ; } exit ( Number ) ; }
__int64 __fastcall decode_switches ( int @@a1@@ , char * const * @@a2@@ ) { const char * @@v2@@ ; const char * @@v3@@ ; __int64 @@v4@@ ; char * @@v5@@ ; unsigned int @@v7@@ ; int @@v8@@ ; int @@v9@@ ; @@v7@@ = Number ; if ( uname_mode == Number ) { @@v8@@ = getopt_long ( @@a1@@ , @@a2@@ , & locale , & arch_long_options , Number L ) ; if ( @@v8@@ != Number ) { if ( @@v8@@ != Number ) { if ( @@v8@@ == Number ) usage ( Number ) ; usage ( Number ) ; } if ( uname_mode == Number ) @@v2@@ = String ; else @@v2@@ = String ; version_etc ( ( _DWORD ) stdout , ( _DWORD ) @@v2@@ , ( unsigned int ) String , ( _DWORD ) Version , ( unsigned int ) String , ( unsigned int ) String , Number ) ; exit ( Number ) ; } @@v7@@ = Number ; } else { while ( Number ) { @@v9@@ = getopt_long ( @@a1@@ , @@a2@@ , String , & uname_long_options , Number L ) ; if ( @@v9@@ == Number ) break ; if ( @@v9@@ == Number ) { @@v7@@ |= Number ; } else if ( @@v9@@ > Number ) { if ( @@v9@@ == Number ) { @@v7@@ |= Number ; } else if ( @@v9@@ > Number ) { if ( @@v9@@ == Number ) { @@v7@@ |= Number ; } else { if ( @@v9@@ != Number ) goto LABEL_44 ; @@v7@@ |= Number ; } } else if ( @@v9@@ == Number ) { @@v7@@ |= Number ; } else { if ( @@v9@@ != Number ) goto LABEL_44 ; @@v7@@ |= Number ; } } else if ( @@v9@@ == Number ) { @@v7@@ = Number ; } else { if ( @@v9@@ <= Number ) { if ( @@v9@@ == Number ) { if ( uname_mode == Number ) @@v3@@ = String ; else @@v3@@ = String ; version_etc ( ( _DWORD ) stdout , ( _DWORD ) @@v3@@ , ( unsigned int ) String , ( _DWORD ) Version , ( unsigned int ) String , Number , ( char ) @@a2@@ ) ; exit ( Number ) ; } if ( @@v9@@ == Number ) usage ( Number ) ; LABEL_44 : usage ( Number ) ; } if ( @@v9@@ == Number ) { @@v7@@ |= Number ; } else { if ( @@v9@@ != Number ) goto LABEL_44 ; @@v7@@ |= Number ; } } } } if ( @@a1@@ != optind ) { @@v4@@ = quote ( @@a2@@ [ optind ] ) ; @@v5@@ = gettext ( String ) ; error ( Number , Number , @@v5@@ , @@v4@@ ) ; usage ( Number ) ; } return @@v7@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
ssize_t __fastcall iread_fullblock ( int @@a1@@ , char * @@a2@@ , size_t @@a3@@ ) { __int64 @@v6@@ ; ssize_t @@v7@@ ; @@v6@@ = Number L ; while ( @@a3@@ ) { @@v7@@ = iread ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( @@v7@@ < Number ) return @@v7@@ ; if ( ! @@v7@@ ) break ; @@v6@@ += @@v7@@ ; @@a2@@ += @@v7@@ ; @@a3@@ -= @@v7@@ ; } return @@v6@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
__int64 __fastcall fwrite_uppcase ( FILE * @@a1@@ , unsigned __int8 * @@a2@@ , __int64 @@a3@@ ) { int @@v3@@ ; __int64 @@result@@ ; while ( Number ) { @@result@@ = @@a3@@ -- ; if ( ! @@result@@ ) break ; @@v3@@ = toupper ( * @@a2@@ ) ; fputc ( @@v3@@ , @@a1@@ ) ; ++ @@a2@@ ; } return @@result@@ ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
_BOOL8 __fastcall operand_matches ( char * @@a1@@ , _BYTE * @@a2@@ , char @@a3@@ ) { char * @@v3@@ ; char @@v4@@ ; _BYTE * @@v5@@ ; while ( * @@a2@@ ) { @@v3@@ = @@a1@@ ++ ; @@v4@@ = * @@v3@@ ; @@v5@@ = @@a2@@ ++ ; if ( @@v4@@ != * @@v5@@ ) return Number L ; } return ! * @@a1@@ || @@a3@@ == * @@a1@@ ; }
_QWORD * __fastcall randint_new ( __int64 @@a1@@ , __int64 @@a2@@ ) { _QWORD * @@result@@ ; @@result@@ = xmalloc ( Number , @@a2@@ ) ; * @@result@@ = @@a1@@ ; @@result@@ [ Number ] = Number L ; @@result@@ [ Number ] = @@result@@ [ Number ] ; return @@result@@ ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_2060C8 ; @@v4@@ [ Number ] = qword_2060D0 ; @@v4@@ [ Number ] = qword_2060D8 ; @@v4@@ [ Number ] = qword_2060E0 ; @@v4@@ [ Number ] = qword_2060E8 ; @@v4@@ [ Number ] = qword_2060F0 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_207038 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
void __fastcall randint_free ( void * @@a1@@ ) { memset ( @@a1@@ , Number , Number ) ; free ( @@a1@@ ) ; }
unsigned __int8 * __fastcall translate_buffer ( unsigned __int8 * @@a1@@ , __int64 @@a2@@ ) { unsigned __int8 * @@result@@ ; unsigned __int8 @@v3@@ ; unsigned __int8 * @@v4@@ ; @@result@@ = @@a1@@ ; @@v4@@ = @@a1@@ ; while ( @@a2@@ ) { @@v3@@ = trans_table [ ( unsigned __int8 ) to_uchar ( * @@v4@@ ) ] ; @@result@@ = @@v4@@ ; * @@v4@@ = @@v3@@ ; -- @@a2@@ ; ++ @@v4@@ ; } return @@result@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
void __fastcall __noreturn randread_error ( __int64 @@a1@@ ) { __int64 * @@v1@@ ; const char * @@v2@@ ; char * @@v3@@ ; int * @@v4@@ ; if ( @@a1@@ ) { @@v1@@ = quotearg_colon ( @@a1@@ ) ; if ( * __errno_location ( ) ) @@v2@@ = String ; else @@v2@@ = String ; @@v3@@ = gettext ( @@v2@@ ) ; @@v4@@ = __errno_location ( ) ; error ( exit_failure , * @@v4@@ , @@v3@@ , @@v1@@ ) ; } abort ( ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_2070C8 ; @@v4@@ [ Number ] = qword_2070D0 ; @@v4@@ [ Number ] = qword_2070D8 ; @@v4@@ [ Number ] = qword_2070E0 ; @@v4@@ [ Number ] = qword_2070E8 ; @@v4@@ [ Number ] = qword_2070F0 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
__off_t __fastcall skip_via_lseek ( __int64 @@a1@@ , int @@a2@@ , __off_t @@a3@@ , int @@a4@@ ) { __int64 @@v4@@ ; char * @@v5@@ ; bool @@v9@@ ; __off_t @@v10@@ ; char @@v11@@ [ Number ] ; __int64 @@v12@@ ; int @@v13@@ ; int @@v14@@ ; __int64 @@v15@@ [ Number ] ; int @@v16@@ ; int @@v17@@ ; unsigned __int64 @@v18@@ ; @@v18@@ = __readfsqword ( Number ) ; @@v9@@ = ioctl ( @@a2@@ , Number , @@v11@@ ) == Number ; @@v10@@ = lseek ( @@a2@@ , @@a3@@ , @@a4@@ ) ; if ( @@v10@@ >= Number && @@v9@@ && ! ioctl ( @@a2@@ , Number , @@v15@@ ) && @@v12@@ == @@v15@@ [ Number ] && @@v13@@ == @@v16@@ && @@v14@@ == @@v17@@ ) { @@v4@@ = @@v15@@ [ Number ] ; @@v5@@ = gettext ( String String ) ; error ( Number , Number , @@v5@@ , @@a1@@ , @@v4@@ ) ; * __errno_location ( ) = Number ; @@v10@@ = Number ; } return @@v10@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_20A028 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
size_t __fastcall readsource ( __int64 @@a1@@ , char * @@a2@@ , size_t @@a3@@ ) { size_t @@result@@ ; int @@v4@@ ; int @@v7@@ ; size_t @@v8@@ ; while ( Number ) { @@v8@@ = fread_unlocked ( @@a2@@ , Number , @@a3@@ , * ( FILE * * ) @@a1@@ ) ; @@v7@@ = * __errno_location ( ) ; @@a2@@ += @@v8@@ ; @@result@@ = @@v8@@ ; @@a3@@ -= @@v8@@ ; if ( ! @@a3@@ ) break ; if ( ferror_unlocked ( * ( FILE * * ) @@a1@@ ) ) @@v4@@ = @@v7@@ ; else @@v4@@ = Number ; * __errno_location ( ) = @@v4@@ ; ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@a1@@ + Number ) ) ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ; } return @@result@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
unsigned __int64 __fastcall copy_with_unblock ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 a3 , __int64 a4 , int @@a5@@ , int @@a6@@ ) { unsigned __int64 @@v6@@ ; int @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; int @@v10@@ ; __int64 @@v11@@ ; __int64 @@v12@@ ; unsigned __int64 @@result@@ ; char @@v14@@ ; unsigned __int64 @@i@@ ; for ( @@i@@ = Number L ; ; ++ @@i@@ ) { @@result@@ = @@i@@ ; if ( @@i@@ >= @@a2@@ ) break ; @@v14@@ = * ( _BYTE * ) ( @@a1@@ + @@i@@ ) ; @@v6@@ = col ++ ; if ( @@v6@@ >= conversion_blocksize ) { pending_spaces_6032 = Number L ; col = Number L ; -- @@i@@ ; @@v7@@ = ( int ) obuf ; @@v8@@ = oc ++ ; * ( ( _BYTE * ) obuf + @@v8@@ ) = newline_character ; @@v9@@ = oc ; if ( oc < output_blocksize ) continue ; LABEL_12 : write_output ( @@a1@@ , @@a2@@ , @@v9@@ , @@v7@@ , @@a5@@ , @@a6@@ ) ; continue ; } if ( @@v14@@ == space_character ) { ++ pending_spaces_6032 ; continue ; } while ( pending_spaces_6032 ) { @@v10@@ = ( int ) obuf ; @@v11@@ = oc ++ ; * ( ( _BYTE * ) obuf + @@v11@@ ) = space_character ; if ( oc >= output_blocksize ) write_output ( @@a1@@ , @@a2@@ , oc , @@v10@@ , @@a5@@ , @@a6@@ ) ; -- pending_spaces_6032 ; } @@v7@@ = ( int ) obuf ; @@v12@@ = oc ++ ; * ( ( _BYTE * ) obuf + @@v12@@ ) = @@v14@@ ; @@v9@@ = oc ; if ( oc >= output_blocksize ) goto LABEL_12 ; } return @@result@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , off_B016 , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
int fdatasync ( int @@fildes@@ ) { return fdatasync ( @@fildes@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
int __fastcall randread_free ( FILE * * @@a1@@ ) { int @@result@@ ; FILE * @@stream@@ ; @@stream@@ = * @@a1@@ ; memset ( @@a1@@ , Number , Number ) ; free ( @@a1@@ ) ; if ( @@stream@@ ) @@result@@ = fclose ( @@stream@@ ) ; else @@result@@ = Number ; return @@result@@ ; }
__int64 __fastcall human_options ( char * @@a1@@ , int * @@a2@@ , uintmax_t * @@a3@@ ) { unsigned int @@v5@@ ; @@v5@@ = humblock ( @@a1@@ , @@a3@@ , @@a2@@ ) ; if ( ! * @@a3@@ ) { * @@a3@@ = default_block_size ( ) ; @@v5@@ = Number ; } return @@v5@@ ; }
int clock_gettime ( clockid_t @@clock_id@@ , struct timespec * @@tp@@ ) { return clock_gettime ( @@clock_id@@ , @@tp@@ ) ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 __fastcall xtime_make ( __int64 @@a1@@ , __int64 @@a2@@ ) { return Number * @@a1@@ + @@a2@@ ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
int uname ( struct utsname * @@name@@ ) { return uname ( @@name@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
int sigemptyset ( sigset_t * @@set@@ ) { return sigemptyset ( @@set@@ ) ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
int fsync ( int @@fd@@ ) { return fsync ( @@fd@@ ) ; }
__int64 gethrxtime ( ) { struct timespec @@tp@@ ; unsigned __int64 @@v2@@ ; @@v2@@ = __readfsqword ( Number ) ; if ( clock_gettime ( Number , & @@tp@@ ) ) gettime ( & @@tp@@ ) ; return xtime_make ( @@tp@@ . tv_sec , @@tp@@ . tv_nsec ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
int fileno ( FILE * @@stream@@ ) { return fileno ( @@stream@@ ) ; }
__int64 __fastcall dup_safer ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
int __fastcall print_element ( const char * @@a1@@ ) { if ( printed_6183 ) putchar_unlocked ( Number ) ; printed_6183 = Number ; return fputs_unlocked ( @@a1@@ , stdout ) ; }
int __fxstat ( int @@ver@@ , int @@fildes@@ , struct stat * @@stat_buf@@ ) { return _fxstat ( @@ver@@ , @@fildes@@ , @@stat_buf@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
void * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
unsigned __int64 __fastcall diagnose_leading_hyphen ( int @@a1@@ , __int64 * @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; char * @@v5@@ ; int @@i@@ ; char * @@filename@@ ; struct stat @@v9@@ ; unsigned __int64 @@v10@@ ; @@v10@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number ; @@i@@ < @@a1@@ ; ++ @@i@@ ) { @@filename@@ = ( char * ) @@a2@@ [ @@i@@ ] ; if ( * @@filename@@ == Number && @@filename@@ [ Number ] && ! ( unsigned int ) lstat ( @@filename@@ , & @@v9@@ ) ) { @@v2@@ = quote ( @@filename@@ ) ; @@v3@@ = quotearg_n_style ( Number L , Number L , @@filename@@ ) ; @@v4@@ = * @@a2@@ ; @@v5@@ = gettext ( String ) ; fprintf ( stderr , @@v5@@ , @@v4@@ , @@v3@@ , @@v2@@ ) ; return __readfsqword ( Number ) ^ @@v10@@ ; } } return __readfsqword ( Number ) ^ @@v10@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
void * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall write_output ( __int64 a1 , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { __int64 @@v6@@ ; char * @@v7@@ ; int * @@v8@@ ; __int64 @@result@@ ; size_t @@v10@@ ; @@v10@@ = iwrite ( Number , ( __int64 ) obuf , output_blocksize , @@a4@@ , @@a5@@ , @@a6@@ ) ; w_bytes += @@v10@@ ; if ( @@v10@@ != output_blocksize ) { @@v6@@ = quote ( output_file ) ; @@v7@@ = gettext ( String ) ; @@v8@@ = __errno_location ( ) ; error ( Number , * @@v8@@ , @@v7@@ , @@v6@@ ) ; if ( @@v10@@ ) ++ w_partial ; quit ( Number ) ; } @@result@@ = ++ w_full ; oc = Number L ; return @@result@@ ; }
void * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
void * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
int dirfd ( DIR * @@dirp@@ ) { return dirfd ( @@dirp@@ ) ; }
__int64 __fastcall swab_buffer ( __int64 @@a1@@ , _QWORD * @@a2@@ ) { __int64 @@v3@@ ; _BYTE * @@v4@@ ; __int64 @@i@@ ; @@v3@@ = @@a1@@ ; if ( char_is_saved ) { @@v3@@ = @@a1@@ - Number ; * ( _BYTE * ) ( @@a1@@ - Number ) = saved_char ; ++ * @@a2@@ ; char_is_saved = Number ; } if ( ( * @@a2@@ & Number L ) != Number ) { saved_char = * ( _BYTE * ) ( -- * @@a2@@ + @@v3@@ ) ; char_is_saved = Number ; } @@v4@@ = ( _BYTE * ) ( * @@a2@@ + @@v3@@ ) ; for ( @@i@@ = * @@a2@@ >> Number ; @@i@@ ; -- @@i@@ ) { * @@v4@@ = * ( @@v4@@ - Number ) ; @@v4@@ -= Number ; } return @@v3@@ + Number ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
_BOOL8 __fastcall nonexistent_file_errno ( int @@a1@@ ) { return @@a1@@ == Number || @@a1@@ == Number ; }
int __fxstat ( int @@ver@@ , int @@fildes@@ , struct stat * @@stat_buf@@ ) { return _fxstat ( @@ver@@ , @@fildes@@ , @@stat_buf@@ ) ; }
void * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_20E368 ; @@v8@@ [ Number ] = qword_20E370 ; @@v8@@ [ Number ] = qword_20E378 ; @@v8@@ [ Number ] = qword_20E380 ; @@v8@@ [ Number ] = qword_20E388 ; @@v8@@ [ Number ] = qword_20E390 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 __fastcall copy_simple ( char * @@a1@@ , size_t @@a2@@ ) { size_t @@v2@@ ; __int64 @@v3@@ ; char * @@v4@@ ; int @@v5@@ ; int @@v6@@ ; int @@v7@@ ; __int64 @@result@@ ; size_t @@n@@ ; do { @@v2@@ = output_blocksize - oc ; if ( @@a2@@ <= output_blocksize - oc ) @@v2@@ = @@a2@@ ; @@n@@ = @@v2@@ ; @@v3@@ = ( __int64 ) @@a1@@ ; @@v4@@ = ( char * ) obuf + oc ; memcpy ( ( char * ) obuf + oc , @@a1@@ , @@v2@@ ) ; @@a2@@ -= @@n@@ ; @@a1@@ += @@n@@ ; oc += @@n@@ ; @@result@@ = output_blocksize ; if ( oc >= output_blocksize ) @@result@@ = write_output ( ( __int64 ) @@v4@@ , @@v3@@ , oc , @@v5@@ , @@v6@@ , @@v7@@ ) ; } while ( @@a2@@ ) ; return @@result@@ ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
__int64 __fastcall mark_ancestor_dirs ( __int64 @@a1@@ ) { __int64 @@result@@ ; _QWORD * @@i@@ ; for ( @@i@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { @@result@@ = @@i@@ [ Number ] ; if ( @@result@@ < Number ) break ; @@result@@ = @@i@@ [ Number ] ; if ( @@result@@ ) break ; @@i@@ [ Number ] = Number L ; } return @@result@@ ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
unsigned __int64 __fastcall describe_change ( __int64 @@a1@@ , unsigned int @@a2@@ , int @@a3@@ ) { __int64 @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; const char * @@format@@ ; char @@v9@@ ; _BYTE @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v11@@ = __readfsqword ( Number ) ; if ( @@a3@@ ) { strmode ( @@a2@@ , & @@v9@@ ) ; @@v10@@ [ Number ] = Number ; switch ( @@a3@@ ) { case Number : @@format@@ = gettext ( String ) ; break ; case Number : @@format@@ = gettext ( String ) ; break ; case Number : @@format@@ = gettext ( String ) ; break ; default : abort ( ) ; } @@v5@@ = quote ( @@a1@@ ) ; printf ( @@format@@ , @@v5@@ , @@a2@@ & Number , @@v10@@ ) ; } else { @@v3@@ = quote ( @@a1@@ ) ; @@v4@@ = gettext ( String ) ; printf ( @@v4@@ , @@v3@@ ) ; } return __readfsqword ( Number ) ^ @@v11@@ ; }
__int64 __fastcall argmatch_to_argument ( const void * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; ++ @@i@@ ) { if ( ! memcmp ( @@a1@@ , ( const void * ) ( @@i@@ * @@a4@@ + @@a3@@ ) , @@a4@@ ) ) return * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; } return Number L ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
__int64 __fastcall argmatch_to_argument ( const void * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; ++ @@i@@ ) { if ( ! memcmp ( @@a1@@ , ( const void * ) ( @@i@@ * @@a4@@ + @@a3@@ ) , @@a4@@ ) ) return * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; } return Number L ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
__int64 gethrxtime ( ) { struct timespec @@tp@@ ; unsigned __int64 @@v2@@ ; @@v2@@ = __readfsqword ( Number ) ; if ( clock_gettime ( Number , & @@tp@@ ) ) gettime ( & @@tp@@ ) ; return xtime_make ( @@tp@@ . tv_sec , @@tp@@ . tv_nsec ) ; }
__int64 __fastcall clear_ungetc_buffer_preserving_position ( _DWORD * @@a1@@ ) { __int64 @@result@@ ; @@result@@ = * @@a1@@ & Number ; if ( ( _DWORD ) @@result@@ ) @@result@@ = rpl_fseeko ( @@a1@@ , Number L , Number L ) ; return @@result@@ ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
_BOOL8 __fastcall AD_compare ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { return @@a1@@ [ Number ] == @@a2@@ [ Number ] && * @@a1@@ == * @@a2@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 default_block_size ( ) { __int64 @@result@@ ; if ( getenv ( String ) ) @@result@@ = Number L ; else @@result@@ = Number L ; return @@result@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
__int64 __fastcall fd_ring_clear ( __int64 @@a1@@ ) { __int64 @@result@@ ; int @@fd@@ ; while ( Number ) { @@result@@ = ( unsigned int ) i_ring_empty ( @@a1@@ ) ^ Number ; if ( ! ( _BYTE ) @@result@@ ) break ; @@fd@@ = i_ring_pop ( @@a1@@ ) ; if ( @@fd@@ >= Number ) close ( @@fd@@ ) ; } return @@result@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return xmalloc ( @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall setup_dir ( __int64 @@a1@@ ) { if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { * ( _QWORD * ) ( @@a1@@ + Number ) = hash_initialize ( Number L , Number L , AD_hash , AD_compare , & free ) ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; } else { * ( _QWORD * ) ( @@a1@@ + Number ) = malloc ( Number ) ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; cycle_check_init ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ; } return Number L ; }
__int64 __fastcall cwd_advance_fd ( __int64 @@a1@@ , int @@a2@@ , char @@a3@@ ) { __int64 @@result@@ ; int @@v4@@ ; int @@fd@@ ; @@v4@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; if ( @@v4@@ == @@a2@@ && @@v4@@ != Number ) abort ( ) ; if ( @@a3@@ ) { @@fd@@ = i_ring_push ( @@a1@@ + Number , ( unsigned int ) @@v4@@ ) ; if ( @@fd@@ >= Number ) close ( @@fd@@ ) ; } else if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) == Number && @@v4@@ >= Number ) { close ( @@v4@@ ) ; } @@result@@ = @@a1@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
int __cdecl __noreturn main ( int @@argc@@ , const char * * @@argv@@ , const char * * @@envp@@ ) { __int64 @@v3@@ ; char * @@v4@@ ; unsigned int @@v5@@ ; set_program_name ( * @@argv@@ , @@argv@@ , @@envp@@ ) ; setlocale ( Number , & shortopts ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; parse_long_options ( @@argc@@ , ( _DWORD ) @@argv@@ , ( unsigned int ) String , ( unsigned int ) String , ( _DWORD ) Version , ( unsigned int ) usage , String , Number L ) ; if ( getopt_long ( @@argc@@ , ( char * const * ) @@argv@@ , & shortopts , Number L , Number L ) != Number ) usage ( Number ) ; if ( @@argc@@ > optind ) { @@v3@@ = quote ( @@argv@@ [ optind ] ) ; @@v4@@ = gettext ( String ) ; error ( Number , Number , @@v4@@ , @@v3@@ ) ; usage ( Number ) ; } @@v5@@ = gethostid ( ) ; printf ( String , @@v5@@ ) ; exit ( Number ) ; }
__int64 __fastcall humblock ( char * @@a1@@ , uintmax_t * @@a2@@ , int * @@a3@@ ) { char * @@v5@@ ; int @@v6@@ ; int @@v7@@ ; unsigned int @@v8@@ ; char * @@v9@@ [ Number ] ; @@v5@@ = @@a1@@ ; @@v9@@ [ Number ] = ( char * ) __readfsqword ( Number ) ; @@v6@@ = Number ; if ( @@a1@@ || ( @@v5@@ = getenv ( String ) ) != Number L || ( @@v5@@ = getenv ( String ) ) != Number L ) { if ( * @@v5@@ == Number ) { @@v6@@ = Number ; ++ @@v5@@ ; } @@v7@@ = argmatch ( @@v5@@ , & block_size_args , block_size_opts , Number L ) ; if ( @@v7@@ < Number ) { @@v8@@ = xstrtoumax ( @@v5@@ , @@v9@@ , Number , @@a2@@ , String ) ; if ( @@v8@@ ) { * @@a3@@ = Number ; return @@v8@@ ; } while ( * @@v5@@ <= Number || * @@v5@@ > Number ) { if ( @@v5@@ == @@v9@@ [ Number ] ) { @@v6@@ |= Number ; if ( * ( @@v9@@ [ Number ] - Number ) == Number ) @@v6@@ |= Number ; if ( * ( @@v9@@ [ Number ] - Number ) != Number || * ( @@v9@@ [ Number ] - Number ) == Number ) @@v6@@ |= Number ; break ; } ++ @@v5@@ ; } } else { @@v6@@ |= block_size_opts [ @@v7@@ ] ; * @@a2@@ = Number L ; } } else { * @@a2@@ = default_block_size ( ) ; } * @@a3@@ = @@v6@@ ; return Number L ; }
__int64 __fastcall fts_set_stat_required ( __int64 @@a1@@ , char @@a2@@ ) { __int64 @@v2@@ ; __int64 @@result@@ ; if ( * ( _WORD * ) ( @@a1@@ + Number ) != Number ) abort ( ) ; if ( @@a2@@ ) @@v2@@ = Number L ; else @@v2@@ = Number L ; @@result@@ = @@a1@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v2@@ ; return @@result@@ ; }
int group_member ( __gid_t @@gid@@ ) { return group_member ( @@gid@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall fts_children ( __int64 @@a1@@ , int @@a2@@ ) { __int64 @@v3@@ ; __int64 @@v4@@ ; int @@v5@@ ; int @@v6@@ ; int @@v7@@ ; int @@v8@@ ; unsigned int @@v9@@ ; int @@fd@@ ; int @@v11@@ ; if ( @@a2@@ && @@a2@@ != Number ) { * __errno_location ( ) = Number ; return Number L ; } @@v3@@ = * ( _QWORD * ) @@a1@@ ; * __errno_location ( ) = Number ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) return Number L ; if ( * ( _WORD * ) ( @@v3@@ + Number ) == Number ) return * ( _QWORD * ) ( @@v3@@ + Number ) ; if ( * ( _WORD * ) ( @@v3@@ + Number ) != Number ) return Number L ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) fts_lfree ( * ( void * * ) ( @@a1@@ + Number ) ) ; if ( @@a2@@ == Number ) { @@v8@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; BYTE1 ( @@v8@@ ) |= Number ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@v8@@ ; @@v9@@ = Number ; } else { @@v9@@ = Number ; } if ( * ( _QWORD * ) ( @@v3@@ + Number ) || * * ( _BYTE * * ) ( @@v3@@ + Number ) == Number || ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { * ( _QWORD * ) ( @@a1@@ + Number ) = fts_build ( @@a1@@ , @@v9@@ ) ; return * ( _QWORD * ) ( @@a1@@ + Number ) ; } @@fd@@ = diropen ( @@a1@@ , ( int ) String , @@v4@@ , @@v5@@ , @@v6@@ , @@v7@@ ) ; if ( @@fd@@ < Number ) { * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; return Number L ; } * ( _QWORD * ) ( @@a1@@ + Number ) = fts_build ( @@a1@@ , @@v9@@ ) ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { cwd_advance_fd ( @@a1@@ , @@fd@@ , Number ) ; } else { if ( fchdir ( @@fd@@ ) ) { @@v11@@ = * __errno_location ( ) ; close ( @@fd@@ ) ; * __errno_location ( ) = @@v11@@ ; return Number L ; } close ( @@fd@@ ) ; } return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
__int64 __fastcall cwd_advance_fd ( __int64 @@a1@@ , int @@a2@@ , char @@a3@@ ) { __int64 @@result@@ ; int @@v4@@ ; int @@fd@@ ; @@v4@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; if ( @@v4@@ == @@a2@@ && @@v4@@ != Number ) abort ( ) ; if ( @@a3@@ ) { @@fd@@ = i_ring_push ( @@a1@@ + Number , ( unsigned int ) @@v4@@ ) ; if ( @@fd@@ >= Number ) close ( @@fd@@ ) ; } else if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) == Number && @@v4@@ >= Number ) { close ( @@v4@@ ) ; } @@result@@ = @@a1@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_20E038 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = ( __int64 * ) & slotvec0 ; } nslots = Number ; return @@result@@ ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
int __lxstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _lxstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
int dirfd ( DIR * @@dirp@@ ) { return dirfd ( @@dirp@@ ) ; }
_BOOL8 __fastcall dirent_inode_sort_may_be_useful ( int @@a1@@ ) { struct statfs @@buf@@ ; unsigned __int64 @@v3@@ ; @@v3@@ = __readfsqword ( Number ) ; if ( fstatfs ( @@a1@@ , & @@buf@@ ) ) return Number L ; return @@buf@@ . f_type != Number && @@buf@@ . f_type != Number ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
void * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_20E368 ; @@v4@@ [ Number ] = qword_20E370 ; @@v4@@ [ Number ] = qword_20E378 ; @@v4@@ [ Number ] = qword_20E380 ; @@v4@@ [ Number ] = qword_20E388 ; @@v4@@ [ Number ] = qword_20E390 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
int __fastcall hash_print_statistics ( __int64 @@a1@@ , FILE * @@a2@@ ) { double @@v2@@ ; double @@v3@@ ; double @@v4@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v6@@ = hash_get_n_entries ( @@a1@@ ) ; @@v7@@ = hash_get_n_buckets ( @@a1@@ ) ; @@v8@@ = hash_get_n_buckets_used ( @@a1@@ ) ; @@v9@@ = hash_get_max_bucket_length ( @@a1@@ ) ; fprintf ( @@a2@@ , String , @@v6@@ ) ; fprintf ( @@a2@@ , String , @@v7@@ ) ; if ( @@v8@@ < Number ) @@v2@@ = ( double ) ( int ) ( @@v8@@ & Number | ( ( unsigned __int64 ) @@v8@@ >> Number ) ) + ( double ) ( int ) ( @@v8@@ & Number | ( ( unsigned __int64 ) @@v8@@ >> Number ) ) ; else @@v2@@ = ( double ) ( int ) @@v8@@ ; @@v3@@ = Number * @@v2@@ ; if ( @@v7@@ < Number ) @@v4@@ = ( double ) ( int ) ( @@v7@@ & Number | ( ( unsigned __int64 ) @@v7@@ >> Number ) ) + ( double ) ( int ) ( @@v7@@ & Number | ( ( unsigned __int64 ) @@v7@@ >> Number ) ) ; else @@v4@@ = ( double ) ( int ) @@v7@@ ; fprintf ( @@a2@@ , String , @@v8@@ , @@v3@@ / @@v4@@ ) ; return fprintf ( @@a2@@ , String , @@v9@@ ) ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_206028 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
unsigned __int64 __fastcall LCO_hash ( _QWORD * @@a1@@ , unsigned __int64 @@a2@@ ) { return * @@a1@@ % @@a2@@ ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
bool __fastcall LCO_compare ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { return * @@a1@@ == * @@a2@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
__int64 __fastcall next_prime ( unsigned __int64 @@a1@@ ) { __int64 @@v2@@ ; __int64 @@i@@ ; @@v2@@ = @@a1@@ ; if ( @@a1@@ <= Number ) @@v2@@ = Number L ; for ( @@i@@ = @@v2@@ | Number ; @@i@@ != Number && ! is_prime ( @@i@@ ) ; @@i@@ += Number L ) { ; } return @@i@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
struct dirent * __fastcall readdir_ignoring_dot_and_dotdot ( DIR * @@a1@@ ) { struct dirent * @@v2@@ ; do @@v2@@ = readdir ( @@a1@@ ) ; while ( @@v2@@ && dot_or_dotdot ( @@v2@@ -> d_name ) ) ; return @@v2@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall link_count_optimize_ok ( __int64 @@a1@@ ) { __int64 @@result@@ ; bool @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; _BYTE * @@ptr@@ ; __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v3@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; if ( ( * ( _DWORD * ) ( @@v4@@ + Number ) & Number ) == Number ) return Number L ; if ( ! @@v3@@ ) { * ( _QWORD * ) ( @@v4@@ + Number ) = hash_initialize ( Number L , Number L , LCO_hash , LCO_compare , & free ) ; @@v3@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; if ( ! @@v3@@ ) return Number L ; } @@v8@@ [ Number ] = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v5@@ = hash_lookup ( @@v3@@ , @@v8@@ ) ; if ( @@v5@@ ) return * ( unsigned __int8 * ) ( @@v5@@ + Number ) ; @@ptr@@ = malloc ( Number ) ; if ( ! @@ptr@@ ) return Number L ; @@v2@@ = leaf_optimization_applies ( * ( _DWORD * ) ( @@v4@@ + Number ) ) ; @@ptr@@ [ Number ] = @@v2@@ ; * ( _QWORD * ) @@ptr@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v6@@ = hash_insert ( @@v3@@ , @@ptr@@ ) ; if ( @@v6@@ ) { if ( ( _BYTE * ) @@v6@@ != @@ptr@@ ) abort ( ) ; @@result@@ = @@v2@@ ; } else { free ( @@ptr@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
size_t * __fastcall hash_initialize ( __int64 @@a1@@ , void * @@a2@@ , unsigned __int64 ( __fastcall * @@a3@@ ) ( __int64 a1 , unsigned __int64 a2 ) , bool ( __fastcall * @@a4@@ ) ( __int64 a1 , __int64 a2 ) , size_t @@a5@@ ) { size_t * @@result@@ ; bool ( __fastcall * @@v7@@ ) ( __int64 , __int64 ) ; unsigned __int64 ( __fastcall * @@v8@@ ) ( __int64 , unsigned __int64 ) ; void * @@v9@@ ; size_t * @@ptr@@ ; @@v9@@ = @@a2@@ ; @@v8@@ = @@a3@@ ; @@v7@@ = @@a4@@ ; if ( ! @@a3@@ ) @@v8@@ = raw_hasher ; if ( ! @@a4@@ ) @@v7@@ = raw_comparator ; @@ptr@@ = ( size_t * ) malloc ( Number ) ; if ( ! @@ptr@@ ) return Number L ; if ( ! @@a2@@ ) @@v9@@ = & default_tuning ; @@ptr@@ [ Number ] = ( size_t ) @@v9@@ ; if ( ( unsigned __int8 ) check_tuning ( ( __int64 ) @@ptr@@ ) == Number && ( @@ptr@@ [ Number ] = compute_bucket_size ( @@a1@@ , ( __int64 ) @@v9@@ ) ) != Number && ( * @@ptr@@ = ( size_t ) calloc ( @@ptr@@ [ Number ] , Number ) ) != Number ) { @@ptr@@ [ Number ] = Number * @@ptr@@ [ Number ] + * @@ptr@@ ; @@ptr@@ [ Number ] = Number L ; @@ptr@@ [ Number ] = Number L ; @@ptr@@ [ Number ] = ( size_t ) @@v8@@ ; @@ptr@@ [ Number ] = ( size_t ) @@v7@@ ; @@ptr@@ [ Number ] = @@a5@@ ; @@ptr@@ [ Number ] = Number L ; @@result@@ = @@ptr@@ ; } else { free ( @@ptr@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
bool __fastcall is_empty_dir ( int @@a1@@ , const char * @@a2@@ ) { bool @@result@@ ; int @@v3@@ ; int @@v4@@ ; DIR * @@dirp@@ ; struct dirent * @@v6@@ ; @@v3@@ = openat ( @@a1@@ , @@a2@@ , Number ) ; if ( @@v3@@ < Number ) return Number ; @@dirp@@ = fdopendir ( @@v3@@ ) ; if ( @@dirp@@ ) { * __errno_location ( ) = Number ; @@v6@@ = readdir_ignoring_dot_and_dotdot ( @@dirp@@ ) ; @@v4@@ = * __errno_location ( ) ; closedir ( @@dirp@@ ) ; if ( @@v6@@ ) @@result@@ = Number ; else @@result@@ = @@v4@@ == Number ; } else { close ( @@v3@@ ) ; @@result@@ = Number ; } return @@result@@ ; }
__int64 __fastcall argmatch ( const char * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { __int64 @@result@@ ; char @@v7@@ ; __int64 @@i@@ ; __int64 @@v9@@ ; size_t @@n@@ ; @@v9@@ = Number ; @@v7@@ = Number ; @@n@@ = strlen ( @@a1@@ ) ; for ( @@i@@ = Number L ; * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; ++ @@i@@ ) { if ( ! strncmp ( * ( const char * * ) ( Number * @@i@@ + @@a2@@ ) , @@a1@@ , @@n@@ ) ) { if ( @@n@@ == strlen ( * ( const char * * ) ( Number * @@i@@ + @@a2@@ ) ) ) return @@i@@ ; if ( @@v9@@ == Number ) { @@v9@@ = @@i@@ ; } else if ( ! @@a3@@ || memcmp ( ( const void * ) ( @@a4@@ * @@v9@@ + @@a3@@ ) , ( const void * ) ( @@i@@ * @@a4@@ + @@a3@@ ) , @@a4@@ ) ) { @@v7@@ = Number ; } } } if ( @@v7@@ ) @@result@@ = Number ; else @@result@@ = @@v9@@ ; return @@result@@ ; }
__int64 __fastcall i_ring_empty ( __int64 @@a1@@ ) { return * ( unsigned __int8 * ) ( @@a1@@ + Number ) ; }
__int64 __fastcall fts_sort ( __int64 @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { size_t @@v3@@ ; _QWORD * @@v5@@ ; __int64 @@i@@ ; _QWORD * @@v7@@ ; _QWORD * @@v8@@ ; __int64 @@v9@@ ; int ( * @@compar@@ ( ) ( constvoid , constvoid ) ) ( const void * , const void * ) ; void * @@v11@@ ; @@v3@@ = @@a3@@ ; @@compar@@ ( ) ( constvoid , constvoid ) = * ( int ( * * ) ( const void * , const void * ) ) ( @@a1@@ + Number ) ; if ( @@a3@@ > * ( _QWORD * ) ( @@a1@@ + Number ) ) { * ( _QWORD * ) ( @@a1@@ + Number ) = @@a3@@ + Number ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) > Number || ( @@v11@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number L * * ( _QWORD * ) ( @@a1@@ + Number ) ) ) == Number L ) { free ( * ( void * * ) ( @@a1@@ + Number ) ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; return @@a2@@ ; } * ( _QWORD * ) ( @@a1@@ + Number ) = @@v11@@ ; } @@v5@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; for ( @@i@@ = @@a2@@ ; @@i@@ ; @@i@@ = * ( _QWORD * ) ( @@i@@ + Number ) ) { @@v7@@ = @@v5@@ ++ ; * @@v7@@ = @@i@@ ; } qsort ( * ( void * * ) ( @@a1@@ + Number ) , @@v3@@ , Number , @@compar@@ ( ) ( constvoid , constvoid ) ) ; @@v8@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; @@v9@@ = * @@v8@@ ; while ( -- @@v3@@ ) { * ( _QWORD * ) ( * @@v8@@ + Number L ) = @@v8@@ [ Number ] ; ++ @@v8@@ ; } * ( _QWORD * ) ( * @@v8@@ + Number L ) = Number L ; return @@v9@@ ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
__int64 __fastcall rm ( _QWORD * @@a1@@ , __int64 @@a2@@ ) { char * @@v2@@ ; int * @@v3@@ ; char * @@v4@@ ; int * @@v5@@ ; unsigned int @@v7@@ ; unsigned int @@v8@@ ; unsigned int @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; @@v7@@ = Number ; if ( * @@a1@@ ) { @@v8@@ = Number ; if ( * ( _BYTE * ) ( @@a2@@ + Number ) ) @@v8@@ = Number ; @@v10@@ = xfts_open ( @@a1@@ , @@v8@@ , Number L ) ; while ( Number ) { @@v11@@ = fts_read ( @@v10@@ ) ; if ( ! @@v11@@ ) break ; @@v9@@ = rm_fts ( @@v10@@ , @@v11@@ , @@a2@@ ) ; if ( @@v9@@ != Number && @@v9@@ != Number && @@v9@@ != Number ) __assert_fail ( String , String , Number , String ) ; if ( @@v9@@ == Number || @@v9@@ == Number && @@v7@@ == Number ) @@v7@@ = @@v9@@ ; } if ( * __errno_location ( ) ) { @@v2@@ = gettext ( String ) ; @@v3@@ = __errno_location ( ) ; error ( Number , * @@v3@@ , @@v2@@ ) ; @@v7@@ = Number ; } if ( ( unsigned int ) fts_close ( @@v10@@ ) ) { @@v4@@ = gettext ( String ) ; @@v5@@ = __errno_location ( ) ; error ( Number , * @@v5@@ , @@v4@@ ) ; @@v7@@ = Number ; } } return @@v7@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) _frame_dummy_init_array_entry [ @@i@@ ] ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
__int64 __fastcall i_ring_push ( __int64 @@a1@@ , int @@a2@@ ) { int @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = ( ( unsigned __int8 ) * ( _DWORD * ) ( @@a1@@ + Number ) + ( * ( _BYTE * ) ( @@a1@@ + Number ) ^ Number ) ) & Number ; @@v4@@ = * ( _DWORD * ) ( @@a1@@ + Number L * ( ( ( unsigned __int8 ) * ( _DWORD * ) ( @@a1@@ + Number ) + ( * ( _BYTE * ) ( @@a1@@ + Number ) ^ Number ) ) & Number ) ) ; * ( _DWORD * ) ( @@a1@@ + Number L * ( ( ( unsigned __int8 ) * ( _DWORD * ) ( @@a1@@ + Number ) + ( * ( _BYTE * ) ( @@a1@@ + Number ) ^ Number ) ) & Number ) ) = @@a2@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@v3@@ ; if ( @@v3@@ == * ( _DWORD * ) ( @@a1@@ + Number ) ) * ( _DWORD * ) ( @@a1@@ + Number ) = ( ( unsigned __int8 ) * ( _DWORD * ) ( @@a1@@ + Number ) + ( * ( _BYTE * ) ( @@a1@@ + Number ) ^ Number ) ) & Number ; * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; return @@v4@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 __fastcall hash_lookup ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; _QWORD * @@i@@ ; _QWORD * @@v5@@ ; @@v2@@ = * @@a1@@ ; @@v5@@ = ( _QWORD * ) ( @@v2@@ + Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) ) ; if ( ( unsigned __int64 ) @@v5@@ >= @@a1@@ [ Number ] ) abort ( ) ; if ( ! * @@v5@@ ) return Number L ; for ( @@i@@ = @@v5@@ ; @@i@@ ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { if ( @@a2@@ == * @@i@@ || ( ( unsigned __int8 ( __fastcall * ) ( __int64 , _QWORD ) ) @@a1@@ [ Number ] ) ( @@a2@@ , * @@i@@ ) ) { return * @@i@@ ; } } return Number L ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
__int64 close_stdin ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char @@v4@@ ; char * @@v5@@ ; @@v4@@ = Number ; if ( freadahead ( stdin ) && ! ( unsigned int ) rpl_fseeko ( stdin , Number L , Number L ) && ( unsigned int ) rpl_fflush ( stdin ) ) @@v4@@ = Number ; if ( ( unsigned int ) close_stream ( stdin ) ) @@v4@@ = Number ; if ( @@v4@@ ) { @@v5@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v5@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v5@@ ) ; } } @@result@@ = close_stdout ( ) ; if ( @@v4@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
int putchar_unlocked ( int @@c@@ ) { return putchar_unlocked ( @@c@@ ) ; }
unsigned __int64 __fastcall hash_get_entries ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; _QWORD * @@i@@ ; _QWORD * @@j@@ ; @@v5@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = @@i@@ ; @@j@@ ; @@j@@ = ( _QWORD * ) @@j@@ [ Number ] ) { if ( @@v5@@ >= @@a3@@ ) return @@v5@@ ; @@v4@@ = @@v5@@ ++ ; * ( _QWORD * ) ( @@a2@@ + Number * @@v4@@ ) = * @@j@@ ; } } } return @@v5@@ ; }
void __fastcall free_dir ( __int64 @@a1@@ ) { if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) hash_free ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ; } else { free ( * ( void * * ) ( @@a1@@ + Number ) ) ; } }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; char * @@v3@@ ; FILE * @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; @@v1@@ = program_name ; if ( @@a1@@ ) { @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = gettext ( String ) ; printf ( @@v3@@ , @@v1@@ ) ; @@v4@@ = stdout ; @@v5@@ = gettext ( String ) ; fputs_unlocked ( @@v5@@ , @@v4@@ ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
__int64 __fastcall opendirat ( int @@a1@@ , int @@a2@@ , __int64 a3 , __int64 a4 , int @@a5@@ , int @@a6@@ ) { int @@fd@@ ; _BYTE @@v8@@ [ Number ] ; @@fd@@ = openat_safer ( @@a1@@ , @@a2@@ , Number , @@a2@@ , @@a5@@ , @@a6@@ , @@a2@@ ) ; if ( @@fd@@ < Number ) return Number L ; set_cloexec_flag ( ( unsigned int ) @@fd@@ , Number L ) ; * ( _QWORD * ) & @@v8@@ [ Number ] = fdopendir ( @@fd@@ ) ; if ( ! * ( _QWORD * ) & @@v8@@ [ Number ] ) { * ( _QWORD * ) @@v8@@ = ( unsigned int ) * __errno_location ( ) ; close ( @@fd@@ ) ; * __errno_location ( ) = * ( _DWORD * ) @@v8@@ ; } return * ( _QWORD * ) & @@v8@@ [ Number ] ; }
void __fastcall hash_free ( __int64 @@a1@@ ) { _QWORD * @@i@@ ; _QWORD * @@j@@ ; _QWORD * @@ptr@@ ; _QWORD * @@ptra@@ ; _QWORD * @@ptrb@@ ; _QWORD * @@v6@@ ; _QWORD * @@v7@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) && * ( _QWORD * ) ( @@a1@@ + Number ) ) { for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@ptr@@ = @@i@@ ; @@ptr@@ ; @@ptr@@ = ( _QWORD * ) @@ptr@@ [ Number ] ) { ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@ptr@@ ) ; } } } } for ( @@j@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@j@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@j@@ += Number ) { for ( @@ptra@@ = ( _QWORD * ) @@j@@ [ Number ] ; @@ptra@@ ; @@ptra@@ = @@v6@@ ) { @@v6@@ = ( _QWORD * ) @@ptra@@ [ Number ] ; free ( @@ptra@@ ) ; } } for ( @@ptrb@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; @@ptrb@@ ; @@ptrb@@ = @@v7@@ ) { @@v7@@ = ( _QWORD * ) @@ptrb@@ [ Number ] ; free ( @@ptrb@@ ) ; } free ( * ( void * * ) @@a1@@ ) ; free ( ( void * ) @@a1@@ ) ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; __int64 @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; FILE * @@v10@@ ; char * @@v11@@ ; if ( @@a1@@ ) { @@v1@@ = program_name ; @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = program_name ; @@v4@@ = gettext ( String ) ; printf ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; if ( uname_mode == Number ) { @@v6@@ = gettext ( String String String String String String String ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v5@@ = stdout ; @@v7@@ = gettext ( String String String String String ) ; } else { @@v7@@ = gettext ( String ) ; } fputs_unlocked ( @@v7@@ , @@v5@@ ) ; @@v8@@ = stdout ; @@v9@@ = gettext ( String ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = stdout ; @@v11@@ = gettext ( String ) ; fputs_unlocked ( @@v11@@ , @@v10@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
unsigned __int64 __fastcall LCO_hash ( _QWORD * @@a1@@ , unsigned __int64 @@a2@@ ) { return * @@a1@@ % @@a2@@ ; }
__int64 __fastcall i_ring_init ( __int64 @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; int @@i@@ ; * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; * ( _DWORD * ) ( @@a1@@ + Number ) = Number ; * ( _DWORD * ) ( @@a1@@ + Number ) = Number ; for ( @@i@@ = Number ; @@i@@ <= Number ; ++ @@i@@ ) * ( _DWORD * ) ( @@a1@@ + Number L * @@i@@ ) = @@a2@@ ; @@result@@ = @@a1@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall i_ring_empty ( __int64 @@a1@@ ) { return * ( unsigned __int8 * ) ( @@a1@@ + Number ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
__int64 __fastcall i_ring_push ( __int64 @@a1@@ , int @@a2@@ ) { int @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = ( ( unsigned __int8 ) * ( _DWORD * ) ( @@a1@@ + Number ) + ( * ( _BYTE * ) ( @@a1@@ + Number ) ^ Number ) ) & Number ; @@v4@@ = * ( _DWORD * ) ( @@a1@@ + Number L * ( ( ( unsigned __int8 ) * ( _DWORD * ) ( @@a1@@ + Number ) + ( * ( _BYTE * ) ( @@a1@@ + Number ) ^ Number ) ) & Number ) ) ; * ( _DWORD * ) ( @@a1@@ + Number L * ( ( ( unsigned __int8 ) * ( _DWORD * ) ( @@a1@@ + Number ) + ( * ( _BYTE * ) ( @@a1@@ + Number ) ^ Number ) ) & Number ) ) = @@a2@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@v3@@ ; if ( @@v3@@ == * ( _DWORD * ) ( @@a1@@ + Number ) ) * ( _DWORD * ) ( @@a1@@ + Number ) = ( ( unsigned __int8 ) * ( _DWORD * ) ( @@a1@@ + Number ) + ( * ( _BYTE * ) ( @@a1@@ + Number ) ^ Number ) ) & Number ; * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; return @@v4@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall fts_set ( __int64 a1 , __int64 @@a2@@ , int @@a3@@ ) { __int64 @@result@@ ; if ( ! @@a3@@ || @@a3@@ == Number || @@a3@@ == Number || @@a3@@ == Number || @@a3@@ == Number ) { * ( _WORD * ) ( @@a2@@ + Number ) = @@a3@@ ; @@result@@ = Number L ; } else { * __errno_location ( ) = Number ; @@result@@ = Number L ; } return @@result@@ ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
__int64 __fastcall mode_adjust ( __int16 @@a1@@ , unsigned __int8 @@a2@@ , int @@a3@@ , char * @@a4@@ , _DWORD * @@a5@@ ) { int @@v5@@ ; int @@v6@@ ; int @@v7@@ ; int @@v8@@ ; int @@v9@@ ; int @@v10@@ ; int @@v11@@ ; int @@v12@@ ; int @@v13@@ ; unsigned int @@v17@@ ; int @@v18@@ ; int @@v19@@ ; int @@v20@@ ; int @@v21@@ ; int @@v22@@ ; int @@v23@@ ; @@v17@@ = @@a1@@ & Number ; @@v18@@ = Number ; while ( @@a4@@ [ Number ] ) { @@v22@@ = * ( ( _DWORD * ) @@a4@@ + Number ) ; if ( @@a2@@ ) @@v5@@ = Number ; else @@v5@@ = Number ; @@v23@@ = @@v5@@ & ~ * ( ( _DWORD * ) @@a4@@ + Number ) ; @@v19@@ = * ( ( _DWORD * ) @@a4@@ + Number ) ; @@v6@@ = @@a4@@ [ Number ] ; if ( @@v6@@ == Number ) { if ( @@v17@@ & Number | @@a2@@ ) @@v19@@ |= Number ; } else if ( @@v6@@ == Number ) { @@v20@@ = @@v17@@ & @@v19@@ ; if ( ( @@v20@@ & Number ) != Number ) @@v7@@ = Number ; else @@v7@@ = Number ; if ( ( @@v20@@ & Number ) != Number ) @@v8@@ = Number ; else @@v8@@ = Number ; @@v9@@ = @@v8@@ | @@v7@@ ; if ( ( @@v20@@ & Number ) != Number ) @@v10@@ = Number ; else @@v10@@ = Number ; @@v19@@ = @@v9@@ | @@v10@@ | @@v20@@ ; } if ( @@v22@@ ) @@v11@@ = * ( ( _DWORD * ) @@a4@@ + Number ) ; else @@v11@@ = ~ @@a3@@ ; @@v21@@ = ~ @@v23@@ & @@v11@@ & @@v19@@ ; @@v12@@ = * @@a4@@ ; switch ( @@v12@@ ) { case String : @@v18@@ |= @@v21@@ ; @@v17@@ &= ~ @@v21@@ ; break ; case String : if ( @@v22@@ ) @@v13@@ = ~ @@v22@@ ; else @@v13@@ = Number ; @@v18@@ |= ~ ( ( unsigned __int16 ) @@v23@@ | ( unsigned __int16 ) @@v13@@ ) & Number ; @@v17@@ = @@v21@@ | ( @@v23@@ | @@v13@@ ) & @@v17@@ ; break ; case String : @@v18@@ |= @@v21@@ ; @@v17@@ |= @@v21@@ ; break ; } @@a4@@ += Number ; } if ( @@a5@@ ) * @@a5@@ = @@v18@@ ; return @@v17@@ ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_2100E8 ; @@v8@@ [ Number ] = qword_2100F0 ; @@v8@@ [ Number ] = qword_2100F8 ; @@v8@@ [ Number ] = qword_210100 ; @@v8@@ [ Number ] = qword_210108 ; @@v8@@ [ Number ] = qword_210110 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
__int64 __fastcall fts_stat ( __int64 @@a1@@ , __int64 @@a2@@ , char @@a3@@ ) { __int64 @@result@@ ; __int64 @@v4@@ ; int @@v6@@ ; struct stat * @@s@@ ; @@s@@ = ( struct stat * ) ( @@a2@@ + Number ) ; if ( ! * ( _QWORD * ) ( @@a2@@ + Number ) && ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) @@a3@@ = Number ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number || @@a3@@ ) { if ( ( unsigned int ) stat ( * ( char * * ) ( @@a2@@ + Number ) , @@s@@ ) ) { @@v6@@ = * __errno_location ( ) ; if ( * __errno_location ( ) == Number && ! ( unsigned int ) lstat ( * ( char * * ) ( @@a2@@ + Number ) , @@s@@ ) ) { * __errno_location ( ) = Number ; return Number L ; } * ( _DWORD * ) ( @@a2@@ + Number ) = @@v6@@ ; goto LABEL_13 ; } } else if ( ( unsigned int ) fstatat ( * ( _DWORD * ) ( @@a1@@ + Number ) , * ( char * * ) ( @@a2@@ + Number ) , @@s@@ , Number ) ) { * ( _DWORD * ) ( @@a2@@ + Number ) = * __errno_location ( ) ; LABEL_13 : memset ( @@s@@ , Number , sizeof ( struct stat ) ) ; return Number L ; } switch ( * ( _DWORD * ) ( @@a2@@ + Number ) & Number ) { case Number : if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) @@v4@@ = Number L ; else @@v4@@ = Number L ; * ( _QWORD * ) ( @@a2@@ + Number ) = * ( _QWORD * ) ( @@a2@@ + Number ) - @@v4@@ ; if ( * ( _BYTE * ) ( @@a2@@ + Number ) != Number || * ( _BYTE * ) ( @@a2@@ + Number ) && ( * ( _BYTE * ) ( @@a2@@ + Number ) != Number || * ( _BYTE * ) ( @@a2@@ + Number ) ) ) { @@result@@ = Number L ; } else if ( * ( _QWORD * ) ( @@a2@@ + Number ) ) { @@result@@ = Number L ; } else { @@result@@ = Number L ; } break ; case Number : @@result@@ = Number L ; break ; case Number : @@result@@ = Number L ; break ; default : @@result@@ = Number L ; break ; } return @@result@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_206028 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return xmalloc ( @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_20E108 ; @@v4@@ [ Number ] = qword_20E110 ; @@v4@@ [ Number ] = qword_20E118 ; @@v4@@ [ Number ] = qword_20E120 ; @@v4@@ [ Number ] = qword_20E128 ; @@v4@@ [ Number ] = qword_20E130 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
__int64 __fastcall hash_get_next ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; _QWORD * @@v4@@ ; _QWORD * @@i@@ ; @@v2@@ = * @@a1@@ ; @@v4@@ = ( _QWORD * ) ( @@v2@@ + Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) ) ; if ( ( unsigned __int64 ) @@v4@@ >= @@a1@@ [ Number ] ) abort ( ) ; for ( @@i@@ = @@v4@@ ; @@i@@ ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { if ( @@a2@@ == * @@i@@ && @@i@@ [ Number ] ) return * ( _QWORD * ) @@i@@ [ Number ] ; } while ( Number ) { @@v4@@ += Number ; if ( ( unsigned __int64 ) @@v4@@ >= @@a1@@ [ Number ] ) break ; if ( * @@v4@@ ) return * @@v4@@ ; } return Number L ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
bool __fastcall is_prime ( unsigned __int64 @@a1@@ ) { unsigned __int64 @@v2@@ ; unsigned __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; @@v2@@ = Number L ; @@v4@@ = Number L ; while ( @@v4@@ < @@a1@@ && @@a1@@ % @@v2@@ ) { @@v3@@ = @@v2@@ + Number ; @@v4@@ += Number * @@v3@@ ; @@v2@@ = @@v3@@ + Number ; } return @@a1@@ % @@v2@@ != Number ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
_BOOL8 __fastcall euidaccess_stat ( _DWORD * @@a1@@ , char @@a2@@ ) { unsigned int @@v3@@ ; __uid_t @@v4@@ ; if ( ( @@a2@@ & Number ) == Number ) return Number L ; @@v4@@ = geteuid ( ) ; if ( ! @@v4@@ && ( ( @@a2@@ & Number ) == Number || ( @@a1@@ [ Number ] & Number ) != Number ) ) return Number L ; @@v3@@ = @@a1@@ [ Number ] ; if ( @@v4@@ == @@a1@@ [ Number ] ) { @@v3@@ >>= Number ; } else if ( getegid ( ) == @@a1@@ [ Number ] || group_member ( @@a1@@ [ Number ] ) ) { @@v3@@ >>= Number ; } return ( ~ @@v3@@ & @@a2@@ & Number ) == Number ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_2070C8 ; @@v8@@ [ Number ] = qword_2070D0 ; @@v8@@ [ Number ] = qword_2070D8 ; @@v8@@ [ Number ] = qword_2070E0 ; @@v8@@ [ Number ] = qword_2070E8 ; @@v8@@ [ Number ] = qword_2070F0 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 __fastcall hash_clear ( __int64 @@a1@@ ) { __int64 @@result@@ ; _QWORD * @@i@@ ; _QWORD * @@j@@ ; _QWORD * @@v4@@ ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = ( _QWORD * ) @@i@@ [ Number ] ; @@j@@ ; @@j@@ = @@v4@@ ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@j@@ ) ; * @@j@@ = Number L ; @@v4@@ = ( _QWORD * ) @@j@@ [ Number ] ; @@j@@ [ Number ] = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@j@@ ; } if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@i@@ ) ; * @@i@@ = Number L ; @@i@@ [ Number ] = Number L ; } } * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; @@result@@ = @@a1@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; return @@result@@ ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
__int64 __fastcall xfts_open ( const char * * @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { unsigned int @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; __int64 @@v7@@ ; @@v3@@ = @@a2@@ ; BYTE1 ( @@v3@@ ) = BYTE1 ( @@a2@@ ) | Number ; @@v4@@ = @@v3@@ ; @@v7@@ = fts_open ( @@a1@@ , @@v3@@ , @@a3@@ ) ; if ( ! @@v7@@ ) { if ( * __errno_location ( ) == Number ) __assert_fail ( String , String , Number , String ) ; xalloc_die ( @@a1@@ , @@v4@@ , @@v5@@ ) ; } return @@v7@@ ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
__int64 __fastcall dup_cloexec ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
__int64 __fastcall i_ring_init ( __int64 @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; int @@i@@ ; * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; * ( _DWORD * ) ( @@a1@@ + Number ) = Number ; * ( _DWORD * ) ( @@a1@@ + Number ) = Number ; for ( @@i@@ = Number ; @@i@@ <= Number ; ++ @@i@@ ) * ( _DWORD * ) ( @@a1@@ + Number L * @@i@@ ) = @@a2@@ ; @@result@@ = @@a1@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
int __cdecl __noreturn main ( int @@argc@@ , const char * * @@argv@@ , const char * * @@envp@@ ) { char * @@v3@@ ; int * @@v4@@ ; int @@v5@@ ; struct utsname @@name@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; set_program_name ( * @@argv@@ , @@argv@@ , @@envp@@ ) ; setlocale ( Number , & locale ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; @@v5@@ = decode_switches ( @@argc@@ , ( char * const * ) @@argv@@ ) ; if ( ! @@v5@@ ) @@v5@@ = Number ; if ( ( @@v5@@ & Number ) != Number ) { if ( uname ( & @@name@@ ) == Number ) { @@v3@@ = gettext ( String ) ; @@v4@@ = __errno_location ( ) ; error ( Number , * @@v4@@ , @@v3@@ ) ; } if ( ( @@v5@@ & Number ) != Number ) print_element ( @@name@@ . sysname ) ; if ( ( @@v5@@ & Number ) != Number ) print_element ( @@name@@ . nodename ) ; if ( ( @@v5@@ & Number ) != Number ) print_element ( @@name@@ . release ) ; if ( ( @@v5@@ & Number ) != Number ) print_element ( @@name@@ . version ) ; if ( ( @@v5@@ & Number ) != Number ) print_element ( @@name@@ . machine ) ; } if ( ( @@v5@@ & Number ) != Number && @@v5@@ != Number ) print_element ( String ) ; if ( ( @@v5@@ & Number ) != Number && @@v5@@ != Number ) print_element ( String ) ; if ( ( @@v5@@ & Number ) != Number ) print_element ( String ) ; putchar_unlocked ( Number ) ; exit ( Number ) ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
__int64 __fastcall i_ring_pop ( __int64 @@a1@@ ) { unsigned int @@v2@@ ; if ( ( unsigned __int8 ) i_ring_empty ( @@a1@@ ) ) abort ( ) ; @@v2@@ = * ( _DWORD * ) ( @@a1@@ + Number L * * ( unsigned int * ) ( @@a1@@ + Number ) ) ; * ( _DWORD * ) ( @@a1@@ + Number L * * ( unsigned int * ) ( @@a1@@ + Number ) ) = * ( _DWORD * ) ( @@a1@@ + Number ) ; if ( * ( _DWORD * ) ( @@a1@@ + Number ) == * ( _DWORD * ) ( @@a1@@ + Number ) ) * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; else * ( _DWORD * ) ( @@a1@@ + Number ) = ( ( unsigned __int8 ) * ( _DWORD * ) ( @@a1@@ + Number ) + Number ) & Number ; return @@v2@@ ; }
int __fxstatat ( int @@ver@@ , int @@fildes@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ , int @@flag@@ ) { return _fxstatat ( @@ver@@ , @@fildes@@ , @@filename@@ , @@stat_buf@@ , @@flag@@ ) ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
struct dirent * readdir ( DIR * @@dirp@@ ) { return readdir ( @@dirp@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
int __freading ( FILE * @@fp@@ ) { return _freading ( @@fp@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
int clock_gettime ( clockid_t @@clock_id@@ , struct timespec * @@tp@@ ) { return clock_gettime ( @@clock_id@@ , @@tp@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
int __lxstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _lxstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
int feof_unlocked ( FILE * @@stream@@ ) { return feof_unlocked ( @@stream@@ ) ; }
_BOOL8 __fastcall dot_or_dotdot ( _BYTE * @@a1@@ ) { __int64 @@v1@@ ; char @@v4@@ ; if ( * @@a1@@ != Number ) return Number L ; if ( @@a1@@ [ Number ] == Number ) @@v1@@ = Number L ; else @@v1@@ = Number L ; @@v4@@ = @@a1@@ [ @@v1@@ ] ; return ! @@v4@@ || @@v4@@ == Number ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
int iconv_close ( iconv_t @@cd@@ ) { return iconv_close ( @@cd@@ ) ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall cache_fstatat ( int @@a1@@ , char * @@a2@@ , struct stat * @@a3@@ , int @@a4@@ ) { __ino_t @@v5@@ ; if ( @@a3@@ -> st_size == Number && ( unsigned int ) fstatat ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ) { @@a3@@ -> st_size = Number ; @@a3@@ -> st_ino = * __errno_location ( ) ; } if ( @@a3@@ -> st_size >= Number ) return Number L ; @@v5@@ = @@a3@@ -> st_ino ; * __errno_location ( ) = @@v5@@ ; return Number ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
_BOOL8 __fastcall ignorable_missing ( _BYTE * @@a1@@ , int @@a2@@ ) { return * @@a1@@ && nonexistent_file_errno ( @@a2@@ ) ; }
_BOOL8 __fastcall target_directory_operand ( char * @@a1@@ , struct stat * @@a2@@ , _BYTE * @@a3@@ ) { int @@v3@@ ; bool @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; bool @@v9@@ ; int @@errnum@@ ; if ( ( unsigned int ) stat ( @@a1@@ , @@a2@@ ) ) @@v3@@ = * __errno_location ( ) ; else @@v3@@ = Number ; @@errnum@@ = @@v3@@ ; @@v4@@ = ! @@v3@@ && ( @@a2@@ -> st_mode & Number ) == Number ; @@v9@@ = @@v4@@ ; if ( @@errnum@@ ) { if ( @@errnum@@ != Number ) { @@v5@@ = quote ( @@a1@@ ) ; @@v6@@ = gettext ( String ) ; error ( Number , @@errnum@@ , @@v6@@ , @@v5@@ ) ; } * @@a3@@ = Number ; } return @@v9@@ ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_210038 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
__int64 __fastcall cksum ( const char * @@a1@@ , char @@a2@@ ) { size_t @@i@@ ; int * @@v3@@ ; __int64 @@result@@ ; char * @@v5@@ ; char * @@v6@@ ; int * @@v8@@ ; int * @@v9@@ ; char * @@v10@@ ; int * @@v11@@ ; __int64 @@v12@@ ; unsigned int @@v13@@ ; size_t @@v14@@ ; size_t @@v15@@ ; FILE * @@stream@@ ; char * @@v17@@ ; const char * @@v18@@ ; char @@v19@@ [ Number ] ; char @@ptr@@ [ Number ] ; unsigned __int64 @@v21@@ ; @@v21@@ = __readfsqword ( Number ) ; @@v12@@ = Number L ; @@v14@@ = Number L ; if ( ! strcmp ( @@a1@@ , String ) ) { @@stream@@ = stdin ; have_read_stdin = Number ; for ( @@i@@ = fread_unlocked ( @@ptr@@ , Number , Number , stdin ) ; ; @@i@@ = fread_unlocked ( @@ptr@@ , Number , Number , @@stream@@ ) ) { @@v15@@ = @@i@@ ; if ( ! @@i@@ ) break ; @@v17@@ = @@ptr@@ ; if ( @@v14@@ > @@v14@@ + @@i@@ ) { @@v5@@ = gettext ( String ) ; error ( Number , Number , @@v5@@ , @@a1@@ ) ; } @@v14@@ += @@v15@@ ; while ( @@v15@@ -- ) { @@v6@@ = @@v17@@ ++ ; @@v12@@ = ( @@v12@@ << Number ) ^ crctab [ ( unsigned __int8 ) ( BYTE3 ( @@v12@@ ) ^ * @@v6@@ ) ] ; } if ( feof_unlocked ( @@stream@@ ) ) break ; LABEL_11 : ; } if ( ferror_unlocked ( @@stream@@ ) ) { @@v8@@ = __errno_location ( ) ; error ( Number , * @@v8@@ , String , @@a1@@ ) ; if ( strcmp ( @@a1@@ , String ) ) fclose ( @@stream@@ ) ; @@result@@ = Number L ; } else if ( ! strcmp ( @@a1@@ , String ) || fclose ( @@stream@@ ) != Number ) { @@v18@@ = ( const char * ) umaxtostr ( @@v14@@ , @@v19@@ ) ; while ( @@v14@@ ) { @@v12@@ = ( @@v12@@ << Number ) ^ crctab [ ( unsigned __int8 ) ( @@v14@@ ^ BYTE3 ( @@v12@@ ) ) ] ; @@v14@@ >>= Number ; } @@v13@@ = ~ ( _DWORD ) @@v12@@ ; if ( @@a2@@ ) printf ( String , @@v13@@ , @@v18@@ , @@a1@@ ) ; else printf ( String , @@v13@@ , @@v18@@ ) ; if ( ferror_unlocked ( stdout ) ) { @@v10@@ = gettext ( String ) ; @@v11@@ = __errno_location ( ) ; error ( Number , * @@v11@@ , String , @@v10@@ ) ; } @@result@@ = Number L ; } else { @@v9@@ = __errno_location ( ) ; error ( Number , * @@v9@@ , String , @@a1@@ ) ; @@result@@ = Number L ; } } else { @@stream@@ = fopen ( @@a1@@ , String ) ; if ( @@stream@@ ) goto LABEL_11 ; @@v3@@ = __errno_location ( ) ; error ( Number , * @@v3@@ , String , @@a1@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
__int64 __fastcall get_stat_atime_0 ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
_BOOL8 __fastcall strip_trailing_slashes ( char * @@a1@@ ) { char @@v1@@ ; const char * @@v3@@ ; const char * @@v4@@ ; @@v3@@ = last_component ( @@a1@@ ) ; if ( ! * @@v3@@ ) @@v3@@ = @@a1@@ ; @@v4@@ = & @@v3@@ [ base_len ( @@v3@@ ) ] ; @@v1@@ = * @@v4@@ ; * @@v4@@ = Number ; return @@v1@@ != Number ; }
__int64 __fastcall excise ( __int64 @@a1@@ , __int64 @@a2@@ , _BYTE * @@a3@@ , char @@a4@@ ) { int @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@result@@ ; int * @@v8@@ ; __int64 @@v9@@ ; char * @@v10@@ ; int * @@v11@@ ; struct stat @@v14@@ ; unsigned __int64 @@v15@@ ; @@v15@@ = __readfsqword ( Number ) ; if ( @@a4@@ ) @@v4@@ = Number ; else @@v4@@ = Number ; if ( unlinkat ( * ( _DWORD * ) ( @@a1@@ + Number ) , * ( const char * * ) ( @@a2@@ + Number ) , @@v4@@ ) ) { if ( * __errno_location ( ) == Number && ( ! ( unsigned int ) lstatat ( * ( _DWORD * ) ( @@a1@@ + Number ) , * ( char * * ) ( @@a2@@ + Number ) , & @@v14@@ ) || * __errno_location ( ) != Number ) ) { * __errno_location ( ) = Number ; } @@v8@@ = __errno_location ( ) ; if ( ignorable_missing ( @@a3@@ , * @@v8@@ ) ) { @@result@@ = Number L ; } else { if ( * ( _WORD * ) ( @@a2@@ + Number ) == Number ) * __errno_location ( ) = * ( _DWORD * ) ( @@a2@@ + Number ) ; @@v9@@ = quote ( * ( _QWORD * ) ( @@a2@@ + Number ) ) ; @@v10@@ = gettext ( String ) ; @@v11@@ = __errno_location ( ) ; error ( Number , * @@v11@@ , @@v10@@ , @@v9@@ ) ; mark_ancestor_dirs ( @@a2@@ ) ; @@result@@ = Number L ; } } else { if ( @@a3@@ [ Number ] ) { @@v5@@ = quote ( * ( _QWORD * ) ( @@a2@@ + Number ) ) ; if ( @@a4@@ ) @@v6@@ = gettext ( String ) ; else @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@result@@ = Number L ; } return @@result@@ ; }
int __fastcall clone_file ( int @@a1@@ , unsigned int @@a2@@ ) { return ioctl ( @@a1@@ , Number , @@a2@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
__int64 __fastcall _xargmatch_internal ( __int64 @@a1@@ , const char * @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ , void ( * @@a6@@ ) ( void ) ) { __int64 @@v11@@ ; @@v11@@ = argmatch ( @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; if ( @@v11@@ >= Number ) return @@v11@@ ; argmatch_invalid ( @@a1@@ , ( __int64 ) @@a2@@ , @@v11@@ ) ; argmatch_valid ( @@a3@@ , @@a4@@ , @@a5@@ ) ; @@a6@@ ( ) ; return Number ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
_BOOL8 yesno ( ) { bool @@v1@@ ; char * @@lineptr@@ ; size_t @@n@@ ; __ssize_t @@v4@@ ; unsigned __int64 @@v5@@ ; @@v5@@ = __readfsqword ( Number ) ; @@lineptr@@ = Number L ; @@n@@ = Number L ; @@v4@@ = getline ( & @@lineptr@@ , & @@n@@ , stdin ) ; if ( @@v4@@ > Number ) { @@lineptr@@ [ @@v4@@ - Number ] = Number ; @@v1@@ = rpmatch ( @@lineptr@@ ) > Number ; } else { @@v1@@ = Number ; } free ( @@lineptr@@ ) ; return @@v1@@ ; }
_BOOL8 __fastcall copy_dir ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int8 @@a3@@ , _QWORD * @@a4@@ , int @@a5@@ , __int64 @@a6@@ , __int64 @@a7@@ , bool * @@a8@@ ) { __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; __int64 @@v12@@ ; char * @@v13@@ ; int * @@v14@@ ; _BOOL8 @@result@@ ; unsigned __int8 @@v16@@ ; size_t @@v17@@ ; char @@v22@@ ; bool @@v23@@ ; char * @@s@@ ; void * @@v25@@ ; void * @@v26@@ ; void * @@ptr@@ ; __int64 @@v28@@ [ Number ] ; @@v28@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ = * ( _QWORD * ) ( @@a6@@ + Number ) ; @@v28@@ [ Number ] = * ( _QWORD * ) @@a6@@ ; @@v28@@ [ Number ] = @@v8@@ ; @@v9@@ = * ( _QWORD * ) ( @@a6@@ + Number ) ; @@v28@@ [ Number ] = * ( _QWORD * ) ( @@a6@@ + Number ) ; @@v28@@ [ Number ] = @@v9@@ ; @@v10@@ = * ( _QWORD * ) ( @@a6@@ + Number ) ; @@v28@@ [ Number ] = * ( _QWORD * ) ( @@a6@@ + Number ) ; @@v28@@ [ Number ] = @@v10@@ ; @@v11@@ = * ( _QWORD * ) ( @@a6@@ + Number ) ; @@v28@@ [ Number ] = * ( _QWORD * ) ( @@a6@@ + Number ) ; @@v28@@ [ Number ] = @@v11@@ ; @@v28@@ [ Number ] = * ( _QWORD * ) ( @@a6@@ + Number ) ; @@v23@@ = Number ; @@v25@@ = ( void * ) savedir ( @@a1@@ ) ; if ( @@v25@@ ) { if ( * ( _DWORD * ) ( @@a6@@ + Number ) == Number ) HIDWORD ( @@v28@@ [ Number ] ) = Number ; for ( @@s@@ = ( char * ) @@v25@@ ; * @@s@@ ; @@s@@ += @@v17@@ + Number ) { @@v26@@ = ( void * ) file_name_concat ( @@a1@@ , @@s@@ , Number L ) ; @@ptr@@ = ( void * ) file_name_concat ( @@a2@@ , @@s@@ , Number L ) ; @@v16@@ = copy_internal ( ( _DWORD ) @@v26@@ , ( _DWORD ) @@ptr@@ , @@a3@@ , * @@a4@@ , @@a5@@ , ( unsigned int ) @@v28@@ , Number , @@a7@@ , ( __int64 ) & @@v22@@ , Number L ) ; @@v23@@ = ( @@v23@@ & @@v16@@ ) != Number ; * @@a8@@ = ( unsigned __int8 ) ( * @@a8@@ | @@v22@@ ) != Number ; free ( @@ptr@@ ) ; free ( @@v26@@ ) ; if ( @@v22@@ ) break ; @@v17@@ = strlen ( @@s@@ ) ; } free ( @@v25@@ ) ; @@result@@ = @@v23@@ ; } else { @@v12@@ = quote ( @@a1@@ ) ; @@v13@@ = gettext ( String ) ; @@v14@@ = __errno_location ( ) ; error ( Number , * @@v14@@ , @@v13@@ , @@v12@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
int __xstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _xstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
int fchdir ( int @@fd@@ ) { return fchdir ( @@fd@@ ) ; }
__int64 __fastcall set_cloexec_flag ( int @@a1@@ , char @@a2@@ , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { int @@v6@@ ; int @@v7@@ ; int @@v8@@ ; unsigned int @@v9@@ ; __int64 @@result@@ ; int @@v11@@ ; @@v11@@ = rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( @@v11@@ < Number || ( ! @@a2@@ ? ( @@v9@@ = @@v11@@ & Number ) : ( @@v9@@ = @@v11@@ | Number ) , @@v11@@ != @@v9@@ && ( unsigned int ) rpl_fcntl ( @@a1@@ , Number , @@v9@@ , @@v6@@ , @@v7@@ , @@v8@@ ) == Number ) ) { @@result@@ = Number ; } else { @@result@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
int __fastcall rpl_fflush ( FILE * @@a1@@ ) { if ( ! @@a1@@ || ! __freading ( @@a1@@ ) ) return fflush ( @@a1@@ ) ; clear_ungetc_buffer_preserving_position ( @@a1@@ ) ; return fflush ( @@a1@@ ) ; }
unsigned __int64 __fastcall forget_created ( __int64 @@a1@@ , __int64 @@a2@@ ) { void * * @@v3@@ ; __int64 @@v4@@ [ Number ] ; unsigned __int64 @@v5@@ ; @@v5@@ = __readfsqword ( Number ) ; @@v4@@ [ Number ] = @@a1@@ ; @@v4@@ [ Number ] = @@a2@@ ; @@v4@@ [ Number ] = Number L ; @@v3@@ = ( void * * ) hash_delete ( src_to_dest , @@v4@@ ) ; if ( @@v3@@ ) src_to_dest_free ( @@v3@@ ) ; return __readfsqword ( Number ) ^ @@v5@@ ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
int __fastcall rpl_fseeko ( FILE * @@a1@@ , __off_t @@a2@@ , int @@a3@@ ) { __off_t @@v3@@ ; int @@v4@@ ; int @@result@@ ; if ( @@a1@@ -> _IO_read_end != @@a1@@ -> _IO_read_ptr || @@a1@@ -> _IO_write_ptr != @@a1@@ -> _IO_write_base || @@a1@@ -> _IO_save_base ) { goto LABEL_13 ; } if ( @@a3@@ == Number && @@a2@@ > Number ) @@v3@@ = Number L ; else @@v3@@ = @@a2@@ ; @@v4@@ = fileno ( @@a1@@ ) ; if ( lseek ( @@v4@@ , @@v3@@ , @@a3@@ ) == Number ) return Number ; @@a1@@ -> _flags &= Number ; if ( @@a3@@ == Number && @@a2@@ > Number ) LABEL_13 : @@result@@ = fseeko ( @@a1@@ , @@a2@@ , @@a3@@ ) ; else @@result@@ = Number ; return @@result@@ ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
unsigned __int64 __fastcall leave_dir ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 * @@v3@@ ; __int64 * @@v4@@ ; void * @@ptr@@ ; __int64 @@v6@@ [ Number ] ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v3@@ = ( __int64 * ) ( @@a2@@ + Number ) ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { @@v6@@ [ Number ] = * @@v3@@ ; @@v6@@ [ Number ] = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@ptr@@ = ( void * ) hash_delete ( * ( _QWORD * ) ( @@a1@@ + Number ) , @@v6@@ ) ; if ( ! @@ptr@@ ) abort ( ) ; free ( @@ptr@@ ) ; } else { @@v4@@ = * ( __int64 * * ) ( @@a2@@ + Number ) ; if ( @@v4@@ && @@v4@@ [ Number ] >= Number ) { if ( ! * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L ) ) abort ( ) ; if ( * * ( _QWORD * * ) ( @@a1@@ + Number ) == * ( _QWORD * ) ( @@a2@@ + Number ) && * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L ) == * @@v3@@ ) { * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L ) = @@v4@@ [ Number ] ; * * ( _QWORD * * ) ( @@a1@@ + Number ) = @@v4@@ [ Number ] ; } } } return __readfsqword ( Number ) ^ @@v7@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
void __fastcall record_file ( __int64 @@a1@@ , __int64 @@a2@@ , _QWORD * @@a3@@ ) { _QWORD * @@v4@@ ; __int64 @@v5@@ ; if ( @@a1@@ ) { @@v4@@ = ( _QWORD * ) xmalloc ( Number L ) ; * @@v4@@ = xstrdup ( @@a2@@ ) ; @@v4@@ [ Number ] = @@a3@@ [ Number ] ; @@v4@@ [ Number ] = * @@a3@@ ; @@v5@@ = hash_insert ( @@a1@@ , @@v4@@ ) ; if ( ! @@v5@@ ) xalloc_die ( ) ; if ( ( _QWORD * ) @@v5@@ != @@v4@@ ) triple_free ( @@v4@@ ) ; } }
__int64 __fastcall rpl_fcntl ( int @@a1@@ , int @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , __m128 @@a7@@ , __m128 @@a8@@ , __m128 @@a9@@ , __m128 @@a10@@ , __m128 @@a11@@ , __m128 @@a12@@ , __m128 @@a13@@ , __m128 @@a14@@ ) { int @@v14@@ ; int @@v15@@ ; int @@v16@@ ; int @@v18@@ ; int @@v19@@ ; int @@v20@@ ; int @@v21@@ ; __int64 @@v22@@ ; __int64 @@v23@@ ; __int64 @@v24@@ ; __int64 @@v25@@ ; __m128 @@v26@@ ; __m128 @@v27@@ ; __m128 @@v28@@ ; __m128 @@v29@@ ; __m128 @@v30@@ ; __m128 @@v31@@ ; __m128 @@v32@@ ; __m128 @@v33@@ ; @@v22@@ = @@a3@@ ; @@v23@@ = @@a4@@ ; @@v24@@ = @@a5@@ ; @@v25@@ = @@a6@@ ; @@v26@@ = @@a7@@ ; @@v27@@ = @@a8@@ ; @@v28@@ = @@a9@@ ; @@v29@@ = @@a10@@ ; @@v30@@ = @@a11@@ ; @@v31@@ = @@a12@@ ; @@v32@@ = @@a13@@ ; @@v33@@ = @@a14@@ ; if ( @@a2@@ != Number ) return ( unsigned int ) fcntl ( @@a1@@ , @@a2@@ , @@v22@@ ) ; @@v19@@ = @@v22@@ ; if ( have_dupfd_cloexec_2895 < Number ) { @@v18@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v22@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; } else { @@v18@@ = fcntl ( @@a1@@ , Number , ( unsigned int ) @@v22@@ ) ; if ( @@v18@@ < Number && * __errno_location ( ) == Number ) { @@v18@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v19@@ , @@v14@@ , @@v15@@ , @@v16@@ ) ; if ( @@v18@@ < Number ) return ( unsigned int ) @@v18@@ ; have_dupfd_cloexec_2895 = Number ; } else { have_dupfd_cloexec_2895 = Number ; } } if ( @@v18@@ >= Number && have_dupfd_cloexec_2895 == Number ) { @@v20@@ = fcntl ( @@v18@@ , Number ) ; if ( @@v20@@ < Number || fcntl ( @@v18@@ , Number , @@v20@@ | Number ) == Number ) { @@v21@@ = * __errno_location ( ) ; close ( @@v18@@ ) ; * __errno_location ( ) = @@v21@@ ; @@v18@@ = Number ; } } return ( unsigned int ) @@v18@@ ; }
__int64 __fastcall cache_stat_init ( __int64 @@a1@@ ) { * ( _QWORD * ) ( @@a1@@ + Number ) = Number ; return @@a1@@ ; }
__locale_t newlocale ( int @@category_mask@@ , const char * @@locale@@ , __locale_t @@base@@ ) { return newlocale ( @@category_mask@@ , @@locale@@ , @@base@@ ) ; }
_BOOL8 __fastcall dirent_inode_sort_may_be_useful ( int @@a1@@ ) { struct statfs @@buf@@ ; unsigned __int64 @@v3@@ ; @@v3@@ = __readfsqword ( Number ) ; if ( fstatfs ( @@a1@@ , & @@buf@@ ) ) return Number L ; return @@buf@@ . f_type != Number && @@buf@@ . f_type != Number ; }
time_t mktime ( struct tm * @@tp@@ ) { return mktime ( @@tp@@ ) ; }
unsigned __int64 __fastcall triple_hash ( _QWORD * @@a1@@ , unsigned __int64 @@a2@@ ) { return ( ( unsigned __int64 ) hash_pjw ( * @@a1@@ , @@a2@@ ) ^ @@a1@@ [ Number ] ) % @@a2@@ ; }
int __fastcall lstat ( char * @@filename@@ , struct stat * @@stat_buf@@ ) { return __lxstat ( Number , @@filename@@ , @@stat_buf@@ ) ; }
bool __fastcall LCO_compare ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { return * @@a1@@ == * @@a2@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
__int64 __fastcall write_protected_non_symlink ( int @@a1@@ , char * @@a2@@ , const char * @@a3@@ , struct stat * @@a4@@ ) { if ( ( unsigned __int8 ) can_write_any_file ( ) ) return Number L ; if ( ( unsigned int ) cache_fstatat ( @@a1@@ , @@a2@@ , @@a4@@ , Number ) ) return Number ; if ( ( @@a4@@ -> st_mode & Number ) == Number ) return Number L ; if ( ! faccessat ( @@a1@@ , @@a2@@ , Number , Number ) ) return Number L ; if ( strlen ( @@a3@@ ) > Number ) return ( unsigned __int8 ) euidaccess_stat ( @@a4@@ , Number L ) ^ Number ; if ( ! euidaccess ( @@a3@@ , Number ) ) return Number L ; if ( * __errno_location ( ) != Number ) return Number ; * __errno_location ( ) = Number ; return Number L ; }
int rpmatch ( const char * @@response@@ ) { return rpmatch ( @@response@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
__int64 __fastcall link_count_optimize_ok ( __int64 @@a1@@ ) { __int64 @@result@@ ; bool @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; _BYTE * @@ptr@@ ; __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v3@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; if ( ( * ( _DWORD * ) ( @@v4@@ + Number ) & Number ) == Number ) return Number L ; if ( ! @@v3@@ ) { * ( _QWORD * ) ( @@v4@@ + Number ) = hash_initialize ( Number L , Number L , LCO_hash , LCO_compare , & free ) ; @@v3@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; if ( ! @@v3@@ ) return Number L ; } @@v8@@ [ Number ] = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v5@@ = hash_lookup ( @@v3@@ , @@v8@@ ) ; if ( @@v5@@ ) return * ( unsigned __int8 * ) ( @@v5@@ + Number ) ; @@ptr@@ = malloc ( Number ) ; if ( ! @@ptr@@ ) return Number L ; @@v2@@ = leaf_optimization_applies ( * ( _DWORD * ) ( @@v4@@ + Number ) ) ; @@ptr@@ [ Number ] = @@v2@@ ; * ( _QWORD * ) @@ptr@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v6@@ = hash_insert ( @@v3@@ , @@ptr@@ ) ; if ( @@v6@@ ) { if ( ( _BYTE * ) @@v6@@ != @@ptr@@ ) abort ( ) ; @@result@@ = @@v2@@ ; } else { free ( @@ptr@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
struct dirent * readdir ( DIR * @@dirp@@ ) { return readdir ( @@dirp@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
__int64 __fastcall iso_week_days ( int @@a1@@ , int @@a2@@ ) { return ( unsigned int ) ( @@a1@@ - ( @@a1@@ - @@a2@@ + Number ) % Number + Number ) ; }
__int64 __fastcall fts_padjust ( __int64 @@a1@@ , _QWORD * @@a2@@ ) { _QWORD * @@v2@@ ; __int64 @@result@@ ; _QWORD * @@i@@ ; __int64 @@v6@@ ; @@v6@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; for ( @@i@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; @@i@@ ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { if ( ( _QWORD * ) @@i@@ [ Number ] != @@i@@ + Number ) @@i@@ [ Number ] = @@v6@@ + @@i@@ [ Number ] - @@i@@ [ Number ] ; @@i@@ [ Number ] = @@v6@@ ; } while ( Number ) { @@result@@ = @@a2@@ [ Number ] ; if ( @@result@@ < Number ) break ; if ( ( _QWORD * ) @@a2@@ [ Number ] != @@a2@@ + Number ) @@a2@@ [ Number ] = @@v6@@ + @@a2@@ [ Number ] - @@a2@@ [ Number ] ; @@a2@@ [ Number ] = @@v6@@ ; if ( @@a2@@ [ Number ] ) @@v2@@ = ( _QWORD * ) @@a2@@ [ Number ] ; else @@v2@@ = ( _QWORD * ) @@a2@@ [ Number ] ; @@a2@@ = @@v2@@ ; } return @@result@@ ; }
int iswspace ( wint_t @@wc@@ ) { return iswspace ( @@wc@@ ) ; }
__int64 __fastcall hash_get_n_buckets ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int64 __fastcall fprintftime ( FILE * @@a1@@ , char * @@a2@@ , __int64 @@a3@@ , unsigned int @@a4@@ , unsigned int @@a5@@ ) { return strftime_case_ ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; }
__int64 __fastcall hash_get_n_buckets_used ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
void __fastcall argmatch_invalid ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { char * @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; char * @@format@@ ; if ( @@a3@@ == Number ) @@v3@@ = gettext ( String ) ; else @@v3@@ = gettext ( String ) ; @@format@@ = @@v3@@ ; @@v4@@ = quote_n ( Number L , @@a1@@ ) ; @@v5@@ = quotearg_n_style ( Number L , Number L , @@a2@@ ) ; error ( Number , Number , @@format@@ , @@v5@@ , @@v4@@ ) ; }
char * strdup ( const char * @@s@@ ) { return strdup ( @@s@@ ) ; }
__int64 __fastcall argmatch ( const char * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { __int64 @@result@@ ; char @@v7@@ ; __int64 @@i@@ ; __int64 @@v9@@ ; size_t @@n@@ ; @@v9@@ = Number ; @@v7@@ = Number ; @@n@@ = strlen ( @@a1@@ ) ; for ( @@i@@ = Number L ; * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; ++ @@i@@ ) { if ( ! strncmp ( * ( const char * * ) ( Number * @@i@@ + @@a2@@ ) , @@a1@@ , @@n@@ ) ) { if ( @@n@@ == strlen ( * ( const char * * ) ( Number * @@i@@ + @@a2@@ ) ) ) return @@i@@ ; if ( @@v9@@ == Number ) { @@v9@@ = @@i@@ ; } else if ( ! @@a3@@ || memcmp ( ( const void * ) ( @@a4@@ * @@v9@@ + @@a3@@ ) , ( const void * ) ( @@i@@ * @@a4@@ + @@a3@@ ) , @@a4@@ ) ) { @@v7@@ = Number ; } } } if ( @@v7@@ ) @@result@@ = Number ; else @@result@@ = @@v9@@ ; return @@result@@ ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
unsigned __int64 __fastcall hash_get_max_bucket_length ( __int64 @@a1@@ ) { _QWORD * @@i@@ ; unsigned __int64 @@v3@@ ; _QWORD * @@v4@@ ; unsigned __int64 @@j@@ ; @@v3@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { @@v4@@ = @@i@@ ; for ( @@j@@ = Number L ; ; ++ @@j@@ ) { @@v4@@ = ( _QWORD * ) @@v4@@ [ Number ] ; if ( ! @@v4@@ ) break ; } if ( @@j@@ > @@v3@@ ) @@v3@@ = @@j@@ ; } } return @@v3@@ ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
unsigned __int64 __fastcall check_extension ( const char * @@a1@@ , __int64 @@a2@@ , char @@a3@@ ) { unsigned __int64 @@v5@@ ; unsigned __int64 @@v6@@ ; char * @@v7@@ ; unsigned __int64 @@v8@@ ; __int64 @@v9@@ ; __int16 @@v10@@ ; unsigned __int64 @@v11@@ ; @@v11@@ = __readfsqword ( Number ) ; @@v7@@ = ( char * ) last_component ( @@a1@@ ) ; @@v5@@ = base_len ( @@v7@@ ) ; @@v8@@ = Number L ; if ( @@v5@@ > Number ) { @@v10@@ = * ( _WORD * ) @@v7@@ ; * ( _WORD * ) @@v7@@ = Number ; * __errno_location ( ) = Number ; @@v9@@ = pathconf ( @@a1@@ , Number ) ; if ( @@v9@@ >= Number || ! * __errno_location ( ) ) @@v8@@ = @@v9@@ ; * ( _WORD * ) @@v7@@ = @@v10@@ ; } if ( @@v8@@ < @@v5@@ ) { @@v6@@ = & @@a1@@ [ @@a2@@ ] - @@v7@@ ; if ( @@v8@@ <= @@v6@@ ) @@v6@@ = @@v8@@ - Number ; @@v7@@ [ @@v6@@ ] = @@a3@@ ; @@v7@@ [ @@v6@@ + Number ] = Number ; } return __readfsqword ( Number ) ^ @@v11@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name_0 ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name_0 ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
__int64 __fastcall hash_lookup ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; _QWORD * @@i@@ ; _QWORD * @@v5@@ ; @@v2@@ = * @@a1@@ ; @@v5@@ = ( _QWORD * ) ( @@v2@@ + Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) ) ; if ( ( unsigned __int64 ) @@v5@@ >= @@a1@@ [ Number ] ) abort ( ) ; if ( ! * @@v5@@ ) return Number L ; for ( @@i@@ = @@v5@@ ; @@i@@ ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { if ( @@a2@@ == * @@i@@ || ( ( unsigned __int8 ( __fastcall * ) ( __int64 , _QWORD ) ) @@a1@@ [ Number ] ) ( @@a2@@ , * @@i@@ ) ) { return * @@i@@ ; } } return Number L ; }
void __fastcall decode_preserve_arg ( __int64 @@a1@@ , _BYTE * @@a2@@ , char @@a3@@ ) { char * @@v3@@ ; char * @@s@@ ; char * @@v6@@ ; char * @@ptr@@ ; @@ptr@@ = ( char * ) xstrdup ( @@a1@@ ) ; @@s@@ = @@ptr@@ ; do { @@v6@@ = strchr ( @@s@@ , Number ) ; if ( @@v6@@ ) { @@v3@@ = @@v6@@ ++ ; * @@v3@@ = Number ; } switch ( _xargmatch_internal ( String , @@s@@ , preserve_args_5954 , & preserve_vals_5953 , Number L , argmatch_die ) ) { case Number L : case Number L : @@a2@@ [ Number ] = @@a3@@ ; break ; case Number L : @@a2@@ [ Number ] = @@a3@@ ; break ; case Number L : @@a2@@ [ Number ] = @@a3@@ ; break ; case Number L : @@a2@@ [ Number ] = @@a3@@ ; break ; case Number L : @@a2@@ [ Number ] = @@a3@@ ; @@a2@@ [ Number ] = @@a3@@ ; break ; case Number L : @@a2@@ [ Number ] = @@a3@@ ; @@a2@@ [ Number ] = @@a3@@ ; break ; case Number L : @@a2@@ [ Number ] = @@a3@@ ; @@a2@@ [ Number ] = @@a3@@ ; @@a2@@ [ Number ] = @@a3@@ ; @@a2@@ [ Number ] = @@a3@@ ; if ( selinux_enabled ) @@a2@@ [ Number ] = @@a3@@ ; @@a2@@ [ Number ] = @@a3@@ ; break ; default : abort ( ) ; } @@s@@ = @@v6@@ ; } while ( @@v6@@ ) ; free ( @@ptr@@ ) ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name_0 ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name_0 ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , off_186B1 , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
_BOOL8 __fastcall AD_compare ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { return @@a1@@ [ Number ] == @@a2@@ [ Number ] && * @@a1@@ == * @@a2@@ ; }
_BYTE * __fastcall longest_relative_suffix ( _BYTE * @@a1@@ ) { while ( * @@a1@@ == Number ) ++ @@a1@@ ; return @@a1@@ ; }
unsigned __int64 __fastcall hash_string ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ ) { unsigned __int64 @@v4@@ ; @@v4@@ = Number L ; while ( * @@a1@@ ) @@v4@@ = ( Number * @@v4@@ + ( unsigned __int8 ) * @@a1@@ ++ ) % @@a2@@ ; return @@v4@@ ; }
_BOOL8 __fastcall errno_unsupported ( int @@a1@@ ) { return @@a1@@ == Number || @@a1@@ == Number ; }
unsigned __int64 __fastcall raw_hasher ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return rotr_sz ( @@a1@@ , Number ) % @@a2@@ ; }
_BOOL8 __fastcall writable_destination ( const char * @@a1@@ , __int16 @@a2@@ ) { return ( @@a2@@ & Number ) == Number || ( unsigned __int8 ) can_write_any_file ( ) || ! euidaccess ( @@a1@@ , Number ) ; }
__int64 __fastcall setup_dir ( __int64 @@a1@@ ) { if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { * ( _QWORD * ) ( @@a1@@ + Number ) = hash_initialize ( Number L , Number L , AD_hash , AD_compare , & free ) ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; } else { * ( _QWORD * ) ( @@a1@@ + Number ) = malloc ( Number ) ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; cycle_check_init ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ; } return Number L ; }
int __fastcall rpl_fseeko ( FILE * @@a1@@ , __off_t @@a2@@ , int @@a3@@ ) { __off_t @@v3@@ ; int @@v4@@ ; int @@result@@ ; if ( @@a1@@ -> _IO_read_end != @@a1@@ -> _IO_read_ptr || @@a1@@ -> _IO_write_ptr != @@a1@@ -> _IO_write_base || @@a1@@ -> _IO_save_base ) { goto LABEL_13 ; } if ( @@a3@@ == Number && @@a2@@ > Number ) @@v3@@ = Number L ; else @@v3@@ = @@a2@@ ; @@v4@@ = fileno ( @@a1@@ ) ; if ( lseek ( @@v4@@ , @@v3@@ , @@a3@@ ) == Number ) return Number ; @@a1@@ -> _flags &= Number ; if ( @@a3@@ == Number && @@a2@@ > Number ) LABEL_13 : @@result@@ = fseeko ( @@a1@@ , @@a2@@ , @@a3@@ ) ; else @@result@@ = Number ; return @@result@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
_BOOL8 __fastcall abandon_move ( __int64 @@a1@@ , const char * @@a2@@ , __int64 @@a3@@ ) { bool @@v3@@ ; if ( ! * ( _BYTE * ) ( @@a1@@ + Number ) ) __assert_fail ( String , String , Number , String ) ; @@v3@@ = Number ; if ( * ( _DWORD * ) ( @@a1@@ + Number ) != Number ) { if ( * ( _DWORD * ) ( @@a1@@ + Number ) != Number && ( * ( _DWORD * ) ( @@a1@@ + Number ) != Number || ! * ( _BYTE * ) ( @@a1@@ + Number ) || writable_destination ( @@a2@@ , * ( _DWORD * ) ( @@a3@@ + Number ) ) ) || ( overwrite_prompt ( @@a2@@ , @@a3@@ ) , ( unsigned __int8 ) yesno ( ) == Number ) ) { @@v3@@ = Number ; } } return @@v3@@ ; }
unsigned __int64 __fastcall compute_bucket_size ( __int64 @@a1@@ , __int64 @@a2@@ ) { float @@v2@@ ; unsigned __int64 @@result@@ ; unsigned __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; float @@v6@@ ; @@v4@@ = @@a1@@ ; if ( * ( _BYTE * ) ( @@a2@@ + Number ) != Number ) { if ( @@a1@@ < Number ) @@v2@@ = ( float ) ( @@a1@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@a1@@ >> Number ) ) + ( float ) ( @@a1@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@a1@@ >> Number ) ) ; else @@v2@@ = ( float ) ( int ) @@a1@@ ; @@v6@@ = @@v2@@ / * ( float * ) ( @@a2@@ + Number ) ; if ( @@v6@@ >= Number ) return Number L ; if ( @@v6@@ >= Number ) @@v4@@ = ( unsigned int ) ( int ) ( float ) ( @@v6@@ - Number ) ^ Number ; else @@v4@@ = ( unsigned int ) ( int ) @@v6@@ ; } @@v5@@ = next_prime ( @@v4@@ ) ; if ( @@v5@@ <= Number ) @@result@@ = @@v5@@ ; else @@result@@ = Number L ; return @@result@@ ; }
__int64 __fastcall fts_set_stat_required ( __int64 @@a1@@ , char @@a2@@ ) { __int64 @@v2@@ ; __int64 @@result@@ ; if ( * ( _WORD * ) ( @@a1@@ + Number ) != Number ) abort ( ) ; if ( @@a2@@ ) @@v2@@ = Number L ; else @@v2@@ = Number L ; @@result@@ = @@a1@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v2@@ ; return @@result@@ ; }
__int64 __fastcall hash_get_n_entries ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__int64 __fastcall copy ( char * @@a1@@ , char * @@a2@@ , char @@a3@@ , unsigned int * @@a4@@ , bool * @@a5@@ , _BYTE * @@a6@@ ) { char @@v11@@ ; unsigned __int64 @@v12@@ ; @@v12@@ = __readfsqword ( Number ) ; if ( ! ( unsigned __int8 ) valid_options ( ( __int64 ) @@a4@@ ) ) __assert_fail ( String , String , Number , String ) ; top_level_src_name = ( __int64 ) @@a1@@ ; top_level_dst_name = ( __int64 ) @@a2@@ ; @@v11@@ = Number ; return copy_internal ( @@a1@@ , @@a2@@ , @@a3@@ , Number L , Number L , @@a4@@ , Number , & @@v11@@ , @@a5@@ , @@a6@@ ) ; }
void * __fastcall allocate_entry ( __int64 @@a1@@ ) { __int64 @@v2@@ ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return malloc ( Number ) ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = * ( _QWORD * ) ( @@v2@@ + Number ) ; return ( void * ) @@v2@@ ; }
unsigned __int64 __fastcall src_to_dest_hash ( _QWORD * @@a1@@ , unsigned __int64 @@a2@@ ) { return * @@a1@@ % @@a2@@ ; }
_BOOL8 __fastcall desirable_utmp_entry ( __int64 @@a1@@ , char @@a2@@ ) { bool @@v2@@ ; @@v2@@ = * ( _BYTE * ) ( @@a1@@ + Number ) && * ( _WORD * ) @@a1@@ == Number ; if ( ( @@a2@@ & Number ) != Number && ! @@v2@@ ) return Number L ; return ( @@a2@@ & Number ) == Number || ! @@v2@@ || * ( int * ) ( @@a1@@ + Number ) > Number && ( kill ( * ( _DWORD * ) ( @@a1@@ + Number ) , Number ) >= Number || * __errno_location ( ) != Number ) ; }
__int64 __fastcall diropen ( __int64 @@a1@@ , int @@a2@@ , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { int @@v6@@ ; int @@v8@@ ; unsigned int @@v9@@ ; @@v8@@ = ( * ( _DWORD * ) ( @@a1@@ + Number ) << Number ) & Number | Number ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) @@v6@@ = openat_safer ( * ( _DWORD * ) ( @@a1@@ + Number ) , @@a2@@ , @@v8@@ , @@a2@@ , @@a5@@ , @@a6@@ , @@a2@@ ) ; else @@v6@@ = open_safer ( @@a2@@ , @@v8@@ , @@v8@@ , @@a4@@ , @@a5@@ , @@a6@@ , @@a2@@ ) ; @@v9@@ = @@v6@@ ; if ( @@v6@@ >= Number ) set_cloexec_flag ( ( unsigned int ) @@v6@@ , Number L ) ; return @@v9@@ ; }
unsigned __int64 __fastcall hash_get_max_bucket_length ( __int64 @@a1@@ ) { _QWORD * @@i@@ ; unsigned __int64 @@v3@@ ; _QWORD * @@v4@@ ; unsigned __int64 @@j@@ ; @@v3@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { @@v4@@ = @@i@@ ; for ( @@j@@ = Number L ; ; ++ @@j@@ ) { @@v4@@ = ( _QWORD * ) @@v4@@ [ Number ] ; if ( ! @@v4@@ ) break ; } if ( @@j@@ > @@v3@@ ) @@v3@@ = @@j@@ ; } } return @@v3@@ ; }
__int64 __fastcall free_entry ( __int64 @@a1@@ , _QWORD * @@a2@@ ) { __int64 @@result@@ ; * @@a2@@ = Number L ; @@a2@@ [ Number ] = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@result@@ = @@a1@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
int __fastcall chmod_or_fchmod ( const char * @@a1@@ , int @@a2@@ , __mode_t @@a3@@ ) { int @@result@@ ; if ( @@a2@@ == Number ) @@result@@ = chmod ( @@a1@@ , @@a3@@ ) ; else @@result@@ = fchmod ( @@a2@@ , @@a3@@ ) ; return @@result@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
_BOOL8 __fastcall leaf_optimization_applies ( int @@a1@@ ) { _BOOL8 @@result@@ ; struct statfs @@buf@@ ; unsigned __int64 @@v3@@ ; @@v3@@ = __readfsqword ( Number ) ; if ( fstatfs ( @@a1@@ , & @@buf@@ ) ) @@result@@ = Number L ; else @@result@@ = @@buf@@ . f_type == Number ; return @@result@@ ; }
__int64 __fastcall hash_get_next ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; _QWORD * @@v4@@ ; _QWORD * @@i@@ ; @@v2@@ = * @@a1@@ ; @@v4@@ = ( _QWORD * ) ( @@v2@@ + Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) ) ; if ( ( unsigned __int64 ) @@v4@@ >= @@a1@@ [ Number ] ) abort ( ) ; for ( @@i@@ = @@v4@@ ; @@i@@ ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { if ( @@a2@@ == * @@i@@ && @@i@@ [ Number ] ) return * ( _QWORD * ) @@i@@ [ Number ] ; } while ( Number ) { @@v4@@ += Number ; if ( ( unsigned __int64 ) @@v4@@ >= @@a1@@ [ Number ] ) break ; if ( * @@v4@@ ) return * @@v4@@ ; } return Number L ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 __fastcall fts_compare_ino ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; if ( * ( _QWORD * ) ( * ( _QWORD * ) @@a1@@ + Number L ) < * ( _QWORD * ) ( * ( _QWORD * ) @@a2@@ + Number L ) ) @@result@@ = Number ; else @@result@@ = * ( _QWORD * ) ( * ( _QWORD * ) @@a2@@ + Number L ) < * ( _QWORD * ) ( * ( _QWORD * ) @@a1@@ + Number L ) ; return @@result@@ ; }
char * __fastcall areadlink_with_size ( const char * @@a1@@ , unsigned __int64 @@a2@@ ) { __int64 @@v2@@ ; char * @@i@@ ; int @@v5@@ ; size_t @@size@@ ; char * @@buf@@ ; ssize_t @@v8@@ ; if ( @@a2@@ >= Number ) @@v2@@ = Number L ; else @@v2@@ = @@a2@@ + Number ; @@size@@ = @@v2@@ ; LABEL_5 : for ( @@i@@ = ( char * ) malloc ( @@size@@ ) ; ; @@i@@ = ( char * ) malloc ( Number ) ) { @@buf@@ = @@i@@ ; if ( ! @@i@@ ) return Number L ; @@v8@@ = readlink ( @@a1@@ , @@i@@ , @@size@@ ) ; if ( @@v8@@ < Number && * __errno_location ( ) != Number ) { @@v5@@ = * __errno_location ( ) ; free ( @@buf@@ ) ; * __errno_location ( ) = @@v5@@ ; return Number L ; } if ( @@v8@@ < @@size@@ ) { @@buf@@ [ @@v8@@ ] = Number ; return @@buf@@ ; } free ( @@buf@@ ) ; if ( @@size@@ <= Number ) { @@size@@ *= Number L ; goto LABEL_5 ; } if ( @@size@@ > Number ) break ; @@size@@ = Number ; } * __errno_location ( ) = Number ; return Number L ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
__int64 __fastcall transfer_entries ( __int64 @@a1@@ , __int64 @@a2@@ , char @@a3@@ ) { __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 * @@i@@ ; _QWORD * @@j@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; _QWORD * @@v11@@ ; _QWORD * @@v12@@ ; _QWORD * @@v13@@ ; _QWORD * @@v14@@ ; for ( @@i@@ = * ( __int64 * * ) @@a2@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a2@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = ( _QWORD * ) @@i@@ [ Number ] ; @@j@@ ; @@j@@ = @@v14@@ ) { @@v9@@ = * @@j@@ ; @@v3@@ = * ( _QWORD * ) @@a1@@ ; @@v11@@ = ( _QWORD * ) ( @@v3@@ + Number * ( * ( __int64 ( __fastcall * * ) ( _QWORD , _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@j@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@v11@@ >= * ( _QWORD * ) ( @@a1@@ + Number ) ) abort ( ) ; @@v14@@ = ( _QWORD * ) @@j@@ [ Number ] ; if ( * @@v11@@ ) { @@j@@ [ Number ] = @@v11@@ [ Number ] ; @@v11@@ [ Number ] = @@j@@ ; } else { * @@v11@@ = @@v9@@ ; ++ * ( _QWORD * ) ( @@a1@@ + Number ) ; free_entry ( @@a1@@ , @@j@@ ) ; } } @@v10@@ = * @@i@@ ; @@i@@ [ Number ] = Number L ; if ( ! @@a3@@ ) { @@v4@@ = * ( _QWORD * ) @@a1@@ ; @@v12@@ = ( _QWORD * ) ( @@v4@@ + Number * ( * ( __int64 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@v10@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@v12@@ >= * ( _QWORD * ) ( @@a1@@ + Number ) ) abort ( ) ; if ( * @@v12@@ ) { @@v13@@ = allocate_entry ( @@a1@@ ) ; if ( ! @@v13@@ ) return Number L ; * @@v13@@ = @@v10@@ ; @@v13@@ [ Number ] = @@v12@@ [ Number ] ; @@v12@@ [ Number ] = @@v13@@ ; } else { * @@v12@@ = @@v10@@ ; ++ * ( _QWORD * ) ( @@a1@@ + Number ) ; } * @@i@@ = Number L ; -- * ( _QWORD * ) ( @@a2@@ + Number ) ; } } } return Number L ; }
unsigned __int64 __fastcall compute_bucket_size ( __int64 @@a1@@ , __int64 @@a2@@ ) { float @@v2@@ ; unsigned __int64 @@result@@ ; unsigned __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; float @@v6@@ ; @@v4@@ = @@a1@@ ; if ( * ( _BYTE * ) ( @@a2@@ + Number ) != Number ) { if ( @@a1@@ < Number ) @@v2@@ = ( float ) ( @@a1@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@a1@@ >> Number ) ) + ( float ) ( @@a1@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@a1@@ >> Number ) ) ; else @@v2@@ = ( float ) ( int ) @@a1@@ ; @@v6@@ = @@v2@@ / * ( float * ) ( @@a2@@ + Number ) ; if ( @@v6@@ >= Number ) return Number L ; if ( @@v6@@ >= Number ) @@v4@@ = ( unsigned int ) ( int ) ( float ) ( @@v6@@ - Number ) ^ Number ; else @@v4@@ = ( unsigned int ) ( int ) @@v6@@ ; } @@v5@@ = next_prime ( @@v4@@ ) ; if ( @@v5@@ <= Number ) @@result@@ = @@v5@@ ; else @@result@@ = Number L ; return @@result@@ ; }
__int64 __fastcall set_stat_type ( __int64 @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; int @@v3@@ ; switch ( @@a2@@ ) { case Number : @@v3@@ = Number ; break ; case Number : @@v3@@ = Number ; break ; case Number : @@v3@@ = Number ; break ; case Number : @@v3@@ = Number ; break ; case Number : @@v3@@ = Number ; break ; case Number : @@v3@@ = Number ; break ; case Number : @@v3@@ = Number ; break ; default : @@v3@@ = Number ; break ; } @@result@@ = @@a1@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@v3@@ ; return @@result@@ ; }
const char * __fastcall proper_name ( const char * @@a1@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; char * @@s@@ ; char * @@v5@@ ; @@s@@ = gettext ( @@a1@@ ) ; if ( @@s@@ == @@a1@@ ) return @@a1@@ ; if ( ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@s@@ , ( __int64 ) @@a1@@ ) ) return @@s@@ ; @@v2@@ = strlen ( @@s@@ ) ; @@v3@@ = strlen ( @@a1@@ ) ; @@v5@@ = ( char * ) xmalloc ( @@v2@@ + @@v3@@ + Number ) ; sprintf ( @@v5@@ , String , @@s@@ , @@a1@@ ) ; return @@v5@@ ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
__int64 __fastcall openat_safer ( int @@a1@@ , const char * @@a2@@ , char @@a3@@ , unsigned int @@a4@@ ) { unsigned int @@v4@@ ; unsigned int @@v6@@ ; @@v6@@ = Number ; if ( ( @@a3@@ & Number ) != Number ) @@v6@@ = @@a4@@ ; @@v4@@ = openat ( @@a1@@ , @@a2@@ , @@a3@@ , @@v6@@ ) ; return fd_safer ( @@v4@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
__int64 __fastcall fts_compar ( __int64 @@a1@@ , __int64 @@a2@@ ) { return ( * ( __int64 ( __fastcall * * ) ( __int64 , __int64 ) ) ( * ( _QWORD * ) ( * ( _QWORD * ) @@a1@@ + Number L ) + Number L ) ) ( @@a1@@ , @@a2@@ ) ; }
void * __fastcall allocate_entry ( __int64 @@a1@@ ) { __int64 @@v2@@ ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return malloc ( Number ) ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = * ( _QWORD * ) ( @@v2@@ + Number ) ; return ( void * ) @@v2@@ ; }
__int64 __fastcall xstr_cd_iconv ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v3@@ ; @@v3@@ = str_cd_iconv ( @@a1@@ , @@a2@@ ) ; if ( ! @@v3@@ && * __errno_location ( ) == Number ) xalloc_die ( ) ; return @@v3@@ ; }
int toupper ( int @@c@@ ) { return toupper ( @@c@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall fts_palloc ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; unsigned __int64 @@v3@@ ; void * @@v4@@ ; @@v3@@ = * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ + Number ; if ( @@v3@@ >= * ( _QWORD * ) ( @@a1@@ + Number ) ) { * ( _QWORD * ) ( @@a1@@ + Number ) = @@v3@@ ; @@v4@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , * ( _QWORD * ) ( @@a1@@ + Number ) ) ; if ( @@v4@@ ) { * ( _QWORD * ) ( @@a1@@ + Number ) = @@v4@@ ; @@result@@ = Number L ; } else { free ( * ( void * * ) ( @@a1@@ + Number ) ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; @@result@@ = Number L ; } } else { free ( * ( void * * ) ( @@a1@@ + Number ) ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * __errno_location ( ) = Number ; @@result@@ = Number L ; } return @@result@@ ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
unsigned __int64 __fastcall buffer_lcm ( unsigned __int64 @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { __int64 @@v3@@ ; unsigned __int64 @@result@@ ; unsigned __int64 @@v5@@ ; unsigned __int64 @@v6@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@v8@@ ; if ( @@a1@@ ) { if ( @@a2@@ ) { @@v6@@ = @@a1@@ ; for ( @@i@@ = @@a2@@ ; ; @@i@@ = @@v8@@ ) { @@v8@@ = @@v6@@ % @@i@@ ; if ( ! ( @@v6@@ % @@i@@ ) ) break ; @@v6@@ = @@i@@ ; } if ( @@a2@@ * ( @@a1@@ / @@i@@ ) <= @@a3@@ && @@a1@@ / @@i@@ == @@a2@@ * ( @@a1@@ / @@i@@ ) / @@a2@@ ) { return @@a2@@ * ( @@a1@@ / @@i@@ ) ; } } @@v5@@ = @@a1@@ ; } else { if ( @@a2@@ ) @@v3@@ = @@a2@@ ; else @@v3@@ = Number ; @@v5@@ = @@v3@@ ; } @@result@@ = @@a3@@ ; if ( @@v5@@ <= @@a3@@ ) @@result@@ = @@v5@@ ; return @@result@@ ; }
__int64 __fastcall transfer_entries ( __int64 @@a1@@ , __int64 @@a2@@ , char @@a3@@ ) { __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 * @@i@@ ; _QWORD * @@j@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; _QWORD * @@v11@@ ; _QWORD * @@v12@@ ; _QWORD * @@v13@@ ; _QWORD * @@v14@@ ; for ( @@i@@ = * ( __int64 * * ) @@a2@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a2@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = ( _QWORD * ) @@i@@ [ Number ] ; @@j@@ ; @@j@@ = @@v14@@ ) { @@v9@@ = * @@j@@ ; @@v3@@ = * ( _QWORD * ) @@a1@@ ; @@v11@@ = ( _QWORD * ) ( @@v3@@ + Number * ( * ( __int64 ( __fastcall * * ) ( _QWORD , _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@j@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@v11@@ >= * ( _QWORD * ) ( @@a1@@ + Number ) ) abort ( ) ; @@v14@@ = ( _QWORD * ) @@j@@ [ Number ] ; if ( * @@v11@@ ) { @@j@@ [ Number ] = @@v11@@ [ Number ] ; @@v11@@ [ Number ] = @@j@@ ; } else { * @@v11@@ = @@v9@@ ; ++ * ( _QWORD * ) ( @@a1@@ + Number ) ; free_entry ( @@a1@@ , @@j@@ ) ; } } @@v10@@ = * @@i@@ ; @@i@@ [ Number ] = Number L ; if ( ! @@a3@@ ) { @@v4@@ = * ( _QWORD * ) @@a1@@ ; @@v12@@ = ( _QWORD * ) ( @@v4@@ + Number * ( * ( __int64 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@v10@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@v12@@ >= * ( _QWORD * ) ( @@a1@@ + Number ) ) abort ( ) ; if ( * @@v12@@ ) { @@v13@@ = allocate_entry ( @@a1@@ ) ; if ( ! @@v13@@ ) return Number L ; * @@v13@@ = @@v10@@ ; @@v13@@ [ Number ] = @@v12@@ [ Number ] ; @@v12@@ [ Number ] = @@v13@@ ; } else { * @@v12@@ = @@v10@@ ; ++ * ( _QWORD * ) ( @@a1@@ + Number ) ; } * @@i@@ = Number L ; -- * ( _QWORD * ) ( @@a2@@ + Number ) ; } } } return Number L ; }
size_t __fastcall fts_maxarglen ( const char * * @@a1@@ ) { size_t @@v3@@ ; size_t @@v4@@ ; @@v3@@ = Number L ; while ( * @@a1@@ ) { @@v4@@ = strlen ( * @@a1@@ ) ; if ( @@v4@@ > @@v3@@ ) @@v3@@ = @@v4@@ ; ++ @@a1@@ ; } return @@v3@@ + Number ; }
int __fxstat ( int @@ver@@ , int @@fildes@@ , struct stat * @@stat_buf@@ ) { return _fxstat ( @@ver@@ , @@fildes@@ , @@stat_buf@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
__int64 __fastcall _xargmatch_internal ( __int64 @@a1@@ , const char * @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ , void ( * @@a6@@ ) ( void ) ) { __int64 @@v11@@ ; @@v11@@ = argmatch ( @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; if ( @@v11@@ >= Number ) return @@v11@@ ; argmatch_invalid ( @@a1@@ , ( __int64 ) @@a2@@ , @@v11@@ ) ; argmatch_valid ( @@a3@@ , @@a4@@ , @@a5@@ ) ; @@a6@@ ( ) ; return Number ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
void * __fastcall find_backup_file_name ( const char * @@a1@@ , int @@a2@@ ) { int @@v2@@ ; bool @@v4@@ ; void * @@dest@@ ; size_t @@v6@@ ; __int64 @@v7@@ ; size_t @@n@@ ; unsigned __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; @@v10@@ = __readfsqword ( Number ) ; @@v7@@ = strlen ( @@a1@@ ) ; @@v4@@ = Number ; @@n@@ = strlen ( simple_backup_suffix ) + Number ; @@v6@@ = @@n@@ ; if ( @@n@@ <= Number ) @@v6@@ = Number L ; @@v9@@ = @@v7@@ + @@v6@@ + Number ; @@dest@@ = ( void * ) xmalloc ( @@v9@@ ) ; memcpy ( @@dest@@ , @@a1@@ , @@v7@@ + Number ) ; if ( @@a2@@ != Number ) { @@v2@@ = numbered_backup ( ( __int64 * ) & @@dest@@ , @@v9@@ , @@v7@@ ) ; switch ( @@v2@@ ) { case Number : @@v4@@ = Number ; break ; case Number : return @@dest@@ ; case Number : @@v4@@ = @@a2@@ == Number ; break ; } } if ( @@v4@@ ) memcpy ( ( char * ) @@dest@@ + @@v7@@ , simple_backup_suffix , @@n@@ ) ; check_extension ( ( const char * ) @@dest@@ , @@v7@@ , Number ) ; return @@dest@@ ; }
__int64 __fastcall fts_safe_changedir ( __int64 @@a1@@ , __int64 @@a2@@ , int @@a3@@ , const char * @@a4@@ , int @@a5@@ , int @@a6@@ ) { bool @@v6@@ ; char * @@s1@@ ; char @@v10@@ ; unsigned int @@v11@@ ; int @@fildes@@ ; int @@v13@@ ; int @@v14@@ ; struct stat @@v15@@ ; unsigned __int64 @@v16@@ ; @@s1@@ = ( char * ) @@a4@@ ; @@v16@@ = __readfsqword ( Number ) ; @@v6@@ = @@a4@@ && ! strcmp ( @@a4@@ , String ) ; @@v10@@ = @@v6@@ ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number && @@a3@@ >= Number ) close ( @@a3@@ ) ; return Number L ; } if ( @@a3@@ < Number ) { if ( @@v10@@ ) { if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number && ( unsigned __int8 ) i_ring_empty ( @@a1@@ + Number ) != Number ) { @@v13@@ = i_ring_pop ( @@a1@@ + Number ) ; @@v10@@ = Number ; if ( @@v13@@ >= Number ) { @@a3@@ = @@v13@@ ; @@s1@@ = Number L ; } } } } @@fildes@@ = @@a3@@ ; if ( @@a3@@ < Number ) { @@fildes@@ = diropen ( @@a1@@ , ( int ) @@s1@@ , ( __int64 ) @@s1@@ , ( int ) @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( @@fildes@@ < Number ) return Number ; } if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) == Number && ( ! @@s1@@ || strcmp ( @@s1@@ , String ) ) ) goto LABEL_27 ; if ( ! ( unsigned int ) fstat ( @@fildes@@ , & @@v15@@ ) ) { if ( * ( _QWORD * ) ( @@a2@@ + Number ) != @@v15@@ . st_dev || * ( _QWORD * ) ( @@a2@@ + Number ) != @@v15@@ . st_ino ) { * __errno_location ( ) = Number ; @@v11@@ = Number ; goto LABEL_30 ; } LABEL_27 : if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { cwd_advance_fd ( @@a1@@ , @@fildes@@ , @@v10@@ == Number ) ; return Number L ; } @@v11@@ = fchdir ( @@fildes@@ ) ; goto LABEL_30 ; } @@v11@@ = Number ; LABEL_30 : if ( @@a3@@ < Number ) { @@v14@@ = * __errno_location ( ) ; close ( @@fildes@@ ) ; * __errno_location ( ) = @@v14@@ ; } return @@v11@@ ; }
unsigned __int64 print_stats ( ) { __int64 @@v0@@ ; __int64 @@v1@@ ; __int64 @@v2@@ ; __int64 @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; char * @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; char * @@v11@@ ; unsigned __int64 @@v12@@ ; double @@v13@@ ; char * @@v14@@ ; double @@v16@@ ; char * @@v17@@ ; __int64 @@v18@@ ; char @@v19@@ [ Number ] ; unsigned __int64 @@v20@@ ; @@v20@@ = __readfsqword ( Number ) ; @@v18@@ = gethrxtime ( ) ; @@v0@@ = w_partial ; @@v1@@ = w_full ; @@v2@@ = r_partial ; @@v3@@ = r_full ; @@v4@@ = gettext ( String ) ; fprintf ( stderr , @@v4@@ , @@v3@@ , @@v2@@ , @@v1@@ , @@v0@@ ) ; if ( r_truncate ) { @@v5@@ = r_truncate ; @@v6@@ = select_plural ( r_truncate ) ; @@v7@@ = ngettext ( String , String , @@v6@@ ) ; fprintf ( stderr , @@v7@@ , @@v5@@ ) ; } if ( ( status_flags & Number ) == Number ) { @@v8@@ = human_readable ( w_bytes , @@v19@@ , Number L , Number L , Number L ) ; @@v9@@ = w_bytes ; @@v10@@ = select_plural ( w_bytes ) ; @@v11@@ = ngettext ( String , String , @@v10@@ ) ; fprintf ( stderr , @@v11@@ , @@v9@@ , @@v8@@ ) ; if ( @@v18@@ <= start_time ) { @@v16@@ = Number ; @@v17@@ = gettext ( String ) ; } else { @@v12@@ = @@v18@@ - start_time ; if ( @@v18@@ - start_time < Number ) @@v13@@ = ( double ) ( int ) ( @@v12@@ & Number | ( @@v12@@ >> Number ) ) + ( double ) ( int ) ( @@v12@@ & Number | ( @@v12@@ >> Number ) ) ; else @@v13@@ = ( double ) ( int ) @@v12@@ ; @@v16@@ = @@v13@@ / Number ; @@v17@@ = ( char * ) human_readable ( w_bytes , @@v19@@ , Number L , Number L , @@v18@@ - start_time ) ; } @@v14@@ = gettext ( String ) ; fprintf ( stderr , @@v14@@ , @@v17@@ , @@v16@@ ) ; } return __readfsqword ( Number ) ^ @@v20@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_210038 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
void * __fastcall mdir_name ( _BYTE * @@a1@@ ) { _BYTE * @@n@@ ; void * @@dest@@ ; @@n@@ = dir_len ( @@a1@@ ) ; @@dest@@ = malloc ( ( size_t ) & @@n@@ [ ( @@n@@ == Number L ) + Number ] ) ; if ( ! @@dest@@ ) return Number L ; memcpy ( @@dest@@ , @@a1@@ , ( size_t ) @@n@@ ) ; if ( ! @@n@@ ) { @@n@@ = ( _BYTE * ) ( & dword_0 + Number ) ; * ( _BYTE * ) @@dest@@ = Number ; } @@n@@ [ ( _QWORD ) @@dest@@ ] = Number ; return @@dest@@ ; }
__int64 __fastcall parse_integer ( __int64 @@a1@@ , _BYTE * @@a2@@ ) { int @@v3@@ ; __int64 @@v4@@ ; _BYTE * @@v5@@ ; unsigned __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v3@@ = xstrtoumax ( @@a1@@ , & @@v5@@ , Number L , & @@v4@@ , String ) ; if ( @@v3@@ == Number && * @@v5@@ == Number ) { @@v6@@ = parse_integer ( ( __int64 ) ( @@v5@@ + Number ) , @@a2@@ ) ; if ( @@v6@@ && @@v6@@ * @@v4@@ / @@v6@@ != @@v4@@ ) { * @@a2@@ = Number ; return Number L ; } @@v4@@ *= @@v6@@ ; } else if ( @@v3@@ ) { * @@a2@@ = Number ; return Number L ; } return @@v4@@ ; }
void __fastcall hash_free ( __int64 @@a1@@ ) { _QWORD * @@i@@ ; _QWORD * @@j@@ ; _QWORD * @@ptr@@ ; _QWORD * @@ptra@@ ; _QWORD * @@ptrb@@ ; _QWORD * @@v6@@ ; _QWORD * @@v7@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) && * ( _QWORD * ) ( @@a1@@ + Number ) ) { for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@ptr@@ = @@i@@ ; @@ptr@@ ; @@ptr@@ = ( _QWORD * ) @@ptr@@ [ Number ] ) { ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@ptr@@ ) ; } } } } for ( @@j@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@j@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@j@@ += Number ) { for ( @@ptra@@ = ( _QWORD * ) @@j@@ [ Number ] ; @@ptra@@ ; @@ptra@@ = @@v6@@ ) { @@v6@@ = ( _QWORD * ) @@ptra@@ [ Number ] ; free ( @@ptra@@ ) ; } } for ( @@ptrb@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; @@ptrb@@ ; @@ptrb@@ = @@v7@@ ) { @@v7@@ = ( _QWORD * ) @@ptrb@@ [ Number ] ; free ( @@ptrb@@ ) ; } free ( * ( void * * ) @@a1@@ ) ; free ( ( void * ) @@a1@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 __fastcall file_name_concat ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v4@@ ; @@v4@@ = mfile_name_concat ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( ! @@v4@@ ) xalloc_die ( ) ; return @@v4@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_21D168 ; @@v4@@ [ Number ] = qword_21D170 ; @@v4@@ [ Number ] = qword_21D178 ; @@v4@@ [ Number ] = qword_21D180 ; @@v4@@ [ Number ] = qword_21D188 ; @@v4@@ [ Number ] = qword_21D190 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
__int64 __fastcall advance_input_offset ( unsigned __int64 @@a1@@ ) { __int64 @@result@@ ; input_offset += @@a1@@ ; @@result@@ = input_offset ; if ( @@a1@@ > input_offset ) input_offset_overflow = Number ; return @@result@@ ; }
__int64 __fastcall hash_get_n_buckets ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 __fastcall dup_cloexec ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
__int64 __fastcall hash_rehash ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; unsigned __int64 @@nmemb@@ ; void * @@v4@@ ; __int64 @@v5@@ ; unsigned __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; __int64 @@v12@@ ; __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; @@v14@@ = __readfsqword ( Number ) ; @@nmemb@@ = compute_bucket_size ( @@a2@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ; if ( ! @@nmemb@@ ) return Number L ; if ( @@nmemb@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; @@v4@@ = calloc ( @@nmemb@@ , Number ) ; if ( ! @@v4@@ ) return Number L ; @@v6@@ = @@nmemb@@ ; @@v5@@ = ( __int64 ) @@v4@@ + Number * @@nmemb@@ ; @@v7@@ = Number L ; @@v8@@ = Number L ; @@v9@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v10@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v11@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v12@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v13@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( ( unsigned __int8 ) transfer_entries ( ( __int64 ) & @@v4@@ , @@a1@@ , Number ) ) { free ( * ( void * * ) @@a1@@ ) ; * ( _QWORD * ) @@a1@@ = @@v4@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v5@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v6@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v7@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v13@@ ; @@result@@ = Number L ; } else { * ( _QWORD * ) ( @@a1@@ + Number ) = @@v13@@ ; if ( ( unsigned __int8 ) transfer_entries ( @@a1@@ , ( __int64 ) & @@v4@@ , Number ) != Number || ( unsigned __int8 ) transfer_entries ( @@a1@@ , ( __int64 ) & @@v4@@ , Number ) != Number ) { abort ( ) ; } free ( @@v4@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall dup_safer ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
_BOOL8 __fastcall same_name ( _BYTE * @@a1@@ , _BYTE * @@a2@@ ) { bool @@v2@@ ; int * @@v3@@ ; int * @@v4@@ ; bool @@v5@@ ; bool @@v7@@ ; const char * @@s1@@ ; const char * @@s2@@ ; size_t @@v10@@ ; size_t @@n@@ ; char * @@ptr@@ ; char * @@filename@@ ; struct stat @@v14@@ ; struct stat @@v15@@ ; unsigned __int64 @@v16@@ ; @@v16@@ = __readfsqword ( Number ) ; @@s1@@ = last_component ( @@a1@@ ) ; @@s2@@ = last_component ( @@a2@@ ) ; @@v10@@ = base_len ( @@s1@@ ) ; @@n@@ = base_len ( @@s2@@ ) ; @@v2@@ = @@v10@@ == @@n@@ && ! memcmp ( @@s1@@ , @@s2@@ , @@n@@ ) ; @@v7@@ = Number ; if ( @@v2@@ ) { @@ptr@@ = ( char * ) dir_name ( ( __int64 ) @@a1@@ ) ; @@filename@@ = ( char * ) dir_name ( ( __int64 ) @@a2@@ ) ; if ( ( unsigned int ) stat ( @@ptr@@ , & @@v14@@ ) ) { @@v3@@ = __errno_location ( ) ; error ( Number , * @@v3@@ , off_18B08 , @@ptr@@ ) ; } if ( ( unsigned int ) stat ( @@filename@@ , & @@v15@@ ) ) { @@v4@@ = __errno_location ( ) ; error ( Number , * @@v4@@ , off_18B08 , @@filename@@ ) ; } @@v5@@ = @@v14@@ . st_ino == @@v15@@ . st_ino && @@v14@@ . st_dev == @@v15@@ . st_dev ; @@v7@@ = @@v5@@ ; free ( @@ptr@@ ) ; free ( @@filename@@ ) ; } return @@v7@@ ; }
int __fastcall fstat ( int @@fildes@@ , struct stat * @@stat_buf@@ ) { return __fxstat ( Number , @@fildes@@ , @@stat_buf@@ ) ; }
unsigned __int64 __fastcall skip ( unsigned int @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ , unsigned __int64 @@a4@@ , __int64 @@a5@@ ) { __int64 @@v5@@ ; char * @@v6@@ ; int * @@v7@@ ; unsigned __int64 @@result@@ ; __int64 @@v9@@ ; char * @@v10@@ ; __int64 @@v11@@ ; char * @@v12@@ ; int * @@v13@@ ; __int64 @@v14@@ ; char * @@v15@@ ; unsigned __int64 @@v18@@ ; __off_t @@v19@@ ; int @@errnum@@ ; unsigned __int64 @@v21@@ ; signed __int64 @@v22@@ ; struct stat @@stat_buf@@ ; unsigned __int64 @@v24@@ ; @@v18@@ = @@a3@@ ; @@v24@@ = __readfsqword ( Number ) ; @@v21@@ = @@a4@@ * @@a3@@ ; * __errno_location ( ) = Number ; if ( @@v18@@ > Number / @@a4@@ || skip_via_lseek ( @@a2@@ , @@a1@@ , @@v21@@ , Number ) < Number ) { @@errnum@@ = * __errno_location ( ) ; if ( skip_via_lseek ( @@a2@@ , @@a1@@ , Number L , Number ) >= Number ) { if ( ! @@errnum@@ ) @@errnum@@ = Number ; @@v9@@ = quote ( @@a2@@ ) ; if ( @@a1@@ ) @@v10@@ = gettext ( String ) ; else @@v10@@ = gettext ( String ) ; error ( Number , @@errnum@@ , @@v10@@ , @@v9@@ ) ; quit ( Number ) ; } do { @@v22@@ = iread_fnc ( @@a1@@ , @@a5@@ , @@a4@@ ) ; if ( @@v22@@ >= Number ) { if ( ! @@v22@@ ) break ; if ( ! @@a1@@ ) advance_input_offset ( @@v22@@ ) ; } else { if ( @@a1@@ ) { @@v14@@ = quote ( @@a2@@ ) ; @@v15@@ = gettext ( String ) ; error ( Number , @@errnum@@ , @@v15@@ , @@v14@@ ) ; LABEL_24 : quit ( Number ) ; } @@v11@@ = quote ( @@a2@@ ) ; @@v12@@ = gettext ( String ) ; @@v13@@ = __errno_location ( ) ; error ( Number , * @@v13@@ , @@v12@@ , @@v11@@ ) ; if ( ( conversions_mask & Number ) == Number ) goto LABEL_24 ; print_stats ( ) ; } -- @@v18@@ ; } while ( @@v18@@ ) ; @@result@@ = @@v18@@ ; } else { if ( @@a1@@ ) { @@v19@@ = Number L ; } else { if ( ( unsigned int ) fstat ( Number , & @@stat_buf@@ ) ) { @@v5@@ = quote ( @@a2@@ ) ; @@v6@@ = gettext ( String ) ; @@v7@@ = __errno_location ( ) ; error ( Number , * @@v7@@ , @@v6@@ , @@v5@@ ) ; } if ( ( @@stat_buf@@ . st_mode & Number ) == Number && @@stat_buf@@ . st_size < input_offset + @@v21@@ ) { @@v19@@ = ( @@v21@@ - @@stat_buf@@ . st_size ) / @@a4@@ ; advance_input_offset ( @@stat_buf@@ . st_size - input_offset ) ; } else { @@v19@@ = Number L ; advance_input_offset ( @@v21@@ ) ; } } @@result@@ = @@v19@@ ; } return @@result@@ ; }
__int64 __fastcall open_safer ( const char * @@a1@@ , char @@a2@@ , unsigned int @@a3@@ ) { unsigned int @@v3@@ ; unsigned int @@v5@@ ; @@v5@@ = Number ; if ( ( @@a2@@ & Number ) != Number ) @@v5@@ = @@a3@@ ; @@v3@@ = open ( @@a1@@ , @@a2@@ , @@v5@@ ) ; return fd_safer ( @@v3@@ ) ; }
int __fastcall hash_print_statistics ( __int64 @@a1@@ , FILE * @@a2@@ ) { double @@v2@@ ; double @@v3@@ ; double @@v4@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v6@@ = hash_get_n_entries ( @@a1@@ ) ; @@v7@@ = hash_get_n_buckets ( @@a1@@ ) ; @@v8@@ = hash_get_n_buckets_used ( @@a1@@ ) ; @@v9@@ = hash_get_max_bucket_length ( @@a1@@ ) ; fprintf ( @@a2@@ , String , @@v6@@ ) ; fprintf ( @@a2@@ , String , @@v7@@ ) ; if ( @@v8@@ < Number ) @@v2@@ = ( double ) ( int ) ( @@v8@@ & Number | ( ( unsigned __int64 ) @@v8@@ >> Number ) ) + ( double ) ( int ) ( @@v8@@ & Number | ( ( unsigned __int64 ) @@v8@@ >> Number ) ) ; else @@v2@@ = ( double ) ( int ) @@v8@@ ; @@v3@@ = Number * @@v2@@ ; if ( @@v7@@ < Number ) @@v4@@ = ( double ) ( int ) ( @@v7@@ & Number | ( ( unsigned __int64 ) @@v7@@ >> Number ) ) + ( double ) ( int ) ( @@v7@@ & Number | ( ( unsigned __int64 ) @@v7@@ >> Number ) ) ; else @@v4@@ = ( double ) ( int ) @@v7@@ ; fprintf ( @@a2@@ , String , @@v8@@ , @@v3@@ / @@v4@@ ) ; return fprintf ( @@a2@@ , String , @@v9@@ ) ; }
__int64 __fastcall get_stat_mtime_ns ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( is_mul_ok ( @@a2@@ , * @@a1@@ ) ) { * @@a1@@ *= @@a2@@ ; @@result@@ = Number L ; } else { * @@a1@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall get_stat_mtime_1 ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
DIR * opendir ( const char * @@name@@ ) { return opendir ( @@name@@ ) ; }
__int64 __fastcall hash_do_for_each ( __int64 @@a1@@ , unsigned __int8 ( __fastcall * @@a2@@ ) ( _QWORD , __int64 ) , __int64 @@a3@@ ) { __int64 @@v5@@ ; _QWORD * @@i@@ ; _QWORD * @@j@@ ; @@v5@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = @@i@@ ; @@j@@ ; @@j@@ = ( _QWORD * ) @@j@@ [ Number ] ) { if ( @@a2@@ ( * @@j@@ , @@a3@@ ) != Number ) return @@v5@@ ; ++ @@v5@@ ; } } } return @@v5@@ ; }
DIR * __fastcall opendir_safer ( const char * @@a1@@ ) { int @@v2@@ ; int @@fd@@ ; int @@v4@@ ; DIR * @@dirp@@ ; DIR * @@v6@@ ; @@dirp@@ = opendir ( @@a1@@ ) ; if ( @@dirp@@ ) { @@v2@@ = dirfd ( @@dirp@@ ) ; if ( @@v2@@ >= Number && @@v2@@ <= Number ) { @@fd@@ = dup_safer ( ( unsigned int ) @@v2@@ ) ; @@v6@@ = fdopendir ( @@fd@@ ) ; @@v4@@ = * __errno_location ( ) ; if ( ! @@v6@@ ) close ( @@fd@@ ) ; closedir ( @@dirp@@ ) ; * __errno_location ( ) = @@v4@@ ; @@dirp@@ = @@v6@@ ; } } return @@dirp@@ ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
int __fastcall lutimens ( char * @@a1@@ , __int64 * @@a2@@ ) { struct timespec * @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; struct timespec * @@v6@@ ; __syscall_slong_t @@v7@@ ; struct timespec * @@v8@@ ; __syscall_slong_t @@v9@@ ; int @@v10@@ ; int @@v11@@ ; struct timespec * @@times@@ ; __int64 @@v13@@ [ Number ] ; struct stat @@v14@@ ; unsigned __int64 @@v15@@ ; @@v15@@ = __readfsqword ( Number ) ; if ( @@a2@@ ) @@v2@@ = ( struct timespec * ) @@v13@@ ; else @@v2@@ = Number L ; @@times@@ = @@v2@@ ; @@v10@@ = Number ; if ( @@v2@@ ) { @@v3@@ = @@a2@@ [ Number ] ; @@v13@@ [ Number ] = * @@a2@@ ; @@v13@@ [ Number ] = @@v3@@ ; @@v4@@ = @@a2@@ [ Number ] ; @@v13@@ [ Number ] = @@a2@@ [ Number ] ; @@v13@@ [ Number ] = @@v4@@ ; @@v10@@ = validate_timespec ( @@times@@ ) ; } if ( @@v10@@ < Number ) return Number ; if ( lutimensat_works_really >= Number ) { if ( @@v10@@ == Number ) { if ( ( unsigned int ) lstat ( @@a1@@ , & @@v14@@ ) ) return Number ; if ( @@times@@ -> tv_nsec == Number ) { @@v6@@ = @@times@@ ; @@times@@ -> tv_sec = get_stat_atime_1 ( ( __int64 ) & @@v14@@ ) ; @@v6@@ -> tv_nsec = @@v7@@ ; } else if ( @@times@@ [ Number ] . tv_nsec == Number ) { @@v8@@ = @@times@@ + Number ; @@times@@ [ Number ] . tv_sec = get_stat_mtime_1 ( ( __int64 ) & @@v14@@ ) ; @@v8@@ -> tv_nsec = @@v9@@ ; } @@v10@@ = Number ; } @@v11@@ = utimensat ( Number , @@a1@@ , @@times@@ , Number ) ; if ( @@v11@@ > Number ) * __errno_location ( ) = Number ; if ( ! @@v11@@ || * __errno_location ( ) != Number ) { utimensat_works_really = Number ; lutimensat_works_really = Number ; return @@v11@@ ; } } lutimensat_works_really = Number ; if ( ! @@v10@@ ) goto LABEL_37 ; if ( @@v10@@ != Number && ( unsigned int ) lstat ( @@a1@@ , & @@v14@@ ) ) return Number ; if ( @@times@@ && ( unsigned __int8 ) update_timespec ( ( __int64 ) & @@v14@@ , ( __int64 * * ) & @@times@@ ) ) { return Number ; } LABEL_37 : if ( ! @@v10@@ && ( unsigned int ) lstat ( @@a1@@ , & @@v14@@ ) ) return Number ; if ( ( @@v14@@ . st_mode & Number ) != Number ) return fdutimens ( @@a1@@ , Number , & @@times@@ -> tv_sec ) ; * __errno_location ( ) = Number ; return Number ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
__mode_t umask ( __mode_t @@mask@@ ) { return umask ( @@mask@@ ) ; }
__int64 __fastcall check_tuning ( __int64 @@a1@@ ) { __int64 @@v2@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( ( _UNKNOWN * ) @@v2@@ == & default_tuning ) return Number L ; if ( * ( float * ) ( @@v2@@ + Number ) > Number && ( float ) ( Number - Number ) > * ( float * ) ( @@v2@@ + Number ) && * ( float * ) ( @@v2@@ + Number ) > ( float ) ( Number + Number ) && * ( float * ) @@v2@@ >= Number && * ( float * ) ( @@v2@@ + Number ) > ( float ) ( * ( float * ) @@v2@@ + Number ) && * ( float * ) ( @@v2@@ + Number ) <= Number && * ( float * ) ( @@v2@@ + Number ) > ( float ) ( * ( float * ) @@v2@@ + Number ) ) { return Number L ; } * ( _QWORD * ) ( @@a1@@ + Number ) = & default_tuning ; return Number L ; }
long double __fastcall adjust_value ( int @@a1@@ , long double @@a2@@ ) { _BOOL4 @@v7@@ ; unsigned __int64 @@v9@@ ; if ( @@a1@@ != Number && @@a2@@ < Number ) { if ( @@a2@@ >= Number ) @@v9@@ = ( __int64 ) ( @@a2@@ - Number ) ^ Number ; else @@v9@@ = ( __int64 ) @@a2@@ ; @@v7@@ = ! @@a1@@ && @@a2@@ != ( long double ) @@v9@@ ; @@a2@@ = ( long double ) ( @@v7@@ + @@v9@@ ) ; } return @@a2@@ ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
int iswalnum ( wint_t @@wc@@ ) { return iswalnum ( @@wc@@ ) ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
int __freading ( FILE * @@fp@@ ) { return _freading ( @@fp@@ ) ; }
_BOOL8 yesno ( ) { bool @@v1@@ ; char * @@lineptr@@ ; size_t @@n@@ ; __ssize_t @@v4@@ ; unsigned __int64 @@v5@@ ; @@v5@@ = __readfsqword ( Number ) ; @@lineptr@@ = Number L ; @@n@@ = Number L ; @@v4@@ = getline ( & @@lineptr@@ , & @@n@@ , stdin ) ; if ( @@v4@@ > Number ) { @@lineptr@@ [ @@v4@@ - Number ] = Number ; @@v1@@ = rpmatch ( @@lineptr@@ ) > Number ; } else { @@v1@@ = Number ; } free ( @@lineptr@@ ) ; return @@v1@@ ; }
void __fastcall hash_free ( __int64 @@a1@@ ) { _QWORD * @@i@@ ; _QWORD * @@j@@ ; _QWORD * @@ptr@@ ; _QWORD * @@ptra@@ ; _QWORD * @@ptrb@@ ; _QWORD * @@v6@@ ; _QWORD * @@v7@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) && * ( _QWORD * ) ( @@a1@@ + Number ) ) { for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@ptr@@ = @@i@@ ; @@ptr@@ ; @@ptr@@ = ( _QWORD * ) @@ptr@@ [ Number ] ) { ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@ptr@@ ) ; } } } } for ( @@j@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@j@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@j@@ += Number ) { for ( @@ptra@@ = ( _QWORD * ) @@j@@ [ Number ] ; @@ptra@@ ; @@ptra@@ = @@v6@@ ) { @@v6@@ = ( _QWORD * ) @@ptra@@ [ Number ] ; free ( @@ptra@@ ) ; } } for ( @@ptrb@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; @@ptrb@@ ; @@ptrb@@ = @@v7@@ ) { @@v7@@ = ( _QWORD * ) @@ptrb@@ [ Number ] ; free ( @@ptrb@@ ) ; } free ( * ( void * * ) @@a1@@ ) ; free ( ( void * ) @@a1@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
void free ( void * @@ptr@@ ) { __imp_free ( @@ptr@@ ) ; }
__int64 __fastcall freadahead ( __int64 @@a1@@ ) { __int64 @@v2@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) > * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; if ( ( * ( _DWORD * ) @@a1@@ & Number ) != Number ) @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) - * ( _QWORD * ) ( @@a1@@ + Number ) ; else @@v2@@ = Number L ; return * ( _QWORD * ) ( @@a1@@ + Number ) - * ( _QWORD * ) ( @@a1@@ + Number ) + @@v2@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
__int64 __fastcall get_stat_atime ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
_BOOL8 __fastcall dot_or_dotdot ( _BYTE * @@a1@@ ) { __int64 @@v1@@ ; char @@v4@@ ; if ( * @@a1@@ != Number ) return Number L ; if ( @@a1@@ [ Number ] == Number ) @@v1@@ = Number L ; else @@v1@@ = Number L ; @@v4@@ = @@a1@@ [ @@v1@@ ] ; return ! @@v4@@ || @@v4@@ == Number ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_2100E8 ; @@v4@@ [ Number ] = qword_2100F0 ; @@v4@@ [ Number ] = qword_2100F8 ; @@v4@@ [ Number ] = qword_210100 ; @@v4@@ [ Number ] = qword_210108 ; @@v4@@ [ Number ] = qword_210110 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
__int64 __fastcall knuth_morris_pratt_unibyte ( _BYTE * @@a1@@ , char * @@a2@@ , _QWORD * @@a3@@ ) { void * @@v3@@ ; unsigned __int64 @@v4@@ ; _QWORD * @@v6@@ ; char * @@s@@ ; _BYTE * @@v8@@ ; char @@v9@@ ; unsigned __int64 @@i@@ ; __int64 @@v11@@ ; __int64 @@v12@@ ; _BYTE * @@v13@@ ; _BYTE * @@v14@@ ; size_t @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v8@@ = @@a1@@ ; @@s@@ = @@a2@@ ; @@v6@@ = @@a3@@ ; @@v17@@ = __readfsqword ( Number ) ; @@v15@@ = strlen ( @@a2@@ ) ; if ( @@v15@@ > Number ) { @@v4@@ = Number L ; } else if ( Number * @@v15@@ > Number ) { @@v4@@ = mmalloca ( Number * @@v15@@ ) ; } else { @@v3@@ = alloca ( Number * ( ( Number * ( @@v15@@ + Number ) + Number ) / Number ) ) ; @@v4@@ = Number * ( ( ( unsigned __int64 ) & @@v6@@ + Number ) >> Number ) + Number ; } @@v16@@ = @@v4@@ ; if ( ! @@v4@@ ) return Number L ; * ( _QWORD * ) ( @@v16@@ + Number ) = Number L ; @@v11@@ = Number L ; for ( @@i@@ = Number L ; @@i@@ < @@v15@@ ; ++ @@i@@ ) { @@v9@@ = @@s@@ [ @@i@@ - Number ] ; while ( Number ) { if ( @@v9@@ == @@s@@ [ @@v11@@ ] ) { ++ @@v11@@ ; * ( _QWORD * ) ( @@v16@@ + Number * @@i@@ ) = @@i@@ - @@v11@@ ; goto LABEL_15 ; } if ( ! @@v11@@ ) break ; @@v11@@ -= * ( _QWORD * ) ( Number * @@v11@@ + @@v16@@ ) ; } * ( _QWORD * ) ( @@v16@@ + Number * @@i@@ ) = @@i@@ ; LABEL_15 : ; } * @@v6@@ = Number L ; @@v12@@ = Number L ; @@v13@@ = @@v8@@ ; @@v14@@ = @@v8@@ ; while ( * @@v14@@ ) { if ( @@s@@ [ @@v12@@ ] == * @@v14@@ ) { ++ @@v12@@ ; ++ @@v14@@ ; if ( @@v12@@ == @@v15@@ ) { * @@v6@@ = @@v13@@ ; break ; } } else if ( @@v12@@ ) { @@v13@@ += * ( _QWORD * ) ( Number * @@v12@@ + @@v16@@ ) ; @@v12@@ -= * ( _QWORD * ) ( Number * @@v12@@ + @@v16@@ ) ; } else { ++ @@v13@@ ; ++ @@v14@@ ; } } freea ( @@v16@@ ) ; return Number L ; }
__int64 __fastcall utimens_symlink ( __int64 @@a1@@ , __int64 @@a2@@ ) { unsigned int @@v3@@ ; @@v3@@ = lutimens ( @@a1@@ , @@a2@@ ) ; if ( @@v3@@ && * __errno_location ( ) == Number ) @@v3@@ = Number ; return @@v3@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
void * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
_BOOL8 __fastcall c_isspace ( int @@a1@@ ) { return @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number ; }
int __fastcall fchmod_or_lchmod ( int @@a1@@ , const char * @@a2@@ , __mode_t @@a3@@ ) { int @@result@@ ; if ( @@a1@@ < Number ) @@result@@ = chmod ( @@a2@@ , @@a3@@ ) ; else @@result@@ = fchmod ( @@a1@@ , @@a3@@ ) ; return @@result@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
void * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
void * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__ino_t * __fastcall get_root_dev_ino ( __ino_t * @@a1@@ ) { struct stat @@v2@@ ; unsigned __int64 @@v3@@ ; @@v3@@ = __readfsqword ( Number ) ; if ( ( unsigned int ) lstat ( String , & @@v2@@ ) ) return Number L ; * @@a1@@ = @@v2@@ . st_ino ; @@a1@@ [ Number ] = @@v2@@ . st_dev ; return @@a1@@ ; }
void * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
int __fastcall emit_verbose ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { const char * @@v3@@ ; const char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; @@v3@@ = ( const char * ) quote_n ( Number L , @@a2@@ ) ; @@v4@@ = ( const char * ) quote_n ( Number L , @@a1@@ ) ; printf ( String , @@v4@@ , @@v3@@ ) ; if ( @@a3@@ ) { @@v5@@ = quote ( @@a3@@ ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } return putchar_unlocked ( Number ) ; }
unsigned __int64 __fastcall mmalloca ( unsigned __int64 @@a1@@ ) { char * @@v2@@ ; unsigned __int64 @@v3@@ ; if ( @@a1@@ + Number < @@a1@@ ) return Number L ; @@v2@@ = ( char * ) malloc ( @@a1@@ + Number ) ; if ( ! @@v2@@ ) return Number L ; @@v3@@ = ( unsigned __int64 ) ( @@v2@@ + Number ) ; * ( _DWORD * ) ( @@v3@@ - Number ) = Number ; * ( _QWORD * ) ( @@v3@@ - Number ) = mmalloca_results [ @@v3@@ % Number ] ; mmalloca_results [ @@v3@@ % Number ] = @@v3@@ ; return @@v3@@ ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_21D168 ; @@v8@@ [ Number ] = qword_21D170 ; @@v8@@ [ Number ] = qword_21D178 ; @@v8@@ [ Number ] = qword_21D180 ; @@v8@@ [ Number ] = qword_21D188 ; @@v8@@ [ Number ] = qword_21D190 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
__int64 __fastcall valid_options ( __int64 @@a1@@ ) { if ( ! @@a1@@ ) __assert_fail ( String , String , Number , String ) ; if ( * ( _DWORD * ) @@a1@@ > Number ) __assert_fail ( String , String , Number , String ) ; if ( * ( _DWORD * ) ( @@a1@@ + Number ) != Number && * ( _DWORD * ) ( @@a1@@ + Number ) != Number && * ( _DWORD * ) ( @@a1@@ + Number ) != Number ) { __assert_fail ( String , String , Number , String ) ; } if ( * ( _DWORD * ) ( @@a1@@ + Number ) && * ( _DWORD * ) ( @@a1@@ + Number ) != Number && * ( _DWORD * ) ( @@a1@@ + Number ) != Number ) { __assert_fail ( String , String , Number , String ) ; } if ( * ( _BYTE * ) ( @@a1@@ + Number ) == Number && * ( _BYTE * ) ( @@a1@@ + Number ) == Number ) __assert_fail ( String , String , Number , String ) ; if ( * ( _DWORD * ) ( @@a1@@ + Number ) == Number && * ( _DWORD * ) ( @@a1@@ + Number ) != Number ) __assert_fail ( String , String , Number , String ) ; return Number L ; }
_BYTE * __fastcall fdsavedir ( int @@a1@@ ) { DIR * @@v1@@ ; @@v1@@ = fdopendir ( @@a1@@ ) ; return savedirstream ( @@v1@@ ) ; }
size_t __fastcall mbslen ( const char * @@a1@@ ) { __int64 @@v3@@ ; char @@v4@@ [ Number ] ; int @@v5@@ ; char @@i@@ ; const char * @@v7@@ ; __int64 @@v8@@ ; char @@v9@@ ; int @@v10@@ ; unsigned __int64 @@v11@@ ; @@v11@@ = __readfsqword ( Number ) ; if ( __ctype_get_mb_cur_max ( ) <= Number ) return strlen ( @@a1@@ ) ; @@v3@@ = Number L ; @@v7@@ = @@a1@@ ; @@v4@@ [ Number ] = Number ; memset ( & @@v5@@ , Number , Number ) ; for ( @@i@@ = Number ; ; @@i@@ = Number ) { mbuiter_multi_next_1 ( ( __int64 ) @@v4@@ ) ; if ( @@v9@@ == Number && ! @@v10@@ ) break ; ++ @@v3@@ ; @@v7@@ += @@v8@@ ; } return @@v3@@ ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall fd_reopen ( int @@a1@@ , const char * @@a2@@ , int @@a3@@ , unsigned int @@a4@@ ) { int @@fd@@ ; unsigned int @@v6@@ ; int @@v7@@ ; @@fd@@ = open ( @@a2@@ , @@a3@@ , @@a4@@ ) ; if ( @@fd@@ == @@a1@@ || @@fd@@ < Number ) return ( unsigned int ) @@fd@@ ; @@v6@@ = dup2 ( @@fd@@ , @@a1@@ ) ; @@v7@@ = * __errno_location ( ) ; close ( @@fd@@ ) ; * __errno_location ( ) = @@v7@@ ; return @@v6@@ ; }
unsigned __int64 __fastcall dev_info_hash ( _QWORD * @@a1@@ , unsigned __int64 @@a2@@ ) { return * @@a1@@ % @@a2@@ ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
_BOOL8 __fastcall src_to_dest_compare ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { return * @@a1@@ == * @@a2@@ && @@a1@@ [ Number ] == @@a2@@ [ Number ] ; }
int clock_gettime ( clockid_t @@clock_id@@ , struct timespec * @@tp@@ ) { return clock_gettime ( @@clock_id@@ , @@tp@@ ) ; }
int __lxstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _lxstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
__int64 __fastcall set_acl ( const char * @@a1@@ , int @@a2@@ , __mode_t @@a3@@ ) { __int64 @@v3@@ ; char * @@v4@@ ; int * @@v5@@ ; unsigned int @@v7@@ ; @@v7@@ = qset_acl ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( @@v7@@ ) { @@v3@@ = quote ( @@a1@@ ) ; @@v4@@ = gettext ( String ) ; @@v5@@ = __errno_location ( ) ; error ( Number , * @@v5@@ , @@v4@@ , @@v3@@ ) ; } return @@v7@@ ; }
__int64 __fastcall freadahead ( __int64 @@a1@@ ) { __int64 @@v2@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) > * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; if ( ( * ( _DWORD * ) @@a1@@ & Number ) != Number ) @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) - * ( _QWORD * ) ( @@a1@@ + Number ) ; else @@v2@@ = Number L ; return * ( _QWORD * ) ( @@a1@@ + Number ) - * ( _QWORD * ) ( @@a1@@ + Number ) + @@v2@@ ; }
int __fastcall argmatch_valid ( __int64 @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { char * @@v3@@ ; __int64 @@i@@ ; void * @@s1@@ ; @@s1@@ = Number L ; @@v3@@ = gettext ( String ) ; fprintf ( stderr , @@v3@@ ) ; for ( @@i@@ = Number L ; * ( _QWORD * ) ( Number * @@i@@ + @@a1@@ ) ; ++ @@i@@ ) { if ( @@i@@ && ! memcmp ( @@s1@@ , ( const void * ) ( @@i@@ * @@a3@@ + @@a2@@ ) , @@a3@@ ) ) { fprintf ( stderr , String , * ( const char * * ) ( Number * @@i@@ + @@a1@@ ) ) ; } else { fprintf ( stderr , String , * ( const char * * ) ( Number * @@i@@ + @@a1@@ ) ) ; @@s1@@ = ( void * ) ( @@i@@ * @@a3@@ + @@a2@@ ) ; } } return putc_unlocked ( Number , stderr ) ; }
__int64 __fastcall update_timespec ( __int64 @@a1@@ , __int64 * * @@a2@@ ) { __int64 @@result@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 * @@v5@@ ; @@v5@@ = * @@a2@@ ; if ( ( * @@a2@@ ) [ Number ] == Number && @@v5@@ [ Number ] == Number ) return Number L ; if ( @@v5@@ [ Number ] == Number && @@v5@@ [ Number ] == Number ) { * @@a2@@ = Number L ; @@result@@ = Number L ; } else { if ( @@v5@@ [ Number ] == Number ) { * @@v5@@ = get_stat_atime_1 ( @@a1@@ ) ; @@v5@@ [ Number ] = @@v3@@ ; } else if ( @@v5@@ [ Number ] == Number ) { gettime ( @@v5@@ ) ; } if ( @@v5@@ [ Number ] == Number ) { @@v5@@ [ Number ] = get_stat_mtime_1 ( @@a1@@ ) ; @@v5@@ [ Number ] = @@v4@@ ; } else if ( @@v5@@ [ Number ] == Number ) { gettime ( @@v5@@ + Number ) ; } @@result@@ = Number L ; } return @@result@@ ; }
int closedir ( DIR * @@dirp@@ ) { return closedir ( @@dirp@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ ) { return xmalloc ( @@a1@@ ) ; }
bool __fastcall seen_file ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 * @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; if ( ! @@a1@@ ) return Number ; @@v4@@ [ Number ] = @@a2@@ ; @@v4@@ [ Number ] = @@a3@@ [ Number ] ; @@v4@@ [ Number ] = * @@a3@@ ; return hash_lookup ( @@a1@@ , @@v4@@ ) != Number ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
__int64 __fastcall cycle_check ( __int64 @@a1@@ , _QWORD * @@a2@@ ) { if ( * ( _DWORD * ) ( @@a1@@ + Number ) != Number ) __assert_fail ( String , String , Number , String ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) && @@a2@@ [ Number ] == * ( _QWORD * ) @@a1@@ && * @@a2@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ) { return Number L ; } if ( is_zero_or_power_of_two ( ++ * ( _QWORD * ) ( @@a1@@ + Number ) ) ) { if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = * @@a2@@ ; * ( _QWORD * ) @@a1@@ = @@a2@@ [ Number ] ; } return Number L ; }
int putchar_unlocked ( int @@c@@ ) { return putchar_unlocked ( @@c@@ ) ; }
unsigned __int64 __fastcall triple_hash_no_name ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) % @@a2@@ ; }
int fflush ( FILE * @@stream@@ ) { return fflush ( @@stream@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
const char * locale_charset ( ) { const char * @@s1@@ ; char * @@s2@@ ; char * @@s2a@@ ; @@s1@@ = nl_langinfo ( Number ) ; if ( ! @@s1@@ ) @@s1@@ = ( const char * ) & unk_18B6F ; for ( @@s2@@ = ( char * ) get_charset_aliases ( ) ; * @@s2@@ ; @@s2@@ = & @@s2a@@ [ strlen ( @@s2a@@ ) + Number ] ) { if ( ! strcmp ( @@s1@@ , @@s2@@ ) || * @@s2@@ == Number && ! @@s2@@ [ Number ] ) { @@s1@@ = & @@s2@@ [ strlen ( @@s2@@ ) + Number ] ; break ; } @@s2a@@ = & @@s2@@ [ strlen ( @@s2@@ ) + Number ] ; } if ( ! * @@s1@@ ) @@s1@@ = String ; return @@s1@@ ; }
int __fastcall stat ( char * @@filename@@ , struct stat * @@stat_buf@@ ) { return __xstat ( Number , @@filename@@ , @@stat_buf@@ ) ; }
DIR * fdopendir ( int @@fd@@ ) { return fdopendir ( @@fd@@ ) ; }
void __fastcall triple_free ( void * * @@a1@@ ) { free ( * @@a1@@ ) ; free ( @@a1@@ ) ; }
void free ( void * @@ptr@@ ) { __imp_free ( @@ptr@@ ) ; }
int __fastcall fstatat ( int @@fildes@@ , char * @@filename@@ , struct stat * @@stat_buf@@ , int @@flag@@ ) { return __fxstatat ( Number , @@fildes@@ , @@filename@@ , @@stat_buf@@ , @@flag@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
bool __fastcall is_basic ( unsigned __int8 @@a1@@ ) { return ( ( is_basic_table [ @@a1@@ >> Number ] >> ( @@a1@@ & Number ) ) & Number ) != Number ; }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
int getc_unlocked ( FILE * @@stream@@ ) { return getc_unlocked ( @@stream@@ ) ; }
bool __fastcall is_basic_0 ( unsigned __int8 @@a1@@ ) { return ( ( is_basic_table [ @@a1@@ >> Number ] >> ( @@a1@@ & Number ) ) & Number ) != Number ; }
_BOOL8 __fastcall target_directory_operand ( char * @@a1@@ ) { int @@v1@@ ; bool @@v2@@ ; __int64 @@v3@@ ; char * @@v4@@ ; bool @@v6@@ ; int @@errnum@@ ; struct stat @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; if ( ( unsigned int ) stat ( @@a1@@ , & @@v8@@ ) ) @@v1@@ = * __errno_location ( ) ; else @@v1@@ = Number ; @@errnum@@ = @@v1@@ ; @@v2@@ = ! @@v1@@ && ( @@v8@@ . st_mode & Number ) == Number ; @@v6@@ = @@v2@@ ; if ( @@errnum@@ && @@errnum@@ != Number ) { @@v3@@ = quote ( @@a1@@ ) ; @@v4@@ = gettext ( String ) ; error ( Number , @@errnum@@ , @@v4@@ , @@v3@@ ) ; } return @@v6@@ ; }
char * __fastcall str_iconv ( char * @@a1@@ , char * @@a2@@ , char * @@a3@@ ) { char * @@result@@ ; int @@v5@@ ; int @@v6@@ ; iconv_t @@cd@@ ; void * @@ptr@@ ; char * @@v9@@ ; if ( * @@a1@@ && ( unsigned int ) c_strcasecmp ( ( unsigned __int8 * ) @@a2@@ , ( unsigned __int8 * ) @@a3@@ ) ) { @@cd@@ = iconv_open ( @@a3@@ , @@a2@@ ) ; if ( @@cd@@ == ( iconv_t ) Number ) return Number L ; @@ptr@@ = str_cd_iconv ( @@a1@@ , @@cd@@ ) ; if ( @@ptr@@ ) { if ( iconv_close ( @@cd@@ ) < Number ) { @@v5@@ = * __errno_location ( ) ; free ( @@ptr@@ ) ; * __errno_location ( ) = @@v5@@ ; return Number L ; } } else { @@v6@@ = * __errno_location ( ) ; iconv_close ( @@cd@@ ) ; * __errno_location ( ) = @@v6@@ ; } @@result@@ = ( char * ) @@ptr@@ ; } else { @@v9@@ = strdup ( @@a1@@ ) ; if ( ! @@v9@@ ) * __errno_location ( ) = Number ; @@result@@ = @@v9@@ ; } return @@result@@ ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
struct dirent * __fastcall readdir_ignoring_dot_and_dotdot ( DIR * @@a1@@ ) { struct dirent * @@v2@@ ; do @@v2@@ = readdir ( @@a1@@ ) ; while ( @@v2@@ && dot_or_dotdot ( @@v2@@ -> d_name ) ) ; return @@v2@@ ; }
_BOOL8 __fastcall c_isascii ( int @@a1@@ ) { return @@a1@@ >= Number && @@a1@@ <= Number ; }
int closedir ( DIR * @@dirp@@ ) { return closedir ( @@dirp@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 __fastcall xstr_iconv ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v4@@ ; @@v4@@ = str_iconv ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( ! @@v4@@ && * __errno_location ( ) == Number ) xalloc_die ( ) ; return @@v4@@ ; }
__int64 __fastcall write_protected_non_symlink ( int @@a1@@ , char * @@a2@@ , const char * @@a3@@ , struct stat * @@a4@@ ) { if ( ( unsigned __int8 ) can_write_any_file ( ) ) return Number L ; if ( ( unsigned int ) cache_fstatat ( @@a1@@ , @@a2@@ , @@a4@@ , Number ) ) return Number ; if ( ( @@a4@@ -> st_mode & Number ) == Number ) return Number L ; if ( ! faccessat ( @@a1@@ , @@a2@@ , Number , Number ) ) return Number L ; if ( strlen ( @@a3@@ ) > Number ) return ( unsigned __int8 ) euidaccess_stat ( @@a4@@ , Number L ) ^ Number ; if ( ! euidaccess ( @@a3@@ , Number ) ) return Number L ; if ( * __errno_location ( ) != Number ) return Number ; * __errno_location ( ) = Number ; return Number L ; }
int putchar_unlocked ( int @@c@@ ) { return putchar_unlocked ( @@c@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
_BOOL8 __fastcall c_isalnum ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number || ( int ) ( @@a1@@ & Number ) > Number && ( int ) ( @@a1@@ & Number ) <= Number ; }
int fileno ( FILE * @@stream@@ ) { return fileno ( @@stream@@ ) ; }
__int64 __fastcall argmatch_to_argument ( const void * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; ++ @@i@@ ) { if ( ! memcmp ( @@a1@@ , ( const void * ) ( @@i@@ * @@a4@@ + @@a3@@ ) , @@a4@@ ) ) return * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; } return Number L ; }
_BOOL8 __fastcall dot_or_dotdot_0 ( _BYTE * @@a1@@ ) { __int64 @@v1@@ ; char @@v4@@ ; if ( * @@a1@@ != Number ) return Number L ; if ( @@a1@@ [ Number ] == Number ) @@v1@@ = Number L ; else @@v1@@ = Number L ; @@v4@@ = @@a1@@ [ @@v1@@ ] ; return ! @@v4@@ || @@v4@@ == Number ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
_BOOL8 __fastcall c_isblank ( int @@a1@@ ) { return @@a1@@ == Number || @@a1@@ == Number ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
char * nl_langinfo ( nl_item @@item@@ ) { return nl_langinfo ( @@item@@ ) ; }
__int64 __fastcall get_version ( __int64 @@a1@@ , const char * @@a2@@ ) { __int64 @@result@@ ; if ( @@a2@@ && * @@a2@@ ) @@result@@ = backup_types [ _xargmatch_internal ( @@a1@@ , @@a2@@ , ( __int64 ) backup_args , ( __int64 ) backup_types , Number , ( void ( * ) ( void ) ) argmatch_die ) ] ; else @@result@@ = Number L ; return @@result@@ ; }
_BOOL8 __fastcall c_isdigit ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
__int64 __fastcall io_blksize ( __int64 a1 , __int64 a2 , __int64 a3 , __int64 a4 , __int64 a5 , __int64 a6 , int a7 , int a8 , int a9 , int a10 , int a11 , int a12 , int a13 , __int64 @@a14@@ ) { __int64 @@result@@ ; if ( @@a14@@ <= Number || ( unsigned __int64 ) @@a14@@ > Number || @@a14@@ <= Number ) { @@result@@ = Number ; } else { @@result@@ = @@a14@@ ; } return @@result@@ ; }
int rename ( const char * @@old@@ , const char * @@a2@@ ) { return rename ( @@old@@ , @@a2@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
__int64 __fastcall get_stat_mtime ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
_BOOL8 __fastcall c_ispunct ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number && ( @@a1@@ <= Number || @@a1@@ > Number ) && ( ( int ) ( @@a1@@ & Number ) <= Number || ( int ) ( @@a1@@ & Number ) > Number ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
__int64 __fastcall dir_name ( __int64 @@a1@@ ) { __int64 @@v2@@ ; @@v2@@ = mdir_name ( @@a1@@ ) ; if ( ! @@v2@@ ) xalloc_die ( ) ; return @@v2@@ ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
__int64 __fastcall c_toupper ( int @@a1@@ ) { __int64 @@result@@ ; if ( @@a1@@ <= Number || @@a1@@ > Number ) @@result@@ = ( unsigned int ) @@a1@@ ; else @@result@@ = ( unsigned int ) ( @@a1@@ - Number ) ; return @@result@@ ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
__int64 __fastcall clear_ungetc_buffer_preserving_position ( _DWORD * @@a1@@ ) { __int64 @@result@@ ; @@result@@ = * @@a1@@ & Number ; if ( ( _DWORD ) @@result@@ ) @@result@@ = rpl_fseeko ( @@a1@@ , Number L , Number L ) ; return @@result@@ ; }
__int64 __fastcall set_owner ( __int64 @@a1@@ , const char * @@a2@@ , unsigned int @@a3@@ , _DWORD * @@a4@@ , char @@a5@@ , __int64 @@a6@@ ) { int @@v6@@ ; unsigned __int16 @@v7@@ ; __int64 @@v8@@ ; char * @@v9@@ ; int * @@v10@@ ; __int64 @@result@@ ; __int64 @@v12@@ ; char * @@v13@@ ; int * @@v14@@ ; __uid_t @@owner@@ ; __gid_t @@group@@ ; int @@v18@@ ; unsigned int @@v19@@ ; int @@v20@@ ; int @@v21@@ ; @@owner@@ = @@a4@@ [ Number ] ; @@group@@ = @@a4@@ [ Number ] ; if ( @@a5@@ != Number && ( * ( _BYTE * ) ( @@a1@@ + Number ) || * ( _BYTE * ) ( @@a1@@ + Number ) || * ( _BYTE * ) ( @@a1@@ + Number ) ) && ( ( @@v18@@ = * ( _DWORD * ) ( @@a6@@ + Number ) , ! * ( _BYTE * ) ( @@a1@@ + Number ) ) && ! * ( _BYTE * ) ( @@a1@@ + Number ) ? ( @@v6@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ) : ( @@v6@@ = @@a4@@ [ Number ] ) , ( @@v19@@ = ( unsigned __int16 ) @@v6@@ & ( unsigned __int16 ) @@v18@@ & Number , @@v7@@ = ~ ( _WORD ) @@v6@@ , HIBYTE ( @@v7@@ ) |= Number , ( ( unsigned __int16 ) @@v18@@ & @@v7@@ & Number ) != Number ) && ( unsigned int ) qset_acl ( @@a2@@ , @@a3@@ , @@v19@@ ) ) ) { if ( ( unsigned __int8 ) owner_failure_ok ( @@a1@@ ) != Number ) { @@v8@@ = quote ( @@a2@@ ) ; @@v9@@ = gettext ( String ) ; @@v10@@ = __errno_location ( ) ; error ( Number , * @@v10@@ , @@v9@@ , @@v8@@ ) ; } @@result@@ = ( unsigned int ) - * ( unsigned __int8 * ) ( @@a1@@ + Number ) ; } else { if ( @@a3@@ == Number ) { if ( ! lchown ( @@a2@@ , @@owner@@ , @@group@@ ) ) return Number L ; if ( * __errno_location ( ) == Number || * __errno_location ( ) == Number ) { @@v20@@ = * __errno_location ( ) ; lchown ( @@a2@@ , Number , @@group@@ ) ; ignore_value ( ) ; * __errno_location ( ) = @@v20@@ ; } } else { if ( ! fchown ( @@a3@@ , @@owner@@ , @@group@@ ) ) return Number L ; if ( * __errno_location ( ) == Number || * __errno_location ( ) == Number ) { @@v21@@ = * __errno_location ( ) ; fchown ( @@a3@@ , Number , @@group@@ ) ; ignore_value ( ) ; * __errno_location ( ) = @@v21@@ ; } } if ( ( unsigned __int8 ) chown_failure_ok ( @@a1@@ ) != Number && ( @@v12@@ = quote ( @@a2@@ ) , @@v13@@ = gettext ( String ) , @@v14@@ = __errno_location ( ) , error ( Number , * @@v14@@ , @@v13@@ , @@v12@@ ) , * ( _BYTE * ) ( @@a1@@ + Number ) ) ) { @@result@@ = Number ; } else { @@result@@ = Number L ; } } return @@result@@ ; }
unsigned __int64 __fastcall gcd ( unsigned __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { unsigned __int64 @@v5@@ ; do { @@v5@@ = @@a1@@ % @@a2@@ ; @@a1@@ = @@a2@@ ; @@a2@@ = @@v5@@ ; } while ( @@v5@@ ) ; return @@a1@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
void __fastcall freea ( unsigned __int64 @@a1@@ ) { _QWORD * @@i@@ ; if ( @@a1@@ && * ( _DWORD * ) ( @@a1@@ - Number ) == Number ) { for ( @@i@@ = & mmalloca_results [ @@a1@@ % Number ] ; * @@i@@ ; @@i@@ = ( _QWORD * ) ( * @@i@@ - Number L ) ) { if ( @@a1@@ == * @@i@@ ) { * @@i@@ = * ( _QWORD * ) ( @@a1@@ - Number ) ; free ( ( void * ) ( @@a1@@ - Number ) ) ; return ; } } } }
_BOOL8 __fastcall hash_table_ok ( __int64 @@a1@@ ) { _QWORD * @@i@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; _QWORD * @@v5@@ ; @@v3@@ = Number L ; @@v4@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { @@v5@@ = @@i@@ ; ++ @@v3@@ ; ++ @@v4@@ ; while ( Number ) { @@v5@@ = ( _QWORD * ) @@v5@@ [ Number ] ; if ( ! @@v5@@ ) break ; ++ @@v4@@ ; } } } return @@v3@@ == * ( _QWORD * ) ( @@a1@@ + Number ) && @@v4@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
int group_member ( __gid_t @@gid@@ ) { return group_member ( @@gid@@ ) ; }
__int64 __fastcall io_blksize ( __int64 a1 , __int64 a2 , __int64 a3 , __int64 a4 , __int64 a5 , __int64 a6 , int a7 , int a8 , int a9 , int a10 , int a11 , int a12 , int a13 , __int64 @@a14@@ ) { __int64 @@result@@ ; if ( @@a14@@ <= Number || ( unsigned __int64 ) @@a14@@ > Number || @@a14@@ <= Number ) { @@result@@ = Number ; } else { @@result@@ = @@a14@@ ; } return @@result@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
int isatty ( int @@fd@@ ) { return isatty ( @@fd@@ ) ; }
__int64 __fastcall copy ( char * @@a1@@ , char * @@a2@@ , char @@a3@@ , unsigned int * @@a4@@ , bool * @@a5@@ , _BYTE * @@a6@@ ) { char @@v11@@ ; unsigned __int64 @@v12@@ ; @@v12@@ = __readfsqword ( Number ) ; if ( ! ( unsigned __int8 ) valid_options ( ( __int64 ) @@a4@@ ) ) __assert_fail ( String , String , Number , String ) ; top_level_src_name = ( __int64 ) @@a1@@ ; top_level_dst_name = ( __int64 ) @@a2@@ ; @@v11@@ = Number ; return copy_internal ( @@a1@@ , @@a2@@ , @@a3@@ , Number L , Number L , @@a4@@ , Number , & @@v11@@ , @@a5@@ , @@a6@@ ) ; }
unsigned __int64 __fastcall hash_get_entries ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; _QWORD * @@i@@ ; _QWORD * @@j@@ ; @@v5@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = @@i@@ ; @@j@@ ; @@j@@ = ( _QWORD * ) @@j@@ [ Number ] ) { if ( @@v5@@ >= @@a3@@ ) return @@v5@@ ; @@v4@@ = @@v5@@ ++ ; * ( _QWORD * ) ( @@a2@@ + Number * @@v4@@ ) = * @@j@@ ; } } } return @@v5@@ ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_2060C8 ; @@v8@@ [ Number ] = qword_2060D0 ; @@v8@@ [ Number ] = qword_2060D8 ; @@v8@@ [ Number ] = qword_2060E0 ; @@v8@@ [ Number ] = qword_2060E8 ; @@v8@@ [ Number ] = qword_2060F0 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
int __fastcall chmod_or_fchmod ( const char * @@a1@@ , int @@a2@@ , __mode_t @@a3@@ ) { int @@result@@ ; if ( @@a2@@ == Number ) @@result@@ = chmod ( @@a1@@ , @@a3@@ ) ; else @@result@@ = fchmod ( @@a2@@ , @@a3@@ ) ; return @@result@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
__int64 __fastcall set_owner ( __int64 @@a1@@ , const char * @@a2@@ , unsigned int @@a3@@ , _DWORD * @@a4@@ , char @@a5@@ , __int64 @@a6@@ ) { int @@v6@@ ; unsigned __int16 @@v7@@ ; __int64 @@v8@@ ; char * @@v9@@ ; int * @@v10@@ ; __int64 @@result@@ ; __int64 @@v12@@ ; char * @@v13@@ ; int * @@v14@@ ; __uid_t @@owner@@ ; __gid_t @@group@@ ; int @@v18@@ ; unsigned int @@v19@@ ; int @@v20@@ ; int @@v21@@ ; @@owner@@ = @@a4@@ [ Number ] ; @@group@@ = @@a4@@ [ Number ] ; if ( @@a5@@ != Number && ( * ( _BYTE * ) ( @@a1@@ + Number ) || * ( _BYTE * ) ( @@a1@@ + Number ) || * ( _BYTE * ) ( @@a1@@ + Number ) ) && ( ( @@v18@@ = * ( _DWORD * ) ( @@a6@@ + Number ) , ! * ( _BYTE * ) ( @@a1@@ + Number ) ) && ! * ( _BYTE * ) ( @@a1@@ + Number ) ? ( @@v6@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ) : ( @@v6@@ = @@a4@@ [ Number ] ) , ( @@v19@@ = ( unsigned __int16 ) @@v6@@ & ( unsigned __int16 ) @@v18@@ & Number , @@v7@@ = ~ ( _WORD ) @@v6@@ , HIBYTE ( @@v7@@ ) |= Number , ( ( unsigned __int16 ) @@v18@@ & @@v7@@ & Number ) != Number ) && ( unsigned int ) qset_acl ( @@a2@@ , @@a3@@ , @@v19@@ ) ) ) { if ( ( unsigned __int8 ) owner_failure_ok ( @@a1@@ ) != Number ) { @@v8@@ = quote ( @@a2@@ ) ; @@v9@@ = gettext ( String ) ; @@v10@@ = __errno_location ( ) ; error ( Number , * @@v10@@ , @@v9@@ , @@v8@@ ) ; } @@result@@ = ( unsigned int ) - * ( unsigned __int8 * ) ( @@a1@@ + Number ) ; } else { if ( @@a3@@ == Number ) { if ( ! lchown ( @@a2@@ , @@owner@@ , @@group@@ ) ) return Number L ; if ( * __errno_location ( ) == Number || * __errno_location ( ) == Number ) { @@v20@@ = * __errno_location ( ) ; lchown ( @@a2@@ , Number , @@group@@ ) ; ignore_value_0 ( ) ; * __errno_location ( ) = @@v20@@ ; } } else { if ( ! fchown ( @@a3@@ , @@owner@@ , @@group@@ ) ) return Number L ; if ( * __errno_location ( ) == Number || * __errno_location ( ) == Number ) { @@v21@@ = * __errno_location ( ) ; fchown ( @@a3@@ , Number , @@group@@ ) ; ignore_value_0 ( ) ; * __errno_location ( ) = @@v21@@ ; } } if ( ( unsigned __int8 ) chown_failure_ok ( @@a1@@ ) != Number && ( @@v12@@ = quote ( @@a2@@ ) , @@v13@@ = gettext ( String ) , @@v14@@ = __errno_location ( ) , error ( Number , * @@v14@@ , @@v13@@ , @@v12@@ ) , * ( _BYTE * ) ( @@a1@@ + Number ) ) ) { @@result@@ = Number ; } else { @@result@@ = Number L ; } } return @@result@@ ; }
__int64 __fastcall next_prime ( unsigned __int64 @@a1@@ ) { __int64 @@v2@@ ; __int64 @@i@@ ; @@v2@@ = @@a1@@ ; if ( @@a1@@ <= Number ) @@v2@@ = Number L ; for ( @@i@@ = @@v2@@ | Number ; @@i@@ != Number && ! is_prime ( @@i@@ ) ; @@i@@ += Number L ) { ; } return @@i@@ ; }
__mode_t umask ( __mode_t @@mask@@ ) { return umask ( @@mask@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
__int64 __fastcall set_acl ( const char * @@a1@@ , int @@a2@@ , __mode_t @@a3@@ ) { __int64 @@v3@@ ; char * @@v4@@ ; int * @@v5@@ ; unsigned int @@v7@@ ; @@v7@@ = qset_acl ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( @@v7@@ ) { @@v3@@ = quote ( @@a1@@ ) ; @@v4@@ = gettext ( String ) ; @@v5@@ = __errno_location ( ) ; error ( Number , * @@v5@@ , @@v4@@ , @@v3@@ ) ; } return @@v7@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
__int64 __fastcall free_entry ( __int64 @@a1@@ , _QWORD * @@a2@@ ) { __int64 @@result@@ ; * @@a2@@ = Number L ; @@a2@@ [ Number ] = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@result@@ = @@a1@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
int rename ( const char * @@old@@ , const char * @@a2@@ ) { return rename ( @@old@@ , @@a2@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int64 __fastcall full_write ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v5@@ ; __int64 @@v7@@ ; @@v5@@ = Number L ; while ( @@a3@@ ) { @@v7@@ = safe_write ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( @@v7@@ == Number ) break ; if ( ! @@v7@@ ) { * __errno_location ( ) = Number ; return @@v5@@ ; } @@v5@@ += @@v7@@ ; @@a2@@ += @@v7@@ ; @@a3@@ -= @@v7@@ ; } return @@v5@@ ; }
__int64 __fastcall remember_copied ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v5@@ ; __int64 @@v6@@ ; @@v5@@ = xmalloc ( Number L ) ; * ( _QWORD * ) ( @@v5@@ + Number ) = xstrdup ( @@a1@@ ) ; * ( _QWORD * ) @@v5@@ = @@a2@@ ; * ( _QWORD * ) ( @@v5@@ + Number ) = @@a3@@ ; @@v6@@ = hash_insert ( src_to_dest , @@v5@@ ) ; if ( ! @@v6@@ ) xalloc_die ( ) ; if ( @@v6@@ == @@v5@@ ) return Number L ; src_to_dest_free ( ( void * * ) @@v5@@ ) ; return * ( _QWORD * ) ( @@v6@@ + Number ) ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
void __fastcall rm_option_init ( __int64 @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; int * @@v3@@ ; * ( _BYTE * ) @@a1@@ = Number ; * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; * ( _DWORD * ) ( @@a1@@ + Number ) = Number ; * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; * ( _QWORD * ) ( @@a1@@ + Number ) = get_root_dev_ino ( & dev_ino_buf_5763 ) ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) { @@v1@@ = quote ( String ) ; @@v2@@ = gettext ( String ) ; @@v3@@ = __errno_location ( ) ; error ( Number , * @@v3@@ , @@v2@@ , @@v1@@ ) ; } }
__int64 __fastcall hash_rehash ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; unsigned __int64 @@nmemb@@ ; void * @@v4@@ ; __int64 @@v5@@ ; unsigned __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; __int64 @@v12@@ ; __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; @@v14@@ = __readfsqword ( Number ) ; @@nmemb@@ = compute_bucket_size ( @@a2@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ; if ( ! @@nmemb@@ ) return Number L ; if ( @@nmemb@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; @@v4@@ = calloc ( @@nmemb@@ , Number ) ; if ( ! @@v4@@ ) return Number L ; @@v6@@ = @@nmemb@@ ; @@v5@@ = ( __int64 ) @@v4@@ + Number * @@nmemb@@ ; @@v7@@ = Number L ; @@v8@@ = Number L ; @@v9@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v10@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v11@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v12@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v13@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( ( unsigned __int8 ) transfer_entries ( ( __int64 ) & @@v4@@ , @@a1@@ , Number ) ) { free ( * ( void * * ) @@a1@@ ) ; * ( _QWORD * ) @@a1@@ = @@v4@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v5@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v6@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v7@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v13@@ ; @@result@@ = Number L ; } else { * ( _QWORD * ) ( @@a1@@ + Number ) = @@v13@@ ; if ( ( unsigned __int8 ) transfer_entries ( @@a1@@ , ( __int64 ) & @@v4@@ , Number ) != Number || ( unsigned __int8 ) transfer_entries ( @@a1@@ , ( __int64 ) & @@v4@@ , Number ) != Number ) { abort ( ) ; } free ( @@v4@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
int __fastcall qcopy_acl ( __int64 a1 , __int64 a2 , const char * @@a3@@ , int @@a4@@ , __mode_t @@a5@@ ) { return qset_acl ( @@a3@@ , @@a4@@ , @@a5@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; FILE * @@v11@@ ; char * @@v12@@ ; FILE * @@v13@@ ; char * @@v14@@ ; FILE * @@v15@@ ; char * @@v16@@ ; FILE * @@v17@@ ; char * @@v18@@ ; FILE * @@v19@@ ; char * @@v20@@ ; FILE * @@v21@@ ; char * @@v22@@ ; FILE * @@v23@@ ; char * @@v24@@ ; if ( @@a1@@ ) { @@v1@@ = program_name ; @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = program_name ; @@v4@@ = program_name ; @@v5@@ = program_name ; @@v6@@ = gettext ( String String String ) ; printf ( @@v6@@ , @@v5@@ , @@v4@@ , @@v3@@ ) ; @@v7@@ = stdout ; @@v8@@ = gettext ( String ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = stdout ; @@v10@@ = gettext ( String ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; @@v11@@ = stdout ; @@v12@@ = gettext ( String String String String String String ) ; fputs_unlocked ( @@v12@@ , @@v11@@ ) ; @@v13@@ = stdout ; @@v14@@ = gettext ( String String String ) ; fputs_unlocked ( @@v14@@ , @@v13@@ ) ; @@v15@@ = stdout ; @@v16@@ = gettext ( String String String String String String ) ; fputs_unlocked ( @@v16@@ , @@v15@@ ) ; @@v17@@ = stdout ; @@v18@@ = gettext ( String ) ; fputs_unlocked ( @@v18@@ , @@v17@@ ) ; @@v19@@ = stdout ; @@v20@@ = gettext ( String ) ; fputs_unlocked ( @@v20@@ , @@v19@@ ) ; @@v21@@ = stdout ; @@v22@@ = gettext ( String String String String String ) ; fputs_unlocked ( @@v22@@ , @@v21@@ ) ; @@v23@@ = stdout ; @@v24@@ = gettext ( String String String String ) ; fputs_unlocked ( @@v24@@ , @@v23@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
DIR * __fastcall opendir_safer ( const char * @@a1@@ ) { int @@v2@@ ; int @@fd@@ ; int @@v4@@ ; DIR * @@dirp@@ ; DIR * @@v6@@ ; @@dirp@@ = opendir ( @@a1@@ ) ; if ( @@dirp@@ ) { @@v2@@ = dirfd ( @@dirp@@ ) ; if ( @@v2@@ >= Number && @@v2@@ <= Number ) { @@fd@@ = dup_safer ( ( unsigned int ) @@v2@@ ) ; @@v6@@ = fdopendir ( @@fd@@ ) ; @@v4@@ = * __errno_location ( ) ; if ( ! @@v6@@ ) close ( @@fd@@ ) ; closedir ( @@dirp@@ ) ; * __errno_location ( ) = @@v4@@ ; @@dirp@@ = @@v6@@ ; } } return @@dirp@@ ; }
__int64 __fastcall full_write ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v5@@ ; __int64 @@v7@@ ; @@v5@@ = Number L ; while ( @@a3@@ ) { @@v7@@ = safe_write ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( @@v7@@ == Number ) break ; if ( ! @@v7@@ ) { * __errno_location ( ) = Number ; return @@v5@@ ; } @@v5@@ += @@v7@@ ; @@a2@@ += @@v7@@ ; @@a3@@ -= @@v7@@ ; } return @@v5@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
void * __fastcall find_backup_file_name ( const char * @@a1@@ , int @@a2@@ ) { int @@v2@@ ; bool @@v4@@ ; void * @@dest@@ ; size_t @@v6@@ ; __int64 @@v7@@ ; size_t @@n@@ ; unsigned __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; @@v10@@ = __readfsqword ( Number ) ; @@v7@@ = strlen ( @@a1@@ ) ; @@v4@@ = Number ; @@n@@ = strlen ( simple_backup_suffix ) + Number ; @@v6@@ = @@n@@ ; if ( @@n@@ <= Number ) @@v6@@ = Number L ; @@v9@@ = @@v7@@ + @@v6@@ + Number ; @@dest@@ = ( void * ) xmalloc ( @@v9@@ ) ; memcpy ( @@dest@@ , @@a1@@ , @@v7@@ + Number ) ; if ( @@a2@@ != Number ) { @@v2@@ = numbered_backup ( ( __int64 * ) & @@dest@@ , @@v9@@ , @@v7@@ ) ; switch ( @@v2@@ ) { case Number : @@v4@@ = Number ; break ; case Number : return @@dest@@ ; case Number : @@v4@@ = @@a2@@ == Number ; break ; } } if ( @@v4@@ ) memcpy ( ( char * ) @@dest@@ + @@v7@@ , simple_backup_suffix , @@n@@ ) ; check_extension ( ( const char * ) @@dest@@ , @@v7@@ , Number ) ; return @@dest@@ ; }
unsigned __int64 __fastcall gcd ( unsigned __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { unsigned __int64 @@v5@@ ; do { @@v5@@ = @@a1@@ % @@a2@@ ; @@a1@@ = @@a2@@ ; @@a2@@ = @@v5@@ ; } while ( @@v5@@ ) ; return @@a1@@ ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
_BOOL8 __fastcall triple_compare ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { return @@a1@@ [ Number ] == @@a2@@ [ Number ] && @@a1@@ [ Number ] == @@a2@@ [ Number ] && ( unsigned __int8 ) same_name ( * @@a1@@ , * @@a2@@ ) ; }
void * __fastcall mdir_name ( _BYTE * @@a1@@ ) { _BYTE * @@n@@ ; void * @@dest@@ ; @@n@@ = dir_len ( @@a1@@ ) ; @@dest@@ = malloc ( ( size_t ) & @@n@@ [ ( @@n@@ == Number L ) + Number ] ) ; if ( ! @@dest@@ ) return Number L ; memcpy ( @@dest@@ , @@a1@@ , ( size_t ) @@n@@ ) ; if ( ! @@n@@ ) { @@n@@ = ( _BYTE * ) ( & dword_0 + Number ) ; * ( _BYTE * ) @@dest@@ = Number ; } @@n@@ [ ( _QWORD ) @@dest@@ ] = Number ; return @@dest@@ ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_21D048 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
__int64 __fastcall strnlen1 ( const void * @@a1@@ , size_t @@a2@@ ) { __int64 @@result@@ ; _BYTE * @@v3@@ ; @@v3@@ = memchr ( @@a1@@ , Number , @@a2@@ ) ; if ( @@v3@@ ) @@result@@ = @@v3@@ - ( _BYTE * ) @@a1@@ + Number ; else @@result@@ = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall is_ancestor ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { while ( @@a2@@ ) { if ( @@a2@@ [ Number ] == @@a1@@ [ Number ] && @@a2@@ [ Number ] == * @@a1@@ ) return Number L ; @@a2@@ = ( _QWORD * ) * @@a2@@ ; } return Number L ; }
void * __fastcall mfile_name_concat ( _BYTE * @@a1@@ , _BYTE * @@a2@@ , _QWORD * @@a3@@ ) { _BOOL4 @@v3@@ ; const char * @@v6@@ ; size_t @@v7@@ ; size_t @@n@@ ; _BOOL8 @@v9@@ ; char * @@s@@ ; size_t @@v11@@ ; void * @@dest@@ ; _BYTE * @@v13@@ ; char * @@v14@@ ; @@v6@@ = last_component ( @@a1@@ ) ; @@v7@@ = base_len ( @@v6@@ ) ; @@n@@ = @@v6@@ - @@a1@@ + @@v7@@ ; @@v3@@ = @@v7@@ && @@v6@@ [ @@v7@@ - Number ] != Number ; @@v9@@ = @@v3@@ ; @@s@@ = longest_relative_suffix ( @@a2@@ ) ; @@v11@@ = strlen ( @@s@@ ) ; @@dest@@ = malloc ( @@v9@@ + @@n@@ + @@v11@@ + Number ) ; if ( ! @@dest@@ ) return Number L ; @@v13@@ = mempcpy ( @@dest@@ , @@a1@@ , @@n@@ ) ; * @@v13@@ = Number ; @@v14@@ = & @@v13@@ [ @@v9@@ ] ; if ( @@a3@@ ) * @@a3@@ = & @@v14@@ [ - ( * @@a2@@ == Number ) ] ; * ( _BYTE * ) mempcpy ( @@v14@@ , @@s@@ , @@v11@@ ) = Number ; return @@dest@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
_BOOL8 __fastcall abandon_move ( __int64 @@a1@@ , const char * @@a2@@ , __int64 @@a3@@ ) { bool @@v3@@ ; if ( ! * ( _BYTE * ) ( @@a1@@ + Number ) ) __assert_fail ( String , String , Number , String ) ; @@v3@@ = Number ; if ( * ( _DWORD * ) ( @@a1@@ + Number ) != Number ) { if ( * ( _DWORD * ) ( @@a1@@ + Number ) != Number && ( * ( _DWORD * ) ( @@a1@@ + Number ) != Number || ! * ( _BYTE * ) ( @@a1@@ + Number ) || writable_destination ( @@a2@@ , * ( _DWORD * ) ( @@a3@@ + Number ) ) ) || ( overwrite_prompt ( @@a2@@ , @@a3@@ ) , ( unsigned __int8 ) yesno ( ) == Number ) ) { @@v3@@ = Number ; } } return @@v3@@ ; }
unsigned __int64 __fastcall leave_dir ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 * @@v3@@ ; __int64 * @@v4@@ ; void * @@ptr@@ ; __int64 @@v6@@ [ Number ] ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v3@@ = ( __int64 * ) ( @@a2@@ + Number ) ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { @@v6@@ [ Number ] = * @@v3@@ ; @@v6@@ [ Number ] = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@ptr@@ = ( void * ) hash_delete ( * ( _QWORD * ) ( @@a1@@ + Number ) , @@v6@@ ) ; if ( ! @@ptr@@ ) abort ( ) ; free ( @@ptr@@ ) ; } else { @@v4@@ = * ( __int64 * * ) ( @@a2@@ + Number ) ; if ( @@v4@@ && @@v4@@ [ Number ] >= Number ) { if ( ! * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L ) ) abort ( ) ; if ( * * ( _QWORD * * ) ( @@a1@@ + Number ) == * ( _QWORD * ) ( @@a2@@ + Number ) && * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L ) == * @@v3@@ ) { * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L ) = @@v4@@ [ Number ] ; * * ( _QWORD * * ) ( @@a1@@ + Number ) = @@v4@@ [ Number ] ; } } } return __readfsqword ( Number ) ^ @@v7@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
unsigned __int64 __fastcall LCO_hash ( _QWORD * @@a1@@ , unsigned __int64 @@a2@@ ) { return * @@a1@@ % @@a2@@ ; }
_BOOL8 __fastcall owner_failure_ok ( __int64 @@a1@@ ) { return ( * __errno_location ( ) == Number || * __errno_location ( ) == Number ) && * ( _BYTE * ) ( @@a1@@ + Number ) != Number ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
bool __fastcall LCO_compare ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { return * @@a1@@ == * @@a2@@ ; }
void __fastcall argmatch_invalid ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { char * @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; char * @@format@@ ; if ( @@a3@@ == Number ) @@v3@@ = gettext ( String ) ; else @@v3@@ = gettext ( String ) ; @@format@@ = @@v3@@ ; @@v4@@ = quote_n ( Number L , @@a1@@ ) ; @@v5@@ = quotearg_n_style ( Number L , Number L , @@a2@@ ) ; error ( Number , Number , @@format@@ , @@v5@@ , @@v4@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
__int64 __fastcall remember_copied ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v5@@ ; __int64 @@v6@@ ; @@v5@@ = xmalloc ( Number L ) ; * ( _QWORD * ) ( @@v5@@ + Number ) = xstrdup ( @@a1@@ ) ; * ( _QWORD * ) @@v5@@ = @@a2@@ ; * ( _QWORD * ) ( @@v5@@ + Number ) = @@a3@@ ; @@v6@@ = hash_insert ( src_to_dest , @@v5@@ ) ; if ( ! @@v6@@ ) xalloc_die ( ) ; if ( @@v6@@ == @@v5@@ ) return Number L ; src_to_dest_free ( ( void * * ) @@v5@@ ) ; return * ( _QWORD * ) ( @@v6@@ + Number ) ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
int __fastcall argmatch_valid ( __int64 @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { char * @@v3@@ ; __int64 @@i@@ ; void * @@s1@@ ; @@s1@@ = Number L ; @@v3@@ = gettext ( String ) ; fprintf ( stderr , @@v3@@ ) ; for ( @@i@@ = Number L ; * ( _QWORD * ) ( Number * @@i@@ + @@a1@@ ) ; ++ @@i@@ ) { if ( @@i@@ && ! memcmp ( @@s1@@ , ( const void * ) ( @@i@@ * @@a3@@ + @@a2@@ ) , @@a3@@ ) ) { fprintf ( stderr , String , * ( const char * * ) ( Number * @@i@@ + @@a1@@ ) ) ; } else { fprintf ( stderr , String , * ( const char * * ) ( Number * @@i@@ + @@a1@@ ) ) ; @@s1@@ = ( void * ) ( @@i@@ * @@a3@@ + @@a2@@ ) ; } } return putc_unlocked ( Number , stderr ) ; }
_BYTE * __fastcall savedirstream ( DIR * @@a1@@ ) { __int64 @@v2@@ ; int @@v3@@ ; _BYTE * @@ptr@@ ; unsigned __int64 @@v5@@ ; size_t @@v6@@ ; struct dirent * @@v7@@ ; char * @@src@@ ; size_t @@n@@ ; @@v5@@ = Number L ; @@v6@@ = Number L ; if ( ! @@a1@@ ) return Number L ; @@ptr@@ = ( _BYTE * ) xmalloc ( Number L ) ; while ( Number ) { * __errno_location ( ) = Number ; @@v7@@ = readdir ( @@a1@@ ) ; if ( ! @@v7@@ ) break ; @@src@@ = @@v7@@ -> d_name ; if ( @@v7@@ -> d_name [ Number ] == Number ) { if ( @@v7@@ -> d_name [ Number ] == Number ) @@v2@@ = Number L ; else @@v2@@ = Number L ; } else { @@v2@@ = Number L ; } if ( @@src@@ [ @@v2@@ ] ) { @@n@@ = strlen ( @@v7@@ -> d_name ) + Number ; if ( @@v6@@ > @@v6@@ + @@n@@ ) xalloc_die ( ) ; if ( @@v5@@ <= @@v6@@ + @@n@@ ) { do { if ( @@v5@@ > Number * @@v5@@ ) xalloc_die ( ) ; @@v5@@ *= Number L ; } while ( @@v5@@ <= @@v6@@ + @@n@@ ) ; @@ptr@@ = ( _BYTE * ) xrealloc ( @@ptr@@ , @@v5@@ ) ; } memcpy ( & @@ptr@@ [ @@v6@@ ] , @@src@@ , @@n@@ ) ; @@v6@@ += @@n@@ ; } } @@ptr@@ [ @@v6@@ ] = Number ; @@v3@@ = * __errno_location ( ) ; if ( closedir ( @@a1@@ ) ) @@v3@@ = * __errno_location ( ) ; if ( ! @@v3@@ ) return @@ptr@@ ; free ( @@ptr@@ ) ; * __errno_location ( ) = @@v3@@ ; return Number L ; }
char * __fastcall areadlink_with_size ( const char * @@a1@@ , unsigned __int64 @@a2@@ ) { __int64 @@v2@@ ; char * @@i@@ ; int @@v5@@ ; size_t @@size@@ ; char * @@buf@@ ; ssize_t @@v8@@ ; if ( @@a2@@ >= Number ) @@v2@@ = Number L ; else @@v2@@ = @@a2@@ + Number ; @@size@@ = @@v2@@ ; LABEL_5 : for ( @@i@@ = ( char * ) malloc ( @@size@@ ) ; ; @@i@@ = ( char * ) malloc ( Number ) ) { @@buf@@ = @@i@@ ; if ( ! @@i@@ ) return Number L ; @@v8@@ = readlink ( @@a1@@ , @@i@@ , @@size@@ ) ; if ( @@v8@@ < Number && * __errno_location ( ) != Number ) { @@v5@@ = * __errno_location ( ) ; free ( @@buf@@ ) ; * __errno_location ( ) = @@v5@@ ; return Number L ; } if ( @@v8@@ < @@size@@ ) { @@buf@@ [ @@v8@@ ] = Number ; return @@buf@@ ; } free ( @@buf@@ ) ; if ( @@size@@ <= Number ) { @@size@@ *= Number L ; goto LABEL_5 ; } if ( @@size@@ > Number ) break ; @@size@@ = Number ; } * __errno_location ( ) = Number ; return Number L ; }
__int64 __fastcall fts_children ( __int64 @@a1@@ , int @@a2@@ ) { __int64 @@v3@@ ; __int64 @@v4@@ ; int @@v5@@ ; int @@v6@@ ; int @@v7@@ ; int @@v8@@ ; unsigned int @@v9@@ ; int @@fd@@ ; int @@v11@@ ; if ( @@a2@@ && @@a2@@ != Number ) { * __errno_location ( ) = Number ; return Number L ; } @@v3@@ = * ( _QWORD * ) @@a1@@ ; * __errno_location ( ) = Number ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) return Number L ; if ( * ( _WORD * ) ( @@v3@@ + Number ) == Number ) return * ( _QWORD * ) ( @@v3@@ + Number ) ; if ( * ( _WORD * ) ( @@v3@@ + Number ) != Number ) return Number L ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) fts_lfree ( * ( void * * ) ( @@a1@@ + Number ) ) ; if ( @@a2@@ == Number ) { @@v8@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; BYTE1 ( @@v8@@ ) |= Number ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@v8@@ ; @@v9@@ = Number ; } else { @@v9@@ = Number ; } if ( * ( _QWORD * ) ( @@v3@@ + Number ) || * * ( _BYTE * * ) ( @@v3@@ + Number ) == Number || ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { * ( _QWORD * ) ( @@a1@@ + Number ) = fts_build ( @@a1@@ , @@v9@@ ) ; return * ( _QWORD * ) ( @@a1@@ + Number ) ; } @@fd@@ = diropen ( @@a1@@ , ( int ) String , @@v4@@ , @@v5@@ , @@v6@@ , @@v7@@ ) ; if ( @@fd@@ < Number ) { * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; return Number L ; } * ( _QWORD * ) ( @@a1@@ + Number ) = fts_build ( @@a1@@ , @@v9@@ ) ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { cwd_advance_fd ( @@a1@@ , @@fd@@ , Number ) ; } else { if ( fchdir ( @@fd@@ ) ) { @@v11@@ = * __errno_location ( ) ; close ( @@fd@@ ) ; * __errno_location ( ) = @@v11@@ ; return Number L ; } close ( @@fd@@ ) ; } return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
__int64 __fastcall xget_version ( __int64 @@a1@@ , const char * @@a2@@ ) { char * @@v3@@ ; if ( @@a2@@ && * @@a2@@ ) return get_version ( @@a1@@ , @@a2@@ ) ; @@v3@@ = getenv ( String ) ; return get_version ( ( __int64 ) String , @@v3@@ ) ; }
__int64 __fastcall get_stat_atime_1 ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
_BOOL8 __fastcall triple_compare ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { return @@a1@@ [ Number ] == @@a2@@ [ Number ] && @@a1@@ [ Number ] == @@a2@@ [ Number ] && ( unsigned __int8 ) same_name ( * @@a1@@ , * @@a2@@ ) ; }
__int64 __fastcall fts_padjust ( __int64 @@a1@@ , _QWORD * @@a2@@ ) { _QWORD * @@v2@@ ; __int64 @@result@@ ; _QWORD * @@i@@ ; __int64 @@v6@@ ; @@v6@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; for ( @@i@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; @@i@@ ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { if ( ( _QWORD * ) @@i@@ [ Number ] != @@i@@ + Number ) @@i@@ [ Number ] = @@v6@@ + @@i@@ [ Number ] - @@i@@ [ Number ] ; @@i@@ [ Number ] = @@v6@@ ; } while ( Number ) { @@result@@ = @@a2@@ [ Number ] ; if ( @@result@@ < Number ) break ; if ( ( _QWORD * ) @@a2@@ [ Number ] != @@a2@@ + Number ) @@a2@@ [ Number ] = @@v6@@ + @@a2@@ [ Number ] - @@a2@@ [ Number ] ; @@a2@@ [ Number ] = @@v6@@ ; if ( @@a2@@ [ Number ] ) @@v2@@ = ( _QWORD * ) @@a2@@ [ Number ] ; else @@v2@@ = ( _QWORD * ) @@a2@@ [ Number ] ; @@a2@@ = @@v2@@ ; } return @@result@@ ; }
__int64 __fastcall xnrealloc ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { if ( ! is_mul_ok ( @@a3@@ , @@a2@@ ) ) xalloc_die ( ) ; return xrealloc ( @@a1@@ , @@a3@@ * @@a2@@ ) ; }
__int64 close_stdin ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char @@v4@@ ; char * @@v5@@ ; @@v4@@ = Number ; if ( freadahead ( stdin ) && ! ( unsigned int ) rpl_fseeko ( stdin , Number L , Number L ) && ( unsigned int ) rpl_fflush ( stdin ) ) @@v4@@ = Number ; if ( ( unsigned int ) close_stream ( stdin ) ) @@v4@@ = Number ; if ( @@v4@@ ) { @@v5@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v5@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v5@@ ) ; } } @@result@@ = close_stdout ( ) ; if ( @@v4@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_207038 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
__int64 __fastcall hash_get_n_entries ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( ) ; return @@ptr@@ ; }
int __fastcall rpl_fflush ( FILE * @@a1@@ ) { if ( ! @@a1@@ || ! __freading ( @@a1@@ ) ) return fflush ( @@a1@@ ) ; clear_ungetc_buffer_preserving_position ( @@a1@@ ) ; return fflush ( @@a1@@ ) ; }
__int64 __fastcall xget_version ( __int64 @@a1@@ , _BYTE * @@a2@@ ) { char * @@v3@@ ; if ( @@a2@@ && * @@a2@@ ) return get_version ( @@a1@@ , @@a2@@ ) ; @@v3@@ = getenv ( String ) ; return get_version ( ( __int64 ) String , @@v3@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
unsigned __int64 __fastcall hash_pjw ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ ) { unsigned __int64 @@v4@@ ; @@v4@@ = Number L ; while ( * @@a1@@ ) @@v4@@ = __ROL8__ ( @@v4@@ , Number ) + ( char ) * @@a1@@ ++ ; return @@v4@@ % @@a2@@ ; }
__int64 __fastcall hash_get_first ( unsigned __int64 * @@a1@@ ) { unsigned __int64 @@i@@ ; if ( ! @@a1@@ [ Number ] ) return Number L ; for ( @@i@@ = * @@a1@@ ; ; @@i@@ += Number L ) { if ( @@i@@ >= @@a1@@ [ Number ] ) abort ( ) ; if ( * ( _QWORD * ) @@i@@ ) break ; } return * ( _QWORD * ) @@i@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
int isatty ( int @@fd@@ ) { return isatty ( @@fd@@ ) ; }
DIR * opendir ( const char * @@name@@ ) { return opendir ( @@name@@ ) ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
int closedir ( DIR * @@dirp@@ ) { return closedir ( @@dirp@@ ) ; }
__int64 __fastcall hash_do_for_each ( __int64 @@a1@@ , unsigned __int8 ( __fastcall * @@a2@@ ) ( _QWORD , __int64 ) , __int64 @@a3@@ ) { __int64 @@v5@@ ; _QWORD * @@i@@ ; _QWORD * @@j@@ ; @@v5@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = @@i@@ ; @@j@@ ; @@j@@ = ( _QWORD * ) @@j@@ [ Number ] ) { if ( @@a2@@ ( * @@j@@ , @@a3@@ ) != Number ) return @@v5@@ ; ++ @@v5@@ ; } } } return @@v5@@ ; }
int rpmatch ( const char * @@response@@ ) { return rpmatch ( @@response@@ ) ; }
__int64 __fastcall mb_copy ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; if ( * ( _QWORD * ) @@a2@@ == @@a2@@ + Number ) { memcpy ( ( void * ) ( @@a1@@ + Number ) , ( const void * ) ( @@a2@@ + Number ) , * ( _QWORD * ) ( @@a2@@ + Number ) ) ; * ( _QWORD * ) @@a1@@ = @@a1@@ + Number ; } else { * ( _QWORD * ) @@a1@@ = * ( _QWORD * ) @@a2@@ ; } * ( _QWORD * ) ( @@a1@@ + Number ) = * ( _QWORD * ) ( @@a2@@ + Number ) ; * ( _BYTE * ) ( @@a1@@ + Number ) = * ( _BYTE * ) ( @@a2@@ + Number ) ; @@result@@ = * ( unsigned __int8 * ) ( @@a1@@ + Number ) ; if ( ( _BYTE ) @@result@@ ) { @@result@@ = @@a1@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = * ( _DWORD * ) ( @@a2@@ + Number ) ; } return @@result@@ ; }
__int64 close_stdin ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char @@v4@@ ; char * @@v5@@ ; @@v4@@ = Number ; if ( freadahead ( stdin ) && ! ( unsigned int ) rpl_fseeko ( stdin , Number L , Number L ) && ( unsigned int ) rpl_fflush ( stdin ) ) @@v4@@ = Number ; if ( ( unsigned int ) close_stream ( stdin ) ) @@v4@@ = Number ; if ( @@v4@@ ) { @@v5@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v5@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v5@@ ) ; } } @@result@@ = close_stdout ( ) ; if ( @@v4@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
_BYTE * __fastcall strmode ( __int16 @@a1@@ , _BYTE * @@a2@@ ) { char @@v2@@ ; char @@v3@@ ; char @@v4@@ ; char @@v5@@ ; char @@v6@@ ; char @@v7@@ ; char @@v8@@ ; char @@v9@@ ; char @@v10@@ ; _BYTE * @@result@@ ; * @@a2@@ = ftypelet ( @@a1@@ ) ; if ( ( @@a1@@ & Number ) != Number ) @@v2@@ = Number ; else @@v2@@ = Number ; @@a2@@ [ Number ] = @@v2@@ ; if ( ( @@a1@@ & Number ) != Number ) @@v3@@ = Number ; else @@v3@@ = Number ; @@a2@@ [ Number ] = @@v3@@ ; if ( ( @@a1@@ & Number ) != Number ) { if ( ( @@a1@@ & Number ) != Number ) @@v4@@ = Number ; else @@v4@@ = Number ; } else if ( ( @@a1@@ & Number ) != Number ) { @@v4@@ = Number ; } else { @@v4@@ = Number ; } @@a2@@ [ Number ] = @@v4@@ ; if ( ( @@a1@@ & Number ) != Number ) @@v5@@ = Number ; else @@v5@@ = Number ; @@a2@@ [ Number ] = @@v5@@ ; if ( ( @@a1@@ & Number ) != Number ) @@v6@@ = Number ; else @@v6@@ = Number ; @@a2@@ [ Number ] = @@v6@@ ; if ( ( @@a1@@ & Number ) != Number ) { if ( ( @@a1@@ & Number ) != Number ) @@v7@@ = Number ; else @@v7@@ = Number ; } else if ( ( @@a1@@ & Number ) != Number ) { @@v7@@ = Number ; } else { @@v7@@ = Number ; } @@a2@@ [ Number ] = @@v7@@ ; if ( ( @@a1@@ & Number ) != Number ) @@v8@@ = Number ; else @@v8@@ = Number ; @@a2@@ [ Number ] = @@v8@@ ; if ( ( @@a1@@ & Number ) != Number ) @@v9@@ = Number ; else @@v9@@ = Number ; @@a2@@ [ Number ] = @@v9@@ ; if ( ( @@a1@@ & Number ) != Number ) { if ( ( @@a1@@ & Number ) != Number ) @@v10@@ = Number ; else @@v10@@ = Number ; } else if ( ( @@a1@@ & Number ) != Number ) { @@v10@@ = Number ; } else { @@v10@@ = Number ; } @@a2@@ [ Number ] = @@v10@@ ; @@a2@@ [ Number ] = Number ; @@result@@ = @@a2@@ + Number ; @@a2@@ [ Number ] = Number ; return @@result@@ ; }
int fflush ( FILE * @@stream@@ ) { return fflush ( @@stream@@ ) ; }
unsigned __int64 __fastcall compute_bucket_size ( __int64 @@a1@@ , __int64 @@a2@@ ) { float @@v2@@ ; unsigned __int64 @@result@@ ; unsigned __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; float @@v6@@ ; @@v4@@ = @@a1@@ ; if ( * ( _BYTE * ) ( @@a2@@ + Number ) != Number ) { if ( @@a1@@ < Number ) @@v2@@ = ( float ) ( @@a1@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@a1@@ >> Number ) ) + ( float ) ( @@a1@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@a1@@ >> Number ) ) ; else @@v2@@ = ( float ) ( int ) @@a1@@ ; @@v6@@ = @@v2@@ / * ( float * ) ( @@a2@@ + Number ) ; if ( @@v6@@ >= Number ) return Number L ; if ( @@v6@@ >= Number ) @@v4@@ = ( unsigned int ) ( int ) ( float ) ( @@v6@@ - Number ) ^ Number ; else @@v4@@ = ( unsigned int ) ( int ) @@v6@@ ; } @@v5@@ = next_prime ( @@v4@@ ) ; if ( @@v5@@ <= Number ) @@result@@ = @@v5@@ ; else @@result@@ = Number L ; return @@result@@ ; }
DIR * fdopendir ( int @@fd@@ ) { return fdopendir ( @@fd@@ ) ; }
__int64 __fastcall clear_ungetc_buffer_preserving_position ( _DWORD * @@a1@@ ) { __int64 @@result@@ ; @@result@@ = * @@a1@@ & Number ; if ( ( _DWORD ) @@result@@ ) @@result@@ = rpl_fseeko ( @@a1@@ , Number L , Number L ) ; return @@result@@ ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
void free ( void * @@ptr@@ ) { __imp_free ( @@ptr@@ ) ; }
__int64 __fastcall hash_get_first ( unsigned __int64 * @@a1@@ ) { unsigned __int64 @@i@@ ; if ( ! @@a1@@ [ Number ] ) return Number L ; for ( @@i@@ = * @@a1@@ ; ; @@i@@ += Number L ) { if ( @@i@@ >= @@a1@@ [ Number ] ) abort ( ) ; if ( * ( _QWORD * ) @@i@@ ) break ; } return * ( _QWORD * ) @@i@@ ; }
__int64 __fastcall free_entry ( __int64 @@a1@@ , _QWORD * @@a2@@ ) { __int64 @@result@@ ; * @@a2@@ = Number L ; @@a2@@ [ Number ] = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@result@@ = @@a1@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall fd_safer ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { unsigned int @@fd@@ ; unsigned int @@v8@@ ; int @@v9@@ ; @@fd@@ = @@a1@@ ; if ( @@a1@@ >= Number && @@a1@@ <= Number ) { @@v8@@ = dup_safer ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; @@v9@@ = * __errno_location ( ) ; close ( @@a1@@ ) ; * __errno_location ( ) = @@v9@@ ; @@fd@@ = @@v8@@ ; } return @@fd@@ ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; char * @@v3@@ ; FILE * @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; FILE * @@v10@@ ; char * @@v11@@ ; FILE * @@v12@@ ; char * @@v13@@ ; FILE * @@v14@@ ; char * @@v15@@ ; FILE * @@v16@@ ; char * @@v17@@ ; __int64 @@v18@@ ; __int64 @@v19@@ ; char * @@v20@@ ; FILE * @@v21@@ ; char * @@v22@@ ; @@v1@@ = program_name ; if ( @@a1@@ ) { @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = gettext ( String ) ; printf ( @@v3@@ , @@v1@@ ) ; @@v4@@ = stdout ; @@v5@@ = gettext ( String String String String ) ; fputs_unlocked ( @@v5@@ , @@v4@@ ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String String String String String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; @@v8@@ = stdout ; @@v9@@ = gettext ( String String String ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = stdout ; @@v11@@ = gettext ( String String String String ) ; fputs_unlocked ( @@v11@@ , @@v10@@ ) ; @@v12@@ = stdout ; @@v13@@ = gettext ( String ) ; fputs_unlocked ( @@v13@@ , @@v12@@ ) ; @@v14@@ = stdout ; @@v15@@ = gettext ( String ) ; fputs_unlocked ( @@v15@@ , @@v14@@ ) ; @@v16@@ = stdout ; @@v17@@ = gettext ( String String String ) ; fputs_unlocked ( @@v17@@ , @@v16@@ ) ; @@v18@@ = program_name ; @@v19@@ = program_name ; @@v20@@ = gettext ( String String String String String String ) ; printf ( @@v20@@ , @@v19@@ , @@v18@@ ) ; @@v21@@ = stdout ; @@v22@@ = gettext ( String String String String ) ; fputs_unlocked ( @@v22@@ , @@v21@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
_BYTE * __fastcall strmode ( __int16 @@a1@@ , _BYTE * @@a2@@ ) { char @@v2@@ ; char @@v3@@ ; char @@v4@@ ; char @@v5@@ ; char @@v6@@ ; char @@v7@@ ; char @@v8@@ ; char @@v9@@ ; char @@v10@@ ; _BYTE * @@result@@ ; * @@a2@@ = ftypelet ( @@a1@@ ) ; if ( ( @@a1@@ & Number ) != Number ) @@v2@@ = Number ; else @@v2@@ = Number ; @@a2@@ [ Number ] = @@v2@@ ; if ( ( @@a1@@ & Number ) != Number ) @@v3@@ = Number ; else @@v3@@ = Number ; @@a2@@ [ Number ] = @@v3@@ ; if ( ( @@a1@@ & Number ) != Number ) { if ( ( @@a1@@ & Number ) != Number ) @@v4@@ = Number ; else @@v4@@ = Number ; } else if ( ( @@a1@@ & Number ) != Number ) { @@v4@@ = Number ; } else { @@v4@@ = Number ; } @@a2@@ [ Number ] = @@v4@@ ; if ( ( @@a1@@ & Number ) != Number ) @@v5@@ = Number ; else @@v5@@ = Number ; @@a2@@ [ Number ] = @@v5@@ ; if ( ( @@a1@@ & Number ) != Number ) @@v6@@ = Number ; else @@v6@@ = Number ; @@a2@@ [ Number ] = @@v6@@ ; if ( ( @@a1@@ & Number ) != Number ) { if ( ( @@a1@@ & Number ) != Number ) @@v7@@ = Number ; else @@v7@@ = Number ; } else if ( ( @@a1@@ & Number ) != Number ) { @@v7@@ = Number ; } else { @@v7@@ = Number ; } @@a2@@ [ Number ] = @@v7@@ ; if ( ( @@a1@@ & Number ) != Number ) @@v8@@ = Number ; else @@v8@@ = Number ; @@a2@@ [ Number ] = @@v8@@ ; if ( ( @@a1@@ & Number ) != Number ) @@v9@@ = Number ; else @@v9@@ = Number ; @@a2@@ [ Number ] = @@v9@@ ; if ( ( @@a1@@ & Number ) != Number ) { if ( ( @@a1@@ & Number ) != Number ) @@v10@@ = Number ; else @@v10@@ = Number ; } else if ( ( @@a1@@ & Number ) != Number ) { @@v10@@ = Number ; } else { @@v10@@ = Number ; } @@a2@@ [ Number ] = @@v10@@ ; @@a2@@ [ Number ] = Number ; @@result@@ = @@a2@@ + Number ; @@a2@@ [ Number ] = Number ; return @@result@@ ; }
_BOOL8 __fastcall c_isalpha ( int @@a1@@ ) { return ( int ) ( @@a1@@ & Number ) > Number && ( int ) ( @@a1@@ & Number ) <= Number ; }
bool __fastcall is_prime ( unsigned __int64 @@a1@@ ) { unsigned __int64 @@v2@@ ; unsigned __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; @@v2@@ = Number L ; @@v4@@ = Number L ; while ( @@v4@@ < @@a1@@ && @@a1@@ % @@v2@@ ) { @@v3@@ = @@v2@@ + Number ; @@v4@@ += Number * @@v3@@ ; @@v2@@ = @@v3@@ + Number ; } return @@a1@@ % @@v2@@ != Number ; }
__int64 __fastcall transfer_entries ( __int64 @@a1@@ , __int64 @@a2@@ , char @@a3@@ ) { __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 * @@i@@ ; _QWORD * @@j@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; _QWORD * @@v11@@ ; _QWORD * @@v12@@ ; _QWORD * @@v13@@ ; _QWORD * @@v14@@ ; for ( @@i@@ = * ( __int64 * * ) @@a2@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a2@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = ( _QWORD * ) @@i@@ [ Number ] ; @@j@@ ; @@j@@ = @@v14@@ ) { @@v9@@ = * @@j@@ ; @@v3@@ = * ( _QWORD * ) @@a1@@ ; @@v11@@ = ( _QWORD * ) ( @@v3@@ + Number * ( * ( __int64 ( __fastcall * * ) ( _QWORD , _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@j@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@v11@@ >= * ( _QWORD * ) ( @@a1@@ + Number ) ) abort ( ) ; @@v14@@ = ( _QWORD * ) @@j@@ [ Number ] ; if ( * @@v11@@ ) { @@j@@ [ Number ] = @@v11@@ [ Number ] ; @@v11@@ [ Number ] = @@j@@ ; } else { * @@v11@@ = @@v9@@ ; ++ * ( _QWORD * ) ( @@a1@@ + Number ) ; free_entry ( @@a1@@ , @@j@@ ) ; } } @@v10@@ = * @@i@@ ; @@i@@ [ Number ] = Number L ; if ( ! @@a3@@ ) { @@v4@@ = * ( _QWORD * ) @@a1@@ ; @@v12@@ = ( _QWORD * ) ( @@v4@@ + Number * ( * ( __int64 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@v10@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@v12@@ >= * ( _QWORD * ) ( @@a1@@ + Number ) ) abort ( ) ; if ( * @@v12@@ ) { @@v13@@ = allocate_entry ( @@a1@@ ) ; if ( ! @@v13@@ ) return Number L ; * @@v13@@ = @@v10@@ ; @@v13@@ [ Number ] = @@v12@@ [ Number ] ; @@v12@@ [ Number ] = @@v13@@ ; } else { * @@v12@@ = @@v10@@ ; ++ * ( _QWORD * ) ( @@a1@@ + Number ) ; } * @@i@@ = Number L ; -- * ( _QWORD * ) ( @@a2@@ + Number ) ; } } } return Number L ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
_BOOL8 __fastcall c_iscntrl ( int @@a1@@ ) { return ( @@a1@@ & Number ) == Number || @@a1@@ == Number ; }
__int64 __fastcall setup_dir ( __int64 @@a1@@ ) { if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { * ( _QWORD * ) ( @@a1@@ + Number ) = hash_initialize ( Number L , Number L , AD_hash , AD_compare , & free ) ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; } else { * ( _QWORD * ) ( @@a1@@ + Number ) = malloc ( Number ) ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; cycle_check_init ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ; } return Number L ; }
__int64 __fastcall hash_clear ( __int64 @@a1@@ ) { __int64 @@result@@ ; _QWORD * @@i@@ ; _QWORD * @@j@@ ; _QWORD * @@v4@@ ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = ( _QWORD * ) @@i@@ [ Number ] ; @@j@@ ; @@j@@ = @@v4@@ ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@j@@ ) ; * @@j@@ = Number L ; @@v4@@ = ( _QWORD * ) @@j@@ [ Number ] ; @@j@@ [ Number ] = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@j@@ ; } if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@i@@ ) ; * @@i@@ = Number L ; @@i@@ [ Number ] = Number L ; } } * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; @@result@@ = @@a1@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; return @@result@@ ; }
_BOOL8 __fastcall c_islower ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
__int64 __fastcall fts_set_stat_required ( __int64 @@a1@@ , char @@a2@@ ) { __int64 @@v2@@ ; __int64 @@result@@ ; if ( * ( _WORD * ) ( @@a1@@ + Number ) != Number ) abort ( ) ; if ( @@a2@@ ) @@v2@@ = Number L ; else @@v2@@ = Number L ; @@result@@ = @@a1@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v2@@ ; return @@result@@ ; }
__int64 __fastcall i_ring_pop ( __int64 @@a1@@ ) { unsigned int @@v2@@ ; if ( ( unsigned __int8 ) i_ring_empty ( @@a1@@ ) ) abort ( ) ; @@v2@@ = * ( _DWORD * ) ( @@a1@@ + Number L * * ( unsigned int * ) ( @@a1@@ + Number ) ) ; * ( _DWORD * ) ( @@a1@@ + Number L * * ( unsigned int * ) ( @@a1@@ + Number ) ) = * ( _DWORD * ) ( @@a1@@ + Number ) ; if ( * ( _DWORD * ) ( @@a1@@ + Number ) == * ( _DWORD * ) ( @@a1@@ + Number ) ) * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; else * ( _DWORD * ) ( @@a1@@ + Number ) = ( ( unsigned __int8 ) * ( _DWORD * ) ( @@a1@@ + Number ) + Number ) & Number ; return @@v2@@ ; }
__int64 __fastcall argmatch ( const char * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { __int64 @@result@@ ; char @@v7@@ ; __int64 @@i@@ ; __int64 @@v9@@ ; size_t @@n@@ ; @@v9@@ = Number ; @@v7@@ = Number ; @@n@@ = strlen ( @@a1@@ ) ; for ( @@i@@ = Number L ; * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; ++ @@i@@ ) { if ( ! strncmp ( * ( const char * * ) ( Number * @@i@@ + @@a2@@ ) , @@a1@@ , @@n@@ ) ) { if ( @@n@@ == strlen ( * ( const char * * ) ( Number * @@i@@ + @@a2@@ ) ) ) return @@i@@ ; if ( @@v9@@ == Number ) { @@v9@@ = @@i@@ ; } else if ( ! @@a3@@ || memcmp ( ( const void * ) ( @@a4@@ * @@v9@@ + @@a3@@ ) , ( const void * ) ( @@i@@ * @@a4@@ + @@a3@@ ) , @@a4@@ ) ) { @@v7@@ = Number ; } } } if ( @@v7@@ ) @@result@@ = Number ; else @@result@@ = @@v9@@ ; return @@result@@ ; }
__int64 __fastcall hash_find_entry ( __int64 @@a1@@ , __int64 @@a2@@ , _QWORD * @@a3@@ , char @@a4@@ ) { __int64 @@v4@@ ; __int64 @@result@@ ; __int64 @@v6@@ ; _QWORD * @@i@@ ; _QWORD * @@v10@@ ; __int64 @@v11@@ ; _QWORD * @@v12@@ ; __int64 @@v13@@ ; _QWORD * @@v14@@ ; @@v4@@ = * ( _QWORD * ) @@a1@@ ; @@v10@@ = ( _QWORD * ) ( @@v4@@ + Number * ( * ( __int64 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@a2@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@v10@@ >= * ( _QWORD * ) ( @@a1@@ + Number ) ) abort ( ) ; * @@a3@@ = @@v10@@ ; if ( ! * @@v10@@ ) return Number L ; if ( @@a2@@ == * @@v10@@ || ( * ( unsigned __int8 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@a2@@ , * @@v10@@ ) ) { @@v13@@ = * @@v10@@ ; if ( @@a4@@ ) { if ( @@v10@@ [ Number ] ) { @@v14@@ = ( _QWORD * ) @@v10@@ [ Number ] ; @@v6@@ = @@v14@@ [ Number ] ; * @@v10@@ = * @@v14@@ ; @@v10@@ [ Number ] = @@v6@@ ; free_entry ( @@a1@@ , @@v14@@ ) ; } else { * @@v10@@ = Number L ; } } @@result@@ = @@v13@@ ; } else { for ( @@i@@ = @@v10@@ ; ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { if ( ! @@i@@ [ Number ] ) return Number L ; if ( @@a2@@ == * ( _QWORD * ) @@i@@ [ Number ] || ( * ( unsigned __int8 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@a2@@ , * ( _QWORD * ) @@i@@ [ Number ] ) ) { break ; } } @@v11@@ = * ( _QWORD * ) @@i@@ [ Number ] ; if ( @@a4@@ ) { @@v12@@ = ( _QWORD * ) @@i@@ [ Number ] ; @@i@@ [ Number ] = @@v12@@ [ Number ] ; free_entry ( @@a1@@ , @@v12@@ ) ; } @@result@@ = @@v11@@ ; } return @@result@@ ; }
_BOOL8 __fastcall c_isupper ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
__int64 __fastcall cwd_advance_fd ( __int64 @@a1@@ , int @@a2@@ , char @@a3@@ ) { __int64 @@result@@ ; int @@v4@@ ; int @@fd@@ ; @@v4@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; if ( @@v4@@ == @@a2@@ && @@v4@@ != Number ) abort ( ) ; if ( @@a3@@ ) { @@fd@@ = i_ring_push ( @@a1@@ + Number , ( unsigned int ) @@v4@@ ) ; if ( @@fd@@ >= Number ) close ( @@fd@@ ) ; } else if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) == Number && @@v4@@ >= Number ) { close ( @@v4@@ ) ; } @@result@@ = @@a1@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall openat_safer ( int @@a1@@ , const char * @@a2@@ , char @@a3@@ , unsigned int @@a4@@ ) { unsigned int @@v4@@ ; unsigned int @@v6@@ ; @@v6@@ = Number ; if ( ( @@a3@@ & Number ) != Number ) @@v6@@ = @@a4@@ ; @@v4@@ = openat ( @@a1@@ , @@a2@@ , @@a3@@ , @@v6@@ ) ; return fd_safer ( @@v4@@ ) ; }
int __fastcall argmatch_valid ( __int64 @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { char * @@v3@@ ; __int64 @@i@@ ; void * @@s1@@ ; @@s1@@ = Number L ; @@v3@@ = gettext ( String ) ; fprintf ( stderr , @@v3@@ ) ; for ( @@i@@ = Number L ; * ( _QWORD * ) ( Number * @@i@@ + @@a1@@ ) ; ++ @@i@@ ) { if ( @@i@@ && ! memcmp ( @@s1@@ , ( const void * ) ( @@i@@ * @@a3@@ + @@a2@@ ) , @@a3@@ ) ) { fprintf ( stderr , String , * ( const char * * ) ( Number * @@i@@ + @@a1@@ ) ) ; } else { fprintf ( stderr , String , * ( const char * * ) ( Number * @@i@@ + @@a1@@ ) ) ; @@s1@@ = ( void * ) ( @@i@@ * @@a3@@ + @@a2@@ ) ; } } return putc_unlocked ( Number , stderr ) ; }
int __fastcall stat ( char * @@filename@@ , struct stat * @@stat_buf@@ ) { return __xstat ( Number , @@filename@@ , @@stat_buf@@ ) ; }
int __fastcall rpl_linkat ( unsigned int @@a1@@ , char * @@a2@@ , int @@a3@@ , const char * @@a4@@ , int @@a5@@ ) { int @@v6@@ ; int @@v9@@ ; if ( ! @@a5@@ ) return linkat ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , Number ) ; @@v6@@ = @@a5@@ ; BYTE1 ( @@v6@@ ) = BYTE1 ( @@a5@@ ) & Number ; if ( @@v6@@ ) { * __errno_location ( ) = Number ; return Number ; } if ( have_follow_really_4385 >= Number ) { @@v9@@ = linkat ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; if ( @@v9@@ != Number || * __errno_location ( ) != Number ) { have_follow_really_4385 = Number ; return @@v9@@ ; } have_follow_really_4385 = Number ; } return linkat_follow ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
_BOOL8 __fastcall leaf_optimization_applies ( int @@a1@@ ) { _BOOL8 @@result@@ ; struct statfs @@buf@@ ; unsigned __int64 @@v3@@ ; @@v3@@ = __readfsqword ( Number ) ; if ( fstatfs ( @@a1@@ , & @@buf@@ ) ) @@result@@ = Number L ; else @@result@@ = @@buf@@ . f_type == Number ; return @@result@@ ; }
int __fastcall fstat ( int @@fildes@@ , struct stat * @@stat_buf@@ ) { return __fxstat ( Number , @@fildes@@ , @@stat_buf@@ ) ; }
char * __fastcall file_type ( __int64 @@a1@@ ) { char * @@result@@ ; switch ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) { case Number : if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) @@result@@ = gettext ( String ) ; else @@result@@ = gettext ( String ) ; break ; case Number : @@result@@ = gettext ( String ) ; break ; case Number : @@result@@ = gettext ( String ) ; break ; case Number : @@result@@ = gettext ( String ) ; break ; case Number : @@result@@ = gettext ( String ) ; break ; case Number : @@result@@ = gettext ( String ) ; break ; case Number : @@result@@ = gettext ( String ) ; break ; default : @@result@@ = gettext ( String ) ; break ; } return @@result@@ ; }
__int64 __fastcall open_safer ( const char * @@a1@@ , char @@a2@@ , unsigned int @@a3@@ ) { unsigned int @@v3@@ ; unsigned int @@v5@@ ; @@v5@@ = Number ; if ( ( @@a2@@ & Number ) != Number ) @@v5@@ = @@a3@@ ; @@v3@@ = open ( @@a1@@ , @@a2@@ , @@v5@@ ) ; return fd_safer ( @@v3@@ ) ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
int __fastcall mknod ( char * @@path@@ , __mode_t @@mode@@ , __dev_t @@a3@@ ) { __dev_t @@dev@@ [ Number ] ; @@dev@@ [ Number ] = @@a3@@ ; return __xmknod ( Number , @@path@@ , @@mode@@ , @@dev@@ ) ; }
__int64 __fastcall fts_compare_ino ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; if ( * ( _QWORD * ) ( * ( _QWORD * ) @@a1@@ + Number L ) < * ( _QWORD * ) ( * ( _QWORD * ) @@a2@@ + Number L ) ) @@result@@ = Number ; else @@result@@ = * ( _QWORD * ) ( * ( _QWORD * ) @@a2@@ + Number L ) < * ( _QWORD * ) ( * ( _QWORD * ) @@a1@@ + Number L ) ; return @@result@@ ; }
unsigned __int64 __fastcall AD_hash ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) % @@a2@@ ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
__int64 __fastcall fts_compar ( __int64 @@a1@@ , __int64 @@a2@@ ) { return ( * ( __int64 ( __fastcall * * ) ( __int64 , __int64 ) ) ( * ( _QWORD * ) ( * ( _QWORD * ) @@a1@@ + Number L ) + Number L ) ) ( @@a1@@ , @@a2@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
int __fxstatat ( int @@ver@@ , int @@fildes@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ , int @@flag@@ ) { return _fxstatat ( @@ver@@ , @@fildes@@ , @@filename@@ , @@stat_buf@@ , @@flag@@ ) ; }
__int64 __fastcall enter_dir ( __int64 @@a1@@ , __int64 @@a2@@ ) { _QWORD * @@ptr@@ ; __int64 @@v4@@ ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { @@ptr@@ = malloc ( Number ) ; if ( ! @@ptr@@ ) return Number L ; * @@ptr@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@ptr@@ [ Number ] = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@ptr@@ [ Number ] = @@a2@@ ; @@v4@@ = hash_insert ( * ( _QWORD * ) ( @@a1@@ + Number ) , @@ptr@@ ) ; if ( ( _QWORD * ) @@v4@@ != @@ptr@@ ) { free ( @@ptr@@ ) ; if ( ! @@v4@@ ) return Number L ; * ( _QWORD * ) @@a2@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; * ( _WORD * ) ( @@a2@@ + Number ) = Number ; } } else if ( ( unsigned __int8 ) cycle_check ( * ( _QWORD * ) ( @@a1@@ + Number ) , @@a2@@ + Number ) ) { * ( _QWORD * ) @@a2@@ = @@a2@@ ; * ( _WORD * ) ( @@a2@@ + Number ) = Number ; } return Number L ; }
size_t __fastcall fts_maxarglen ( const char * * @@a1@@ ) { size_t @@v3@@ ; size_t @@v4@@ ; @@v3@@ = Number L ; while ( * @@a1@@ ) { @@v4@@ = strlen ( * @@a1@@ ) ; if ( @@v4@@ > @@v3@@ ) @@v3@@ = @@v4@@ ; ++ @@a1@@ ; } return @@v3@@ + Number ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
void * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
int rpmatch ( const char * @@response@@ ) { return rpmatch ( @@response@@ ) ; }
__int64 __fastcall hash_get_n_buckets ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
struct dirent * readdir ( DIR * @@dirp@@ ) { return readdir ( @@dirp@@ ) ; }
void * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__int64 __fastcall fts_close ( __int64 @@a1@@ ) { _QWORD * @@v1@@ ; void * @@v2@@ ; _QWORD * @@v3@@ ; int @@v5@@ ; @@v5@@ = Number ; if ( * ( _QWORD * ) @@a1@@ ) { @@v1@@ = * ( _QWORD * * ) @@a1@@ ; while ( ( __int64 ) @@v1@@ [ Number ] >= Number ) { @@v2@@ = @@v1@@ ; if ( @@v1@@ [ Number ] ) @@v3@@ = ( _QWORD * ) @@v1@@ [ Number ] ; else @@v3@@ = ( _QWORD * ) @@v1@@ [ Number ] ; @@v1@@ = @@v3@@ ; free ( @@v2@@ ) ; } free ( @@v1@@ ) ; } if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) fts_lfree ( * ( void * * ) ( @@a1@@ + Number ) ) ; free ( * ( void * * ) ( @@a1@@ + Number ) ) ; free ( * ( void * * ) ( @@a1@@ + Number ) ) ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { if ( * ( int * ) ( @@a1@@ + Number ) >= Number && close ( * ( _DWORD * ) ( @@a1@@ + Number ) ) ) { LABEL_20 : @@v5@@ = * __errno_location ( ) ; goto LABEL_21 ; } } else if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) == Number ) { if ( fchdir ( * ( _DWORD * ) ( @@a1@@ + Number ) ) ) @@v5@@ = * __errno_location ( ) ; if ( close ( * ( _DWORD * ) ( @@a1@@ + Number ) ) && ! @@v5@@ ) goto LABEL_20 ; } LABEL_21 : fd_ring_clear ( @@a1@@ + Number ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) hash_free ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ; free_dir ( @@a1@@ ) ; free ( ( void * ) @@a1@@ ) ; if ( ! @@v5@@ ) return Number L ; * __errno_location ( ) = @@v5@@ ; return Number ; }
int fchdir ( int @@fd@@ ) { return fchdir ( @@fd@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
_BOOL8 __fastcall hash_table_ok ( __int64 @@a1@@ ) { _QWORD * @@i@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; _QWORD * @@v5@@ ; @@v3@@ = Number L ; @@v4@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { @@v5@@ = @@i@@ ; ++ @@v3@@ ; ++ @@v4@@ ; while ( Number ) { @@v5@@ = ( _QWORD * ) @@v5@@ [ Number ] ; if ( ! @@v5@@ ) break ; ++ @@v4@@ ; } } } return @@v3@@ == * ( _QWORD * ) ( @@a1@@ + Number ) && @@v4@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ; }
_BYTE * __fastcall savedirstream ( DIR * @@a1@@ ) { __int64 @@v2@@ ; int @@v3@@ ; _BYTE * @@ptr@@ ; unsigned __int64 @@v5@@ ; size_t @@v6@@ ; struct dirent * @@v7@@ ; char * @@src@@ ; size_t @@n@@ ; @@v5@@ = Number L ; @@v6@@ = Number L ; if ( ! @@a1@@ ) return Number L ; @@ptr@@ = ( _BYTE * ) xmalloc ( Number L ) ; while ( Number ) { * __errno_location ( ) = Number ; @@v7@@ = readdir ( @@a1@@ ) ; if ( ! @@v7@@ ) break ; @@src@@ = @@v7@@ -> d_name ; if ( @@v7@@ -> d_name [ Number ] == Number ) { if ( @@v7@@ -> d_name [ Number ] == Number ) @@v2@@ = Number L ; else @@v2@@ = Number L ; } else { @@v2@@ = Number L ; } if ( @@src@@ [ @@v2@@ ] ) { @@n@@ = strlen ( @@v7@@ -> d_name ) + Number ; if ( @@v6@@ > @@v6@@ + @@n@@ ) xalloc_die ( ) ; if ( @@v5@@ <= @@v6@@ + @@n@@ ) { do { if ( @@v5@@ > Number * @@v5@@ ) xalloc_die ( ) ; @@v5@@ *= Number L ; } while ( @@v5@@ <= @@v6@@ + @@n@@ ) ; @@ptr@@ = ( _BYTE * ) xrealloc ( @@ptr@@ , @@v5@@ ) ; } memcpy ( & @@ptr@@ [ @@v6@@ ] , @@src@@ , @@n@@ ) ; @@v6@@ += @@n@@ ; } } @@ptr@@ [ @@v6@@ ] = Number ; @@v3@@ = * __errno_location ( ) ; if ( closedir ( @@a1@@ ) ) @@v3@@ = * __errno_location ( ) ; if ( ! @@v3@@ ) return @@ptr@@ ; free ( @@ptr@@ ) ; * __errno_location ( ) = @@v3@@ ; return Number L ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
unsigned __int64 __fastcall hash_get_entries ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; _QWORD * @@i@@ ; _QWORD * @@j@@ ; @@v5@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = @@i@@ ; @@j@@ ; @@j@@ = ( _QWORD * ) @@j@@ [ Number ] ) { if ( @@v5@@ >= @@a3@@ ) return @@v5@@ ; @@v4@@ = @@v5@@ ++ ; * ( _QWORD * ) ( @@a2@@ + Number * @@v4@@ ) = * @@j@@ ; } } } return @@v5@@ ; }
ssize_t __fastcall safe_write ( int @@a1@@ , const void * @@a2@@ , size_t @@a3@@ ) { ssize_t @@result@@ ; ssize_t @@v5@@ ; LABEL_1 : for ( @@result@@ = write ( @@a1@@ , @@a2@@ , @@a3@@ ) ; ; @@result@@ = write ( @@a1@@ , @@a2@@ , Number ) ) { @@v5@@ = @@result@@ ; if ( @@result@@ >= Number ) break ; if ( * __errno_location ( ) == Number ) goto LABEL_1 ; if ( * __errno_location ( ) != Number || @@a3@@ <= Number ) return @@v5@@ ; @@a3@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall fts_sort ( __int64 @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { size_t @@v3@@ ; _QWORD * @@v5@@ ; __int64 @@i@@ ; _QWORD * @@v7@@ ; _QWORD * @@v8@@ ; __int64 @@v9@@ ; int ( * @@compar@@ ( ) ( constvoid , constvoid ) ) ( const void * , const void * ) ; void * @@v11@@ ; @@v3@@ = @@a3@@ ; @@compar@@ ( ) ( constvoid , constvoid ) = * ( int ( * * ) ( const void * , const void * ) ) ( @@a1@@ + Number ) ; if ( @@a3@@ > * ( _QWORD * ) ( @@a1@@ + Number ) ) { * ( _QWORD * ) ( @@a1@@ + Number ) = @@a3@@ + Number ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) > Number || ( @@v11@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number L * * ( _QWORD * ) ( @@a1@@ + Number ) ) ) == Number L ) { free ( * ( void * * ) ( @@a1@@ + Number ) ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; return @@a2@@ ; } * ( _QWORD * ) ( @@a1@@ + Number ) = @@v11@@ ; } @@v5@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; for ( @@i@@ = @@a2@@ ; @@i@@ ; @@i@@ = * ( _QWORD * ) ( @@i@@ + Number ) ) { @@v7@@ = @@v5@@ ++ ; * @@v7@@ = @@i@@ ; } qsort ( * ( void * * ) ( @@a1@@ + Number ) , @@v3@@ , Number , @@compar@@ ( ) ( constvoid , constvoid ) ) ; @@v8@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; @@v9@@ = * @@v8@@ ; while ( -- @@v3@@ ) { * ( _QWORD * ) ( * @@v8@@ + Number L ) = @@v8@@ [ Number ] ; ++ @@v8@@ ; } * ( _QWORD * ) ( * @@v8@@ + Number L ) = Number L ; return @@v9@@ ; }
unsigned __int64 __fastcall dev_info_hash ( _QWORD * @@a1@@ , unsigned __int64 @@a2@@ ) { return * @@a1@@ % @@a2@@ ; }
unsigned __int64 __fastcall raw_hasher ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return rotr_sz ( @@a1@@ , Number ) % @@a2@@ ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
_BOOL8 __fastcall strip_trailing_slashes ( char * @@a1@@ ) { char @@v1@@ ; const char * @@v3@@ ; const char * @@v4@@ ; @@v3@@ = last_component ( @@a1@@ ) ; if ( ! * @@v3@@ ) @@v3@@ = @@a1@@ ; @@v4@@ = & @@v3@@ [ base_len ( @@v3@@ ) ] ; @@v1@@ = * @@v4@@ ; * @@v4@@ = Number ; return @@v1@@ != Number ; }
__int64 __fastcall hash_get_n_entries ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int64 __fastcall get_stat_ctime_ns ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
_BOOL8 __fastcall dot_or_dotdot ( _BYTE * @@a1@@ ) { __int64 @@v1@@ ; char @@v4@@ ; if ( * @@a1@@ != Number ) return Number L ; if ( @@a1@@ [ Number ] == Number ) @@v1@@ = Number L ; else @@v1@@ = Number L ; @@v4@@ = @@a1@@ [ @@v1@@ ] ; return ! @@v4@@ || @@v4@@ == Number ; }
__int64 __fastcall update_timespec ( __int64 @@a1@@ , __int64 * * @@a2@@ ) { __int64 @@result@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 * @@v5@@ ; @@v5@@ = * @@a2@@ ; if ( ( * @@a2@@ ) [ Number ] == Number && @@v5@@ [ Number ] == Number ) return Number L ; if ( @@v5@@ [ Number ] == Number && @@v5@@ [ Number ] == Number ) { * @@a2@@ = Number L ; @@result@@ = Number L ; } else { if ( @@v5@@ [ Number ] == Number ) { * @@v5@@ = get_stat_atime_0 ( @@a1@@ ) ; @@v5@@ [ Number ] = @@v3@@ ; } else if ( @@v5@@ [ Number ] == Number ) { gettime ( @@v5@@ ) ; } if ( @@v5@@ [ Number ] == Number ) { @@v5@@ [ Number ] = get_stat_mtime_0 ( @@a1@@ ) ; @@v5@@ [ Number ] = @@v4@@ ; } else if ( @@v5@@ [ Number ] == Number ) { gettime ( @@v5@@ + Number ) ; } @@result@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall cache_stat_init ( __int64 @@a1@@ ) { * ( _QWORD * ) ( @@a1@@ + Number ) = Number ; return @@a1@@ ; }
_BOOL8 __fastcall hash_table_ok ( __int64 @@a1@@ ) { _QWORD * @@i@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; _QWORD * @@v5@@ ; @@v3@@ = Number L ; @@v4@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { @@v5@@ = @@i@@ ; ++ @@v3@@ ; ++ @@v4@@ ; while ( Number ) { @@v5@@ = ( _QWORD * ) @@v5@@ [ Number ] ; if ( ! @@v5@@ ) break ; ++ @@v4@@ ; } } } return @@v3@@ == * ( _QWORD * ) ( @@a1@@ + Number ) && @@v4@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ; }
void __fastcall hash_free ( __int64 @@a1@@ ) { _QWORD * @@i@@ ; _QWORD * @@j@@ ; _QWORD * @@ptr@@ ; _QWORD * @@ptra@@ ; _QWORD * @@ptrb@@ ; _QWORD * @@v6@@ ; _QWORD * @@v7@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) && * ( _QWORD * ) ( @@a1@@ + Number ) ) { for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@ptr@@ = @@i@@ ; @@ptr@@ ; @@ptr@@ = ( _QWORD * ) @@ptr@@ [ Number ] ) { ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@ptr@@ ) ; } } } } for ( @@j@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@j@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@j@@ += Number ) { for ( @@ptra@@ = ( _QWORD * ) @@j@@ [ Number ] ; @@ptra@@ ; @@ptra@@ = @@v6@@ ) { @@v6@@ = ( _QWORD * ) @@ptra@@ [ Number ] ; free ( @@ptra@@ ) ; } } for ( @@ptrb@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; @@ptrb@@ ; @@ptrb@@ = @@v7@@ ) { @@v7@@ = ( _QWORD * ) @@ptrb@@ [ Number ] ; free ( @@ptrb@@ ) ; } free ( * ( void * * ) @@a1@@ ) ; free ( ( void * ) @@a1@@ ) ; }
__int64 __fastcall validate_timespec ( _QWORD * @@a1@@ ) { __int64 @@result@@ ; int @@v2@@ ; int @@v3@@ ; @@v2@@ = Number ; @@v3@@ = Number ; if ( ! @@a1@@ ) __assert_fail ( String , String , Number , String ) ; if ( ( @@a1@@ [ Number ] == Number || @@a1@@ [ Number ] == Number L || ( __int64 ) @@a1@@ [ Number ] >= Number && ( __int64 ) @@a1@@ [ Number ] <= Number ) && ( @@a1@@ [ Number ] == Number || @@a1@@ [ Number ] == Number L || ( __int64 ) @@a1@@ [ Number ] >= Number && ( __int64 ) @@a1@@ [ Number ] <= Number ) ) { if ( @@a1@@ [ Number ] == Number || @@a1@@ [ Number ] == Number L ) { * @@a1@@ = Number L ; @@v2@@ = Number ; if ( @@a1@@ [ Number ] == Number L ) @@v3@@ = Number ; } if ( @@a1@@ [ Number ] == Number || @@a1@@ [ Number ] == Number L ) { @@a1@@ [ Number ] = Number L ; @@v2@@ = Number ; if ( @@a1@@ [ Number ] == Number L ) ++ @@v3@@ ; } @@result@@ = ( unsigned int ) ( @@v3@@ == Number ) + @@v2@@ ; } else { * __errno_location ( ) = Number ; @@result@@ = Number ; } return @@result@@ ; }
void * __fastcall xzalloc ( size_t @@a1@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@a1@@ ) ; return memset ( @@v1@@ , Number , @@a1@@ ) ; }
_BOOL8 __fastcall nonexistent_file_errno ( int @@a1@@ ) { return @@a1@@ == Number || @@a1@@ == Number ; }
__int64 __fastcall hash_get_first ( unsigned __int64 * @@a1@@ ) { unsigned __int64 @@i@@ ; if ( ! @@a1@@ [ Number ] ) return Number L ; for ( @@i@@ = * @@a1@@ ; ; @@i@@ += Number L ) { if ( @@i@@ >= @@a1@@ [ Number ] ) abort ( ) ; if ( * ( _QWORD * ) @@i@@ ) break ; } return * ( _QWORD * ) @@i@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@v2@@ ; @@v2@@ = malloc ( @@a1@@ ) ; if ( ! @@v2@@ && @@a1@@ ) xalloc_die ( ) ; return @@v2@@ ; }
__int64 __fastcall i_ring_init ( __int64 @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; int @@i@@ ; * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; * ( _DWORD * ) ( @@a1@@ + Number ) = Number ; * ( _DWORD * ) ( @@a1@@ + Number ) = Number ; for ( @@i@@ = Number ; @@i@@ <= Number ; ++ @@i@@ ) * ( _DWORD * ) ( @@a1@@ + Number L * @@i@@ ) = @@a2@@ ; @@result@@ = @@a1@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall mark_ancestor_dirs ( __int64 @@a1@@ ) { __int64 @@result@@ ; _QWORD * @@i@@ ; for ( @@i@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { @@result@@ = @@i@@ [ Number ] ; if ( @@result@@ < Number ) break ; @@result@@ = @@i@@ [ Number ] ; if ( @@result@@ ) break ; @@i@@ [ Number ] = Number L ; } return @@result@@ ; }
_BOOL8 __fastcall euidaccess_stat ( _DWORD * @@a1@@ , char @@a2@@ ) { unsigned int @@v3@@ ; __uid_t @@v4@@ ; if ( ( @@a2@@ & Number ) == Number ) return Number L ; @@v4@@ = geteuid ( ) ; if ( ! @@v4@@ && ( ( @@a2@@ & Number ) == Number || ( @@a1@@ [ Number ] & Number ) != Number ) ) return Number L ; @@v3@@ = @@a1@@ [ Number ] ; if ( @@v4@@ == @@a1@@ [ Number ] ) { @@v3@@ >>= Number ; } else if ( getegid ( ) == @@a1@@ [ Number ] || group_member ( @@a1@@ [ Number ] ) ) { @@v3@@ >>= Number ; } return ( ~ @@v3@@ & @@a2@@ & Number ) == Number ; }
unsigned __int64 __fastcall hash_get_entries ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; _QWORD * @@i@@ ; _QWORD * @@j@@ ; @@v5@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = @@i@@ ; @@j@@ ; @@j@@ = ( _QWORD * ) @@j@@ [ Number ] ) { if ( @@v5@@ >= @@a3@@ ) return @@v5@@ ; @@v4@@ = @@v5@@ ++ ; * ( _QWORD * ) ( @@a2@@ + Number * @@v4@@ ) = * @@j@@ ; } } } return @@v5@@ ; }
void * __fastcall xzalloc ( size_t @@a1@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@a1@@ ) ; return memset ( @@v1@@ , Number , @@a1@@ ) ; }
unsigned __int64 __fastcall lcm ( unsigned __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return @@a1@@ * ( @@a2@@ / gcd ( @@a1@@ , @@a2@@ ) ) ; }
int __fastcall rpl_linkat ( unsigned int @@a1@@ , char * @@a2@@ , int @@a3@@ , const char * @@a4@@ , int @@a5@@ ) { int @@v6@@ ; int @@v9@@ ; if ( ! @@a5@@ ) return linkat ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , Number ) ; @@v6@@ = @@a5@@ ; BYTE1 ( @@v6@@ ) = BYTE1 ( @@a5@@ ) & Number ; if ( @@v6@@ ) { * __errno_location ( ) = Number ; return Number ; } if ( have_follow_really_4385 >= Number ) { @@v9@@ = linkat ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; if ( @@v9@@ != Number || * __errno_location ( ) != Number ) { have_follow_really_4385 = Number ; return @@v9@@ ; } have_follow_really_4385 = Number ; } return linkat_follow ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__int64 __fastcall freadahead ( __int64 @@a1@@ ) { __int64 @@v2@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) > * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; if ( ( * ( _DWORD * ) @@a1@@ & Number ) != Number ) @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) - * ( _QWORD * ) ( @@a1@@ + Number ) ; else @@v2@@ = Number L ; return * ( _QWORD * ) ( @@a1@@ + Number ) - * ( _QWORD * ) ( @@a1@@ + Number ) + @@v2@@ ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
__int64 __fastcall hash_do_for_each ( __int64 @@a1@@ , unsigned __int8 ( __fastcall * @@a2@@ ) ( _QWORD , __int64 ) , __int64 @@a3@@ ) { __int64 @@v5@@ ; _QWORD * @@i@@ ; _QWORD * @@j@@ ; @@v5@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = @@i@@ ; @@j@@ ; @@j@@ = ( _QWORD * ) @@j@@ [ Number ] ) { if ( @@a2@@ ( * @@j@@ , @@a3@@ ) != Number ) return @@v5@@ ; ++ @@v5@@ ; } } } return @@v5@@ ; }
__int64 __fastcall get_stat_atime ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
__int64 __fastcall c_strcasecmp ( unsigned __int8 * @@a1@@ , unsigned __int8 * @@a2@@ ) { unsigned __int8 * @@v2@@ ; unsigned __int8 * @@v3@@ ; unsigned __int8 @@v5@@ ; unsigned __int8 @@v6@@ ; @@v2@@ = @@a1@@ ; @@v3@@ = @@a2@@ ; if ( @@a1@@ == @@a2@@ ) return Number L ; do { @@v5@@ = c_tolower ( * @@v2@@ ) ; @@v6@@ = c_tolower ( * @@v3@@ ) ; if ( ! @@v5@@ ) break ; ++ @@v2@@ ; ++ @@v3@@ ; } while ( @@v5@@ == @@v6@@ ) ; return @@v5@@ - ( unsigned int ) @@v6@@ ; }
int __fastcall argmatch_valid ( __int64 @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { char * @@v3@@ ; __int64 @@i@@ ; void * @@s1@@ ; @@s1@@ = Number L ; @@v3@@ = gettext ( String ) ; fprintf ( stderr , @@v3@@ ) ; for ( @@i@@ = Number L ; * ( _QWORD * ) ( Number * @@i@@ + @@a1@@ ) ; ++ @@i@@ ) { if ( @@i@@ && ! memcmp ( @@s1@@ , ( const void * ) ( @@i@@ * @@a3@@ + @@a2@@ ) , @@a3@@ ) ) { fprintf ( stderr , String , * ( const char * * ) ( Number * @@i@@ + @@a1@@ ) ) ; } else { fprintf ( stderr , String , * ( const char * * ) ( Number * @@i@@ + @@a1@@ ) ) ; @@s1@@ = ( void * ) ( @@i@@ * @@a3@@ + @@a2@@ ) ; } } return putc_unlocked ( Number , stderr ) ; }
bool __fastcall is_basic_1 ( unsigned __int8 @@a1@@ ) { return ( ( is_basic_table [ @@a1@@ >> Number ] >> ( @@a1@@ & Number ) ) & Number ) != Number ; }
__int64 __fastcall check_tuning ( __int64 @@a1@@ ) { __int64 @@v2@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( ( _UNKNOWN * ) @@v2@@ == & default_tuning ) return Number L ; if ( * ( float * ) ( @@v2@@ + Number ) > Number && ( float ) ( Number - Number ) > * ( float * ) ( @@v2@@ + Number ) && * ( float * ) ( @@v2@@ + Number ) > ( float ) ( Number + Number ) && * ( float * ) @@v2@@ >= Number && * ( float * ) ( @@v2@@ + Number ) > ( float ) ( * ( float * ) @@v2@@ + Number ) && * ( float * ) ( @@v2@@ + Number ) <= Number && * ( float * ) ( @@v2@@ + Number ) > ( float ) ( * ( float * ) @@v2@@ + Number ) ) { return Number L ; } * ( _QWORD * ) ( @@a1@@ + Number ) = & default_tuning ; return Number L ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
_BOOL8 __fastcall copy_dir ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int8 @@a3@@ , _QWORD * @@a4@@ , int @@a5@@ , __int64 @@a6@@ , __int64 @@a7@@ , bool * @@a8@@ ) { __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; __int64 @@v12@@ ; char * @@v13@@ ; int * @@v14@@ ; _BOOL8 @@result@@ ; unsigned __int8 @@v16@@ ; size_t @@v17@@ ; char @@v22@@ ; bool @@v23@@ ; char * @@s@@ ; void * @@v25@@ ; void * @@v26@@ ; void * @@ptr@@ ; __int64 @@v28@@ [ Number ] ; @@v28@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ = * ( _QWORD * ) ( @@a6@@ + Number ) ; @@v28@@ [ Number ] = * ( _QWORD * ) @@a6@@ ; @@v28@@ [ Number ] = @@v8@@ ; @@v9@@ = * ( _QWORD * ) ( @@a6@@ + Number ) ; @@v28@@ [ Number ] = * ( _QWORD * ) ( @@a6@@ + Number ) ; @@v28@@ [ Number ] = @@v9@@ ; @@v10@@ = * ( _QWORD * ) ( @@a6@@ + Number ) ; @@v28@@ [ Number ] = * ( _QWORD * ) ( @@a6@@ + Number ) ; @@v28@@ [ Number ] = @@v10@@ ; @@v11@@ = * ( _QWORD * ) ( @@a6@@ + Number ) ; @@v28@@ [ Number ] = * ( _QWORD * ) ( @@a6@@ + Number ) ; @@v28@@ [ Number ] = @@v11@@ ; @@v28@@ [ Number ] = * ( _QWORD * ) ( @@a6@@ + Number ) ; @@v23@@ = Number ; @@v25@@ = ( void * ) savedir ( @@a1@@ ) ; if ( @@v25@@ ) { if ( * ( _DWORD * ) ( @@a6@@ + Number ) == Number ) HIDWORD ( @@v28@@ [ Number ] ) = Number ; for ( @@s@@ = ( char * ) @@v25@@ ; * @@s@@ ; @@s@@ += @@v17@@ + Number ) { @@v26@@ = ( void * ) file_name_concat ( @@a1@@ , @@s@@ , Number L ) ; @@ptr@@ = ( void * ) file_name_concat ( @@a2@@ , @@s@@ , Number L ) ; @@v16@@ = copy_internal ( ( _DWORD ) @@v26@@ , ( _DWORD ) @@ptr@@ , @@a3@@ , * @@a4@@ , @@a5@@ , ( unsigned int ) @@v28@@ , Number , @@a7@@ , ( __int64 ) & @@v22@@ , Number L ) ; @@v23@@ = ( @@v23@@ & @@v16@@ ) != Number ; * @@a8@@ = ( unsigned __int8 ) ( * @@a8@@ | @@v22@@ ) != Number ; free ( @@ptr@@ ) ; free ( @@v26@@ ) ; if ( @@v22@@ ) break ; @@v17@@ = strlen ( @@s@@ ) ; } free ( @@v25@@ ) ; @@result@@ = @@v23@@ ; } else { @@v12@@ = quote ( @@a1@@ ) ; @@v13@@ = gettext ( String ) ; @@v14@@ = __errno_location ( ) ; error ( Number , * @@v14@@ , @@v13@@ , @@v12@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
void * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * @@v4@@ ; void * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * @@v12@@ ; void * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == ( __int64 * ) & slotvec0 ; if ( slotvec == ( __int64 * ) & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = off_21B038 ; * @@v12@@ = ( __int64 ) slotvec0 ; @@v12@@ [ Number ] = ( __int64 ) @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = ( void * ) @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = @@v17@@ + Number ; if ( @@ptr@@ != & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( void * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = ( __int64 ) @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
int __fastcall stat ( char * @@filename@@ , struct stat * @@stat_buf@@ ) { return __xstat ( Number , @@filename@@ , @@stat_buf@@ ) ; }
__int64 __fastcall mem_cd_iconv ( char * @@a1@@ , size_t @@a2@@ , void * @@a3@@ , void * * @@a4@@ , size_t * @@a5@@ ) { int @@v9@@ ; char * @@inbuf@@ ; size_t @@inbytesleft@@ ; char * @@outbuf@@ ; size_t @@outbytesleft@@ ; void * @@ptr@@ ; size_t @@v15@@ ; size_t @@v16@@ ; size_t @@v17@@ ; size_t @@size@@ ; size_t @@v19@@ ; size_t @@v20@@ ; char @@v21@@ $D1F1B2789FC85C59BE59CF61C76BFA1E [ Number ] ; unsigned __int64 @@v22@@ ; @@v22@@ = __readfsqword ( Number ) ; iconv ( @@a3@@ , Number L , Number L , Number L , Number L ) ; @@v15@@ = Number L ; @@inbuf@@ = @@a1@@ ; @@inbytesleft@@ = @@a2@@ ; while ( @@inbytesleft@@ ) { @@outbuf@@ = @@v21@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; @@outbytesleft@@ = Number L ; @@v16@@ = iconv ( @@a3@@ , & @@inbuf@@ , & @@inbytesleft@@ , & @@outbuf@@ , & @@outbytesleft@@ ) ; if ( @@v16@@ == Number && * __errno_location ( ) != Number ) { if ( * __errno_location ( ) != Number ) return Number ; break ; } @@v15@@ += @@outbuf@@ - @@v21@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; } @@outbuf@@ = @@v21@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; @@outbytesleft@@ = Number L ; @@v17@@ = iconv ( @@a3@@ , Number L , Number L , & @@outbuf@@ , & @@outbytesleft@@ ) ; if ( @@v17@@ == Number ) return Number ; @@v15@@ += @@outbuf@@ - @@v21@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; @@size@@ = @@v15@@ ; if ( ! @@v15@@ ) { * @@a5@@ = Number L ; return Number L ; } if ( * @@a4@@ && @@size@@ <= * @@a5@@ ) { @@ptr@@ = * @@a4@@ ; } else { @@ptr@@ = malloc ( @@size@@ ) ; if ( ! @@ptr@@ ) { * __errno_location ( ) = Number ; return Number ; } } iconv ( @@a3@@ , Number L , Number L , Number L , Number L ) ; @@inbuf@@ = @@a1@@ ; @@inbytesleft@@ = @@a2@@ ; @@outbuf@@ = ( char * ) @@ptr@@ ; @@outbytesleft@@ = @@size@@ ; while ( @@inbytesleft@@ ) { @@v19@@ = iconv ( @@a3@@ , & @@inbuf@@ , & @@inbytesleft@@ , & @@outbuf@@ , & @@outbytesleft@@ ) ; if ( @@v19@@ == Number ) { if ( * __errno_location ( ) != Number ) goto LABEL_26 ; break ; } } @@v20@@ = iconv ( @@a3@@ , Number L , Number L , & @@outbuf@@ , & @@outbytesleft@@ ) ; if ( @@v20@@ != Number ) { if ( @@outbytesleft@@ ) abort ( ) ; * @@a4@@ = @@ptr@@ ; * @@a5@@ = @@size@@ ; return Number L ; } LABEL_26 : if ( @@ptr@@ != * @@a4@@ ) { @@v9@@ = * __errno_location ( ) ; free ( @@ptr@@ ) ; * __errno_location ( ) = @@v9@@ ; } return Number ; }
__int64 __fastcall hash_find_entry ( __int64 @@a1@@ , __int64 @@a2@@ , _QWORD * @@a3@@ , char @@a4@@ ) { __int64 @@v4@@ ; __int64 @@result@@ ; __int64 @@v6@@ ; _QWORD * @@i@@ ; _QWORD * @@v10@@ ; __int64 @@v11@@ ; _QWORD * @@v12@@ ; __int64 @@v13@@ ; _QWORD * @@v14@@ ; @@v4@@ = * ( _QWORD * ) @@a1@@ ; @@v10@@ = ( _QWORD * ) ( @@v4@@ + Number * ( * ( __int64 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@a2@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@v10@@ >= * ( _QWORD * ) ( @@a1@@ + Number ) ) abort ( ) ; * @@a3@@ = @@v10@@ ; if ( ! * @@v10@@ ) return Number L ; if ( @@a2@@ == * @@v10@@ || ( * ( unsigned __int8 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@a2@@ , * @@v10@@ ) ) { @@v13@@ = * @@v10@@ ; if ( @@a4@@ ) { if ( @@v10@@ [ Number ] ) { @@v14@@ = ( _QWORD * ) @@v10@@ [ Number ] ; @@v6@@ = @@v14@@ [ Number ] ; * @@v10@@ = * @@v14@@ ; @@v10@@ [ Number ] = @@v6@@ ; free_entry ( @@a1@@ , @@v14@@ ) ; } else { * @@v10@@ = Number L ; } } @@result@@ = @@v13@@ ; } else { for ( @@i@@ = @@v10@@ ; ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { if ( ! @@i@@ [ Number ] ) return Number L ; if ( @@a2@@ == * ( _QWORD * ) @@i@@ [ Number ] || ( * ( unsigned __int8 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@a2@@ , * ( _QWORD * ) @@i@@ [ Number ] ) ) { break ; } } @@v11@@ = * ( _QWORD * ) @@i@@ [ Number ] ; if ( @@a4@@ ) { @@v12@@ = ( _QWORD * ) @@i@@ [ Number ] ; @@i@@ [ Number ] = @@v12@@ [ Number ] ; free_entry ( @@a1@@ , @@v12@@ ) ; } @@result@@ = @@v11@@ ; } return @@result@@ ; }
_BOOL8 __fastcall chown_failure_ok ( __int64 @@a1@@ ) { return ( * __errno_location ( ) == Number || * __errno_location ( ) == Number ) && * ( _BYTE * ) ( @@a1@@ + Number ) != Number ; }
void * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
int __fastcall fstat ( int @@fildes@@ , struct stat * @@stat_buf@@ ) { return __fxstat ( Number , @@fildes@@ , @@stat_buf@@ ) ; }
_BOOL8 __fastcall c_isprint ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
_BOOL8 __fastcall cycle_warning_required ( __int64 @@a1@@ , __int64 @@a2@@ ) { return ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number && ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) == Number || ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number && ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number && * ( _QWORD * ) ( @@a2@@ + Number ) ; }
__int64 __fastcall src_to_dest_lookup ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; __int64 @@v3@@ ; __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = @@a1@@ ; @@v4@@ [ Number ] = @@a2@@ ; @@v3@@ = hash_lookup ( src_to_dest , @@v4@@ ) ; if ( @@v3@@ ) @@result@@ = * ( _QWORD * ) ( @@v3@@ + Number ) ; else @@result@@ = Number L ; return @@result@@ ; }
int __fastcall mknod ( char * @@path@@ , __mode_t @@mode@@ , __dev_t @@a3@@ ) { __dev_t @@dev@@ [ Number ] ; @@dev@@ [ Number ] = @@a3@@ ; return __xmknod ( Number , @@path@@ , @@mode@@ , @@dev@@ ) ; }
bool __fastcall is_zero_or_power_of_two ( __int64 @@a1@@ ) { return ( @@a1@@ & ( @@a1@@ - Number ) ) == Number ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall c_tolower ( int @@a1@@ ) { __int64 @@result@@ ; if ( @@a1@@ <= Number || @@a1@@ > Number ) @@result@@ = ( unsigned int ) @@a1@@ ; else @@result@@ = ( unsigned int ) ( @@a1@@ + Number ) ; return @@result@@ ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
void * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_21B128 ; @@v8@@ [ Number ] = qword_21B130 ; @@v8@@ [ Number ] = qword_21B138 ; @@v8@@ [ Number ] = qword_21B140 ; @@v8@@ [ Number ] = qword_21B148 ; @@v8@@ [ Number ] = qword_21B150 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
__int64 __fastcall fd_safer ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { unsigned int @@fd@@ ; unsigned int @@v8@@ ; int @@v9@@ ; @@fd@@ = @@a1@@ ; if ( @@a1@@ >= Number && @@a1@@ <= Number ) { @@v8@@ = dup_safer ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; @@v9@@ = * __errno_location ( ) ; close ( @@a1@@ ) ; * __errno_location ( ) = @@v9@@ ; @@fd@@ = @@v8@@ ; } return @@fd@@ ; }
__int64 __fastcall copy_acl ( __int64 @@a1@@ , unsigned int @@a2@@ , const char * @@a3@@ , int @@a4@@ , __mode_t @@a5@@ ) { int @@v5@@ ; const char * @@v6@@ ; int * @@v7@@ ; __int64 @@v8@@ ; char * @@v9@@ ; int * @@v10@@ ; __int64 @@result@@ ; @@v5@@ = qcopy_acl ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; if ( @@v5@@ == Number ) { @@v6@@ = ( const char * ) quote ( @@a1@@ ) ; @@v7@@ = __errno_location ( ) ; error ( Number , * @@v7@@ , String , @@v6@@ ) ; @@result@@ = Number ; } else if ( @@v5@@ == Number ) { @@v8@@ = quote ( @@a3@@ ) ; @@v9@@ = gettext ( String ) ; @@v10@@ = __errno_location ( ) ; error ( Number , * @@v10@@ , @@v9@@ , @@v8@@ ) ; @@result@@ = Number ; } else { @@result@@ = Number L ; } return @@result@@ ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) _frame_dummy_init_array_entry [ @@i@@ ] ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
_BYTE * __fastcall savedir ( const char * @@a1@@ ) { DIR * @@v1@@ ; @@v1@@ = opendir_safer ( @@a1@@ ) ; return savedirstream ( @@v1@@ ) ; }
int unlink ( const char * @@name@@ ) { return unlink ( @@name@@ ) ; }
unsigned __int64 __fastcall triple_hash ( _QWORD * @@a1@@ , unsigned __int64 @@a2@@ ) { return ( ( unsigned __int64 ) hash_pjw ( * @@a1@@ , @@a2@@ ) ^ @@a1@@ [ Number ] ) % @@a2@@ ; }
int unlink ( const char * @@name@@ ) { return unlink ( @@name@@ ) ; }
__int64 __fastcall get_stat_atime_ns ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
void __fastcall triple_free ( void * * @@a1@@ ) { free ( * @@a1@@ ) ; free ( @@a1@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 __fastcall get_stat_atime_0 ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
unsigned __int64 __fastcall buffer_lcm ( unsigned __int64 @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { __int64 @@v3@@ ; unsigned __int64 @@result@@ ; unsigned __int64 @@v5@@ ; unsigned __int64 @@v6@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@v8@@ ; if ( @@a1@@ ) { if ( @@a2@@ ) { @@v6@@ = @@a1@@ ; for ( @@i@@ = @@a2@@ ; ; @@i@@ = @@v8@@ ) { @@v8@@ = @@v6@@ % @@i@@ ; if ( ! ( @@v6@@ % @@i@@ ) ) break ; @@v6@@ = @@i@@ ; } if ( @@a2@@ * ( @@a1@@ / @@i@@ ) <= @@a3@@ && @@a1@@ / @@i@@ == @@a2@@ * ( @@a1@@ / @@i@@ ) / @@a2@@ ) { return @@a2@@ * ( @@a1@@ / @@i@@ ) ; } } @@v5@@ = @@a1@@ ; } else { if ( @@a2@@ ) @@v3@@ = @@a2@@ ; else @@v3@@ = Number ; @@v5@@ = @@v3@@ ; } @@result@@ = @@a3@@ ; if ( @@v5@@ <= @@a3@@ ) @@result@@ = @@v5@@ ; return @@result@@ ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
int dirfd ( DIR * @@dirp@@ ) { return dirfd ( @@dirp@@ ) ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
__int64 __fastcall validate_timespec ( _QWORD * @@a1@@ ) { __int64 @@result@@ ; int @@v2@@ ; int @@v3@@ ; @@v2@@ = Number ; @@v3@@ = Number ; if ( ! @@a1@@ ) __assert_fail ( String , String , Number , String ) ; if ( ( @@a1@@ [ Number ] == Number || @@a1@@ [ Number ] == Number L || ( __int64 ) @@a1@@ [ Number ] >= Number && ( __int64 ) @@a1@@ [ Number ] <= Number ) && ( @@a1@@ [ Number ] == Number || @@a1@@ [ Number ] == Number L || ( __int64 ) @@a1@@ [ Number ] >= Number && ( __int64 ) @@a1@@ [ Number ] <= Number ) ) { if ( @@a1@@ [ Number ] == Number || @@a1@@ [ Number ] == Number L ) { * @@a1@@ = Number L ; @@v2@@ = Number ; if ( @@a1@@ [ Number ] == Number L ) @@v3@@ = Number ; } if ( @@a1@@ [ Number ] == Number || @@a1@@ [ Number ] == Number L ) { @@a1@@ [ Number ] = Number L ; @@v2@@ = Number ; if ( @@a1@@ [ Number ] == Number L ) ++ @@v3@@ ; } @@result@@ = ( unsigned int ) ( @@v3@@ == Number ) + @@v2@@ ; } else { * __errno_location ( ) = Number ; @@result@@ = Number ; } return @@result@@ ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
int __xstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _xstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
int fileno ( FILE * @@stream@@ ) { return fileno ( @@stream@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@v2@@ ; @@v2@@ = malloc ( @@a1@@ ) ; if ( ! @@v2@@ && @@a1@@ ) xalloc_die ( ) ; return @@v2@@ ; }
int fflush ( FILE * @@stream@@ ) { return fflush ( @@stream@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
int __fxstat ( int @@ver@@ , int @@fildes@@ , struct stat * @@stat_buf@@ ) { return _fxstat ( @@ver@@ , @@fildes@@ , @@stat_buf@@ ) ; }
int __fxstat ( int @@ver@@ , int @@fildes@@ , struct stat * @@stat_buf@@ ) { return _fxstat ( @@ver@@ , @@fildes@@ , @@stat_buf@@ ) ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
DIR * fdopendir ( int @@fd@@ ) { return fdopendir ( @@fd@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name_0 ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name_0 ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
char * __fastcall areadlinkat ( int @@a1@@ , const char * @@a2@@ ) { signed __int64 @@v3@@ ; int @@v4@@ ; char * @@buf@@ ; __int64 @@len@@ ; signed __int64 @@size@@ ; size_t @@sizea@@ ; char * @@v9@@ ; char @@src@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v11@@ = __readfsqword ( Number ) ; @@buf@@ = @@src@@ ; @@len@@ = Number L ; while ( Number ) { @@size@@ = readlinkat ( @@a1@@ , @@a2@@ , @@buf@@ , @@len@@ ) ; if ( @@size@@ < Number && * __errno_location ( ) != Number ) { if ( @@buf@@ != @@src@@ ) { @@v4@@ = * __errno_location ( ) ; free ( @@buf@@ ) ; * __errno_location ( ) = @@v4@@ ; } return Number L ; } if ( @@len@@ > ( unsigned __int64 ) @@size@@ ) break ; if ( @@buf@@ != @@src@@ ) free ( @@buf@@ ) ; @@len@@ *= Number L ; if ( @@len@@ < Number ) { * __errno_location ( ) = Number ; return Number L ; } @@buf@@ = ( char * ) malloc ( @@len@@ ) ; if ( ! @@buf@@ ) return Number L ; } @@v3@@ = @@size@@ ; @@sizea@@ = @@size@@ + Number ; @@buf@@ [ @@v3@@ ] = Number ; if ( @@buf@@ == @@src@@ ) { @@buf@@ = ( char * ) malloc ( @@sizea@@ ) ; if ( ! @@buf@@ ) return Number L ; memcpy ( @@buf@@ , @@src@@ , @@sizea@@ ) ; } else if ( @@len@@ > @@sizea@@ ) { @@v9@@ = ( char * ) realloc ( @@buf@@ , @@sizea@@ ) ; if ( @@v9@@ ) @@buf@@ = @@v9@@ ; } return @@buf@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
__int64 __fastcall get_stat_mtime ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
char * __fastcall file_type ( __int64 @@a1@@ ) { char * @@result@@ ; switch ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) { case Number : if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) @@result@@ = gettext ( String ) ; else @@result@@ = gettext ( String ) ; break ; case Number : @@result@@ = gettext ( String ) ; break ; case Number : @@result@@ = gettext ( String ) ; break ; case Number : @@result@@ = gettext ( String ) ; break ; case Number : @@result@@ = gettext ( String ) ; break ; case Number : @@result@@ = gettext ( String ) ; break ; case Number : @@result@@ = gettext ( String ) ; break ; default : @@result@@ = gettext ( String ) ; break ; } return @@result@@ ; }
__int64 __fastcall do_move ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { char @@v5@@ ; char @@v6@@ ; unsigned __int8 @@v7@@ ; int @@v8@@ ; __int64 @@v9@@ ; char @@v10@@ [ Number ] ; __int64 @@v11@@ [ Number ] ; @@v11@@ [ Number ] = __readfsqword ( Number ) ; @@v7@@ = copy ( @@a1@@ , @@a2@@ , Number L , @@a3@@ , & @@v5@@ , & @@v6@@ ) ; if ( @@v7@@ ) { if ( @@v5@@ ) { @@v9@@ = Number L ; @@v7@@ = Number ; } else { @@v9@@ = @@v6@@ ? Number L : @@a1@@ ; } if ( @@v9@@ ) { rm_option_init ( ( __int64 ) @@v10@@ ) ; @@v10@@ [ Number ] = * ( _BYTE * ) ( @@a3@@ + Number ) ; @@v11@@ [ Number ] = @@v9@@ ; @@v11@@ [ Number ] = Number L ; @@v8@@ = rm ( @@v11@@ , @@v10@@ ) ; if ( @@v8@@ != Number && @@v8@@ != Number && @@v8@@ != Number ) __assert_fail ( String , String , Number , String ) ; if ( @@v8@@ == Number ) @@v7@@ = Number ; } } return @@v7@@ ; }
__int64 __fastcall dup_cloexec ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
unsigned __int64 __fastcall lcm ( unsigned __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return @@a1@@ * ( @@a2@@ / gcd ( @@a1@@ , @@a2@@ ) ) ; }
bool __fastcall is_empty_dir ( int @@a1@@ , const char * @@a2@@ ) { bool @@result@@ ; int @@v3@@ ; int @@v4@@ ; DIR * @@dirp@@ ; struct dirent * @@v6@@ ; @@v3@@ = openat ( @@a1@@ , @@a2@@ , Number ) ; if ( @@v3@@ < Number ) return Number ; @@dirp@@ = fdopendir ( @@v3@@ ) ; if ( @@dirp@@ ) { * __errno_location ( ) = Number ; @@v6@@ = readdir_ignoring_dot_and_dotdot ( @@dirp@@ ) ; @@v4@@ = * __errno_location ( ) ; closedir ( @@dirp@@ ) ; if ( @@v6@@ ) @@result@@ = Number ; else @@result@@ = @@v4@@ == Number ; } else { close ( @@v3@@ ) ; @@result@@ = Number ; } return @@result@@ ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_207028 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
__int64 __fastcall dup_safer ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
_BOOL8 __fastcall AD_compare ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { return @@a1@@ [ Number ] == @@a2@@ [ Number ] && * @@a1@@ == * @@a2@@ ; }
__int64 __fastcall get_stat_mtime_0 ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
_BOOL8 __fastcall ignorable_missing ( _BYTE * @@a1@@ , int @@a2@@ ) { return * @@a1@@ && nonexistent_file_errno ( @@a2@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
void __fastcall free_dir ( __int64 @@a1@@ ) { if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) hash_free ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ; } else { free ( * ( void * * ) ( @@a1@@ + Number ) ) ; } }
__int64 __fastcall rm ( _QWORD * @@a1@@ , __int64 @@a2@@ ) { char * @@v2@@ ; int * @@v3@@ ; char * @@v4@@ ; int * @@v5@@ ; unsigned int @@v7@@ ; unsigned int @@v8@@ ; unsigned int @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; @@v7@@ = Number ; if ( * @@a1@@ ) { @@v8@@ = Number ; if ( * ( _BYTE * ) ( @@a2@@ + Number ) ) @@v8@@ = Number ; @@v10@@ = xfts_open ( @@a1@@ , @@v8@@ , Number L ) ; while ( Number ) { @@v11@@ = fts_read ( @@v10@@ ) ; if ( ! @@v11@@ ) break ; @@v9@@ = rm_fts ( @@v10@@ , @@v11@@ , @@a2@@ ) ; if ( @@v9@@ != Number && @@v9@@ != Number && @@v9@@ != Number ) __assert_fail ( String , String , Number , _PRETTY_FUNCTION___5846 ) ; if ( @@v9@@ == Number || @@v9@@ == Number && @@v7@@ == Number ) @@v7@@ = @@v9@@ ; } if ( * __errno_location ( ) ) { @@v2@@ = gettext ( String ) ; @@v3@@ = __errno_location ( ) ; error ( Number , * @@v3@@ , @@v2@@ ) ; @@v7@@ = Number ; } if ( ( unsigned int ) fts_close ( @@v10@@ ) ) { @@v4@@ = gettext ( String ) ; @@v5@@ = __errno_location ( ) ; error ( Number , * @@v5@@ , @@v4@@ ) ; @@v7@@ = Number ; } } return @@v7@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
__int64 __fastcall is_ancestor ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { while ( @@a2@@ ) { if ( @@a2@@ [ Number ] == @@a1@@ [ Number ] && @@a2@@ [ Number ] == * @@a1@@ ) return Number L ; @@a2@@ = ( _QWORD * ) * @@a2@@ ; } return Number L ; }
__int64 __fastcall diropen ( __int64 @@a1@@ , int @@a2@@ , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { int @@v6@@ ; int @@v8@@ ; unsigned int @@v9@@ ; @@v8@@ = ( * ( _DWORD * ) ( @@a1@@ + Number ) << Number ) & Number | Number ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) @@v6@@ = openat_safer ( * ( _DWORD * ) ( @@a1@@ + Number ) , @@a2@@ , @@v8@@ , @@a2@@ , @@a5@@ , @@a6@@ , @@a2@@ ) ; else @@v6@@ = open_safer ( @@a2@@ , @@v8@@ , @@v8@@ , @@a4@@ , @@a5@@ , @@a6@@ , @@a2@@ ) ; @@v9@@ = @@v6@@ ; if ( @@v6@@ >= Number ) set_cloexec_flag ( ( unsigned int ) @@v6@@ , Number L ) ; return @@v9@@ ; }
_BOOL8 __fastcall errno_unsupported ( int @@a1@@ ) { return @@a1@@ == Number || @@a1@@ == Number ; }
__int64 sysconf ( int @@name@@ ) { return sysconf ( @@name@@ ) ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
__int64 __fastcall fts_set ( __int64 a1 , __int64 @@a2@@ , int @@a3@@ ) { __int64 @@result@@ ; if ( ! @@a3@@ || @@a3@@ == Number || @@a3@@ == Number || @@a3@@ == Number || @@a3@@ == Number ) { * ( _WORD * ) ( @@a2@@ + Number ) = @@a3@@ ; @@result@@ = Number L ; } else { * __errno_location ( ) = Number ; @@result@@ = Number L ; } return @@result@@ ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
unsigned __int64 __fastcall overwrite_prompt ( const char * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; char * @@v5@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; char @@v10@@ ; _BYTE @@v11@@ [ Number ] ; unsigned __int64 @@v12@@ ; @@v12@@ = __readfsqword ( Number ) ; if ( ! writable_destination ( @@a1@@ , * ( _DWORD * ) ( @@a2@@ + Number ) ) ) { strmode ( * ( unsigned int * ) ( @@a2@@ + Number ) , & @@v10@@ ) ; @@v11@@ [ Number ] = Number ; @@v2@@ = * ( _DWORD * ) ( @@a2@@ + Number ) & Number ; @@v3@@ = quote ( @@a1@@ ) ; @@v4@@ = program_name ; @@v5@@ = gettext ( String ) ; fprintf ( stderr , @@v5@@ , @@v4@@ , @@v3@@ , @@v2@@ , @@v11@@ ) ; } else { @@v6@@ = quote ( @@a1@@ ) ; @@v7@@ = program_name ; @@v8@@ = gettext ( String ) ; fprintf ( stderr , @@v8@@ , @@v7@@ , @@v6@@ ) ; } return __readfsqword ( Number ) ^ @@v12@@ ; }
unsigned __int64 __fastcall overwrite_prompt ( const char * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; char * @@v5@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; char @@v10@@ ; _BYTE @@v11@@ [ Number ] ; unsigned __int64 @@v12@@ ; @@v12@@ = __readfsqword ( Number ) ; if ( ! writable_destination ( @@a1@@ , * ( _DWORD * ) ( @@a2@@ + Number ) ) ) { strmode ( * ( unsigned int * ) ( @@a2@@ + Number ) , & @@v10@@ ) ; @@v11@@ [ Number ] = Number ; @@v2@@ = * ( _DWORD * ) ( @@a2@@ + Number ) & Number ; @@v3@@ = quote ( @@a1@@ ) ; @@v4@@ = program_name ; @@v5@@ = gettext ( String ) ; fprintf ( stderr , @@v5@@ , @@v4@@ , @@v3@@ , @@v2@@ , @@v11@@ ) ; } else { @@v6@@ = quote ( @@a1@@ ) ; @@v7@@ = program_name ; @@v8@@ = gettext ( String ) ; fprintf ( stderr , @@v8@@ , @@v7@@ , @@v6@@ ) ; } return __readfsqword ( Number ) ^ @@v12@@ ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall set_stat_type ( __int64 @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; int @@v3@@ ; switch ( @@a2@@ ) { case Number : @@v3@@ = Number ; break ; case Number : @@v3@@ = Number ; break ; case Number : @@v3@@ = Number ; break ; case Number : @@v3@@ = Number ; break ; case Number : @@v3@@ = Number ; break ; case Number : @@v3@@ = Number ; break ; case Number : @@v3@@ = Number ; break ; default : @@v3@@ = Number ; break ; } @@result@@ = @@a1@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@v3@@ ; return @@result@@ ; }
_BOOL8 __fastcall chown_failure_ok ( __int64 @@a1@@ ) { return ( * __errno_location ( ) == Number || * __errno_location ( ) == Number ) && * ( _BYTE * ) ( @@a1@@ + Number ) != Number ; }
__int64 __fastcall num_processors ( int @@a1@@ ) { __int64 @@result@@ ; int @@v2@@ ; int @@v3@@ ; char * @@endptr@@ ; char * @@nptr@@ ; unsigned __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; cpu_set_t @@cpuset@@ ; unsigned __int64 @@v11@@ ; @@v3@@ = @@a1@@ ; @@v11@@ = __readfsqword ( Number ) ; if ( @@a1@@ == Number ) { @@nptr@@ = getenv ( String ) ; if ( @@nptr@@ ) { while ( * @@nptr@@ && ( unsigned __int8 ) c_isspace ( ( unsigned int ) * @@nptr@@ ) ) ++ @@nptr@@ ; if ( ( unsigned __int8 ) c_isdigit ( ( unsigned int ) * @@nptr@@ ) ) { @@endptr@@ = Number L ; @@v6@@ = strtoul ( @@nptr@@ , & @@endptr@@ , Number ) ; if ( @@endptr@@ ) { while ( * @@endptr@@ && ( unsigned __int8 ) c_isspace ( ( unsigned int ) * @@endptr@@ ) ) ++ @@endptr@@ ; if ( ! * @@endptr@@ ) { if ( @@v6@@ ) @@result@@ = @@v6@@ ; else @@result@@ = Number L ; return @@result@@ ; } } } } @@v3@@ = Number ; } if ( @@v3@@ == Number ) { if ( ! sched_getaffinity ( Number , Number , & @@cpuset@@ ) ) { @@v2@@ = __sched_cpucount ( Number , & @@cpuset@@ ) ; @@v8@@ = @@v2@@ ; if ( @@v2@@ ) return @@v8@@ ; } @@v9@@ = sysconf ( Number ) ; if ( @@v9@@ > Number ) return @@v9@@ ; } else { @@v7@@ = sysconf ( Number ) ; if ( @@v7@@ > Number ) return @@v7@@ ; } return Number L ; }
_BOOL8 __fastcall c_isascii ( int @@a1@@ ) { return @@a1@@ >= Number && @@a1@@ <= Number ; }
_BOOL8 __fastcall owner_failure_ok ( __int64 @@a1@@ ) { return ( * __errno_location ( ) == Number || * __errno_location ( ) == Number ) && * ( _BYTE * ) ( @@a1@@ + Number ) != Number ; }
__int64 __fastcall valid_options ( __int64 @@a1@@ ) { if ( ! @@a1@@ ) __assert_fail ( String , String , Number , String ) ; if ( * ( _DWORD * ) @@a1@@ > Number ) __assert_fail ( String , String , Number , String ) ; if ( * ( _DWORD * ) ( @@a1@@ + Number ) != Number && * ( _DWORD * ) ( @@a1@@ + Number ) != Number && * ( _DWORD * ) ( @@a1@@ + Number ) != Number ) { __assert_fail ( String , String , Number , String ) ; } if ( * ( _DWORD * ) ( @@a1@@ + Number ) && * ( _DWORD * ) ( @@a1@@ + Number ) != Number && * ( _DWORD * ) ( @@a1@@ + Number ) != Number ) { __assert_fail ( String , String , Number , String ) ; } if ( * ( _BYTE * ) ( @@a1@@ + Number ) == Number && * ( _BYTE * ) ( @@a1@@ + Number ) == Number ) __assert_fail ( String , String , Number , String ) ; if ( * ( _DWORD * ) ( @@a1@@ + Number ) == Number && * ( _DWORD * ) ( @@a1@@ + Number ) != Number ) __assert_fail ( String , String , Number , String ) ; return Number L ; }
__int64 __fastcall fts_palloc ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; unsigned __int64 @@v3@@ ; void * @@v4@@ ; @@v3@@ = * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ + Number ; if ( @@v3@@ >= * ( _QWORD * ) ( @@a1@@ + Number ) ) { * ( _QWORD * ) ( @@a1@@ + Number ) = @@v3@@ ; @@v4@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , * ( _QWORD * ) ( @@a1@@ + Number ) ) ; if ( @@v4@@ ) { * ( _QWORD * ) ( @@a1@@ + Number ) = @@v4@@ ; @@result@@ = Number L ; } else { free ( * ( void * * ) ( @@a1@@ + Number ) ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; @@result@@ = Number L ; } } else { free ( * ( void * * ) ( @@a1@@ + Number ) ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * __errno_location ( ) = Number ; @@result@@ = Number L ; } return @@result@@ ; }
_BOOL8 __fastcall c_isdigit ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
__int64 __fastcall src_to_dest_lookup ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; __int64 @@v3@@ ; __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = @@a1@@ ; @@v4@@ [ Number ] = @@a2@@ ; @@v3@@ = hash_lookup ( src_to_dest , @@v4@@ ) ; if ( @@v3@@ ) @@result@@ = * ( _QWORD * ) ( @@v3@@ + Number ) ; else @@result@@ = Number L ; return @@result@@ ; }
unsigned __int64 __fastcall forget_created ( __int64 @@a1@@ , __int64 @@a2@@ ) { void * * @@v3@@ ; __int64 @@v4@@ [ Number ] ; unsigned __int64 @@v5@@ ; @@v5@@ = __readfsqword ( Number ) ; @@v4@@ [ Number ] = @@a1@@ ; @@v4@@ [ Number ] = @@a2@@ ; @@v4@@ [ Number ] = Number L ; @@v3@@ = ( void * * ) hash_delete ( src_to_dest , @@v4@@ ) ; if ( @@v3@@ ) src_to_dest_free ( @@v3@@ ) ; return __readfsqword ( Number ) ^ @@v5@@ ; }
__int64 __fastcall hash_get_n_buckets_used ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
_BOOL8 __fastcall c_isspace ( int @@a1@@ ) { return @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
__int64 __fastcall copy_acl ( __int64 @@a1@@ , unsigned int @@a2@@ , const char * @@a3@@ , int @@a4@@ , __mode_t @@a5@@ ) { int @@v5@@ ; const char * @@v6@@ ; int * @@v7@@ ; __int64 @@v8@@ ; char * @@v9@@ ; int * @@v10@@ ; __int64 @@result@@ ; @@v5@@ = qcopy_acl ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; if ( @@v5@@ == Number ) { @@v6@@ = ( const char * ) quote ( @@a1@@ ) ; @@v7@@ = __errno_location ( ) ; error ( Number , * @@v7@@ , String , @@v6@@ ) ; @@result@@ = Number ; } else if ( @@v5@@ == Number ) { @@v8@@ = quote ( @@a3@@ ) ; @@v9@@ = gettext ( String ) ; @@v10@@ = __errno_location ( ) ; error ( Number , * @@v10@@ , @@v9@@ , @@v8@@ ) ; @@result@@ = Number ; } else { @@result@@ = Number L ; } return @@result@@ ; }
int __fastcall qcopy_acl ( __int64 a1 , __int64 a2 , const char * @@a3@@ , int @@a4@@ , __mode_t @@a5@@ ) { return qset_acl ( @@a3@@ , @@a4@@ , @@a5@@ ) ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
int __fastcall hash_print_statistics ( __int64 @@a1@@ , FILE * @@a2@@ ) { double @@v2@@ ; double @@v3@@ ; double @@v4@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v6@@ = hash_get_n_entries ( @@a1@@ ) ; @@v7@@ = hash_get_n_buckets ( @@a1@@ ) ; @@v8@@ = hash_get_n_buckets_used ( @@a1@@ ) ; @@v9@@ = hash_get_max_bucket_length ( @@a1@@ ) ; fprintf ( @@a2@@ , String , @@v6@@ ) ; fprintf ( @@a2@@ , String , @@v7@@ ) ; if ( @@v8@@ < Number ) @@v2@@ = ( double ) ( int ) ( @@v8@@ & Number | ( ( unsigned __int64 ) @@v8@@ >> Number ) ) + ( double ) ( int ) ( @@v8@@ & Number | ( ( unsigned __int64 ) @@v8@@ >> Number ) ) ; else @@v2@@ = ( double ) ( int ) @@v8@@ ; @@v3@@ = Number * @@v2@@ ; if ( @@v7@@ < Number ) @@v4@@ = ( double ) ( int ) ( @@v7@@ & Number | ( ( unsigned __int64 ) @@v7@@ >> Number ) ) + ( double ) ( int ) ( @@v7@@ & Number | ( ( unsigned __int64 ) @@v7@@ >> Number ) ) ; else @@v4@@ = ( double ) ( int ) @@v7@@ ; fprintf ( @@a2@@ , String , @@v8@@ , @@v3@@ / @@v4@@ ) ; return fprintf ( @@a2@@ , String , @@v9@@ ) ; }
_BOOL8 __fastcall triple_compare_ino_str ( __int64 @@a1@@ , __int64 @@a2@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) == * ( _QWORD * ) ( @@a2@@ + Number ) && * ( _QWORD * ) ( @@a1@@ + Number ) == * ( _QWORD * ) ( @@a2@@ + Number ) && ! strcmp ( * ( const char * * ) @@a1@@ , * ( const char * * ) @@a2@@ ) ; }
bool __fastcall seen_file ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 * @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; if ( ! @@a1@@ ) return Number ; @@v4@@ [ Number ] = @@a2@@ ; @@v4@@ [ Number ] = @@a3@@ [ Number ] ; @@v4@@ [ Number ] = * @@a3@@ ; return hash_lookup ( @@a1@@ , @@v4@@ ) != Number ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
bool __fastcall is_prime ( unsigned __int64 @@a1@@ ) { unsigned __int64 @@v2@@ ; unsigned __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; @@v2@@ = Number L ; @@v4@@ = Number L ; while ( @@v4@@ < @@a1@@ && @@a1@@ % @@v2@@ ) { @@v3@@ = @@v2@@ + Number ; @@v4@@ += Number * @@v3@@ ; @@v2@@ = @@v3@@ + Number ; } return @@a1@@ % @@v2@@ != Number ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_207028 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
_BOOL8 __fastcall triple_compare_ino_str ( __int64 @@a1@@ , __int64 @@a2@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) == * ( _QWORD * ) ( @@a2@@ + Number ) && * ( _QWORD * ) ( @@a1@@ + Number ) == * ( _QWORD * ) ( @@a2@@ + Number ) && ! strcmp ( * ( const char * * ) @@a1@@ , * ( const char * * ) @@a2@@ ) ; }
__int64 __fastcall hash_clear ( __int64 @@a1@@ ) { __int64 @@result@@ ; _QWORD * @@i@@ ; _QWORD * @@j@@ ; _QWORD * @@v4@@ ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = ( _QWORD * ) @@i@@ [ Number ] ; @@j@@ ; @@j@@ = @@v4@@ ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@j@@ ) ; * @@j@@ = Number L ; @@v4@@ = ( _QWORD * ) @@j@@ [ Number ] ; @@j@@ [ Number ] = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@j@@ ; } if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@i@@ ) ; * @@i@@ = Number L ; @@i@@ [ Number ] = Number L ; } } * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; @@result@@ = @@a1@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; return @@result@@ ; }
char * __fastcall proper_name_utf8 ( const char * @@a1@@ , __int64 @@a2@@ ) { char * @@v2@@ ; char * @@result@@ ; size_t @@v4@@ ; size_t @@v5@@ ; char * @@ptr@@ ; char * @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; char * @@s1@@ ; char * @@s@@ ; size_t @@n@@ ; char * @@dest@@ ; char * @@v14@@ ; char * @@v15@@ ; char * @@v16@@ ; @@s1@@ = gettext ( @@a1@@ ) ; @@s@@ = ( char * ) locale_charset ( ) ; @@ptr@@ = Number L ; @@v7@@ = Number L ; @@v9@@ = Number L ; if ( ( unsigned int ) c_strcasecmp ( @@s@@ , String ) ) { @@ptr@@ = ( char * ) xstr_iconv ( @@a2@@ , String , @@s@@ ) ; @@v8@@ = ( __int64 ) @@ptr@@ ; @@n@@ = strlen ( @@s@@ ) ; @@dest@@ = ( char * ) xmalloc ( @@n@@ + Number ) ; memcpy ( @@dest@@ , @@s@@ , @@n@@ ) ; memcpy ( & @@dest@@ [ @@n@@ ] , String , Number ) ; @@v14@@ = ( char * ) xstr_iconv ( @@a2@@ , String , @@dest@@ ) ; free ( @@dest@@ ) ; if ( @@v14@@ ) { if ( strchr ( @@v14@@ , Number ) ) { free ( @@v14@@ ) ; } else { @@v7@@ = @@v14@@ ; @@v9@@ = ( __int64 ) @@v14@@ ; } } } else { @@v8@@ = @@a2@@ ; @@v9@@ = @@a2@@ ; } if ( @@v8@@ ) { @@v2@@ = ( char * ) @@v8@@ ; } else if ( @@v9@@ ) { @@v2@@ = ( char * ) @@v9@@ ; } else { @@v2@@ = ( char * ) @@a1@@ ; } @@v15@@ = @@v2@@ ; if ( ! strcmp ( @@s1@@ , @@a1@@ ) ) { if ( @@ptr@@ && @@ptr@@ != @@v15@@ ) free ( @@ptr@@ ) ; if ( @@v7@@ && @@v7@@ != @@v15@@ ) free ( @@v7@@ ) ; @@result@@ = @@v15@@ ; } else if ( ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@s1@@ , ( __int64 ) @@a1@@ ) || @@v8@@ && ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@s1@@ , @@v8@@ ) || @@v9@@ && ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@s1@@ , @@v9@@ ) ) { if ( @@ptr@@ ) free ( @@ptr@@ ) ; if ( @@v7@@ ) free ( @@v7@@ ) ; @@result@@ = @@s1@@ ; } else { @@v4@@ = strlen ( @@s1@@ ) ; @@v5@@ = strlen ( @@v15@@ ) ; @@v16@@ = ( char * ) xmalloc ( @@v4@@ + @@v5@@ + Number ) ; sprintf ( @@v16@@ , String , @@s1@@ , @@v15@@ ) ; if ( @@ptr@@ ) free ( @@ptr@@ ) ; if ( @@v7@@ ) free ( @@v7@@ ) ; @@result@@ = @@v16@@ ; } return @@result@@ ; }
int tolower ( int @@c@@ ) { return tolower ( @@c@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
unsigned __int64 __fastcall check_extension ( const char * @@a1@@ , __int64 @@a2@@ , char @@a3@@ ) { unsigned __int64 @@v5@@ ; unsigned __int64 @@v6@@ ; char * @@v7@@ ; unsigned __int64 @@v8@@ ; __int64 @@v9@@ ; __int16 @@v10@@ ; unsigned __int64 @@v11@@ ; @@v11@@ = __readfsqword ( Number ) ; @@v7@@ = ( char * ) last_component ( @@a1@@ ) ; @@v5@@ = base_len ( @@v7@@ ) ; @@v8@@ = Number L ; if ( @@v5@@ > Number ) { @@v10@@ = * ( _WORD * ) @@v7@@ ; * ( _WORD * ) @@v7@@ = Number ; * __errno_location ( ) = Number ; @@v9@@ = pathconf ( @@a1@@ , Number ) ; if ( @@v9@@ >= Number || ! * __errno_location ( ) ) @@v8@@ = @@v9@@ ; * ( _WORD * ) @@v7@@ = @@v10@@ ; } if ( @@v8@@ < @@v5@@ ) { @@v6@@ = & @@a1@@ [ @@a2@@ ] - @@v7@@ ; if ( @@v8@@ <= @@v6@@ ) @@v6@@ = @@v8@@ - Number ; @@v7@@ [ @@v6@@ ] = @@a3@@ ; @@v7@@ [ @@v6@@ + Number ] = Number ; } return __readfsqword ( Number ) ^ @@v11@@ ; }
__int64 __fastcall hash_rehash ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; unsigned __int64 @@nmemb@@ ; void * @@v4@@ ; __int64 @@v5@@ ; unsigned __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; __int64 @@v12@@ ; __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; @@v14@@ = __readfsqword ( Number ) ; @@nmemb@@ = compute_bucket_size ( @@a2@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ; if ( ! @@nmemb@@ ) return Number L ; if ( @@nmemb@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; @@v4@@ = calloc ( @@nmemb@@ , Number ) ; if ( ! @@v4@@ ) return Number L ; @@v6@@ = @@nmemb@@ ; @@v5@@ = ( __int64 ) @@v4@@ + Number * @@nmemb@@ ; @@v7@@ = Number L ; @@v8@@ = Number L ; @@v9@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v10@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v11@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v12@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v13@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( ( unsigned __int8 ) transfer_entries ( ( __int64 ) & @@v4@@ , @@a1@@ , Number ) ) { free ( * ( void * * ) @@a1@@ ) ; * ( _QWORD * ) @@a1@@ = @@v4@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v5@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v6@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v7@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v13@@ ; @@result@@ = Number L ; } else { * ( _QWORD * ) ( @@a1@@ + Number ) = @@v13@@ ; if ( ( unsigned __int8 ) transfer_entries ( @@a1@@ , ( __int64 ) & @@v4@@ , Number ) != Number || ( unsigned __int8 ) transfer_entries ( @@a1@@ , ( __int64 ) & @@v4@@ , Number ) != Number ) { abort ( ) ; } free ( @@v4@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
__int64 __fastcall dir_name ( __int64 @@a1@@ ) { __int64 @@v2@@ ; @@v2@@ = mdir_name ( @@a1@@ ) ; if ( ! @@v2@@ ) xalloc_die ( ) ; return @@v2@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
__int64 __fastcall open_safer ( const char * @@a1@@ , char @@a2@@ , unsigned int @@a3@@ ) { unsigned int @@v3@@ ; unsigned int @@v5@@ ; @@v5@@ = Number ; if ( ( @@a2@@ & Number ) != Number ) @@v5@@ = @@a3@@ ; @@v3@@ = open ( @@a1@@ , @@a2@@ , @@v5@@ ) ; return fd_safer ( @@v3@@ ) ; }
_BOOL8 __fastcall c_isalpha ( int @@a1@@ ) { return ( int ) ( @@a1@@ & Number ) > Number && ( int ) ( @@a1@@ & Number ) <= Number ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
int __fastcall rpl_fflush ( FILE * @@a1@@ ) { if ( ! @@a1@@ || ! __freading ( @@a1@@ ) ) return fflush ( @@a1@@ ) ; clear_ungetc_buffer_preserving_position ( @@a1@@ ) ; return fflush ( @@a1@@ ) ; }
_BOOL8 __fastcall c_isprint ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
_BYTE * __fastcall dir_len ( _BYTE * @@a1@@ ) { _BYTE * @@i@@ ; unsigned __int64 @@v3@@ ; @@v3@@ = * @@a1@@ == Number ; for ( @@i@@ = ( _BYTE * ) ( last_component ( @@a1@@ ) - @@a1@@ ) ; @@v3@@ < ( unsigned __int64 ) @@i@@ && @@a1@@ [ ( _QWORD ) ( @@i@@ - Number ) ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
_BYTE * __fastcall filemodestring ( __int64 @@a1@@ , _BYTE * @@a2@@ ) { return strmode ( * ( _DWORD * ) ( @@a1@@ + Number ) , @@a2@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
_BOOL8 __fastcall c_ispunct ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number && ( @@a1@@ <= Number || @@a1@@ > Number ) && ( ( int ) ( @@a1@@ & Number ) <= Number || ( int ) ( @@a1@@ & Number ) > Number ) ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
__int64 __fastcall ftypelet ( __int16 @@a1@@ ) { switch ( @@a1@@ & Number ) { case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; } return Number L ; }
_BYTE * __fastcall longest_relative_suffix ( _BYTE * @@a1@@ ) { while ( * @@a1@@ == Number ) ++ @@a1@@ ; return @@a1@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
__int64 __fastcall c_toupper ( int @@a1@@ ) { __int64 @@result@@ ; if ( @@a1@@ <= Number || @@a1@@ > Number ) @@result@@ = ( unsigned int ) @@a1@@ ; else @@result@@ = ( unsigned int ) ( @@a1@@ - Number ) ; return @@result@@ ; }
_BYTE * __fastcall filemodestring ( __int64 @@a1@@ , _BYTE * @@a2@@ ) { return strmode ( * ( _DWORD * ) ( @@a1@@ + Number ) , @@a2@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
unsigned __int64 __fastcall AD_hash ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) % @@a2@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_21B038 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = ( __int64 * ) & slotvec0 ; } nslots = Number ; return @@result@@ ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 __fastcall fd_ring_clear ( __int64 @@a1@@ ) { __int64 @@result@@ ; int @@fd@@ ; while ( Number ) { @@result@@ = ( unsigned int ) i_ring_empty ( @@a1@@ ) ^ Number ; if ( ! ( _BYTE ) @@result@@ ) break ; @@fd@@ = i_ring_pop ( @@a1@@ ) ; if ( @@fd@@ >= Number ) close ( @@fd@@ ) ; } return @@result@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
void * __fastcall mfile_name_concat ( _BYTE * @@a1@@ , _BYTE * @@a2@@ , _QWORD * @@a3@@ ) { _BOOL4 @@v3@@ ; const char * @@v6@@ ; size_t @@v7@@ ; size_t @@n@@ ; _BOOL8 @@v9@@ ; char * @@s@@ ; size_t @@v11@@ ; void * @@dest@@ ; _BYTE * @@v13@@ ; char * @@v14@@ ; @@v6@@ = last_component ( @@a1@@ ) ; @@v7@@ = base_len ( @@v6@@ ) ; @@n@@ = @@v6@@ - @@a1@@ + @@v7@@ ; @@v3@@ = @@v7@@ && @@v6@@ [ @@v7@@ - Number ] != Number ; @@v9@@ = @@v3@@ ; @@s@@ = longest_relative_suffix ( @@a2@@ ) ; @@v11@@ = strlen ( @@s@@ ) ; @@dest@@ = malloc ( @@v9@@ + @@n@@ + @@v11@@ + Number ) ; if ( ! @@dest@@ ) return Number L ; @@v13@@ = mempcpy ( @@dest@@ , @@a1@@ , @@n@@ ) ; * @@v13@@ = Number ; @@v14@@ = & @@v13@@ [ @@v9@@ ] ; if ( @@a3@@ ) * @@a3@@ = & @@v14@@ [ - ( * @@a2@@ == Number ) ] ; * ( _BYTE * ) mempcpy ( @@v14@@ , @@s@@ , @@v11@@ ) = Number ; return @@dest@@ ; }
int putchar_unlocked ( int @@c@@ ) { return putchar_unlocked ( @@c@@ ) ; }
void * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall opendirat ( int @@a1@@ , int @@a2@@ , __int64 a3 , __int64 a4 , int @@a5@@ , int @@a6@@ ) { int @@fd@@ ; _BYTE @@v8@@ [ Number ] ; @@fd@@ = openat_safer ( @@a1@@ , @@a2@@ , Number , @@a2@@ , @@a5@@ , @@a6@@ , @@a2@@ ) ; if ( @@fd@@ < Number ) return Number L ; set_cloexec_flag ( ( unsigned int ) @@fd@@ , Number L ) ; * ( _QWORD * ) & @@v8@@ [ Number ] = fdopendir ( @@fd@@ ) ; if ( ! * ( _QWORD * ) & @@v8@@ [ Number ] ) { * ( _QWORD * ) @@v8@@ = ( unsigned int ) * __errno_location ( ) ; close ( @@fd@@ ) ; * __errno_location ( ) = * ( _DWORD * ) @@v8@@ ; } return * ( _QWORD * ) & @@v8@@ [ Number ] ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
__int64 __fastcall hash_get_n_buckets_used ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
_BOOL8 __fastcall dirent_inode_sort_may_be_useful ( int @@a1@@ ) { struct statfs @@buf@@ ; unsigned __int64 @@v3@@ ; @@v3@@ = __readfsqword ( Number ) ; if ( fstatfs ( @@a1@@ , & @@buf@@ ) ) return Number L ; return @@buf@@ . f_type != Number && @@buf@@ . f_type != Number ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
ssize_t __fastcall safe_write ( int @@a1@@ , const void * @@a2@@ , size_t @@a3@@ ) { ssize_t @@result@@ ; ssize_t @@v5@@ ; LABEL_1 : for ( @@result@@ = write ( @@a1@@ , @@a2@@ , @@a3@@ ) ; ; @@result@@ = write ( @@a1@@ , @@a2@@ , Number ) ) { @@v5@@ = @@result@@ ; if ( @@result@@ >= Number ) break ; if ( * __errno_location ( ) == Number ) goto LABEL_1 ; if ( * __errno_location ( ) != Number || @@a3@@ <= Number ) return @@v5@@ ; @@a3@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall hash_lookup ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; _QWORD * @@i@@ ; _QWORD * @@v5@@ ; @@v2@@ = * @@a1@@ ; @@v5@@ = ( _QWORD * ) ( @@v2@@ + Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) ) ; if ( ( unsigned __int64 ) @@v5@@ >= @@a1@@ [ Number ] ) abort ( ) ; if ( ! * @@v5@@ ) return Number L ; for ( @@i@@ = @@v5@@ ; @@i@@ ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { if ( @@a2@@ == * @@i@@ || ( ( unsigned __int8 ( __fastcall * ) ( __int64 , _QWORD ) ) @@a1@@ [ Number ] ) ( @@a2@@ , * @@i@@ ) ) { return * @@i@@ ; } } return Number L ; }
__int64 __fastcall link_count_optimize_ok ( __int64 @@a1@@ ) { __int64 @@result@@ ; bool @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; _BYTE * @@ptr@@ ; __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v3@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; if ( ( * ( _DWORD * ) ( @@v4@@ + Number ) & Number ) == Number ) return Number L ; if ( ! @@v3@@ ) { * ( _QWORD * ) ( @@v4@@ + Number ) = hash_initialize ( Number L , Number L , LCO_hash , LCO_compare , & free ) ; @@v3@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; if ( ! @@v3@@ ) return Number L ; } @@v8@@ [ Number ] = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v5@@ = hash_lookup ( @@v3@@ , @@v8@@ ) ; if ( @@v5@@ ) return * ( unsigned __int8 * ) ( @@v5@@ + Number ) ; @@ptr@@ = malloc ( Number ) ; if ( ! @@ptr@@ ) return Number L ; @@v2@@ = leaf_optimization_applies ( * ( _DWORD * ) ( @@v4@@ + Number ) ) ; @@ptr@@ [ Number ] = @@v2@@ ; * ( _QWORD * ) @@ptr@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v6@@ = hash_insert ( @@v3@@ , @@ptr@@ ) ; if ( @@v6@@ ) { if ( ( _BYTE * ) @@v6@@ != @@ptr@@ ) abort ( ) ; @@result@@ = @@v2@@ ; } else { free ( @@ptr@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
bool __fastcall hex_digits ( _BYTE * @@a1@@ ) { unsigned int @@i@@ ; for ( @@i@@ = Number ; @@i@@ < ( unsigned __int64 ) digest_hex_bytes ; ++ @@i@@ ) { if ( ( ( * __ctype_b_loc ( ) ) [ ( unsigned __int8 ) * @@a1@@ ] & Number ) == Number ) return Number ; ++ @@a1@@ ; } return * @@a1@@ == Number ; }
_BOOL8 __fastcall strip_trailing_slashes ( char * @@a1@@ ) { char @@v1@@ ; const char * @@v3@@ ; const char * @@v4@@ ; @@v3@@ = last_component ( @@a1@@ ) ; if ( ! * @@v3@@ ) @@v3@@ = @@a1@@ ; @@v4@@ = & @@v3@@ [ base_len ( @@v3@@ ) ] ; @@v1@@ = * @@v4@@ ; * @@v4@@ = Number ; return @@v1@@ != Number ; }
unsigned __int64 __fastcall hash_string ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ ) { unsigned __int64 @@v4@@ ; @@v4@@ = Number L ; while ( * @@a1@@ ) @@v4@@ = ( Number * @@v4@@ + ( unsigned __int8 ) * @@a1@@ ++ ) % @@a2@@ ; return @@v4@@ ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_20D028 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
bool __fastcall dev_info_compare ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { return * @@a1@@ == * @@a2@@ ; }
unsigned __int64 __fastcall raw_hasher ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return rotr_sz ( @@a1@@ , Number ) % @@a2@@ ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_20D0E8 ; @@v8@@ [ Number ] = qword_20D0F0 ; @@v8@@ [ Number ] = qword_20D0F8 ; @@v8@@ [ Number ] = qword_20D100 ; @@v8@@ [ Number ] = qword_20D108 ; @@v8@@ [ Number ] = qword_20D110 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
__int64 __fastcall fts_sort ( __int64 @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { size_t @@v3@@ ; _QWORD * @@v5@@ ; __int64 @@i@@ ; _QWORD * @@v7@@ ; _QWORD * @@v8@@ ; __int64 @@v9@@ ; int ( * @@compar@@ ( ) ( constvoid , constvoid ) ) ( const void * , const void * ) ; void * @@v11@@ ; @@v3@@ = @@a3@@ ; @@compar@@ ( ) ( constvoid , constvoid ) = * ( int ( * * ) ( const void * , const void * ) ) ( @@a1@@ + Number ) ; if ( @@a3@@ > * ( _QWORD * ) ( @@a1@@ + Number ) ) { * ( _QWORD * ) ( @@a1@@ + Number ) = @@a3@@ + Number ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) > Number || ( @@v11@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number L * * ( _QWORD * ) ( @@a1@@ + Number ) ) ) == Number L ) { free ( * ( void * * ) ( @@a1@@ + Number ) ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; return @@a2@@ ; } * ( _QWORD * ) ( @@a1@@ + Number ) = @@v11@@ ; } @@v5@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; for ( @@i@@ = @@a2@@ ; @@i@@ ; @@i@@ = * ( _QWORD * ) ( @@i@@ + Number ) ) { @@v7@@ = @@v5@@ ++ ; * @@v7@@ = @@i@@ ; } qsort ( * ( void * * ) ( @@a1@@ + Number ) , @@v3@@ , Number , @@compar@@ ( ) ( constvoid , constvoid ) ) ; @@v8@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; @@v9@@ = * @@v8@@ ; while ( -- @@v3@@ ) { * ( _QWORD * ) ( * @@v8@@ + Number L ) = @@v8@@ [ Number ] ; ++ @@v8@@ ; } * ( _QWORD * ) ( * @@v8@@ + Number L ) = Number L ; return @@v9@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
__int64 __fastcall get_stat_mtime_0 ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int64 __fastcall sha224_buffer ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { char @@v5@@ [ Number ] ; unsigned __int64 @@v6@@ ; @@v6@@ = __readfsqword ( Number ) ; sha224_init_ctx ( ( __int64 ) @@v5@@ ) ; sha256_process_bytes ( @@a1@@ , @@a2@@ , @@v5@@ ) ; return sha224_finish_ctx ( ( __int64 ) @@v5@@ , @@a3@@ ) ; }
size_t * __fastcall hash_initialize ( __int64 @@a1@@ , void * @@a2@@ , unsigned __int64 ( __fastcall * @@a3@@ ) ( __int64 a1 , unsigned __int64 a2 ) , bool ( __fastcall * @@a4@@ ) ( __int64 a1 , __int64 a2 ) , size_t @@a5@@ ) { size_t * @@result@@ ; bool ( __fastcall * @@v7@@ ) ( __int64 , __int64 ) ; unsigned __int64 ( __fastcall * @@v8@@ ) ( __int64 , unsigned __int64 ) ; void * @@v9@@ ; size_t * @@ptr@@ ; @@v9@@ = @@a2@@ ; @@v8@@ = @@a3@@ ; @@v7@@ = @@a4@@ ; if ( ! @@a3@@ ) @@v8@@ = raw_hasher ; if ( ! @@a4@@ ) @@v7@@ = raw_comparator ; @@ptr@@ = ( size_t * ) malloc ( Number ) ; if ( ! @@ptr@@ ) return Number L ; if ( ! @@a2@@ ) @@v9@@ = & default_tuning ; @@ptr@@ [ Number ] = ( size_t ) @@v9@@ ; if ( ( unsigned __int8 ) check_tuning ( ( __int64 ) @@ptr@@ ) == Number && ( @@ptr@@ [ Number ] = compute_bucket_size ( @@a1@@ , ( __int64 ) @@v9@@ ) ) != Number && ( * @@ptr@@ = ( size_t ) calloc ( @@ptr@@ [ Number ] , Number ) ) != Number ) { @@ptr@@ [ Number ] = Number * @@ptr@@ [ Number ] + * @@ptr@@ ; @@ptr@@ [ Number ] = Number L ; @@ptr@@ [ Number ] = Number L ; @@ptr@@ [ Number ] = ( size_t ) @@v8@@ ; @@ptr@@ [ Number ] = ( size_t ) @@v7@@ ; @@ptr@@ [ Number ] = @@a5@@ ; @@ptr@@ [ Number ] = Number L ; @@result@@ = @@ptr@@ ; } else { free ( @@ptr@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
unsigned __int64 __fastcall hash_get_max_bucket_length ( __int64 @@a1@@ ) { _QWORD * @@i@@ ; unsigned __int64 @@v3@@ ; _QWORD * @@v4@@ ; unsigned __int64 @@j@@ ; @@v3@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { @@v4@@ = @@i@@ ; for ( @@j@@ = Number L ; ; ++ @@j@@ ) { @@v4@@ = ( _QWORD * ) @@v4@@ [ Number ] ; if ( ! @@v4@@ ) break ; } if ( @@j@@ > @@v3@@ ) @@v3@@ = @@j@@ ; } } return @@v3@@ ; }
FILE * __fastcall fopen_safer ( const char * @@a1@@ , const char * @@a2@@ ) { int @@v3@@ ; int @@fd@@ ; int @@v5@@ ; int @@v6@@ ; FILE * @@stream@@ ; @@stream@@ = fopen ( @@a1@@ , @@a2@@ ) ; if ( ! @@stream@@ ) return @@stream@@ ; @@v3@@ = fileno ( @@stream@@ ) ; if ( @@v3@@ < Number || @@v3@@ > Number ) return @@stream@@ ; @@fd@@ = dup_safer ( ( unsigned int ) @@v3@@ ) ; if ( @@fd@@ < Number ) { @@v6@@ = * __errno_location ( ) ; fclose ( @@stream@@ ) ; * __errno_location ( ) = @@v6@@ ; return Number L ; } if ( ! fclose ( @@stream@@ ) ) { @@stream@@ = fdopen ( @@fd@@ , @@a2@@ ) ; if ( @@stream@@ ) return @@stream@@ ; } @@v5@@ = * __errno_location ( ) ; close ( @@fd@@ ) ; * __errno_location ( ) = @@v5@@ ; return Number L ; }
int __fastcall lutimens ( char * @@a1@@ , __int64 * @@a2@@ ) { struct timespec * @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; struct timespec * @@v6@@ ; __syscall_slong_t @@v7@@ ; struct timespec * @@v8@@ ; __syscall_slong_t @@v9@@ ; int @@v10@@ ; int @@v11@@ ; struct timespec * @@times@@ ; __int64 @@v13@@ [ Number ] ; struct stat @@v14@@ ; unsigned __int64 @@v15@@ ; @@v15@@ = __readfsqword ( Number ) ; if ( @@a2@@ ) @@v2@@ = ( struct timespec * ) @@v13@@ ; else @@v2@@ = Number L ; @@times@@ = @@v2@@ ; @@v10@@ = Number ; if ( @@v2@@ ) { @@v3@@ = @@a2@@ [ Number ] ; @@v13@@ [ Number ] = * @@a2@@ ; @@v13@@ [ Number ] = @@v3@@ ; @@v4@@ = @@a2@@ [ Number ] ; @@v13@@ [ Number ] = @@a2@@ [ Number ] ; @@v13@@ [ Number ] = @@v4@@ ; @@v10@@ = validate_timespec ( @@times@@ ) ; } if ( @@v10@@ < Number ) return Number ; if ( lutimensat_works_really >= Number ) { if ( @@v10@@ == Number ) { if ( ( unsigned int ) lstat ( @@a1@@ , & @@v14@@ ) ) return Number ; if ( @@times@@ -> tv_nsec == Number ) { @@v6@@ = @@times@@ ; @@times@@ -> tv_sec = get_stat_atime_0 ( ( __int64 ) & @@v14@@ ) ; @@v6@@ -> tv_nsec = @@v7@@ ; } else if ( @@times@@ [ Number ] . tv_nsec == Number ) { @@v8@@ = @@times@@ + Number ; @@times@@ [ Number ] . tv_sec = get_stat_mtime_0 ( ( __int64 ) & @@v14@@ ) ; @@v8@@ -> tv_nsec = @@v9@@ ; } @@v10@@ = Number ; } @@v11@@ = utimensat ( Number , @@a1@@ , @@times@@ , Number ) ; if ( @@v11@@ > Number ) * __errno_location ( ) = Number ; if ( ! @@v11@@ || * __errno_location ( ) != Number ) { utimensat_works_really = Number ; lutimensat_works_really = Number ; return @@v11@@ ; } } lutimensat_works_really = Number ; if ( ! @@v10@@ ) goto LABEL_37 ; if ( @@v10@@ != Number && ( unsigned int ) lstat ( @@a1@@ , & @@v14@@ ) ) return Number ; if ( @@times@@ && ( unsigned __int8 ) update_timespec ( ( __int64 ) & @@v14@@ , ( __int64 * * ) & @@times@@ ) ) { return Number ; } LABEL_37 : if ( ! @@v10@@ && ( unsigned int ) lstat ( @@a1@@ , & @@v14@@ ) ) return Number ; if ( ( @@v14@@ . st_mode & Number ) != Number ) return fdutimens ( @@a1@@ , Number , & @@times@@ -> tv_sec ) ; * __errno_location ( ) = Number ; return Number ; }
unsigned __int64 __fastcall sha256_process_bytes ( char * @@a1@@ , unsigned __int64 @@a2@@ , size_t * @@a3@@ ) { unsigned __int64 @@result@@ ; size_t @@v4@@ ; void * @@v5@@ ; size_t @@v7@@ ; char * @@src@@ ; size_t @@v9@@ ; size_t @@v10@@ ; size_t @@v11@@ ; size_t @@n@@ ; @@src@@ = @@a1@@ ; @@v7@@ = @@a2@@ ; @@result@@ = @@a3@@ [ Number ] ; if ( @@result@@ ) { @@v11@@ = @@a3@@ [ Number ] ; @@v4@@ = Number - @@v11@@ ; if ( @@a2@@ <= Number - @@v11@@ ) @@v4@@ = @@a2@@ ; @@n@@ = @@v4@@ ; memcpy ( ( char * ) @@a3@@ + @@v11@@ + Number , @@a1@@ , @@v4@@ ) ; @@a3@@ [ Number ] += @@n@@ ; if ( @@a3@@ [ Number ] > Number ) { sha256_process_block ( @@a3@@ + Number , @@a3@@ [ Number ] & Number , @@a3@@ ) ; @@a3@@ [ Number ] &= Number ; memcpy ( @@a3@@ + Number , ( char * ) @@a3@@ + ( ( @@v11@@ + @@n@@ ) & Number ) + Number , @@a3@@ [ Number ] ) ; } @@src@@ = & @@a1@@ [ @@n@@ ] ; @@result@@ = @@n@@ ; @@v7@@ = @@a2@@ - @@n@@ ; } if ( @@v7@@ > Number ) { @@result@@ = ( unsigned __int8 ) @@src@@ & Number ; if ( ( ( unsigned __int8 ) @@src@@ & Number ) != Number ) { while ( @@v7@@ > Number ) { @@v5@@ = memcpy ( @@a3@@ + Number , @@src@@ , Number ) ; @@result@@ = sha256_process_block ( @@v5@@ , Number L , @@a3@@ ) ; @@src@@ += Number ; @@v7@@ -= Number L ; } } else { sha256_process_block ( @@src@@ , @@v7@@ & Number , @@a3@@ ) ; @@result@@ = @@v7@@ & Number ; @@src@@ += @@v7@@ & Number ; @@v7@@ &= Number ; } } if ( @@v7@@ ) { @@v9@@ = @@a3@@ [ Number ] ; memcpy ( ( char * ) @@a3@@ + @@v9@@ + Number , @@src@@ , @@v7@@ ) ; @@v10@@ = @@v7@@ + @@v9@@ ; if ( @@v10@@ > Number ) { sha256_process_block ( @@a3@@ + Number , Number L , @@a3@@ ) ; @@v10@@ -= Number L ; memcpy ( @@a3@@ + Number , @@a3@@ + Number , @@v10@@ ) ; } @@result@@ = ( unsigned __int64 ) @@a3@@ ; @@a3@@ [ Number ] = @@v10@@ ; } return @@result@@ ; }
__int64 __fastcall linkat_follow ( unsigned int @@a1@@ , _BYTE * @@a2@@ , int @@a3@@ , const char * @@a4@@ ) { __int64 @@result@@ ; int @@v8@@ ; int @@v9@@ ; unsigned int @@v10@@ ; int @@v11@@ ; _BYTE * @@ptr@@ ; _BYTE * @@v13@@ ; _BYTE * @@v14@@ ; @@ptr@@ = @@a2@@ ; @@v8@@ = Number ; while ( @@v8@@ -- ) { @@v13@@ = ( _BYTE * ) areadlinkat ( @@a1@@ , @@ptr@@ ) ; if ( ! @@v13@@ ) break ; if ( * @@v13@@ == Number ) { if ( @@ptr@@ != @@a2@@ ) free ( @@ptr@@ ) ; @@ptr@@ = @@v13@@ ; } else { @@v14@@ = mdir_name ( @@ptr@@ ) ; if ( @@ptr@@ != @@a2@@ ) free ( @@ptr@@ ) ; if ( ! @@v14@@ ) { free ( @@v13@@ ) ; * __errno_location ( ) = Number ; return Number ; } @@ptr@@ = mfile_name_concat ( @@v14@@ , @@v13@@ , Number L ) ; free ( @@v14@@ ) ; free ( @@v13@@ ) ; if ( ! @@ptr@@ ) { * __errno_location ( ) = Number ; return Number ; } } } if ( @@v8@@ < Number ) { @@v13@@ = Number L ; * __errno_location ( ) = Number ; } if ( @@v13@@ || * __errno_location ( ) == Number ) { @@v10@@ = linkat ( @@a1@@ , @@ptr@@ , @@a3@@ , @@a4@@ , Number ) ; if ( @@ptr@@ != @@a2@@ ) { @@v11@@ = * __errno_location ( ) ; free ( @@ptr@@ ) ; * __errno_location ( ) = @@v11@@ ; } @@result@@ = @@v10@@ ; } else { if ( @@ptr@@ != @@a2@@ ) { @@v9@@ = * __errno_location ( ) ; free ( @@ptr@@ ) ; * __errno_location ( ) = @@v9@@ ; } @@result@@ = Number ; } return @@result@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
__int64 __fastcall hash_get_next ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; _QWORD * @@v4@@ ; _QWORD * @@i@@ ; @@v2@@ = * @@a1@@ ; @@v4@@ = ( _QWORD * ) ( @@v2@@ + Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) ) ; if ( ( unsigned __int64 ) @@v4@@ >= @@a1@@ [ Number ] ) abort ( ) ; for ( @@i@@ = @@v4@@ ; @@i@@ ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { if ( @@a2@@ == * @@i@@ && @@i@@ [ Number ] ) return * ( _QWORD * ) @@i@@ [ Number ] ; } while ( Number ) { @@v4@@ += Number ; if ( ( unsigned __int64 ) @@v4@@ >= @@a1@@ [ Number ] ) break ; if ( * @@v4@@ ) return * @@v4@@ ; } return Number L ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
_BOOL8 __fastcall cycle_warning_required ( __int64 @@a1@@ , __int64 @@a2@@ ) { return ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number && ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) == Number || ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number && ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number && * ( _QWORD * ) ( @@a2@@ + Number ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
__int64 __fastcall check_tuning ( __int64 @@a1@@ ) { __int64 @@v2@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( ( _UNKNOWN * ) @@v2@@ == & default_tuning ) return Number L ; if ( * ( float * ) ( @@v2@@ + Number ) > Number && ( float ) ( Number - Number ) > * ( float * ) ( @@v2@@ + Number ) && * ( float * ) ( @@v2@@ + Number ) > ( float ) ( Number + Number ) && * ( float * ) @@v2@@ >= Number && * ( float * ) ( @@v2@@ + Number ) > ( float ) ( * ( float * ) @@v2@@ + Number ) && * ( float * ) ( @@v2@@ + Number ) <= Number && * ( float * ) ( @@v2@@ + Number ) > ( float ) ( * ( float * ) @@v2@@ + Number ) ) { return Number L ; } * ( _QWORD * ) ( @@a1@@ + Number ) = & default_tuning ; return Number L ; }
__int64 __fastcall rpl_fcntl ( int @@a1@@ , int @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , __m128 @@a7@@ , __m128 @@a8@@ , __m128 @@a9@@ , __m128 @@a10@@ , __m128 @@a11@@ , __m128 @@a12@@ , __m128 @@a13@@ , __m128 @@a14@@ ) { int @@v14@@ ; int @@v15@@ ; int @@v16@@ ; int @@v18@@ ; int @@v19@@ ; int @@v20@@ ; int @@v21@@ ; __int64 @@v22@@ ; __int64 @@v23@@ ; __int64 @@v24@@ ; __int64 @@v25@@ ; __m128 @@v26@@ ; __m128 @@v27@@ ; __m128 @@v28@@ ; __m128 @@v29@@ ; __m128 @@v30@@ ; __m128 @@v31@@ ; __m128 @@v32@@ ; __m128 @@v33@@ ; @@v22@@ = @@a3@@ ; @@v23@@ = @@a4@@ ; @@v24@@ = @@a5@@ ; @@v25@@ = @@a6@@ ; @@v26@@ = @@a7@@ ; @@v27@@ = @@a8@@ ; @@v28@@ = @@a9@@ ; @@v29@@ = @@a10@@ ; @@v30@@ = @@a11@@ ; @@v31@@ = @@a12@@ ; @@v32@@ = @@a13@@ ; @@v33@@ = @@a14@@ ; if ( @@a2@@ != Number ) return ( unsigned int ) fcntl ( @@a1@@ , @@a2@@ , @@v22@@ ) ; @@v19@@ = @@v22@@ ; if ( have_dupfd_cloexec_2895 < Number ) { @@v18@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v22@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; } else { @@v18@@ = fcntl ( @@a1@@ , Number , ( unsigned int ) @@v22@@ ) ; if ( @@v18@@ < Number && * __errno_location ( ) == Number ) { @@v18@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v19@@ , @@v14@@ , @@v15@@ , @@v16@@ ) ; if ( @@v18@@ < Number ) return ( unsigned int ) @@v18@@ ; have_dupfd_cloexec_2895 = Number ; } else { have_dupfd_cloexec_2895 = Number ; } } if ( @@v18@@ >= Number && have_dupfd_cloexec_2895 == Number ) { @@v20@@ = fcntl ( @@v18@@ , Number ) ; if ( @@v20@@ < Number || fcntl ( @@v18@@ , Number , @@v20@@ | Number ) == Number ) { @@v21@@ = * __errno_location ( ) ; close ( @@v18@@ ) ; * __errno_location ( ) = @@v21@@ ; @@v18@@ = Number ; } } return ( unsigned int ) @@v18@@ ; }
void __fastcall argmatch_invalid ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { char * @@v3@@ ; __int64 @@v4@@ ; void * @@v5@@ ; char * @@format@@ ; if ( @@a3@@ == Number ) @@v3@@ = gettext ( String ) ; else @@v3@@ = gettext ( String ) ; @@format@@ = @@v3@@ ; @@v4@@ = quote_n ( Number , @@a1@@ ) ; @@v5@@ = quotearg_n_style ( Number , Number , @@a2@@ ) ; error ( Number , Number , @@format@@ , @@v5@@ , @@v4@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
void * __fastcall allocate_entry ( __int64 @@a1@@ ) { __int64 @@v2@@ ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return malloc ( Number ) ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = * ( _QWORD * ) ( @@v2@@ + Number ) ; return ( void * ) @@v2@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
__int64 __fastcall sha256_finish_ctx ( __int64 @@a1@@ , __int64 @@a2@@ ) { sha256_conclude_ctx ( @@a1@@ ) ; return sha256_read_ctx ( @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall argmatch_to_argument ( const void * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; ++ @@i@@ ) { if ( ! memcmp ( @@a1@@ , ( const void * ) ( @@i@@ * @@a4@@ + @@a3@@ ) , @@a4@@ ) ) return * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; } return Number L ; }
__int64 __fastcall hash_find_entry ( __int64 @@a1@@ , __int64 @@a2@@ , _QWORD * @@a3@@ , char @@a4@@ ) { __int64 @@v4@@ ; __int64 @@result@@ ; __int64 @@v6@@ ; _QWORD * @@i@@ ; _QWORD * @@v10@@ ; __int64 @@v11@@ ; _QWORD * @@v12@@ ; __int64 @@v13@@ ; _QWORD * @@v14@@ ; @@v4@@ = * ( _QWORD * ) @@a1@@ ; @@v10@@ = ( _QWORD * ) ( @@v4@@ + Number * ( * ( __int64 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@a2@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@v10@@ >= * ( _QWORD * ) ( @@a1@@ + Number ) ) abort ( ) ; * @@a3@@ = @@v10@@ ; if ( ! * @@v10@@ ) return Number L ; if ( @@a2@@ == * @@v10@@ || ( * ( unsigned __int8 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@a2@@ , * @@v10@@ ) ) { @@v13@@ = * @@v10@@ ; if ( @@a4@@ ) { if ( @@v10@@ [ Number ] ) { @@v14@@ = ( _QWORD * ) @@v10@@ [ Number ] ; @@v6@@ = @@v14@@ [ Number ] ; * @@v10@@ = * @@v14@@ ; @@v10@@ [ Number ] = @@v6@@ ; free_entry ( @@a1@@ , @@v14@@ ) ; } else { * @@v10@@ = Number L ; } } @@result@@ = @@v13@@ ; } else { for ( @@i@@ = @@v10@@ ; ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { if ( ! @@i@@ [ Number ] ) return Number L ; if ( @@a2@@ == * ( _QWORD * ) @@i@@ [ Number ] || ( * ( unsigned __int8 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@a2@@ , * ( _QWORD * ) @@i@@ [ Number ] ) ) { break ; } } @@v11@@ = * ( _QWORD * ) @@i@@ [ Number ] ; if ( @@a4@@ ) { @@v12@@ = ( _QWORD * ) @@i@@ [ Number ] ; @@i@@ [ Number ] = @@v12@@ [ Number ] ; free_entry ( @@a1@@ , @@v12@@ ) ; } @@result@@ = @@v11@@ ; } return @@result@@ ; }
__int64 __fastcall hextobin ( unsigned __int8 @@a1@@ ) { __int64 @@result@@ ; switch ( @@a1@@ ) { case String : case String : @@result@@ = Number L ; break ; case String : case String : @@result@@ = Number L ; break ; case String : case String : @@result@@ = Number L ; break ; case String : case String : @@result@@ = Number L ; break ; case String : case String : @@result@@ = Number L ; break ; case String : case String : @@result@@ = Number L ; break ; default : @@result@@ = ( unsigned int ) @@a1@@ - Number ; break ; } return @@result@@ ; }
__int64 __fastcall sha224_finish_ctx ( __int64 @@a1@@ , __int64 @@a2@@ ) { sha256_conclude_ctx ( @@a1@@ ) ; return sha224_read_ctx ( @@a1@@ , @@a2@@ ) ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_21D048 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
__int64 __fastcall cycle_check ( __int64 @@a1@@ , _QWORD * @@a2@@ ) { if ( * ( _DWORD * ) ( @@a1@@ + Number ) != Number ) __assert_fail ( String , String , Number , String ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) && @@a2@@ [ Number ] == * ( _QWORD * ) @@a1@@ && * @@a2@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ) { return Number L ; } if ( is_zero_or_power_of_two ( ++ * ( _QWORD * ) ( @@a1@@ + Number ) ) ) { if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = * @@a2@@ ; * ( _QWORD * ) @@a1@@ = @@a2@@ [ Number ] ; } return Number L ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
__int64 __fastcall i_ring_push ( __int64 @@a1@@ , int @@a2@@ ) { int @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = ( ( unsigned __int8 ) * ( _DWORD * ) ( @@a1@@ + Number ) + ( * ( _BYTE * ) ( @@a1@@ + Number ) ^ Number ) ) & Number ; @@v4@@ = * ( _DWORD * ) ( @@a1@@ + Number L * ( ( ( unsigned __int8 ) * ( _DWORD * ) ( @@a1@@ + Number ) + ( * ( _BYTE * ) ( @@a1@@ + Number ) ^ Number ) ) & Number ) ) ; * ( _DWORD * ) ( @@a1@@ + Number L * ( ( ( unsigned __int8 ) * ( _DWORD * ) ( @@a1@@ + Number ) + ( * ( _BYTE * ) ( @@a1@@ + Number ) ^ Number ) ) & Number ) ) = @@a2@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@v3@@ ; if ( @@v3@@ == * ( _DWORD * ) ( @@a1@@ + Number ) ) * ( _DWORD * ) ( @@a1@@ + Number ) = ( ( unsigned __int8 ) * ( _DWORD * ) ( @@a1@@ + Number ) + ( * ( _BYTE * ) ( @@a1@@ + Number ) ^ Number ) ) & Number ; * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; return @@v4@@ ; }
__int64 __fastcall sha256_stream ( FILE * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v3@@ ; char * @@ptr@@ ; size_t @@v5@@ ; char @@v6@@ [ Number ] ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@ptr@@ = ( char * ) malloc ( Number ) ; if ( ! @@ptr@@ ) return Number L ; sha256_init_ctx ( ( __int64 ) @@v6@@ ) ; LABEL_4 : @@v3@@ = Number L ; while ( Number ) { @@v5@@ = fread_unlocked ( & @@ptr@@ [ @@v3@@ ] , Number , Number - @@v3@@ , @@a1@@ ) ; @@v3@@ += @@v5@@ ; if ( @@v3@@ == Number ) { sha256_process_block ( @@ptr@@ , Number , @@v6@@ ) ; goto LABEL_4 ; } if ( ! @@v5@@ ) break ; if ( feof_unlocked ( @@a1@@ ) ) goto LABEL_12 ; } if ( ferror_unlocked ( @@a1@@ ) ) { free ( @@ptr@@ ) ; return Number L ; } LABEL_12 : if ( @@v3@@ ) sha256_process_bytes ( @@ptr@@ , @@v3@@ , @@v6@@ ) ; sha256_finish_ctx ( ( __int64 ) @@v6@@ , @@a2@@ ) ; free ( @@ptr@@ ) ; return Number L ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
int __fastcall lstat ( char * @@filename@@ , struct stat * @@stat_buf@@ ) { return __lxstat ( Number , @@filename@@ , @@stat_buf@@ ) ; }
_BYTE * __fastcall savedir ( const char * @@a1@@ ) { DIR * @@v1@@ ; @@v1@@ = opendir_safer ( @@a1@@ ) ; return savedirstream ( @@v1@@ ) ; }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
DIR * __fastcall opendir_safer ( const char * @@a1@@ ) { int @@v2@@ ; int @@fd@@ ; int @@v4@@ ; DIR * @@dirp@@ ; DIR * @@v6@@ ; @@dirp@@ = opendir ( @@a1@@ ) ; if ( @@dirp@@ ) { @@v2@@ = dirfd ( @@dirp@@ ) ; if ( @@v2@@ >= Number && @@v2@@ <= Number ) { @@fd@@ = dup_safer ( ( unsigned int ) @@v2@@ ) ; @@v6@@ = fdopendir ( @@fd@@ ) ; @@v4@@ = * __errno_location ( ) ; if ( ! @@v6@@ ) close ( @@fd@@ ) ; closedir ( @@dirp@@ ) ; * __errno_location ( ) = @@v4@@ ; @@dirp@@ = @@v6@@ ; } } return @@dirp@@ ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
__int64 __fastcall get_stat_atime_ns ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
bool __fastcall dev_info_compare ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { return * @@a1@@ == * @@a2@@ ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
int __fastcall gl_futimens ( int @@a1@@ , char * @@a2@@ , __int64 * @@a3@@ ) { return fdutimens ( @@a2@@ , @@a1@@ , @@a3@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
int __fastcall utimens ( char * @@a1@@ , __int64 * @@a2@@ ) { return fdutimens ( @@a1@@ , Number , @@a2@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
void * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
void * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_21B128 ; @@v4@@ [ Number ] = qword_21B130 ; @@v4@@ [ Number ] = qword_21B138 ; @@v4@@ [ Number ] = qword_21B140 ; @@v4@@ [ Number ] = qword_21B148 ; @@v4@@ [ Number ] = qword_21B150 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v4@@ ; @@v4@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v4@@ >= Number / @@a3@@ ) xalloc_die ( ) ; @@v4@@ += ( @@v4@@ + Number ) >> Number ; } else if ( ! @@v4@@ ) { @@v4@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v4@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v4@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@v3@@ ; @@v3@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v3@@ ) xalloc_die ( ) ; return @@v3@@ ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
int __cdecl __noreturn main ( int @@argc@@ , const char * * @@argv@@ , const char * * @@envp@@ ) { __int64 @@v3@@ ; char * @@v4@@ ; unsigned int @@v5@@ ; int @@v6@@ ; unsigned __int64 @@v7@@ ; unsigned __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v7@@ = Number L ; set_program_name ( * @@argv@@ , @@argv@@ , @@envp@@ ) ; setlocale ( Number , & shortopts ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; @@v5@@ = Number ; while ( Number ) { @@v6@@ = getopt_long ( @@argc@@ , ( char * const * ) @@argv@@ , & shortopts , & longopts , Number L ) ; if ( @@v6@@ == Number ) { @@v8@@ = num_processors ( @@v5@@ ) ; if ( @@v8@@ <= @@v7@@ ) @@v8@@ = Number L ; else @@v8@@ -= @@v7@@ ; printf ( String , @@v8@@ ) ; exit ( Number ) ; } if ( @@v6@@ == Number ) usage ( Number ) ; if ( @@v6@@ <= Number ) break ; if ( @@v6@@ == Number ) { @@v5@@ = Number ; } else { if ( @@v6@@ != Number ) goto LABEL_15 ; if ( ( unsigned int ) xstrtoul ( optarg , Number L , Number L , & @@v7@@ , & shortopts ) ) { @@v3@@ = optarg ; @@v4@@ = gettext ( String ) ; error ( Number , Number , @@v4@@ , @@v3@@ ) ; usage ( Number ) ; } } } if ( @@v6@@ == Number ) { version_etc ( ( _DWORD ) stdout , ( unsigned int ) String , ( unsigned int ) String , ( _DWORD ) Version , ( unsigned int ) String , Number , ( char ) @@argv@@ ) ; exit ( Number ) ; } LABEL_15 : usage ( Number ) ; }
__ino_t * __fastcall get_root_dev_ino ( __ino_t * @@a1@@ ) { struct stat @@v2@@ ; unsigned __int64 @@v3@@ ; @@v3@@ = __readfsqword ( Number ) ; if ( ( unsigned int ) lstat ( String , & @@v2@@ ) ) return Number L ; * @@a1@@ = @@v2@@ . st_ino ; @@a1@@ [ Number ] = @@v2@@ . st_dev ; return @@a1@@ ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_2060A8 ; @@v8@@ [ Number ] = qword_2060B0 ; @@v8@@ [ Number ] = qword_2060B8 ; @@v8@@ [ Number ] = qword_2060C0 ; @@v8@@ [ Number ] = qword_2060C8 ; @@v8@@ [ Number ] = qword_2060D0 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; FILE * @@v10@@ ; char * @@v11@@ ; FILE * @@v12@@ ; char * @@v13@@ ; FILE * @@v14@@ ; char * @@v15@@ ; FILE * @@v16@@ ; char * @@v17@@ ; FILE * @@v18@@ ; char * @@v19@@ ; char * @@v20@@ ; if ( @@a1@@ ) { @@v1@@ = program_name ; @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = program_name ; @@v4@@ = program_name ; @@v5@@ = gettext ( String ) ; printf ( @@v5@@ , @@v4@@ , @@v3@@ ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String String String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; @@v8@@ = stdout ; @@v9@@ = gettext ( String String ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = stdout ; @@v11@@ = gettext ( String ) ; fputs_unlocked ( @@v11@@ , @@v10@@ ) ; @@v12@@ = stdout ; @@v13@@ = gettext ( String ) ; fputs_unlocked ( @@v13@@ , @@v12@@ ) ; @@v14@@ = stdout ; @@v15@@ = gettext ( String ) ; fputs_unlocked ( @@v15@@ , @@v14@@ ) ; @@v16@@ = stdout ; @@v17@@ = gettext ( String String String String String String String String String String ) ; fputs_unlocked ( @@v17@@ , @@v16@@ ) ; @@v18@@ = stdout ; @@v19@@ = gettext ( String String ) ; fputs_unlocked ( @@v19@@ , @@v18@@ ) ; @@v20@@ = gettext ( String String String String ) ; printf ( @@v20@@ , String ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
char * __fastcall areadlinkat ( int @@a1@@ , const char * @@a2@@ ) { signed __int64 @@v3@@ ; int @@v4@@ ; char * @@buf@@ ; __int64 @@len@@ ; signed __int64 @@size@@ ; size_t @@sizea@@ ; char * @@v9@@ ; char @@src@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v11@@ = __readfsqword ( Number ) ; @@buf@@ = @@src@@ ; @@len@@ = Number L ; while ( Number ) { @@size@@ = readlinkat ( @@a1@@ , @@a2@@ , @@buf@@ , @@len@@ ) ; if ( @@size@@ < Number && * __errno_location ( ) != Number ) { if ( @@buf@@ != @@src@@ ) { @@v4@@ = * __errno_location ( ) ; free ( @@buf@@ ) ; * __errno_location ( ) = @@v4@@ ; } return Number L ; } if ( @@len@@ > ( unsigned __int64 ) @@size@@ ) break ; if ( @@buf@@ != @@src@@ ) free ( @@buf@@ ) ; @@len@@ *= Number L ; if ( @@len@@ < Number ) { * __errno_location ( ) = Number ; return Number L ; } @@buf@@ = ( char * ) malloc ( @@len@@ ) ; if ( ! @@buf@@ ) return Number L ; } @@v3@@ = @@size@@ ; @@sizea@@ = @@size@@ + Number ; @@buf@@ [ @@v3@@ ] = Number ; if ( @@buf@@ == @@src@@ ) { @@buf@@ = ( char * ) malloc ( @@sizea@@ ) ; if ( ! @@buf@@ ) return Number L ; memcpy ( @@buf@@ , @@src@@ , @@sizea@@ ) ; } else if ( @@len@@ > @@sizea@@ ) { @@v9@@ = ( char * ) realloc ( @@buf@@ , @@sizea@@ ) ; if ( @@v9@@ ) @@buf@@ = @@v9@@ ; } return @@buf@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
_BYTE * __fastcall fdsavedir ( int @@a1@@ ) { DIR * @@v1@@ ; @@v1@@ = fdopendir ( @@a1@@ ) ; return savedirstream ( @@v1@@ ) ; }
__int64 __fastcall dup_safer ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 __fastcall get_stat_ctime_ns ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
int __fastcall gl_futimens ( int @@a1@@ , char * @@a2@@ , __int64 * @@a3@@ ) { return fdutimens ( @@a2@@ , @@a1@@ , @@a3@@ ) ; }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall rpl_fcntl ( int @@a1@@ , int @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , __m128 @@a7@@ , __m128 @@a8@@ , __m128 @@a9@@ , __m128 @@a10@@ , __m128 @@a11@@ , __m128 @@a12@@ , __m128 @@a13@@ , __m128 @@a14@@ ) { int @@v14@@ ; int @@v15@@ ; int @@v16@@ ; int @@v18@@ ; int @@v19@@ ; int @@v20@@ ; int @@v21@@ ; __int64 @@v22@@ ; __int64 @@v23@@ ; __int64 @@v24@@ ; __int64 @@v25@@ ; __m128 @@v26@@ ; __m128 @@v27@@ ; __m128 @@v28@@ ; __m128 @@v29@@ ; __m128 @@v30@@ ; __m128 @@v31@@ ; __m128 @@v32@@ ; __m128 @@v33@@ ; @@v22@@ = @@a3@@ ; @@v23@@ = @@a4@@ ; @@v24@@ = @@a5@@ ; @@v25@@ = @@a6@@ ; @@v26@@ = @@a7@@ ; @@v27@@ = @@a8@@ ; @@v28@@ = @@a9@@ ; @@v29@@ = @@a10@@ ; @@v30@@ = @@a11@@ ; @@v31@@ = @@a12@@ ; @@v32@@ = @@a13@@ ; @@v33@@ = @@a14@@ ; if ( @@a2@@ != Number ) return ( unsigned int ) fcntl ( @@a1@@ , @@a2@@ , @@v22@@ ) ; @@v19@@ = @@v22@@ ; if ( have_dupfd_cloexec_2895 < Number ) { @@v18@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v22@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; } else { @@v18@@ = fcntl ( @@a1@@ , Number , ( unsigned int ) @@v22@@ ) ; if ( @@v18@@ < Number && * __errno_location ( ) == Number ) { @@v18@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v19@@ , @@v14@@ , @@v15@@ , @@v16@@ ) ; if ( @@v18@@ < Number ) return ( unsigned int ) @@v18@@ ; have_dupfd_cloexec_2895 = Number ; } else { have_dupfd_cloexec_2895 = Number ; } } if ( @@v18@@ >= Number && have_dupfd_cloexec_2895 == Number ) { @@v20@@ = fcntl ( @@v18@@ , Number ) ; if ( @@v20@@ < Number || fcntl ( @@v18@@ , Number , @@v20@@ | Number ) == Number ) { @@v21@@ = * __errno_location ( ) ; close ( @@v18@@ ) ; * __errno_location ( ) = @@v21@@ ; @@v18@@ = Number ; } } return ( unsigned int ) @@v18@@ ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
__int64 __fastcall xnrealloc ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { if ( ! is_mul_ok ( @@a3@@ , @@a2@@ ) ) xalloc_die ( ) ; return xrealloc ( @@a1@@ , @@a3@@ * @@a2@@ ) ; }
struct tm * localtime ( const time_t * @@timer@@ ) { return localtime ( @@timer@@ ) ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ ) { return xmalloc ( @@a1@@ ) ; }
_BOOL8 __fastcall c_isgraph ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
int clock_gettime ( clockid_t @@clock_id@@ , struct timespec * @@tp@@ ) { return clock_gettime ( @@clock_id@@ , @@tp@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( ) ; return @@ptr@@ ; }
_BOOL8 __fastcall c_isxdigit ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number || ( int ) ( @@a1@@ & Number ) > Number && ( int ) ( @@a1@@ & Number ) <= Number ; }
time_t time ( time_t * @@timer@@ ) { return time ( @@timer@@ ) ; }
time_t mktime ( struct tm * @@tp@@ ) { return mktime ( @@tp@@ ) ; }
bool __fastcall is_basic_2 ( unsigned __int8 @@a1@@ ) { return ( ( is_basic_table [ @@a1@@ >> Number ] >> ( @@a1@@ & Number ) ) & Number ) != Number ; }
int unsetenv ( const char * @@name@@ ) { return unsetenv ( @@name@@ ) ; }
int __fastcall lstat ( char * @@filename@@ , struct stat * @@stat_buf@@ ) { return __lxstat ( Number , @@filename@@ , @@stat_buf@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_2070A8 ; @@v4@@ [ Number ] = qword_2070B0 ; @@v4@@ [ Number ] = qword_2070B8 ; @@v4@@ [ Number ] = qword_2070C0 ; @@v4@@ [ Number ] = qword_2070C8 ; @@v4@@ [ Number ] = qword_2070D0 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_206028 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
_BOOL8 yesno ( ) { bool @@v1@@ ; char * @@lineptr@@ ; size_t @@n@@ ; __ssize_t @@v4@@ ; unsigned __int64 @@v5@@ ; @@v5@@ = __readfsqword ( Number ) ; @@lineptr@@ = Number L ; @@n@@ = Number L ; @@v4@@ = getline ( & @@lineptr@@ , & @@n@@ , stdin ) ; if ( @@v4@@ > Number ) { @@lineptr@@ [ @@v4@@ - Number ] = Number ; @@v1@@ = rpmatch ( @@lineptr@@ ) > Number ; } else { @@v1@@ = Number ; } free ( @@lineptr@@ ) ; return @@v1@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
DIR * opendir ( const char * @@name@@ ) { return opendir ( @@name@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall argmatch ( const char * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { __int64 @@result@@ ; char @@v7@@ ; __int64 @@i@@ ; __int64 @@v9@@ ; size_t @@n@@ ; @@v9@@ = Number ; @@v7@@ = Number ; @@n@@ = strlen ( @@a1@@ ) ; for ( @@i@@ = Number L ; * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; ++ @@i@@ ) { if ( ! strncmp ( * ( const char * * ) ( Number * @@i@@ + @@a2@@ ) , @@a1@@ , @@n@@ ) ) { if ( @@n@@ == strlen ( * ( const char * * ) ( Number * @@i@@ + @@a2@@ ) ) ) return @@i@@ ; if ( @@v9@@ == Number ) { @@v9@@ = @@i@@ ; } else if ( ! @@a3@@ || memcmp ( ( const void * ) ( @@a4@@ * @@v9@@ + @@a3@@ ) , ( const void * ) ( @@i@@ * @@a4@@ + @@a3@@ ) , @@a4@@ ) ) { @@v7@@ = Number ; } } } if ( @@v7@@ ) @@result@@ = Number ; else @@result@@ = @@v9@@ ; return @@result@@ ; }
_BOOL8 __fastcall batch_convert ( const char * @@a1@@ , __int64 @@a2@@ ) { const char * @@v2@@ ; int * @@v3@@ ; __int64 @@v4@@ ; char * @@v5@@ ; const char * @@v6@@ ; int * @@v7@@ ; char * @@s1@@ ; bool @@v10@@ ; char * @@lineptr@@ ; size_t @@n@@ ; FILE * @@stream@@ ; __ssize_t @@v14@@ ; __int64 @@v15@@ [ Number ] ; @@s1@@ = ( char * ) @@a1@@ ; @@v15@@ [ Number ] = __readfsqword ( Number ) ; if ( ! strcmp ( @@a1@@ , String ) ) { @@s1@@ = gettext ( String ) ; @@stream@@ = ( FILE * ) stdin ; } else { @@stream@@ = fopen ( @@a1@@ , String ) ; if ( ! @@stream@@ ) { @@v2@@ = ( const char * ) quote ( @@a1@@ ) ; @@v3@@ = __errno_location ( ) ; error ( Number , * @@v3@@ , String , @@v2@@ ) ; } } @@lineptr@@ = Number L ; @@n@@ = Number L ; @@v10@@ = Number ; while ( Number ) { @@v14@@ = getline ( & @@lineptr@@ , & @@n@@ , @@stream@@ ) ; if ( @@v14@@ < Number ) break ; if ( ( unsigned __int8 ) get_date ( @@v15@@ , @@lineptr@@ , Number L ) != Number ) { if ( @@lineptr@@ [ @@v14@@ - Number ] == Number ) @@lineptr@@ [ @@v14@@ - Number ] = Number ; @@v4@@ = quote ( @@lineptr@@ ) ; @@v5@@ = gettext ( String ) ; error ( Number , Number , @@v5@@ , @@v4@@ ) ; @@v10@@ = Number ; } else { @@v10@@ = ( @@v10@@ & ( unsigned __int8 ) show_date ( @@a2@@ , @@v15@@ [ Number ] , @@v15@@ [ Number ] ) ) != Number ; } } if ( fclose ( @@stream@@ ) == Number ) { @@v6@@ = ( const char * ) quote ( @@s1@@ ) ; @@v7@@ = __errno_location ( ) ; error ( Number , * @@v7@@ , String , @@v6@@ ) ; } free ( @@lineptr@@ ) ; return @@v10@@ ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( is_mul_ok ( @@a2@@ , * @@a1@@ ) ) { * @@a1@@ *= @@a2@@ ; @@result@@ = Number L ; } else { * @@a1@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
__int64 __fastcall set_cloexec_flag ( int @@a1@@ , char @@a2@@ , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { int @@v6@@ ; int @@v7@@ ; int @@v8@@ ; unsigned int @@v9@@ ; __int64 @@result@@ ; int @@v11@@ ; @@v11@@ = rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( @@v11@@ < Number || ( ! @@a2@@ ? ( @@v9@@ = @@v11@@ & Number ) : ( @@v9@@ = @@v11@@ | Number ) , @@v11@@ != @@v9@@ && ( unsigned int ) rpl_fcntl ( @@a1@@ , Number , @@v9@@ , @@v6@@ , @@v7@@ , @@v8@@ ) == Number ) ) { @@result@@ = Number ; } else { @@result@@ = Number L ; } return @@result@@ ; }
_BOOL8 __fastcall c_isblank ( int @@a1@@ ) { return @@a1@@ == Number || @@a1@@ == Number ; }
int dirfd ( DIR * @@dirp@@ ) { return dirfd ( @@dirp@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
_BOOL8 __fastcall c_isgraph ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
int __xstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _xstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
_BOOL8 __fastcall c_isxdigit ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number || ( int ) ( @@a1@@ & Number ) > Number && ( int ) ( @@a1@@ & Number ) <= Number ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
int __freading ( FILE * @@fp@@ ) { return _freading ( @@fp@@ ) ; }
__int64 __fastcall fd_safer ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { unsigned int @@fd@@ ; unsigned int @@v8@@ ; int @@v9@@ ; @@fd@@ = @@a1@@ ; if ( @@a1@@ >= Number && @@a1@@ <= Number ) { @@v8@@ = dup_safer ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; @@v9@@ = * __errno_location ( ) ; close ( @@a1@@ ) ; * __errno_location ( ) = @@v9@@ ; @@fd@@ = @@v8@@ ; } return @@fd@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
int __fastcall fstatat ( int @@fildes@@ , char * @@filename@@ , struct stat * @@stat_buf@@ , int @@flag@@ ) { return __fxstatat ( Number , @@fildes@@ , @@filename@@ , @@stat_buf@@ , @@flag@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 __fastcall fprintftime ( FILE * @@a1@@ , char * @@a2@@ , __int64 @@a3@@ , unsigned int @@a4@@ , unsigned int @@a5@@ ) { return strftime_case_ ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
int fileno ( FILE * @@stream@@ ) { return fileno ( @@stream@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
__int64 __fastcall movefile ( __int64 @@a1@@ , __int64 @@a2@@ , char @@a3@@ , __int64 @@a4@@ ) { unsigned __int8 @@v7@@ ; __int64 @@v8@@ ; void * @@ptr@@ ; if ( remove_trailing_slashes ) strip_trailing_slashes ( @@a1@@ ) ; if ( ! @@a3@@ ) return ( unsigned __int8 ) do_move ( @@a1@@ , @@a2@@ , @@a4@@ ) ; @@v8@@ = last_component ( @@a1@@ ) ; @@ptr@@ = ( void * ) file_name_concat ( @@a2@@ , @@v8@@ , Number L ) ; strip_trailing_slashes ( @@ptr@@ ) ; @@v7@@ = do_move ( @@a1@@ , ( __int64 ) @@ptr@@ , @@a4@@ ) ; free ( @@ptr@@ ) ; return @@v7@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
__int64 __fastcall select_plural ( __int64 @@a1@@ ) { return @@a1@@ ; }
int tolower ( int @@c@@ ) { return tolower ( @@c@@ ) ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
__int64 __fastcall cache_fstatat ( int @@a1@@ , char * @@a2@@ , struct stat * @@a3@@ , int @@a4@@ ) { __ino_t @@v5@@ ; if ( @@a3@@ -> st_size == Number && ( unsigned int ) fstatat ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ) { @@a3@@ -> st_size = Number ; @@a3@@ -> st_ino = * __errno_location ( ) ; } if ( @@a3@@ -> st_size >= Number ) return Number L ; @@v5@@ = @@a3@@ -> st_ino ; * __errno_location ( ) = @@v5@@ ; return Number ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
__int64 __fastcall get_stat_mtime ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
__int64 __fastcall bsd_split_3 ( __int64 @@a1@@ , __int64 @@a2@@ , _QWORD * @@a3@@ , _QWORD * @@a4@@ ) { __int64 @@v5@@ ; __int64 @@i@@ ; __int64 @@v7@@ ; __int64 @@j@@ ; if ( ! @@a2@@ ) return Number L ; * @@a4@@ = @@a1@@ ; for ( @@i@@ = @@a2@@ - Number ; @@i@@ && * ( _BYTE * ) ( @@a1@@ + @@i@@ ) != Number ; -- @@i@@ ) { ; } if ( * ( _BYTE * ) ( @@a1@@ + @@i@@ ) != Number ) return Number L ; @@v5@@ = @@i@@ ; @@v7@@ = @@i@@ + Number ; * ( _BYTE * ) ( @@a1@@ + @@v5@@ ) = Number ; while ( * ( _BYTE * ) ( @@a1@@ + @@v7@@ ) == Number || * ( _BYTE * ) ( @@a1@@ + @@v7@@ ) == Number ) ++ @@v7@@ ; if ( * ( _BYTE * ) ( @@a1@@ + @@v7@@ ) != Number ) return Number L ; for ( @@j@@ = @@v7@@ + Number ; * ( _BYTE * ) ( @@a1@@ + @@j@@ ) == Number || * ( _BYTE * ) ( @@a1@@ + @@j@@ ) == Number ; ++ @@j@@ ) { ; } * @@a3@@ = @@j@@ + @@a1@@ ; return Number L ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
__int64 __fastcall apply_relative_time ( __int64 @@a1@@ , int @@a2@@ , __int64 a3 , __int64 a4 , __int64 a5 , __int64 a6 , __int64 @@a7@@ , __int64 @@a8@@ , __int64 @@a9@@ , __int64 @@a10@@ , __int64 @@a11@@ , __int64 @@a12@@ , __int64 @@a13@@ ) { __int64 @@result@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) += @@a2@@ * @@a13@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) += @@a2@@ * @@a12@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) += @@a2@@ * @@a11@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) += @@a2@@ * @@a10@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) += @@a2@@ * @@a9@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) += @@a2@@ * @@a8@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) += @@a2@@ * @@a7@@ ; @@result@@ = @@a1@@ ; * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; return @@result@@ ; }
__int64 __fastcall excise ( __int64 @@a1@@ , __int64 @@a2@@ , _BYTE * @@a3@@ , char @@a4@@ ) { int @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@result@@ ; int * @@v8@@ ; __int64 @@v9@@ ; char * @@v10@@ ; int * @@v11@@ ; struct stat @@v14@@ ; unsigned __int64 @@v15@@ ; @@v15@@ = __readfsqword ( Number ) ; if ( @@a4@@ ) @@v4@@ = Number ; else @@v4@@ = Number ; if ( unlinkat ( * ( _DWORD * ) ( @@a1@@ + Number ) , * ( const char * * ) ( @@a2@@ + Number ) , @@v4@@ ) ) { if ( * __errno_location ( ) == Number && ( ! ( unsigned int ) lstatat ( * ( _DWORD * ) ( @@a1@@ + Number ) , * ( char * * ) ( @@a2@@ + Number ) , & @@v14@@ ) || * __errno_location ( ) != Number ) ) { * __errno_location ( ) = Number ; } @@v8@@ = __errno_location ( ) ; if ( ignorable_missing ( @@a3@@ , * @@v8@@ ) ) { @@result@@ = Number L ; } else { if ( * ( _WORD * ) ( @@a2@@ + Number ) == Number ) * __errno_location ( ) = * ( _DWORD * ) ( @@a2@@ + Number ) ; @@v9@@ = quote ( * ( _QWORD * ) ( @@a2@@ + Number ) ) ; @@v10@@ = gettext ( String ) ; @@v11@@ = __errno_location ( ) ; error ( Number , * @@v11@@ , @@v10@@ , @@v9@@ ) ; mark_ancestor_dirs ( @@a2@@ ) ; @@result@@ = Number L ; } } else { if ( @@a3@@ [ Number ] ) { @@v5@@ = quote ( * ( _QWORD * ) ( @@a2@@ + Number ) ) ; if ( @@a4@@ ) @@v6@@ = gettext ( String ) ; else @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@result@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
bool __fastcall mktime_ok ( _DWORD * @@a1@@ , struct tm * @@a2@@ , time_t @@a3@@ ) { bool @@result@@ ; time_t @@timer@@ ; struct tm * @@v5@@ ; _DWORD * @@v6@@ ; @@v6@@ = @@a1@@ ; @@v5@@ = @@a2@@ ; @@timer@@ = @@a3@@ ; if ( @@a3@@ != Number || ( @@v5@@ = localtime ( & @@timer@@ ) ) != Number L ) @@result@@ = ( @@v6@@ [ Number ] ^ @@v5@@ -> tm_mon | @@v6@@ [ Number ] ^ @@v5@@ -> tm_mday | @@v6@@ [ Number ] ^ @@v5@@ -> tm_hour | @@v6@@ [ Number ] ^ @@v5@@ -> tm_min | @@v5@@ -> tm_sec ^ * @@v6@@ | @@v6@@ [ Number ] ^ @@v5@@ -> tm_year ) == Number ; else @@result@@ = Number ; return @@result@@ ; }
int __fastcall clone_file ( int @@a1@@ , unsigned int @@a2@@ ) { return ioctl ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
int __fastcall fchmod_or_lchmod ( int @@a1@@ , const char * @@a2@@ , __mode_t @@a3@@ ) { int @@result@@ ; if ( @@a1@@ < Number ) @@result@@ = chmod ( @@a2@@ , @@a3@@ ) ; else @@result@@ = fchmod ( @@a1@@ , @@a3@@ ) ; return @@result@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
int __fastcall argmatch_valid ( __int64 @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { char * @@v3@@ ; __int64 @@i@@ ; void * @@s1@@ ; @@s1@@ = Number L ; @@v3@@ = gettext ( String ) ; fprintf ( stderr , @@v3@@ ) ; for ( @@i@@ = Number L ; * ( _QWORD * ) ( Number * @@i@@ + @@a1@@ ) ; ++ @@i@@ ) { if ( @@i@@ && ! memcmp ( @@s1@@ , ( const void * ) ( @@i@@ * @@a3@@ + @@a2@@ ) , @@a3@@ ) ) { fprintf ( stderr , String , * ( const char * * ) ( Number * @@i@@ + @@a1@@ ) ) ; } else { fprintf ( stderr , String , * ( const char * * ) ( Number * @@i@@ + @@a1@@ ) ) ; @@s1@@ = ( void * ) ( @@i@@ * @@a3@@ + @@a2@@ ) ; } } return putc_unlocked ( Number , stderr ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
__int64 __fastcall xnrealloc ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { if ( ! is_mul_ok ( @@a3@@ , @@a2@@ ) ) xalloc_die ( ) ; return xrealloc ( @@a1@@ , @@a3@@ * @@a2@@ ) ; }
_BOOL8 __fastcall writable_destination ( const char * @@a1@@ , __int16 @@a2@@ ) { return ( @@a2@@ & Number ) == Number || ( unsigned __int8 ) can_write_any_file ( ) || ! euidaccess ( @@a1@@ , Number ) ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
void * __fastcall xzalloc ( size_t @@a1@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@a1@@ ) ; return memset ( @@v1@@ , Number , @@a1@@ ) ; }
int __fastcall emit_verbose ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { const char * @@v3@@ ; const char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; @@v3@@ = ( const char * ) quote_n ( Number L , @@a2@@ ) ; @@v4@@ = ( const char * ) quote_n ( Number L , @@a1@@ ) ; printf ( String , @@v4@@ , @@v3@@ ) ; if ( @@a3@@ ) { @@v5@@ = quote ( @@a3@@ ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } return putchar_unlocked ( Number ) ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
_BOOL8 __fastcall c_isdigit ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
unsigned __int64 __fastcall src_to_dest_hash ( _QWORD * @@a1@@ , unsigned __int64 @@a2@@ ) { return * @@a1@@ % @@a2@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
_BOOL8 __fastcall c_ispunct ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number && ( @@a1@@ <= Number || @@a1@@ > Number ) && ( ( int ) ( @@a1@@ & Number ) <= Number || ( int ) ( @@a1@@ & Number ) > Number ) ; }
_BOOL8 __fastcall src_to_dest_compare ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { return * @@a1@@ == * @@a2@@ && @@a1@@ [ Number ] == @@a2@@ [ Number ] ; }
_BOOL8 __fastcall c_isspace ( int @@a1@@ ) { return @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
void __fastcall record_file ( __int64 @@a1@@ , __int64 @@a2@@ , _QWORD * @@a3@@ ) { _QWORD * @@v4@@ ; __int64 @@v5@@ ; if ( @@a1@@ ) { @@v4@@ = ( _QWORD * ) xmalloc ( Number L ) ; * @@v4@@ = xstrdup ( @@a2@@ ) ; @@v4@@ [ Number ] = @@a3@@ [ Number ] ; @@v4@@ [ Number ] = * @@a3@@ ; @@v5@@ = hash_insert ( @@a1@@ , @@v4@@ ) ; if ( ! @@v5@@ ) xalloc_die ( ) ; if ( ( _QWORD * ) @@v5@@ != @@v4@@ ) triple_free ( @@v4@@ ) ; } }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
unsigned __int64 __fastcall triple_hash_no_name ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) % @@a2@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_213038 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return xmalloc ( @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
__int64 __fastcall sha256_conclude_ctx ( __int64 @@a1@@ ) { __int64 @@v1@@ ; unsigned __int64 @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( @@v3@@ > Number ) @@v1@@ = Number L ; else @@v1@@ = Number L ; @@v4@@ = @@v1@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) += @@v3@@ ; if ( @@v3@@ > * ( unsigned int * ) ( @@a1@@ + Number ) ) ++ * ( _DWORD * ) ( @@a1@@ + Number ) ; set_uint32 ( ( _DWORD * ) ( Number * ( @@v1@@ - Number + Number ) + @@a1@@ ) , ( ( unsigned int ) ( * ( __int64 * ) ( @@a1@@ + Number ) >> Number ) >> Number ) | ( ( unsigned int ) ( * ( __int64 * ) ( @@a1@@ + Number ) >> Number ) >> Number ) & Number | ( ( unsigned int ) ( * ( __int64 * ) ( @@a1@@ + Number ) >> Number ) << Number ) & Number | ( ( unsigned int ) ( * ( __int64 * ) ( @@a1@@ + Number ) >> Number ) << Number ) ) ; set_uint32 ( ( _DWORD * ) ( Number * ( @@v4@@ - Number + Number ) + @@a1@@ ) , ( ( unsigned int ) ( Number * * ( _DWORD * ) ( @@a1@@ + Number ) ) >> Number ) | ( ( unsigned int ) ( Number * * ( _DWORD * ) ( @@a1@@ + Number ) ) >> Number ) & Number | ( * ( _DWORD * ) ( @@a1@@ + Number ) << Number ) & Number | ( * ( _DWORD * ) ( @@a1@@ + Number ) << Number ) ) ; memcpy ( ( void * ) ( @@a1@@ + Number + @@v3@@ ) , & fillbuf , Number * @@v4@@ - @@v3@@ - Number ) ; return sha256_process_block ( @@a1@@ + Number , Number * @@v4@@ , @@a1@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 __fastcall get_version ( __int64 @@a1@@ , _BYTE * @@a2@@ ) { __int64 @@result@@ ; if ( @@a2@@ && * @@a2@@ ) @@result@@ = backup_types [ _xargmatch_internal ( @@a1@@ , @@a2@@ , backup_args , backup_types , Number L , argmatch_die ) ] ; else @@result@@ = Number L ; return @@result@@ ; }
__int64 __fastcall xnmalloc ( unsigned __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { if ( ! is_mul_ok ( @@a2@@ , @@a1@@ ) ) xalloc_die ( ) ; return xmalloc ( @@a2@@ * @@a1@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
__int64 __fastcall bkm_scale_by_power ( unsigned __int64 * @@a1@@ , int @@a2@@ , int @@a3@@ ) { unsigned int @@i@@ ; for ( @@i@@ = Number ; @@a3@@ -- ; @@i@@ |= bkm_scale ( @@a1@@ , @@a2@@ ) ) { ; } return @@i@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( ) ; return @@ptr@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
_BOOL8 __fastcall c_iscntrl ( int @@a1@@ ) { return ( @@a1@@ & Number ) == Number || @@a1@@ == Number ; }
_BOOL8 __fastcall c_isascii ( int @@a1@@ ) { return @@a1@@ >= Number && @@a1@@ <= Number ; }
_BYTE * __fastcall dir_len ( _BYTE * @@a1@@ ) { _BYTE * @@i@@ ; unsigned __int64 @@v3@@ ; @@v3@@ = * @@a1@@ == Number ; for ( @@i@@ = ( _BYTE * ) ( last_component ( @@a1@@ ) - @@a1@@ ) ; @@v3@@ < ( unsigned __int64 ) @@i@@ && @@a1@@ [ ( _QWORD ) ( @@i@@ - Number ) ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
_BOOL8 __fastcall c_isalnum ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number || ( int ) ( @@a1@@ & Number ) > Number && ( int ) ( @@a1@@ & Number ) <= Number ; }
__int64 __fastcall c_tolower ( int @@a1@@ ) { __int64 @@result@@ ; if ( @@a1@@ <= Number || @@a1@@ > Number ) @@result@@ = ( unsigned int ) @@a1@@ ; else @@result@@ = ( unsigned int ) ( @@a1@@ + Number ) ; return @@result@@ ; }
__int64 __fastcall ftypelet ( __int16 @@a1@@ ) { switch ( @@a1@@ & Number ) { case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; } return Number L ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 __fastcall c_toupper ( int @@a1@@ ) { __int64 @@result@@ ; if ( @@a1@@ <= Number || @@a1@@ > Number ) @@result@@ = ( unsigned int ) @@a1@@ ; else @@result@@ = ( unsigned int ) ( @@a1@@ - Number ) ; return @@result@@ ; }
int putchar_unlocked ( int @@c@@ ) { return putchar_unlocked ( @@c@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 __fastcall file_name_concat ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v4@@ ; @@v4@@ = mfile_name_concat ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( ! @@v4@@ ) xalloc_die ( ) ; return @@v4@@ ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
int __fastcall rpl_fseeko ( FILE * @@a1@@ , __off_t @@a2@@ , int @@a3@@ ) { __off_t @@v3@@ ; int @@v4@@ ; int @@result@@ ; if ( @@a1@@ -> _IO_read_end != @@a1@@ -> _IO_read_ptr || @@a1@@ -> _IO_write_ptr != @@a1@@ -> _IO_write_base || @@a1@@ -> _IO_save_base ) { goto LABEL_13 ; } if ( @@a3@@ == Number && @@a2@@ > Number ) @@v3@@ = Number L ; else @@v3@@ = @@a2@@ ; @@v4@@ = fileno ( @@a1@@ ) ; if ( lseek ( @@v4@@ , @@v3@@ , @@a3@@ ) == Number ) return Number ; @@a1@@ -> _flags &= Number ; if ( @@a3@@ == Number && @@a2@@ > Number ) LABEL_13 : @@result@@ = fseeko ( @@a1@@ , @@a2@@ , @@a3@@ ) ; else @@result@@ = Number ; return @@result@@ ; }
__int64 __fastcall bad_cast ( __int64 @@a1@@ ) { return @@a1@@ ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; char * @@v3@@ ; FILE * @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; FILE * @@v10@@ ; char * @@v11@@ ; @@v1@@ = program_name ; if ( @@a1@@ ) { @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = gettext ( String ) ; printf ( @@v3@@ , @@v1@@ ) ; @@v4@@ = stdout ; @@v5@@ = gettext ( String String String String ) ; fputs_unlocked ( @@v5@@ , @@v4@@ ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; @@v8@@ = stdout ; @@v9@@ = gettext ( String ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = stdout ; @@v11@@ = gettext ( String ) ; fputs_unlocked ( @@v11@@ , @@v10@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
__int64 __fastcall enter_dir ( __int64 @@a1@@ , __int64 @@a2@@ ) { _QWORD * @@ptr@@ ; __int64 @@v4@@ ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { @@ptr@@ = malloc ( Number ) ; if ( ! @@ptr@@ ) return Number L ; * @@ptr@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@ptr@@ [ Number ] = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@ptr@@ [ Number ] = @@a2@@ ; @@v4@@ = hash_insert ( * ( _QWORD * ) ( @@a1@@ + Number ) , @@ptr@@ ) ; if ( ( _QWORD * ) @@v4@@ != @@ptr@@ ) { free ( @@ptr@@ ) ; if ( ! @@v4@@ ) return Number L ; * ( _QWORD * ) @@a2@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; * ( _WORD * ) ( @@a2@@ + Number ) = Number ; } } else if ( ( unsigned __int8 ) cycle_check ( * ( _QWORD * ) ( @@a1@@ + Number ) , @@a2@@ + Number ) ) { * ( _QWORD * ) @@a2@@ = @@a2@@ ; * ( _WORD * ) ( @@a2@@ + Number ) = Number ; } return Number L ; }
__int64 __fastcall digest_file ( const char * @@a1@@ , __int64 a2 , __int64 @@a3@@ ) { int @@v3@@ ; int @@v4@@ ; int * @@v5@@ ; int * @@v7@@ ; bool @@v9@@ ; FILE * @@stream@@ ; @@v3@@ = strcmp ( @@a1@@ , String ) ; @@v9@@ = @@v3@@ == Number ; if ( @@v3@@ ) { @@stream@@ = ( FILE * ) fopen_safer ( @@a1@@ , String ) ; if ( ! @@stream@@ ) goto LABEL_4 ; @@v4@@ = sha256_stream ( @@stream@@ , @@a3@@ ) ; } else { have_read_stdin = Number ; @@stream@@ = stdin ; @@v4@@ = sha256_stream ( stdin , @@a3@@ ) ; } if ( ! @@v4@@ ) { if ( @@v9@@ || ! fclose ( @@stream@@ ) ) return Number L ; LABEL_4 : @@v5@@ = __errno_location ( ) ; error ( Number , * @@v5@@ , String , @@a1@@ ) ; return Number L ; } @@v7@@ = __errno_location ( ) ; error ( Number , * @@v7@@ , String , @@a1@@ ) ; if ( @@stream@@ != stdin ) fclose ( @@stream@@ ) ; return Number L ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall fts_close ( __int64 @@a1@@ ) { _QWORD * @@v1@@ ; void * @@v2@@ ; _QWORD * @@v3@@ ; int @@v5@@ ; @@v5@@ = Number ; if ( * ( _QWORD * ) @@a1@@ ) { @@v1@@ = * ( _QWORD * * ) @@a1@@ ; while ( ( __int64 ) @@v1@@ [ Number ] >= Number ) { @@v2@@ = @@v1@@ ; if ( @@v1@@ [ Number ] ) @@v3@@ = ( _QWORD * ) @@v1@@ [ Number ] ; else @@v3@@ = ( _QWORD * ) @@v1@@ [ Number ] ; @@v1@@ = @@v3@@ ; free ( @@v2@@ ) ; } free ( @@v1@@ ) ; } if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) fts_lfree ( * ( void * * ) ( @@a1@@ + Number ) ) ; free ( * ( void * * ) ( @@a1@@ + Number ) ) ; free ( * ( void * * ) ( @@a1@@ + Number ) ) ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { if ( * ( int * ) ( @@a1@@ + Number ) >= Number && close ( * ( _DWORD * ) ( @@a1@@ + Number ) ) ) { LABEL_20 : @@v5@@ = * __errno_location ( ) ; goto LABEL_21 ; } } else if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) == Number ) { if ( fchdir ( * ( _DWORD * ) ( @@a1@@ + Number ) ) ) @@v5@@ = * __errno_location ( ) ; if ( close ( * ( _DWORD * ) ( @@a1@@ + Number ) ) && ! @@v5@@ ) goto LABEL_20 ; } LABEL_21 : fd_ring_clear ( @@a1@@ + Number ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) hash_free ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ; free_dir ( @@a1@@ ) ; free ( ( void * ) @@a1@@ ) ; if ( ! @@v5@@ ) return Number L ; * __errno_location ( ) = @@v5@@ ; return Number ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_2070A8 ; @@v4@@ [ Number ] = qword_2070B0 ; @@v4@@ [ Number ] = qword_2070B8 ; @@v4@@ [ Number ] = qword_2070C0 ; @@v4@@ [ Number ] = qword_2070C8 ; @@v4@@ [ Number ] = qword_2070D0 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , off_A8A2 , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return xmalloc ( @@a1@@ , @@a2@@ , @@a3@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
__int64 __fastcall fts_stat ( __int64 @@a1@@ , __int64 @@a2@@ , char @@a3@@ ) { __int64 @@result@@ ; __int64 @@v4@@ ; int @@v6@@ ; struct stat * @@s@@ ; @@s@@ = ( struct stat * ) ( @@a2@@ + Number ) ; if ( ! * ( _QWORD * ) ( @@a2@@ + Number ) && ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) @@a3@@ = Number ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number || @@a3@@ ) { if ( ( unsigned int ) stat ( * ( char * * ) ( @@a2@@ + Number ) , @@s@@ ) ) { @@v6@@ = * __errno_location ( ) ; if ( * __errno_location ( ) == Number && ! ( unsigned int ) lstat ( * ( char * * ) ( @@a2@@ + Number ) , @@s@@ ) ) { * __errno_location ( ) = Number ; return Number L ; } * ( _DWORD * ) ( @@a2@@ + Number ) = @@v6@@ ; goto LABEL_13 ; } } else if ( ( unsigned int ) fstatat ( * ( _DWORD * ) ( @@a1@@ + Number ) , * ( char * * ) ( @@a2@@ + Number ) , @@s@@ , Number ) ) { * ( _DWORD * ) ( @@a2@@ + Number ) = * __errno_location ( ) ; LABEL_13 : memset ( @@s@@ , Number , sizeof ( struct stat ) ) ; return Number L ; } switch ( * ( _DWORD * ) ( @@a2@@ + Number ) & Number ) { case Number : if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) @@v4@@ = Number L ; else @@v4@@ = Number L ; * ( _QWORD * ) ( @@a2@@ + Number ) = * ( _QWORD * ) ( @@a2@@ + Number ) - @@v4@@ ; if ( * ( _BYTE * ) ( @@a2@@ + Number ) != Number || * ( _BYTE * ) ( @@a2@@ + Number ) && ( * ( _BYTE * ) ( @@a2@@ + Number ) != Number || * ( _BYTE * ) ( @@a2@@ + Number ) ) ) { @@result@@ = Number L ; } else if ( * ( _QWORD * ) ( @@a2@@ + Number ) ) { @@result@@ = Number L ; } else { @@result@@ = Number L ; } break ; case Number : @@result@@ = Number L ; break ; case Number : @@result@@ = Number L ; break ; default : @@result@@ = Number L ; break ; } return @@result@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_20D028 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_2060A8 ; @@v4@@ [ Number ] = qword_2060B0 ; @@v4@@ [ Number ] = qword_2060B8 ; @@v4@@ [ Number ] = qword_2060C0 ; @@v4@@ [ Number ] = qword_2060C8 ; @@v4@@ [ Number ] = qword_2060D0 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
__int64 __fastcall fts_safe_changedir ( __int64 @@a1@@ , __int64 @@a2@@ , int @@a3@@ , const char * @@a4@@ , int @@a5@@ , int @@a6@@ ) { bool @@v6@@ ; char * @@s1@@ ; char @@v10@@ ; unsigned int @@v11@@ ; int @@fildes@@ ; int @@v13@@ ; int @@v14@@ ; struct stat @@v15@@ ; unsigned __int64 @@v16@@ ; @@s1@@ = ( char * ) @@a4@@ ; @@v16@@ = __readfsqword ( Number ) ; @@v6@@ = @@a4@@ && ! strcmp ( @@a4@@ , off_16953 ) ; @@v10@@ = @@v6@@ ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number && @@a3@@ >= Number ) close ( @@a3@@ ) ; return Number L ; } if ( @@a3@@ < Number ) { if ( @@v10@@ ) { if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number && ( unsigned __int8 ) i_ring_empty ( @@a1@@ + Number ) != Number ) { @@v13@@ = i_ring_pop ( @@a1@@ + Number ) ; @@v10@@ = Number ; if ( @@v13@@ >= Number ) { @@a3@@ = @@v13@@ ; @@s1@@ = Number L ; } } } } @@fildes@@ = @@a3@@ ; if ( @@a3@@ < Number ) { @@fildes@@ = diropen ( @@a1@@ , ( int ) @@s1@@ , ( __int64 ) @@s1@@ , ( int ) @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( @@fildes@@ < Number ) return Number ; } if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) == Number && ( ! @@s1@@ || strcmp ( @@s1@@ , off_16953 ) ) ) goto LABEL_27 ; if ( ! ( unsigned int ) fstat ( @@fildes@@ , & @@v15@@ ) ) { if ( * ( _QWORD * ) ( @@a2@@ + Number ) != @@v15@@ . st_dev || * ( _QWORD * ) ( @@a2@@ + Number ) != @@v15@@ . st_ino ) { * __errno_location ( ) = Number ; @@v11@@ = Number ; goto LABEL_30 ; } LABEL_27 : if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { cwd_advance_fd ( @@a1@@ , @@fildes@@ , @@v10@@ == Number ) ; return Number L ; } @@v11@@ = fchdir ( @@fildes@@ ) ; goto LABEL_30 ; } @@v11@@ = Number ; LABEL_30 : if ( @@a3@@ < Number ) { @@v14@@ = * __errno_location ( ) ; close ( @@fildes@@ ) ; * __errno_location ( ) = @@v14@@ ; } return @@v11@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return xmalloc ( @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
__int64 __fastcall sha256_read_ctx ( __int64 @@a1@@ , __int64 @@a2@@ ) { int @@i@@ ; for ( @@i@@ = Number ; @@i@@ <= Number ; ++ @@i@@ ) set_uint32 ( ( _DWORD * ) ( Number L * @@i@@ + @@a2@@ ) , HIBYTE ( * ( _DWORD * ) ( @@a1@@ + Number L * @@i@@ ) ) | ( * ( _DWORD * ) ( @@a1@@ + Number L * @@i@@ ) >> Number ) & Number | ( * ( _DWORD * ) ( @@a1@@ + Number L * @@i@@ ) << Number ) & Number | ( * ( _DWORD * ) ( @@a1@@ + Number L * @@i@@ ) << Number ) ) ; return @@a2@@ ; }
int fgetc ( FILE * @@stream@@ ) { return fgetc ( @@stream@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
int putchar_unlocked ( int @@c@@ ) { return putchar_unlocked ( @@c@@ ) ; }
int iswspace ( wint_t @@wc@@ ) { return iswspace ( @@wc@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 __fastcall hash_lookup ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; _QWORD * @@i@@ ; _QWORD * @@v5@@ ; @@v2@@ = * @@a1@@ ; @@v5@@ = ( _QWORD * ) ( @@v2@@ + Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) ) ; if ( ( unsigned __int64 ) @@v5@@ >= @@a1@@ [ Number ] ) abort ( ) ; if ( ! * @@v5@@ ) return Number L ; for ( @@i@@ = @@v5@@ ; @@i@@ ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { if ( @@a2@@ == * @@i@@ || ( ( unsigned __int8 ( __fastcall * ) ( __int64 , _QWORD ) ) @@a1@@ [ Number ] ) ( @@a2@@ , * @@i@@ ) ) { return * @@i@@ ; } } return Number L ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
__int64 __fastcall sha224_stream ( FILE * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v3@@ ; char * @@ptr@@ ; size_t @@v5@@ ; char @@v6@@ [ Number ] ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@ptr@@ = ( char * ) malloc ( Number ) ; if ( ! @@ptr@@ ) return Number L ; sha224_init_ctx ( ( __int64 ) @@v6@@ ) ; LABEL_4 : @@v3@@ = Number L ; while ( Number ) { @@v5@@ = fread_unlocked ( & @@ptr@@ [ @@v3@@ ] , Number , Number - @@v3@@ , @@a1@@ ) ; @@v3@@ += @@v5@@ ; if ( @@v3@@ == Number ) { sha256_process_block ( @@ptr@@ , Number , @@v6@@ ) ; goto LABEL_4 ; } if ( ! @@v5@@ ) break ; if ( feof_unlocked ( @@a1@@ ) ) goto LABEL_12 ; } if ( ferror_unlocked ( @@a1@@ ) ) { free ( @@ptr@@ ) ; return Number L ; } LABEL_12 : if ( @@v3@@ ) sha256_process_bytes ( @@ptr@@ , @@v3@@ , @@v6@@ ) ; sha224_finish_ctx ( ( __int64 ) @@v6@@ , @@a2@@ ) ; free ( @@ptr@@ ) ; return Number L ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
unsigned __int64 __fastcall hash_string ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ ) { unsigned __int64 @@v4@@ ; @@v4@@ = Number L ; while ( * @@a1@@ ) @@v4@@ = ( Number * @@v4@@ + ( unsigned __int8 ) * @@a1@@ ++ ) % @@a2@@ ; return @@v4@@ ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return xmalloc ( @@a1@@ , @@a2@@ , @@a3@@ ) ; }
int putenv ( char * @@string@@ ) { return putenv ( @@string@@ ) ; }
__int64 __fastcall next_prime ( unsigned __int64 @@a1@@ ) { __int64 @@v2@@ ; __int64 @@i@@ ; @@v2@@ = @@a1@@ ; if ( @@a1@@ <= Number ) @@v2@@ = Number L ; for ( @@i@@ = @@v2@@ | Number ; @@i@@ != Number && ! is_prime ( @@i@@ ) ; @@i@@ += Number L ) { ; } return @@i@@ ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
__int64 __fastcall compute_number_width ( int @@a1@@ , int * @@a2@@ ) { int @@v3@@ ; int @@v4@@ ; int @@i@@ ; unsigned __int64 @@v6@@ ; @@v3@@ = Number ; if ( @@a1@@ > Number && * @@a2@@ <= Number ) { @@v4@@ = Number ; @@v6@@ = Number L ; for ( @@i@@ = Number ; @@i@@ < @@a1@@ ; ++ @@i@@ ) { if ( ! @@a2@@ [ Number * @@i@@ ] ) { if ( ( @@a2@@ [ Number * @@i@@ + Number ] & Number ) == Number ) @@v6@@ += * ( _QWORD * ) & @@a2@@ [ Number * @@i@@ + Number ] ; else @@v4@@ = Number ; } } while ( @@v6@@ > Number ) { ++ @@v3@@ ; @@v6@@ /= Number ; } if ( @@v3@@ < @@v4@@ ) @@v3@@ = @@v4@@ ; } return ( unsigned int ) @@v3@@ ; }
size_t * __fastcall hash_initialize ( __int64 @@a1@@ , void * @@a2@@ , unsigned __int64 ( __fastcall * @@a3@@ ) ( __int64 a1 , unsigned __int64 a2 ) , bool ( __fastcall * @@a4@@ ) ( __int64 a1 , __int64 a2 ) , size_t @@a5@@ ) { size_t * @@result@@ ; bool ( __fastcall * @@v7@@ ) ( __int64 , __int64 ) ; unsigned __int64 ( __fastcall * @@v8@@ ) ( __int64 , unsigned __int64 ) ; void * @@v9@@ ; size_t * @@ptr@@ ; @@v9@@ = @@a2@@ ; @@v8@@ = @@a3@@ ; @@v7@@ = @@a4@@ ; if ( ! @@a3@@ ) @@v8@@ = raw_hasher ; if ( ! @@a4@@ ) @@v7@@ = raw_comparator ; @@ptr@@ = ( size_t * ) malloc ( Number ) ; if ( ! @@ptr@@ ) return Number L ; if ( ! @@a2@@ ) @@v9@@ = & default_tuning ; @@ptr@@ [ Number ] = ( size_t ) @@v9@@ ; if ( ( unsigned __int8 ) check_tuning ( ( __int64 ) @@ptr@@ ) == Number && ( @@ptr@@ [ Number ] = compute_bucket_size ( @@a1@@ , ( __int64 ) @@v9@@ ) ) != Number && ( * @@ptr@@ = ( size_t ) calloc ( @@ptr@@ [ Number ] , Number ) ) != Number ) { @@ptr@@ [ Number ] = Number * @@ptr@@ [ Number ] + * @@ptr@@ ; @@ptr@@ [ Number ] = Number L ; @@ptr@@ [ Number ] = Number L ; @@ptr@@ [ Number ] = ( size_t ) @@v8@@ ; @@ptr@@ [ Number ] = ( size_t ) @@v7@@ ; @@ptr@@ [ Number ] = @@a5@@ ; @@ptr@@ [ Number ] = Number L ; @@result@@ = @@ptr@@ ; } else { free ( @@ptr@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
__int64 __fastcall i_ring_empty ( __int64 @@a1@@ ) { return * ( unsigned __int8 * ) ( @@a1@@ + Number ) ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
__int64 __fastcall time_zone_hhmm ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 a3 , __int64 a4 , __int64 a5 , __int64 a6 , char @@a7@@ , __int64 @@a8@@ , unsigned __int64 @@a9@@ ) { __int64 @@v9@@ ; __int64 @@v11@@ ; if ( @@a9@@ <= Number && @@a2@@ < Number ) @@a8@@ *= Number L ; if ( @@a2@@ >= Number ) { if ( @@a7@@ ) @@v9@@ = - @@a2@@ ; else @@v9@@ = @@a2@@ ; @@v11@@ = Number * @@a8@@ + @@v9@@ ; } else { @@v11@@ = Number * ( @@a8@@ / Number ) + @@a8@@ % Number ; } if ( ( int ) abs32 ( @@v11@@ ) > Number ) ++ * ( _QWORD * ) ( @@a1@@ + Number ) ; return @@v11@@ ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
int wcwidth ( wchar_t @@c@@ ) { return wcwidth ( @@c@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int64 __fastcall to_year ( __int64 a1 , __int64 a2 , __int64 a3 , __int64 a4 , __int64 a5 , __int64 a6 , int a7 , __int64 @@a8@@ , __int64 @@a9@@ ) { __int64 @@v9@@ ; __int64 @@v11@@ ; @@v11@@ = @@a8@@ ; if ( @@a8@@ < Number ) return - @@a8@@ ; if ( @@a9@@ == Number ) { if ( @@a8@@ > Number ) @@v9@@ = Number L ; else @@v9@@ = Number L ; @@v11@@ = @@v9@@ + @@a8@@ ; } return @@v11@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
__int64 __fastcall linkat_follow ( unsigned int @@a1@@ , _BYTE * @@a2@@ , int @@a3@@ , const char * @@a4@@ ) { __int64 @@result@@ ; int @@v8@@ ; int @@v9@@ ; unsigned int @@v10@@ ; int @@v11@@ ; _BYTE * @@ptr@@ ; _BYTE * @@v13@@ ; _BYTE * @@v14@@ ; @@ptr@@ = @@a2@@ ; @@v8@@ = Number ; while ( @@v8@@ -- ) { @@v13@@ = ( _BYTE * ) areadlinkat ( @@a1@@ , @@ptr@@ ) ; if ( ! @@v13@@ ) break ; if ( * @@v13@@ == Number ) { if ( @@ptr@@ != @@a2@@ ) free ( @@ptr@@ ) ; @@ptr@@ = @@v13@@ ; } else { @@v14@@ = mdir_name ( @@ptr@@ ) ; if ( @@ptr@@ != @@a2@@ ) free ( @@ptr@@ ) ; if ( ! @@v14@@ ) { free ( @@v13@@ ) ; * __errno_location ( ) = Number ; return Number ; } @@ptr@@ = mfile_name_concat ( @@v14@@ , @@v13@@ , Number L ) ; free ( @@v14@@ ) ; free ( @@v13@@ ) ; if ( ! @@ptr@@ ) { * __errno_location ( ) = Number ; return Number ; } } } if ( @@v8@@ < Number ) { @@v13@@ = Number L ; * __errno_location ( ) = Number ; } if ( @@v13@@ || * __errno_location ( ) == Number ) { @@v10@@ = linkat ( @@a1@@ , @@ptr@@ , @@a3@@ , @@a4@@ , Number ) ; if ( @@ptr@@ != @@a2@@ ) { @@v11@@ = * __errno_location ( ) ; free ( @@ptr@@ ) ; * __errno_location ( ) = @@v11@@ ; } @@result@@ = @@v10@@ ; } else { if ( @@ptr@@ != @@a2@@ ) { @@v9@@ = * __errno_location ( ) ; free ( @@ptr@@ ) ; * __errno_location ( ) = @@v9@@ ; } @@result@@ = Number ; } return @@result@@ ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; FILE * @@v10@@ ; char * @@v11@@ ; FILE * @@v12@@ ; char * @@v13@@ ; if ( @@a1@@ ) { @@v1@@ = program_name ; @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = program_name ; @@v4@@ = program_name ; @@v5@@ = gettext ( String ) ; printf ( @@v5@@ , @@v4@@ , @@v3@@ ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String String String String String String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; @@v8@@ = stdout ; @@v9@@ = gettext ( String String String String String ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = stdout ; @@v11@@ = gettext ( String ) ; fputs_unlocked ( @@v11@@ , @@v10@@ ) ; @@v12@@ = stdout ; @@v13@@ = gettext ( String ) ; fputs_unlocked ( @@v13@@ , @@v12@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
_QWORD * __fastcall argv_iter_init_stream ( __int64 @@a1@@ ) { _QWORD * @@v2@@ ; @@v2@@ = malloc ( Number ) ; if ( ! @@v2@@ ) return Number L ; * @@v2@@ = @@a1@@ ; @@v2@@ [ Number ] = Number L ; @@v2@@ [ Number ] = Number L ; @@v2@@ [ Number ] = Number L ; @@v2@@ [ Number ] = Number L ; return @@v2@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall argmatch_to_argument ( const void * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; ++ @@i@@ ) { if ( ! memcmp ( @@a1@@ , ( const void * ) ( @@i@@ * @@a4@@ + @@a3@@ ) , @@a4@@ ) ) return * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; } return Number L ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
__int64 __fastcall fwrite_lowcase ( FILE * @@a1@@ , unsigned __int8 * @@a2@@ , __int64 @@a3@@ ) { int @@v3@@ ; __int64 @@result@@ ; while ( Number ) { @@result@@ = @@a3@@ -- ; if ( ! @@result@@ ) break ; @@v3@@ = tolower ( * @@a2@@ ) ; fputc ( @@v3@@ , @@a1@@ ) ; ++ @@a2@@ ; } return @@result@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
void * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
unsigned __int64 __fastcall save_token ( __int64 @@a1@@ ) { __int64 @@src@@ [ Number ] ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; struct obstack * @@v6@@ ; struct obstack * @@v7@@ ; struct obstack * @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@src@@ [ Number ] = @@a1@@ + Number ; @@src@@ [ Number ] = ( unsigned int ) ( * ( _DWORD * ) ( @@a1@@ + Number ) - * ( _DWORD * ) ( @@a1@@ + Number ) - Number ) ; @@v3@@ = @@a1@@ + Number ; @@v4@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( @@v4@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ) * ( _BYTE * ) ( @@v3@@ + Number ) |= Number ; * ( _QWORD * ) ( @@v3@@ + Number ) = ( * ( int * ) ( @@v3@@ + Number ) + * ( _QWORD * ) ( @@v3@@ + Number ) ) & ~ * ( _DWORD * ) ( @@v3@@ + Number ) ; if ( * ( _QWORD * ) ( @@v3@@ + Number ) - * ( _QWORD * ) ( @@v3@@ + Number ) > * ( _QWORD * ) ( @@v3@@ + Number ) - * ( _QWORD * ) ( @@v3@@ + Number ) ) * ( _QWORD * ) ( @@v3@@ + Number ) = * ( _QWORD * ) ( @@v3@@ + Number ) ; * ( _QWORD * ) ( @@v3@@ + Number ) = * ( _QWORD * ) ( @@v3@@ + Number ) ; @@v5@@ = @@v4@@ ; @@v6@@ = ( struct obstack * ) ( @@a1@@ + Number ) ; if ( ( unsigned __int64 ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L ) > * ( _QWORD * ) ( @@a1@@ + Number ) ) _obstack_newchunk ( @@v6@@ , Number ) ; @@v7@@ = @@v6@@ ; * ( _QWORD * ) @@v6@@ -> next_free = @@v5@@ ; @@v7@@ -> next_free += Number ; @@v8@@ = ( struct obstack * ) ( @@a1@@ + Number ) ; if ( ( unsigned __int64 ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L ) > * ( _QWORD * ) ( @@a1@@ + Number ) ) _obstack_newchunk ( @@v8@@ , Number ) ; memcpy ( @@v8@@ -> next_free , @@src@@ , Number ) ; @@v8@@ -> next_free += Number ; ++ * ( _QWORD * ) @@a1@@ ; return __readfsqword ( Number ) ^ @@v9@@ ; }
__int64 __fastcall imaxtostr ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = @@a1@@ ; @@v4@@ = @@a2@@ + Number ; * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; if ( @@a1@@ >= Number ) { do { * ( _BYTE * ) -- @@v4@@ = ( char ) @@v3@@ % Number + Number ; @@v3@@ /= Number L ; } while ( @@v3@@ ) ; } else { do { * ( _BYTE * ) -- @@v4@@ = Number - ( char ) @@v3@@ % Number ; @@v3@@ /= Number L ; } while ( @@v3@@ ) ; * ( _BYTE * ) -- @@v4@@ = Number ; } return @@v4@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
void * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
void * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
_BOOL8 __fastcall same_name ( _BYTE * @@a1@@ , _BYTE * @@a2@@ ) { bool @@v2@@ ; int * @@v3@@ ; int * @@v4@@ ; bool @@v5@@ ; bool @@v7@@ ; const char * @@s1@@ ; const char * @@s2@@ ; size_t @@v10@@ ; size_t @@n@@ ; char * @@ptr@@ ; char * @@filename@@ ; struct stat @@v14@@ ; struct stat @@v15@@ ; unsigned __int64 @@v16@@ ; @@v16@@ = __readfsqword ( Number ) ; @@s1@@ = last_component ( @@a1@@ ) ; @@s2@@ = last_component ( @@a2@@ ) ; @@v10@@ = base_len ( @@s1@@ ) ; @@n@@ = base_len ( @@s2@@ ) ; @@v2@@ = @@v10@@ == @@n@@ && ! memcmp ( @@s1@@ , @@s2@@ , @@n@@ ) ; @@v7@@ = Number ; if ( @@v2@@ ) { @@ptr@@ = ( char * ) dir_name ( ( __int64 ) @@a1@@ ) ; @@filename@@ = ( char * ) dir_name ( ( __int64 ) @@a2@@ ) ; if ( ( unsigned int ) stat ( @@ptr@@ , & @@v14@@ ) ) { @@v3@@ = __errno_location ( ) ; error ( Number , * @@v3@@ , String , @@ptr@@ ) ; } if ( ( unsigned int ) stat ( @@filename@@ , & @@v15@@ ) ) { @@v4@@ = __errno_location ( ) ; error ( Number , * @@v4@@ , String , @@filename@@ ) ; } @@v5@@ = @@v14@@ . st_ino == @@v15@@ . st_ino && @@v14@@ . st_dev == @@v15@@ . st_dev ; @@v7@@ = @@v5@@ ; free ( @@ptr@@ ) ; free ( @@filename@@ ) ; } return @@v7@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_209028 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_209108 ; @@v8@@ [ Number ] = qword_209110 ; @@v8@@ [ Number ] = qword_209118 ; @@v8@@ [ Number ] = qword_209120 ; @@v8@@ [ Number ] = qword_209128 ; @@v8@@ [ Number ] = qword_209130 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall get_stat_mtime_ns ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
int __fastcall utimens ( char * @@a1@@ , __int64 * @@a2@@ ) { return fdutimens ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall umaxtostr ( unsigned __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v4@@ ; @@v4@@ = @@a2@@ + Number ; * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; do { * ( _BYTE * ) -- @@v4@@ = @@a1@@ % Number + Number ; @@a1@@ /= Number ; } while ( @@a1@@ ) ; return @@v4@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v4@@ ; @@v4@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v4@@ >= Number / @@a3@@ ) xalloc_die ( ) ; @@v4@@ += ( @@v4@@ + Number ) >> Number ; } else if ( ! @@v4@@ ) { @@v4@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v4@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v4@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@v3@@ ; @@v3@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v3@@ ) xalloc_die ( ) ; return @@v3@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) _frame_dummy_init_array_entry [ @@i@@ ] ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v4@@ ; @@v4@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v4@@ >= Number / @@a3@@ ) xalloc_die ( ) ; @@v4@@ += ( @@v4@@ + Number ) >> Number ; } else if ( ! @@v4@@ ) { @@v4@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v4@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v4@@ ) ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_2130E8 ; @@v8@@ [ Number ] = qword_2130F0 ; @@v8@@ [ Number ] = qword_2130F8 ; @@v8@@ [ Number ] = qword_213100 ; @@v8@@ [ Number ] = qword_213108 ; @@v8@@ [ Number ] = qword_213110 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ ) { return xmalloc ( @@a1@@ ) ; }
int toupper ( int @@c@@ ) { return toupper ( @@c@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@v3@@ ; @@v3@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v3@@ ) xalloc_die ( ) ; return @@v3@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
int __fastcall fstat ( int @@fildes@@ , struct stat * @@stat_buf@@ ) { return __fxstat ( Number , @@fildes@@ , @@stat_buf@@ ) ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
__int64 __fastcall xfts_open ( const char * * @@a1@@ , int @@a2@@ , __int64 @@a3@@ ) { int @@v3@@ ; __int64 @@v5@@ ; @@v3@@ = @@a2@@ ; BYTE1 ( @@v3@@ ) = BYTE1 ( @@a2@@ ) | Number ; @@v5@@ = fts_open ( @@a1@@ , @@v3@@ , @@a3@@ ) ; if ( ! @@v5@@ ) { if ( * __errno_location ( ) == Number ) __assert_fail ( String , String , Number , String ) ; xalloc_die ( ) ; } return @@v5@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@v3@@ ; @@v3@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v3@@ ) xalloc_die ( ) ; return @@v3@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
int __xstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _xstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
unsigned __int64 __fastcall hash_pjw ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ ) { unsigned __int64 @@v4@@ ; @@v4@@ = Number L ; while ( * @@a1@@ ) @@v4@@ = __ROL8__ ( @@v4@@ , Number ) + ( char ) * @@a1@@ ++ ; return @@v4@@ % @@a2@@ ; }
_BOOL8 __fastcall c_isalpha ( int @@a1@@ ) { return ( int ) ( @@a1@@ & Number ) > Number && ( int ) ( @@a1@@ & Number ) <= Number ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
int clock_settime ( clockid_t @@clock_id@@ , const struct timespec * @@tp@@ ) { return clock_settime ( @@clock_id@@ , @@tp@@ ) ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
_BOOL8 __fastcall c_isgraph ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
__int64 __fastcall _xargmatch_internal ( __int64 @@a1@@ , const char * @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ , void ( * @@a6@@ ) ( void ) ) { __int64 @@v11@@ ; @@v11@@ = argmatch ( @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; if ( @@v11@@ >= Number ) return @@v11@@ ; argmatch_invalid ( @@a1@@ , ( __int64 ) @@a2@@ , @@v11@@ ) ; argmatch_valid ( @@a3@@ , @@a4@@ , @@a5@@ ) ; @@a6@@ ( ) ; return Number ; }
_BOOL8 __fastcall c_isxdigit ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number || ( int ) ( @@a1@@ & Number ) > Number && ( int ) ( @@a1@@ & Number ) <= Number ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
int setuid ( __uid_t @@uid@@ ) { return setuid ( @@uid@@ ) ; }
bool __fastcall is_zero_or_power_of_two ( __int64 @@a1@@ ) { return ( @@a1@@ & ( @@a1@@ - Number ) ) == Number ; }
__int64 __fastcall bad_cast ( __int64 @@a1@@ ) { return @@a1@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) _frame_dummy_init_array_entry [ @@i@@ ] ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
__int64 __fastcall show_date ( char * @@a1@@ , time_t @@a2@@ , __int64 @@a3@@ ) { __int64 @@v3@@ ; char * @@v4@@ ; __int64 @@result@@ ; time_t @@timer@@ ; __int64 @@v7@@ ; char * @@v8@@ ; struct tm * @@v9@@ ; char @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v8@@ = @@a1@@ ; @@timer@@ = @@a2@@ ; @@v7@@ = @@a3@@ ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = localtime ( & @@timer@@ ) ; if ( @@v9@@ ) { if ( @@v8@@ == String ) setlocale ( Number , String ) ; fprintftime ( stdout , @@v8@@ , @@v9@@ , Number L , ( unsigned int ) @@v7@@ ) ; fputc_unlocked ( Number , stdout ) ; if ( @@v8@@ == String ) setlocale ( Number , & locale ) ; @@result@@ = Number L ; } else { @@v3@@ = timetostr ( @@timer@@ , ( __int64 ) @@v10@@ ) ; @@v4@@ = gettext ( String ) ; error ( Number , Number , @@v4@@ , @@v3@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall rpl_fcntl ( int @@a1@@ , int @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , __m128 @@a7@@ , __m128 @@a8@@ , __m128 @@a9@@ , __m128 @@a10@@ , __m128 @@a11@@ , __m128 @@a12@@ , __m128 @@a13@@ , __m128 @@a14@@ ) { int @@v14@@ ; int @@v15@@ ; int @@v16@@ ; int @@v18@@ ; int @@v19@@ ; int @@v20@@ ; int @@v21@@ ; __int64 @@v22@@ ; __int64 @@v23@@ ; __int64 @@v24@@ ; __int64 @@v25@@ ; __m128 @@v26@@ ; __m128 @@v27@@ ; __m128 @@v28@@ ; __m128 @@v29@@ ; __m128 @@v30@@ ; __m128 @@v31@@ ; __m128 @@v32@@ ; __m128 @@v33@@ ; @@v22@@ = @@a3@@ ; @@v23@@ = @@a4@@ ; @@v24@@ = @@a5@@ ; @@v25@@ = @@a6@@ ; @@v26@@ = @@a7@@ ; @@v27@@ = @@a8@@ ; @@v28@@ = @@a9@@ ; @@v29@@ = @@a10@@ ; @@v30@@ = @@a11@@ ; @@v31@@ = @@a12@@ ; @@v32@@ = @@a13@@ ; @@v33@@ = @@a14@@ ; if ( @@a2@@ != Number ) return ( unsigned int ) fcntl ( @@a1@@ , @@a2@@ , @@v22@@ ) ; @@v19@@ = @@v22@@ ; if ( have_dupfd_cloexec_2895 < Number ) { @@v18@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v22@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; } else { @@v18@@ = fcntl ( @@a1@@ , Number , ( unsigned int ) @@v22@@ ) ; if ( @@v18@@ < Number && * __errno_location ( ) == Number ) { @@v18@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v19@@ , @@v14@@ , @@v15@@ , @@v16@@ ) ; if ( @@v18@@ < Number ) return ( unsigned int ) @@v18@@ ; have_dupfd_cloexec_2895 = Number ; } else { have_dupfd_cloexec_2895 = Number ; } } if ( @@v18@@ >= Number && have_dupfd_cloexec_2895 == Number ) { @@v20@@ = fcntl ( @@v18@@ , Number ) ; if ( @@v20@@ < Number || fcntl ( @@v18@@ , Number , @@v20@@ | Number ) == Number ) { @@v21@@ = * __errno_location ( ) ; close ( @@v18@@ ) ; * __errno_location ( ) = @@v21@@ ; @@v18@@ = Number ; } } return ( unsigned int ) @@v18@@ ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
__int64 __fastcall set_additional_groups ( __int64 @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; int * @@v3@@ ; size_t @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; char * @@v7@@ ; int * @@v8@@ ; unsigned int @@v10@@ ; __int64 @@v11@@ ; __gid_t @@gid@@ [ Number ] ; __gid_t * @@groups@@ ; size_t @@n@@ ; char * @@name@@ ; struct group * @@v16@@ ; char * @@s@@ ; unsigned __int64 @@v18@@ ; @@v18@@ = __readfsqword ( Number ) ; @@groups@@ = Number L ; @@v11@@ = Number L ; @@n@@ = Number L ; @@s@@ = ( char * ) xstrdup ( @@a1@@ ) ; @@v10@@ = Number ; for ( @@name@@ = strtok ( @@s@@ , String ) ; @@name@@ ; @@name@@ = strtok ( Number L , String ) ) { if ( ( unsigned int ) xstrtoul ( @@name@@ , Number L , Number L , @@gid@@ , & locale ) || * ( _QWORD * ) @@gid@@ > Number ) { @@v16@@ = getgrnam ( @@name@@ ) ; if ( @@v16@@ ) * ( _QWORD * ) @@gid@@ = @@v16@@ -> gr_gid ; } else { @@v16@@ = getgrgid ( @@gid@@ [ Number ] ) ; } if ( @@v16@@ ) { if ( @@n@@ == @@v11@@ ) @@groups@@ = ( __gid_t * ) x2nrealloc ( @@groups@@ , & @@v11@@ , Number L ) ; @@v4@@ = @@n@@ ++ ; @@groups@@ [ @@v4@@ ] = @@gid@@ [ Number ] ; } else { @@v1@@ = quote ( @@name@@ ) ; @@v2@@ = gettext ( String ) ; @@v3@@ = __errno_location ( ) ; error ( Number , * @@v3@@ , @@v2@@ , @@v1@@ ) ; @@v10@@ = Number ; } } if ( ! @@v10@@ && ! @@n@@ ) { @@v5@@ = quote ( @@a1@@ ) ; @@v6@@ = gettext ( String ) ; error ( Number , Number , @@v6@@ , @@v5@@ ) ; @@v10@@ = Number ; } if ( ! @@v10@@ ) { @@v10@@ = setgroups ( @@n@@ , @@groups@@ ) ; if ( @@v10@@ ) { @@v7@@ = gettext ( String ) ; @@v8@@ = __errno_location ( ) ; error ( Number , * @@v8@@ , @@v7@@ ) ; } } free ( @@s@@ ) ; free ( @@groups@@ ) ; return @@v10@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
const char * * __fastcall lookup_zone ( __int64 @@a1@@ , const char * @@a2@@ ) { const char * * @@i@@ ; const char * * @@j@@ ; const char * * @@k@@ ; for ( @@i@@ = ( const char * * ) & universal_time_zone_table ; * @@i@@ ; @@i@@ += Number ) { if ( ! strcmp ( @@a2@@ , * @@i@@ ) ) return @@i@@ ; } for ( @@j@@ = ( const char * * ) ( @@a1@@ + Number ) ; * @@j@@ ; @@j@@ += Number ) { if ( ! strcmp ( @@a2@@ , * @@j@@ ) ) return @@j@@ ; } for ( @@k@@ = ( const char * * ) & time_zone_table ; * @@k@@ ; @@k@@ += Number ) { if ( ! strcmp ( @@a2@@ , * @@k@@ ) ) return @@k@@ ; } return Number L ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; char * @@v3@@ ; FILE * @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; FILE * @@v10@@ ; char * @@v11@@ ; @@v1@@ = program_name ; if ( @@a1@@ ) { @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = gettext ( String ) ; printf ( @@v3@@ , @@v1@@ ) ; @@v4@@ = stdout ; @@v5@@ = gettext ( String String String ) ; fputs_unlocked ( @@v5@@ , @@v4@@ ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; @@v8@@ = stdout ; @@v9@@ = gettext ( String ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = stdout ; @@v11@@ = gettext ( String ) ; fputs_unlocked ( @@v11@@ , @@v10@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
__int64 __fastcall argmatch ( const char * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { __int64 @@result@@ ; char @@v7@@ ; __int64 @@i@@ ; __int64 @@v9@@ ; size_t @@n@@ ; @@v9@@ = Number ; @@v7@@ = Number ; @@n@@ = strlen ( @@a1@@ ) ; for ( @@i@@ = Number L ; * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; ++ @@i@@ ) { if ( ! strncmp ( * ( const char * * ) ( Number * @@i@@ + @@a2@@ ) , @@a1@@ , @@n@@ ) ) { if ( @@n@@ == strlen ( * ( const char * * ) ( Number * @@i@@ + @@a2@@ ) ) ) return @@i@@ ; if ( @@v9@@ == Number ) { @@v9@@ = @@i@@ ; } else if ( ! @@a3@@ || memcmp ( ( const void * ) ( @@a4@@ * @@v9@@ + @@a3@@ ) , ( const void * ) ( @@i@@ * @@a4@@ + @@a3@@ ) , @@a4@@ ) ) { @@v7@@ = Number ; } } } if ( @@v7@@ ) @@result@@ = Number ; else @@result@@ = @@v9@@ ; return @@result@@ ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_208028 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = ( __int64 * ) & slotvec0 ; } nslots = Number ; return @@result@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_207028 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
void * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
void * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
__int64 __fastcall iso_week_days ( int @@a1@@ , int @@a2@@ ) { return ( unsigned int ) ( @@a1@@ - ( @@a1@@ - @@a2@@ + Number ) % Number + Number ) ; }
void * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_2070A8 ; @@v8@@ [ Number ] = qword_2070B0 ; @@v8@@ [ Number ] = qword_2070B8 ; @@v8@@ [ Number ] = qword_2070C0 ; @@v8@@ [ Number ] = qword_2070C8 ; @@v8@@ [ Number ] = qword_2070D0 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
void * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
void * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_208108 ; @@v4@@ [ Number ] = qword_208110 ; @@v4@@ [ Number ] = qword_208118 ; @@v4@@ [ Number ] = qword_208120 ; @@v4@@ [ Number ] = qword_208128 ; @@v4@@ [ Number ] = qword_208130 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
__int64 __fastcall year ( __int64 @@a1@@ , _DWORD * @@a2@@ , __int64 @@a3@@ , char @@a4@@ ) { time_t @@timer@@ ; struct tm * @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; if ( @@a3@@ == Number ) { * ( _DWORD * ) ( @@a1@@ + Number ) = * @@a2@@ ; if ( ( int ) * @@a2@@ <= Number ) { if ( ( @@a4@@ & Number ) != Number ) return Number L ; * ( _DWORD * ) ( @@a1@@ + Number ) += Number ; } } else if ( @@a3@@ ) { if ( @@a3@@ != Number ) abort ( ) ; if ( ( @@a4@@ & Number ) == Number ) return Number L ; * ( _DWORD * ) ( @@a1@@ + Number ) = Number * * @@a2@@ + @@a2@@ [ Number ] - Number ; } else { time ( & @@timer@@ ) ; @@v6@@ = localtime ( & @@timer@@ ) ; if ( ! @@v6@@ ) return Number L ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@v6@@ -> tm_year ; } return Number L ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
__int64 __fastcall rpl_fcntl ( int @@a1@@ , int @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , __m128 @@a7@@ , __m128 @@a8@@ , __m128 @@a9@@ , __m128 @@a10@@ , __m128 @@a11@@ , __m128 @@a12@@ , __m128 @@a13@@ , __m128 @@a14@@ ) { int @@v14@@ ; int @@v15@@ ; int @@v16@@ ; int @@v18@@ ; int @@v19@@ ; int @@v20@@ ; int @@v21@@ ; __int64 @@v22@@ ; __int64 @@v23@@ ; __int64 @@v24@@ ; __int64 @@v25@@ ; __m128 @@v26@@ ; __m128 @@v27@@ ; __m128 @@v28@@ ; __m128 @@v29@@ ; __m128 @@v30@@ ; __m128 @@v31@@ ; __m128 @@v32@@ ; __m128 @@v33@@ ; @@v22@@ = @@a3@@ ; @@v23@@ = @@a4@@ ; @@v24@@ = @@a5@@ ; @@v25@@ = @@a6@@ ; @@v26@@ = @@a7@@ ; @@v27@@ = @@a8@@ ; @@v28@@ = @@a9@@ ; @@v29@@ = @@a10@@ ; @@v30@@ = @@a11@@ ; @@v31@@ = @@a12@@ ; @@v32@@ = @@a13@@ ; @@v33@@ = @@a14@@ ; if ( @@a2@@ != Number ) return ( unsigned int ) fcntl ( @@a1@@ , @@a2@@ , @@v22@@ ) ; @@v19@@ = @@v22@@ ; if ( have_dupfd_cloexec_2895 < Number ) { @@v18@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v22@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; } else { @@v18@@ = fcntl ( @@a1@@ , Number , ( unsigned int ) @@v22@@ ) ; if ( @@v18@@ < Number && * __errno_location ( ) == Number ) { @@v18@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v19@@ , @@v14@@ , @@v15@@ , @@v16@@ ) ; if ( @@v18@@ < Number ) return ( unsigned int ) @@v18@@ ; have_dupfd_cloexec_2895 = Number ; } else { have_dupfd_cloexec_2895 = Number ; } } if ( @@v18@@ >= Number && have_dupfd_cloexec_2895 == Number ) { @@v20@@ = fcntl ( @@v18@@ , Number ) ; if ( @@v20@@ < Number || fcntl ( @@v18@@ , Number , @@v20@@ | Number ) == Number ) { @@v21@@ = * __errno_location ( ) ; close ( @@v18@@ ) ; * __errno_location ( ) = @@v21@@ ; @@v18@@ = Number ; } } return ( unsigned int ) @@v18@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( is_mul_ok ( @@a2@@ , * @@a1@@ ) ) { * @@a1@@ *= @@a2@@ ; @@result@@ = Number L ; } else { * @@a1@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
int fileno ( FILE * @@stream@@ ) { return fileno ( @@stream@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
int raise ( int @@sig@@ ) { return raise ( @@sig@@ ) ; }
int __xstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _xstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
int toupper ( int @@c@@ ) { return toupper ( @@c@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
void * malloc ( size_t @@size@@ ) { return __imp_malloc ( @@size@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_2070A8 ; @@v8@@ [ Number ] = qword_2070B0 ; @@v8@@ [ Number ] = qword_2070B8 ; @@v8@@ [ Number ] = qword_2070C0 ; @@v8@@ [ Number ] = qword_2070C8 ; @@v8@@ [ Number ] = qword_2070D0 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
struct group * getgrnam ( const char * @@name@@ ) { return getgrnam ( @@name@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
unsigned __int64 __fastcall write_counts ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , const char * @@a6@@ ) { const char * @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; char * @@format@@ ; char @@v17@@ [ Number ] ; unsigned __int64 @@v18@@ ; @@v18@@ = __readfsqword ( Number ) ; @@format@@ = String ; if ( print_lines ) { @@v6@@ = ( const char * ) umaxtostr ( @@a1@@ , @@v17@@ ) ; printf ( String , number_width , @@v6@@ ) ; @@format@@ = String ; } if ( print_words ) { @@v7@@ = umaxtostr ( @@a2@@ , @@v17@@ ) ; printf ( @@format@@ , ( unsigned int ) number_width , @@v7@@ ) ; @@format@@ = String ; } if ( print_chars ) { @@v8@@ = umaxtostr ( @@a3@@ , @@v17@@ ) ; printf ( @@format@@ , ( unsigned int ) number_width , @@v8@@ ) ; @@format@@ = String ; } if ( print_bytes ) { @@v9@@ = umaxtostr ( @@a4@@ , @@v17@@ ) ; printf ( @@format@@ , ( unsigned int ) number_width , @@v9@@ ) ; @@format@@ = String ; } if ( print_linelength ) { @@v10@@ = umaxtostr ( @@a5@@ , @@v17@@ ) ; printf ( @@format@@ , ( unsigned int ) number_width , @@v10@@ ) ; } if ( @@a6@@ ) printf ( String , @@a6@@ ) ; putchar_unlocked ( Number ) ; return __readfsqword ( Number ) ^ @@v18@@ ; }
__int64 __fastcall umaxtostr ( unsigned __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v4@@ ; @@v4@@ = @@a2@@ + Number ; * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; do { * ( _BYTE * ) -- @@v4@@ = @@a1@@ % Number + Number ; @@a1@@ /= Number ; } while ( @@a1@@ ) ; return @@v4@@ ; }
int wcwidth ( wchar_t @@c@@ ) { return wcwidth ( @@c@@ ) ; }
_BOOL8 __fastcall c_isalnum ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number || ( int ) ( @@a1@@ & Number ) > Number && ( int ) ( @@a1@@ & Number ) <= Number ; }
int __fastcall settime ( const struct timespec * @@a1@@ ) { int @@v2@@ ; struct timeval @@tv@@ ; unsigned __int64 @@v4@@ ; @@v4@@ = __readfsqword ( Number ) ; @@v2@@ = clock_settime ( Number , @@a1@@ ) ; if ( ! @@v2@@ || * __errno_location ( ) == Number ) return @@v2@@ ; @@tv@@ . tv_sec = @@a1@@ -> tv_sec ; @@tv@@ . tv_usec = @@a1@@ -> tv_nsec / Number ; return settimeofday ( & @@tv@@ , Number L ) ; }
unsigned int gnu_dev_major ( unsigned __int64 @@dev@@ ) { return gnu_dev_major ( @@dev@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
__int64 __fastcall argv_iter ( __int64 @@a1@@ , int * @@a2@@ ) { int @@v2@@ ; __int64 @@result@@ ; __int64 * @@v4@@ ; if ( * ( _QWORD * ) @@a1@@ ) { if ( getdelim ( ( char * * ) ( @@a1@@ + Number ) , ( size_t * ) ( @@a1@@ + Number ) , Number , * ( FILE * * ) @@a1@@ ) >= Number ) { * @@a2@@ = Number ; ++ * ( _QWORD * ) ( @@a1@@ + Number ) ; @@result@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; } else { if ( feof ( * ( FILE * * ) @@a1@@ ) ) @@v2@@ = Number ; else @@v2@@ = Number ; * @@a2@@ = @@v2@@ ; @@result@@ = Number L ; } } else if ( * * ( _QWORD * * ) ( @@a1@@ + Number ) ) { * @@a2@@ = Number ; @@v4@@ = * ( __int64 * * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v4@@ + Number ; @@result@@ = * @@v4@@ ; } else { * @@a2@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
_BOOL8 __fastcall c_islower ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@v2@@ ; @@v2@@ = malloc ( @@a1@@ ) ; if ( ! @@v2@@ && @@a1@@ ) xalloc_die ( ) ; return @@v2@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
_BOOL8 __fastcall c_isupper ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
__int64 __fastcall bad_cast ( __int64 @@a1@@ ) { return @@a1@@ ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
int __lxstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _lxstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
_BOOL8 __fastcall c_iscntrl ( int @@a1@@ ) { return ( @@a1@@ & Number ) == Number || @@a1@@ == Number ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
int _setjmp ( struct __jmp_buf_tag @@env@@ ( ( orgarrdim ( Number , Number ) ) ) [ Number ] ) { return setjmp ( @@env@@ ( ( orgarrdim ( Number , Number ) ) ) ) ; }
_BOOL8 __fastcall c_islower ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
unsigned int __fastcall dired_dump_obstack ( const char * @@a1@@ , __int64 @@a2@@ ) { unsigned int @@result@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@v4@@ ; __int64 @@v5@@ ; @@result@@ = ( unsigned int ) ( * ( _DWORD * ) ( @@a2@@ + Number ) - * ( _DWORD * ) ( @@a2@@ + Number ) ) >> Number ; @@v4@@ = @@result@@ ; if ( @@result@@ ) { @@v5@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( @@v5@@ == * ( _QWORD * ) ( @@a2@@ + Number ) ) * ( _BYTE * ) ( @@a2@@ + Number ) |= Number ; * ( _QWORD * ) ( @@a2@@ + Number ) = ( * ( int * ) ( @@a2@@ + Number ) + * ( _QWORD * ) ( @@a2@@ + Number ) ) & ~ * ( _DWORD * ) ( @@a2@@ + Number ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) - * ( _QWORD * ) ( @@a2@@ + Number ) > * ( _QWORD * ) ( @@a2@@ + Number ) - * ( _QWORD * ) ( @@a2@@ + Number ) ) * ( _QWORD * ) ( @@a2@@ + Number ) = * ( _QWORD * ) ( @@a2@@ + Number ) ; * ( _QWORD * ) ( @@a2@@ + Number ) = * ( _QWORD * ) ( @@a2@@ + Number ) ; fputs_unlocked ( @@a1@@ , stdout ) ; for ( @@i@@ = Number L ; @@i@@ < @@v4@@ ; ++ @@i@@ ) printf ( String , * ( _QWORD * ) ( Number * @@i@@ + @@v5@@ ) ) ; @@result@@ = putchar_unlocked ( Number ) ; } return @@result@@ ; }
_BOOL8 __fastcall c_isupper ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
double physmem_total ( ) { double @@result@@ ; double @@v1@@ ; double @@v2@@ ; @@v1@@ = ( double ) ( int ) sysconf ( Number ) ; @@v2@@ = ( double ) ( int ) sysconf ( Number ) ; if ( @@v1@@ < Number || @@v2@@ < Number ) @@result@@ = Number ; else @@result@@ = @@v1@@ * @@v2@@ ; return @@result@@ ; }
int putchar_unlocked ( int @@c@@ ) { return putchar_unlocked ( @@c@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
int tolower ( int @@c@@ ) { return tolower ( @@c@@ ) ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
unsigned int gnu_dev_minor ( unsigned __int64 @@dev@@ ) { return gnu_dev_minor ( @@dev@@ ) ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
_BOOL8 __fastcall is_directory ( __int64 @@a1@@ ) { return * ( _DWORD * ) ( @@a1@@ + Number ) == Number || * ( _DWORD * ) ( @@a1@@ + Number ) == Number ; }
int feof_unlocked ( FILE * @@stream@@ ) { return feof_unlocked ( @@stream@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
_BOOL8 __fastcall dot_or_dotdot ( _BYTE * @@a1@@ ) { __int64 @@v1@@ ; char @@v4@@ ; if ( * @@a1@@ != Number ) return Number L ; if ( @@a1@@ [ Number ] == Number ) @@v1@@ = Number L ; else @@v1@@ = Number L ; @@v4@@ = @@a1@@ [ @@v1@@ ] ; return ! @@v4@@ || @@v4@@ == Number ; }
__int64 __fastcall extract_dirs_from_files ( __int64 @@a1@@ , char @@a2@@ ) { __int64 @@result@@ ; __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 * @@v8@@ ; void * @@ptr@@ ; if ( @@a1@@ && active_dir_set ) queue_directory ( Number L , @@a1@@ , Number ) ; @@v4@@ = cwd_n_used ; while ( @@v4@@ -- ) { @@v8@@ = ( __int64 * ) * ( ( _QWORD * ) sorted_file + @@v4@@ ) ; if ( is_directory ( ( __int64 ) @@v8@@ ) && ( ! @@a1@@ || ! basename_is_dot_or_dotdot ( * @@v8@@ ) ) ) { if ( @@a1@@ && * ( _BYTE * ) * @@v8@@ != Number ) { @@ptr@@ = ( void * ) file_name_concat ( @@a1@@ , * @@v8@@ , Number L ) ; queue_directory ( ( __int64 ) @@ptr@@ , @@v8@@ [ Number ] , @@a2@@ ) ; free ( @@ptr@@ ) ; } else { queue_directory ( * @@v8@@ , @@v8@@ [ Number ] , @@a2@@ ) ; } if ( * ( ( _DWORD * ) @@v8@@ + Number ) == Number ) free ( ( void * ) * @@v8@@ ) ; } } @@v5@@ = Number L ; @@v6@@ = Number L ; while ( @@v5@@ < cwd_n_used ) { @@v7@@ = * ( ( _QWORD * ) sorted_file + @@v5@@ ) ; * ( ( _QWORD * ) sorted_file + @@v6@@ ) = @@v7@@ ; @@v6@@ += * ( _DWORD * ) ( @@v7@@ + Number ) != Number ; ++ @@v5@@ ; } @@result@@ = @@v6@@ ; cwd_n_used = @@v6@@ ; return @@result@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; char * @@v3@@ ; FILE * @@v4@@ ; char * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; FILE * @@v11@@ ; char * @@v12@@ ; FILE * @@v13@@ ; char * @@v14@@ ; char * @@v15@@ ; @@v1@@ = program_name ; if ( @@a1@@ ) { @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = gettext ( String String String String ) ; printf ( @@v3@@ , @@v1@@ , String , Number L ) ; @@v4@@ = stdout ; @@v5@@ = gettext ( String ) ; fputs_unlocked ( @@v5@@ , @@v4@@ ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , String ) ; @@v7@@ = stdout ; @@v8@@ = gettext ( String ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = stdout ; @@v10@@ = gettext ( String String String String String String ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; @@v11@@ = stdout ; @@v12@@ = gettext ( String ) ; fputs_unlocked ( @@v12@@ , @@v11@@ ) ; @@v13@@ = stdout ; @@v14@@ = gettext ( String ) ; fputs_unlocked ( @@v14@@ , @@v13@@ ) ; @@v15@@ = gettext ( String String String String String ) ; printf ( @@v15@@ , String ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
__int64 abmon_init ( ) { char * @@v0@@ ; __int64 @@v2@@ ; int @@i@@ ; unsigned __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; unsigned __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; required_mon_width = Number L ; do { @@v5@@ = required_mon_width ; required_mon_width = Number L ; for ( @@i@@ = Number ; @@i@@ <= Number ; ++ @@i@@ ) { @@v4@@ = @@v5@@ ; @@v0@@ = nl_langinfo ( @@i@@ + Number ) ; @@v6@@ = mbsalign ( @@v0@@ , ( char * ) & abmon + Number * @@i@@ , Number L , & @@v4@@ , Number L , Number L ) ; if ( @@v6@@ == Number || @@v6@@ > Number ) { required_mon_width = Number L ; return Number L ; } @@v2@@ = required_mon_width ; if ( @@v4@@ >= required_mon_width ) @@v2@@ = @@v4@@ ; required_mon_width = @@v2@@ ; } } while ( @@v5@@ > required_mon_width ) ; return required_mon_width ; }
__int64 __fastcall xstrcoll_df_atime ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_atime ( @@a1@@ , @@a2@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) xstrcoll ) ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
__int64 __fastcall file_failure ( unsigned __int8 @@a1@@ , const char * @@a2@@ , __int64 @@a3@@ ) { __int64 @@v3@@ ; int * @@v4@@ ; @@v3@@ = quotearg_colon ( @@a3@@ ) ; @@v4@@ = __errno_location ( ) ; error ( Number , * @@v4@@ , @@a2@@ , @@v3@@ ) ; return set_exit_status ( @@a1@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall strcmp_df_size ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_size ( @@a1@@ , @@a2@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) & strcmp ) ; }
FILE * __fastcall fopen_safer ( const char * @@a1@@ , const char * @@a2@@ ) { int @@v3@@ ; int @@fd@@ ; int @@v5@@ ; int @@v6@@ ; FILE * @@stream@@ ; @@stream@@ = fopen ( @@a1@@ , @@a2@@ ) ; if ( ! @@stream@@ ) return @@stream@@ ; @@v3@@ = fileno ( @@stream@@ ) ; if ( @@v3@@ < Number || @@v3@@ > Number ) return @@stream@@ ; @@fd@@ = dup_safer ( ( unsigned int ) @@v3@@ ) ; if ( @@fd@@ < Number ) { @@v6@@ = * __errno_location ( ) ; fclose ( @@stream@@ ) ; * __errno_location ( ) = @@v6@@ ; return Number L ; } if ( ! fclose ( @@stream@@ ) ) { @@stream@@ = fdopen ( @@fd@@ , @@a2@@ ) ; if ( @@stream@@ ) return @@stream@@ ; } @@v5@@ = * __errno_location ( ) ; close ( @@fd@@ ) ; * __errno_location ( ) = @@v5@@ ; return Number L ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
_QWORD * __fastcall add_ignore_pattern ( __int64 @@a1@@ ) { _QWORD * @@result@@ ; @@result@@ = ( _QWORD * ) xmalloc ( Number L ) ; * @@result@@ = @@a1@@ ; @@result@@ [ Number ] = ignore_patterns ; ignore_patterns = ( __int64 ) @@result@@ ; return @@result@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
__int64 __fastcall rev_xstrcoll_df_name ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_name ( @@a2@@ , @@a1@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) xstrcoll ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
__int64 clear_files ( ) { __int64 @@result@@ ; unsigned __int64 @@i@@ ; void * * @@v2@@ ; for ( @@i@@ = Number L ; ; ++ @@i@@ ) { @@result@@ = cwd_n_used ; if ( @@i@@ >= cwd_n_used ) break ; @@v2@@ = ( void * * ) * ( ( _QWORD * ) sorted_file + @@i@@ ) ; free ( * @@v2@@ ) ; free ( @@v2@@ [ Number ] ) ; if ( @@v2@@ [ Number ] != & UNKNOWN_SECURITY_CONTEXT ) freecon ( ) ; } cwd_n_used = Number L ; any_has_acl = Number ; inode_number_width = Number ; block_size_width = Number ; nlink_width = Number ; owner_width = Number ; group_width = Number ; author_width = Number ; scontext_width = Number ; major_device_number_width = Number ; minor_device_number_width = Number ; file_size_width = Number ; return @@result@@ ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
__int64 __fastcall rev_strcmp_df_extension ( const char * * @@a1@@ , const char * * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_extension ( @@a2@@ , @@a1@@ , ( __int64 ( __fastcall * ) ( const char * , const char * ) ) & strcmp ) ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__int64 __fastcall make_link_name ( const char * @@a1@@ , const char * @@a2@@ ) { size_t @@v3@@ ; char * @@dest@@ ; char * @@desta@@ ; __int64 @@n@@ ; if ( ! @@a2@@ ) return Number L ; if ( * @@a2@@ == Number ) return xstrdup ( @@a2@@ ) ; @@dest@@ = strrchr ( @@a1@@ , Number ) ; if ( ! @@dest@@ ) return xstrdup ( @@a2@@ ) ; @@n@@ = @@dest@@ - @@a1@@ + Number ; @@v3@@ = strlen ( @@a2@@ ) ; @@desta@@ = ( char * ) xmalloc ( @@v3@@ + @@n@@ + Number ) ; strncpy ( @@desta@@ , @@a1@@ , @@n@@ ) ; strcpy ( & @@desta@@ [ @@n@@ ] , @@a2@@ ) ; return ( __int64 ) @@desta@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return xmalloc ( @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_207028 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 print_current_files ( ) { __int64 @@result@@ ; unsigned __int64 @@j@@ ; unsigned __int64 @@i@@ ; @@result@@ = ( unsigned int ) format ; switch ( format ) { case Number : for ( @@i@@ = Number L ; ; ++ @@i@@ ) { @@result@@ = cwd_n_used ; if ( @@i@@ >= cwd_n_used ) break ; print_long_format ( * ( ( _QWORD * ) sorted_file + @@i@@ ) ) ; putchar_unlocked ( Number ) ; ++ dired_pos ; } break ; case Number : for ( @@j@@ = Number L ; ; ++ @@j@@ ) { @@result@@ = cwd_n_used ; if ( @@j@@ >= cwd_n_used ) break ; print_file_name_and_frills ( * ( ( _QWORD * ) sorted_file + @@j@@ ) , Number L ) ; putchar_unlocked ( Number ) ; } break ; case Number : @@result@@ = print_many_per_line ( ) ; break ; case Number : @@result@@ = print_horizontal ( ) ; break ; case Number : @@result@@ = print_with_commas ( ) ; break ; default : return @@result@@ ; } return @@result@@ ; }
__int64 __fastcall cmp_size ( _QWORD * @@a1@@ , _QWORD * @@a2@@ , __int64 ( __fastcall * @@a3@@ ( ) ( constchar , constchar ) ) ( _QWORD , _QWORD ) ) { __int64 @@result@@ ; if ( @@a2@@ [ Number ] < @@a1@@ [ Number ] ) LODWORD ( @@result@@ ) = Number ; else LODWORD ( @@result@@ ) = @@a2@@ [ Number ] > @@a1@@ [ Number ] ; if ( ( _DWORD ) @@result@@ ) @@result@@ = ( unsigned int ) @@result@@ ; else @@result@@ = @@a3@@ ( ) ( constchar , constchar ) ( * @@a1@@ , * @@a2@@ ) ; return @@result@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( ) ; return @@ptr@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_20D0E8 ; @@v4@@ [ Number ] = qword_20D0F0 ; @@v4@@ [ Number ] = qword_20D0F8 ; @@v4@@ [ Number ] = qword_20D100 ; @@v4@@ [ Number ] = qword_20D108 ; @@v4@@ [ Number ] = qword_20D110 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
__int64 __fastcall format_group ( unsigned int @@a1@@ , int @@a2@@ , char @@a3@@ ) { const char * @@v3@@ ; if ( @@a3@@ != Number ) { @@v3@@ = String ; } else if ( numeric_ids ) { @@v3@@ = Number L ; } else { @@v3@@ = ( const char * ) getgroup ( @@a1@@ ) ; } return format_user_or_group ( @@v3@@ , @@a1@@ , @@a2@@ ) ; }
int __fastcall stat ( char * @@filename@@ , struct stat * @@stat_buf@@ ) { return __xstat ( Number , @@filename@@ , @@stat_buf@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__int64 __fastcall strcmp_df_ctime ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_ctime ( @@a1@@ , @@a2@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) & strcmp ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
__int64 __fastcall sha224_read_ctx ( __int64 @@a1@@ , __int64 @@a2@@ ) { int @@i@@ ; for ( @@i@@ = Number ; @@i@@ <= Number ; ++ @@i@@ ) set_uint32 ( ( _DWORD * ) ( Number L * @@i@@ + @@a2@@ ) , HIBYTE ( * ( _DWORD * ) ( @@a1@@ + Number L * @@i@@ ) ) | ( * ( _DWORD * ) ( @@a1@@ + Number L * @@i@@ ) >> Number ) & Number | ( * ( _DWORD * ) ( @@a1@@ + Number L * @@i@@ ) << Number ) & Number | ( * ( _DWORD * ) ( @@a1@@ + Number L * @@i@@ ) << Number ) ) ; return @@a2@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 __fastcall strcmp_df_mtime ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_mtime ( @@a1@@ , @@a2@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) & strcmp ) ; }
size_t __fastcall print_file_name_and_frills ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { const char * @@v2@@ ; int @@v3@@ ; const char * @@v4@@ ; int @@v5@@ ; int @@v6@@ ; size_t @@v8@@ ; char @@v9@@ [ Number ] ; unsigned __int64 @@v10@@ ; @@v10@@ = __readfsqword ( Number ) ; if ( print_inode ) { @@v2@@ = format_inode ( ( __int64 ) @@v9@@ , Number , @@a1@@ ) ; if ( format == Number ) @@v3@@ = Number ; else @@v3@@ = inode_number_width ; printf ( String , @@v3@@ , @@v2@@ ) ; } if ( print_block_size ) { if ( * ( _BYTE * ) ( @@a1@@ + Number ) != Number ) @@v4@@ = String ; else @@v4@@ = ( const char * ) human_readable ( * ( _QWORD * ) ( @@a1@@ + Number ) , @@v9@@ , ( unsigned int ) human_output_opts , Number L , output_block_size ) ; if ( format == Number ) @@v5@@ = Number ; else @@v5@@ = block_size_width ; printf ( String , @@v5@@ , @@v4@@ ) ; } if ( print_scontext ) { if ( format == Number ) @@v6@@ = Number ; else @@v6@@ = scontext_width ; printf ( String , @@v6@@ , * ( const char * * ) ( @@a1@@ + Number ) ) ; } @@v8@@ = print_name_with_quoting ( ( __int64 * ) @@a1@@ , Number , Number L , @@a2@@ ) ; if ( indicator_style ) @@v8@@ += ( unsigned __int8 ) print_type_indicator ( * ( unsigned __int8 * ) ( @@a1@@ + Number ) , * ( unsigned int * ) ( @@a1@@ + Number ) , * ( unsigned int * ) ( @@a1@@ + Number ) ) ; return @@v8@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 __fastcall dup_safer ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
__int64 __fastcall strcmp_df_atime ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_atime ( @@a1@@ , @@a2@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) & strcmp ) ; }
__int64 __fastcall order ( unsigned __int8 @@a1@@ ) { if ( ( unsigned __int8 ) c_isdigit ( @@a1@@ ) ) return Number L ; if ( ( unsigned __int8 ) c_isalpha ( @@a1@@ ) ) return @@a1@@ ; if ( @@a1@@ == Number ) return Number ; return ( unsigned int ) @@a1@@ + Number ; }
__int64 __fastcall sha256_buffer ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { char @@v5@@ [ Number ] ; unsigned __int64 @@v6@@ ; @@v6@@ = __readfsqword ( Number ) ; sha256_init_ctx ( ( __int64 ) @@v5@@ ) ; sha256_process_bytes ( @@a1@@ , @@a2@@ , @@v5@@ ) ; return sha256_finish_ctx ( ( __int64 ) @@v5@@ , @@a3@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
int setgid ( __gid_t @@gid@@ ) { return setgid ( @@gid@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 __fastcall rev_xstrcoll_df_size ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_size ( @@a2@@ , @@a1@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) xstrcoll ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
__int64 __fastcall bad_cast ( __int64 @@a1@@ ) { return @@a1@@ ; }
int ferror ( FILE * @@stream@@ ) { return ferror ( @@stream@@ ) ; }
__int64 __fastcall dup_safer ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
__int64 __fastcall rpl_wcswidth ( wchar_t * @@a1@@ , __int64 @@a2@@ ) { wchar_t * @@v2@@ ; __int64 @@v4@@ ; int @@i@@ ; int @@v8@@ ; for ( @@i@@ = Number ; ; @@i@@ += @@v8@@ ) { @@v4@@ = @@a2@@ -- ; if ( ! @@v4@@ || ! * @@a1@@ ) break ; @@v2@@ = @@a1@@ ++ ; @@v8@@ = wcwidth ( * @@v2@@ ) ; if ( @@v8@@ == Number ) return Number ; if ( @@i@@ > Number - @@v8@@ ) return Number ; } return ( unsigned int ) @@i@@ ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 __fastcall rev_strcmp_df_name ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_name ( @@a2@@ , @@a1@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) & strcmp ) ; }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
__int64 __fastcall xstrcoll_df_version ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_version ( @@a1@@ , @@a2@@ ) ; }
__int64 sysconf ( int @@name@@ ) { return sysconf ( @@name@@ ) ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
void free ( void * @@ptr@@ ) { __imp_free ( @@ptr@@ ) ; }
__int64 __fastcall argmatch ( const char * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { __int64 @@result@@ ; char @@v7@@ ; __int64 @@i@@ ; __int64 @@v9@@ ; size_t @@n@@ ; @@v9@@ = Number ; @@v7@@ = Number ; @@n@@ = strlen ( @@a1@@ ) ; for ( @@i@@ = Number L ; * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; ++ @@i@@ ) { if ( ! strncmp ( * ( const char * * ) ( Number * @@i@@ + @@a2@@ ) , @@a1@@ , @@n@@ ) ) { if ( @@n@@ == strlen ( * ( const char * * ) ( Number * @@i@@ + @@a2@@ ) ) ) return @@i@@ ; if ( @@v9@@ == Number ) { @@v9@@ = @@i@@ ; } else if ( ! @@a3@@ || memcmp ( ( const void * ) ( @@a4@@ * @@v9@@ + @@a3@@ ) , ( const void * ) ( @@i@@ * @@a4@@ + @@a3@@ ) , @@a4@@ ) ) { @@v7@@ = Number ; } } } if ( @@v7@@ ) @@result@@ = Number ; else @@result@@ = @@v9@@ ; return @@result@@ ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
__int64 __fastcall format_user_or_group ( const char * @@a1@@ , __int64 @@a2@@ , int @@a3@@ ) { int @@v3@@ ; __int64 @@result@@ ; int @@v7@@ ; int @@v8@@ ; size_t @@v9@@ ; if ( @@a1@@ ) { @@v8@@ = @@a3@@ - gnu_mbswidth ( @@a1@@ , Number L ) ; @@v3@@ = Number ; if ( @@v8@@ >= Number ) @@v3@@ = @@v8@@ ; @@v7@@ = @@v3@@ ; fputs_unlocked ( @@a1@@ , stdout ) ; @@v9@@ = strlen ( @@a1@@ ) + @@v7@@ ; do putchar_unlocked ( Number ) ; while ( @@v7@@ -- ) ; } else { printf ( String , @@a3@@ , @@a2@@ ) ; @@v9@@ = @@a3@@ ; } @@result@@ = dired_pos + @@v9@@ + Number ; dired_pos = @@result@@ ; return @@result@@ ; }
bool __fastcall is_basic ( unsigned __int8 @@a1@@ ) { return ( ( * ( ( _DWORD * ) & is_basic_table + ( @@a1@@ >> Number ) ) >> ( @@a1@@ & Number ) ) & Number ) != Number ; }
__int64 __fastcall ftypelet ( __int16 @@a1@@ ) { switch ( @@a1@@ & Number ) { case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; } return Number L ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
void * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * @@v4@@ ; void * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * @@v12@@ ; void * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == ( __int64 * ) & slotvec0 ; if ( slotvec == ( __int64 * ) & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = off_208028 ; * @@v12@@ = ( __int64 ) slotvec0 ; @@v12@@ [ Number ] = ( __int64 ) @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = ( void * ) @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = @@v17@@ + Number ; if ( @@ptr@@ != & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( void * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = ( __int64 ) @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
size_t __fastcall format_group_width ( unsigned int @@a1@@ ) { __int64 @@v1@@ ; if ( numeric_ids ) @@v1@@ = Number L ; else @@v1@@ = getgroup ( @@a1@@ ) ; return format_user_or_group_width ( @@v1@@ , @@a1@@ ) ; }
void * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
_DWORD * __fastcall get_input_fstatus ( int @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; int @@v3@@ ; int @@i@@ ; _DWORD * @@v6@@ ; if ( @@a1@@ ) @@v2@@ = @@a1@@ ; else @@v2@@ = Number L ; @@v6@@ = ( _DWORD * ) xnmalloc ( @@v2@@ , Number L ) ; if ( ! @@a1@@ || @@a1@@ == Number && ( unsigned __int8 ) print_bytes + ( unsigned __int8 ) print_chars + ( unsigned __int8 ) print_words + ( unsigned __int8 ) print_lines + ( unsigned __int8 ) print_linelength == Number ) { * @@v6@@ = Number ; } else { for ( @@i@@ = Number ; @@i@@ < @@a1@@ ; ++ @@i@@ ) { if ( * ( _QWORD * ) ( Number L * @@i@@ + @@a2@@ ) && strcmp ( * ( const char * * ) ( Number L * @@i@@ + @@a2@@ ) , String ) ) { @@v3@@ = stat ( * ( char * * ) ( Number L * @@i@@ + @@a2@@ ) , ( struct stat * ) & @@v6@@ [ Number * @@i@@ + Number ] ) ; } else { @@v3@@ = fstat ( Number , ( struct stat * ) & @@v6@@ [ Number * @@i@@ + Number ] ) ; } @@v6@@ [ Number * @@i@@ ] = @@v3@@ ; } } return @@v6@@ ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
__int64 __fastcall file_name_concat ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v4@@ ; @@v4@@ = mfile_name_concat ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( ! @@v4@@ ) xalloc_die ( ) ; return @@v4@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return xmalloc ( @@a1@@ , @@a2@@ , @@a3@@ ) ; }
bool __fastcall print_type_indicator ( char @@a1@@ , __int16 @@a2@@ , int @@a3@@ ) { char @@v4@@ ; @@v4@@ = get_type_indicator ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( @@v4@@ ) { putchar_unlocked ( @@v4@@ ) ; ++ dired_pos ; } return @@v4@@ != Number ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
__int64 __fastcall hash_get_n_buckets_used ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
__int64 __fastcall length_of_file_name_and_frills ( __int64 @@a1@@ ) { const char * @@v1@@ ; __int64 @@v2@@ ; const char * @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; char @@v7@@ ; size_t @@v8@@ ; __int64 @@v9@@ ; char @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; if ( print_inode ) { if ( format == Number ) { @@v1@@ = ( const char * ) umaxtostr ( * ( _QWORD * ) ( @@a1@@ + Number ) , @@v10@@ ) ; @@v2@@ = strlen ( @@v1@@ ) + Number ; } else { @@v2@@ = inode_number_width + Number L ; } @@v9@@ += @@v2@@ ; } if ( print_block_size ) { if ( format == Number ) { if ( * ( _BYTE * ) ( @@a1@@ + Number ) != Number ) @@v3@@ = String ; else @@v3@@ = ( const char * ) human_readable ( * ( _QWORD * ) ( @@a1@@ + Number ) , @@v10@@ , ( unsigned int ) human_output_opts , Number L , output_block_size ) ; @@v4@@ = strlen ( @@v3@@ ) + Number ; } else { @@v4@@ = block_size_width + Number L ; } @@v9@@ += @@v4@@ ; } if ( print_scontext ) { if ( format == Number ) @@v5@@ = strlen ( * ( const char * * ) ( @@a1@@ + Number ) ) + Number ; else @@v5@@ = scontext_width + Number L ; @@v9@@ += @@v5@@ ; } quote_name ( Number L , * ( _QWORD * ) @@a1@@ , filename_quoting_options , & @@v8@@ ) ; @@v9@@ += @@v8@@ ; if ( indicator_style ) { @@v7@@ = get_type_indicator ( * ( _BYTE * ) ( @@a1@@ + Number ) , * ( _DWORD * ) ( @@a1@@ + Number ) , * ( _DWORD * ) ( @@a1@@ + Number ) ) ; @@v9@@ += @@v7@@ != Number ; } return @@v9@@ ; }
__int64 __fastcall bkm_scale_by_power ( unsigned __int64 * @@a1@@ , int @@a2@@ , int @@a3@@ ) { unsigned int @@i@@ ; for ( @@i@@ = Number ; @@a3@@ -- ; @@i@@ |= bkm_scale ( @@a1@@ , @@a2@@ ) ) { ; } return @@i@@ ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , off_7496 , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
int __fastcall hash_print_statistics ( __int64 @@a1@@ , FILE * @@a2@@ ) { double @@v2@@ ; double @@v3@@ ; double @@v4@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v6@@ = hash_get_n_entries ( @@a1@@ ) ; @@v7@@ = hash_get_n_buckets ( @@a1@@ ) ; @@v8@@ = hash_get_n_buckets_used ( @@a1@@ ) ; @@v9@@ = hash_get_max_bucket_length ( @@a1@@ ) ; fprintf ( @@a2@@ , String , @@v6@@ ) ; fprintf ( @@a2@@ , String , @@v7@@ ) ; if ( @@v8@@ < Number ) @@v2@@ = ( double ) ( int ) ( @@v8@@ & Number | ( ( unsigned __int64 ) @@v8@@ >> Number ) ) + ( double ) ( int ) ( @@v8@@ & Number | ( ( unsigned __int64 ) @@v8@@ >> Number ) ) ; else @@v2@@ = ( double ) ( int ) @@v8@@ ; @@v3@@ = Number * @@v2@@ ; if ( @@v7@@ < Number ) @@v4@@ = ( double ) ( int ) ( @@v7@@ & Number | ( ( unsigned __int64 ) @@v7@@ >> Number ) ) + ( double ) ( int ) ( @@v7@@ & Number | ( ( unsigned __int64 ) @@v7@@ >> Number ) ) ; else @@v4@@ = ( double ) ( int ) @@v7@@ ; fprintf ( @@a2@@ , String , @@v8@@ , @@v3@@ / @@v4@@ ) ; return fprintf ( @@a2@@ , String , @@v9@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_206028 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
_BYTE * __fastcall attach ( _BYTE * @@a1@@ , _BYTE * @@a2@@ , _BYTE * @@a3@@ ) { _BYTE * @@v3@@ ; _BYTE * @@v4@@ ; _BYTE * @@v5@@ ; _BYTE * @@v6@@ ; _BYTE * @@v7@@ ; _BYTE * @@result@@ ; _BYTE * @@v11@@ ; @@v11@@ = @@a2@@ ; if ( * @@a2@@ != Number || @@a2@@ [ Number ] ) { while ( * @@v11@@ ) { @@v3@@ = @@v11@@ ++ ; @@v4@@ = @@a1@@ ++ ; * @@v4@@ = * @@v3@@ ; } if ( @@v11@@ > @@a2@@ && * ( @@v11@@ - Number ) != Number ) { @@v5@@ = @@a1@@ ++ ; * @@v5@@ = Number ; } } while ( * @@a3@@ ) { @@v6@@ = @@a3@@ ++ ; @@v7@@ = @@a1@@ ++ ; * @@v7@@ = * @@v6@@ ; } @@result@@ = @@a1@@ ; * @@a1@@ = Number ; return @@result@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
int clock_gettime ( clockid_t @@clock_id@@ , struct timespec * @@tp@@ ) { return clock_gettime ( @@clock_id@@ , @@tp@@ ) ; }
__int64 __fastcall check_tuning ( __int64 @@a1@@ ) { __int64 @@v2@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( ( _UNKNOWN * ) @@v2@@ == & default_tuning ) return Number L ; if ( * ( float * ) ( @@v2@@ + Number ) > Number && ( float ) ( Number - Number ) > * ( float * ) ( @@v2@@ + Number ) && * ( float * ) ( @@v2@@ + Number ) > ( float ) ( Number + Number ) && * ( float * ) @@v2@@ >= Number && * ( float * ) ( @@v2@@ + Number ) > ( float ) ( * ( float * ) @@v2@@ + Number ) && * ( float * ) ( @@v2@@ + Number ) <= Number && * ( float * ) ( @@v2@@ + Number ) > ( float ) ( * ( float * ) @@v2@@ + Number ) ) { return Number L ; } * ( _QWORD * ) ( @@a1@@ + Number ) = & default_tuning ; return Number L ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
int closedir ( DIR * @@dirp@@ ) { return closedir ( @@dirp@@ ) ; }
_BYTE * __fastcall match_suffix ( _BYTE * * @@a1@@ ) { char @@v2@@ ; _BYTE * @@v3@@ ; @@v3@@ = Number L ; @@v2@@ = Number ; while ( * * @@a1@@ ) { if ( @@v2@@ ) { @@v2@@ = Number ; if ( ( unsigned __int8 ) c_isalpha ( ( unsigned int ) ( char ) * * @@a1@@ ) != Number && * * @@a1@@ != Number ) { @@v3@@ = Number L ; } } else if ( * * @@a1@@ == Number ) { @@v2@@ = Number ; if ( ! @@v3@@ ) @@v3@@ = * @@a1@@ ; } else if ( ( unsigned __int8 ) c_isalnum ( ( unsigned int ) ( char ) * * @@a1@@ ) != Number && * * @@a1@@ != Number ) { @@v3@@ = Number L ; } ++ * @@a1@@ ; } return @@v3@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
int sigemptyset ( sigset_t * @@set@@ ) { return sigemptyset ( @@set@@ ) ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
void __fastcall hash_free ( __int64 @@a1@@ ) { _QWORD * @@i@@ ; _QWORD * @@j@@ ; _QWORD * @@ptr@@ ; _QWORD * @@ptra@@ ; _QWORD * @@ptrb@@ ; _QWORD * @@v6@@ ; _QWORD * @@v7@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) && * ( _QWORD * ) ( @@a1@@ + Number ) ) { for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@ptr@@ = @@i@@ ; @@ptr@@ ; @@ptr@@ = ( _QWORD * ) @@ptr@@ [ Number ] ) { ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@ptr@@ ) ; } } } } for ( @@j@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@j@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@j@@ += Number ) { for ( @@ptra@@ = ( _QWORD * ) @@j@@ [ Number ] ; @@ptra@@ ; @@ptra@@ = @@v6@@ ) { @@v6@@ = ( _QWORD * ) @@ptra@@ [ Number ] ; free ( @@ptra@@ ) ; } } for ( @@ptrb@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; @@ptrb@@ ; @@ptrb@@ = @@v7@@ ) { @@v7@@ = ( _QWORD * ) @@ptrb@@ [ Number ] ; free ( @@ptrb@@ ) ; } free ( * ( void * * ) @@a1@@ ) ; free ( ( void * ) @@a1@@ ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
int __xstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _xstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
__int64 __fastcall verrevcmp ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , unsigned __int64 @@a4@@ ) { int @@v4@@ ; int @@v5@@ ; unsigned int @@v9@@ ; int @@v10@@ ; unsigned __int64 @@v11@@ ; unsigned __int64 @@v12@@ ; @@v11@@ = Number L ; @@v12@@ = Number L ; while ( @@v11@@ < @@a2@@ || @@v12@@ < @@a4@@ ) { @@v9@@ = Number ; while ( @@v11@@ < @@a2@@ && ( unsigned __int8 ) c_isdigit ( ( unsigned int ) * ( char * ) ( @@a1@@ + @@v11@@ ) ) != Number || @@v12@@ < @@a4@@ && ( unsigned __int8 ) c_isdigit ( ( unsigned int ) * ( char * ) ( @@a3@@ + @@v12@@ ) ) != Number ) { if ( @@v11@@ == @@a2@@ ) @@v4@@ = Number ; else @@v4@@ = order ( * ( _BYTE * ) ( @@a1@@ + @@v11@@ ) ) ; @@v10@@ = @@v4@@ ; if ( @@v12@@ == @@a4@@ ) @@v5@@ = Number ; else @@v5@@ = order ( * ( _BYTE * ) ( @@a3@@ + @@v12@@ ) ) ; if ( @@v10@@ != @@v5@@ ) return ( unsigned int ) ( @@v10@@ - @@v5@@ ) ; ++ @@v11@@ ; ++ @@v12@@ ; } while ( * ( _BYTE * ) ( @@a1@@ + @@v11@@ ) == Number ) ++ @@v11@@ ; while ( * ( _BYTE * ) ( @@a3@@ + @@v12@@ ) == Number ) ++ @@v12@@ ; while ( ( unsigned __int8 ) c_isdigit ( ( unsigned int ) * ( char * ) ( @@a1@@ + @@v11@@ ) ) && ( unsigned __int8 ) c_isdigit ( ( unsigned int ) * ( char * ) ( @@a3@@ + @@v12@@ ) ) ) { if ( ! @@v9@@ ) @@v9@@ = * ( char * ) ( @@a1@@ + @@v11@@ ) - * ( char * ) ( @@a3@@ + @@v12@@ ) ; ++ @@v11@@ ; ++ @@v12@@ ; } if ( ( unsigned __int8 ) c_isdigit ( ( unsigned int ) * ( char * ) ( @@a1@@ + @@v11@@ ) ) ) return Number L ; if ( ( unsigned __int8 ) c_isdigit ( ( unsigned int ) * ( char * ) ( @@a3@@ + @@v12@@ ) ) ) return Number ; if ( @@v9@@ ) return @@v9@@ ; } return Number L ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
void free ( void * @@ptr@@ ) { __imp_free ( @@ptr@@ ) ; }
char * __fastcall group_number ( char * @@a1@@ , size_t @@a2@@ , unsigned __int8 * @@a3@@ , const char * @@a4@@ ) { char * @@i@@ ; size_t @@v5@@ ; char * @@v6@@ ; unsigned __int8 @@v10@@ ; size_t @@v11@@ ; size_t @@v12@@ ; size_t @@v13@@ ; char @@dest@@ [ Number ] ; unsigned __int64 @@v15@@ ; @@v15@@ = __readfsqword ( Number ) ; @@v11@@ = Number ; @@v13@@ = strlen ( @@a4@@ ) ; @@v12@@ = @@a2@@ ; memcpy ( @@dest@@ , @@a1@@ , @@a2@@ ) ; for ( @@i@@ = & @@a1@@ [ @@a2@@ ] ; ; memcpy ( @@i@@ , @@a4@@ , @@v13@@ ) ) { @@v10@@ = * @@a3@@ ; if ( * @@a3@@ ) { if ( @@v10@@ > Number ) @@v5@@ = @@v12@@ ; else @@v5@@ = @@v10@@ ; @@v11@@ = @@v5@@ ; ++ @@a3@@ ; } if ( @@v12@@ < @@v11@@ ) @@v11@@ = @@v12@@ ; @@v6@@ = & @@i@@ [ - @@v11@@ ] ; @@v12@@ -= @@v11@@ ; memcpy ( @@v6@@ , & @@dest@@ [ @@v12@@ ] , @@v11@@ ) ; if ( ! @@v12@@ ) break ; @@i@@ = & @@v6@@ [ - @@v13@@ ] ; } return @@v6@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
void __fastcall argmatch_invalid ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { char * @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; char * @@format@@ ; if ( @@a3@@ == Number ) @@v3@@ = gettext ( String ) ; else @@v3@@ = gettext ( String ) ; @@format@@ = @@v3@@ ; @@v4@@ = quote_n ( Number L , @@a1@@ ) ; @@v5@@ = quotearg_n_style ( Number L , Number L , @@a2@@ ) ; error ( Number , Number , @@format@@ , @@v5@@ , @@v4@@ ) ; }
__int64 __fastcall get_stat_atime ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
char * nl_langinfo ( nl_item @@item@@ ) { return nl_langinfo ( @@item@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
__int64 __fastcall getgroup ( __gid_t @@a1@@ ) { const char * @@v1@@ ; size_t @@v2@@ ; __int64 @@result@@ ; __int64 @@i@@ ; __int64 @@v5@@ ; struct group * @@v6@@ ; char * @@s@@ ; @@v5@@ = Number L ; for ( @@i@@ = group_alist ; @@i@@ ; @@i@@ = * ( _QWORD * ) ( @@i@@ + Number ) ) { if ( @@a1@@ == * ( _DWORD * ) @@i@@ ) { @@v5@@ = @@i@@ ; break ; } } if ( ! @@v5@@ ) { @@v6@@ = getgrgid ( @@a1@@ ) ; if ( @@v6@@ ) @@v1@@ = @@v6@@ -> gr_name ; else @@v1@@ = ( const char * ) & unk_19CC0 ; @@s@@ = ( char * ) @@v1@@ ; @@v2@@ = strlen ( @@v1@@ ) ; @@v5@@ = xmalloc ( @@v2@@ + Number ) ; * ( _DWORD * ) @@v5@@ = @@a1@@ ; strcpy ( ( char * ) ( @@v5@@ + Number ) , @@s@@ ) ; * ( _QWORD * ) ( @@v5@@ + Number ) = group_alist ; group_alist = @@v5@@ ; } if ( * ( _BYTE * ) ( @@v5@@ + Number ) ) @@result@@ = @@v5@@ + Number ; else @@result@@ = Number L ; return @@result@@ ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
_BOOL8 __fastcall dev_ino_compare ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { return * @@a1@@ == * @@a2@@ && @@a1@@ [ Number ] == @@a2@@ [ Number ] ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void * __fastcall mfile_name_concat ( _BYTE * @@a1@@ , _BYTE * @@a2@@ , _QWORD * @@a3@@ ) { _BOOL4 @@v3@@ ; const char * @@v6@@ ; size_t @@v7@@ ; size_t @@n@@ ; _BOOL8 @@v9@@ ; char * @@s@@ ; size_t @@v11@@ ; void * @@dest@@ ; _BYTE * @@v13@@ ; char * @@v14@@ ; @@v6@@ = last_component ( @@a1@@ ) ; @@v7@@ = base_len ( @@v6@@ ) ; @@n@@ = @@v6@@ - @@a1@@ + @@v7@@ ; @@v3@@ = @@v7@@ && @@v6@@ [ @@v7@@ - Number ] != Number ; @@v9@@ = @@v3@@ ; @@s@@ = longest_relative_suffix ( @@a2@@ ) ; @@v11@@ = strlen ( @@s@@ ) ; @@dest@@ = malloc ( @@v9@@ + @@n@@ + @@v11@@ + Number ) ; if ( ! @@dest@@ ) return Number L ; @@v13@@ = mempcpy ( @@dest@@ , @@a1@@ , @@n@@ ) ; * @@v13@@ = Number ; @@v14@@ = & @@v13@@ [ @@v9@@ ] ; if ( @@a3@@ ) * @@a3@@ = & @@v14@@ [ - ( * @@a2@@ == Number ) ] ; * ( _BYTE * ) mempcpy ( @@v14@@ , @@s@@ , @@v11@@ ) = Number ; return @@dest@@ ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
unsigned __int64 process_signals ( ) { int @@sig@@ ; sigset_t @@oset@@ ; unsigned __int64 @@v3@@ ; @@v3@@ = __readfsqword ( Number ) ; while ( interrupt_signal || stop_signal_count ) { if ( used_color ) restore_default_color ( ) ; fflush_unlocked ( stdout ) ; sigprocmask ( Number , & caught_signals , & @@oset@@ ) ; @@sig@@ = interrupt_signal ; if ( stop_signal_count ) { -- stop_signal_count ; raise ( Number ) ; } else { signal ( interrupt_signal , Number L ) ; raise ( @@sig@@ ) ; } sigprocmask ( Number , & @@oset@@ , Number L ) ; } return __readfsqword ( Number ) ^ @@v3@@ ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
__int64 __fastcall hash_get_first ( unsigned __int64 * @@a1@@ ) { unsigned __int64 @@i@@ ; if ( ! @@a1@@ [ Number ] ) return Number L ; for ( @@i@@ = * @@a1@@ ; ; @@i@@ += Number L ) { if ( @@i@@ >= @@a1@@ [ Number ] ) abort ( ) ; if ( * ( _QWORD * ) @@i@@ ) break ; } return * ( _QWORD * ) @@i@@ ; }
__int64 __fastcall xnrealloc ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { if ( ! is_mul_ok ( @@a3@@ , @@a2@@ ) ) xalloc_die ( ) ; return xrealloc ( @@a1@@ , @@a3@@ * @@a2@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall unsigned_file_size ( __int64 @@a1@@ ) { return @@a1@@ ; }
_QWORD * __fastcall set_hhmmss ( _QWORD * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ ) { _QWORD * @@result@@ ; @@a1@@ [ Number ] = @@a2@@ ; @@a1@@ [ Number ] = @@a3@@ ; @@a1@@ [ Number ] = @@a4@@ ; @@result@@ = @@a1@@ ; @@a1@@ [ Number ] = @@a5@@ ; return @@result@@ ; }
__int64 __fastcall cmp_ctime ( _QWORD * @@a1@@ , _QWORD * @@a2@@ , __int64 ( __fastcall * @@a3@@ ( ) ( constchar , constchar ) ) ( _QWORD , _QWORD ) ) { __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@result@@ ; unsigned int @@v10@@ ; @@v3@@ = get_stat_ctime ( ( __int64 ) ( @@a1@@ + Number ) ) ; @@v5@@ = @@v4@@ ; @@v6@@ = get_stat_ctime ( ( __int64 ) ( @@a2@@ + Number ) ) ; @@v10@@ = timespec_cmp ( @@v6@@ , @@v7@@ , @@v3@@ , @@v5@@ ) ; if ( @@v10@@ ) @@result@@ = @@v10@@ ; else @@result@@ = @@a3@@ ( ) ( constchar , constchar ) ( * @@a1@@ , * @@a2@@ ) ; return @@result@@ ; }
__int64 __fastcall hash_do_for_each ( __int64 @@a1@@ , unsigned __int8 ( __fastcall * @@a2@@ ) ( _QWORD , __int64 ) , __int64 @@a3@@ ) { __int64 @@v5@@ ; _QWORD * @@i@@ ; _QWORD * @@j@@ ; @@v5@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = @@i@@ ; @@j@@ ; @@j@@ = ( _QWORD * ) @@j@@ [ Number ] ) { if ( @@a2@@ ( * @@j@@ , @@a3@@ ) != Number ) return @@v5@@ ; ++ @@v5@@ ; } } } return @@v5@@ ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@v2@@ ; @@v2@@ = malloc ( @@a1@@ ) ; if ( ! @@v2@@ && @@a1@@ ) xalloc_die ( ) ; return @@v2@@ ; }
__int64 __fastcall cmp_name ( _QWORD * @@a1@@ , _QWORD * @@a2@@ , __int64 ( __fastcall * @@a3@@ ( ) ( constchar , constchar ) ) ( _QWORD , _QWORD ) ) { return @@a3@@ ( ) ( constchar , constchar ) ( * @@a1@@ , * @@a2@@ ) ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
unsigned __int64 __fastcall compute_bucket_size ( __int64 @@a1@@ , __int64 @@a2@@ ) { float @@v2@@ ; unsigned __int64 @@result@@ ; unsigned __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; float @@v6@@ ; @@v4@@ = @@a1@@ ; if ( * ( _BYTE * ) ( @@a2@@ + Number ) != Number ) { if ( @@a1@@ < Number ) @@v2@@ = ( float ) ( @@a1@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@a1@@ >> Number ) ) + ( float ) ( @@a1@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@a1@@ >> Number ) ) ; else @@v2@@ = ( float ) ( int ) @@a1@@ ; @@v6@@ = @@v2@@ / * ( float * ) ( @@a2@@ + Number ) ; if ( @@v6@@ >= Number ) return Number L ; if ( @@v6@@ >= Number ) @@v4@@ = ( unsigned int ) ( int ) ( float ) ( @@v6@@ - Number ) ^ Number ; else @@v4@@ = ( unsigned int ) ( int ) @@v6@@ ; } @@v5@@ = next_prime ( @@v4@@ ) ; if ( @@v5@@ <= Number ) @@result@@ = @@v5@@ ; else @@result@@ = Number L ; return @@result@@ ; }
__int64 __fastcall to_hour ( __int64 @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( @@a2@@ ) { if ( @@a2@@ == Number ) { if ( @@a1@@ <= Number || @@a1@@ > Number ) { if ( @@a1@@ == Number ) @@result@@ = Number L ; else @@result@@ = Number ; } else { @@result@@ = ( unsigned int ) ( @@a1@@ + Number ) ; } } else if ( @@a1@@ < Number || @@a1@@ > Number ) { @@result@@ = Number ; } else { @@result@@ = @@a1@@ ; } } else if ( @@a1@@ > Number && @@a1@@ <= Number ) { @@result@@ = @@a1@@ ; } else if ( @@a1@@ == Number ) { @@result@@ = Number L ; } else { @@result@@ = Number ; } return @@result@@ ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 __fastcall cmp_extension ( const char * * @@a1@@ , const char * * @@a2@@ , __int64 ( __fastcall * @@a3@@ ( ) ( constchar , constchar ) ) ( const char * , const char * ) ) { const char * @@v3@@ ; const char * @@v4@@ ; __int64 @@result@@ ; unsigned int @@v7@@ ; char * @@v8@@ ; char * @@v9@@ ; @@v8@@ = strrchr ( * @@a1@@ , Number ) ; @@v9@@ = strrchr ( * @@a2@@ , Number ) ; if ( @@v9@@ ) @@v3@@ = @@v9@@ ; else @@v3@@ = & off_16E97 [ Number ] ; if ( @@v8@@ ) @@v4@@ = @@v8@@ ; else @@v4@@ = & off_16E97 [ Number ] ; @@v7@@ = @@a3@@ ( ) ( constchar , constchar ) ( @@v4@@ , @@v3@@ ) ; if ( @@v7@@ ) @@result@@ = @@v7@@ ; else @@result@@ = @@a3@@ ( ) ( constchar , constchar ) ( * @@a1@@ , * @@a2@@ ) ; return @@result@@ ; }
int chroot ( const char * @@path@@ ) { return chroot ( @@path@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
const char * __fastcall get_tz ( void * @@a1@@ ) { const char * @@v1@@ ; const char * @@s@@ ; size_t @@n@@ ; @@s@@ = getenv ( String ) ; if ( @@s@@ ) { @@n@@ = strlen ( @@s@@ ) + Number ; if ( @@n@@ > Number ) @@v1@@ = ( const char * ) xmemdup ( @@s@@ , @@n@@ ) ; else @@v1@@ = ( const char * ) memcpy ( @@a1@@ , @@s@@ , @@n@@ ) ; @@s@@ = @@v1@@ ; } return @@s@@ ; }
__int64 __fastcall free_entry ( __int64 @@a1@@ , _QWORD * @@a2@@ ) { __int64 @@result@@ ; * @@a2@@ = Number L ; @@a2@@ [ Number ] = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@result@@ = @@a1@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
int chdir ( const char * @@path@@ ) { return chdir ( @@path@@ ) ; }
__int64 __fastcall xstrcoll_df_mtime ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_mtime ( @@a1@@ , @@a2@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) xstrcoll ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
void __fastcall argmatch_invalid ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { char * @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; char * @@format@@ ; if ( @@a3@@ == Number ) @@v3@@ = gettext ( String ) ; else @@v3@@ = gettext ( String ) ; @@format@@ = @@v3@@ ; @@v4@@ = quote_n ( Number L , @@a1@@ ) ; @@v5@@ = quotearg_n_style ( Number L , Number L , @@a2@@ ) ; error ( Number , Number , @@format@@ , @@v5@@ , @@v4@@ ) ; }
struct group * getgrgid ( __gid_t @@gid@@ ) { return getgrgid ( @@gid@@ ) ; }
__int64 __fastcall memcpy_lowcase ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { while ( @@a3@@ -- ) * ( _BYTE * ) ( @@a1@@ + @@a3@@ ) = tolower ( * ( unsigned __int8 * ) ( @@a2@@ + @@a3@@ ) ) ; return @@a1@@ ; }
__int64 __fastcall rev_strcmp_df_atime ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_atime ( @@a2@@ , @@a1@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) & strcmp ) ; }
struct passwd * getpwnam ( const char * @@name@@ ) { return getpwnam ( @@name@@ ) ; }
__int64 __fastcall nstrftime ( char * @@a1@@ , __int64 @@a2@@ , char * @@a3@@ , __int64 @@a4@@ , int @@a5@@ , int @@a6@@ ) { return strftime_case_ ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
__int64 __fastcall _xargmatch_internal ( __int64 @@a1@@ , const char * @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ , void ( * @@a6@@ ) ( void ) ) { __int64 @@v11@@ ; @@v11@@ = argmatch ( @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; if ( @@v11@@ >= Number ) return @@v11@@ ; argmatch_invalid ( @@a1@@ , ( __int64 ) @@a2@@ , @@v11@@ ) ; argmatch_valid ( @@a3@@ , @@a4@@ , @@a5@@ ) ; @@a6@@ ( ) ; return Number ; }
__int64 __fastcall hash_find_entry ( __int64 @@a1@@ , __int64 @@a2@@ , _QWORD * @@a3@@ , char @@a4@@ ) { __int64 @@v4@@ ; __int64 @@result@@ ; __int64 @@v6@@ ; _QWORD * @@i@@ ; _QWORD * @@v10@@ ; __int64 @@v11@@ ; _QWORD * @@v12@@ ; __int64 @@v13@@ ; _QWORD * @@v14@@ ; @@v4@@ = * ( _QWORD * ) @@a1@@ ; @@v10@@ = ( _QWORD * ) ( @@v4@@ + Number * ( * ( __int64 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@a2@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@v10@@ >= * ( _QWORD * ) ( @@a1@@ + Number ) ) abort ( ) ; * @@a3@@ = @@v10@@ ; if ( ! * @@v10@@ ) return Number L ; if ( @@a2@@ == * @@v10@@ || ( * ( unsigned __int8 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@a2@@ , * @@v10@@ ) ) { @@v13@@ = * @@v10@@ ; if ( @@a4@@ ) { if ( @@v10@@ [ Number ] ) { @@v14@@ = ( _QWORD * ) @@v10@@ [ Number ] ; @@v6@@ = @@v14@@ [ Number ] ; * @@v10@@ = * @@v14@@ ; @@v10@@ [ Number ] = @@v6@@ ; free_entry ( @@a1@@ , @@v14@@ ) ; } else { * @@v10@@ = Number L ; } } @@result@@ = @@v13@@ ; } else { for ( @@i@@ = @@v10@@ ; ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { if ( ! @@i@@ [ Number ] ) return Number L ; if ( @@a2@@ == * ( _QWORD * ) @@i@@ [ Number ] || ( * ( unsigned __int8 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@a2@@ , * ( _QWORD * ) @@i@@ [ Number ] ) ) { break ; } } @@v11@@ = * ( _QWORD * ) @@i@@ [ Number ] ; if ( @@a4@@ ) { @@v12@@ = ( _QWORD * ) @@i@@ [ Number ] ; @@i@@ [ Number ] = @@v12@@ [ Number ] ; free_entry ( @@a1@@ , @@v12@@ ) ; } @@result@@ = @@v11@@ ; } return @@result@@ ; }
__int64 __fastcall xstrcoll_df_name ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_name ( @@a1@@ , @@a2@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) xstrcoll ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@v2@@ ; @@v2@@ = malloc ( @@a1@@ ) ; if ( ! @@v2@@ && @@a1@@ ) xalloc_die ( ) ; return @@v2@@ ; }
__int64 __fastcall fwrite_uppcase ( FILE * @@a1@@ , unsigned __int8 * @@a2@@ , __int64 @@a3@@ ) { int @@v3@@ ; __int64 @@result@@ ; while ( Number ) { @@result@@ = @@a3@@ -- ; if ( ! @@result@@ ) break ; @@v3@@ = toupper ( * @@a2@@ ) ; fputc ( @@v3@@ , @@a1@@ ) ; ++ @@a2@@ ; } return @@result@@ ; }
__int64 default_block_size ( ) { __int64 @@result@@ ; if ( getenv ( String ) ) @@result@@ = Number L ; else @@result@@ = Number L ; return @@result@@ ; }
__int64 __fastcall xstrcoll_df_extension ( const char * * @@a1@@ , const char * * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_extension ( @@a1@@ , @@a2@@ , xstrcoll ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( is_mul_ok ( @@a2@@ , * @@a1@@ ) ) { * @@a1@@ *= @@a2@@ ; @@result@@ = Number L ; } else { * @@a1@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall rev_xstrcoll_df_version ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_version ( @@a2@@ , @@a1@@ ) ; }
__int64 __fastcall getuidbyname ( const char * @@a1@@ ) { __int64 @@result@@ ; size_t @@v2@@ ; __int64 @@i@@ ; __int64 @@j@@ ; __int64 @@v5@@ ; struct passwd * @@v6@@ ; for ( @@i@@ = user_alist ; @@i@@ ; @@i@@ = * ( _QWORD * ) ( @@i@@ + Number ) ) { if ( * ( _BYTE * ) ( @@i@@ + Number ) == * @@a1@@ && ! strcmp ( ( const char * ) ( @@i@@ + Number ) , @@a1@@ ) ) { return @@i@@ ; } } for ( @@j@@ = nouser_alist ; @@j@@ ; @@j@@ = * ( _QWORD * ) ( @@j@@ + Number ) ) { if ( * ( _BYTE * ) ( @@j@@ + Number ) == * @@a1@@ && ! strcmp ( ( const char * ) ( @@j@@ + Number ) , @@a1@@ ) ) { return Number L ; } } @@v6@@ = getpwnam ( @@a1@@ ) ; @@v2@@ = strlen ( @@a1@@ ) ; @@v5@@ = xmalloc ( @@v2@@ + Number ) ; strcpy ( ( char * ) ( @@v5@@ + Number ) , @@a1@@ ) ; if ( @@v6@@ ) { * ( _DWORD * ) @@v5@@ = @@v6@@ -> pw_uid ; * ( _QWORD * ) ( @@v5@@ + Number ) = user_alist ; user_alist = @@v5@@ ; @@result@@ = @@v5@@ ; } else { * ( _QWORD * ) ( @@v5@@ + Number ) = nouser_alist ; nouser_alist = @@v5@@ ; @@result@@ = Number L ; } return @@result@@ ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; FILE * @@v10@@ ; char * @@v11@@ ; FILE * @@v12@@ ; char * @@v13@@ ; FILE * @@v14@@ ; char * @@v15@@ ; if ( @@a1@@ ) { @@v1@@ = program_name ; @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = program_name ; @@v4@@ = program_name ; @@v5@@ = gettext ( String ) ; printf ( @@v5@@ , @@v4@@ , @@v3@@ ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; @@v8@@ = stdout ; @@v9@@ = gettext ( String String ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = stdout ; @@v11@@ = gettext ( String ) ; fputs_unlocked ( @@v11@@ , @@v10@@ ) ; @@v12@@ = stdout ; @@v13@@ = gettext ( String ) ; fputs_unlocked ( @@v13@@ , @@v12@@ ) ; @@v14@@ = stdout ; @@v15@@ = gettext ( String ) ; fputs_unlocked ( @@v15@@ , @@v14@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
__int64 __fastcall posixtime ( time_t * @@a1@@ , const char * @@a2@@ , unsigned int @@a3@@ ) { time_t @@timer@@ ; char @@v6@@ [ Number ] ; struct tm * @@v7@@ ; char * @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; __int64 @@v12@@ ; __int64 @@v13@@ ; __int64 @@v14@@ ; const char * @@v15@@ ; struct tm @@tp@@ ; char @@dest@@ [ Number ] ; unsigned __int64 @@v18@@ ; @@v18@@ = __readfsqword ( Number ) ; if ( ( unsigned int ) posix_time_parse ( & @@v9@@ , @@a2@@ , @@a3@@ ) ) return Number L ; * ( _QWORD * ) & @@tp@@ . tm_sec = @@v9@@ ; * ( _QWORD * ) & @@tp@@ . tm_hour = @@v10@@ ; * ( _QWORD * ) & @@tp@@ . tm_mon = @@v11@@ ; * ( _QWORD * ) & @@tp@@ . tm_wday = @@v12@@ ; * ( & @@tp@@ . tm_isdst + Number ) = HIDWORD ( @@v13@@ ) ; @@tp@@ . tm_gmtoff = @@v14@@ ; @@tp@@ . tm_zone = @@v15@@ ; @@tp@@ . tm_isdst = Number ; @@timer@@ = mktime ( & @@tp@@ ) ; if ( @@timer@@ == Number ) { @@v7@@ = localtime ( & @@timer@@ ) ; if ( ! @@v7@@ ) return Number L ; } else { @@v7@@ = & @@tp@@ ; } if ( ! ( HIDWORD ( @@v9@@ ) ^ @@v7@@ -> tm_min | ( unsigned int ) @@v10@@ ^ @@v7@@ -> tm_hour | HIDWORD ( @@v10@@ ) ^ @@v7@@ -> tm_mday | ( unsigned int ) @@v11@@ ^ @@v7@@ -> tm_mon | @@v7@@ -> tm_year ^ HIDWORD ( @@v11@@ ) | ( unsigned int ) @@v9@@ ^ @@v7@@ -> tm_sec ) ) goto LABEL_12 ; if ( ( _DWORD ) @@v9@@ != Number ) return Number L ; @@v8@@ = stpcpy ( @@dest@@ , @@a2@@ ) ; strcpy ( @@v8@@ - Number , String ) ; if ( ( unsigned __int8 ) posixtime ( ( time_t * ) @@v6@@ , @@dest@@ , @@a3@@ ) != Number ) return Number L ; LABEL_12 : * @@a1@@ = @@timer@@ ; return Number L ; }
_BOOL8 __fastcall c_isblank ( int @@a1@@ ) { return @@a1@@ == Number || @@a1@@ == Number ; }
__int64 __fastcall align_nstrftime ( __int64 @@a1@@ , __int64 @@a2@@ , const char * @@a3@@ , __int64 @@a4@@ , unsigned int @@a5@@ , unsigned int @@a6@@ ) { char * @@v6@@ ; char * @@haystack@@ ; char * @@v12@@ ; char * @@v13@@ ; char * @@dest@@ ; char @@v15@@ [ Number ] ; unsigned __int64 @@v16@@ ; @@haystack@@ = ( char * ) @@a3@@ ; @@v16@@ = __readfsqword ( Number ) ; @@v12@@ = ( char * ) @@a3@@ ; if ( required_mon_width ) { @@v13@@ = strstr ( @@a3@@ , needle ) ; if ( @@v13@@ ) { if ( strlen ( @@haystack@@ ) <= Number ) { @@v12@@ = @@v15@@ ; @@v6@@ = ( char * ) mempcpy ( @@v15@@ , @@haystack@@ , @@v13@@ - @@haystack@@ ) ; @@dest@@ = stpcpy ( @@v6@@ , & abmon [ Number * * ( int * ) ( @@a4@@ + Number ) ] ) ; strcpy ( @@dest@@ , @@v13@@ + Number ) ; } } } return nstrftime ( @@a1@@ , @@a2@@ , @@v12@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
void __fastcall mpsort_with_tmp ( __int64 * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int64 ( __fastcall * @@a4@@ ) ( __int64 , __int64 ) ) { int @@i@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; __int64 @@v12@@ ; __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; __int64 @@v15@@ ; __int64 @@v16@@ ; if ( @@a2@@ > Number ) { @@v10@@ = Number L ; @@v14@@ = @@a2@@ >> Number ; @@v11@@ = @@a2@@ >> Number ; mpsort_with_tmp ( & @@a1@@ [ @@a2@@ >> Number ] , @@a2@@ - ( @@a2@@ >> Number ) , @@a3@@ , @@a4@@ ) ; if ( @@a2@@ >> Number > Number ) mpsort_into_tmp ( @@a1@@ , @@a2@@ >> Number , @@a3@@ , @@a4@@ ) ; else * @@a3@@ = * @@a1@@ ; @@v13@@ = * @@a3@@ ; @@v12@@ = @@a1@@ [ @@v11@@ ] ; @@v9@@ = Number L ; for ( @@i@@ = @@a4@@ ( * @@a3@@ , @@v12@@ ) ; ; @@i@@ = @@a4@@ ( @@v13@@ , @@v12@@ ) ) { while ( @@i@@ <= Number ) { @@v5@@ = @@v9@@ ++ ; @@a1@@ [ @@v5@@ ] = @@v13@@ ; if ( ++ @@v10@@ == @@v14@@ ) return ; @@v13@@ = @@a3@@ [ @@v10@@ ] ; @@i@@ = @@a4@@ ( @@v13@@ , @@v12@@ ) ; } @@v6@@ = @@v9@@ ++ ; @@a1@@ [ @@v6@@ ] = @@v12@@ ; if ( ++ @@v11@@ == @@a2@@ ) break ; @@v12@@ = @@a1@@ [ @@v11@@ ] ; } memcpy ( & @@a1@@ [ @@v9@@ ] , & @@a3@@ [ @@v10@@ ] , Number * ( @@v14@@ - @@v10@@ ) ) ; } else if ( @@a2@@ == Number ) { @@v15@@ = * @@a1@@ ; @@v16@@ = @@a1@@ [ Number ] ; if ( ( int ) @@a4@@ ( * @@a1@@ , @@v16@@ ) > Number ) { * @@a1@@ = @@v16@@ ; @@a1@@ [ Number ] = @@v15@@ ; } } }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
_BOOL8 __fastcall c_isprint ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
__int64 __fastcall format_user ( unsigned int @@a1@@ , int @@a2@@ , char @@a3@@ ) { const char * @@v3@@ ; if ( @@a3@@ != Number ) { @@v3@@ = String ; } else if ( numeric_ids ) { @@v3@@ = Number L ; } else { @@v3@@ = ( const char * ) getuser ( @@a1@@ ) ; } return format_user_or_group ( @@v3@@ , @@a1@@ , @@a2@@ ) ; }
_BOOL8 __fastcall c_isxdigit ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number || ( int ) ( @@a1@@ & Number ) > Number && ( int ) ( @@a1@@ & Number ) <= Number ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
__int64 __fastcall bkm_scale_by_power_0 ( unsigned __int64 * @@a1@@ , int @@a2@@ , int @@a3@@ ) { unsigned int @@i@@ ; for ( @@i@@ = Number ; @@a3@@ -- ; @@i@@ |= bkm_scale_0 ( @@a1@@ , @@a2@@ ) ) { ; } return @@i@@ ; }
const char * __fastcall format_inode ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ ) { const char * @@result@@ ; if ( @@a2@@ <= Number ) __assert_fail ( String , String , Number , String ) ; if ( * ( _BYTE * ) ( @@a3@@ + Number ) && * ( _QWORD * ) ( @@a3@@ + Number ) ) @@result@@ = ( const char * ) umaxtostr ( * ( _QWORD * ) ( @@a3@@ + Number ) , @@a1@@ ) ; else @@result@@ = String ; return @@result@@ ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_213038 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
int __fastcall stat ( char * @@filename@@ , struct stat * @@stat_buf@@ ) { return __xstat ( Number , @@filename@@ , @@stat_buf@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_21F238 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
size_t __fastcall put_indicator ( __int64 @@a1@@ ) { if ( used_color != Number ) { used_color = Number ; prep_non_filename_text ( ) ; } return fwrite_unlocked ( * ( const void * * ) ( @@a1@@ + Number ) , * ( _QWORD * ) @@a1@@ , Number , stdout ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_2130E8 ; @@v4@@ [ Number ] = qword_2130F0 ; @@v4@@ [ Number ] = qword_2130F8 ; @@v4@@ [ Number ] = qword_213100 ; @@v4@@ [ Number ] = qword_213108 ; @@v4@@ [ Number ] = qword_213110 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
void * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
unsigned __int64 print_many_per_line ( ) { __int64 @@v0@@ ; unsigned __int64 @@result@@ ; unsigned __int64 @@i@@ ; __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; unsigned __int64 @@j@@ ; unsigned __int64 @@v6@@ ; __int64 @@v7@@ ; unsigned __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; @@v6@@ = calculate_columns ( Number L ) ; @@v7@@ = column_info + Number * @@v6@@ - Number ; @@v8@@ = cwd_n_used / @@v6@@ + ( cwd_n_used % @@v6@@ != Number ) ; for ( @@i@@ = Number L ; ; ++ @@i@@ ) { @@result@@ = @@i@@ ; if ( @@i@@ >= @@v8@@ ) break ; @@v3@@ = Number L ; @@v4@@ = @@i@@ ; for ( @@j@@ = Number L ; ; @@j@@ += @@v11@@ ) { @@v9@@ = * ( ( _QWORD * ) sorted_file + @@v4@@ ) ; @@v10@@ = length_of_file_name_and_frills ( @@v9@@ ) ; @@v0@@ = @@v3@@ ++ ; @@v11@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( @@v7@@ + Number ) + Number * @@v0@@ ) ; print_file_name_and_frills ( @@v9@@ , @@j@@ ) ; @@v4@@ += @@v8@@ ; if ( @@v4@@ >= cwd_n_used ) break ; indent ( @@j@@ + @@v10@@ , @@v11@@ + @@j@@ ) ; } putchar_unlocked ( Number ) ; } return @@result@@ ; }
void * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
struct dirent * readdir ( DIR * @@dirp@@ ) { return readdir ( @@dirp@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v4@@ ; @@v4@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v4@@ >= Number / @@a3@@ ) xalloc_die ( ) ; @@v4@@ += ( @@v4@@ + Number ) >> Number ; } else if ( ! @@v4@@ ) { @@v4@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v4@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v4@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
char * __fastcall parse_user_spec ( char * @@a1@@ , int * @@a2@@ , __gid_t * @@a3@@ , char * * @@a4@@ , void * * @@a5@@ ) { char * @@v9@@ ; char * @@v10@@ ; char * @@v11@@ ; @@v10@@ = strchr ( @@a1@@ , Number ) ; @@v9@@ = parse_with_separator ( @@a1@@ , @@v10@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; if ( ! @@v10@@ ) { if ( @@v9@@ ) { @@v11@@ = strchr ( @@a1@@ , Number ) ; if ( @@v11@@ ) { if ( ! parse_with_separator ( @@a1@@ , @@v11@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ) @@v9@@ = Number L ; } } } return @@v9@@ ; }
int print_horizontal ( ) { unsigned __int64 @@i@@ ; unsigned __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; @@v2@@ = Number L ; @@v5@@ = calculate_columns ( Number L ) ; @@v6@@ = column_info + Number * @@v5@@ - Number ; @@v7@@ = * ( _QWORD * ) sorted_file ; @@v3@@ = length_of_file_name_and_frills ( * ( _QWORD * ) sorted_file ) ; @@v4@@ = * * ( _QWORD * * ) ( @@v6@@ + Number ) ; print_file_name_and_frills ( @@v7@@ , Number L ) ; for ( @@i@@ = Number L ; @@i@@ < cwd_n_used ; ++ @@i@@ ) { if ( @@i@@ % @@v5@@ ) { indent ( @@v2@@ + @@v3@@ , @@v4@@ + @@v2@@ ) ; @@v2@@ += @@v4@@ ; } else { putchar_unlocked ( Number ) ; @@v2@@ = Number L ; } @@v8@@ = * ( ( _QWORD * ) sorted_file + @@i@@ ) ; print_file_name_and_frills ( @@v8@@ , @@v2@@ ) ; @@v3@@ = length_of_file_name_and_frills ( @@v8@@ ) ; @@v4@@ = * ( _QWORD * ) ( Number * ( @@i@@ % @@v5@@ ) + * ( _QWORD * ) ( @@v6@@ + Number ) ) ; } return putchar_unlocked ( Number ) ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall bad_cast ( __int64 @@a1@@ ) { return @@a1@@ ; }
__int64 __fastcall memcpy_uppcase ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { while ( @@a3@@ -- ) * ( _BYTE * ) ( @@a1@@ + @@a3@@ ) = toupper ( * ( unsigned __int8 * ) ( @@a2@@ + @@a3@@ ) ) ; return @@a1@@ ; }
_BOOL8 __fastcall c_isblank ( int @@a1@@ ) { return @@a1@@ == Number || @@a1@@ == Number ; }
char * __fastcall areadlink_with_size ( const char * @@a1@@ , unsigned __int64 @@a2@@ ) { __int64 @@v2@@ ; char * @@i@@ ; int @@v5@@ ; size_t @@size@@ ; char * @@buf@@ ; ssize_t @@v8@@ ; if ( @@a2@@ >= Number ) @@v2@@ = Number L ; else @@v2@@ = @@a2@@ + Number ; @@size@@ = @@v2@@ ; LABEL_5 : for ( @@i@@ = ( char * ) malloc ( @@size@@ ) ; ; @@i@@ = ( char * ) malloc ( Number ) ) { @@buf@@ = @@i@@ ; if ( ! @@i@@ ) return Number L ; @@v8@@ = readlink ( @@a1@@ , @@i@@ , @@size@@ ) ; if ( @@v8@@ < Number && * __errno_location ( ) != Number ) { @@v5@@ = * __errno_location ( ) ; free ( @@buf@@ ) ; * __errno_location ( ) = @@v5@@ ; return Number L ; } if ( @@v8@@ < @@size@@ ) { @@buf@@ [ @@v8@@ ] = Number ; return @@buf@@ ; } free ( @@buf@@ ) ; if ( @@size@@ <= Number ) { @@size@@ *= Number L ; goto LABEL_5 ; } if ( @@size@@ > Number ) break ; @@size@@ = Number ; } * __errno_location ( ) = Number ; return Number L ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
_BOOL8 __fastcall c_isprint ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
__int64 __fastcall xnrealloc ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { if ( ! is_mul_ok ( @@a3@@ , @@a2@@ ) ) xalloc_die ( ) ; return xrealloc ( @@a1@@ , @@a3@@ * @@a2@@ ) ; }
__int64 __fastcall uid_to_name ( __uid_t @@a1@@ ) { __int64 @@v1@@ ; struct passwd * @@v3@@ ; char @@v4@@ [ Number ] ; unsigned __int64 @@v5@@ ; @@v5@@ = __readfsqword ( Number ) ; @@v3@@ = getpwuid ( @@a1@@ ) ; if ( @@v3@@ ) @@v1@@ = ( __int64 ) @@v3@@ -> pw_name ; else @@v1@@ = umaxtostr ( @@a1@@ , @@v4@@ ) ; return xstrdup ( @@v1@@ ) ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall c_tolower ( int @@a1@@ ) { __int64 @@result@@ ; if ( @@a1@@ <= Number || @@a1@@ > Number ) @@result@@ = ( unsigned int ) @@a1@@ ; else @@result@@ = ( unsigned int ) ( @@a1@@ + Number ) ; return @@result@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ ) { return xmalloc ( @@a1@@ ) ; }
__int64 __fastcall filevercmp ( const char * @@a1@@ , const char * @@a2@@ ) { __int64 @@result@@ ; _BYTE * @@v3@@ ; _BYTE * @@v4@@ ; __int64 @@s2@@ ; __int64 @@s1@@ ; unsigned int @@v7@@ ; unsigned int @@v8@@ ; _BYTE * @@v9@@ ; _BYTE * @@v10@@ ; size_t @@n@@ ; _BYTE * @@v12@@ ; _BYTE * @@v13@@ ; _BYTE * @@v14@@ ; unsigned __int64 @@v15@@ ; @@s1@@ = ( __int64 ) @@a1@@ ; @@s2@@ = ( __int64 ) @@a2@@ ; @@v15@@ = __readfsqword ( Number ) ; @@v7@@ = strcmp ( @@a1@@ , @@a2@@ ) ; if ( ! @@v7@@ ) return Number L ; if ( ! * @@a1@@ ) return Number ; if ( ! * @@a2@@ ) return Number L ; if ( ! strcmp ( String , @@a1@@ ) ) return Number ; if ( ! strcmp ( String , @@a2@@ ) ) return Number L ; if ( ! strcmp ( String , @@a1@@ ) ) return Number ; if ( ! strcmp ( String , @@a2@@ ) ) return Number L ; if ( * @@a1@@ == Number && * @@a2@@ != Number ) return Number ; if ( * @@a1@@ != Number && * @@a2@@ == Number ) return Number L ; if ( * @@a1@@ == Number && * @@a2@@ == Number ) { @@s1@@ = ( __int64 ) ( @@a1@@ + Number ) ; @@s2@@ = ( __int64 ) ( @@a2@@ + Number ) ; } @@v9@@ = ( _BYTE * ) @@s1@@ ; @@v10@@ = ( _BYTE * ) @@s2@@ ; @@v13@@ = match_suffix ( & @@v9@@ ) ; @@v14@@ = match_suffix ( & @@v10@@ ) ; if ( @@v13@@ ) @@v3@@ = @@v13@@ ; else @@v3@@ = @@v9@@ ; @@n@@ = ( size_t ) & @@v3@@ [ - @@s1@@ ] ; if ( @@v14@@ ) @@v4@@ = @@v14@@ ; else @@v4@@ = @@v10@@ ; @@v12@@ = & @@v4@@ [ - @@s2@@ ] ; if ( ( @@v13@@ || @@v14@@ ) && ( _BYTE * ) @@n@@ == @@v12@@ && ! strncmp ( ( const char * ) @@s1@@ , ( const char * ) @@s2@@ , @@n@@ ) ) { @@n@@ = ( size_t ) & @@v9@@ [ - @@s1@@ ] ; @@v12@@ = & @@v10@@ [ - @@s2@@ ] ; } @@v8@@ = verrevcmp ( @@s1@@ , @@n@@ , @@s2@@ , ( unsigned __int64 ) @@v12@@ ) ; if ( @@v8@@ ) @@result@@ = @@v8@@ ; else @@result@@ = @@v7@@ ; return @@result@@ ; }
int __fastcall stat ( char * @@filename@@ , struct stat * @@stat_buf@@ ) { return __xstat ( Number , @@filename@@ , @@stat_buf@@ ) ; }
void * __fastcall xzalloc ( size_t @@a1@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@a1@@ ) ; return memset ( @@v1@@ , Number , @@a1@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
int fileno ( FILE * @@stream@@ ) { return fileno ( @@stream@@ ) ; }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
_BOOL8 __fastcall AD_compare ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { return @@a1@@ [ Number ] == @@a2@@ [ Number ] && * @@a1@@ == * @@a2@@ ; }
int isatty ( int @@fd@@ ) { return isatty ( @@fd@@ ) ; }
DIR * opendir ( const char * @@name@@ ) { return opendir ( @@name@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
__int64 __fastcall fd_ring_clear ( __int64 @@a1@@ ) { __int64 @@result@@ ; int @@fd@@ ; while ( Number ) { @@result@@ = ( unsigned int ) i_ring_empty ( @@a1@@ ) ^ Number ; if ( ! ( _BYTE ) @@result@@ ) break ; @@fd@@ = i_ring_pop ( @@a1@@ ) ; if ( @@fd@@ >= Number ) close ( @@fd@@ ) ; } return @@result@@ ; }
unsigned __int64 __fastcall xstrtol_error ( unsigned int @@a1@@ , int @@a2@@ , char @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , int @@a6@@ ) { char * @@v6@@ ; char * @@v10@@ ; char * @@msgid@@ ; char * @@v12@@ ; char @@v13@@ [ Number ] ; unsigned __int64 @@v14@@ ; @@v14@@ = __readfsqword ( Number ) ; @@v10@@ = ( char * ) & unk_1A278 ; if ( @@a1@@ > Number ) { if ( @@a1@@ != Number ) goto LABEL_6 ; @@msgid@@ = String ; } else if ( @@a1@@ >= Number ) { @@msgid@@ = String ; } else { if ( @@a1@@ != Number ) LABEL_6 : abort ( ) ; @@msgid@@ = String ; } if ( @@a2@@ >= Number ) { @@v12@@ = * ( char * * ) ( Number L * @@a2@@ + @@a4@@ ) ; } else { @@v10@@ = ( char * ) & unk_1A278 - @@a2@@ ; @@v13@@ [ Number ] = @@a3@@ ; @@v13@@ [ Number ] = Number ; @@v12@@ = @@v13@@ ; } @@v6@@ = gettext ( @@msgid@@ ) ; error ( @@a6@@ , Number , @@v6@@ , @@v10@@ , @@v12@@ , @@a5@@ ) ; return __readfsqword ( Number ) ^ @@v14@@ ; }
int __cdecl __noreturn main ( int @@argc@@ , const char * * @@argv@@ , const char * * @@envp@@ ) { char * @@v3@@ ; int * @@v4@@ ; unsigned __int8 @@v5@@ ; int @@v6@@ ; set_program_name ( * @@argv@@ , @@argv@@ , @@envp@@ ) ; setlocale ( Number , & locale ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; append = Number ; ignore_interrupts = Number ; while ( Number ) { @@v6@@ = getopt_long ( @@argc@@ , ( char * const * ) @@argv@@ , String , & long_options , Number L ) ; if ( @@v6@@ == Number ) { if ( ignore_interrupts ) signal ( Number , ( __sighandler_t ) ( ( char * ) & dword_0 + Number ) ) ; @@v5@@ = tee_files ( ( unsigned int ) ( @@argc@@ - optind ) , & @@argv@@ [ optind ] ) ; if ( close ( Number ) ) { @@v3@@ = gettext ( String ) ; @@v4@@ = __errno_location ( ) ; error ( Number , * @@v4@@ , @@v3@@ ) ; } exit ( @@v5@@ ^ Number ) ; } if ( @@v6@@ == Number ) usage ( Number ) ; if ( @@v6@@ <= Number ) break ; if ( @@v6@@ == Number ) { append = Number ; } else { if ( @@v6@@ != Number ) goto LABEL_13 ; ignore_interrupts = Number ; } } if ( @@v6@@ == Number ) { version_etc ( ( _DWORD ) stdout , ( unsigned int ) String , ( unsigned int ) String , ( _DWORD ) Version , ( unsigned int ) String , ( unsigned int ) String , String , Number L ) ; exit ( Number ) ; } LABEL_13 : usage ( Number ) ; }
struct passwd * getpwnam ( const char * @@name@@ ) { return getpwnam ( @@name@@ ) ; }
__int64 __fastcall argmatch_to_argument ( const void * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; ++ @@i@@ ) { if ( ! memcmp ( @@a1@@ , ( const void * ) ( @@i@@ * @@a4@@ + @@a3@@ ) , @@a4@@ ) ) return * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; } return Number L ; }
__int64 __fastcall cwd_advance_fd ( __int64 @@a1@@ , int @@a2@@ , char @@a3@@ ) { __int64 @@result@@ ; int @@v4@@ ; int @@fd@@ ; @@v4@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; if ( @@v4@@ == @@a2@@ && @@v4@@ != Number ) abort ( ) ; if ( @@a3@@ ) { @@fd@@ = i_ring_push ( @@a1@@ + Number , ( unsigned int ) @@v4@@ ) ; if ( @@fd@@ >= Number ) close ( @@fd@@ ) ; } else if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) == Number && @@v4@@ >= Number ) { close ( @@v4@@ ) ; } @@result@@ = @@a1@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
_BOOL8 __fastcall c_ispunct ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number && ( @@a1@@ <= Number || @@a1@@ > Number ) && ( ( int ) ( @@a1@@ & Number ) <= Number || ( int ) ( @@a1@@ & Number ) > Number ) ; }
struct dirent * readdir ( DIR * @@dirp@@ ) { return readdir ( @@dirp@@ ) ; }
unsigned __int64 __fastcall LCO_hash ( _QWORD * @@a1@@ , unsigned __int64 @@a2@@ ) { return * @@a1@@ % @@a2@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
char * nl_langinfo ( nl_item @@item@@ ) { return nl_langinfo ( @@item@@ ) ; }
bool __fastcall LCO_compare ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { return * @@a1@@ == * @@a2@@ ; }
int __fxstat ( int @@ver@@ , int @@fildes@@ , struct stat * @@stat_buf@@ ) { return _fxstat ( @@ver@@ , @@fildes@@ , @@stat_buf@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) _frame_dummy_init_array_entry [ @@i@@ ] ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
__int64 __fastcall link_count_optimize_ok ( __int64 @@a1@@ ) { __int64 @@result@@ ; bool @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; _BYTE * @@ptr@@ ; __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v3@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; if ( ( * ( _DWORD * ) ( @@v4@@ + Number ) & Number ) == Number ) return Number L ; if ( ! @@v3@@ ) { * ( _QWORD * ) ( @@v4@@ + Number ) = hash_initialize ( Number L , Number L , LCO_hash , LCO_compare , & free ) ; @@v3@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; if ( ! @@v3@@ ) return Number L ; } @@v8@@ [ Number ] = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v5@@ = hash_lookup ( @@v3@@ , @@v8@@ ) ; if ( @@v5@@ ) return * ( unsigned __int8 * ) ( @@v5@@ + Number ) ; @@ptr@@ = malloc ( Number ) ; if ( ! @@ptr@@ ) return Number L ; @@v2@@ = leaf_optimization_applies ( * ( _DWORD * ) ( @@v4@@ + Number ) ) ; @@ptr@@ [ Number ] = @@v2@@ ; * ( _QWORD * ) @@ptr@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v6@@ = hash_insert ( @@v3@@ , @@ptr@@ ) ; if ( @@v6@@ ) { if ( ( _BYTE * ) @@v6@@ != @@ptr@@ ) abort ( ) ; @@result@@ = @@v2@@ ; } else { free ( @@ptr@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
_BYTE * __fastcall strmode ( __int16 @@a1@@ , _BYTE * @@a2@@ ) { char @@v2@@ ; char @@v3@@ ; char @@v4@@ ; char @@v5@@ ; char @@v6@@ ; char @@v7@@ ; char @@v8@@ ; char @@v9@@ ; char @@v10@@ ; _BYTE * @@result@@ ; * @@a2@@ = ftypelet ( @@a1@@ ) ; if ( ( @@a1@@ & Number ) != Number ) @@v2@@ = Number ; else @@v2@@ = Number ; @@a2@@ [ Number ] = @@v2@@ ; if ( ( @@a1@@ & Number ) != Number ) @@v3@@ = Number ; else @@v3@@ = Number ; @@a2@@ [ Number ] = @@v3@@ ; if ( ( @@a1@@ & Number ) != Number ) { if ( ( @@a1@@ & Number ) != Number ) @@v4@@ = Number ; else @@v4@@ = Number ; } else if ( ( @@a1@@ & Number ) != Number ) { @@v4@@ = Number ; } else { @@v4@@ = Number ; } @@a2@@ [ Number ] = @@v4@@ ; if ( ( @@a1@@ & Number ) != Number ) @@v5@@ = Number ; else @@v5@@ = Number ; @@a2@@ [ Number ] = @@v5@@ ; if ( ( @@a1@@ & Number ) != Number ) @@v6@@ = Number ; else @@v6@@ = Number ; @@a2@@ [ Number ] = @@v6@@ ; if ( ( @@a1@@ & Number ) != Number ) { if ( ( @@a1@@ & Number ) != Number ) @@v7@@ = Number ; else @@v7@@ = Number ; } else if ( ( @@a1@@ & Number ) != Number ) { @@v7@@ = Number ; } else { @@v7@@ = Number ; } @@a2@@ [ Number ] = @@v7@@ ; if ( ( @@a1@@ & Number ) != Number ) @@v8@@ = Number ; else @@v8@@ = Number ; @@a2@@ [ Number ] = @@v8@@ ; if ( ( @@a1@@ & Number ) != Number ) @@v9@@ = Number ; else @@v9@@ = Number ; @@a2@@ [ Number ] = @@v9@@ ; if ( ( @@a1@@ & Number ) != Number ) { if ( ( @@a1@@ & Number ) != Number ) @@v10@@ = Number ; else @@v10@@ = Number ; } else if ( ( @@a1@@ & Number ) != Number ) { @@v10@@ = Number ; } else { @@v10@@ = Number ; } @@a2@@ [ Number ] = @@v10@@ ; @@a2@@ [ Number ] = Number ; @@result@@ = @@a2@@ + Number ; @@a2@@ [ Number ] = Number ; return @@result@@ ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
int fflush_unlocked ( FILE * @@stream@@ ) { return fflush_unlocked ( @@stream@@ ) ; }
__int64 __fastcall hash_get_n_entries ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
__int64 __fastcall fts_palloc ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; unsigned __int64 @@v3@@ ; void * @@v4@@ ; @@v3@@ = * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ + Number ; if ( @@v3@@ >= * ( _QWORD * ) ( @@a1@@ + Number ) ) { * ( _QWORD * ) ( @@a1@@ + Number ) = @@v3@@ ; @@v4@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , * ( _QWORD * ) ( @@a1@@ + Number ) ) ; if ( @@v4@@ ) { * ( _QWORD * ) ( @@a1@@ + Number ) = @@v4@@ ; @@result@@ = Number L ; } else { free ( * ( void * * ) ( @@a1@@ + Number ) ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; @@result@@ = Number L ; } } else { free ( * ( void * * ) ( @@a1@@ + Number ) ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * __errno_location ( ) = Number ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
int closedir ( DIR * @@dirp@@ ) { return closedir ( @@dirp@@ ) ; }
int __xstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _xstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
DIR * fdopendir ( int @@fd@@ ) { return fdopendir ( @@fd@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 __fastcall hash_lookup ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; _QWORD * @@i@@ ; _QWORD * @@v5@@ ; @@v2@@ = * @@a1@@ ; @@v5@@ = ( _QWORD * ) ( @@v2@@ + Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) ) ; if ( ( unsigned __int64 ) @@v5@@ >= @@a1@@ [ Number ] ) abort ( ) ; if ( ! * @@v5@@ ) return Number L ; for ( @@i@@ = @@v5@@ ; @@i@@ ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { if ( @@a2@@ == * @@i@@ || ( ( unsigned __int8 ( __fastcall * ) ( __int64 , _QWORD ) ) @@a1@@ [ Number ] ) ( @@a2@@ , * @@i@@ ) ) { return * @@i@@ ; } } return Number L ; }
__int64 __fastcall fts_safe_changedir ( __int64 @@a1@@ , __int64 @@a2@@ , int @@a3@@ , const char * @@a4@@ , int @@a5@@ , int @@a6@@ ) { bool @@v6@@ ; char * @@s1@@ ; char @@v10@@ ; unsigned int @@v11@@ ; int @@fildes@@ ; int @@v13@@ ; int @@v14@@ ; struct stat @@v15@@ ; unsigned __int64 @@v16@@ ; @@s1@@ = ( char * ) @@a4@@ ; @@v16@@ = __readfsqword ( Number ) ; @@v6@@ = @@a4@@ && ! strcmp ( @@a4@@ , String ) ; @@v10@@ = @@v6@@ ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number && @@a3@@ >= Number ) close ( @@a3@@ ) ; return Number L ; } if ( @@a3@@ < Number ) { if ( @@v10@@ ) { if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number && ( unsigned __int8 ) i_ring_empty ( @@a1@@ + Number ) != Number ) { @@v13@@ = i_ring_pop ( @@a1@@ + Number ) ; @@v10@@ = Number ; if ( @@v13@@ >= Number ) { @@a3@@ = @@v13@@ ; @@s1@@ = Number L ; } } } } @@fildes@@ = @@a3@@ ; if ( @@a3@@ < Number ) { @@fildes@@ = diropen ( @@a1@@ , ( int ) @@s1@@ , ( __int64 ) @@s1@@ , ( int ) @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( @@fildes@@ < Number ) return Number ; } if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) == Number && ( ! @@s1@@ || strcmp ( @@s1@@ , String ) ) ) goto LABEL_27 ; if ( ! ( unsigned int ) fstat ( @@fildes@@ , & @@v15@@ ) ) { if ( * ( _QWORD * ) ( @@a2@@ + Number ) != @@v15@@ . st_dev || * ( _QWORD * ) ( @@a2@@ + Number ) != @@v15@@ . st_ino ) { * __errno_location ( ) = Number ; @@v11@@ = Number ; goto LABEL_30 ; } LABEL_27 : if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { cwd_advance_fd ( @@a1@@ , @@fildes@@ , @@v10@@ == Number ) ; return Number L ; } @@v11@@ = fchdir ( @@fildes@@ ) ; goto LABEL_30 ; } @@v11@@ = Number ; LABEL_30 : if ( @@a3@@ < Number ) { @@v14@@ = * __errno_location ( ) ; close ( @@fildes@@ ) ; * __errno_location ( ) = @@v14@@ ; } return @@v11@@ ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
void free ( void * @@ptr@@ ) { __imp_free ( @@ptr@@ ) ; }
unsigned __int64 __fastcall hash_string ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ ) { unsigned __int64 @@v4@@ ; @@v4@@ = Number L ; while ( * @@a1@@ ) @@v4@@ = ( Number * @@v4@@ + ( unsigned __int8 ) * @@a1@@ ++ ) % @@a2@@ ; return @@v4@@ ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 __fastcall get_stat_mtime ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
void __fastcall dev_ino_free ( void * @@a1@@ ) { free ( @@a1@@ ) ; }
__int64 __fastcall next_prime ( unsigned __int64 @@a1@@ ) { __int64 @@v2@@ ; __int64 @@i@@ ; @@v2@@ = @@a1@@ ; if ( @@a1@@ <= Number ) @@v2@@ = Number L ; for ( @@i@@ = @@v2@@ | Number ; @@i@@ != Number && ! is_prime ( @@i@@ ) ; @@i@@ += Number L ) { ; } return @@i@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
_BOOL8 __fastcall is_colored ( unsigned int @@a1@@ ) { __int64 @@v3@@ ; char * @@s1@@ ; @@v3@@ = * ( ( _QWORD * ) & color_indicator + Number * @@a1@@ ) ; @@s1@@ = ( char * ) * ( & off_21F088 + Number * @@a1@@ ) ; return @@v3@@ && ( @@v3@@ != Number || * @@s1@@ != Number ) && ( @@v3@@ != Number || strncmp ( @@s1@@ , off_16E97 , Number ) ) ; }
unsigned __int64 __fastcall compute_bucket_size ( __int64 @@a1@@ , __int64 @@a2@@ ) { float @@v2@@ ; unsigned __int64 @@result@@ ; unsigned __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; float @@v6@@ ; @@v4@@ = @@a1@@ ; if ( * ( _BYTE * ) ( @@a2@@ + Number ) != Number ) { if ( @@a1@@ < Number ) @@v2@@ = ( float ) ( @@a1@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@a1@@ >> Number ) ) + ( float ) ( @@a1@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@a1@@ >> Number ) ) ; else @@v2@@ = ( float ) ( int ) @@a1@@ ; @@v6@@ = @@v2@@ / * ( float * ) ( @@a2@@ + Number ) ; if ( @@v6@@ >= Number ) return Number L ; if ( @@v6@@ >= Number ) @@v4@@ = ( unsigned int ) ( int ) ( float ) ( @@v6@@ - Number ) ^ Number ; else @@v4@@ = ( unsigned int ) ( int ) @@v6@@ ; } @@v5@@ = next_prime ( @@v4@@ ) ; if ( @@v5@@ <= Number ) @@result@@ = @@v5@@ ; else @@result@@ = Number L ; return @@result@@ ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; FILE * @@v10@@ ; char * @@v11@@ ; FILE * @@v12@@ ; char * @@v13@@ ; FILE * @@v14@@ ; char * @@v15@@ ; FILE * @@v16@@ ; char * @@v17@@ ; FILE * @@v18@@ ; char * @@v19@@ ; FILE * @@v20@@ ; char * @@v21@@ ; FILE * @@v22@@ ; char * @@v23@@ ; __int64 @@v24@@ ; __int64 @@v25@@ ; __int64 @@v26@@ ; char * @@v27@@ ; if ( @@a1@@ ) { @@v1@@ = program_name ; @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = program_name ; @@v4@@ = program_name ; @@v5@@ = gettext ( String String ) ; printf ( @@v5@@ , @@v4@@ , @@v3@@ ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String String String String String String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; @@v8@@ = stdout ; @@v9@@ = gettext ( String String String ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = stdout ; @@v11@@ = gettext ( String String String String String ) ; fputs_unlocked ( @@v11@@ , @@v10@@ ) ; @@v12@@ = stdout ; @@v13@@ = gettext ( String String ) ; fputs_unlocked ( @@v13@@ , @@v12@@ ) ; @@v14@@ = stdout ; @@v15@@ = gettext ( String String String String String String ) ; fputs_unlocked ( @@v15@@ , @@v14@@ ) ; @@v16@@ = stdout ; @@v17@@ = gettext ( String String String String String String String String String String ) ; fputs_unlocked ( @@v17@@ , @@v16@@ ) ; @@v18@@ = stdout ; @@v19@@ = gettext ( String ) ; fputs_unlocked ( @@v19@@ , @@v18@@ ) ; @@v20@@ = stdout ; @@v21@@ = gettext ( String ) ; fputs_unlocked ( @@v21@@ , @@v20@@ ) ; @@v22@@ = stdout ; @@v23@@ = gettext ( String String String String ) ; fputs_unlocked ( @@v23@@ , @@v22@@ ) ; @@v24@@ = program_name ; @@v25@@ = program_name ; @@v26@@ = program_name ; @@v27@@ = gettext ( String String String String String ) ; printf ( @@v27@@ , @@v26@@ , @@v25@@ , @@v24@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
__int64 __fastcall patterns_match ( __int64 @@a1@@ , const char * @@a2@@ ) { while ( @@a1@@ ) { if ( ! fnmatch ( * ( const char * * ) @@a1@@ , @@a2@@ , Number ) ) return Number L ; @@a1@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; } return Number L ; }
int feof ( FILE * @@stream@@ ) { return feof ( @@stream@@ ) ; }
__int64 __fastcall hash_clear ( __int64 @@a1@@ ) { __int64 @@result@@ ; _QWORD * @@i@@ ; _QWORD * @@j@@ ; _QWORD * @@v4@@ ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = ( _QWORD * ) @@i@@ [ Number ] ; @@j@@ ; @@j@@ = @@v4@@ ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@j@@ ) ; * @@j@@ = Number L ; @@v4@@ = ( _QWORD * ) @@j@@ [ Number ] ; @@j@@ [ Number ] = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@j@@ ; } if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@i@@ ) ; * @@i@@ = Number L ; @@i@@ [ Number ] = Number L ; } } * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; @@result@@ = @@a1@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; return @@result@@ ; }
__int64 __fastcall free_entry ( __int64 @@a1@@ , _QWORD * @@a2@@ ) { __int64 @@result@@ ; * @@a2@@ = Number L ; @@a2@@ [ Number ] = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@result@@ = @@a1@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
int __fxstat ( int @@ver@@ , int @@fildes@@ , struct stat * @@stat_buf@@ ) { return _fxstat ( @@ver@@ , @@fildes@@ , @@stat_buf@@ ) ; }
_BOOL8 __fastcall basename_is_dot_or_dotdot ( __int64 @@a1@@ ) { _BYTE * @@v2@@ ; @@v2@@ = ( _BYTE * ) last_component ( @@a1@@ ) ; return dot_or_dotdot ( @@v2@@ ) ; }
__int64 __fastcall i_ring_pop ( __int64 @@a1@@ ) { unsigned int @@v2@@ ; if ( ( unsigned __int8 ) i_ring_empty ( @@a1@@ ) ) abort ( ) ; @@v2@@ = * ( _DWORD * ) ( @@a1@@ + Number L * * ( unsigned int * ) ( @@a1@@ + Number ) ) ; * ( _DWORD * ) ( @@a1@@ + Number L * * ( unsigned int * ) ( @@a1@@ + Number ) ) = * ( _DWORD * ) ( @@a1@@ + Number ) ; if ( * ( _DWORD * ) ( @@a1@@ + Number ) == * ( _DWORD * ) ( @@a1@@ + Number ) ) * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; else * ( _DWORD * ) ( @@a1@@ + Number ) = ( ( unsigned __int8 ) * ( _DWORD * ) ( @@a1@@ + Number ) + Number ) & Number ; return @@v2@@ ; }
__int64 __fastcall hash_rehash ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; unsigned __int64 @@nmemb@@ ; void * @@v4@@ ; __int64 @@v5@@ ; unsigned __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; __int64 @@v12@@ ; __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; @@v14@@ = __readfsqword ( Number ) ; @@nmemb@@ = compute_bucket_size ( @@a2@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ; if ( ! @@nmemb@@ ) return Number L ; if ( @@nmemb@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; @@v4@@ = calloc ( @@nmemb@@ , Number ) ; if ( ! @@v4@@ ) return Number L ; @@v6@@ = @@nmemb@@ ; @@v5@@ = ( __int64 ) @@v4@@ + Number * @@nmemb@@ ; @@v7@@ = Number L ; @@v8@@ = Number L ; @@v9@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v10@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v11@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v12@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v13@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( ( unsigned __int8 ) transfer_entries ( ( __int64 ) & @@v4@@ , @@a1@@ , Number ) ) { free ( * ( void * * ) @@a1@@ ) ; * ( _QWORD * ) @@a1@@ = @@v4@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v5@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v6@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v7@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v13@@ ; @@result@@ = Number L ; } else { * ( _QWORD * ) ( @@a1@@ + Number ) = @@v13@@ ; if ( ( unsigned __int8 ) transfer_entries ( @@a1@@ , ( __int64 ) & @@v4@@ , Number ) != Number || ( unsigned __int8 ) transfer_entries ( @@a1@@ , ( __int64 ) & @@v4@@ , Number ) != Number ) { abort ( ) ; } free ( @@v4@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
__int64 __fastcall cmp_mtime ( _QWORD * @@a1@@ , _QWORD * @@a2@@ , __int64 ( __fastcall * @@a3@@ ( ) ( constchar , constchar ) ) ( _QWORD , _QWORD ) ) { __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@result@@ ; unsigned int @@v10@@ ; @@v3@@ = get_stat_mtime ( ( __int64 ) ( @@a1@@ + Number ) ) ; @@v5@@ = @@v4@@ ; @@v6@@ = get_stat_mtime ( ( __int64 ) ( @@a2@@ + Number ) ) ; @@v10@@ = timespec_cmp ( @@v6@@ , @@v7@@ , @@v3@@ , @@v5@@ ) ; if ( @@v10@@ ) @@result@@ = @@v10@@ ; else @@result@@ = @@a3@@ ( ) ( constchar , constchar ) ( * @@a1@@ , * @@a2@@ ) ; return @@result@@ ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
__int64 __fastcall getuser ( __uid_t @@a1@@ ) { const char * @@v1@@ ; size_t @@v2@@ ; __int64 @@result@@ ; __int64 @@i@@ ; __int64 @@v5@@ ; struct passwd * @@v6@@ ; char * @@s@@ ; @@v5@@ = Number L ; for ( @@i@@ = user_alist ; @@i@@ ; @@i@@ = * ( _QWORD * ) ( @@i@@ + Number ) ) { if ( @@a1@@ == * ( _DWORD * ) @@i@@ ) { @@v5@@ = @@i@@ ; break ; } } if ( ! @@v5@@ ) { @@v6@@ = getpwuid ( @@a1@@ ) ; if ( @@v6@@ ) @@v1@@ = @@v6@@ -> pw_name ; else @@v1@@ = ( const char * ) & unk_19CC0 ; @@s@@ = ( char * ) @@v1@@ ; @@v2@@ = strlen ( @@v1@@ ) ; @@v5@@ = xmalloc ( @@v2@@ + Number ) ; * ( _DWORD * ) @@v5@@ = @@a1@@ ; strcpy ( ( char * ) ( @@v5@@ + Number ) , @@s@@ ) ; * ( _QWORD * ) ( @@v5@@ + Number ) = user_alist ; user_alist = @@v5@@ ; } if ( * ( _BYTE * ) ( @@v5@@ + Number ) ) @@result@@ = @@v5@@ + Number ; else @@result@@ = Number L ; return @@result@@ ; }
__int64 __fastcall rev_xstrcoll_df_ctime ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_ctime ( @@a2@@ , @@a1@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) xstrcoll ) ; }
__int64 __fastcall wc_file ( const char * @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; int * @@v3@@ ; unsigned __int8 @@v4@@ ; int @@fd@@ ; if ( @@a1@@ && strcmp ( @@a1@@ , String ) ) { @@fd@@ = open ( @@a1@@ , Number ) ; if ( @@fd@@ == Number || ( @@v4@@ = wc ( @@fd@@ , @@a1@@ , @@a2@@ ) , close ( @@fd@@ ) ) ) { @@v3@@ = __errno_location ( ) ; error ( Number , * @@v3@@ , String , @@a1@@ ) ; @@result@@ = Number L ; } else { @@result@@ = @@v4@@ ; } } else { have_read_stdin = Number ; @@result@@ = wc ( Number , @@a1@@ , @@a2@@ ) ; } return @@result@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
void * __fastcall mpsort_into_tmp ( __int64 * @@a1@@ , unsigned __int64 @@a2@@ , _QWORD * @@a3@@ , __int64 ( __fastcall * @@a4@@ ) ( __int64 , __int64 ) ) { int @@i@@ ; _QWORD * @@v5@@ ; _QWORD * @@v6@@ ; _QWORD * @@dest@@ ; unsigned __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; unsigned __int64 @@v12@@ ; __int64 @@v13@@ ; __int64 @@v14@@ ; @@dest@@ = @@a3@@ ; @@v10@@ = Number L ; @@v11@@ = @@a2@@ >> Number ; @@v12@@ = @@a2@@ >> Number ; mpsort_with_tmp ( & @@a1@@ [ @@a2@@ >> Number ] , @@a2@@ - ( @@a2@@ >> Number ) , @@a3@@ , @@a4@@ ) ; mpsort_with_tmp ( @@a1@@ , @@a2@@ >> Number , @@dest@@ , @@a4@@ ) ; @@v13@@ = * @@a1@@ ; @@v14@@ = @@a1@@ [ @@a2@@ >> Number ] ; for ( @@i@@ = @@a4@@ ( * @@a1@@ , @@v14@@ ) ; ; @@i@@ = @@a4@@ ( @@v13@@ , @@v14@@ ) ) { while ( @@i@@ > Number ) { @@v6@@ = @@dest@@ ++ ; * @@v6@@ = @@v14@@ ; if ( ++ @@v12@@ == @@a2@@ ) return memcpy ( @@dest@@ , & @@a1@@ [ @@v10@@ ] , Number * ( @@v11@@ - @@v10@@ ) ) ; @@v14@@ = @@a1@@ [ @@v12@@ ] ; @@i@@ = @@a4@@ ( @@v13@@ , @@v14@@ ) ; } @@v5@@ = @@dest@@ ++ ; * @@v5@@ = @@v13@@ ; if ( ++ @@v10@@ == @@v11@@ ) break ; @@v13@@ = @@a1@@ [ @@v10@@ ] ; } @@v10@@ = @@v12@@ ; @@v11@@ = @@a2@@ ; return memcpy ( @@dest@@ , & @@a1@@ [ @@v10@@ ] , Number * ( @@v11@@ - @@v10@@ ) ) ; }
__int64 __fastcall rev_strcmp_df_mtime ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_mtime ( @@a2@@ , @@a1@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) & strcmp ) ; }
__int64 __fastcall enter_dir ( __int64 @@a1@@ , __int64 @@a2@@ ) { _QWORD * @@ptr@@ ; __int64 @@v4@@ ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { @@ptr@@ = malloc ( Number ) ; if ( ! @@ptr@@ ) return Number L ; * @@ptr@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@ptr@@ [ Number ] = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@ptr@@ [ Number ] = @@a2@@ ; @@v4@@ = hash_insert ( * ( _QWORD * ) ( @@a1@@ + Number ) , @@ptr@@ ) ; if ( ( _QWORD * ) @@v4@@ != @@ptr@@ ) { free ( @@ptr@@ ) ; if ( ! @@v4@@ ) return Number L ; * ( _QWORD * ) @@a2@@ = * ( _QWORD * ) ( @@v4@@ + Number ) ; * ( _WORD * ) ( @@a2@@ + Number ) = Number ; } } else if ( ( unsigned __int8 ) cycle_check ( * ( _QWORD * ) ( @@a1@@ + Number ) , @@a2@@ + Number ) ) { * ( _QWORD * ) @@a2@@ = @@a2@@ ; * ( _WORD * ) ( @@a2@@ + Number ) = Number ; } return Number L ; }
_QWORD * __fastcall argv_iter_init_argv ( __int64 @@a1@@ ) { _QWORD * @@v2@@ ; @@v2@@ = malloc ( Number ) ; if ( ! @@v2@@ ) return Number L ; * @@v2@@ = Number L ; @@v2@@ [ Number ] = @@a1@@ ; @@v2@@ [ Number ] = @@a1@@ ; return @@v2@@ ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_210028 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = ( __int64 * ) & slotvec0 ; } nslots = Number ; return @@result@@ ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
__int64 __fastcall xstrcoll_df_size ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_size ( @@a1@@ , @@a2@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) xstrcoll ) ; }
__int64 __fastcall argv_iter_n_args ( _QWORD * @@a1@@ ) { __int64 @@result@@ ; if ( * @@a1@@ ) @@result@@ = @@a1@@ [ Number ] ; else @@result@@ = ( __int64 ) ( @@a1@@ [ Number ] - @@a1@@ [ Number ] ) >> Number ; return @@result@@ ; }
__int64 __fastcall fts_children ( __int64 @@a1@@ , int @@a2@@ ) { __int64 @@v3@@ ; __int64 @@v4@@ ; int @@v5@@ ; int @@v6@@ ; int @@v7@@ ; int @@v8@@ ; unsigned int @@v9@@ ; int @@fd@@ ; int @@v11@@ ; if ( @@a2@@ && @@a2@@ != Number ) { * __errno_location ( ) = Number ; return Number L ; } @@v3@@ = * ( _QWORD * ) @@a1@@ ; * __errno_location ( ) = Number ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) return Number L ; if ( * ( _WORD * ) ( @@v3@@ + Number ) == Number ) return * ( _QWORD * ) ( @@v3@@ + Number ) ; if ( * ( _WORD * ) ( @@v3@@ + Number ) != Number ) return Number L ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) fts_lfree ( * ( void * * ) ( @@a1@@ + Number ) ) ; if ( @@a2@@ == Number ) { @@v8@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; BYTE1 ( @@v8@@ ) |= Number ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@v8@@ ; @@v9@@ = Number ; } else { @@v9@@ = Number ; } if ( * ( _QWORD * ) ( @@v3@@ + Number ) || * * ( _BYTE * * ) ( @@v3@@ + Number ) == Number || ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { * ( _QWORD * ) ( @@a1@@ + Number ) = fts_build ( @@a1@@ , @@v9@@ ) ; return * ( _QWORD * ) ( @@a1@@ + Number ) ; } @@fd@@ = diropen ( @@a1@@ , ( int ) & unk_CD49 , @@v4@@ , @@v5@@ , @@v6@@ , @@v7@@ ) ; if ( @@fd@@ < Number ) { * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; return Number L ; } * ( _QWORD * ) ( @@a1@@ + Number ) = fts_build ( @@a1@@ , @@v9@@ ) ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { cwd_advance_fd ( @@a1@@ , @@fd@@ , Number ) ; } else { if ( fchdir ( @@fd@@ ) ) { @@v11@@ = * __errno_location ( ) ; close ( @@fd@@ ) ; * __errno_location ( ) = @@v11@@ ; return Number L ; } close ( @@fd@@ ) ; } return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
void * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
__int64 __fastcall strcmp_df_name ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_name ( @@a1@@ , @@a2@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) & strcmp ) ; }
__int64 __fastcall fts_compar ( __int64 @@a1@@ , __int64 @@a2@@ ) { return ( * ( __int64 ( __fastcall * * ) ( __int64 , __int64 ) ) ( * ( _QWORD * ) ( * ( _QWORD * ) @@a1@@ + Number L ) + Number L ) ) ( @@a1@@ , @@a2@@ ) ; }
int __fastcall readtokens0_init ( __int64 @@a1@@ ) { * ( _QWORD * ) @@a1@@ = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; _obstack_begin ( ( struct obstack * ) ( @@a1@@ + Number ) , Number , Number , ( void * ( * ) ( __int64 ) ) & malloc , ( void ( * ) ( void * ) ) & free ) ; _obstack_begin ( ( struct obstack * ) ( @@a1@@ + Number ) , Number , Number , ( void * ( * ) ( __int64 ) ) & malloc , ( void ( * ) ( void * ) ) & free ) ; return _obstack_begin ( ( struct obstack * ) ( @@a1@@ + Number ) , Number , Number , ( void * ( * ) ( __int64 ) ) & malloc , ( void ( * ) ( void * ) ) & free ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
size_t __fastcall fts_maxarglen ( const char * * @@a1@@ ) { size_t @@v3@@ ; size_t @@v4@@ ; @@v3@@ = Number L ; while ( * @@a1@@ ) { @@v4@@ = strlen ( * @@a1@@ ) ; if ( @@v4@@ > @@v3@@ ) @@v3@@ = @@v4@@ ; ++ @@a1@@ ; } return @@v3@@ + Number ; }
__int64 __fastcall rev_xstrcoll_df_extension ( const char * * @@a1@@ , const char * * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_extension ( @@a2@@ , @@a1@@ , xstrcoll ) ; }
void * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_210108 ; @@v4@@ [ Number ] = qword_210110 ; @@v4@@ [ Number ] = qword_210118 ; @@v4@@ [ Number ] = qword_210120 ; @@v4@@ [ Number ] = qword_210128 ; @@v4@@ [ Number ] = qword_210130 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_21F238 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
int __fastcall hash_print_statistics ( __int64 @@a1@@ , FILE * @@a2@@ ) { double @@v2@@ ; double @@v3@@ ; double @@v4@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v6@@ = hash_get_n_entries ( @@a1@@ ) ; @@v7@@ = hash_get_n_buckets ( @@a1@@ ) ; @@v8@@ = hash_get_n_buckets_used ( @@a1@@ ) ; @@v9@@ = hash_get_max_bucket_length ( @@a1@@ ) ; fprintf ( @@a2@@ , String , @@v6@@ ) ; fprintf ( @@a2@@ , String , @@v7@@ ) ; if ( @@v8@@ < Number ) @@v2@@ = ( double ) ( int ) ( @@v8@@ & Number | ( ( unsigned __int64 ) @@v8@@ >> Number ) ) + ( double ) ( int ) ( @@v8@@ & Number | ( ( unsigned __int64 ) @@v8@@ >> Number ) ) ; else @@v2@@ = ( double ) ( int ) @@v8@@ ; @@v3@@ = Number * @@v2@@ ; if ( @@v7@@ < Number ) @@v4@@ = ( double ) ( int ) ( @@v7@@ & Number | ( ( unsigned __int64 ) @@v7@@ >> Number ) ) + ( double ) ( int ) ( @@v7@@ & Number | ( ( unsigned __int64 ) @@v7@@ >> Number ) ) ; else @@v4@@ = ( double ) ( int ) @@v7@@ ; fprintf ( @@a2@@ , String , @@v8@@ , @@v3@@ / @@v4@@ ) ; return fprintf ( @@a2@@ , String , @@v9@@ ) ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
__int64 sort_files ( ) { __int64 @@result@@ ; int @@v1@@ ; unsigned __int8 @@v2@@ ; if ( cwd_n_used + ( ( unsigned __int64 ) cwd_n_used >> Number ) > sorted_file_alloc ) { free ( sorted_file ) ; sorted_file = ( void * ) xnmalloc ( cwd_n_used , Number L ) ; sorted_file_alloc = Number * cwd_n_used ; } initialize_ordering_vector ( ) ; @@result@@ = ( unsigned int ) sort_type ; if ( sort_type != Number ) { if ( _setjmp ( failed_strcoll ) ) { @@v2@@ = Number ; if ( sort_type == Number ) __assert_fail ( String , String , Number , String ) ; initialize_ordering_vector ( ) ; } else { @@v2@@ = Number ; } if ( sort_type == Number ) @@v1@@ = time_type ; else @@v1@@ = Number ; @@result@@ = mpsort ( sorted_file , cwd_n_used , * ( & sort_functions [ Number * ( unsigned int ) ( @@v1@@ + sort_type ) ] + Number * @@v2@@ + Number * ( unsigned __int8 ) sort_reverse + ( unsigned __int8 ) directories_first ) ) ; } return @@result@@ ; }
unsigned __int64 __fastcall hash_string ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ ) { unsigned __int64 @@v4@@ ; @@v4@@ = Number L ; while ( * @@a1@@ ) @@v4@@ = ( Number * @@v4@@ + ( unsigned __int8 ) * @@a1@@ ++ ) % @@a2@@ ; return @@v4@@ ; }
__int64 __fastcall bkm_scale_by_power ( unsigned __int64 * @@a1@@ , int @@a2@@ , int @@a3@@ ) { unsigned int @@i@@ ; for ( @@i@@ = Number ; @@a3@@ -- ; @@i@@ |= bkm_scale ( @@a1@@ , @@a2@@ ) ) { ; } return @@i@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_21FE88 ; @@v4@@ [ Number ] = qword_21FE90 ; @@v4@@ [ Number ] = qword_21FE98 ; @@v4@@ [ Number ] = qword_21FEA0 ; @@v4@@ [ Number ] = qword_21FEA8 ; @@v4@@ [ Number ] = qword_21FEB0 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_209028 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
unsigned __int64 __fastcall raw_hasher ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return rotr_sz ( @@a1@@ , Number ) % @@a2@@ ; }
size_t __fastcall format_user_width ( unsigned int @@a1@@ ) { __int64 @@v1@@ ; if ( numeric_ids ) @@v1@@ = Number L ; else @@v1@@ = getuser ( @@a1@@ ) ; return format_user_or_group_width ( @@v1@@ , @@a1@@ ) ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
__int64 __fastcall umaxtostr ( unsigned __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v4@@ ; @@v4@@ = @@a2@@ + Number ; * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; do { * ( _BYTE * ) -- @@v4@@ = @@a1@@ % Number + Number ; @@a1@@ /= Number ; } while ( @@a1@@ ) ; return @@v4@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_209108 ; @@v4@@ [ Number ] = qword_209110 ; @@v4@@ [ Number ] = qword_209118 ; @@v4@@ [ Number ] = qword_209120 ; @@v4@@ [ Number ] = qword_209128 ; @@v4@@ [ Number ] = qword_209130 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
void __fastcall hash_free ( __int64 @@a1@@ ) { _QWORD * @@i@@ ; _QWORD * @@j@@ ; _QWORD * @@ptr@@ ; _QWORD * @@ptra@@ ; _QWORD * @@ptrb@@ ; _QWORD * @@v6@@ ; _QWORD * @@v7@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) && * ( _QWORD * ) ( @@a1@@ + Number ) ) { for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@ptr@@ = @@i@@ ; @@ptr@@ ; @@ptr@@ = ( _QWORD * ) @@ptr@@ [ Number ] ) { ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@ptr@@ ) ; } } } } for ( @@j@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@j@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@j@@ += Number ) { for ( @@ptra@@ = ( _QWORD * ) @@j@@ [ Number ] ; @@ptra@@ ; @@ptra@@ = @@v6@@ ) { @@v6@@ = ( _QWORD * ) @@ptra@@ [ Number ] ; free ( @@ptra@@ ) ; } } for ( @@ptrb@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; @@ptrb@@ ; @@ptrb@@ = @@v7@@ ) { @@v7@@ = ( _QWORD * ) @@ptrb@@ [ Number ] ; free ( @@ptrb@@ ) ; } free ( * ( void * * ) @@a1@@ ) ; free ( ( void * ) @@a1@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@v3@@ ; @@v3@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v3@@ ) xalloc_die ( ) ; return @@v3@@ ; }
__int64 __fastcall fd_safer ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { unsigned int @@fd@@ ; unsigned int @@v8@@ ; int @@v9@@ ; @@fd@@ = @@a1@@ ; if ( @@a1@@ >= Number && @@a1@@ <= Number ) { @@v8@@ = dup_safer ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; @@v9@@ = * __errno_location ( ) ; close ( @@a1@@ ) ; * __errno_location ( ) = @@v9@@ ; @@fd@@ = @@v8@@ ; } return @@fd@@ ; }
size_t __fastcall print_name_with_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , struct obstack * @@a3@@ , unsigned __int64 @@a4@@ ) { __int64 @@v4@@ ; bool @@v5@@ ; bool @@v9@@ ; __int64 @@v10@@ ; size_t @@v11@@ ; if ( @@a2@@ ) @@v4@@ = @@a1@@ [ Number ] ; else @@v4@@ = * @@a1@@ ; @@v10@@ = @@v4@@ ; @@v5@@ = print_with_color && ( unsigned __int8 ) print_color_indicator ( @@a1@@ , @@a2@@ ) ; @@v9@@ = @@v5@@ ; if ( @@a3@@ && dired ) { if ( @@a3@@ -> next_free + Number > @@a3@@ -> chunk_limit ) _obstack_newchunk ( @@a3@@ , Number ) ; memcpy ( @@a3@@ -> next_free , & dired_pos , Number ) ; @@a3@@ -> next_free += Number ; } @@v11@@ = quote_name ( stdout , @@v10@@ , filename_quoting_options , Number L ) ; dired_pos += @@v11@@ ; if ( @@a3@@ && dired ) { if ( @@a3@@ -> next_free + Number > @@a3@@ -> chunk_limit ) _obstack_newchunk ( @@a3@@ , Number ) ; memcpy ( @@a3@@ -> next_free , & dired_pos , Number ) ; @@a3@@ -> next_free += Number ; } if ( @@v9@@ ) { process_signals ( ) ; prep_non_filename_text ( ) ; if ( @@a4@@ / line_length != ( @@a4@@ + @@v11@@ - Number ) / line_length ) put_indicator ( & unk_21F1F0 ) ; } return @@v11@@ ; }
ssize_t __fastcall safe_read ( int @@a1@@ , void * @@a2@@ , size_t @@a3@@ ) { ssize_t @@result@@ ; ssize_t @@v5@@ ; LABEL_1 : for ( @@result@@ = read ( @@a1@@ , @@a2@@ , @@a3@@ ) ; ; @@result@@ = read ( @@a1@@ , @@a2@@ , Number ) ) { @@v5@@ = @@result@@ ; if ( @@result@@ >= Number ) break ; if ( * __errno_location ( ) == Number ) goto LABEL_1 ; if ( * __errno_location ( ) != Number || @@a3@@ <= Number ) return @@v5@@ ; @@a3@@ = Number L ; } return @@result@@ ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
int __fastcall lstat ( char * @@filename@@ , struct stat * @@stat_buf@@ ) { return __lxstat ( Number , @@filename@@ , @@stat_buf@@ ) ; }
unsigned __int64 __fastcall indent ( unsigned __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { unsigned __int64 @@result@@ ; while ( Number ) { @@result@@ = @@a1@@ ; if ( @@a1@@ >= @@a2@@ ) break ; if ( tabsize && @@a2@@ / tabsize > ( @@a1@@ + Number ) / tabsize ) { putchar_unlocked ( Number ) ; @@a1@@ += tabsize - @@a1@@ % tabsize ; } else { putchar_unlocked ( Number ) ; ++ @@a1@@ ; } } return @@result@@ ; }
__int64 __fastcall hash_rehash ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; unsigned __int64 @@nmemb@@ ; void * @@v4@@ ; __int64 @@v5@@ ; unsigned __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; __int64 @@v12@@ ; __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; @@v14@@ = __readfsqword ( Number ) ; @@nmemb@@ = compute_bucket_size ( @@a2@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ; if ( ! @@nmemb@@ ) return Number L ; if ( @@nmemb@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; @@v4@@ = calloc ( @@nmemb@@ , Number ) ; if ( ! @@v4@@ ) return Number L ; @@v6@@ = @@nmemb@@ ; @@v5@@ = ( __int64 ) @@v4@@ + Number * @@nmemb@@ ; @@v7@@ = Number L ; @@v8@@ = Number L ; @@v9@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v10@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v11@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v12@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v13@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( ( unsigned __int8 ) transfer_entries ( ( __int64 ) & @@v4@@ , @@a1@@ , Number ) ) { free ( * ( void * * ) @@a1@@ ) ; * ( _QWORD * ) @@a1@@ = @@v4@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v5@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v6@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v7@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v13@@ ; @@result@@ = Number L ; } else { * ( _QWORD * ) ( @@a1@@ + Number ) = @@v13@@ ; if ( ( unsigned __int8 ) transfer_entries ( @@a1@@ , ( __int64 ) & @@v4@@ , Number ) != Number || ( unsigned __int8 ) transfer_entries ( @@a1@@ , ( __int64 ) & @@v4@@ , Number ) != Number ) { abort ( ) ; } free ( @@v4@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
void * __fastcall xzalloc ( size_t @@a1@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@a1@@ ) ; return memset ( @@v1@@ , Number , @@a1@@ ) ; }
__int64 __fastcall i_ring_empty ( __int64 @@a1@@ ) { return * ( unsigned __int8 * ) ( @@a1@@ + Number ) ; }
int __fastcall fstatat ( int @@fildes@@ , char * @@filename@@ , struct stat * @@stat_buf@@ , int @@flag@@ ) { return __fxstatat ( Number , @@fildes@@ , @@filename@@ , @@stat_buf@@ , @@flag@@ ) ; }
unsigned __int64 init_column_info ( ) { unsigned __int64 @@v0@@ ; unsigned __int64 @@result@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@j@@ ; unsigned __int64 @@v4@@ ; __int64 @@v5@@ ; unsigned __int64 @@k@@ ; unsigned __int64 @@v7@@ ; unsigned __int64 @@v8@@ ; @@v0@@ = max_idx ; if ( cwd_n_used <= ( unsigned __int64 ) max_idx ) @@v0@@ = cwd_n_used ; @@v7@@ = @@v0@@ ; if ( @@v0@@ > column_info_alloc_8572 ) { if ( @@v0@@ >= ( unsigned __int64 ) max_idx >> Number ) { column_info = xnrealloc ( column_info , max_idx , Number L ) ; @@v4@@ = max_idx ; } else { column_info = xnrealloc ( column_info , @@v0@@ , Number L ) ; @@v4@@ = Number * @@v7@@ ; } @@v8@@ = ( @@v4@@ - column_info_alloc_8572 ) * ( column_info_alloc_8572 + @@v4@@ + Number ) ; if ( column_info_alloc_8572 + @@v4@@ + Number < @@v4@@ || column_info_alloc_8572 + @@v4@@ + Number != @@v8@@ / ( @@v4@@ - column_info_alloc_8572 ) ) { xalloc_die ( ) ; } @@v5@@ = xnmalloc ( @@v8@@ >> Number , Number L ) ; for ( @@i@@ = column_info_alloc_8572 ; @@i@@ < @@v4@@ ; ++ @@i@@ ) { * ( _QWORD * ) ( column_info + Number * @@i@@ + Number ) = @@v5@@ ; @@v5@@ += Number * ( @@i@@ + Number ) ; } column_info_alloc_8572 = @@v4@@ ; } for ( @@j@@ = Number L ; ; ++ @@j@@ ) { @@result@@ = @@j@@ ; if ( @@j@@ >= @@v7@@ ) break ; * ( _BYTE * ) ( column_info + Number * @@j@@ ) = Number ; * ( _QWORD * ) ( column_info + Number * @@j@@ + Number ) = Number * ( @@j@@ + Number ) ; for ( @@k@@ = Number L ; @@k@@ <= @@j@@ ; ++ @@k@@ ) * ( _QWORD * ) ( Number * @@k@@ + * ( _QWORD * ) ( column_info + Number * @@j@@ + Number ) ) = Number L ; } return @@result@@ ; }
__int64 __fastcall bkm_scale_by_power ( unsigned __int64 * @@a1@@ , int @@a2@@ , int @@a3@@ ) { unsigned int @@i@@ ; for ( @@i@@ = Number ; @@a3@@ -- ; @@i@@ |= bkm_scale ( @@a1@@ , @@a2@@ ) ) { ; } return @@i@@ ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
__int64 __fastcall wc_ensure_printable ( wint_t * @@a1@@ ) { unsigned __int8 @@v2@@ ; @@v2@@ = Number ; while ( * @@a1@@ ) { if ( ! iswprint ( * @@a1@@ ) ) { * @@a1@@ = Number ; @@v2@@ = Number ; } ++ @@a1@@ ; } return @@v2@@ ; }
_BOOL8 __fastcall c_isalnum ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number || ( int ) ( @@a1@@ & Number ) > Number && ( int ) ( @@a1@@ & Number ) <= Number ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
__int64 __fastcall open_safer ( const char * @@a1@@ , char @@a2@@ , unsigned int @@a3@@ ) { unsigned int @@v3@@ ; unsigned int @@v5@@ ; @@v5@@ = Number ; if ( ( @@a2@@ & Number ) != Number ) @@v5@@ = @@a3@@ ; @@v3@@ = open ( @@a1@@ , @@a2@@ , @@v5@@ ) ; return fd_safer ( @@v3@@ ) ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
_BOOL8 __fastcall c_isgraph ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
struct group * getgrnam ( const char * @@name@@ ) { return getgrnam ( @@name@@ ) ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
_BOOL8 __fastcall c_isupper ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
_BYTE * __fastcall mbs_align_pad ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ ) { _BYTE * @@v3@@ ; __int64 @@v4@@ ; while ( Number ) { @@v4@@ = @@a3@@ -- ; if ( ! @@v4@@ || ( unsigned __int64 ) @@a1@@ >= @@a2@@ ) break ; @@v3@@ = @@a1@@ ++ ; * @@v3@@ = Number ; } * @@a1@@ = Number ; return @@a1@@ ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
__int64 __fastcall c_toupper ( int @@a1@@ ) { __int64 @@result@@ ; if ( @@a1@@ <= Number || @@a1@@ > Number ) @@result@@ = ( unsigned int ) @@a1@@ ; else @@result@@ = ( unsigned int ) ( @@a1@@ - Number ) ; return @@result@@ ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; char * @@v3@@ ; FILE * @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; @@v1@@ = program_name ; if ( @@a1@@ ) { @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = gettext ( String ) ; printf ( @@v3@@ , @@v1@@ ) ; @@v4@@ = stdout ; @@v5@@ = gettext ( String ) ; fputs_unlocked ( @@v5@@ , @@v4@@ ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; @@v8@@ = stdout ; @@v9@@ = gettext ( String ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
int __fastcall lstat ( char * @@filename@@ , struct stat * @@stat_buf@@ ) { return __lxstat ( Number , @@filename@@ , @@stat_buf@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
__int64 __fastcall mbsnwidth ( char * @@a1@@ , __int64 @@a2@@ , char @@a3@@ ) { int @@v3@@ ; char * @@v5@@ ; unsigned __int8 @@v7@@ ; wchar_t @@pwc@@ ; unsigned int @@v9@@ ; int @@v10@@ ; char * @@v11@@ ; size_t @@v12@@ ; char * @@v13@@ ; mbstate_t @@s@@ [ Number ] ; @@s@@ [ Number ] = ( mbstate_t ) __readfsqword ( Number ) ; @@v11@@ = @@a1@@ ; @@v13@@ = & @@a1@@ [ @@a2@@ ] ; @@v9@@ = Number ; if ( __ctype_get_mb_cur_max ( ) > Number ) { while ( Number ) { LABEL_28 : if ( @@v11@@ >= @@v13@@ ) return @@v9@@ ; @@v3@@ = * @@v11@@ ; if ( @@v3@@ > Number ) { if ( @@v3@@ < Number || @@v3@@ > Number && ( unsigned int ) ( @@v3@@ - Number ) > Number ) { LABEL_11 : memset ( @@s@@ , Number , Number ) ; while ( Number ) { @@v12@@ = mbrtowc ( & @@pwc@@ , @@v11@@ , @@v13@@ - @@v11@@ , @@s@@ ) ; if ( @@v12@@ == Number ) { if ( ( @@a3@@ & Number ) == Number ) { ++ @@v11@@ ; ++ @@v9@@ ; goto LABEL_28 ; } return Number ; } if ( @@v12@@ == Number ) break ; if ( ! @@v12@@ ) @@v12@@ = Number L ; @@v10@@ = wcwidth ( @@pwc@@ ) ; if ( @@v10@@ < Number ) { if ( ( @@a3@@ & Number ) != Number ) return Number ; @@v9@@ += iswcntrl ( @@pwc@@ ) == Number ; } else { @@v9@@ += @@v10@@ ; } @@v11@@ += @@v12@@ ; if ( mbsinit ( @@s@@ ) ) goto LABEL_28 ; } if ( ( @@a3@@ & Number ) == Number ) { @@v11@@ = @@v13@@ ; ++ @@v9@@ ; continue ; } return Number ; } } else if ( @@v3@@ < Number && ( unsigned int ) ( @@v3@@ - Number ) > Number ) { goto LABEL_11 ; } ++ @@v11@@ ; ++ @@v9@@ ; } } while ( @@v11@@ < @@v13@@ ) { @@v5@@ = @@v11@@ ++ ; @@v7@@ = * @@v5@@ ; if ( ( ( * __ctype_b_loc ( ) ) [ @@v7@@ ] & Number ) != Number ) { ++ @@v9@@ ; } else { if ( ( @@a3@@ & Number ) != Number ) return Number ; @@v9@@ += ( ( * __ctype_b_loc ( ) ) [ @@v7@@ ] & Number ) == Number ; } } return @@v9@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
int __lxstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _lxstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
__int64 __fastcall _xargmatch_internal ( __int64 @@a1@@ , const char * @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ , void ( * @@a6@@ ) ( void ) ) { __int64 @@v11@@ ; @@v11@@ = argmatch ( @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; if ( @@v11@@ >= Number ) return @@v11@@ ; argmatch_invalid ( @@a1@@ , ( __int64 ) @@a2@@ , @@v11@@ ) ; argmatch_valid ( @@a3@@ , @@a4@@ , @@a5@@ ) ; @@a6@@ ( ) ; return Number ; }
void * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
struct group * getgrnam ( const char * @@name@@ ) { return getgrnam ( @@name@@ ) ; }
void * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_206028 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
int fchdir ( int @@fd@@ ) { return fchdir ( @@fd@@ ) ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
__ino_t * __fastcall get_root_dev_ino ( __ino_t * @@a1@@ ) { struct stat @@v2@@ ; unsigned __int64 @@v3@@ ; @@v3@@ = __readfsqword ( Number ) ; if ( ( unsigned int ) lstat ( String , & @@v2@@ ) ) return Number L ; * @@a1@@ = @@v2@@ . st_ino ; @@a1@@ [ Number ] = @@v2@@ . st_dev ; return @@a1@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
void * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
void * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
_BYTE * __fastcall longest_relative_suffix ( _BYTE * @@a1@@ ) { while ( * @@a1@@ == Number ) ++ @@a1@@ ; return @@a1@@ ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
__int64 __fastcall hard_locale ( int @@a1@@ ) { unsigned __int8 @@v2@@ ; const char * @@s1@@ ; @@v2@@ = Number ; @@s1@@ = setlocale ( @@a1@@ , Number L ) ; if ( @@s1@@ && ( ! strcmp ( @@s1@@ , String ) || ! strcmp ( @@s1@@ , String ) ) ) @@v2@@ = Number ; return @@v2@@ ; }
void * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_208108 ; @@v8@@ [ Number ] = qword_208110 ; @@v8@@ [ Number ] = qword_208118 ; @@v8@@ [ Number ] = qword_208120 ; @@v8@@ [ Number ] = qword_208128 ; @@v8@@ [ Number ] = qword_208130 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
void __fastcall describe_change ( __int64 @@a1@@ , int @@a2@@ , const char * @@a3@@ , const char * @@a4@@ ) { __int64 @@v4@@ ; char * @@v5@@ ; size_t @@v6@@ ; size_t @@v7@@ ; char * @@v8@@ ; char * @@v9@@ ; char * @@v10@@ ; char * @@v11@@ ; __int64 @@v12@@ ; char * @@format@@ ; void * @@v16@@ ; char * @@dest@@ ; @@dest@@ = Number L ; if ( @@a2@@ == Number ) { @@v4@@ = quote ( @@a1@@ ) ; @@v5@@ = gettext ( String ) ; printf ( @@v5@@ , @@v4@@ ) ; } else { if ( @@a3@@ ) { if ( @@a4@@ ) { @@v6@@ = strlen ( @@a3@@ ) ; @@v7@@ = strlen ( @@a4@@ ) ; @@dest@@ = ( char * ) xmalloc ( @@v6@@ + @@v7@@ + Number ) ; @@v8@@ = stpcpy ( @@dest@@ , @@a3@@ ) ; * ( _WORD * ) @@v8@@ = Number ; strcpy ( @@v8@@ + Number , @@a4@@ ) ; @@v16@@ = @@dest@@ ; } else { @@v16@@ = ( void * ) @@a3@@ ; } } else { @@v16@@ = ( void * ) @@a4@@ ; } switch ( @@a2@@ ) { case Number : if ( @@a3@@ ) { @@v10@@ = gettext ( String ) ; } else if ( @@a4@@ ) { @@v10@@ = gettext ( String ) ; } else { @@v10@@ = gettext ( String ) ; } @@format@@ = @@v10@@ ; break ; case Number : if ( @@a3@@ ) { @@v11@@ = gettext ( String ) ; } else if ( @@a4@@ ) { @@v11@@ = gettext ( String ) ; } else { @@v11@@ = gettext ( String ) ; } @@format@@ = @@v11@@ ; break ; case Number : if ( @@a3@@ ) { @@v9@@ = gettext ( String ) ; } else if ( @@a4@@ ) { @@v9@@ = gettext ( String ) ; } else { @@v9@@ = gettext ( String ) ; } @@format@@ = @@v9@@ ; break ; default : abort ( ) ; } @@v12@@ = quote ( @@a1@@ ) ; printf ( @@format@@ , @@v12@@ , @@v16@@ ) ; free ( @@dest@@ ) ; } }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
_BOOL8 __fastcall hash_table_ok ( __int64 @@a1@@ ) { _QWORD * @@i@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; _QWORD * @@v5@@ ; @@v3@@ = Number L ; @@v4@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { @@v5@@ = @@i@@ ; ++ @@v3@@ ; ++ @@v4@@ ; while ( Number ) { @@v5@@ = ( _QWORD * ) @@v5@@ [ Number ] ; if ( ! @@v5@@ ) break ; ++ @@v4@@ ; } } } return @@v3@@ == * ( _QWORD * ) ( @@a1@@ + Number ) && @@v4@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ; }
_BOOL8 __fastcall cycle_warning_required ( __int64 @@a1@@ , __int64 @@a2@@ ) { return ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number && ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) == Number || ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number && ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number && * ( _QWORD * ) ( @@a2@@ + Number ) ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall dup_safer ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
unsigned __int64 __fastcall hash_get_entries ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; _QWORD * @@i@@ ; _QWORD * @@j@@ ; @@v5@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = @@i@@ ; @@j@@ ; @@j@@ = ( _QWORD * ) @@j@@ [ Number ] ) { if ( @@v5@@ >= @@a3@@ ) return @@v5@@ ; @@v4@@ = @@v5@@ ++ ; * ( _QWORD * ) ( @@a2@@ + Number * @@v4@@ ) = * @@j@@ ; } } } return @@v5@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
int __fastcall stat ( char * @@filename@@ , struct stat * @@stat_buf@@ ) { return __xstat ( Number , @@filename@@ , @@stat_buf@@ ) ; }
unsigned __int64 __fastcall raw_hasher ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return rotr_sz ( @@a1@@ , Number ) % @@a2@@ ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
__int64 __fastcall setup_dir ( __int64 @@a1@@ ) { if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { * ( _QWORD * ) ( @@a1@@ + Number ) = hash_initialize ( Number L , Number L , AD_hash , AD_compare , & free ) ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; } else { * ( _QWORD * ) ( @@a1@@ + Number ) = malloc ( Number ) ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; cycle_check_init ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ; } return Number L ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
struct tm * localtime ( const time_t * @@timer@@ ) { return localtime ( @@timer@@ ) ; }
__int64 __fastcall fts_set_stat_required ( __int64 @@a1@@ , char @@a2@@ ) { __int64 @@v2@@ ; __int64 @@result@@ ; if ( * ( _WORD * ) ( @@a1@@ + Number ) != Number ) abort ( ) ; if ( @@a2@@ ) @@v2@@ = Number L ; else @@v2@@ = Number L ; @@result@@ = @@a1@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v2@@ ; return @@result@@ ; }
int iswcntrl ( wint_t @@wc@@ ) { return iswcntrl ( @@wc@@ ) ; }
size_t * __fastcall hash_initialize ( __int64 @@a1@@ , void * @@a2@@ , unsigned __int64 ( __fastcall * @@a3@@ ) ( __int64 a1 , unsigned __int64 a2 ) , bool ( __fastcall * @@a4@@ ) ( __int64 a1 , __int64 a2 ) , size_t @@a5@@ ) { size_t * @@result@@ ; bool ( __fastcall * @@v7@@ ) ( __int64 , __int64 ) ; unsigned __int64 ( __fastcall * @@v8@@ ) ( __int64 , unsigned __int64 ) ; void * @@v9@@ ; size_t * @@ptr@@ ; @@v9@@ = @@a2@@ ; @@v8@@ = @@a3@@ ; @@v7@@ = @@a4@@ ; if ( ! @@a3@@ ) @@v8@@ = raw_hasher ; if ( ! @@a4@@ ) @@v7@@ = raw_comparator ; @@ptr@@ = ( size_t * ) malloc ( Number ) ; if ( ! @@ptr@@ ) return Number L ; if ( ! @@a2@@ ) @@v9@@ = & default_tuning ; @@ptr@@ [ Number ] = ( size_t ) @@v9@@ ; if ( ( unsigned __int8 ) check_tuning ( ( __int64 ) @@ptr@@ ) == Number && ( @@ptr@@ [ Number ] = compute_bucket_size ( @@a1@@ , ( __int64 ) @@v9@@ ) ) != Number && ( * @@ptr@@ = ( size_t ) calloc ( @@ptr@@ [ Number ] , Number ) ) != Number ) { @@ptr@@ [ Number ] = Number * @@ptr@@ [ Number ] + * @@ptr@@ ; @@ptr@@ [ Number ] = Number L ; @@ptr@@ [ Number ] = Number L ; @@ptr@@ [ Number ] = ( size_t ) @@v8@@ ; @@ptr@@ [ Number ] = ( size_t ) @@v7@@ ; @@ptr@@ [ Number ] = @@a5@@ ; @@ptr@@ [ Number ] = Number L ; @@result@@ = @@ptr@@ ; } else { free ( @@ptr@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
struct passwd * getpwuid ( __uid_t @@uid@@ ) { return getpwuid ( @@uid@@ ) ; }
__int64 __fastcall append_quoted ( char * @@a1@@ ) { int @@v1@@ ; char * @@v2@@ ; char * @@v3@@ ; char * @@v4@@ ; char * @@v5@@ ; char * @@v6@@ ; __int64 @@result@@ ; bool @@v9@@ ; @@v9@@ = Number ; while ( Number ) { @@result@@ = ( unsigned __int8 ) * @@a1@@ ; if ( ! ( _BYTE ) @@result@@ ) return @@result@@ ; @@v1@@ = * @@a1@@ ; if ( @@v1@@ == Number ) goto LABEL_18 ; if ( @@v1@@ > Number ) { if ( @@v1@@ == Number || @@v1@@ == Number ) { @@v9@@ = ! @@v9@@ ; goto LABEL_23 ; } goto LABEL_22 ; } if ( @@v1@@ != Number ) { if ( @@v1@@ == Number ) { LABEL_18 : if ( @@v9@@ ) { if ( lsc_obstack . next_free + Number > lsc_obstack . chunk_limit ) _obstack_newchunk ( & lsc_obstack , Number ) ; @@v5@@ = lsc_obstack . next_free ; lsc_obstack . next_free = @@v5@@ + Number ; * @@v5@@ = Number ; } } LABEL_22 : @@v9@@ = Number ; goto LABEL_23 ; } if ( lsc_obstack . next_free + Number > lsc_obstack . chunk_limit ) _obstack_newchunk ( & lsc_obstack , Number ) ; @@v2@@ = lsc_obstack . next_free ; lsc_obstack . next_free = @@v2@@ + Number ; * @@v2@@ = Number ; if ( lsc_obstack . next_free + Number > lsc_obstack . chunk_limit ) _obstack_newchunk ( & lsc_obstack , Number ) ; @@v3@@ = lsc_obstack . next_free ; lsc_obstack . next_free = @@v3@@ + Number ; * @@v3@@ = Number ; if ( lsc_obstack . next_free + Number > lsc_obstack . chunk_limit ) _obstack_newchunk ( & lsc_obstack , Number ) ; @@v4@@ = lsc_obstack . next_free ; lsc_obstack . next_free = @@v4@@ + Number ; * @@v4@@ = Number ; @@v9@@ = Number ; LABEL_23 : if ( lsc_obstack . next_free + Number > lsc_obstack . chunk_limit ) _obstack_newchunk ( & lsc_obstack , Number ) ; @@v6@@ = lsc_obstack . next_free ; lsc_obstack . next_free = @@v6@@ + Number ; * @@v6@@ = * @@a1@@ ++ ; } }
__int64 __fastcall diropen ( __int64 @@a1@@ , int @@a2@@ , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { int @@v6@@ ; int @@v8@@ ; unsigned int @@v9@@ ; @@v8@@ = ( * ( _DWORD * ) ( @@a1@@ + Number ) << Number ) & Number | Number ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) @@v6@@ = openat_safer ( * ( _DWORD * ) ( @@a1@@ + Number ) , @@a2@@ , @@v8@@ , @@a2@@ , @@a5@@ , @@a6@@ , @@a2@@ ) ; else @@v6@@ = open_safer ( @@a2@@ , @@v8@@ , @@v8@@ , @@a4@@ , @@a5@@ , @@a6@@ , @@a2@@ ) ; @@v9@@ = @@v6@@ ; if ( @@v6@@ >= Number ) set_cloexec_flag ( ( unsigned int ) @@v6@@ , Number L ) ; return @@v9@@ ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
struct group * getgrgid ( __gid_t @@gid@@ ) { return getgrgid ( @@gid@@ ) ; }
long double __fastcall adjust_value ( int @@a1@@ , long double @@a2@@ ) { _BOOL4 @@v7@@ ; unsigned __int64 @@v9@@ ; if ( @@a1@@ != Number && @@a2@@ < Number ) { if ( @@a2@@ >= Number ) @@v9@@ = ( __int64 ) ( @@a2@@ - Number ) ^ Number ; else @@v9@@ = ( __int64 ) @@a2@@ ; @@v7@@ = ! @@a1@@ && @@a2@@ != ( long double ) @@v9@@ ; @@a2@@ = ( long double ) ( @@v7@@ + @@v9@@ ) ; } return @@a2@@ ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
int dirfd ( DIR * @@dirp@@ ) { return dirfd ( @@dirp@@ ) ; }
_BOOL8 __fastcall dirent_inode_sort_may_be_useful ( int @@a1@@ ) { struct statfs @@buf@@ ; unsigned __int64 @@v3@@ ; @@v3@@ = __readfsqword ( Number ) ; if ( fstatfs ( @@a1@@ , & @@buf@@ ) ) return Number L ; return @@buf@@ . f_type != Number && @@buf@@ . f_type != Number ; }
__pid_t tcgetpgrp ( int @@fd@@ ) { return tcgetpgrp ( @@fd@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
time_t mktime ( struct tm * @@tp@@ ) { return mktime ( @@tp@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
void * malloc ( size_t @@size@@ ) { return __imp_malloc ( @@size@@ ) ; }
_BOOL8 __fastcall leaf_optimization_applies ( int @@a1@@ ) { _BOOL8 @@result@@ ; struct statfs @@buf@@ ; unsigned __int64 @@v3@@ ; @@v3@@ = __readfsqword ( Number ) ; if ( fstatfs ( @@a1@@ , & @@buf@@ ) ) @@result@@ = Number L ; else @@result@@ = @@buf@@ . f_type == Number ; return @@result@@ ; }
__int64 __fastcall humblock ( char * @@a1@@ , _QWORD * @@a2@@ , int * @@a3@@ ) { char * @@v5@@ ; int @@v6@@ ; int @@v7@@ ; unsigned int @@v8@@ ; __int64 @@v9@@ [ Number ] ; @@v5@@ = @@a1@@ ; @@v9@@ [ Number ] = __readfsqword ( Number ) ; @@v6@@ = Number ; if ( @@a1@@ || ( @@v5@@ = getenv ( String ) ) != Number L || ( @@v5@@ = getenv ( String ) ) != Number L ) { if ( * @@v5@@ == Number ) { @@v6@@ = Number ; ++ @@v5@@ ; } @@v7@@ = argmatch ( @@v5@@ , ( __int64 ) block_size_args , ( __int64 ) block_size_opts , Number ) ; if ( @@v7@@ < Number ) { @@v8@@ = xstrtoumax ( @@v5@@ , @@v9@@ , Number L , @@a2@@ , String ) ; if ( @@v8@@ ) { * @@a3@@ = Number ; return @@v8@@ ; } while ( * @@v5@@ <= Number || * @@v5@@ > Number ) { if ( @@v5@@ == ( char * ) @@v9@@ [ Number ] ) { @@v6@@ |= Number ; if ( * ( _BYTE * ) ( @@v9@@ [ Number ] - Number ) == Number ) @@v6@@ |= Number ; if ( * ( _BYTE * ) ( @@v9@@ [ Number ] - Number ) != Number || * ( _BYTE * ) ( @@v9@@ [ Number ] - Number ) == Number ) @@v6@@ |= Number ; break ; } ++ @@v5@@ ; } } else { @@v6@@ |= block_size_opts [ @@v7@@ ] ; * @@a2@@ = Number L ; } } else { * @@a2@@ = default_block_size ( ) ; } * @@a3@@ = @@v6@@ ; return Number L ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
__int64 __fastcall get_stat_ctime ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
__int64 __fastcall fts_set ( __int64 a1 , __int64 @@a2@@ , int @@a3@@ ) { __int64 @@result@@ ; if ( ! @@a3@@ || @@a3@@ == Number || @@a3@@ == Number || @@a3@@ == Number || @@a3@@ == Number ) { * ( _WORD * ) ( @@a2@@ + Number ) = @@a3@@ ; @@result@@ = Number L ; } else { * __errno_location ( ) = Number ; @@result@@ = Number L ; } return @@result@@ ; }
unsigned __int64 __fastcall dev_ino_hash ( _QWORD * @@a1@@ , unsigned __int64 @@a2@@ ) { return * @@a1@@ % @@a2@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
_BOOL8 __fastcall visit_dir ( __int64 @@a1@@ , __int64 @@a2@@ ) { _QWORD * @@ptr@@ ; __int64 @@v4@@ ; @@ptr@@ = ( _QWORD * ) xmalloc ( Number L ) ; * @@ptr@@ = @@a2@@ ; @@ptr@@ [ Number ] = @@a1@@ ; @@v4@@ = hash_insert ( active_dir_set , @@ptr@@ ) ; if ( ! @@v4@@ ) xalloc_die ( ) ; if ( ( _QWORD * ) @@v4@@ != @@ptr@@ ) free ( @@ptr@@ ) ; return @@v4@@ != ( _QWORD ) @@ptr@@ ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
__int64 __fastcall getgidbyname ( const char * @@a1@@ ) { __int64 @@result@@ ; size_t @@v2@@ ; __int64 @@i@@ ; __int64 @@j@@ ; __int64 @@v5@@ ; struct group * @@v6@@ ; for ( @@i@@ = group_alist ; @@i@@ ; @@i@@ = * ( _QWORD * ) ( @@i@@ + Number ) ) { if ( * ( _BYTE * ) ( @@i@@ + Number ) == * @@a1@@ && ! strcmp ( ( const char * ) ( @@i@@ + Number ) , @@a1@@ ) ) { return @@i@@ ; } } for ( @@j@@ = nogroup_alist ; @@j@@ ; @@j@@ = * ( _QWORD * ) ( @@j@@ + Number ) ) { if ( * ( _BYTE * ) ( @@j@@ + Number ) == * @@a1@@ && ! strcmp ( ( const char * ) ( @@j@@ + Number ) , @@a1@@ ) ) { return Number L ; } } @@v6@@ = getgrnam ( @@a1@@ ) ; @@v2@@ = strlen ( @@a1@@ ) ; @@v5@@ = xmalloc ( @@v2@@ + Number ) ; strcpy ( ( char * ) ( @@v5@@ + Number ) , @@a1@@ ) ; if ( @@v6@@ ) { * ( _DWORD * ) @@v5@@ = @@v6@@ -> gr_gid ; * ( _QWORD * ) ( @@v5@@ + Number ) = group_alist ; group_alist = @@v5@@ ; @@result@@ = @@v5@@ ; } else { * ( _QWORD * ) ( @@v5@@ + Number ) = nogroup_alist ; nogroup_alist = @@v5@@ ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_20A028 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
__int64 __fastcall fts_stat ( __int64 @@a1@@ , __int64 @@a2@@ , char @@a3@@ ) { __int64 @@result@@ ; __int64 @@v4@@ ; int @@v6@@ ; struct stat * @@s@@ ; @@s@@ = ( struct stat * ) ( @@a2@@ + Number ) ; if ( ! * ( _QWORD * ) ( @@a2@@ + Number ) && ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) @@a3@@ = Number ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number || @@a3@@ ) { if ( ( unsigned int ) stat ( * ( char * * ) ( @@a2@@ + Number ) , @@s@@ ) ) { @@v6@@ = * __errno_location ( ) ; if ( * __errno_location ( ) == Number && ! ( unsigned int ) lstat ( * ( char * * ) ( @@a2@@ + Number ) , @@s@@ ) ) { * __errno_location ( ) = Number ; return Number L ; } * ( _DWORD * ) ( @@a2@@ + Number ) = @@v6@@ ; goto LABEL_13 ; } } else if ( ( unsigned int ) fstatat ( * ( _DWORD * ) ( @@a1@@ + Number ) , * ( char * * ) ( @@a2@@ + Number ) , @@s@@ , Number ) ) { * ( _DWORD * ) ( @@a2@@ + Number ) = * __errno_location ( ) ; LABEL_13 : memset ( @@s@@ , Number , sizeof ( struct stat ) ) ; return Number L ; } switch ( * ( _DWORD * ) ( @@a2@@ + Number ) & Number ) { case Number : if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) @@v4@@ = Number L ; else @@v4@@ = Number L ; * ( _QWORD * ) ( @@a2@@ + Number ) = * ( _QWORD * ) ( @@a2@@ + Number ) - @@v4@@ ; if ( * ( _BYTE * ) ( @@a2@@ + Number ) != Number || * ( _BYTE * ) ( @@a2@@ + Number ) && ( * ( _BYTE * ) ( @@a2@@ + Number ) != Number || * ( _BYTE * ) ( @@a2@@ + Number ) ) ) { @@result@@ = Number L ; } else if ( * ( _QWORD * ) ( @@a2@@ + Number ) ) { @@result@@ = Number L ; } else { @@result@@ = Number L ; } break ; case Number : @@result@@ = Number L ; break ; case Number : @@result@@ = Number L ; break ; default : @@result@@ = Number L ; break ; } return @@result@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall queue_directory ( __int64 @@a1@@ , __int64 @@a2@@ , char @@a3@@ ) { __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@result@@ ; __int64 @@v7@@ ; @@v7@@ = xmalloc ( Number L ) ; if ( @@a2@@ ) @@v3@@ = xstrdup ( @@a2@@ ) ; else @@v3@@ = Number L ; * ( _QWORD * ) ( @@v7@@ + Number ) = @@v3@@ ; if ( @@a1@@ ) @@v4@@ = xstrdup ( @@a1@@ ) ; else @@v4@@ = Number L ; * ( _QWORD * ) @@v7@@ = @@v4@@ ; * ( _BYTE * ) ( @@v7@@ + Number ) = @@a3@@ ; * ( _QWORD * ) ( @@v7@@ + Number ) = pending_dirs ; @@result@@ = @@v7@@ ; pending_dirs = @@v7@@ ; return @@result@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
__int64 __fastcall hash_get_n_buckets_used ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall get_link_name ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@result@@ ; char * @@v4@@ ; * ( _QWORD * ) ( @@a2@@ + Number ) = areadlink_with_size ( @@a1@@ , * ( _QWORD * ) ( @@a2@@ + Number ) ) ; @@result@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( ! @@result@@ ) { @@v4@@ = gettext ( String ) ; @@result@@ = file_failure ( @@a3@@ , @@v4@@ , @@a1@@ ) ; } return @@result@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return xmalloc ( @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return xmalloc ( @@a1@@ , @@a2@@ , @@a3@@ ) ; }
unsigned __int64 __fastcall hash_get_max_bucket_length ( __int64 @@a1@@ ) { _QWORD * @@i@@ ; unsigned __int64 @@v3@@ ; _QWORD * @@v4@@ ; unsigned __int64 @@j@@ ; @@v3@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { @@v4@@ = @@i@@ ; for ( @@j@@ = Number L ; ; ++ @@j@@ ) { @@v4@@ = ( _QWORD * ) @@v4@@ [ Number ] ; if ( ! @@v4@@ ) break ; } if ( @@j@@ > @@v3@@ ) @@v3@@ = @@j@@ ; } } return @@v3@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 __fastcall cmp_atime ( _QWORD * @@a1@@ , _QWORD * @@a2@@ , __int64 ( __fastcall * @@a3@@ ( ) ( constchar , constchar ) ) ( _QWORD , _QWORD ) ) { __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@result@@ ; unsigned int @@v10@@ ; @@v3@@ = get_stat_atime ( ( __int64 ) ( @@a1@@ + Number ) ) ; @@v5@@ = @@v4@@ ; @@v6@@ = get_stat_atime ( ( __int64 ) ( @@a2@@ + Number ) ) ; @@v10@@ = timespec_cmp ( @@v6@@ , @@v7@@ , @@v3@@ , @@v5@@ ) ; if ( @@v10@@ ) @@result@@ = @@v10@@ ; else @@result@@ = @@a3@@ ( ) ( constchar , constchar ) ( * @@a1@@ , * @@a2@@ ) ; return @@result@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@v3@@ ; @@v3@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v3@@ ) xalloc_die ( @@a1@@ , @@a2@@ ) ; return @@v3@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
__int64 __fastcall hash_lookup ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; _QWORD * @@i@@ ; _QWORD * @@v5@@ ; @@v2@@ = * @@a1@@ ; @@v5@@ = ( _QWORD * ) ( @@v2@@ + Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) ) ; if ( ( unsigned __int64 ) @@v5@@ >= @@a1@@ [ Number ] ) abort ( ) ; if ( ! * @@v5@@ ) return Number L ; for ( @@i@@ = @@v5@@ ; @@i@@ ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { if ( @@a2@@ == * @@i@@ || ( ( unsigned __int8 ( __fastcall * ) ( __int64 , _QWORD ) ) @@a1@@ [ Number ] ) ( @@a2@@ , * @@i@@ ) ) { return * @@i@@ ; } } return Number L ; }
__int64 __fastcall xstrcoll_df_ctime ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_ctime ( @@a1@@ , @@a2@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) xstrcoll ) ; }
_BOOL8 __fastcall c_isalpha ( int @@a1@@ ) { return ( int ) ( @@a1@@ & Number ) > Number && ( int ) ( @@a1@@ & Number ) <= Number ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
__int64 __fastcall hash_do_for_each ( __int64 @@a1@@ , unsigned __int8 ( __fastcall * @@a2@@ ) ( _QWORD , __int64 ) , __int64 @@a3@@ ) { __int64 @@v5@@ ; _QWORD * @@i@@ ; _QWORD * @@j@@ ; @@v5@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = @@i@@ ; @@j@@ ; @@j@@ = ( _QWORD * ) @@j@@ [ Number ] ) { if ( @@a2@@ ( * @@j@@ , @@a3@@ ) != Number ) return @@v5@@ ; ++ @@v5@@ ; } } } return @@v5@@ ; }
_BOOL8 __fastcall c_isdigit ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
void * malloc ( size_t @@size@@ ) { return __imp_malloc ( @@size@@ ) ; }
__int64 __fastcall rev_strcmp_df_ctime ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_ctime ( @@a2@@ , @@a1@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) & strcmp ) ; }
__int64 __fastcall next_prime ( unsigned __int64 @@a1@@ ) { __int64 @@v2@@ ; __int64 @@i@@ ; @@v2@@ = @@a1@@ ; if ( @@a1@@ <= Number ) @@v2@@ = Number L ; for ( @@i@@ = @@v2@@ | Number ; @@i@@ != Number && ! is_prime ( @@i@@ ) ; @@i@@ += Number L ) { ; } return @@i@@ ; }
_BOOL8 __fastcall c_isspace ( int @@a1@@ ) { return @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number ; }
__int64 guess_shell_syntax ( ) { char * @@s1@@ ; char * @@s1a@@ ; @@s1@@ = getenv ( String ) ; if ( ! @@s1@@ || ! * @@s1@@ ) return Number L ; @@s1a@@ = ( char * ) last_component ( @@s1@@ ) ; return ! strcmp ( @@s1a@@ , String ) || ! strcmp ( @@s1a@@ , String ) ; }
__int64 __fastcall rev_xstrcoll_df_mtime ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_mtime ( @@a2@@ , @@a1@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) xstrcoll ) ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_21FE88 ; @@v8@@ [ Number ] = qword_21FE90 ; @@v8@@ [ Number ] = qword_21FE98 ; @@v8@@ [ Number ] = qword_21FEA0 ; @@v8@@ [ Number ] = qword_21FEA8 ; @@v8@@ [ Number ] = qword_21FEB0 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
__int64 __fastcall rev_xstrcoll_df_atime ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_atime ( @@a2@@ , @@a1@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) xstrcoll ) ; }
__int64 __fastcall hash_clear ( __int64 @@a1@@ ) { __int64 @@result@@ ; _QWORD * @@i@@ ; _QWORD * @@j@@ ; _QWORD * @@v4@@ ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = ( _QWORD * ) @@i@@ [ Number ] ; @@j@@ ; @@j@@ = @@v4@@ ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@j@@ ) ; * @@j@@ = Number L ; @@v4@@ = ( _QWORD * ) @@j@@ [ Number ] ; @@j@@ [ Number ] = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@j@@ ; } if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@i@@ ) ; * @@i@@ = Number L ; @@i@@ [ Number ] = Number L ; } } * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; @@result@@ = @@a1@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; return @@result@@ ; }
__int64 __fastcall c_strcasecmp ( unsigned __int8 * @@a1@@ , unsigned __int8 * @@a2@@ ) { unsigned __int8 * @@v2@@ ; unsigned __int8 * @@v3@@ ; unsigned __int8 @@v5@@ ; unsigned __int8 @@v6@@ ; @@v2@@ = @@a1@@ ; @@v3@@ = @@a2@@ ; if ( @@a1@@ == @@a2@@ ) return Number L ; do { @@v5@@ = c_tolower ( * @@v2@@ ) ; @@v6@@ = c_tolower ( * @@v3@@ ) ; if ( ! @@v5@@ ) break ; ++ @@v2@@ ; ++ @@v3@@ ; } while ( @@v5@@ == @@v6@@ ) ; return @@v5@@ - ( unsigned int ) @@v6@@ ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( ) ; return @@ptr@@ ; }
__int64 __fastcall rev_strcmp_df_size ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_size ( @@a2@@ , @@a1@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) & strcmp ) ; }
int puts ( const char * @@s@@ ) { return puts ( @@s@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
_BOOL8 __fastcall c_iscntrl ( int @@a1@@ ) { return ( @@a1@@ & Number ) == Number || @@a1@@ == Number ; }
__int64 __fastcall strcmp_df_extension ( const char * * @@a1@@ , const char * * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_extension ( @@a1@@ , @@a2@@ , ( __int64 ( __fastcall * ) ( const char * , const char * ) ) & strcmp ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
__int64 __fastcall transfer_entries ( __int64 @@a1@@ , __int64 @@a2@@ , char @@a3@@ ) { __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 * @@i@@ ; _QWORD * @@j@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; _QWORD * @@v11@@ ; _QWORD * @@v12@@ ; _QWORD * @@v13@@ ; _QWORD * @@v14@@ ; for ( @@i@@ = * ( __int64 * * ) @@a2@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a2@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = ( _QWORD * ) @@i@@ [ Number ] ; @@j@@ ; @@j@@ = @@v14@@ ) { @@v9@@ = * @@j@@ ; @@v3@@ = * ( _QWORD * ) @@a1@@ ; @@v11@@ = ( _QWORD * ) ( @@v3@@ + Number * ( * ( __int64 ( __fastcall * * ) ( _QWORD , _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@j@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@v11@@ >= * ( _QWORD * ) ( @@a1@@ + Number ) ) abort ( ) ; @@v14@@ = ( _QWORD * ) @@j@@ [ Number ] ; if ( * @@v11@@ ) { @@j@@ [ Number ] = @@v11@@ [ Number ] ; @@v11@@ [ Number ] = @@j@@ ; } else { * @@v11@@ = @@v9@@ ; ++ * ( _QWORD * ) ( @@a1@@ + Number ) ; free_entry ( @@a1@@ , @@j@@ ) ; } } @@v10@@ = * @@i@@ ; @@i@@ [ Number ] = Number L ; if ( ! @@a3@@ ) { @@v4@@ = * ( _QWORD * ) @@a1@@ ; @@v12@@ = ( _QWORD * ) ( @@v4@@ + Number * ( * ( __int64 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@v10@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@v12@@ >= * ( _QWORD * ) ( @@a1@@ + Number ) ) abort ( ) ; if ( * @@v12@@ ) { @@v13@@ = allocate_entry ( @@a1@@ ) ; if ( ! @@v13@@ ) return Number L ; * @@v13@@ = @@v10@@ ; @@v13@@ [ Number ] = @@v12@@ [ Number ] ; @@v12@@ [ Number ] = @@v13@@ ; } else { * @@v12@@ = @@v10@@ ; ++ * ( _QWORD * ) ( @@a1@@ + Number ) ; } * @@i@@ = Number L ; -- * ( _QWORD * ) ( @@a2@@ + Number ) ; } } } return Number L ; }
int fileno ( FILE * @@stream@@ ) { return fileno ( @@stream@@ ) ; }
_BOOL8 __fastcall c_isdigit ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
__int64 long_time_expected_width ( ) { time_t @@timer@@ ; struct tm * @@v2@@ ; __int64 @@v3@@ ; char @@v4@@ [ Number ] ; unsigned __int64 @@v5@@ ; @@v5@@ = __readfsqword ( Number ) ; if ( width_8232 < Number ) { @@timer@@ = Number L ; @@v2@@ = localtime ( & @@timer@@ ) ; if ( @@v2@@ ) { @@v3@@ = align_nstrftime ( ( __int64 ) @@v4@@ , Number L , long_time_format , ( __int64 ) @@v2@@ , Number , Number ) ; if ( @@v3@@ ) width_8232 = mbsnwidth ( @@v4@@ , @@v3@@ , Number L ) ; } if ( width_8232 < Number ) width_8232 = Number ; } return ( unsigned int ) width_8232 ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
__int64 __fastcall openat_safer ( int @@a1@@ , const char * @@a2@@ , char @@a3@@ , unsigned int @@a4@@ ) { unsigned int @@v4@@ ; unsigned int @@v6@@ ; @@v6@@ = Number ; if ( ( @@a3@@ & Number ) != Number ) @@v6@@ = @@a4@@ ; @@v4@@ = openat ( @@a1@@ , @@a2@@ , @@a3@@ , @@v6@@ ) ; return fd_safer ( @@v4@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
_BOOL8 __fastcall c_isspace ( int @@a1@@ ) { return @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
size_t __fastcall format_user_or_group_width ( __int64 @@a1@@ , __int64 @@a2@@ ) { size_t @@result@@ ; int @@v3@@ ; char @@s@@ [ Number ] ; unsigned __int64 @@v5@@ ; @@v5@@ = __readfsqword ( Number ) ; if ( @@a1@@ ) { @@v3@@ = gnu_mbswidth ( @@a1@@ , Number L ) ; @@result@@ = Number L ; if ( @@v3@@ >= Number ) @@result@@ = ( unsigned int ) @@v3@@ ; } else { sprintf ( @@s@@ , String , @@a2@@ ) ; @@result@@ = strlen ( @@s@@ ) ; } return @@result@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
void * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
__int64 __fastcall get_type_indicator ( char @@a1@@ , __int16 @@a2@@ , int @@a3@@ ) { bool @@v3@@ ; bool @@v4@@ ; bool @@v5@@ ; bool @@v6@@ ; bool @@v7@@ ; bool @@v8@@ ; unsigned __int8 @@v10@@ ; if ( @@a1@@ ) @@v3@@ = ( @@a2@@ & Number ) == Number ; else @@v3@@ = @@a3@@ == Number ; if ( @@v3@@ ) { if ( @@a1@@ && indicator_style == Number && ( @@a2@@ & Number ) != Number ) @@v10@@ = Number ; else @@v10@@ = Number ; } else { if ( @@a1@@ ) { @@v4@@ = ( @@a2@@ & Number ) == Number ; } else { @@v5@@ = @@a3@@ == Number || @@a3@@ == Number ; @@v4@@ = @@v5@@ ; } if ( @@v4@@ ) { @@v10@@ = Number ; } else if ( indicator_style == Number ) { @@v10@@ = Number ; } else { if ( @@a1@@ ) @@v6@@ = ( @@a2@@ & Number ) == Number ; else @@v6@@ = @@a3@@ == Number ; if ( @@v6@@ ) { @@v10@@ = Number ; } else { if ( @@a1@@ ) @@v7@@ = ( @@a2@@ & Number ) == Number ; else @@v7@@ = @@a3@@ == Number ; if ( @@v7@@ ) { @@v10@@ = Number ; } else { if ( @@a1@@ ) @@v8@@ = ( @@a2@@ & Number ) == Number ; else @@v8@@ = @@a3@@ == Number ; if ( @@v8@@ ) @@v10@@ = Number ; else @@v10@@ = Number ; } } } } return @@v10@@ ; }
unsigned __int64 __fastcall print_long_long ( unsigned __int64 @@a1@@ , unsigned __int64 @@a2@@ , _QWORD * @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { _QWORD * @@v6@@ ; unsigned __int64 @@result@@ ; char @@v8@@ ; int @@v9@@ ; int @@v12@@ ; int @@v13@@ ; unsigned __int64 @@i@@ ; @@v9@@ = @@a6@@ ; @@v12@@ = @@a6@@ ; for ( @@i@@ = @@a1@@ ; ; -- @@i@@ ) { @@result@@ = @@a2@@ ; if ( @@a2@@ >= @@i@@ ) break ; @@v13@@ = ( @@i@@ - Number ) * @@v9@@ / @@a1@@ ; @@v6@@ = @@a3@@ ++ ; xprintf ( @@a4@@ , @@a5@@ + @@v12@@ - @@v13@@ , * @@v6@@ , @@a5@@ + @@v12@@ - @@v13@@ , @@a5@@ , @@a6@@ , @@v8@@ ) ; @@v12@@ = @@v13@@ ; } return @@result@@ ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
void * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
struct group * getgrgid ( __gid_t @@gid@@ ) { return getgrgid ( @@gid@@ ) ; }
int print_with_commas ( ) { char @@v1@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; @@v3@@ = Number L ; for ( @@i@@ = Number L ; @@i@@ < cwd_n_used ; ++ @@i@@ ) { @@v4@@ = * ( ( _QWORD * ) sorted_file + @@i@@ ) ; @@v5@@ = length_of_file_name_and_frills ( @@v4@@ ) ; if ( @@i@@ ) { if ( @@v3@@ + @@v5@@ + Number >= line_length ) { @@v3@@ = Number L ; @@v1@@ = Number ; } else { @@v3@@ += Number L ; @@v1@@ = Number ; } putchar_unlocked ( Number ) ; putchar_unlocked ( @@v1@@ ) ; } print_file_name_and_frills ( @@v4@@ , @@v3@@ ) ; @@v3@@ += @@v5@@ ; } return putchar_unlocked ( Number ) ; }
void * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
int dirfd ( DIR * @@dirp@@ ) { return dirfd ( @@dirp@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
void * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
unsigned __int64 __fastcall print_named_ascii ( unsigned __int64 @@a1@@ , unsigned __int64 @@a2@@ , _BYTE * @@a3@@ , __int64 a4 , int @@a5@@ , int @@a6@@ ) { _BYTE * @@v6@@ ; int @@v8@@ ; int @@v10@@ ; int @@v11@@ ; unsigned __int64 @@i@@ ; char @@v14@@ [ Number ] ; unsigned __int64 @@v15@@ ; @@v8@@ = @@a6@@ ; @@v15@@ = __readfsqword ( Number ) ; @@v10@@ = @@a6@@ ; for ( @@i@@ = @@a1@@ ; @@a2@@ < @@i@@ ; -- @@i@@ ) { @@v11@@ = ( @@i@@ - Number ) * @@v8@@ / @@a1@@ ; @@v6@@ = @@a3@@ ++ ; if ( ( * @@v6@@ & Number ) == Number ) { xprintf ( ( unsigned int ) String , @@v10@@ - @@v11@@ + @@a5@@ , ( unsigned int ) String , @@v10@@ - @@v11@@ + @@a5@@ , @@a5@@ , @@a6@@ ) ; } else if ( ( * @@v6@@ & Number ) > Number ) { @@v14@@ [ Number ] = * @@v6@@ & Number ; @@v14@@ [ Number ] = Number ; xprintf ( ( unsigned int ) String , @@v10@@ - @@v11@@ + @@a5@@ , ( unsigned int ) @@v14@@ , @@v10@@ - @@v11@@ + @@a5@@ , @@a5@@ , @@a6@@ ) ; } else { xprintf ( ( unsigned int ) String , @@v10@@ - @@v11@@ + @@a5@@ , ( unsigned int ) & charname + Number * ( * @@v6@@ & Number ) , @@v10@@ - @@v11@@ + @@a5@@ , @@a5@@ , @@a6@@ ) ; } @@v10@@ = ( @@i@@ - Number ) * @@v8@@ / @@a1@@ ; } return __readfsqword ( Number ) ^ @@v15@@ ; }
unsigned __int64 __fastcall calculate_columns ( char @@a1@@ ) { __int64 @@v1@@ ; unsigned __int64 @@v2@@ ; __int64 @@v3@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@k@@ ; unsigned __int64 @@j@@ ; unsigned __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; @@v1@@ = max_idx ; if ( cwd_n_used <= ( unsigned __int64 ) max_idx ) @@v1@@ = cwd_n_used ; @@v8@@ = @@v1@@ ; init_column_info ( ) ; for ( @@i@@ = Number L ; @@i@@ < cwd_n_used ; ++ @@i@@ ) { @@v9@@ = length_of_file_name_and_frills ( * ( ( _QWORD * ) sorted_file + @@i@@ ) ) ; for ( @@j@@ = Number L ; @@j@@ < @@v8@@ ; ++ @@j@@ ) { if ( * ( _BYTE * ) ( column_info + Number * @@j@@ ) ) { @@v2@@ = @@a1@@ ? @@i@@ / ( ( cwd_n_used + @@j@@ ) / ( @@j@@ + Number ) ) : @@i@@ % ( @@j@@ + Number ) ; @@v3@@ = @@v2@@ == @@j@@ ? Number L : Number L ; @@v10@@ = @@v3@@ + @@v9@@ ; if ( ( unsigned __int64 ) ( @@v3@@ + @@v9@@ ) > * ( _QWORD * ) ( Number * @@v2@@ + * ( _QWORD * ) ( column_info + Number * @@j@@ + Number ) ) ) { * ( _QWORD * ) ( column_info + Number * @@j@@ + Number ) += @@v10@@ - * ( _QWORD * ) ( Number * @@v2@@ + * ( _QWORD * ) ( column_info + Number * @@j@@ + Number ) ) ; * ( _QWORD * ) ( * ( _QWORD * ) ( column_info + Number * @@j@@ + Number ) + Number * @@v2@@ ) = @@v10@@ ; * ( _BYTE * ) ( column_info + Number * @@j@@ ) = * ( _QWORD * ) ( column_info + Number * @@j@@ + Number ) < ( unsigned __int64 ) line_length ; } } } } for ( @@k@@ = @@v8@@ ; @@k@@ > Number && ! * ( _BYTE * ) ( column_info + Number * @@k@@ - Number ) ; -- @@k@@ ) { ; } return @@k@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
char * __fastcall parse_user_spec ( char * @@a1@@ , int * @@a2@@ , __gid_t * @@a3@@ , char * * @@a4@@ , void * * @@a5@@ ) { char * @@v9@@ ; char * @@v10@@ ; char * @@v11@@ ; @@v10@@ = strchr ( @@a1@@ , Number ) ; @@v9@@ = parse_with_separator ( @@a1@@ , @@v10@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; if ( ! @@v10@@ ) { if ( @@v9@@ ) { @@v11@@ = strchr ( @@a1@@ , Number ) ; if ( @@v11@@ ) { if ( ! parse_with_separator ( @@a1@@ , @@v11@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ) @@v9@@ = Number L ; } } } return @@v9@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__int64 __fastcall skip ( unsigned __int64 @@a1@@ ) { int @@v2@@ ; const char * @@v3@@ ; int * @@v4@@ ; char * @@v5@@ ; unsigned __int64 @@v6@@ ; bool @@v7@@ ; bool @@v8@@ ; int @@v9@@ ; size_t @@n@@ ; size_t @@v11@@ ; struct stat @@stat_buf@@ ; char @@ptr@@ [ Number ] ; unsigned __int64 @@v14@@ ; @@v6@@ = @@a1@@ ; @@v14@@ = __readfsqword ( Number ) ; @@v7@@ = Number ; @@v9@@ = Number ; if ( ! @@a1@@ ) return Number L ; while ( in_stream ) { @@v2@@ = fileno ( in_stream ) ; if ( ( unsigned int ) fstat ( @@v2@@ , & @@stat_buf@@ ) ) { @@v3@@ = input_filename ; @@v4@@ = __errno_location ( ) ; error ( Number , * @@v4@@ , String , @@v3@@ ) ; @@v7@@ = Number ; } else { if ( ( @@stat_buf@@ . st_mode & Number ) == Number && @@stat_buf@@ . st_size > Number ) { if ( @@v6@@ <= @@stat_buf@@ . st_size ) { if ( ( unsigned int ) rpl_fseeko ( in_stream , @@v6@@ , Number L ) ) { @@v9@@ = * __errno_location ( ) ; @@v7@@ = Number ; } @@v6@@ = Number L ; } else { @@v6@@ -= @@stat_buf@@ . st_size ; } } else { @@n@@ = Number ; while ( @@v6@@ ) { if ( @@v6@@ < @@n@@ ) @@n@@ = @@v6@@ ; @@v11@@ = fread_unlocked ( @@ptr@@ , Number , @@n@@ , in_stream ) ; @@v6@@ -= @@v11@@ ; if ( @@v11@@ != @@n@@ ) { @@v9@@ = * __errno_location ( ) ; @@v7@@ = Number ; @@v6@@ = Number L ; break ; } } } if ( ! @@v6@@ ) break ; } @@v8@@ = ( @@v7@@ & ( unsigned __int8 ) check_and_close ( @@v9@@ ) ) != Number ; @@v7@@ = ( @@v8@@ & ( unsigned __int8 ) open_next_file ( ) ) != Number ; } if ( @@v6@@ ) { @@v5@@ = gettext ( String ) ; error ( Number , Number , @@v5@@ ) ; } return @@v7@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 __fastcall wc_truncate ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { int @@v4@@ ; __int64 @@v5@@ ; @@v5@@ = Number L ; while ( * @@a1@@ ) { @@v4@@ = wcwidth ( * @@a1@@ ) ; if ( @@v4@@ == Number ) { * @@a1@@ = Number ; @@v4@@ = Number ; } if ( @@a2@@ < @@v4@@ + @@v5@@ ) break ; @@v5@@ += @@v4@@ ; ++ @@a1@@ ; } * @@a1@@ = Number ; return @@v5@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ ) { return xmalloc ( @@a1@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v3@@ ; @@v3@@ = malloc ( @@a1@@ ) ; if ( ! @@v3@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ ) ; return @@v3@@ ; }
__int64 __fastcall gnu_mbswidth ( const char * @@a1@@ , unsigned int @@a2@@ ) { size_t @@v2@@ ; @@v2@@ = strlen ( @@a1@@ ) ; return mbsnwidth ( @@a1@@ , @@v2@@ , @@a2@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
_BOOL8 __fastcall c_isascii ( int @@a1@@ ) { return @@a1@@ >= Number && @@a1@@ <= Number ; }
__int64 __fastcall xfts_open ( const char * * @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { unsigned int @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; __int64 @@v7@@ ; @@v3@@ = @@a2@@ ; BYTE1 ( @@v3@@ ) = BYTE1 ( @@a2@@ ) | Number ; @@v4@@ = @@v3@@ ; @@v7@@ = fts_open ( @@a1@@ , @@v3@@ , @@a3@@ ) ; if ( ! @@v7@@ ) { if ( * __errno_location ( ) == Number ) __assert_fail ( String , String , Number , String ) ; xalloc_die ( @@a1@@ , @@v4@@ , @@v5@@ ) ; } return @@v7@@ ; }
int __fastcall argmatch_valid ( __int64 @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { char * @@v3@@ ; __int64 @@i@@ ; void * @@s1@@ ; @@s1@@ = Number L ; @@v3@@ = gettext ( String ) ; fprintf ( stderr , @@v3@@ ) ; for ( @@i@@ = Number L ; * ( _QWORD * ) ( Number * @@i@@ + @@a1@@ ) ; ++ @@i@@ ) { if ( @@i@@ && ! memcmp ( @@s1@@ , ( const void * ) ( @@i@@ * @@a3@@ + @@a2@@ ) , @@a3@@ ) ) { fprintf ( stderr , String , * ( const char * * ) ( Number * @@i@@ + @@a1@@ ) ) ; } else { fprintf ( stderr , String , * ( const char * * ) ( Number * @@i@@ + @@a1@@ ) ) ; @@s1@@ = ( void * ) ( @@i@@ * @@a3@@ + @@a2@@ ) ; } } return putc_unlocked ( Number , stderr ) ; }
__int64 dump ( ) { size_t @@v0@@ ; bool @@v2@@ ; unsigned __int8 @@v3@@ ; int @@v4@@ ; unsigned __int64 @@v5@@ ; unsigned __int64 @@v6@@ ; size_t @@v7@@ ; unsigned __int64 @@v8@@ ; void * @@ptr@@ [ Number ] ; @@ptr@@ [ Number ] = ( void * ) __readfsqword ( Number ) ; @@v2@@ = Number ; @@v3@@ = Number ; @@ptr@@ [ Number ] = ( void * ) xnmalloc ( Number L , bytes_per_block ) ; @@ptr@@ [ Number ] = ( char * ) @@ptr@@ [ Number ] + bytes_per_block ; @@v6@@ = n_bytes_to_skip ; if ( limit_bytes_to_format ) { while ( @@v6@@ < end_offset ) { @@v0@@ = bytes_per_block ; if ( end_offset - @@v6@@ <= bytes_per_block ) @@v0@@ = end_offset - @@v6@@ ; @@v7@@ = @@v0@@ ; @@v3@@ &= read_block ( @@v0@@ , ( __int64 ) @@ptr@@ [ @@v2@@ ] , & @@v5@@ ) ; if ( @@v5@@ < bytes_per_block ) goto LABEL_14 ; if ( @@v5@@ != bytes_per_block ) __assert_fail ( String , String , Number , String ) ; write_block ( @@v6@@ , @@v5@@ , @@ptr@@ [ ! @@v2@@ ] , ( unsigned __int8 * ) @@ptr@@ [ @@v2@@ ] ) ; @@v6@@ += @@v5@@ ; @@v2@@ = ! @@v2@@ ; } @@v5@@ = Number L ; } else { while ( Number ) { @@v3@@ &= read_block ( bytes_per_block , ( __int64 ) @@ptr@@ [ @@v2@@ ] , & @@v5@@ ) ; if ( @@v5@@ < bytes_per_block ) break ; if ( @@v5@@ != bytes_per_block ) __assert_fail ( String , String , Number , String ) ; write_block ( @@v6@@ , @@v5@@ , @@ptr@@ [ ! @@v2@@ ] , ( unsigned __int8 * ) @@ptr@@ [ @@v2@@ ] ) ; @@v6@@ += @@v5@@ ; @@v2@@ = ! @@v2@@ ; } } LABEL_14 : if ( @@v5@@ ) { @@v4@@ = get_lcm ( ) ; @@v8@@ = @@v4@@ * ( ( @@v4@@ + @@v5@@ - Number ) / @@v4@@ ) ; memset ( ( char * ) @@ptr@@ [ @@v2@@ ] + @@v5@@ , Number , @@v8@@ - @@v5@@ ) ; write_block ( @@v6@@ , @@v5@@ , @@ptr@@ [ ! @@v2@@ ] , ( unsigned __int8 * ) @@ptr@@ [ @@v2@@ ] ) ; @@v6@@ += @@v5@@ ; } format_address ( @@v6@@ , Number L ) ; if ( limit_bytes_to_format && @@v6@@ >= end_offset ) @@v3@@ = ( unsigned __int8 ) ( @@v3@@ & check_and_close ( Number ) ) != Number ; free ( @@ptr@@ [ Number ] ) ; return @@v3@@ ; }
_BOOL8 __fastcall c_iscntrl ( int @@a1@@ ) { return ( @@a1@@ & Number ) == Number || @@a1@@ == Number ; }
__int64 __fastcall cycle_check ( __int64 @@a1@@ , _QWORD * @@a2@@ ) { if ( * ( _DWORD * ) ( @@a1@@ + Number ) != Number ) __assert_fail ( String , String , Number , String ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) && @@a2@@ [ Number ] == * ( _QWORD * ) @@a1@@ && * @@a2@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ) { return Number L ; } if ( is_zero_or_power_of_two ( ++ * ( _QWORD * ) ( @@a1@@ + Number ) ) ) { if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = * @@a2@@ ; * ( _QWORD * ) @@a1@@ = @@a2@@ [ Number ] ; } return Number L ; }
__int64 __fastcall restricted_chown ( int @@a1@@ , const char * @@a2@@ , __int64 @@a3@@ , __uid_t @@a4@@ , __gid_t @@a5@@ , int @@a6@@ , int @@a7@@ ) { __int64 @@result@@ ; unsigned int @@v12@@ ; int @@oflag@@ ; int @@fildes@@ ; int @@v15@@ ; struct stat @@v16@@ ; unsigned __int64 @@v17@@ ; @@v17@@ = __readfsqword ( Number ) ; @@v12@@ = Number ; @@oflag@@ = Number ; if ( @@a6@@ == Number && @@a7@@ == Number ) return Number L ; if ( ( * ( _DWORD * ) ( @@a3@@ + Number ) & Number ) != Number ) { if ( ( * ( _DWORD * ) ( @@a3@@ + Number ) & Number ) != Number ) return Number L ; @@oflag@@ = Number ; } @@fildes@@ = openat ( @@a1@@ , @@a2@@ , @@oflag@@ ) ; if ( @@fildes@@ < Number ) { if ( * __errno_location ( ) != Number || ( * ( _DWORD * ) ( @@a3@@ + Number ) & Number ) != Number || ( @@fildes@@ = openat ( @@a1@@ , @@a2@@ , @@oflag@@ | Number ) , @@fildes@@ < Number ) ) { if ( * __errno_location ( ) == Number ) @@result@@ = Number L ; else @@result@@ = Number L ; return @@result@@ ; } } if ( ( unsigned int ) fstat ( @@fildes@@ , & @@v16@@ ) ) { @@v12@@ = Number ; LABEL_30 : @@v15@@ = * __errno_location ( ) ; close ( @@fildes@@ ) ; * __errno_location ( ) = @@v15@@ ; return @@v12@@ ; } if ( * ( _QWORD * ) ( @@a3@@ + Number ) != @@v16@@ . st_ino || * ( _QWORD * ) @@a3@@ != @@v16@@ . st_dev ) { @@v12@@ = Number ; goto LABEL_30 ; } if ( @@a6@@ != Number && @@a6@@ != @@v16@@ . st_uid || @@a7@@ != Number && @@a7@@ != @@v16@@ . st_gid ) { goto LABEL_30 ; } if ( fchown ( @@fildes@@ , @@a4@@ , @@a5@@ ) ) { @@v12@@ = Number ; goto LABEL_30 ; } if ( close ( @@fildes@@ ) ) LODWORD ( @@result@@ ) = Number ; else LODWORD ( @@result@@ ) = Number ; return ( unsigned int ) @@result@@ ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
int __fastcall fstat ( int @@fildes@@ , struct stat * @@stat_buf@@ ) { return __fxstat ( Number , @@fildes@@ , @@stat_buf@@ ) ; }
_BYTE * __fastcall filemodestring ( __int64 @@a1@@ , _BYTE * @@a2@@ ) { return strmode ( * ( _DWORD * ) ( @@a1@@ + Number ) , @@a2@@ ) ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , off_CD42 , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
_BOOL8 __fastcall c_ispunct ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number && ( @@a1@@ <= Number || @@a1@@ > Number ) && ( ( int ) ( @@a1@@ & Number ) <= Number || ( int ) ( @@a1@@ & Number ) > Number ) ; }
__int64 __fastcall hash_get_n_buckets ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 __fastcall c_toupper ( int @@a1@@ ) { __int64 @@result@@ ; if ( @@a1@@ <= Number || @@a1@@ > Number ) @@result@@ = ( unsigned int ) @@a1@@ ; else @@result@@ = ( unsigned int ) ( @@a1@@ - Number ) ; return @@result@@ ; }
unsigned __int64 __fastcall hash_get_max_bucket_length ( __int64 @@a1@@ ) { _QWORD * @@i@@ ; unsigned __int64 @@v3@@ ; _QWORD * @@v4@@ ; unsigned __int64 @@j@@ ; @@v3@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { @@v4@@ = @@i@@ ; for ( @@j@@ = Number L ; ; ++ @@j@@ ) { @@v4@@ = ( _QWORD * ) @@v4@@ [ Number ] ; if ( ! @@v4@@ ) break ; } if ( @@j@@ > @@v3@@ ) @@v3@@ = @@j@@ ; } } return @@v3@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
unsigned __int64 __fastcall leave_dir ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 * @@v3@@ ; __int64 * @@v4@@ ; void * @@ptr@@ ; __int64 @@v6@@ [ Number ] ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v3@@ = ( __int64 * ) ( @@a2@@ + Number ) ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { @@v6@@ [ Number ] = * @@v3@@ ; @@v6@@ [ Number ] = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@ptr@@ = ( void * ) hash_delete ( * ( _QWORD * ) ( @@a1@@ + Number ) , @@v6@@ ) ; if ( ! @@ptr@@ ) abort ( ) ; free ( @@ptr@@ ) ; } else { @@v4@@ = * ( __int64 * * ) ( @@a2@@ + Number ) ; if ( @@v4@@ && @@v4@@ [ Number ] >= Number ) { if ( ! * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L ) ) abort ( ) ; if ( * * ( _QWORD * * ) ( @@a1@@ + Number ) == * ( _QWORD * ) ( @@a2@@ + Number ) && * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L ) == * @@v3@@ ) { * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L ) = @@v4@@ [ Number ] ; * * ( _QWORD * * ) ( @@a1@@ + Number ) = @@v4@@ [ Number ] ; } } } return __readfsqword ( Number ) ^ @@v7@@ ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall hash_get_next ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; _QWORD * @@v4@@ ; _QWORD * @@i@@ ; @@v2@@ = * @@a1@@ ; @@v4@@ = ( _QWORD * ) ( @@v2@@ + Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) ) ; if ( ( unsigned __int64 ) @@v4@@ >= @@a1@@ [ Number ] ) abort ( ) ; for ( @@i@@ = @@v4@@ ; @@i@@ ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { if ( @@a2@@ == * @@i@@ && @@i@@ [ Number ] ) return * ( _QWORD * ) @@i@@ [ Number ] ; } while ( Number ) { @@v4@@ += Number ; if ( ( unsigned __int64 ) @@v4@@ >= @@a1@@ [ Number ] ) break ; if ( * @@v4@@ ) return * @@v4@@ ; } return Number L ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 __fastcall fts_compare_ino ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; if ( * ( _QWORD * ) ( * ( _QWORD * ) @@a1@@ + Number L ) < * ( _QWORD * ) ( * ( _QWORD * ) @@a2@@ + Number L ) ) @@result@@ = Number ; else @@result@@ = * ( _QWORD * ) ( * ( _QWORD * ) @@a2@@ + Number L ) < * ( _QWORD * ) ( * ( _QWORD * ) @@a1@@ + Number L ) ; return @@result@@ ; }
int __cdecl __noreturn main ( int @@argc@@ , const char * * @@argv@@ , const char * * @@envp@@ ) { char * @@v3@@ ; set_program_name ( * @@argv@@ , @@argv@@ , @@envp@@ ) ; setlocale ( Number , & shortopts ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; parse_long_options ( @@argc@@ , ( _DWORD ) @@argv@@ , ( unsigned int ) String , ( unsigned int ) String , ( _DWORD ) Version , ( unsigned int ) usage , String , Number L ) ; if ( getopt_long ( @@argc@@ , ( char * const * ) @@argv@@ , & shortopts , Number L , Number L ) != Number ) usage ( Number ) ; if ( @@argc@@ > optind ) { @@v3@@ = gettext ( String ) ; error ( Number , Number , @@v3@@ ) ; } sync ( ) ; exit ( Number ) ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
bool __fastcall is_prime ( unsigned __int64 @@a1@@ ) { unsigned __int64 @@v2@@ ; unsigned __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; @@v2@@ = Number L ; @@v4@@ = Number L ; while ( @@v4@@ < @@a1@@ && @@a1@@ % @@v2@@ ) { @@v3@@ = @@v2@@ + Number ; @@v4@@ += Number * @@v3@@ ; @@v2@@ = @@v3@@ + Number ; } return @@a1@@ % @@v2@@ != Number ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
__int64 __fastcall fts_padjust ( __int64 @@a1@@ , _QWORD * @@a2@@ ) { _QWORD * @@v2@@ ; __int64 @@result@@ ; _QWORD * @@i@@ ; __int64 @@v6@@ ; @@v6@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; for ( @@i@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; @@i@@ ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { if ( ( _QWORD * ) @@i@@ [ Number ] != @@i@@ + Number ) @@i@@ [ Number ] = @@v6@@ + @@i@@ [ Number ] - @@i@@ [ Number ] ; @@i@@ [ Number ] = @@v6@@ ; } while ( Number ) { @@result@@ = @@a2@@ [ Number ] ; if ( @@result@@ < Number ) break ; if ( ( _QWORD * ) @@a2@@ [ Number ] != @@a2@@ + Number ) @@a2@@ [ Number ] = @@v6@@ + @@a2@@ [ Number ] - @@a2@@ [ Number ] ; @@a2@@ [ Number ] = @@v6@@ ; if ( @@a2@@ [ Number ] ) @@v2@@ = ( _QWORD * ) @@a2@@ [ Number ] ; else @@v2@@ = ( _QWORD * ) @@a2@@ [ Number ] ; @@a2@@ = @@v2@@ ; } return @@result@@ ; }
int __fxstat ( int @@ver@@ , int @@fildes@@ , struct stat * @@stat_buf@@ ) { return _fxstat ( @@ver@@ , @@fildes@@ , @@stat_buf@@ ) ; }
void * __fastcall allocate_entry ( __int64 @@a1@@ ) { __int64 @@v2@@ ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return malloc ( Number ) ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = * ( _QWORD * ) ( @@v2@@ + Number ) ; return ( void * ) @@v2@@ ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
_BOOL8 __fastcall hash_table_ok ( __int64 @@a1@@ ) { _QWORD * @@i@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; _QWORD * @@v5@@ ; @@v3@@ = Number L ; @@v4@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { @@v5@@ = @@i@@ ; ++ @@v3@@ ; ++ @@v4@@ ; while ( Number ) { @@v5@@ = ( _QWORD * ) @@v5@@ [ Number ] ; if ( ! @@v5@@ ) break ; ++ @@v4@@ ; } } } return @@v3@@ == * ( _QWORD * ) ( @@a1@@ + Number ) && @@v4@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int64 __fastcall xsum4 ( unsigned __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ ) { __int64 @@v4@@ ; __int64 @@v5@@ ; @@v4@@ = xsum ( @@a1@@ , @@a2@@ ) ; @@v5@@ = xsum ( @@v4@@ , @@a3@@ ) ; return xsum ( @@v5@@ , @@a4@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
unsigned __int64 __fastcall print_s_short ( unsigned __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int16 * @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { __int16 * @@v6@@ ; unsigned __int64 @@result@@ ; char @@v8@@ ; int @@v9@@ ; int @@v12@@ ; int @@v13@@ ; unsigned __int64 @@i@@ ; @@v9@@ = @@a6@@ ; @@v12@@ = @@a6@@ ; for ( @@i@@ = @@a1@@ ; ; -- @@i@@ ) { @@result@@ = @@a2@@ ; if ( @@a2@@ >= @@i@@ ) break ; @@v13@@ = ( @@i@@ - Number ) * @@v9@@ / @@a1@@ ; @@v6@@ = @@a3@@ ++ ; xprintf ( @@a4@@ , @@a5@@ + @@v12@@ - @@v13@@ , * @@v6@@ , @@a5@@ + @@v12@@ - @@v13@@ , @@a5@@ , @@a6@@ , @@v8@@ ) ; @@v12@@ = @@v13@@ ; } return @@result@@ ; }
__int64 __fastcall transfer_entries ( __int64 @@a1@@ , __int64 @@a2@@ , char @@a3@@ ) { __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 * @@i@@ ; _QWORD * @@j@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; _QWORD * @@v11@@ ; _QWORD * @@v12@@ ; _QWORD * @@v13@@ ; _QWORD * @@v14@@ ; for ( @@i@@ = * ( __int64 * * ) @@a2@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a2@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = ( _QWORD * ) @@i@@ [ Number ] ; @@j@@ ; @@j@@ = @@v14@@ ) { @@v9@@ = * @@j@@ ; @@v3@@ = * ( _QWORD * ) @@a1@@ ; @@v11@@ = ( _QWORD * ) ( @@v3@@ + Number * ( * ( __int64 ( __fastcall * * ) ( _QWORD , _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@j@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@v11@@ >= * ( _QWORD * ) ( @@a1@@ + Number ) ) abort ( ) ; @@v14@@ = ( _QWORD * ) @@j@@ [ Number ] ; if ( * @@v11@@ ) { @@j@@ [ Number ] = @@v11@@ [ Number ] ; @@v11@@ [ Number ] = @@j@@ ; } else { * @@v11@@ = @@v9@@ ; ++ * ( _QWORD * ) ( @@a1@@ + Number ) ; free_entry ( @@a1@@ , @@j@@ ) ; } } @@v10@@ = * @@i@@ ; @@i@@ [ Number ] = Number L ; if ( ! @@a3@@ ) { @@v4@@ = * ( _QWORD * ) @@a1@@ ; @@v12@@ = ( _QWORD * ) ( @@v4@@ + Number * ( * ( __int64 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@v10@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@v12@@ >= * ( _QWORD * ) ( @@a1@@ + Number ) ) abort ( ) ; if ( * @@v12@@ ) { @@v13@@ = allocate_entry ( @@a1@@ ) ; if ( ! @@v13@@ ) return Number L ; * @@v13@@ = @@v10@@ ; @@v13@@ [ Number ] = @@v12@@ [ Number ] ; @@v12@@ [ Number ] = @@v13@@ ; } else { * @@v12@@ = @@v10@@ ; ++ * ( _QWORD * ) ( @@a1@@ + Number ) ; } * @@i@@ = Number L ; -- * ( _QWORD * ) ( @@a2@@ + Number ) ; } } } return Number L ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 __fastcall xsum_0 ( unsigned __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; if ( @@a1@@ + @@a2@@ < @@a1@@ ) @@result@@ = Number ; else @@result@@ = @@a1@@ + @@a2@@ ; return @@result@@ ; }
__int64 __fastcall hash_get_next ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; _QWORD * @@v4@@ ; _QWORD * @@i@@ ; @@v2@@ = * @@a1@@ ; @@v4@@ = ( _QWORD * ) ( @@v2@@ + Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) ) ; if ( ( unsigned __int64 ) @@v4@@ >= @@a1@@ [ Number ] ) abort ( ) ; for ( @@i@@ = @@v4@@ ; @@i@@ ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { if ( @@a2@@ == * @@i@@ && @@i@@ [ Number ] ) return * ( _QWORD * ) @@i@@ [ Number ] ; } while ( Number ) { @@v4@@ += Number ; if ( ( unsigned __int64 ) @@v4@@ >= @@a1@@ [ Number ] ) break ; if ( * @@v4@@ ) return * @@v4@@ ; } return Number L ; }
unsigned __int64 __fastcall print_short ( unsigned __int64 @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int16 * @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { unsigned __int16 * @@v6@@ ; unsigned __int64 @@result@@ ; char @@v8@@ ; int @@v9@@ ; int @@v12@@ ; int @@v13@@ ; unsigned __int64 @@i@@ ; @@v9@@ = @@a6@@ ; @@v12@@ = @@a6@@ ; for ( @@i@@ = @@a1@@ ; ; -- @@i@@ ) { @@result@@ = @@a2@@ ; if ( @@a2@@ >= @@i@@ ) break ; @@v13@@ = ( @@i@@ - Number ) * @@v9@@ / @@a1@@ ; @@v6@@ = @@a3@@ ++ ; xprintf ( @@a4@@ , @@a5@@ + @@v12@@ - @@v13@@ , * @@v6@@ , @@a5@@ + @@v12@@ - @@v13@@ , @@a5@@ , @@a6@@ , @@v8@@ ) ; @@v12@@ = @@v13@@ ; } return @@result@@ ; }
__int64 __fastcall human_options ( char * @@a1@@ , int * @@a2@@ , _QWORD * @@a3@@ ) { unsigned int @@v5@@ ; @@v5@@ = humblock ( @@a1@@ , @@a3@@ , @@a2@@ ) ; if ( ! * @@a3@@ ) { * @@a3@@ = default_block_size ( ) ; @@v5@@ = Number ; } return @@v5@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
unsigned __int64 __fastcall print_double ( unsigned __int64 @@a1@@ , unsigned __int64 @@a2@@ , _QWORD * @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { _QWORD * @@v6@@ ; unsigned __int64 @@result@@ ; int @@v8@@ ; int @@v11@@ ; int @@v12@@ ; unsigned __int64 @@i@@ ; @@v8@@ = @@a6@@ ; @@v11@@ = @@a6@@ ; for ( @@i@@ = @@a1@@ ; ; -- @@i@@ ) { @@result@@ = @@a2@@ ; if ( @@a2@@ >= @@i@@ ) break ; @@v12@@ = ( @@i@@ - Number ) * @@v8@@ / @@a1@@ ; @@v6@@ = @@a3@@ ++ ; xprintf ( @@a4@@ , @@a5@@ + @@v11@@ - @@v12@@ , * @@v6@@ , @@a5@@ + @@v11@@ - @@v12@@ , @@a5@@ , @@a6@@ , * @@v6@@ ) ; @@v11@@ = @@v12@@ ; } return @@result@@ ; }
__int64 __fastcall check_tuning ( __int64 @@a1@@ ) { __int64 @@v2@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( ( _UNKNOWN * ) @@v2@@ == & default_tuning ) return Number L ; if ( * ( float * ) ( @@v2@@ + Number ) > Number && ( float ) ( Number - Number ) > * ( float * ) ( @@v2@@ + Number ) && * ( float * ) ( @@v2@@ + Number ) > ( float ) ( Number + Number ) && * ( float * ) @@v2@@ >= Number && * ( float * ) ( @@v2@@ + Number ) > ( float ) ( * ( float * ) @@v2@@ + Number ) && * ( float * ) ( @@v2@@ + Number ) <= Number && * ( float * ) ( @@v2@@ + Number ) > ( float ) ( * ( float * ) @@v2@@ + Number ) ) { return Number L ; } * ( _QWORD * ) ( @@a1@@ + Number ) = & default_tuning ; return Number L ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_206028 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
__int64 __fastcall imaxtostr ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = @@a1@@ ; @@v4@@ = @@a2@@ + Number ; * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; if ( @@a1@@ >= Number ) { do { * ( _BYTE * ) -- @@v4@@ = ( char ) @@v3@@ % Number + Number ; @@v3@@ /= Number L ; } while ( @@v3@@ ) ; } else { do { * ( _BYTE * ) -- @@v4@@ = Number - ( char ) @@v3@@ % Number ; @@v3@@ /= Number L ; } while ( @@v3@@ ) ; * ( _BYTE * ) -- @@v4@@ = Number ; } return @@v4@@ ; }
void * __fastcall allocate_entry ( __int64 @@a1@@ ) { __int64 @@v2@@ ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return malloc ( Number ) ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = * ( _QWORD * ) ( @@v2@@ + Number ) ; return ( void * ) @@v2@@ ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
unsigned __int64 __fastcall print_ascii ( unsigned __int64 @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 * @@a3@@ , __int64 a4 , int @@a5@@ , int @@a6@@ ) { unsigned __int8 * @@v6@@ ; int @@v7@@ ; int @@v8@@ ; int @@v10@@ ; unsigned __int8 @@v12@@ ; int @@v13@@ ; int @@v14@@ ; unsigned __int64 @@i@@ ; char @@s@@ [ Number ] ; unsigned __int64 @@v18@@ ; @@v10@@ = @@a6@@ ; @@v18@@ = __readfsqword ( Number ) ; @@v13@@ = @@a6@@ ; for ( @@i@@ = @@a1@@ ; @@a2@@ < @@i@@ ; -- @@i@@ ) { @@v14@@ = ( @@i@@ - Number ) * @@v10@@ / @@a1@@ ; @@v6@@ = @@a3@@ ++ ; @@v12@@ = * @@v6@@ ; switch ( * @@v6@@ ) { case Number : xprintf ( ( unsigned int ) String , @@v13@@ - @@v14@@ + @@a5@@ , ( unsigned int ) String , @@v13@@ - @@v14@@ + @@a5@@ , @@a5@@ , @@a6@@ ) ; break ; case Number : xprintf ( ( unsigned int ) String , @@v13@@ - @@v14@@ + @@a5@@ , ( unsigned int ) String , @@v13@@ - @@v14@@ + @@a5@@ , @@a5@@ , @@a6@@ ) ; break ; case Number : xprintf ( ( unsigned int ) String , @@v13@@ - @@v14@@ + @@a5@@ , ( unsigned int ) String , @@v13@@ - @@v14@@ + @@a5@@ , @@a5@@ , @@a6@@ ) ; break ; case Number : xprintf ( ( unsigned int ) String , @@v13@@ - @@v14@@ + @@a5@@ , ( unsigned int ) String , @@v13@@ - @@v14@@ + @@a5@@ , @@a5@@ , @@a6@@ ) ; break ; case Number : xprintf ( ( unsigned int ) String , @@v13@@ - @@v14@@ + @@a5@@ , ( unsigned int ) String , @@v13@@ - @@v14@@ + @@a5@@ , @@a5@@ , @@a6@@ ) ; break ; case Number : xprintf ( ( unsigned int ) String , @@v13@@ - @@v14@@ + @@a5@@ , ( unsigned int ) String , @@v13@@ - @@v14@@ + @@a5@@ , @@a5@@ , @@a6@@ ) ; break ; case Number : xprintf ( ( unsigned int ) String , @@v13@@ - @@v14@@ + @@a5@@ , ( unsigned int ) String , @@v13@@ - @@v14@@ + @@a5@@ , @@a5@@ , @@a6@@ ) ; break ; case Number : xprintf ( ( unsigned int ) String , @@v13@@ - @@v14@@ + @@a5@@ , ( unsigned int ) String , @@v13@@ - @@v14@@ + @@a5@@ , @@a5@@ , @@a6@@ ) ; break ; default : if ( ( ( * __ctype_b_loc ( ) ) [ @@v12@@ ] & Number ) != Number ) sprintf ( @@s@@ , String , @@v12@@ ) ; else sprintf ( @@s@@ , String , @@v12@@ ) ; xprintf ( ( unsigned int ) String , @@v13@@ - @@v14@@ + @@a5@@ , ( unsigned int ) @@s@@ , @@v13@@ - @@v14@@ + @@a5@@ , @@v7@@ , @@v8@@ ) ; break ; } @@v13@@ = ( @@i@@ - Number ) * @@v10@@ / @@a1@@ ; } return __readfsqword ( Number ) ^ @@v18@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
void __fastcall mpsort ( __int64 * @@a1@@ , unsigned __int64 @@a2@@ , __int64 ( __fastcall * @@a3@@ ) ( __int64 , __int64 ) ) { mpsort_with_tmp ( @@a1@@ , @@a2@@ , & @@a1@@ [ @@a2@@ ] , @@a3@@ ) ; }
int __fastcall format_address_label ( unsigned __int64 @@a1@@ , char @@a2@@ ) { format_address_std ( @@a1@@ , Number ) ; return format_address_paren ( pseudo_offset + @@a1@@ , @@a2@@ ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
__int64 __fastcall hash_find_entry ( __int64 @@a1@@ , __int64 @@a2@@ , _QWORD * @@a3@@ , char @@a4@@ ) { __int64 @@v4@@ ; __int64 @@result@@ ; __int64 @@v6@@ ; _QWORD * @@i@@ ; _QWORD * @@v10@@ ; __int64 @@v11@@ ; _QWORD * @@v12@@ ; __int64 @@v13@@ ; _QWORD * @@v14@@ ; @@v4@@ = * ( _QWORD * ) @@a1@@ ; @@v10@@ = ( _QWORD * ) ( @@v4@@ + Number * ( * ( __int64 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@a2@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@v10@@ >= * ( _QWORD * ) ( @@a1@@ + Number ) ) abort ( ) ; * @@a3@@ = @@v10@@ ; if ( ! * @@v10@@ ) return Number L ; if ( @@a2@@ == * @@v10@@ || ( * ( unsigned __int8 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@a2@@ , * @@v10@@ ) ) { @@v13@@ = * @@v10@@ ; if ( @@a4@@ ) { if ( @@v10@@ [ Number ] ) { @@v14@@ = ( _QWORD * ) @@v10@@ [ Number ] ; @@v6@@ = @@v14@@ [ Number ] ; * @@v10@@ = * @@v14@@ ; @@v10@@ [ Number ] = @@v6@@ ; free_entry ( @@a1@@ , @@v14@@ ) ; } else { * @@v10@@ = Number L ; } } @@result@@ = @@v13@@ ; } else { for ( @@i@@ = @@v10@@ ; ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { if ( ! @@i@@ [ Number ] ) return Number L ; if ( @@a2@@ == * ( _QWORD * ) @@i@@ [ Number ] || ( * ( unsigned __int8 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@a2@@ , * ( _QWORD * ) @@i@@ [ Number ] ) ) { break ; } } @@v11@@ = * ( _QWORD * ) @@i@@ [ Number ] ; if ( @@a4@@ ) { @@v12@@ = ( _QWORD * ) @@i@@ [ Number ] ; @@i@@ [ Number ] = @@v12@@ [ Number ] ; free_entry ( @@a1@@ , @@v12@@ ) ; } @@result@@ = @@v11@@ ; } return @@result@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
_BOOL8 __fastcall read_block ( size_t @@a1@@ , __int64 @@a2@@ , _QWORD * @@a3@@ ) { int * @@v3@@ ; bool @@v6@@ ; bool @@v7@@ ; size_t @@n@@ ; size_t @@v9@@ ; @@v6@@ = Number ; if ( ! @@a1@@ || @@a1@@ > bytes_per_block ) __assert_fail ( String , String , Number , String ) ; * @@a3@@ = Number L ; while ( in_stream ) { @@n@@ = @@a1@@ - * @@a3@@ ; @@v9@@ = fread_unlocked ( ( void * ) ( * @@a3@@ + @@a2@@ ) , Number , @@n@@ , in_stream ) ; * @@a3@@ += @@v9@@ ; if ( @@v9@@ == @@n@@ ) break ; @@v3@@ = __errno_location ( ) ; @@v7@@ = ( @@v6@@ & ( unsigned __int8 ) check_and_close ( * @@v3@@ ) ) != Number ; @@v6@@ = ( @@v7@@ & ( unsigned __int8 ) open_next_file ( ) ) != Number ; } return @@v6@@ ; }
size_t __fastcall writeline ( __int64 @@a1@@ , FILE * @@a2@@ , int @@a3@@ ) { size_t @@result@@ ; if ( @@a3@@ == Number ) { @@result@@ = ( unsigned __int8 ) only_file_2 ^ Number ; if ( only_file_2 != Number ) return @@result@@ ; if ( ! only_file_1 ) return fwrite_unlocked ( * ( const void * * ) ( @@a1@@ + Number ) , Number , * ( _QWORD * ) ( @@a1@@ + Number ) , @@a2@@ ) ; goto LABEL_13 ; } if ( @@a3@@ == Number ) { @@result@@ = ( unsigned __int8 ) both ^ Number ; if ( both != Number ) return @@result@@ ; if ( only_file_1 ) fputs_unlocked ( delimiter , @@a2@@ ) ; if ( ! only_file_2 ) return fwrite_unlocked ( * ( const void * * ) ( @@a1@@ + Number ) , Number , * ( _QWORD * ) ( @@a1@@ + Number ) , @@a2@@ ) ; LABEL_13 : fputs_unlocked ( delimiter , @@a2@@ ) ; return fwrite_unlocked ( * ( const void * * ) ( @@a1@@ + Number ) , Number , * ( _QWORD * ) ( @@a1@@ + Number ) , @@a2@@ ) ; } if ( @@a3@@ != Number ) return fwrite_unlocked ( * ( const void * * ) ( @@a1@@ + Number ) , Number , * ( _QWORD * ) ( @@a1@@ + Number ) , @@a2@@ ) ; @@result@@ = ( unsigned __int8 ) only_file_1 ^ Number ; if ( only_file_1 == Number ) return fwrite_unlocked ( * ( const void * * ) ( @@a1@@ + Number ) , Number , * ( _QWORD * ) ( @@a1@@ + Number ) , @@a2@@ ) ; return @@result@@ ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
__int64 __fastcall i_ring_push ( __int64 @@a1@@ , int @@a2@@ ) { int @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = ( ( unsigned __int8 ) * ( _DWORD * ) ( @@a1@@ + Number ) + ( * ( _BYTE * ) ( @@a1@@ + Number ) ^ Number ) ) & Number ; @@v4@@ = * ( _DWORD * ) ( @@a1@@ + Number L * ( ( ( unsigned __int8 ) * ( _DWORD * ) ( @@a1@@ + Number ) + ( * ( _BYTE * ) ( @@a1@@ + Number ) ^ Number ) ) & Number ) ) ; * ( _DWORD * ) ( @@a1@@ + Number L * ( ( ( unsigned __int8 ) * ( _DWORD * ) ( @@a1@@ + Number ) + ( * ( _BYTE * ) ( @@a1@@ + Number ) ^ Number ) ) & Number ) ) = @@a2@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@v3@@ ; if ( @@v3@@ == * ( _DWORD * ) ( @@a1@@ + Number ) ) * ( _DWORD * ) ( @@a1@@ + Number ) = ( ( unsigned __int8 ) * ( _DWORD * ) ( @@a1@@ + Number ) + ( * ( _BYTE * ) ( @@a1@@ + Number ) ^ Number ) ) & Number ; * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; return @@v4@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
__int64 __fastcall xvfprintf ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { char * @@v3@@ ; int * @@v4@@ ; int @@v6@@ ; @@v6@@ = rpl_vfprintf ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( @@v6@@ < Number && ! ferror ( @@a1@@ ) ) { @@v3@@ = gettext ( String ) ; @@v4@@ = __errno_location ( ) ; error ( exit_failure , * @@v4@@ , @@v3@@ ) ; } return ( unsigned int ) @@v6@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
__int64 __fastcall memcoll ( const char * @@a1@@ , size_t @@a2@@ , const char * @@a3@@ , __int64 @@a4@@ ) { __int64 @@v4@@ ; __int64 @@v8@@ ; const char * @@s2@@ ; size_t @@n@@ ; const char * @@s1@@ ; char @@v12@@ ; char @@v13@@ ; unsigned int @@v14@@ ; size_t @@v15@@ ; size_t @@v16@@ ; @@s1@@ = @@a1@@ ; @@s2@@ = @@a3@@ ; if ( @@a2@@ == @@a4@@ && ! memcmp ( @@a1@@ , @@a3@@ , @@a2@@ ) ) { * __errno_location ( ) = Number ; @@v14@@ = Number ; } else { @@v12@@ = @@a1@@ [ @@a2@@ ] ; @@v13@@ = @@s2@@ [ @@a4@@ ] ; @@n@@ = @@a2@@ + Number ; @@a1@@ [ @@a2@@ ] = Number ; @@v4@@ = @@a4@@ ; @@v8@@ = @@a4@@ + Number ; @@s2@@ [ @@v4@@ ] = Number ; while ( Number ) { * __errno_location ( ) = Number ; @@v14@@ = strcoll ( @@s1@@ , @@s2@@ ) ; if ( @@v14@@ || * __errno_location ( ) ) break ; @@v15@@ = strlen ( @@s1@@ ) + Number ; @@v16@@ = strlen ( @@s2@@ ) + Number ; @@s1@@ += @@v15@@ ; @@s2@@ += @@v16@@ ; @@n@@ -= @@v15@@ ; @@v8@@ -= @@v16@@ ; if ( ! @@n@@ ) { if ( @@v8@@ ) @@v14@@ = Number ; break ; } if ( ! @@v8@@ ) { @@v14@@ = Number ; break ; } } @@s1@@ [ @@n@@ - Number ] = @@v12@@ ; @@s2@@ [ @@v8@@ - Number ] = @@v13@@ ; } return @@v14@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
void * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
int __fastcall rpl_fseeko ( FILE * @@a1@@ , __off_t @@a2@@ , int @@a3@@ ) { __off_t @@v3@@ ; int @@v4@@ ; int @@result@@ ; if ( @@a1@@ -> _IO_read_end != @@a1@@ -> _IO_read_ptr || @@a1@@ -> _IO_write_ptr != @@a1@@ -> _IO_write_base || @@a1@@ -> _IO_save_base ) { goto LABEL_13 ; } if ( @@a3@@ == Number && @@a2@@ > Number ) @@v3@@ = Number L ; else @@v3@@ = @@a2@@ ; @@v4@@ = fileno ( @@a1@@ ) ; if ( lseek ( @@v4@@ , @@v3@@ , @@a3@@ ) == Number ) return Number ; @@a1@@ -> _flags &= Number ; if ( @@a3@@ == Number && @@a2@@ > Number ) LABEL_13 : @@result@@ = fseeko ( @@a1@@ , @@a2@@ , @@a3@@ ) ; else @@result@@ = Number ; return @@result@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
void * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
__int64 __fastcall iso_week_days ( int @@a1@@ , int @@a2@@ ) { return ( unsigned int ) ( @@a1@@ - ( @@a1@@ - @@a2@@ + Number ) % Number + Number ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v4@@ ; @@v4@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v4@@ >= Number / @@a3@@ ) xalloc_die ( ) ; @@v4@@ += ( @@v4@@ + Number ) >> Number ; } else if ( ! @@v4@@ ) { @@v4@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v4@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v4@@ ) ; }
__int64 __fastcall umaxtostr ( unsigned __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v4@@ ; @@v4@@ = @@a2@@ + Number ; * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; do { * ( _BYTE * ) -- @@v4@@ = @@a1@@ % Number + Number ; @@a1@@ /= Number ; } while ( @@a1@@ ) ; return @@v4@@ ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_2080C8 ; @@v4@@ [ Number ] = qword_2080D0 ; @@v4@@ [ Number ] = qword_2080D8 ; @@v4@@ [ Number ] = qword_2080E0 ; @@v4@@ [ Number ] = qword_2080E8 ; @@v4@@ [ Number ] = qword_2080F0 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
_BOOL8 __fastcall c_isascii ( int @@a1@@ ) { return @@a1@@ >= Number && @@a1@@ <= Number ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 * __fastcall parse_line ( unsigned __int8 * @@a1@@ , _QWORD * @@a2@@ , __int64 * @@a3@@ ) { const unsigned __int16 * @@v3@@ ; __int64 * @@result@@ ; const unsigned __int16 * @@v5@@ ; const unsigned __int16 * @@v6@@ ; const unsigned __int16 * @@v7@@ ; __int64 @@v8@@ ; unsigned __int8 * @@i@@ ; unsigned __int8 * @@v12@@ ; unsigned __int8 * @@v13@@ ; * @@a2@@ = Number L ; * @@a3@@ = Number L ; while ( Number ) { @@v3@@ = * __ctype_b_loc ( ) ; if ( ( @@v3@@ [ ( unsigned __int8 ) to_uchar ( * @@a1@@ ) ] & Number ) == Number ) break ; ++ @@a1@@ ; } @@result@@ = ( __int64 * ) * @@a1@@ ; if ( ( _BYTE ) @@result@@ ) { @@result@@ = ( __int64 * ) * @@a1@@ ; if ( ( _BYTE ) @@result@@ != Number ) { @@v12@@ = @@a1@@ ; while ( Number ) { @@v5@@ = * __ctype_b_loc ( ) ; if ( ( @@v5@@ [ ( unsigned __int8 ) to_uchar ( * @@a1@@ ) ] & Number ) != Number || ! * @@a1@@ ) { break ; } ++ @@a1@@ ; } * @@a2@@ = xstrndup ( @@v12@@ , @@a1@@ - @@v12@@ ) ; @@result@@ = ( __int64 * ) * @@a1@@ ; if ( ( _BYTE ) @@result@@ ) { do { ++ @@a1@@ ; @@v6@@ = * __ctype_b_loc ( ) ; } while ( ( @@v6@@ [ ( unsigned __int8 ) to_uchar ( * @@a1@@ ) ] & Number ) != Number ) ; @@result@@ = ( __int64 * ) * @@a1@@ ; if ( ( _BYTE ) @@result@@ ) { @@result@@ = ( __int64 * ) * @@a1@@ ; if ( ( _BYTE ) @@result@@ != Number ) { @@v13@@ = @@a1@@ ; while ( * @@a1@@ && * @@a1@@ != Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ - Number ; ; -- @@i@@ ) { @@v7@@ = * __ctype_b_loc ( ) ; if ( ( @@v7@@ [ ( unsigned __int8 ) to_uchar ( * @@i@@ ) ] & Number ) == Number ) break ; } @@v8@@ = xstrndup ( @@v13@@ , @@i@@ + Number - @@v13@@ ) ; @@result@@ = @@a3@@ ; * @@a3@@ = @@v8@@ ; } } } } } return @@result@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_212038 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
size_t __fastcall rpl_vprintf ( __int64 @@a1@@ , __int64 @@a2@@ ) { return rpl_vfprintf ( stdout , @@a1@@ , @@a2@@ ) ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
_BOOL8 __fastcall c_isalpha ( int @@a1@@ ) { return ( int ) ( @@a1@@ & Number ) > Number && ( int ) ( @@a1@@ & Number ) <= Number ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
_BOOL8 __fastcall c_islower ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
__int64 __fastcall set_cloexec_flag ( int @@a1@@ , char @@a2@@ , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { int @@v6@@ ; int @@v7@@ ; int @@v8@@ ; unsigned int @@v9@@ ; __int64 @@result@@ ; int @@v11@@ ; @@v11@@ = rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( @@v11@@ < Number || ( ! @@a2@@ ? ( @@v9@@ = @@v11@@ & Number ) : ( @@v9@@ = @@v11@@ | Number ) , @@v11@@ != @@v9@@ && ( unsigned int ) rpl_fcntl ( @@a1@@ , Number , @@v9@@ , @@v6@@ , @@v7@@ , @@v8@@ ) == Number ) ) { @@result@@ = Number ; } else { @@result@@ = Number L ; } return @@result@@ ; }
unsigned __int64 __fastcall xstrtol_error ( unsigned int @@a1@@ , int @@a2@@ , char @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , int @@a6@@ ) { char * @@v6@@ ; char * @@v10@@ ; char * @@msgid@@ ; char * @@v12@@ ; char @@v13@@ [ Number ] ; unsigned __int64 @@v14@@ ; @@v14@@ = __readfsqword ( Number ) ; @@v10@@ = ( char * ) & unk_FE08 ; if ( @@a1@@ > Number ) { if ( @@a1@@ != Number ) goto LABEL_6 ; @@msgid@@ = String ; } else if ( @@a1@@ >= Number ) { @@msgid@@ = String ; } else { if ( @@a1@@ != Number ) LABEL_6 : abort ( ) ; @@msgid@@ = String ; } if ( @@a2@@ >= Number ) { @@v12@@ = * ( char * * ) ( Number L * @@a2@@ + @@a4@@ ) ; } else { @@v10@@ = ( char * ) & unk_FE08 - @@a2@@ ; @@v13@@ [ Number ] = @@a3@@ ; @@v13@@ [ Number ] = Number ; @@v12@@ = @@v13@@ ; } @@v6@@ = gettext ( @@msgid@@ ) ; error ( @@a6@@ , Number , @@v6@@ , @@v10@@ , @@v12@@ , @@a5@@ ) ; return __readfsqword ( Number ) ^ @@v14@@ ; }
__int64 __fastcall c_tolower ( int @@a1@@ ) { __int64 @@result@@ ; if ( @@a1@@ <= Number || @@a1@@ > Number ) @@result@@ = ( unsigned int ) @@a1@@ ; else @@result@@ = ( unsigned int ) ( @@a1@@ + Number ) ; return @@result@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
int __fastcall fstat ( int @@fildes@@ , struct stat * @@stat_buf@@ ) { return __fxstat ( Number , @@fildes@@ , @@stat_buf@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall bkm_scale_0 ( unsigned __int64 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( is_mul_ok ( @@a2@@ , * @@a1@@ ) ) { * @@a1@@ *= @@a2@@ ; @@result@@ = Number L ; } else { * @@a1@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
int __fastcall fstat ( int @@fildes@@ , struct stat * @@stat_buf@@ ) { return __fxstat ( Number , @@fildes@@ , @@stat_buf@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
DIR * opendir ( const char * @@name@@ ) { return opendir ( @@name@@ ) ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
struct passwd * getpwuid ( __uid_t @@uid@@ ) { return getpwuid ( @@uid@@ ) ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
int __fxstatat ( int @@ver@@ , int @@fildes@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ , int @@flag@@ ) { return _fxstatat ( @@ver@@ , @@fildes@@ , @@filename@@ , @@stat_buf@@ , @@flag@@ ) ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v4@@ ; @@v4@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v4@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ ) ; @@v4@@ += ( @@v4@@ + Number ) >> Number ; } else if ( ! @@v4@@ ) { @@v4@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v4@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v4@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
void * __fastcall initbuffer ( void * @@a1@@ ) { return memset ( @@a1@@ , Number , Number ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
struct passwd * getpwnam ( const char * @@name@@ ) { return getpwnam ( @@name@@ ) ; }
__int64 __fastcall bad_cast ( __int64 @@a1@@ ) { return @@a1@@ ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
__int64 __fastcall readlinebuffer ( __int64 @@a1@@ , __int64 @@a2@@ ) { return readlinebuffer_delim ( @@a1@@ , @@a2@@ , Number L ) ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
int __fxstat ( int @@ver@@ , int @@fildes@@ , struct stat * @@stat_buf@@ ) { return _fxstat ( @@ver@@ , @@fildes@@ , @@stat_buf@@ ) ; }
_BOOL8 __fastcall c_isblank ( int @@a1@@ ) { return @@a1@@ == Number || @@a1@@ == Number ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
_BOOL8 __fastcall c_isprint ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 __fastcall c_tolower ( int @@a1@@ ) { __int64 @@result@@ ; if ( @@a1@@ <= Number || @@a1@@ > Number ) @@result@@ = ( unsigned int ) @@a1@@ ; else @@result@@ = ( unsigned int ) ( @@a1@@ + Number ) ; return @@result@@ ; }
__int64 __fastcall digest_file ( const char * @@a1@@ , __int64 a2 , __int64 @@a3@@ ) { int @@v3@@ ; int @@v4@@ ; int * @@v5@@ ; int * @@v7@@ ; bool @@v9@@ ; FILE * @@stream@@ ; @@v3@@ = strcmp ( @@a1@@ , String ) ; @@v9@@ = @@v3@@ == Number ; if ( @@v3@@ ) { @@stream@@ = ( FILE * ) fopen_safer ( @@a1@@ , String ) ; if ( ! @@stream@@ ) goto LABEL_4 ; @@v4@@ = sha1_stream ( @@stream@@ , @@a3@@ ) ; } else { have_read_stdin = Number ; @@stream@@ = stdin ; @@v4@@ = sha1_stream ( stdin , @@a3@@ ) ; } if ( ! @@v4@@ ) { if ( @@v9@@ || ! fclose ( @@stream@@ ) ) return Number L ; LABEL_4 : @@v5@@ = __errno_location ( ) ; error ( Number , * @@v5@@ , String , @@a1@@ ) ; return Number L ; } @@v7@@ = __errno_location ( ) ; error ( Number , * @@v7@@ , String , @@a1@@ ) ; if ( @@stream@@ != stdin ) fclose ( @@stream@@ ) ; return Number L ; }
__int64 * __fastcall readlinebuffer_delim ( __int64 * @@a1@@ , FILE * @@a2@@ , char @@a3@@ ) { _BYTE * @@v4@@ ; int @@v6@@ ; __int64 @@v7@@ ; _BYTE * @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; @@v7@@ = @@a1@@ [ Number ] ; @@v8@@ = ( _BYTE * ) @@v7@@ ; @@v9@@ = * @@a1@@ + @@v7@@ ; if ( feof_unlocked ( @@a2@@ ) ) return Number L ; while ( Number ) { @@v6@@ = getc_unlocked ( @@a2@@ ) ; if ( @@v6@@ == Number ) break ; LABEL_9 : if ( @@v8@@ == ( _BYTE * ) @@v9@@ ) { @@v10@@ = * @@a1@@ ; @@v7@@ = x2realloc ( @@v7@@ , @@a1@@ ) ; @@v8@@ = ( _BYTE * ) ( @@v7@@ + @@v10@@ ) ; @@a1@@ [ Number ] = @@v7@@ ; @@v9@@ = * @@a1@@ + @@v7@@ ; } @@v4@@ = @@v8@@ ++ ; * @@v4@@ = @@v6@@ ; if ( @@v6@@ == @@a3@@ ) goto LABEL_12 ; } if ( @@v8@@ == ( _BYTE * ) @@v7@@ || ferror_unlocked ( @@a2@@ ) ) return Number L ; if ( @@a3@@ != * ( @@v8@@ - Number ) ) { @@v6@@ = @@a3@@ ; goto LABEL_9 ; } LABEL_12 : @@a1@@ [ Number ] = ( __int64 ) & @@v8@@ [ - @@v7@@ ] ; return @@a1@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
__int64 __fastcall gid_to_name ( __gid_t @@a1@@ ) { __int64 @@v1@@ ; struct group * @@v3@@ ; char @@v4@@ [ Number ] ; unsigned __int64 @@v5@@ ; @@v5@@ = __readfsqword ( Number ) ; @@v3@@ = getgrgid ( @@a1@@ ) ; if ( @@v3@@ ) @@v1@@ = ( __int64 ) @@v3@@ -> gr_name ; else @@v1@@ = umaxtostr ( @@a1@@ , @@v4@@ ) ; return xstrdup ( @@v1@@ ) ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , off_83A2 , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_2060C8 ; @@v4@@ [ Number ] = qword_2060D0 ; @@v4@@ [ Number ] = qword_2060D8 ; @@v4@@ [ Number ] = qword_2060E0 ; @@v4@@ [ Number ] = qword_2060E8 ; @@v4@@ [ Number ] = qword_2060F0 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
_BOOL8 __fastcall chown_files ( __int64 @@a1@@ , unsigned int @@a2@@ , __uid_t @@a3@@ , __gid_t @@a4@@ , int @@a5@@ , int @@a6@@ , __int64 @@a7@@ ) { int @@v7@@ ; char * @@v8@@ ; int * @@v9@@ ; char * @@v10@@ ; int * @@v11@@ ; bool @@v17@@ ; __int64 @@i@@ ; __int64 @@v19@@ ; @@v17@@ = Number ; if ( @@a5@@ == Number && @@a6@@ == Number && ! * ( _BYTE * ) ( @@a7@@ + Number ) && * ( _DWORD * ) @@a7@@ == Number ) { @@v7@@ = Number ; } else { @@v7@@ = Number ; } for ( @@i@@ = xfts_open ( @@a1@@ , @@v7@@ | @@a2@@ , Number L ) ; ; @@v17@@ = ( @@v17@@ & ( unsigned __int8 ) change_file_owner ( @@i@@ , @@v19@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ , @@a7@@ ) ) != Number ) { @@v19@@ = fts_read ( @@i@@ ) ; if ( ! @@v19@@ ) break ; } if ( * __errno_location ( ) ) { if ( * ( _BYTE * ) ( @@a7@@ + Number ) != Number ) { @@v8@@ = gettext ( String ) ; @@v9@@ = __errno_location ( ) ; error ( Number , * @@v9@@ , @@v8@@ ) ; } @@v17@@ = Number ; } if ( ( unsigned int ) fts_close ( @@i@@ ) ) { @@v10@@ = gettext ( String ) ; @@v11@@ = __errno_location ( ) ; error ( Number , * @@v11@@ , @@v10@@ ) ; @@v17@@ = Number ; } return @@v17@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
__int64 __fastcall xmemcoll ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ ) { char * @@v4@@ ; char * @@v5@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; unsigned int @@v12@@ ; int @@errnum@@ ; @@v12@@ = memcoll ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; @@errnum@@ = * __errno_location ( ) ; if ( @@errnum@@ ) { @@v4@@ = gettext ( String ) ; error ( Number , @@errnum@@ , @@v4@@ ) ; @@v5@@ = gettext ( String ) ; error ( Number , Number , @@v5@@ ) ; @@v6@@ = quotearg_n_style_mem ( Number L , Number L , @@a3@@ , @@a4@@ ) ; @@v7@@ = quotearg_n_style_mem ( Number L , Number L , @@a1@@ , @@a2@@ ) ; @@v8@@ = gettext ( String ) ; error ( exit_failure , Number , @@v8@@ , @@v7@@ , @@v6@@ ) ; } return @@v12@@ ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
char * nl_langinfo ( nl_item @@item@@ ) { return nl_langinfo ( @@item@@ ) ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
unsigned __int64 __fastcall AD_hash ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) % @@a2@@ ; }
unsigned __int64 __fastcall gcd ( unsigned __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { unsigned __int64 @@v5@@ ; do { @@v5@@ = @@a1@@ % @@a2@@ ; @@a1@@ = @@a2@@ ; @@a2@@ = @@v5@@ ; } while ( @@v5@@ ) ; return @@a1@@ ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
int fileno ( FILE * @@stream@@ ) { return fileno ( @@stream@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
void __fastcall free_dir ( __int64 @@a1@@ ) { if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) hash_free ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ; } else { free ( * ( void * * ) ( @@a1@@ + Number ) ) ; } }
void free ( void * @@ptr@@ ) { __imp_free ( @@ptr@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_20A0E8 ; @@v4@@ [ Number ] = qword_20A0F0 ; @@v4@@ [ Number ] = qword_20A0F8 ; @@v4@@ [ Number ] = qword_20A100 ; @@v4@@ [ Number ] = qword_20A108 ; @@v4@@ [ Number ] = qword_20A110 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
__int64 __fastcall opendirat ( int @@a1@@ , int @@a2@@ , __int64 a3 , __int64 a4 , int @@a5@@ , int @@a6@@ ) { int @@fd@@ ; _BYTE @@v8@@ [ Number ] ; @@fd@@ = openat_safer ( @@a1@@ , @@a2@@ , Number , @@a2@@ , @@a5@@ , @@a6@@ , @@a2@@ ) ; if ( @@fd@@ < Number ) return Number L ; set_cloexec_flag ( ( unsigned int ) @@fd@@ , Number L ) ; * ( _QWORD * ) & @@v8@@ [ Number ] = fdopendir ( @@fd@@ ) ; if ( ! * ( _QWORD * ) & @@v8@@ [ Number ] ) { * ( _QWORD * ) @@v8@@ = ( unsigned int ) * __errno_location ( ) ; close ( @@fd@@ ) ; * __errno_location ( ) = * ( _DWORD * ) @@v8@@ ; } return * ( _QWORD * ) & @@v8@@ [ Number ] ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; char * @@v3@@ ; FILE * @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; FILE * @@v10@@ ; char * @@v11@@ ; @@v1@@ = program_name ; if ( @@a1@@ ) { @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = gettext ( String ) ; printf ( @@v3@@ , @@v1@@ ) ; @@v4@@ = stdout ; @@v5@@ = gettext ( String String String String String String ) ; fputs_unlocked ( @@v5@@ , @@v4@@ ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; @@v8@@ = stdout ; @@v9@@ = gettext ( String ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = stdout ; @@v11@@ = gettext ( String String String String ) ; fputs_unlocked ( @@v11@@ , @@v10@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; FILE * @@v11@@ ; char * @@v12@@ ; FILE * @@v13@@ ; char * @@v14@@ ; FILE * @@v15@@ ; char * @@v16@@ ; FILE * @@v17@@ ; char * @@v18@@ ; FILE * @@v19@@ ; char * @@v20@@ ; FILE * @@v21@@ ; char * @@v22@@ ; FILE * @@v23@@ ; char * @@v24@@ ; FILE * @@v25@@ ; char * @@v26@@ ; FILE * @@v27@@ ; char * @@v28@@ ; FILE * @@v29@@ ; char * @@v30@@ ; FILE * @@v31@@ ; char * @@v32@@ ; FILE * @@v33@@ ; char * @@v34@@ ; if ( @@a1@@ ) { @@v1@@ = program_name ; @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = program_name ; @@v4@@ = program_name ; @@v5@@ = program_name ; @@v6@@ = gettext ( String String String ) ; printf ( @@v6@@ , @@v5@@ , @@v4@@ , @@v3@@ ) ; @@v7@@ = stdout ; @@v8@@ = gettext ( String String String String String String ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = stdout ; @@v10@@ = gettext ( String ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; @@v11@@ = stdout ; @@v12@@ = gettext ( String String ) ; fputs_unlocked ( @@v12@@ , @@v11@@ ) ; @@v13@@ = stdout ; @@v14@@ = gettext ( String String String String String String ) ; fputs_unlocked ( @@v14@@ , @@v13@@ ) ; @@v15@@ = stdout ; @@v16@@ = gettext ( String ) ; fputs_unlocked ( @@v16@@ , @@v15@@ ) ; @@v17@@ = stdout ; @@v18@@ = gettext ( String ) ; fputs_unlocked ( @@v18@@ , @@v17@@ ) ; @@v19@@ = stdout ; @@v20@@ = gettext ( String String String String String String ) ; fputs_unlocked ( @@v20@@ , @@v19@@ ) ; @@v21@@ = stdout ; @@v22@@ = gettext ( String String String String String String ) ; fputs_unlocked ( @@v22@@ , @@v21@@ ) ; @@v23@@ = stdout ; @@v24@@ = gettext ( String String String String String String String ) ; fputs_unlocked ( @@v24@@ , @@v23@@ ) ; @@v25@@ = stdout ; @@v26@@ = gettext ( String String String String String ) ; fputs_unlocked ( @@v26@@ , @@v25@@ ) ; @@v27@@ = stdout ; @@v28@@ = gettext ( String String String String String ) ; fputs_unlocked ( @@v28@@ , @@v27@@ ) ; @@v29@@ = stdout ; @@v30@@ = gettext ( String String String String String ) ; fputs_unlocked ( @@v30@@ , @@v29@@ ) ; @@v31@@ = stdout ; @@v32@@ = gettext ( String String String String String String String ) ; fputs_unlocked ( @@v32@@ , @@v31@@ ) ; @@v33@@ = stdout ; @@v34@@ = gettext ( String String ) ; fputs_unlocked ( @@v34@@ , @@v33@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
__int64 __fastcall fts_close ( __int64 @@a1@@ ) { _QWORD * @@v1@@ ; void * @@v2@@ ; _QWORD * @@v3@@ ; int @@v5@@ ; @@v5@@ = Number ; if ( * ( _QWORD * ) @@a1@@ ) { @@v1@@ = * ( _QWORD * * ) @@a1@@ ; while ( ( __int64 ) @@v1@@ [ Number ] >= Number ) { @@v2@@ = @@v1@@ ; if ( @@v1@@ [ Number ] ) @@v3@@ = ( _QWORD * ) @@v1@@ [ Number ] ; else @@v3@@ = ( _QWORD * ) @@v1@@ [ Number ] ; @@v1@@ = @@v3@@ ; free ( @@v2@@ ) ; } free ( @@v1@@ ) ; } if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) fts_lfree ( * ( void * * ) ( @@a1@@ + Number ) ) ; free ( * ( void * * ) ( @@a1@@ + Number ) ) ; free ( * ( void * * ) ( @@a1@@ + Number ) ) ; if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) != Number ) { if ( * ( int * ) ( @@a1@@ + Number ) >= Number && close ( * ( _DWORD * ) ( @@a1@@ + Number ) ) ) { LABEL_20 : @@v5@@ = * __errno_location ( ) ; goto LABEL_21 ; } } else if ( ( * ( _DWORD * ) ( @@a1@@ + Number ) & Number ) == Number ) { if ( fchdir ( * ( _DWORD * ) ( @@a1@@ + Number ) ) ) @@v5@@ = * __errno_location ( ) ; if ( close ( * ( _DWORD * ) ( @@a1@@ + Number ) ) && ! @@v5@@ ) goto LABEL_20 ; } LABEL_21 : fd_ring_clear ( @@a1@@ + Number ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) hash_free ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ; free_dir ( @@a1@@ ) ; free ( ( void * ) @@a1@@ ) ; if ( ! @@v5@@ ) return Number L ; * __errno_location ( ) = @@v5@@ ; return Number ; }
int __fastcall dump_hexl_mode_trailer ( __int64 @@a1@@ , unsigned __int8 * @@a2@@ ) { unsigned __int8 * @@v2@@ ; unsigned __int8 @@v3@@ ; unsigned __int8 @@v6@@ ; fwrite_unlocked ( String , Number , Number , stdout ) ; while ( @@a1@@ ) { @@v2@@ = @@a2@@ ++ ; @@v6@@ = * @@v2@@ ; if ( ( ( * __ctype_b_loc ( ) ) [ @@v6@@ ] & Number ) != Number ) @@v3@@ = @@v6@@ ; else @@v3@@ = Number ; putchar_unlocked ( @@v3@@ ) ; -- @@a1@@ ; } return putchar_unlocked ( Number ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_2080C8 ; @@v8@@ [ Number ] = qword_2080D0 ; @@v8@@ [ Number ] = qword_2080D8 ; @@v8@@ [ Number ] = qword_2080E0 ; @@v8@@ [ Number ] = qword_2080E8 ; @@v8@@ [ Number ] = qword_2080F0 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
unsigned __int64 __fastcall sha1_process_bytes ( char * @@a1@@ , unsigned __int64 @@a2@@ , unsigned int * @@a3@@ ) { unsigned __int64 @@result@@ ; size_t @@v4@@ ; void * @@v5@@ ; size_t @@v7@@ ; char * @@src@@ ; size_t @@v9@@ ; size_t @@v10@@ ; __int64 @@v11@@ ; size_t @@n@@ ; @@src@@ = @@a1@@ ; @@v7@@ = @@a2@@ ; @@result@@ = @@a3@@ [ Number ] ; if ( ( _DWORD ) @@result@@ ) { @@v11@@ = @@a3@@ [ Number ] ; @@v4@@ = Number - @@v11@@ ; if ( @@a2@@ <= Number - @@v11@@ ) @@v4@@ = @@a2@@ ; @@n@@ = @@v4@@ ; memcpy ( ( char * ) @@a3@@ + @@v11@@ + Number , @@a1@@ , @@v4@@ ) ; @@a3@@ [ Number ] += @@n@@ ; if ( @@a3@@ [ Number ] > Number ) { sha1_process_block ( @@a3@@ + Number , @@a3@@ [ Number ] & Number , @@a3@@ ) ; @@a3@@ [ Number ] &= Number ; memcpy ( @@a3@@ + Number , ( char * ) @@a3@@ + ( ( @@v11@@ + @@n@@ ) & Number ) + Number , @@a3@@ [ Number ] ) ; } @@src@@ = & @@a1@@ [ @@n@@ ] ; @@result@@ = @@n@@ ; @@v7@@ = @@a2@@ - @@n@@ ; } if ( @@v7@@ > Number ) { @@result@@ = ( unsigned __int8 ) @@src@@ & Number ; if ( ( ( unsigned __int8 ) @@src@@ & Number ) != Number ) { while ( @@v7@@ > Number ) { @@v5@@ = memcpy ( @@a3@@ + Number , @@src@@ , Number ) ; @@result@@ = sha1_process_block ( @@v5@@ , Number L , @@a3@@ ) ; @@src@@ += Number ; @@v7@@ -= Number L ; } } else { sha1_process_block ( @@src@@ , @@v7@@ & Number , @@a3@@ ) ; @@result@@ = @@v7@@ & Number ; @@src@@ += @@v7@@ & Number ; @@v7@@ &= Number ; } } if ( @@v7@@ ) { @@v9@@ = @@a3@@ [ Number ] ; memcpy ( ( char * ) @@a3@@ + @@v9@@ + Number , @@src@@ , @@v7@@ ) ; @@v10@@ = @@v7@@ + @@v9@@ ; if ( @@v10@@ > Number ) { sha1_process_block ( @@a3@@ + Number , Number L , @@a3@@ ) ; @@v10@@ -= Number L ; memcpy ( @@a3@@ + Number , @@a3@@ + Number , @@v10@@ ) ; } @@result@@ = ( unsigned __int64 ) @@a3@@ ; @@a3@@ [ Number ] = @@v10@@ ; } return @@result@@ ; }
__int64 __fastcall set_stat_type ( __int64 @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; int @@v3@@ ; switch ( @@a2@@ ) { case Number : @@v3@@ = Number ; break ; case Number : @@v3@@ = Number ; break ; case Number : @@v3@@ = Number ; break ; case Number : @@v3@@ = Number ; break ; case Number : @@v3@@ = Number ; break ; case Number : @@v3@@ = Number ; break ; case Number : @@v3@@ = Number ; break ; default : @@v3@@ = Number ; break ; } @@result@@ = @@a1@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@v3@@ ; return @@result@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
FILE * __fastcall freopen_safer ( const char * @@a1@@ , const char * @@a2@@ , FILE * @@a3@@ ) { int @@v3@@ ; FILE * @@streama@@ ; char @@v7@@ ; char @@v8@@ ; char @@v9@@ ; int @@v10@@ ; @@v7@@ = Number ; @@v8@@ = Number ; @@v9@@ = Number ; @@v3@@ = fileno ( @@a3@@ ) ; if ( @@v3@@ != Number ) { if ( @@v3@@ != Number ) { if ( ! @@v3@@ ) goto LABEL_10 ; if ( dup2 ( Number , Number ) != Number ) @@v9@@ = Number ; } if ( dup2 ( Number , Number ) != Number ) @@v8@@ = Number ; } if ( dup2 ( Number , Number ) ) @@v7@@ = Number ; LABEL_10 : if ( @@v7@@ && ( unsigned __int8 ) protect_fd ( Number ) != Number ) { @@streama@@ = Number L ; } else if ( @@v8@@ && ( unsigned __int8 ) protect_fd ( Number ) != Number ) { @@streama@@ = Number L ; } else if ( @@v9@@ && ( unsigned __int8 ) protect_fd ( Number ) != Number ) { @@streama@@ = Number L ; } else { @@streama@@ = freopen ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } @@v10@@ = * __errno_location ( ) ; if ( @@v9@@ ) close ( Number ) ; if ( @@v8@@ ) close ( Number ) ; if ( @@v7@@ ) close ( Number ) ; if ( ! @@streama@@ ) * __errno_location ( ) = @@v10@@ ; return @@streama@@ ; }
__int64 __fastcall check_and_close ( int @@a1@@ ) { char * @@v1@@ ; char * @@v2@@ ; const char * @@v3@@ ; int * @@v4@@ ; char * @@v5@@ ; unsigned __int8 @@v7@@ ; @@v7@@ = Number ; if ( in_stream ) { if ( ferror_unlocked ( in_stream ) ) { @@v1@@ = input_filename ; @@v2@@ = gettext ( String ) ; error ( Number , @@a1@@ , @@v2@@ , @@v1@@ ) ; if ( strcmp ( * ( const char * * ) ( file_list - Number ) , String ) ) fclose ( in_stream ) ; @@v7@@ = Number ; } else if ( strcmp ( * ( const char * * ) ( file_list - Number ) , String ) && fclose ( in_stream ) ) { @@v3@@ = input_filename ; @@v4@@ = __errno_location ( ) ; error ( Number , * @@v4@@ , String , @@v3@@ ) ; @@v7@@ = Number ; } in_stream = Number L ; } if ( ferror_unlocked ( stdout ) ) { @@v5@@ = gettext ( String ) ; error ( Number , Number , @@v5@@ ) ; @@v7@@ = Number ; } return @@v7@@ ; }
__int64 __fastcall dup_safer ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
__int64 __fastcall fts_sort ( __int64 @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { size_t @@v3@@ ; _QWORD * @@v5@@ ; __int64 @@i@@ ; _QWORD * @@v7@@ ; _QWORD * @@v8@@ ; __int64 @@v9@@ ; int ( * @@compar@@ ( ) ( constvoid , constvoid ) ) ( const void * , const void * ) ; void * @@v11@@ ; @@v3@@ = @@a3@@ ; @@compar@@ ( ) ( constvoid , constvoid ) = * ( int ( * * ) ( const void * , const void * ) ) ( @@a1@@ + Number ) ; if ( @@a3@@ > * ( _QWORD * ) ( @@a1@@ + Number ) ) { * ( _QWORD * ) ( @@a1@@ + Number ) = @@a3@@ + Number ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) > Number || ( @@v11@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number L * * ( _QWORD * ) ( @@a1@@ + Number ) ) ) == Number L ) { free ( * ( void * * ) ( @@a1@@ + Number ) ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; return @@a2@@ ; } * ( _QWORD * ) ( @@a1@@ + Number ) = @@v11@@ ; } @@v5@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; for ( @@i@@ = @@a2@@ ; @@i@@ ; @@i@@ = * ( _QWORD * ) ( @@i@@ + Number ) ) { @@v7@@ = @@v5@@ ++ ; * @@v7@@ = @@i@@ ; } qsort ( * ( void * * ) ( @@a1@@ + Number ) , @@v3@@ , Number , @@compar@@ ( ) ( constvoid , constvoid ) ) ; @@v8@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; @@v9@@ = * @@v8@@ ; while ( -- @@v3@@ ) { * ( _QWORD * ) ( * @@v8@@ + Number L ) = @@v8@@ [ Number ] ; ++ @@v8@@ ; } * ( _QWORD * ) ( * @@v8@@ + Number L ) = Number L ; return @@v9@@ ; }
int __fastcall format_address_paren ( unsigned __int64 @@a1@@ , char @@a2@@ ) { int @@result@@ ; putchar_unlocked ( Number ) ; @@result@@ = format_address_std ( @@a1@@ , Number ) ; if ( @@a2@@ ) @@result@@ = putchar_unlocked ( @@a2@@ ) ; return @@result@@ ; }
__int64 __fastcall hash_get_n_buckets ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
__int64 __fastcall hash_get_n_entries ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
_BOOL8 __fastcall read_char ( int * @@a1@@ ) { int * @@v1@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = Number ; * @@a1@@ = Number ; while ( in_stream ) { * @@a1@@ = fgetc ( in_stream ) ; if ( * @@a1@@ != Number ) break ; @@v1@@ = __errno_location ( ) ; @@v4@@ = ( @@v3@@ & ( unsigned __int8 ) check_and_close ( * @@v1@@ ) ) != Number ; @@v3@@ = ( @@v4@@ & ( unsigned __int8 ) open_next_file ( ) ) != Number ; } return @@v3@@ ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
__int64 __fastcall hash_get_first ( unsigned __int64 * @@a1@@ ) { unsigned __int64 @@i@@ ; if ( ! @@a1@@ [ Number ] ) return Number L ; for ( @@i@@ = * @@a1@@ ; ; @@i@@ += Number L ) { if ( @@i@@ >= @@a1@@ [ Number ] ) abort ( ) ; if ( * ( _QWORD * ) @@i@@ ) break ; } return * ( _QWORD * ) @@i@@ ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_20A128 ; @@v8@@ [ Number ] = qword_20A130 ; @@v8@@ [ Number ] = qword_20A138 ; @@v8@@ [ Number ] = qword_20A140 ; @@v8@@ [ Number ] = qword_20A148 ; @@v8@@ [ Number ] = qword_20A150 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
__int64 __fastcall select_plural ( __int64 @@a1@@ ) { return @@a1@@ ; }
__int64 __fastcall bkm_scale_by_power ( unsigned __int64 * @@a1@@ , int @@a2@@ , int @@a3@@ ) { unsigned int @@i@@ ; for ( @@i@@ = Number ; @@a3@@ -- ; @@i@@ |= bkm_scale ( @@a1@@ , @@a2@@ ) ) ; return @@i@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
unsigned __int64 __fastcall hash_get_entries ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; _QWORD * @@i@@ ; _QWORD * @@j@@ ; @@v5@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = @@i@@ ; @@j@@ ; @@j@@ = ( _QWORD * ) @@j@@ [ Number ] ) { if ( @@v5@@ >= @@a3@@ ) return @@v5@@ ; @@v4@@ = @@v5@@ ++ ; * ( _QWORD * ) ( @@a2@@ + Number * @@v4@@ ) = * @@j@@ ; } } } return @@v5@@ ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
bool __fastcall hex_digits ( _BYTE * @@a1@@ ) { unsigned int @@i@@ ; for ( @@i@@ = Number ; @@i@@ < ( unsigned __int64 ) digest_hex_bytes ; ++ @@i@@ ) { if ( ( ( * __ctype_b_loc ( ) ) [ ( unsigned __int8 ) * @@a1@@ ] & Number ) == Number ) return Number ; ++ @@a1@@ ; } return * @@a1@@ == Number ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
_BOOL8 __fastcall c_isalnum ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number || ( int ) ( @@a1@@ & Number ) > Number && ( int ) ( @@a1@@ & Number ) <= Number ; }
bool __fastcall is_prime ( unsigned __int64 @@a1@@ ) { unsigned __int64 @@v2@@ ; unsigned __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; @@v2@@ = Number L ; @@v4@@ = Number L ; while ( @@v4@@ < @@a1@@ && @@a1@@ % @@v2@@ ) { @@v3@@ = @@v2@@ + Number ; @@v4@@ += Number * @@v3@@ ; @@v2@@ = @@v3@@ + Number ; } return @@a1@@ % @@v2@@ != Number ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
_BOOL8 __fastcall c_isgraph ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
_BOOL8 __fastcall c_isxdigit ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number || ( int ) ( @@a1@@ & Number ) > Number && ( int ) ( @@a1@@ & Number ) <= Number ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
size_t * __fastcall hash_initialize ( __int64 @@a1@@ , void * @@a2@@ , unsigned __int64 ( __fastcall * @@a3@@ ) ( __int64 a1 , unsigned __int64 a2 ) , bool ( __fastcall * @@a4@@ ) ( __int64 a1 , __int64 a2 ) , size_t @@a5@@ ) { size_t * @@result@@ ; bool ( __fastcall * @@v7@@ ) ( __int64 , __int64 ) ; unsigned __int64 ( __fastcall * @@v8@@ ) ( __int64 , unsigned __int64 ) ; void * @@v9@@ ; size_t * @@ptr@@ ; @@v9@@ = @@a2@@ ; @@v8@@ = @@a3@@ ; @@v7@@ = @@a4@@ ; if ( ! @@a3@@ ) @@v8@@ = raw_hasher ; if ( ! @@a4@@ ) @@v7@@ = raw_comparator ; @@ptr@@ = ( size_t * ) malloc ( Number ) ; if ( ! @@ptr@@ ) return Number L ; if ( ! @@a2@@ ) @@v9@@ = & default_tuning ; @@ptr@@ [ Number ] = ( size_t ) @@v9@@ ; if ( ( unsigned __int8 ) check_tuning ( ( __int64 ) @@ptr@@ ) == Number && ( @@ptr@@ [ Number ] = compute_bucket_size ( @@a1@@ , ( __int64 ) @@v9@@ ) ) != Number && ( * @@ptr@@ = ( size_t ) calloc ( @@ptr@@ [ Number ] , Number ) ) != Number ) { @@ptr@@ [ Number ] = Number * @@ptr@@ [ Number ] + * @@ptr@@ ; @@ptr@@ [ Number ] = Number L ; @@ptr@@ [ Number ] = Number L ; @@ptr@@ [ Number ] = ( size_t ) @@v8@@ ; @@ptr@@ [ Number ] = ( size_t ) @@v7@@ ; @@ptr@@ [ Number ] = @@a5@@ ; @@ptr@@ [ Number ] = Number L ; @@result@@ = @@ptr@@ ; } else { free ( @@ptr@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) _frame_dummy_init_array_entry [ @@i@@ ] ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
int ferror ( FILE * @@stream@@ ) { return ferror ( @@stream@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
__int64 __fastcall i_ring_init ( __int64 @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; int @@i@@ ; * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; * ( _DWORD * ) ( @@a1@@ + Number ) = Number ; * ( _DWORD * ) ( @@a1@@ + Number ) = Number ; for ( @@i@@ = Number ; @@i@@ <= Number ; ++ @@i@@ ) * ( _DWORD * ) ( @@a1@@ + Number L * @@i@@ ) = @@a2@@ ; @@result@@ = @@a1@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
int fgetc ( FILE * @@stream@@ ) { return fgetc ( @@stream@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_206028 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
DIR * __fastcall opendir_safer ( const char * @@a1@@ ) { int @@v2@@ ; int @@fd@@ ; int @@v4@@ ; DIR * @@dirp@@ ; DIR * @@v6@@ ; @@dirp@@ = opendir ( @@a1@@ ) ; if ( @@dirp@@ ) { @@v2@@ = dirfd ( @@dirp@@ ) ; if ( @@v2@@ >= Number && @@v2@@ <= Number ) { @@fd@@ = dup_safer ( ( unsigned int ) @@v2@@ ) ; @@v6@@ = fdopendir ( @@fd@@ ) ; @@v4@@ = * __errno_location ( ) ; if ( ! @@v6@@ ) close ( @@fd@@ ) ; closedir ( @@dirp@@ ) ; * __errno_location ( ) = @@v4@@ ; @@dirp@@ = @@v6@@ ; } } return @@dirp@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return xmalloc ( @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
unsigned __int64 __fastcall lcm ( unsigned __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return @@a1@@ * ( @@a2@@ / gcd ( @@a1@@ , @@a2@@ ) ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
unsigned __int64 __fastcall print_char ( unsigned __int64 @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int8 * @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { unsigned __int8 * @@v6@@ ; unsigned __int64 @@result@@ ; char @@v8@@ ; int @@v9@@ ; int @@v12@@ ; int @@v13@@ ; unsigned __int64 @@i@@ ; @@v9@@ = @@a6@@ ; @@v12@@ = @@a6@@ ; for ( @@i@@ = @@a1@@ ; ; -- @@i@@ ) { @@result@@ = @@a2@@ ; if ( @@a2@@ >= @@i@@ ) break ; @@v13@@ = ( @@i@@ - Number ) * @@v9@@ / @@a1@@ ; @@v6@@ = @@a3@@ ++ ; xprintf ( @@a4@@ , @@a5@@ + @@v12@@ - @@v13@@ , * @@v6@@ , @@a5@@ + @@v12@@ - @@v13@@ , @@a5@@ , @@a6@@ , @@v8@@ ) ; @@v12@@ = @@v13@@ ; } return @@result@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
size_t __fastcall rpl_vfprintf ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { size_t @@result@@ ; size_t @@v4@@ ; int @@v5@@ ; size_t @@v6@@ ; void * @@ptr@@ ; size_t @@n@@ ; char @@v9@@ [ Number ] ; unsigned __int64 @@v10@@ ; @@v10@@ = __readfsqword ( Number ) ; @@v6@@ = Number L ; @@ptr@@ = ( void * ) vasnprintf ( @@v9@@ , & @@v6@@ , @@a2@@ , @@a3@@ ) ; @@n@@ = @@v6@@ ; if ( @@ptr@@ ) { @@v4@@ = fwrite ( @@ptr@@ , Number , @@n@@ , @@a1@@ ) ; if ( @@n@@ <= @@v4@@ ) { if ( @@ptr@@ != @@v9@@ ) free ( @@ptr@@ ) ; if ( @@n@@ <= Number ) { @@result@@ = @@n@@ ; } else { * __errno_location ( ) = Number ; fseterr ( @@a1@@ ) ; @@result@@ = Number ; } } else { if ( @@ptr@@ != @@v9@@ ) { @@v5@@ = * __errno_location ( ) ; free ( @@ptr@@ ) ; * __errno_location ( ) = @@v5@@ ; } @@result@@ = Number ; } } else { fseterr ( @@a1@@ ) ; @@result@@ = Number ; } return @@result@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
unsigned __int64 __fastcall print_long ( unsigned __int64 @@a1@@ , unsigned __int64 @@a2@@ , _QWORD * @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { _QWORD * @@v6@@ ; unsigned __int64 @@result@@ ; char @@v8@@ ; int @@v9@@ ; int @@v12@@ ; int @@v13@@ ; unsigned __int64 @@i@@ ; @@v9@@ = @@a6@@ ; @@v12@@ = @@a6@@ ; for ( @@i@@ = @@a1@@ ; ; -- @@i@@ ) { @@result@@ = @@a2@@ ; if ( @@a2@@ >= @@i@@ ) break ; @@v13@@ = ( @@i@@ - Number ) * @@v9@@ / @@a1@@ ; @@v6@@ = @@a3@@ ++ ; xprintf ( @@a4@@ , @@a5@@ + @@v12@@ - @@v13@@ , * @@v6@@ , @@a5@@ + @@v12@@ - @@v13@@ , @@a5@@ , @@a6@@ , @@v8@@ ) ; @@v12@@ = @@v13@@ ; } return @@result@@ ; }
void * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * @@v4@@ ; void * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * @@v12@@ ; void * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == ( __int64 * ) & slotvec0 ; if ( slotvec == ( __int64 * ) & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = off_210028 ; * @@v12@@ = ( __int64 ) slotvec0 ; @@v12@@ [ Number ] = ( __int64 ) @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = ( void * ) @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = @@v17@@ + Number ; if ( @@ptr@@ != & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( void * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = ( __int64 ) @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
int putchar_unlocked ( int @@c@@ ) { return putchar_unlocked ( @@c@@ ) ; }
unsigned __int64 __fastcall print_long_double ( unsigned __int64 @@a1@@ , unsigned __int64 @@a2@@ , long double * @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { long double * @@v6@@ ; unsigned __int64 @@result@@ ; int @@v8@@ ; int @@v11@@ ; int @@v12@@ ; unsigned __int64 @@i@@ ; @@v8@@ = @@a6@@ ; @@v11@@ = @@a6@@ ; for ( @@i@@ = @@a1@@ ; ; -- @@i@@ ) { @@result@@ = @@a2@@ ; if ( @@a2@@ >= @@i@@ ) break ; @@v12@@ = ( @@i@@ - Number ) * @@v8@@ / @@a1@@ ; @@v6@@ = @@a3@@ ++ ; xprintf ( @@a4@@ , @@a5@@ + @@v11@@ - @@v12@@ , @@a5@@ + @@v11@@ - @@v12@@ , @@a4@@ , @@a5@@ , @@a6@@ , * @@v6@@ ) ; @@v11@@ = @@v12@@ ; } return @@result@@ ; }
_DWORD * __fastcall sha1_finish_ctx ( _DWORD * @@a1@@ , _DWORD * @@a2@@ ) { __int64 @@v2@@ ; unsigned int @@v4@@ ; __int64 @@v5@@ ; @@v4@@ = @@a1@@ [ Number ] ; if ( @@v4@@ > Number ) @@v2@@ = Number L ; else @@v2@@ = Number L ; @@v5@@ = @@v2@@ ; @@a1@@ [ Number ] += @@v4@@ ; if ( @@v4@@ > @@a1@@ [ Number ] ) ++ @@a1@@ [ Number ] ; @@a1@@ [ @@v2@@ + Number ] = ( ( unsigned int ) ( * ( __int64 * ) ( @@a1@@ + Number ) >> Number ) >> Number ) & Number | ( ( unsigned int ) ( * ( __int64 * ) ( @@a1@@ + Number ) >> Number ) << Number ) & Number | ( ( unsigned int ) ( * ( __int64 * ) ( @@a1@@ + Number ) >> Number ) << Number ) | ( ( unsigned int ) ( * ( __int64 * ) ( @@a1@@ + Number ) >> Number ) >> Number ) ; @@a1@@ [ @@v2@@ + Number ] = ( ( unsigned int ) ( Number * @@a1@@ [ Number ] ) >> Number ) & Number | ( @@a1@@ [ Number ] << Number ) & Number | ( @@a1@@ [ Number ] << Number ) | ( ( unsigned int ) ( Number * @@a1@@ [ Number ] ) >> Number ) ; memcpy ( ( char * ) @@a1@@ + @@v4@@ + Number , & fillbuf , Number * @@v2@@ - @@v4@@ - Number ) ; sha1_process_block ( @@a1@@ + Number , Number * @@v5@@ , @@a1@@ ) ; return sha1_read_ctx ( @@a1@@ , @@a2@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
__int64 decimal_point_char ( ) { __int64 @@result@@ ; char * @@v1@@ ; @@v1@@ = nl_langinfo ( Number ) ; if ( * @@v1@@ ) @@result@@ = ( unsigned __int8 ) * @@v1@@ ; else @@result@@ = Number L ; return @@result@@ ; }
void * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_210108 ; @@v8@@ [ Number ] = qword_210110 ; @@v8@@ [ Number ] = qword_210118 ; @@v8@@ [ Number ] = qword_210120 ; @@v8@@ [ Number ] = qword_210128 ; @@v8@@ [ Number ] = qword_210130 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
unsigned __int64 __fastcall format_address_std ( unsigned __int64 @@a1@@ , char @@a2@@ ) { char * @@s@@ ; char * @@v5@@ ; _BYTE @@v6@@ [ Number ] ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v6@@ [ Number ] = Number ; @@s@@ = @@v6@@ ; @@v6@@ [ Number ] = @@a2@@ ; @@v5@@ = & @@v6@@ [ - address_pad_len ] ; switch ( address_base ) { case Number : do { * -- @@s@@ = @@a1@@ % Number + Number ; @@a1@@ /= Number ; } while ( @@a1@@ ) ; break ; case Number : do { * -- @@s@@ = a0123456789abcd [ @@a1@@ & Number ] ; @@a1@@ >>= Number ; } while ( @@a1@@ ) ; break ; case Number : do { * -- @@s@@ = ( @@a1@@ & Number ) + Number ; @@a1@@ >>= Number ; } while ( @@a1@@ ) ; break ; } while ( @@v5@@ < @@s@@ ) * -- @@s@@ = Number ; fputs_unlocked ( @@s@@ , stdout ) ; return __readfsqword ( Number ) ^ @@v7@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
_BOOL8 __fastcall rpl_isnanl ( __int64 a1 , __int64 a2 , __int64 a3 , __int64 a4 , __int64 a5 , __int64 a6 , __int128 @@a7@@ ) { if ( ( WORD4 ( @@a7@@ ) & Number ) == Number ) return DWORD1 ( @@a7@@ ) >> Number ; if ( ( WORD4 ( @@a7@@ ) & Number ) == Number ) return ( DWORD1 ( @@a7@@ ) ^ Number | ( unsigned int ) @@a7@@ ) != Number ; return ( DWORD1 ( @@a7@@ ) & Number ) == Number ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
bool __fastcall parse_old_offset ( char * @@a1@@ , __int64 @@a2@@ ) { char * @@s@@ ; unsigned int @@v4@@ ; @@s@@ = @@a1@@ ; if ( ! * @@a1@@ ) return Number ; if ( * @@a1@@ == Number ) @@s@@ = @@a1@@ + Number ; if ( strchr ( @@s@@ , Number ) ) { @@v4@@ = Number ; } else if ( * @@s@@ == Number && ( @@s@@ [ Number ] == Number || @@s@@ [ Number ] == Number ) ) { @@v4@@ = Number ; } else { @@v4@@ = Number ; } return ( unsigned int ) xstrtoumax ( @@s@@ , Number L , @@v4@@ , @@a2@@ , & off_EF09 ) == Number ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( is_mul_ok ( @@a2@@ , * @@a1@@ ) ) { * @@a1@@ *= @@a2@@ ; @@result@@ = Number L ; } else { * @@a1@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
__int64 __fastcall rpl_fcntl ( int @@a1@@ , int @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , __m128 @@a7@@ , __m128 @@a8@@ , __m128 @@a9@@ , __m128 @@a10@@ , __m128 @@a11@@ , __m128 @@a12@@ , __m128 @@a13@@ , __m128 @@a14@@ ) { int @@v14@@ ; int @@v15@@ ; int @@v16@@ ; int @@v18@@ ; int @@v19@@ ; int @@v20@@ ; int @@v21@@ ; __int64 @@v22@@ ; __int64 @@v23@@ ; __int64 @@v24@@ ; __int64 @@v25@@ ; __m128 @@v26@@ ; __m128 @@v27@@ ; __m128 @@v28@@ ; __m128 @@v29@@ ; __m128 @@v30@@ ; __m128 @@v31@@ ; __m128 @@v32@@ ; __m128 @@v33@@ ; @@v22@@ = @@a3@@ ; @@v23@@ = @@a4@@ ; @@v24@@ = @@a5@@ ; @@v25@@ = @@a6@@ ; @@v26@@ = @@a7@@ ; @@v27@@ = @@a8@@ ; @@v28@@ = @@a9@@ ; @@v29@@ = @@a10@@ ; @@v30@@ = @@a11@@ ; @@v31@@ = @@a12@@ ; @@v32@@ = @@a13@@ ; @@v33@@ = @@a14@@ ; if ( @@a2@@ != Number ) return ( unsigned int ) fcntl ( @@a1@@ , @@a2@@ , @@v22@@ ) ; @@v19@@ = @@v22@@ ; if ( have_dupfd_cloexec_2895 < Number ) { @@v18@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v22@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; } else { @@v18@@ = fcntl ( @@a1@@ , Number , ( unsigned int ) @@v22@@ ) ; if ( @@v18@@ < Number && * __errno_location ( ) == Number ) { @@v18@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v19@@ , @@v14@@ , @@v15@@ , @@v16@@ ) ; if ( @@v18@@ < Number ) return ( unsigned int ) @@v18@@ ; have_dupfd_cloexec_2895 = Number ; } else { have_dupfd_cloexec_2895 = Number ; } } if ( @@v18@@ >= Number && have_dupfd_cloexec_2895 == Number ) { @@v20@@ = fcntl ( @@v18@@ , Number ) ; if ( @@v20@@ < Number || fcntl ( @@v18@@ , Number , @@v20@@ | Number ) == Number ) { @@v21@@ = * __errno_location ( ) ; close ( @@v18@@ ) ; * __errno_location ( ) = @@v21@@ ; @@v18@@ = Number ; } } return ( unsigned int ) @@v18@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
__int64 __fastcall dup_cloexec ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
bool __fastcall is_zero_or_power_of_two ( __int64 @@a1@@ ) { return ( @@a1@@ & ( @@a1@@ - Number ) ) == Number ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; char * @@v3@@ ; FILE * @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; char * @@v10@@ ; @@v1@@ = program_name ; if ( @@a1@@ ) { @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = gettext ( String String String String ) ; printf ( @@v3@@ , @@v1@@ ) ; @@v4@@ = stdout ; @@v5@@ = gettext ( String ) ; fputs_unlocked ( @@v5@@ , @@v4@@ ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; @@v8@@ = stdout ; @@v9@@ = gettext ( String ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = gettext ( String String String String ) ; printf ( @@v10@@ , String ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
__int64 __fastcall rpl_fcntl ( int @@a1@@ , int @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , __m128 @@a7@@ , __m128 @@a8@@ , __m128 @@a9@@ , __m128 @@a10@@ , __m128 @@a11@@ , __m128 @@a12@@ , __m128 @@a13@@ , __m128 @@a14@@ ) { int @@v14@@ ; int @@v15@@ ; int @@v16@@ ; int @@v18@@ ; int @@v19@@ ; int @@v20@@ ; int @@v21@@ ; __int64 @@v22@@ ; __int64 @@v23@@ ; __int64 @@v24@@ ; __int64 @@v25@@ ; __m128 @@v26@@ ; __m128 @@v27@@ ; __m128 @@v28@@ ; __m128 @@v29@@ ; __m128 @@v30@@ ; __m128 @@v31@@ ; __m128 @@v32@@ ; __m128 @@v33@@ ; @@v22@@ = @@a3@@ ; @@v23@@ = @@a4@@ ; @@v24@@ = @@a5@@ ; @@v25@@ = @@a6@@ ; @@v26@@ = @@a7@@ ; @@v27@@ = @@a8@@ ; @@v28@@ = @@a9@@ ; @@v29@@ = @@a10@@ ; @@v30@@ = @@a11@@ ; @@v31@@ = @@a12@@ ; @@v32@@ = @@a13@@ ; @@v33@@ = @@a14@@ ; if ( @@a2@@ != Number ) return ( unsigned int ) fcntl ( @@a1@@ , @@a2@@ , @@v22@@ ) ; @@v19@@ = @@v22@@ ; if ( have_dupfd_cloexec_2895 < Number ) { @@v18@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v22@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; } else { @@v18@@ = fcntl ( @@a1@@ , Number , ( unsigned int ) @@v22@@ ) ; if ( @@v18@@ < Number && * __errno_location ( ) == Number ) { @@v18@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v19@@ , @@v14@@ , @@v15@@ , @@v16@@ ) ; if ( @@v18@@ < Number ) return ( unsigned int ) @@v18@@ ; have_dupfd_cloexec_2895 = Number ; } else { have_dupfd_cloexec_2895 = Number ; } } if ( @@v18@@ >= Number && have_dupfd_cloexec_2895 == Number ) { @@v20@@ = fcntl ( @@v18@@ , Number ) ; if ( @@v20@@ < Number || fcntl ( @@v18@@ , Number , @@v20@@ | Number ) == Number ) { @@v21@@ = * __errno_location ( ) ; close ( @@v18@@ ) ; * __errno_location ( ) = @@v21@@ ; @@v18@@ = Number ; } } return ( unsigned int ) @@v18@@ ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
void __fastcall freebuffer ( __int64 @@a1@@ ) { free ( * ( void * * ) ( @@a1@@ + Number ) ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
__int64 __fastcall memcmp2 ( const void * @@a1@@ , size_t @@a2@@ , const void * @@a3@@ , size_t @@a4@@ ) { size_t @@v4@@ ; size_t @@v6@@ ; unsigned int @@v7@@ ; @@v6@@ = @@a4@@ ; @@v4@@ = @@a4@@ ; if ( @@a2@@ <= @@a4@@ ) @@v4@@ = @@a2@@ ; @@v7@@ = memcmp ( @@a1@@ , @@a3@@ , @@v4@@ ) ; if ( ! @@v7@@ ) { if ( @@a2@@ >= @@v6@@ ) { if ( @@a2@@ > @@v6@@ ) @@v7@@ = Number ; } else { @@v7@@ = Number ; } } return @@v7@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_2070C8 ; @@v8@@ [ Number ] = qword_2070D0 ; @@v8@@ [ Number ] = qword_2070D8 ; @@v8@@ [ Number ] = qword_2070E0 ; @@v8@@ [ Number ] = qword_2070E8 ; @@v8@@ [ Number ] = qword_2070F0 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_212038 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_206028 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_212208 ; @@v8@@ [ Number ] = qword_212210 ; @@v8@@ [ Number ] = qword_212218 ; @@v8@@ [ Number ] = qword_212220 ; @@v8@@ [ Number ] = qword_212228 ; @@v8@@ [ Number ] = qword_212230 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_2060C8 ; @@v4@@ [ Number ] = qword_2060D0 ; @@v4@@ [ Number ] = qword_2060D8 ; @@v4@@ [ Number ] = qword_2060E0 ; @@v4@@ [ Number ] = qword_2060E8 ; @@v4@@ [ Number ] = qword_2060F0 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ ) { return xmalloc ( @@a1@@ ) ; }
int clock_gettime ( clockid_t @@clock_id@@ , struct timespec * @@tp@@ ) { return clock_gettime ( @@clock_id@@ , @@tp@@ ) ; }
__int64 __fastcall hard_locale ( int @@a1@@ ) { unsigned __int8 @@v2@@ ; const char * @@s1@@ ; @@v2@@ = Number ; @@s1@@ = setlocale ( @@a1@@ , Number L ) ; if ( @@s1@@ && ( ! strcmp ( @@s1@@ , String ) || ! strcmp ( @@s1@@ , String ) ) ) @@v2@@ = Number ; return @@v2@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
int __fxstat ( int @@ver@@ , int @@fildes@@ , struct stat * @@stat_buf@@ ) { return _fxstat ( @@ver@@ , @@fildes@@ , @@stat_buf@@ ) ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
_BOOL8 __fastcall input_numbers_option_used ( __int64 @@a1@@ , __int64 @@a2@@ ) { return @@a1@@ != Number || @@a2@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall xsum ( unsigned __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; if ( @@a1@@ + @@a2@@ < @@a1@@ ) @@result@@ = Number ; else @@result@@ = @@a1@@ + @@a2@@ ; return @@result@@ ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_2060C8 ; @@v8@@ [ Number ] = qword_2060D0 ; @@v8@@ [ Number ] = qword_2060D8 ; @@v8@@ [ Number ] = qword_2060E0 ; @@v8@@ [ Number ] = qword_2060E8 ; @@v8@@ [ Number ] = qword_2060F0 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
_BOOL8 __fastcall is_infinite_or_zerol ( long double @@a1@@ ) { return ( unsigned int ) rpl_isnanl ( * ( _TBYTE * ) & @@a1@@ ) || @@a1@@ == @@a1@@ + @@a1@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) _frame_dummy_init_array_entry [ @@i@@ ] ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
unsigned __int64 __fastcall read_input ( FILE * @@a1@@ , char @@a2@@ , __int64 * * @@a3@@ ) { int @@v3@@ ; unsigned __int64 @@v4@@ ; __int64 @@v5@@ ; int @@v8@@ ; char * @@i@@ ; char * @@v10@@ ; __int64 @@v11@@ ; unsigned __int64 @@v12@@ ; __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; unsigned __int64 @@j@@ ; unsigned __int64 @@v16@@ ; __off_t @@v17@@ ; __off_t @@v18@@ ; __int64 @@n@@ ; size_t @@v20@@ ; unsigned __int64 @@v21@@ ; __int64 * @@v22@@ ; struct stat @@stat_buf@@ ; unsigned __int64 @@v24@@ ; @@v24@@ = __readfsqword ( Number ) ; @@v11@@ = Number L ; @@v12@@ = Number L ; @@v13@@ = Number L ; @@v14@@ = Number L ; @@v3@@ = fileno ( @@a1@@ ) ; if ( ! ( unsigned int ) fstat ( @@v3@@ , & @@stat_buf@@ ) && ( @@stat_buf@@ . st_mode & Number ) == Number ) { @@v17@@ = @@stat_buf@@ . st_size ; @@v18@@ = ftello ( @@a1@@ ) ; if ( @@v18@@ >= Number ) { if ( @@v18@@ >= @@v17@@ ) @@v4@@ = Number L ; else @@v4@@ = @@v17@@ - @@v18@@ ; if ( @@v4@@ > Number ) xalloc_die ( ) ; @@v14@@ = @@v4@@ + Number ; } } do { if ( @@v12@@ <= @@v13@@ + Number ) { if ( @@v12@@ == Number ) xalloc_die ( ) ; @@v12@@ = @@v14@@ ; @@v14@@ *= Number L ; if ( @@v14@@ < @@v12@@ ) @@v14@@ = Number ; @@v11@@ = xrealloc ( @@v11@@ , @@v12@@ ) ; } @@n@@ = @@v12@@ - @@v13@@ - Number ; @@v20@@ = fread_unlocked ( ( void * ) ( @@v11@@ + @@v13@@ ) , Number , @@n@@ , @@a1@@ ) ; @@v13@@ += @@v20@@ ; } while ( @@v20@@ == @@n@@ ) ; @@v8@@ = * __errno_location ( ) ; if ( @@v13@@ && @@a2@@ != * ( _BYTE * ) ( @@v13@@ - Number + @@v11@@ ) ) { @@v5@@ = @@v13@@ ++ ; * ( _BYTE * ) ( @@v5@@ + @@v11@@ ) = @@a2@@ ; } @@v21@@ = @@v11@@ + @@v13@@ ; @@v16@@ = Number L ; for ( @@i@@ = ( char * ) @@v11@@ ; ( unsigned __int64 ) @@i@@ < @@v21@@ ; @@i@@ = next_line ( @@i@@ , @@a2@@ , @@v21@@ - ( _QWORD ) @@i@@ ) ) { ++ @@v16@@ ; } @@v22@@ = ( __int64 * ) xnmalloc ( @@v16@@ + Number , Number L ) ; * @@a3@@ = @@v22@@ ; @@v10@@ = ( char * ) @@v11@@ ; * @@v22@@ = @@v11@@ ; for ( @@j@@ = Number L ; @@j@@ <= @@v16@@ ; ++ @@j@@ ) { @@v10@@ = next_line ( @@v10@@ , @@a2@@ , @@v21@@ - ( _QWORD ) @@v10@@ ) ; @@v22@@ [ @@j@@ ] = ( __int64 ) @@v10@@ ; } * __errno_location ( ) = @@v8@@ ; return @@v16@@ ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
__int64 __fastcall shift_left ( __int64 @@a1@@ ) { return @@a1@@ << Number ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
int getc_unlocked ( FILE * @@stream@@ ) { return getc_unlocked ( @@stream@@ ) ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
unsigned __int64 __fastcall randint_choose ( __int64 * @@a1@@ , __int64 @@a2@@ ) { return randint_genmax ( @@a1@@ , @@a2@@ - Number ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
int feof_unlocked ( FILE * @@stream@@ ) { return feof_unlocked ( @@stream@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
unsigned __int64 __fastcall randperm_bound ( __int64 @@a1@@ , __int64 @@a2@@ ) { return ( unsigned __int64 ) ( @@a1@@ * ceil_lg ( @@a2@@ ) + Number ) >> Number ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 __fastcall check_order ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned int @@a3@@ ) { __int64 @@result@@ ; __int64 @@v4@@ ; char * @@v5@@ ; @@result@@ = ( unsigned int ) check_input_order ; if ( check_input_order != Number ) { if ( check_input_order == Number || ( @@result@@ = ( unsigned __int8 ) seen_unpairable , seen_unpairable ) ) { @@v4@@ = ( int ) ( @@a3@@ - Number ) ; @@result@@ = ( unsigned __int8 ) issued_disorder_warning [ @@v4@@ ] ^ Number ; if ( issued_disorder_warning [ @@v4@@ ] != Number ) { if ( hard_LC_COLLATE ) @@result@@ = xmemcoll ( * ( _QWORD * ) ( @@a1@@ + Number ) , * ( _QWORD * ) ( @@a1@@ + Number ) - Number L , * ( _QWORD * ) ( @@a2@@ + Number ) , * ( _QWORD * ) ( @@a2@@ + Number ) - Number L ) ; else @@result@@ = memcmp2 ( * ( _QWORD * ) ( @@a1@@ + Number ) , * ( _QWORD * ) ( @@a1@@ + Number ) - Number L , * ( _QWORD * ) ( @@a2@@ + Number ) , * ( _QWORD * ) ( @@a2@@ + Number ) - Number L ) ; if ( ( int ) @@result@@ > Number ) { @@v5@@ = gettext ( String ) ; error ( check_input_order == Number , Number , @@v5@@ , @@a3@@ ) ; @@result@@ = ( __int64 ) issued_disorder_warning ; issued_disorder_warning [ @@a3@@ - Number ] = Number ; } } } } return @@result@@ ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
int puts ( const char * @@s@@ ) { return puts ( @@s@@ ) ; }
void __fastcall __noreturn randread_error ( __int64 @@a1@@ ) { __int64 @@v1@@ ; const char * @@v2@@ ; char * @@v3@@ ; int * @@v4@@ ; if ( @@a1@@ ) { @@v1@@ = quotearg_colon ( @@a1@@ ) ; if ( * __errno_location ( ) ) @@v2@@ = String ; else @@v2@@ = String ; @@v3@@ = gettext ( @@v2@@ ) ; @@v4@@ = __errno_location ( ) ; error ( exit_failure , * @@v4@@ , @@v3@@ , @@v1@@ ) ; } abort ( ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
int putchar_unlocked ( int @@c@@ ) { return putchar_unlocked ( @@c@@ ) ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
size_t __fastcall readsource ( __int64 @@a1@@ , char * @@a2@@ , size_t @@a3@@ ) { size_t @@result@@ ; int @@v4@@ ; int @@v7@@ ; size_t @@v8@@ ; while ( Number ) { @@v8@@ = fread_unlocked ( @@a2@@ , Number , @@a3@@ , * ( FILE * * ) @@a1@@ ) ; @@v7@@ = * __errno_location ( ) ; @@a2@@ += @@v8@@ ; @@result@@ = @@v8@@ ; @@a3@@ -= @@v8@@ ; if ( ! @@a3@@ ) break ; if ( ferror_unlocked ( * ( FILE * * ) @@a1@@ ) ) @@v4@@ = @@v7@@ ; else @@v4@@ = Number ; * __errno_location ( ) = @@v4@@ ; ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@a1@@ + Number ) ) ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ; } return @@result@@ ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
int __fastcall randread_free ( FILE * * @@a1@@ ) { int @@result@@ ; FILE * @@stream@@ ; @@stream@@ = * @@a1@@ ; memset ( @@a1@@ , Number , Number ) ; free ( @@a1@@ ) ; if ( @@stream@@ ) @@result@@ = fclose ( @@stream@@ ) ; else @@result@@ = Number ; return @@result@@ ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
__int64 __fastcall bsd_split_3 ( __int64 @@a1@@ , __int64 @@a2@@ , _QWORD * @@a3@@ , _QWORD * @@a4@@ ) { __int64 @@v5@@ ; __int64 @@i@@ ; __int64 @@v7@@ ; __int64 @@j@@ ; if ( ! @@a2@@ ) return Number L ; * @@a4@@ = @@a1@@ ; for ( @@i@@ = @@a2@@ - Number ; @@i@@ && * ( _BYTE * ) ( @@a1@@ + @@i@@ ) != Number ; -- @@i@@ ) { ; } if ( * ( _BYTE * ) ( @@a1@@ + @@i@@ ) != Number ) return Number L ; @@v5@@ = @@i@@ ; @@v7@@ = @@i@@ + Number ; * ( _BYTE * ) ( @@a1@@ + @@v5@@ ) = Number ; while ( * ( _BYTE * ) ( @@a1@@ + @@v7@@ ) == Number || * ( _BYTE * ) ( @@a1@@ + @@v7@@ ) == Number ) ++ @@v7@@ ; if ( * ( _BYTE * ) ( @@a1@@ + @@v7@@ ) != Number ) return Number L ; for ( @@j@@ = @@v7@@ + Number ; * ( _BYTE * ) ( @@a1@@ + @@j@@ ) == Number || * ( _BYTE * ) ( @@a1@@ + @@j@@ ) == Number ; ++ @@j@@ ) { ; } * @@a3@@ = @@j@@ + @@a1@@ ; return Number L ; }
__int64 __fastcall dc_parse_file ( const char * @@a1@@ ) { int * @@v1@@ ; __int64 @@result@@ ; __int64 @@v3@@ ; int * @@v4@@ ; unsigned __int8 @@v5@@ ; if ( ! strcmp ( @@a1@@ , String ) || freopen_safer ( @@a1@@ , String , stdin ) ) { @@v5@@ = dc_parse_stream ( stdin , ( __int64 ) @@a1@@ ) ; if ( fclose ( stdin ) ) { @@v3@@ = quote ( @@a1@@ ) ; @@v4@@ = __errno_location ( ) ; error ( Number , * @@v4@@ , format , @@v3@@ ) ; @@result@@ = Number L ; } else { @@result@@ = @@v5@@ ; } } else { @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , format , @@a1@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
char * __fastcall xstrndup ( const char * @@a1@@ , size_t @@a2@@ ) { char * @@v3@@ ; @@v3@@ = strndup ( @@a1@@ , @@a2@@ ) ; if ( ! @@v3@@ ) xalloc_die ( @@a1@@ , @@a2@@ ) ; return @@v3@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall protect_fd ( int @@a1@@ ) { int @@fd@@ ; @@fd@@ = open ( String , Number ) ; if ( @@fd@@ == @@a1@@ ) return Number L ; if ( @@fd@@ >= Number ) { close ( @@fd@@ ) ; * __errno_location ( ) = Number ; } return Number L ; }
__int64 __fastcall protect_fd ( int @@a1@@ ) { int @@fd@@ ; @@fd@@ = open ( String , Number ) ; if ( @@fd@@ == @@a1@@ ) return Number L ; if ( @@fd@@ >= Number ) { close ( @@fd@@ ) ; * __errno_location ( ) = Number ; } return Number L ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall xtime_make ( __int64 @@a1@@ , __int64 @@a2@@ ) { return Number * @@a1@@ + @@a2@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 gethrxtime ( ) { struct timespec @@tp@@ ; unsigned __int64 @@v2@@ ; @@v2@@ = __readfsqword ( Number ) ; if ( clock_gettime ( Number , & @@tp@@ ) ) gettime ( & @@tp@@ ) ; return xtime_make ( @@tp@@ . tv_sec , @@tp@@ . tv_nsec ) ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_2070C8 ; @@v4@@ [ Number ] = qword_2070D0 ; @@v4@@ [ Number ] = qword_2070D8 ; @@v4@@ [ Number ] = qword_2070E0 ; @@v4@@ [ Number ] = qword_2070E8 ; @@v4@@ [ Number ] = qword_2070F0 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
__int64 __fastcall rpl_fcntl ( int @@a1@@ , int @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , __m128 @@a7@@ , __m128 @@a8@@ , __m128 @@a9@@ , __m128 @@a10@@ , __m128 @@a11@@ , __m128 @@a12@@ , __m128 @@a13@@ , __m128 @@a14@@ ) { int @@v14@@ ; int @@v15@@ ; int @@v16@@ ; int @@v18@@ ; int @@v19@@ ; int @@v20@@ ; int @@v21@@ ; __int64 @@v22@@ ; __int64 @@v23@@ ; __int64 @@v24@@ ; __int64 @@v25@@ ; __m128 @@v26@@ ; __m128 @@v27@@ ; __m128 @@v28@@ ; __m128 @@v29@@ ; __m128 @@v30@@ ; __m128 @@v31@@ ; __m128 @@v32@@ ; __m128 @@v33@@ ; @@v22@@ = @@a3@@ ; @@v23@@ = @@a4@@ ; @@v24@@ = @@a5@@ ; @@v25@@ = @@a6@@ ; @@v26@@ = @@a7@@ ; @@v27@@ = @@a8@@ ; @@v28@@ = @@a9@@ ; @@v29@@ = @@a10@@ ; @@v30@@ = @@a11@@ ; @@v31@@ = @@a12@@ ; @@v32@@ = @@a13@@ ; @@v33@@ = @@a14@@ ; if ( @@a2@@ != Number ) return ( unsigned int ) fcntl ( @@a1@@ , @@a2@@ , @@v22@@ ) ; @@v19@@ = @@v22@@ ; if ( have_dupfd_cloexec_2895 < Number ) { @@v18@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v22@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; } else { @@v18@@ = fcntl ( @@a1@@ , Number , ( unsigned int ) @@v22@@ ) ; if ( @@v18@@ < Number && * __errno_location ( ) == Number ) { @@v18@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v19@@ , @@v14@@ , @@v15@@ , @@v16@@ ) ; if ( @@v18@@ < Number ) return ( unsigned int ) @@v18@@ ; have_dupfd_cloexec_2895 = Number ; } else { have_dupfd_cloexec_2895 = Number ; } } if ( @@v18@@ >= Number && have_dupfd_cloexec_2895 == Number ) { @@v20@@ = fcntl ( @@v18@@ , Number ) ; if ( @@v20@@ < Number || fcntl ( @@v18@@ , Number , @@v20@@ | Number ) == Number ) { @@v21@@ = * __errno_location ( ) ; close ( @@v18@@ ) ; * __errno_location ( ) = @@v21@@ ; @@v18@@ = Number ; } } return ( unsigned int ) @@v18@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_20A028 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_20A0E8 ; @@v8@@ [ Number ] = qword_20A0F0 ; @@v8@@ [ Number ] = qword_20A0F8 ; @@v8@@ [ Number ] = qword_20A100 ; @@v8@@ [ Number ] = qword_20A108 ; @@v8@@ [ Number ] = qword_20A110 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
int fileno ( FILE * @@stream@@ ) { return fileno ( @@stream@@ ) ; }
int fileno ( FILE * @@stream@@ ) { return fileno ( @@stream@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_20A128 ; @@v4@@ [ Number ] = qword_20A130 ; @@v4@@ [ Number ] = qword_20A138 ; @@v4@@ [ Number ] = qword_20A140 ; @@v4@@ [ Number ] = qword_20A148 ; @@v4@@ [ Number ] = qword_20A150 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
__int64 __fastcall sha1_stream ( FILE * @@a1@@ , _DWORD * @@a2@@ ) { __int64 @@v3@@ ; char * @@ptr@@ ; size_t @@v5@@ ; _DWORD @@v6@@ [ Number ] ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@ptr@@ = ( char * ) malloc ( Number ) ; if ( ! @@ptr@@ ) return Number L ; sha1_init_ctx ( @@v6@@ ) ; LABEL_4 : @@v3@@ = Number L ; while ( Number ) { @@v5@@ = fread_unlocked ( & @@ptr@@ [ @@v3@@ ] , Number , Number - @@v3@@ , @@a1@@ ) ; @@v3@@ += @@v5@@ ; if ( @@v3@@ == Number ) { sha1_process_block ( @@ptr@@ , String , @@v6@@ ) ; goto LABEL_4 ; } if ( ! @@v5@@ ) break ; if ( feof_unlocked ( @@a1@@ ) ) goto LABEL_12 ; } if ( ferror_unlocked ( @@a1@@ ) ) { free ( @@ptr@@ ) ; return Number L ; } LABEL_12 : if ( @@v3@@ ) sha1_process_bytes ( @@ptr@@ , @@v3@@ , @@v6@@ ) ; sha1_finish_ctx ( @@v6@@ , @@a2@@ ) ; free ( @@ptr@@ ) ; return Number L ; }
char * __fastcall input_from_argv ( __int64 @@a1@@ , int @@a2@@ , char @@a3@@ ) { char * @@result@@ ; int @@i@@ ; int @@j@@ ; char * @@dest@@ ; __int64 @@v8@@ ; char * @@v9@@ ; @@v8@@ = @@a2@@ ; for ( @@i@@ = Number ; @@i@@ < @@a2@@ ; ++ @@i@@ ) @@v8@@ += strlen ( * ( const char * * ) ( Number L * @@i@@ + @@a1@@ ) ) ; @@dest@@ = ( char * ) xmalloc ( @@v8@@ ) ; for ( @@j@@ = Number ; @@j@@ < @@a2@@ ; ++ @@j@@ ) { @@v9@@ = stpcpy ( @@dest@@ , * ( const char * * ) ( Number L * @@j@@ + @@a1@@ ) ) ; * ( _QWORD * ) ( @@a1@@ + Number L * @@j@@ ) = @@dest@@ ; @@dest@@ = @@v9@@ + Number ; * @@v9@@ = @@a3@@ ; } @@result@@ = @@dest@@ ; * ( _QWORD * ) ( @@a1@@ + Number L * @@a2@@ ) = @@dest@@ ; return @@result@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ ) ; return @@ptr@@ ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
_QWORD * __fastcall randint_new ( __int64 @@a1@@ ) { _QWORD * @@result@@ ; @@result@@ = ( _QWORD * ) xmalloc ( Number L ) ; * @@result@@ = @@a1@@ ; @@result@@ [ Number ] = Number L ; @@result@@ [ Number ] = @@result@@ [ Number ] ; return @@result@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
_BOOL8 __fastcall c_islower ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
void __fastcall randint_free ( void * @@a1@@ ) { memset ( @@a1@@ , Number , Number ) ; free ( @@a1@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
_BOOL8 __fastcall c_isupper ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
__int64 __fastcall ceil_lg ( __int64 @@a1@@ ) { unsigned __int64 @@i@@ ; __int64 @@v3@@ ; @@v3@@ = Number L ; for ( @@i@@ = @@a1@@ - Number ; @@i@@ ; @@i@@ >>= Number ) ++ @@v3@@ ; return @@v3@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
int putchar_unlocked ( int @@c@@ ) { return putchar_unlocked ( @@c@@ ) ; }
_QWORD * __fastcall simple_new ( __int64 @@a1@@ , __int64 @@a2@@ ) { _QWORD * @@result@@ ; @@result@@ = ( _QWORD * ) xmalloc ( Number L ) ; * @@result@@ = @@a1@@ ; @@result@@ [ Number ] = randread_error ; @@result@@ [ Number ] = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ ) { return xmalloc ( @@a1@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( ) ; return @@ptr@@ ; }
FILE * __fastcall fopen_safer ( const char * @@a1@@ , const char * @@a2@@ ) { int @@v3@@ ; int @@fd@@ ; int @@v5@@ ; int @@v6@@ ; FILE * @@stream@@ ; @@stream@@ = fopen ( @@a1@@ , @@a2@@ ) ; if ( ! @@stream@@ ) return @@stream@@ ; @@v3@@ = fileno ( @@stream@@ ) ; if ( @@v3@@ < Number || @@v3@@ > Number ) return @@stream@@ ; @@fd@@ = dup_safer ( ( unsigned int ) @@v3@@ ) ; if ( @@fd@@ < Number ) { @@v6@@ = * __errno_location ( ) ; fclose ( @@stream@@ ) ; * __errno_location ( ) = @@v6@@ ; return Number L ; } if ( ! fclose ( @@stream@@ ) ) { @@stream@@ = fdopen ( @@fd@@ , @@a2@@ ) ; if ( @@stream@@ ) return @@stream@@ ; } @@v5@@ = * __errno_location ( ) ; close ( @@fd@@ ) ; * __errno_location ( ) = @@v5@@ ; return Number L ; }
size_t * __fastcall readisaac ( size_t * @@a1@@ , char * @@a2@@ , size_t @@a3@@ ) { size_t * @@result@@ ; size_t @@i@@ ; char * @@v7@@ ; for ( @@i@@ = * @@a1@@ ; @@a3@@ > @@i@@ ; @@i@@ = Number L ) { memcpy ( @@a2@@ , ( char * ) @@a1@@ + Number - @@i@@ + Number , @@i@@ ) ; @@a2@@ += @@i@@ ; @@a3@@ -= @@i@@ ; if ( ( ( unsigned __int8 ) @@a2@@ & Number ) == Number ) { @@v7@@ = @@a2@@ ; while ( @@a3@@ > Number ) { isaac_refill ( @@a1@@ + Number , @@v7@@ ) ; @@v7@@ += Number ; @@a3@@ -= Number L ; if ( ! @@a3@@ ) { @@result@@ = @@a1@@ ; * @@a1@@ = Number L ; return @@result@@ ; } } @@a2@@ = @@v7@@ ; } isaac_refill ( @@a1@@ + Number , ( char * ) @@a1@@ + Number ) ; } memcpy ( @@a2@@ , ( char * ) @@a1@@ + Number - @@i@@ + Number , @@a3@@ ) ; @@result@@ = @@a1@@ ; * @@a1@@ = @@i@@ - @@a3@@ ; return @@result@@ ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
unsigned __int64 __fastcall print_s_char ( unsigned __int64 @@a1@@ , unsigned __int64 @@a2@@ , char * @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { char * @@v6@@ ; unsigned __int64 @@result@@ ; char @@v8@@ ; int @@v9@@ ; int @@v12@@ ; int @@v13@@ ; unsigned __int64 @@i@@ ; @@v9@@ = @@a6@@ ; @@v12@@ = @@a6@@ ; for ( @@i@@ = @@a1@@ ; ; -- @@i@@ ) { @@result@@ = @@a2@@ ; if ( @@a2@@ >= @@i@@ ) break ; @@v13@@ = ( @@i@@ - Number ) * @@v9@@ / @@a1@@ ; @@v6@@ = @@a3@@ ++ ; xprintf ( @@a4@@ , @@a5@@ + @@v12@@ - @@v13@@ , * @@v6@@ , @@a5@@ + @@v12@@ - @@v13@@ , @@a5@@ , @@a6@@ , @@v8@@ ) ; @@v12@@ = @@v13@@ ; } return @@result@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
__int64 __fastcall dup_safer ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
int __fastcall fstat ( int @@fildes@@ , struct stat * @@stat_buf@@ ) { return __fxstat ( Number , @@fildes@@ , @@stat_buf@@ ) ; }
unsigned __int64 __fastcall print_int ( unsigned __int64 @@a1@@ , unsigned __int64 @@a2@@ , _DWORD * @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { _DWORD * @@v6@@ ; unsigned __int64 @@result@@ ; char @@v8@@ ; int @@v9@@ ; int @@v12@@ ; int @@v13@@ ; unsigned __int64 @@i@@ ; @@v9@@ = @@a6@@ ; @@v12@@ = @@a6@@ ; for ( @@i@@ = @@a1@@ ; ; -- @@i@@ ) { @@result@@ = @@a2@@ ; if ( @@a2@@ >= @@i@@ ) break ; @@v13@@ = ( @@i@@ - Number ) * @@v9@@ / @@a1@@ ; @@v6@@ = @@a3@@ ++ ; xprintf ( @@a4@@ , @@a5@@ + @@v12@@ - @@v13@@ , * @@v6@@ , @@a5@@ + @@v12@@ - @@v13@@ , @@a5@@ , @@a6@@ , @@v8@@ ) ; @@v12@@ = @@v13@@ ; } return @@result@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_20A028 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
unsigned __int64 __fastcall print_float ( unsigned __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { unsigned __int64 @@result@@ ; char @@v7@@ ; int @@v8@@ ; int @@v11@@ ; int @@v12@@ ; unsigned __int64 @@i@@ ; @@v8@@ = @@a6@@ ; @@v11@@ = @@a6@@ ; for ( @@i@@ = @@a1@@ ; ; -- @@i@@ ) { @@result@@ = @@a2@@ ; if ( @@a2@@ >= @@i@@ ) break ; @@v12@@ = ( @@i@@ - Number ) * @@v8@@ / @@a1@@ ; @@a3@@ += Number L ; xprintf ( @@a4@@ , @@a5@@ + @@v11@@ - @@v12@@ , @@a5@@ + @@v11@@ - @@v12@@ , @@a4@@ , @@a5@@ , @@a6@@ , @@v7@@ ) ; @@v11@@ = @@v12@@ ; } return @@result@@ ; }
int ferror ( FILE * @@stream@@ ) { return ferror ( @@stream@@ ) ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
_DWORD * __fastcall sha1_buffer ( __int64 @@a1@@ , __int64 @@a2@@ , _DWORD * @@a3@@ ) { _DWORD @@v5@@ [ Number ] ; unsigned __int64 @@v6@@ ; @@v6@@ = __readfsqword ( Number ) ; sha1_init_ctx ( @@v5@@ ) ; sha1_process_bytes ( @@a1@@ , @@a2@@ , @@v5@@ ) ; return sha1_finish_ctx ( @@v5@@ , @@a3@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall simple_strtoul ( char * @@a1@@ , char * * @@a2@@ , unsigned __int64 * @@a3@@ ) { char * @@v3@@ ; int @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = Number L ; while ( ( unsigned int ) ( * @@a1@@ - Number ) <= Number ) { @@v3@@ = @@a1@@ ++ ; @@v6@@ = * @@v3@@ - Number ; if ( @@v7@@ > ~ ( __int64 ) @@v6@@ / Number ) return Number L ; @@v7@@ = Number * @@v7@@ + @@v6@@ ; } * @@a2@@ = @@a1@@ ; * @@a3@@ = @@v7@@ ; return Number L ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return xmalloc ( @@a1@@ , @@a2@@ , @@a3@@ ) ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
__int64 __fastcall decode_format_string ( __int64 @@a1@@ ) { char * @@v2@@ ; char * @@v3@@ ; __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; @@v2@@ = ( char * ) @@a1@@ ; @@v5@@ = __readfsqword ( Number ) ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) __assert_fail ( String , String , Number , String ) ; while ( * @@v2@@ ) { if ( n_specs_allocated <= ( unsigned __int64 ) n_specs ) spec = x2nrealloc ( spec , & n_specs_allocated , Number L ) ; if ( ( unsigned __int8 ) decode_one_format ( @@v4@@ , @@v2@@ , & @@v3@@ , Number * n_specs + spec ) != Number ) return Number L ; if ( @@v2@@ == @@v3@@ ) __assert_fail ( String , String , Number , String ) ; @@v2@@ = @@v3@@ ; ++ n_specs ; } return Number L ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
_BYTE * __fastcall mark_printable_field ( unsigned __int64 @@a1@@ ) { _BYTE * @@result@@ ; @@result@@ = ( _BYTE * ) ( printable_field + ( @@a1@@ >> Number ) ) ; * @@result@@ |= Number << ( @@a1@@ & Number ) ; return @@result@@ ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_20A028 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
int __fastcall write_block ( __int64 @@a1@@ , __int64 @@a2@@ , const void * @@a3@@ , unsigned __int8 * @@a4@@ ) { int @@result@@ ; int @@v6@@ ; int @@v7@@ ; int @@v8@@ ; unsigned __int64 @@i@@ ; if ( abbreviate_duplicate_blocks && first_5993 != Number && @@a2@@ == bytes_per_block && ! memcmp ( @@a3@@ , @@a4@@ , bytes_per_block ) ) { @@result@@ = ( unsigned __int8 ) prev_pair_equal_5994 ; if ( ! prev_pair_equal_5994 ) { @@result@@ = puts ( String ) ; prev_pair_equal_5994 = Number ; } } else { prev_pair_equal_5994 = Number ; for ( @@i@@ = Number L ; ; ++ @@i@@ ) { @@result@@ = n_specs ; if ( @@i@@ >= n_specs ) break ; @@v6@@ = width_bytes [ * ( unsigned int * ) ( spec + Number * @@i@@ + Number ) ] ; @@v7@@ = bytes_per_block / @@v6@@ ; @@v8@@ = ( bytes_per_block - @@a2@@ ) / @@v6@@ ; if ( @@i@@ ) printf ( String , address_pad_len , & locale ) ; else format_address ( @@a1@@ , Number L ) ; ( * ( void ( __fastcall * * ) ( _QWORD , _QWORD , unsigned __int8 * , unsigned __int64 , _QWORD , _QWORD ) ) ( spec + Number * @@i@@ + Number ) ) ( @@v7@@ , @@v8@@ , @@a4@@ , spec + Number * @@i@@ + Number , * ( unsigned int * ) ( spec + Number * @@i@@ + Number ) , * ( unsigned int * ) ( spec + Number * @@i@@ + Number ) ) ; if ( * ( _BYTE * ) ( spec + Number * @@i@@ + Number ) ) { printf ( String , * ( _DWORD * ) ( spec + Number * @@i@@ + Number ) * @@v8@@ + @@v8@@ * * ( _DWORD * ) ( spec + Number * @@i@@ + Number ) / @@v7@@ , & locale ) ; dump_hexl_mode_trailer ( @@a2@@ , @@a4@@ ) ; } putchar_unlocked ( Number ) ; } } first_5993 = Number ; return @@result@@ ; }
bool __fastcall is_range_start_index ( __int64 @@a1@@ ) { return hash_lookup ( range_start_ht , @@a1@@ ) != Number ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_2060C8 ; @@v8@@ [ Number ] = qword_2060D0 ; @@v8@@ [ Number ] = qword_2060D8 ; @@v8@@ [ Number ] = qword_2060E0 ; @@v8@@ [ Number ] = qword_2060E8 ; @@v8@@ [ Number ] = qword_2060F0 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
__int64 __fastcall compare_ranges ( const void * @@a1@@ , const void * @@a2@@ ) { __int64 @@result@@ ; int @@v3@@ ; int @@v4@@ ; @@v3@@ = * ( _QWORD * ) @@a1@@ ; @@v4@@ = * ( _QWORD * ) @@a2@@ ; if ( @@v3@@ < @@v4@@ ) @@result@@ = Number ; else @@result@@ = @@v3@@ > @@v4@@ ; return @@result@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( is_mul_ok ( @@a2@@ , * @@a1@@ ) ) { * @@a1@@ *= @@a2@@ ; @@result@@ = Number L ; } else { * @@a1@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , off_FA5E , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
__int64 __fastcall xnrealloc ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { if ( ! is_mul_ok ( @@a3@@ , @@a2@@ ) ) xalloc_die ( ) ; return xrealloc ( @@a1@@ , @@a3@@ * @@a2@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
__int64 __fastcall hash_get_n_entries ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@v2@@ ; @@v2@@ = malloc ( @@a1@@ ) ; if ( ! @@v2@@ && @@a1@@ ) xalloc_die ( ) ; return @@v2@@ ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
int __cdecl __noreturn main ( int @@argc@@ , const char * * @@argv@@ , const char * * @@envp@@ ) { __int64 @@v3@@ ; __int64 @@v4@@ ; char * @@v5@@ ; char @@v6@@ ; const char * @@v7@@ ; bool @@v8@@ ; char @@v9@@ ; unsigned __int8 @@v10@@ ; int @@i@@ ; int @@v12@@ ; int @@v13@@ ; const char * * @@k@@ ; char * * @@j@@ ; char * @@v16@@ ; const char * @@v17@@ ; @@v9@@ = Number ; set_program_name ( * @@argv@@ , @@argv@@ , @@envp@@ ) ; setlocale ( Number , & locale ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; initialize_exit_failure ( Number ) ; atexit ( close_stdout ) ; while ( Number ) { @@v13@@ = getopt_long ( @@argc@@ , ( char * const * ) @@argv@@ , String , & longopts , Number L ) ; if ( @@v13@@ == Number ) break ; if ( @@v13@@ == Number ) usage ( Number ) ; if ( @@v13@@ != Number ) { if ( @@v13@@ != Number ) usage ( Number ) ; version_etc ( ( _DWORD ) stdout , ( unsigned int ) String , ( unsigned int ) String , ( _DWORD ) Version , ( unsigned int ) String , ( unsigned int ) String , Number ) ; exit ( Number ) ; } @@v9@@ = Number ; } if ( @@argc@@ > optind ) { @@v12@@ = Number ; for ( @@i@@ = optind ; @@i@@ < @@argc@@ ; ++ @@i@@ ) { @@v10@@ = Number ; if ( ! strchr ( @@argv@@ [ @@i@@ ] , Number ) ) { for ( @@j@@ = ( char * * ) environ ; * @@j@@ ; ++ @@j@@ ) { @@v16@@ = * @@j@@ ; @@v17@@ = @@argv@@ [ @@i@@ ] ; do { if ( * @@v16@@ ) { if ( * @@v17@@ ) { @@v5@@ = @@v16@@ ++ ; @@v6@@ = * @@v5@@ ; @@v7@@ = @@v17@@ ++ ; if ( @@v6@@ == * @@v7@@ ) continue ; } } goto LABEL_31 ; } while ( * @@v16@@ != Number || * @@v17@@ ) ; if ( @@v9@@ ) @@v4@@ = Number L ; else @@v4@@ = Number L ; printf ( String , @@v16@@ + Number , @@v4@@ ) ; @@v10@@ = Number ; LABEL_31 : ; } @@v12@@ += @@v10@@ ; } } @@v8@@ = @@v12@@ == @@argc@@ - optind ; } else { for ( @@k@@ = ( const char * * ) environ ; * @@k@@ ; ++ @@k@@ ) { if ( @@v9@@ ) @@v3@@ = Number L ; else @@v3@@ = Number L ; printf ( String , * @@k@@ , @@v3@@ ) ; } @@v8@@ = Number ; } exit ( ! @@v8@@ ) ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
__int64 __fastcall hash_get_first ( unsigned __int64 * @@a1@@ ) { unsigned __int64 @@i@@ ; if ( ! @@a1@@ [ Number ] ) return Number L ; for ( @@i@@ = * @@a1@@ ; ; @@i@@ += Number L ) { if ( @@i@@ >= @@a1@@ [ Number ] ) abort ( ) ; if ( * ( _QWORD * ) @@i@@ ) break ; } return * ( _QWORD * ) @@i@@ ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
unsigned __int64 __fastcall adjust_column ( unsigned __int64 @@a1@@ , char @@a2@@ ) { unsigned __int64 @@v3@@ ; @@v3@@ = @@a1@@ ; if ( count_bytes == Number ) return @@a1@@ + Number ; switch ( @@a2@@ ) { case Number : if ( @@a1@@ ) @@v3@@ = @@a1@@ - Number ; break ; case Number : @@v3@@ = Number L ; break ; case Number : @@v3@@ = ( @@a1@@ & Number ) + Number ; break ; default : @@v3@@ = @@a1@@ + Number ; break ; } return @@v3@@ ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
__int64 __fastcall hash_do_for_each ( __int64 @@a1@@ , unsigned __int8 ( __fastcall * @@a2@@ ) ( _QWORD , __int64 ) , __int64 @@a3@@ ) { __int64 @@v5@@ ; _QWORD * @@i@@ ; _QWORD * @@j@@ ; @@v5@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = @@i@@ ; @@j@@ ; @@j@@ = ( _QWORD * ) @@j@@ [ Number ] ) { if ( @@a2@@ ( * @@j@@ , @@a3@@ ) != Number ) return @@v5@@ ; ++ @@v5@@ ; } } } return @@v5@@ ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_212208 ; @@v4@@ [ Number ] = qword_212210 ; @@v4@@ [ Number ] = qword_212218 ; @@v4@@ [ Number ] = qword_212220 ; @@v4@@ [ Number ] = qword_212228 ; @@v4@@ [ Number ] = qword_212230 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
__int64 __fastcall check_tuning ( __int64 @@a1@@ ) { __int64 @@v2@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( ( _UNKNOWN * ) @@v2@@ == & default_tuning ) return Number L ; if ( * ( float * ) ( @@v2@@ + Number ) > Number && ( float ) ( Number - Number ) > * ( float * ) ( @@v2@@ + Number ) && * ( float * ) ( @@v2@@ + Number ) > ( float ) ( Number + Number ) && * ( float * ) @@v2@@ >= Number && * ( float * ) ( @@v2@@ + Number ) > ( float ) ( * ( float * ) @@v2@@ + Number ) && * ( float * ) ( @@v2@@ + Number ) <= Number && * ( float * ) ( @@v2@@ + Number ) > ( float ) ( * ( float * ) @@v2@@ + Number ) ) { return Number L ; } * ( _QWORD * ) ( @@a1@@ + Number ) = & default_tuning ; return Number L ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
void clearerr_unlocked ( FILE * @@stream@@ ) { clearerr_unlocked ( @@stream@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
void * __fastcall allocate_entry ( __int64 @@a1@@ ) { __int64 @@v2@@ ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return malloc ( Number ) ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = * ( _QWORD * ) ( @@v2@@ + Number ) ; return ( void * ) @@v2@@ ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
int fgetc ( FILE * @@stream@@ ) { return fgetc ( @@stream@@ ) ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
unsigned __int64 __fastcall xmax ( unsigned __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { unsigned __int64 @@result@@ ; @@result@@ = @@a2@@ ; if ( @@a1@@ >= @@a2@@ ) @@result@@ = @@a1@@ ; return @@result@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
int feof_unlocked ( FILE * @@stream@@ ) { return feof_unlocked ( @@stream@@ ) ; }
__int64 __fastcall transfer_entries ( __int64 @@a1@@ , __int64 @@a2@@ , char @@a3@@ ) { __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 * @@i@@ ; _QWORD * @@j@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; _QWORD * @@v11@@ ; _QWORD * @@v12@@ ; _QWORD * @@v13@@ ; _QWORD * @@v14@@ ; for ( @@i@@ = * ( __int64 * * ) @@a2@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a2@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = ( _QWORD * ) @@i@@ [ Number ] ; @@j@@ ; @@j@@ = @@v14@@ ) { @@v9@@ = * @@j@@ ; @@v3@@ = * ( _QWORD * ) @@a1@@ ; @@v11@@ = ( _QWORD * ) ( @@v3@@ + Number * ( * ( __int64 ( __fastcall * * ) ( _QWORD , _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@j@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@v11@@ >= * ( _QWORD * ) ( @@a1@@ + Number ) ) abort ( ) ; @@v14@@ = ( _QWORD * ) @@j@@ [ Number ] ; if ( * @@v11@@ ) { @@j@@ [ Number ] = @@v11@@ [ Number ] ; @@v11@@ [ Number ] = @@j@@ ; } else { * @@v11@@ = @@v9@@ ; ++ * ( _QWORD * ) ( @@a1@@ + Number ) ; free_entry ( @@a1@@ , @@j@@ ) ; } } @@v10@@ = * @@i@@ ; @@i@@ [ Number ] = Number L ; if ( ! @@a3@@ ) { @@v4@@ = * ( _QWORD * ) @@a1@@ ; @@v12@@ = ( _QWORD * ) ( @@v4@@ + Number * ( * ( __int64 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@v10@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@v12@@ >= * ( _QWORD * ) ( @@a1@@ + Number ) ) abort ( ) ; if ( * @@v12@@ ) { @@v13@@ = allocate_entry ( @@a1@@ ) ; if ( ! @@v13@@ ) return Number L ; * @@v13@@ = @@v10@@ ; @@v13@@ [ Number ] = @@v12@@ [ Number ] ; @@v12@@ [ Number ] = @@v13@@ ; } else { * @@v12@@ = @@v10@@ ; ++ * ( _QWORD * ) ( @@a1@@ + Number ) ; } * @@i@@ = Number L ; -- * ( _QWORD * ) ( @@a2@@ + Number ) ; } } } return Number L ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_207028 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; char * @@v3@@ ; FILE * @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; FILE * @@v10@@ ; char * @@v11@@ ; FILE * @@v12@@ ; char * @@v13@@ ; FILE * @@v14@@ ; char * @@v15@@ ; FILE * @@v16@@ ; char * @@v17@@ ; FILE * @@v18@@ ; char * @@v19@@ ; FILE * @@v20@@ ; char * @@v21@@ ; FILE * @@v22@@ ; char * @@v23@@ ; @@v1@@ = program_name ; if ( @@a1@@ ) { @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = gettext ( String ) ; printf ( @@v3@@ , @@v1@@ ) ; @@v4@@ = stdout ; @@v5@@ = gettext ( String ) ; fputs_unlocked ( @@v5@@ , @@v4@@ ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; @@v8@@ = stdout ; @@v9@@ = gettext ( String String String ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = stdout ; @@v11@@ = gettext ( String String String String ) ; fputs_unlocked ( @@v11@@ , @@v10@@ ) ; @@v12@@ = stdout ; @@v13@@ = gettext ( String String ) ; fputs_unlocked ( @@v13@@ , @@v12@@ ) ; @@v14@@ = stdout ; @@v15@@ = gettext ( String String String ) ; fputs_unlocked ( @@v15@@ , @@v14@@ ) ; @@v16@@ = stdout ; @@v17@@ = gettext ( String ) ; fputs_unlocked ( @@v17@@ , @@v16@@ ) ; @@v18@@ = stdout ; @@v19@@ = gettext ( String ) ; fputs_unlocked ( @@v19@@ , @@v18@@ ) ; @@v20@@ = stdout ; @@v21@@ = gettext ( String String String String ) ; fputs_unlocked ( @@v21@@ , @@v20@@ ) ; @@v22@@ = stdout ; @@v23@@ = gettext ( String String String String String String String String ) ; fputs_unlocked ( @@v23@@ , @@v22@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_20B028 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
int fileno ( FILE * @@stream@@ ) { return fileno ( @@stream@@ ) ; }
__int64 __fastcall cut_file ( const char * @@a1@@ ) { int * @@v1@@ ; FILE * @@stream@@ ; if ( ! strcmp ( @@a1@@ , String ) ) { have_read_stdin = Number ; @@stream@@ = stdin ; cut_stream ( stdin ) ; } else { @@stream@@ = fopen ( @@a1@@ , String ) ; if ( ! @@stream@@ ) goto LABEL_10 ; cut_stream ( @@stream@@ ) ; } if ( ferror_unlocked ( @@stream@@ ) ) goto LABEL_10 ; if ( strcmp ( @@a1@@ , String ) ) { if ( fclose ( @@stream@@ ) != Number ) return Number L ; LABEL_10 : @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , format , @@a1@@ ) ; return Number L ; } clearerr_unlocked ( @@stream@@ ) ; return Number L ; }
__int64 __fastcall xnrealloc ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { if ( ! is_mul_ok ( @@a3@@ , @@a2@@ ) ) xalloc_die ( ) ; return xrealloc ( @@a1@@ , @@a3@@ * @@a2@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
int getc_unlocked ( FILE * @@stream@@ ) { return getc_unlocked ( @@stream@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
char * __fastcall xstrndup ( const char * @@a1@@ , size_t @@a2@@ ) { char * @@v3@@ ; @@v3@@ = strndup ( @@a1@@ , @@a2@@ ) ; if ( ! @@v3@@ ) xalloc_die ( ) ; return @@v3@@ ; }
void * __fastcall xzalloc ( size_t @@a1@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@a1@@ ) ; return memset ( @@v1@@ , Number , @@a1@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
__int64 __fastcall freadptr ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { __int64 @@v3@@ ; if ( @@a1@@ [ Number ] > @@a1@@ [ Number ] ) return Number L ; @@v3@@ = @@a1@@ [ Number ] - @@a1@@ [ Number ] ; if ( ! @@v3@@ ) return Number L ; * @@a2@@ = @@v3@@ ; return @@a1@@ [ Number ] ; }
_BOOL8 __fastcall hash_table_ok ( __int64 @@a1@@ ) { _QWORD * @@i@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; _QWORD * @@v5@@ ; @@v3@@ = Number L ; @@v4@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { @@v5@@ = @@i@@ ; ++ @@v3@@ ; ++ @@v4@@ ; while ( Number ) { @@v5@@ = ( _QWORD * ) @@v5@@ [ Number ] ; if ( ! @@v5@@ ) break ; ++ @@v4@@ ; } } } return @@v3@@ == * ( _QWORD * ) ( @@a1@@ + Number ) && @@v4@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; char * @@v3@@ ; FILE * @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; FILE * @@v10@@ ; char * @@v11@@ ; FILE * @@v12@@ ; char * @@v13@@ ; FILE * @@v14@@ ; char * @@v15@@ ; FILE * @@v16@@ ; char * @@v17@@ ; FILE * @@v18@@ ; char * @@v19@@ ; __int64 @@v20@@ ; __int64 @@v21@@ ; char * @@v22@@ ; @@v1@@ = program_name ; if ( @@a1@@ ) { @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = gettext ( String ) ; printf ( @@v3@@ , @@v1@@ ) ; @@v4@@ = stdout ; @@v5@@ = gettext ( String ) ; fputs_unlocked ( @@v5@@ , @@v4@@ ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String String String String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; @@v8@@ = stdout ; @@v9@@ = gettext ( String String String String ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = stdout ; @@v11@@ = gettext ( String String String String ) ; fputs_unlocked ( @@v11@@ , @@v10@@ ) ; @@v12@@ = stdout ; @@v13@@ = gettext ( String ) ; fputs_unlocked ( @@v13@@ , @@v12@@ ) ; @@v14@@ = stdout ; @@v15@@ = gettext ( String ) ; fputs_unlocked ( @@v15@@ , @@v14@@ ) ; @@v16@@ = stdout ; @@v17@@ = gettext ( String ) ; fputs_unlocked ( @@v17@@ , @@v16@@ ) ; @@v18@@ = stdout ; @@v19@@ = gettext ( String ) ; fputs_unlocked ( @@v19@@ , @@v18@@ ) ; @@v20@@ = program_name ; @@v21@@ = program_name ; @@v22@@ = gettext ( String String String String ) ; printf ( @@v22@@ , @@v21@@ , @@v20@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
__off_t ftello ( FILE * @@stream@@ ) { return ftello ( @@stream@@ ) ; }
__int64 __fastcall freadahead ( __int64 @@a1@@ ) { __int64 @@v2@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) > * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; if ( ( * ( _DWORD * ) @@a1@@ & Number ) != Number ) @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) - * ( _QWORD * ) ( @@a1@@ + Number ) ; else @@v2@@ = Number L ; return * ( _QWORD * ) ( @@a1@@ + Number ) - * ( _QWORD * ) ( @@a1@@ + Number ) + @@v2@@ ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; char * @@v3@@ ; FILE * @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; FILE * @@v10@@ ; char * @@v11@@ ; FILE * @@v12@@ ; char * @@v13@@ ; @@v1@@ = program_name ; if ( @@a1@@ ) { @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = gettext ( String ) ; printf ( @@v3@@ , @@v1@@ ) ; @@v4@@ = stdout ; @@v5@@ = gettext ( String ) ; fputs_unlocked ( @@v5@@ , @@v4@@ ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; @@v8@@ = stdout ; @@v9@@ = gettext ( String String String ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = stdout ; @@v11@@ = gettext ( String ) ; fputs_unlocked ( @@v11@@ , @@v10@@ ) ; @@v12@@ = stdout ; @@v13@@ = gettext ( String ) ; fputs_unlocked ( @@v13@@ , @@v12@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
unsigned __int64 __fastcall hash_get_entries ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; _QWORD * @@i@@ ; _QWORD * @@j@@ ; @@v5@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = @@i@@ ; @@j@@ ; @@j@@ = ( _QWORD * ) @@j@@ [ Number ] ) { if ( @@v5@@ >= @@a3@@ ) return @@v5@@ ; @@v4@@ = @@v5@@ ++ ; * ( _QWORD * ) ( @@a2@@ + Number * @@v4@@ ) = * @@j@@ ; } } } return @@v5@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
int getc_unlocked ( FILE * @@stream@@ ) { return getc_unlocked ( @@stream@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
__int64 __fastcall next_prime ( unsigned __int64 @@a1@@ ) { __int64 @@v2@@ ; __int64 @@i@@ ; @@v2@@ = @@a1@@ ; if ( @@a1@@ <= Number ) @@v2@@ = Number L ; for ( @@i@@ = @@v2@@ | Number ; @@i@@ != Number && ! is_prime ( @@i@@ ) ; @@i@@ += Number L ) { ; } return @@i@@ ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
char * __fastcall next_line ( const void * @@a1@@ , char @@a2@@ , size_t @@a3@@ ) { return ( char * ) memchr ( @@a1@@ , @@a2@@ , @@a3@@ ) + Number ; }
FILE * __fastcall fopen_safer ( const char * @@a1@@ , const char * @@a2@@ ) { int @@v3@@ ; int @@fd@@ ; int @@v5@@ ; int @@v6@@ ; FILE * @@stream@@ ; @@stream@@ = fopen ( @@a1@@ , @@a2@@ ) ; if ( ! @@stream@@ ) return @@stream@@ ; @@v3@@ = fileno ( @@stream@@ ) ; if ( @@v3@@ < Number || @@v3@@ > Number ) return @@stream@@ ; @@fd@@ = dup_safer ( ( unsigned int ) @@v3@@ ) ; if ( @@fd@@ < Number ) { @@v6@@ = * __errno_location ( ) ; fclose ( @@stream@@ ) ; * __errno_location ( ) = @@v6@@ ; return Number L ; } if ( ! fclose ( @@stream@@ ) ) { @@stream@@ = fdopen ( @@fd@@ , @@a2@@ ) ; if ( @@stream@@ ) return @@stream@@ ; } @@v5@@ = * __errno_location ( ) ; close ( @@fd@@ ) ; * __errno_location ( ) = @@v5@@ ; return Number L ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall hash_clear ( __int64 @@a1@@ ) { __int64 @@result@@ ; _QWORD * @@i@@ ; _QWORD * @@j@@ ; _QWORD * @@v4@@ ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = ( _QWORD * ) @@i@@ [ Number ] ; @@j@@ ; @@j@@ = @@v4@@ ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@j@@ ) ; * @@j@@ = Number L ; @@v4@@ = ( _QWORD * ) @@j@@ [ Number ] ; @@j@@ [ Number ] = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@j@@ ; } if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@i@@ ) ; * @@i@@ = Number L ; @@i@@ [ Number ] = Number L ; } } * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; @@result@@ = @@a1@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; return @@result@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
__int64 __fastcall hash_rehash ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; unsigned __int64 @@nmemb@@ ; void * @@v4@@ ; __int64 @@v5@@ ; unsigned __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; __int64 @@v12@@ ; __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; @@v14@@ = __readfsqword ( Number ) ; @@nmemb@@ = compute_bucket_size ( @@a2@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ; if ( ! @@nmemb@@ ) return Number L ; if ( @@nmemb@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; @@v4@@ = calloc ( @@nmemb@@ , Number ) ; if ( ! @@v4@@ ) return Number L ; @@v6@@ = @@nmemb@@ ; @@v5@@ = ( __int64 ) @@v4@@ + Number * @@nmemb@@ ; @@v7@@ = Number L ; @@v8@@ = Number L ; @@v9@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v10@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v11@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v12@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v13@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( ( unsigned __int8 ) transfer_entries ( ( __int64 ) & @@v4@@ , @@a1@@ , Number ) ) { free ( * ( void * * ) @@a1@@ ) ; * ( _QWORD * ) @@a1@@ = @@v4@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v5@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v6@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v7@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v13@@ ; @@result@@ = Number L ; } else { * ( _QWORD * ) ( @@a1@@ + Number ) = @@v13@@ ; if ( ( unsigned __int8 ) transfer_entries ( @@a1@@ , ( __int64 ) & @@v4@@ , Number ) != Number || ( unsigned __int8 ) transfer_entries ( @@a1@@ , ( __int64 ) & @@v4@@ , Number ) != Number ) { abort ( ) ; } free ( @@v4@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_208028 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
unsigned __int64 __fastcall randint_genmax ( __int64 * @@a1@@ , unsigned __int64 @@a2@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; char @@v11@@ [ Number ] ; unsigned __int64 @@v12@@ ; @@v12@@ = __readfsqword ( Number ) ; @@v8@@ = * @@a1@@ ; @@v3@@ = @@a1@@ [ Number ] ; @@v4@@ = @@a1@@ [ Number ] ; @@v9@@ = @@a2@@ + Number ; while ( Number ) { if ( @@v4@@ < @@a2@@ ) { @@v5@@ = Number L ; @@v7@@ = @@v4@@ ; do { @@v7@@ = shift_left ( @@v7@@ ) + Number ; ++ @@v5@@ ; } while ( @@v7@@ < @@a2@@ ) ; randread ( @@v8@@ , @@v11@@ , @@v5@@ ) ; @@v6@@ = Number L ; do { @@v3@@ = shift_left ( @@v3@@ ) + ( unsigned __int8 ) @@v11@@ [ @@v6@@ ] ; @@v4@@ = shift_left ( @@v4@@ ) + Number ; ++ @@v6@@ ; } while ( @@v4@@ < @@a2@@ ) ; } if ( @@v4@@ == @@a2@@ ) { @@a1@@ [ Number ] = Number L ; @@a1@@ [ Number ] = @@a1@@ [ Number ] ; return @@v3@@ ; } @@v10@@ = ( @@v4@@ - @@a2@@ ) % @@v9@@ ; if ( @@v3@@ <= @@v4@@ - @@v10@@ ) break ; @@v3@@ %= @@v9@@ ; @@v4@@ = @@v10@@ - Number ; } @@a1@@ [ Number ] = @@v3@@ / @@v9@@ ; @@a1@@ [ Number ] = ( @@v4@@ - @@a2@@ ) / @@v9@@ ; return @@v3@@ % @@v9@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
__int64 __fastcall recurse_tree ( __int64 @@a1@@ , __int64 ( __fastcall * @@a2@@ ( ) ( item ) ) ( __int64 ) ) { if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) && ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return @@a2@@ ( ) ( item ) ( @@a1@@ ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) && ( unsigned __int8 ) recurse_tree ( * ( _QWORD * ) ( @@a1@@ + Number ) , @@a2@@ ( ) ( item ) ) ) { return Number L ; } if ( ( unsigned __int8 ) @@a2@@ ( ) ( item ) ( @@a1@@ ) ) return Number L ; return * ( _QWORD * ) ( @@a1@@ + Number ) && ( unsigned __int8 ) recurse_tree ( * ( _QWORD * ) ( @@a1@@ + Number ) , @@a2@@ ( ) ( item ) ) ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_208028 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return xmalloc ( @@a1@@ , @@a2@@ , @@a3@@ ) ; }
char * __fastcall randread_new ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { size_t @@v3@@ ; FILE * @@stream@@ ; char * @@v5@@ ; if ( ! @@a2@@ ) return ( char * ) simple_new ( Number L , Number L ) ; @@stream@@ = Number L ; if ( @@a1@@ ) { @@stream@@ = ( FILE * ) fopen_safer ( @@a1@@ , & off_796B ) ; if ( ! @@stream@@ ) return Number L ; } @@v5@@ = ( char * ) simple_new ( ( __int64 ) @@stream@@ , @@a1@@ ) ; if ( @@stream@@ ) { @@v3@@ = Number L ; if ( @@a2@@ <= Number ) @@v3@@ = @@a2@@ ; setvbuf ( @@stream@@ , @@v5@@ + Number , Number , @@v3@@ ) ; } else { * ( ( _QWORD * ) @@v5@@ + Number ) = Number L ; isaac_seed ( @@v5@@ + Number ) ; } return @@v5@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return xmalloc ( @@a1@@ , @@a2@@ , @@a3@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@v3@@ ; @@v3@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v3@@ ) xalloc_die ( ) ; return @@v3@@ ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
unsigned __int64 __fastcall isaac_seed ( _DWORD * @@a1@@ ) { __int64 @@v2@@ ; unsigned __int64 @@v3@@ ; @@v3@@ = __readfsqword ( Number ) ; isaac_seed_start ( @@a1@@ ) ; LODWORD ( @@v2@@ ) = getpid ( ) ; isaac_seed_data ( @@a1@@ , ( __int64 ) & @@v2@@ , Number ) ; LODWORD ( @@v2@@ ) = getppid ( ) ; isaac_seed_data ( @@a1@@ , ( __int64 ) & @@v2@@ , Number ) ; LODWORD ( @@v2@@ ) = getuid ( ) ; isaac_seed_data ( @@a1@@ , ( __int64 ) & @@v2@@ , Number ) ; LODWORD ( @@v2@@ ) = getgid ( ) ; isaac_seed_data ( @@a1@@ , ( __int64 ) & @@v2@@ , Number ) ; @@v2@@ = gethrxtime ( ) ; isaac_seed_data ( @@a1@@ , ( __int64 ) & @@v2@@ , Number ) ; isaac_seed_finish ( @@a1@@ ) ; return __readfsqword ( Number ) ^ @@v3@@ ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
__int64 __fastcall freadseek ( FILE * @@a1@@ , unsigned __int64 @@a2@@ ) { __int64 @@result@@ ; __int64 @@v3@@ ; size_t @@v4@@ ; size_t @@v5@@ ; unsigned __int64 @@v6@@ ; int @@fd@@ ; unsigned __int64 @@v8@@ ; __int64 @@i@@ ; __int64 @@v10@@ ; size_t @@n@@ ; char @@ptr@@ [ Number ] ; unsigned __int64 @@v13@@ ; @@v6@@ = @@a2@@ ; @@v13@@ = __readfsqword ( Number ) ; if ( ! @@a2@@ ) return Number L ; for ( @@i@@ = freadahead ( @@a1@@ ) ; @@i@@ ; -- @@i@@ ) { if ( freadptr ( @@a1@@ , & @@v8@@ ) && @@v8@@ ) { @@v3@@ = @@v8@@ ; if ( @@v6@@ <= @@v8@@ ) @@v3@@ = @@v6@@ ; @@v10@@ = @@v3@@ ; freadptrinc ( ( __int64 ) @@a1@@ , @@v3@@ ) ; @@v6@@ -= @@v10@@ ; if ( ! @@v6@@ ) return Number L ; @@i@@ -= @@v10@@ ; if ( ! @@i@@ ) break ; } if ( fgetc ( @@a1@@ ) == Number ) goto LABEL_24 ; if ( ! -- @@v6@@ ) return Number L ; } @@fd@@ = fileno ( @@a1@@ ) ; if ( @@fd@@ >= Number && lseek ( @@fd@@ , Number L , Number ) >= Number ) return rpl_fseeko ( @@a1@@ , @@v6@@ , Number L ) ; while ( Number ) { @@v4@@ = Number L ; if ( @@v6@@ <= Number ) @@v4@@ = @@v6@@ ; @@n@@ = @@v4@@ ; @@v5@@ = fread ( @@ptr@@ , Number , @@v4@@ , @@a1@@ ) ; if ( @@n@@ > @@v5@@ ) break ; @@v6@@ -= @@n@@ ; if ( ! @@v6@@ ) return Number L ; } LABEL_24 : if ( ferror ( @@a1@@ ) ) @@result@@ = Number ; else @@result@@ = Number L ; return @@result@@ ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( is_mul_ok ( @@a2@@ , * @@a1@@ ) ) { * @@a1@@ *= @@a2@@ ; @@result@@ = Number L ; } else { * @@a1@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
int tolower ( int @@c@@ ) { return tolower ( @@c@@ ) ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
FILE * __fastcall fopen_safer ( const char * @@a1@@ , const char * @@a2@@ ) { int @@v3@@ ; int @@fd@@ ; int @@v5@@ ; int @@v6@@ ; FILE * @@stream@@ ; @@stream@@ = fopen ( @@a1@@ , @@a2@@ ) ; if ( ! @@stream@@ ) return @@stream@@ ; @@v3@@ = fileno ( @@stream@@ ) ; if ( @@v3@@ < Number || @@v3@@ > Number ) return @@stream@@ ; @@fd@@ = dup_safer ( ( unsigned int ) @@v3@@ ) ; if ( @@fd@@ < Number ) { @@v6@@ = * __errno_location ( ) ; fclose ( @@stream@@ ) ; * __errno_location ( ) = @@v6@@ ; return Number L ; } if ( ! fclose ( @@stream@@ ) ) { @@stream@@ = fdopen ( @@fd@@ , @@a2@@ ) ; if ( @@stream@@ ) return @@stream@@ ; } @@v5@@ = * __errno_location ( ) ; close ( @@fd@@ ) ; * __errno_location ( ) = @@v5@@ ; return Number L ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
int feof_unlocked ( FILE * @@stream@@ ) { return feof_unlocked ( @@stream@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
unsigned __int64 __fastcall readtokens ( FILE * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , unsigned __int64 @@a4@@ , _QWORD * @@a5@@ , _QWORD * @@a6@@ ) { void * * @@v6@@ ; __int64 @@v12@@ ; unsigned __int64 @@v13@@ ; __int64 @@v14@@ ; __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; __int64 * @@v17@@ ; __int64 @@v18@@ ; void * @@dest@@ ; char @@v20@@ ; unsigned __int64 @@v21@@ ; @@v21@@ = __readfsqword ( Number ) ; @@v17@@ = ( __int64 * ) & @@v20@@ ; if ( @@a2@@ ) @@v12@@ = @@a2@@ + Number ; else @@v12@@ = Number L ; @@v13@@ = @@v12@@ ; @@v14@@ = xnmalloc ( @@v12@@ , Number L ) ; @@v15@@ = xnmalloc ( @@v12@@ , Number L ) ; @@v16@@ = Number L ; init_tokenbuffer ( @@v17@@ ) ; while ( Number ) { @@v18@@ = readtoken ( @@a1@@ , @@a3@@ , @@a4@@ , @@v17@@ ) ; if ( @@v16@@ >= @@v13@@ ) { @@v14@@ = x2nrealloc ( @@v14@@ , & @@v13@@ , Number L ) ; @@v15@@ = xnrealloc ( @@v15@@ , @@v13@@ , Number L ) ; } if ( @@v18@@ == Number ) break ; @@dest@@ = ( void * ) xnmalloc ( @@v18@@ + Number , Number L ) ; * ( _QWORD * ) ( @@v15@@ + Number * @@v16@@ ) = @@v18@@ ; @@v6@@ = ( void * * ) ( Number * @@v16@@ + @@v14@@ ) ; * @@v6@@ = memcpy ( @@dest@@ , ( const void * ) @@v17@@ [ Number ] , @@v18@@ + Number ) ; ++ @@v16@@ ; } * ( _QWORD * ) ( Number * @@v16@@ + @@v14@@ ) = Number L ; * ( _QWORD * ) ( Number * @@v16@@ + @@v15@@ ) = Number L ; free ( ( void * ) @@v17@@ [ Number ] ) ; * @@a5@@ = @@v14@@ ; if ( @@a6@@ ) * @@a6@@ = @@v15@@ ; return @@v16@@ ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; char * @@v3@@ ; FILE * @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; @@v1@@ = program_name ; if ( @@a1@@ ) { @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = gettext ( String String String String ) ; printf ( @@v3@@ , @@v1@@ ) ; @@v4@@ = stdout ; @@v5@@ = gettext ( String ) ; fputs_unlocked ( @@v5@@ , @@v4@@ ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; char * @@v3@@ ; FILE * @@v4@@ ; char * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; FILE * @@v11@@ ; char * @@v12@@ ; FILE * @@v13@@ ; char * @@v14@@ ; char * @@v15@@ ; @@v1@@ = program_name ; if ( @@a1@@ ) { @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = gettext ( String String String String ) ; printf ( @@v3@@ , @@v1@@ , String , Number L ) ; @@v4@@ = stdout ; @@v5@@ = gettext ( String ) ; fputs_unlocked ( @@v5@@ , @@v4@@ ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , String ) ; @@v7@@ = stdout ; @@v8@@ = gettext ( String ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = stdout ; @@v10@@ = gettext ( String String String String String String ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; @@v11@@ = stdout ; @@v12@@ = gettext ( String ) ; fputs_unlocked ( @@v12@@ , @@v11@@ ) ; @@v13@@ = stdout ; @@v14@@ = gettext ( String ) ; fputs_unlocked ( @@v14@@ , @@v13@@ ) ; @@v15@@ = gettext ( String String String String String ) ; printf ( @@v15@@ , String ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
__int64 __fastcall detect_loop ( __int64 @@a1@@ ) { __int64 @@i@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) { if ( loop ) { for ( @@i@@ = @@a1@@ + Number ; * ( _QWORD * ) @@i@@ ; @@i@@ = * ( _QWORD * ) @@i@@ + Number L ) { if ( * * ( _QWORD * * ) @@i@@ == loop ) { if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) { * ( _QWORD * ) ( @@a1@@ + Number ) = loop ; loop = @@a1@@ ; return Number L ; } while ( loop ) { @@v3@@ = * ( _QWORD * ) ( loop + Number ) ; fprintf ( stderr , String , ( const char * ) program_name , * ( const char * * ) loop ) ; if ( @@a1@@ == loop ) { -- * ( _QWORD * ) ( * * ( _QWORD * * ) @@i@@ + Number L ) ; * ( _QWORD * ) @@i@@ = * ( _QWORD * ) ( * ( _QWORD * ) @@i@@ + Number L ) ; break ; } * ( _QWORD * ) ( loop + Number ) = Number L ; loop = @@v3@@ ; } while ( loop ) { @@v4@@ = * ( _QWORD * ) ( loop + Number ) ; * ( _QWORD * ) ( loop + Number ) = Number L ; loop = @@v4@@ ; } return Number L ; } } } else { loop = @@a1@@ ; } } return Number L ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_20A028 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
__int64 __fastcall protect_fd ( int @@a1@@ ) { int @@fd@@ ; @@fd@@ = open ( String , Number ) ; if ( @@fd@@ == @@a1@@ ) return Number L ; if ( @@fd@@ >= Number ) { close ( @@fd@@ ) ; * __errno_location ( ) = Number ; } return Number L ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v4@@ ; @@v4@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v4@@ >= Number / @@a3@@ ) xalloc_die ( ) ; @@v4@@ += ( @@v4@@ + Number ) >> Number ; } else if ( ! @@v4@@ ) { @@v4@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v4@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v4@@ ) ; }
__int64 __fastcall write_permuted_output ( unsigned __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , char @@a5@@ ) { unsigned __int64 @@i@@ ; unsigned __int64 @@j@@ ; __int64 @@v11@@ ; size_t @@n@@ ; if ( @@a2@@ ) { for ( @@i@@ = Number L ; @@i@@ < @@a1@@ ; ++ @@i@@ ) { @@v11@@ = Number L * * ( _QWORD * ) ( Number * @@i@@ + @@a4@@ ) + @@a2@@ ; @@n@@ = * ( _QWORD * ) ( @@v11@@ + Number ) - * ( _QWORD * ) @@v11@@ ; if ( @@n@@ != fwrite_unlocked ( * ( const void * * ) @@v11@@ , Number , @@n@@ , stdout ) ) return Number ; } } else { for ( @@j@@ = Number L ; @@j@@ < @@a1@@ ; ++ @@j@@ ) { if ( printf ( String , * ( _QWORD * ) ( Number * @@j@@ + @@a4@@ ) + @@a3@@ , ( unsigned int ) @@a5@@ ) < Number ) return Number ; } } return Number L ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@v3@@ ; @@v3@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v3@@ ) xalloc_die ( ) ; return @@v3@@ ; }
_QWORD * __fastcall randint_all_new ( __int64 @@a1@@ , __int64 @@a2@@ ) { _QWORD * @@result@@ ; __int64 @@v3@@ ; @@v3@@ = randread_new ( @@a1@@ , @@a2@@ ) ; if ( @@v3@@ ) @@result@@ = randint_new ( @@v3@@ ) ; else @@result@@ = Number L ; return @@result@@ ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; char * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; char * @@v9@@ ; @@v1@@ = program_name ; if ( @@a1@@ ) { @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = gettext ( String ) ; printf ( @@v3@@ , @@v1@@ ) ; @@v4@@ = gettext ( String String String String String ) ; printf ( @@v4@@ , Number L , Number L ) ; @@v5@@ = stdout ; @@v6@@ = gettext ( String ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = stdout ; @@v8@@ = gettext ( String ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = gettext ( String String String String ) ; printf ( @@v9@@ , String ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
__int64 __fastcall randint_get_source ( __int64 @@a1@@ ) { return * ( _QWORD * ) @@a1@@ ; }
__int64 __fastcall bkm_scale_by_power ( unsigned __int64 * @@a1@@ , int @@a2@@ , int @@a3@@ ) { unsigned int @@i@@ ; for ( @@i@@ = Number ; @@a3@@ -- ; @@i@@ |= bkm_scale ( @@a1@@ , @@a2@@ ) ) { ; } return @@i@@ ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
__int64 __fastcall randint_all_free ( _QWORD * @@a1@@ ) { unsigned int @@v2@@ ; int @@v3@@ ; @@v2@@ = randread_free ( * @@a1@@ ) ; @@v3@@ = * __errno_location ( ) ; randint_free ( @@a1@@ ) ; * __errno_location ( ) = @@v3@@ ; return @@v2@@ ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_20A028 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
__int64 __fastcall rpl_fcntl ( int @@a1@@ , int @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , __m128 @@a7@@ , __m128 @@a8@@ , __m128 @@a9@@ , __m128 @@a10@@ , __m128 @@a11@@ , __m128 @@a12@@ , __m128 @@a13@@ , __m128 @@a14@@ ) { int @@v14@@ ; int @@v15@@ ; int @@v16@@ ; int @@v18@@ ; int @@v19@@ ; int @@v20@@ ; int @@v21@@ ; __int64 @@v22@@ ; __int64 @@v23@@ ; __int64 @@v24@@ ; __int64 @@v25@@ ; __m128 @@v26@@ ; __m128 @@v27@@ ; __m128 @@v28@@ ; __m128 @@v29@@ ; __m128 @@v30@@ ; __m128 @@v31@@ ; __m128 @@v32@@ ; __m128 @@v33@@ ; @@v22@@ = @@a3@@ ; @@v23@@ = @@a4@@ ; @@v24@@ = @@a5@@ ; @@v25@@ = @@a6@@ ; @@v26@@ = @@a7@@ ; @@v27@@ = @@a8@@ ; @@v28@@ = @@a9@@ ; @@v29@@ = @@a10@@ ; @@v30@@ = @@a11@@ ; @@v31@@ = @@a12@@ ; @@v32@@ = @@a13@@ ; @@v33@@ = @@a14@@ ; if ( @@a2@@ != Number ) return ( unsigned int ) fcntl ( @@a1@@ , @@a2@@ , @@v22@@ ) ; @@v19@@ = @@v22@@ ; if ( have_dupfd_cloexec_2895 < Number ) { @@v18@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v22@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; } else { @@v18@@ = fcntl ( @@a1@@ , Number , ( unsigned int ) @@v22@@ ) ; if ( @@v18@@ < Number && * __errno_location ( ) == Number ) { @@v18@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v19@@ , @@v14@@ , @@v15@@ , @@v16@@ ) ; if ( @@v18@@ < Number ) return ( unsigned int ) @@v18@@ ; have_dupfd_cloexec_2895 = Number ; } else { have_dupfd_cloexec_2895 = Number ; } } if ( @@v18@@ >= Number && have_dupfd_cloexec_2895 == Number ) { @@v20@@ = fcntl ( @@v18@@ , Number ) ; if ( @@v20@@ < Number || fcntl ( @@v18@@ , Number , @@v20@@ | Number ) == Number ) { @@v21@@ = * __errno_location ( ) ; close ( @@v18@@ ) ; * __errno_location ( ) = @@v21@@ ; @@v18@@ = Number ; } } return ( unsigned int ) @@v18@@ ; }
unsigned __int64 * __fastcall randperm_new ( __int64 * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 * @@v6@@ ; __int64 @@v7@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@j@@ ; __int64 @@v10@@ ; if ( ! @@a2@@ ) return Number L ; if ( @@a2@@ == Number ) { @@v6@@ = ( unsigned __int64 * ) xmalloc ( Number L ) ; * @@v6@@ = randint_choose ( @@a1@@ , @@a3@@ ) ; } else { @@v7@@ = xnmalloc ( @@a3@@ , Number L ) ; for ( @@i@@ = Number L ; @@i@@ < @@a3@@ ; ++ @@i@@ ) * ( _QWORD * ) ( @@v7@@ + Number * @@i@@ ) = @@i@@ ; for ( @@j@@ = Number L ; @@j@@ < @@a2@@ ; ++ @@j@@ ) { @@v3@@ = randint_choose ( @@a1@@ , @@a3@@ - @@j@@ ) ; @@v10@@ = * ( _QWORD * ) ( Number * @@j@@ + @@v7@@ ) ; * ( _QWORD * ) ( Number * @@j@@ + @@v7@@ ) = * ( _QWORD * ) ( Number * ( @@v3@@ + @@j@@ ) + @@v7@@ ) ; * ( _QWORD * ) ( @@v7@@ + Number * ( @@v3@@ + @@j@@ ) ) = @@v10@@ ; } @@v6@@ = ( unsigned __int64 * ) xnrealloc ( @@v7@@ , @@a2@@ , Number L ) ; } return @@v6@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_207108 ; @@v4@@ [ Number ] = qword_207110 ; @@v4@@ [ Number ] = qword_207118 ; @@v4@@ [ Number ] = qword_207120 ; @@v4@@ [ Number ] = qword_207128 ; @@v4@@ [ Number ] = qword_207130 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_207028 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
size_t __fastcall randread ( _QWORD * @@a1@@ , char * @@a2@@ , size_t @@a3@@ ) { size_t @@result@@ ; if ( * @@a1@@ ) @@result@@ = readsource ( ( __int64 ) @@a1@@ , @@a2@@ , @@a3@@ ) ; else @@result@@ = ( size_t ) readisaac ( @@a1@@ + Number , @@a2@@ , @@a3@@ ) ; return @@result@@ ; }
int putchar_unlocked ( int @@c@@ ) { return putchar_unlocked ( @@c@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ ) { return xmalloc ( @@a1@@ ) ; }
_DWORD * __fastcall isaac_seed_data ( _DWORD * @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { _DWORD * @@result@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@j@@ ; unsigned __int64 @@k@@ ; char * @@v9@@ ; char * @@v10@@ ; for ( @@i@@ = Number L - ( unsigned int ) @@a1@@ [ Number ] ; @@a3@@ > @@i@@ ; @@i@@ = Number L ) { @@v9@@ = ( char * ) @@a1@@ + ( unsigned int ) @@a1@@ [ Number ] ; for ( @@j@@ = Number L ; @@j@@ < @@i@@ ; ++ @@j@@ ) @@v9@@ [ @@j@@ ] ^= * ( _BYTE * ) ( @@a2@@ + @@j@@ ) ; @@a2@@ += @@i@@ ; @@a3@@ -= @@i@@ ; isaac_mix ( @@a1@@ , ( __int64 ) @@a1@@ ) ; @@a1@@ [ Number ] = Number ; } @@v10@@ = ( char * ) @@a1@@ + ( unsigned int ) @@a1@@ [ Number ] ; for ( @@k@@ = Number L ; @@k@@ < @@a3@@ ; ++ @@k@@ ) @@v10@@ [ @@k@@ ] ^= * ( _BYTE * ) ( @@a2@@ + @@k@@ ) ; @@result@@ = @@a1@@ ; @@a1@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
_DWORD * __fastcall sha1_read_ctx ( _DWORD * @@a1@@ , _DWORD * @@a2@@ ) { set_uint32 ( @@a2@@ , HIBYTE ( * @@a1@@ ) | ( * @@a1@@ >> Number ) & Number | ( * @@a1@@ << Number ) & Number | ( * @@a1@@ << Number ) ) ; set_uint32 ( @@a2@@ + Number , HIBYTE ( @@a1@@ [ Number ] ) | ( @@a1@@ [ Number ] >> Number ) & Number | ( @@a1@@ [ Number ] << Number ) & Number | ( @@a1@@ [ Number ] << Number ) ) ; set_uint32 ( @@a2@@ + Number , HIBYTE ( @@a1@@ [ Number ] ) | ( @@a1@@ [ Number ] >> Number ) & Number | ( @@a1@@ [ Number ] << Number ) & Number | ( @@a1@@ [ Number ] << Number ) ) ; set_uint32 ( @@a2@@ + Number , HIBYTE ( @@a1@@ [ Number ] ) | ( @@a1@@ [ Number ] >> Number ) & Number | ( @@a1@@ [ Number ] << Number ) & Number | ( @@a1@@ [ Number ] << Number ) ) ; set_uint32 ( @@a2@@ + Number , HIBYTE ( @@a1@@ [ Number ] ) | ( @@a1@@ [ Number ] >> Number ) & Number | ( @@a1@@ [ Number ] << Number ) & Number | ( @@a1@@ [ Number ] << Number ) ) ; return @@a2@@ ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
FILE * __fastcall freopen_safer ( const char * @@a1@@ , const char * @@a2@@ , FILE * @@a3@@ ) { int @@v3@@ ; FILE * @@streama@@ ; char @@v7@@ ; char @@v8@@ ; char @@v9@@ ; int @@v10@@ ; @@v7@@ = Number ; @@v8@@ = Number ; @@v9@@ = Number ; @@v3@@ = fileno ( @@a3@@ ) ; if ( @@v3@@ != Number ) { if ( @@v3@@ != Number ) { if ( ! @@v3@@ ) goto LABEL_10 ; if ( dup2 ( Number , Number ) != Number ) @@v9@@ = Number ; } if ( dup2 ( Number , Number ) != Number ) @@v8@@ = Number ; } if ( dup2 ( Number , Number ) ) @@v7@@ = Number ; LABEL_10 : if ( @@v7@@ && ( unsigned __int8 ) protect_fd ( Number ) != Number ) { @@streama@@ = Number L ; } else if ( @@v8@@ && ( unsigned __int8 ) protect_fd ( Number ) != Number ) { @@streama@@ = Number L ; } else if ( @@v9@@ && ( unsigned __int8 ) protect_fd ( Number ) != Number ) { @@streama@@ = Number L ; } else { @@streama@@ = freopen ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } @@v10@@ = * __errno_location ( ) ; if ( @@v9@@ ) close ( Number ) ; if ( @@v8@@ ) close ( Number ) ; if ( @@v7@@ ) close ( Number ) ; if ( ! @@streama@@ ) * __errno_location ( ) = @@v10@@ ; return @@streama@@ ; }
__int64 __fastcall mark_range_start ( __int64 @@a1@@ ) { __int64 @@result@@ ; __int64 @@v2@@ ; @@v2@@ = hash_insert ( range_start_ht , @@a1@@ ) ; if ( ! @@v2@@ ) xalloc_die ( ) ; @@result@@ = @@v2@@ ; if ( @@a1@@ != @@v2@@ ) __assert_fail ( String , String , Number , String ) ; return @@result@@ ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
unsigned __int64 __fastcall cut_bytes ( FILE * @@a1@@ ) { bool * @@v1@@ ; char @@v3@@ ; char @@v4@@ ; int @@c@@ ; unsigned __int64 @@v6@@ ; bool * @@v7@@ ; unsigned __int64 @@v8@@ ; @@v8@@ = __readfsqword ( Number ) ; @@v6@@ = Number L ; @@v4@@ = Number ; while ( Number ) { while ( Number ) { @@c@@ = getc_unlocked ( @@a1@@ ) ; if ( @@c@@ != Number ) break ; putchar_unlocked ( Number ) ; @@v6@@ = Number L ; @@v4@@ = Number ; } if ( @@c@@ == Number ) break ; if ( output_delimiter_specified ) @@v1@@ = ( bool * ) & @@v3@@ ; else @@v1@@ = Number L ; @@v7@@ = @@v1@@ ; if ( print_kth ( ++ @@v6@@ , @@v1@@ ) ) { if ( @@v7@@ && * @@v7@@ && @@v4@@ ) fwrite_unlocked ( output_delimiter_string , Number , output_delimiter_length , stdout ) ; @@v4@@ = Number ; putchar_unlocked ( @@c@@ ) ; } } if ( @@v6@@ ) putchar_unlocked ( Number ) ; return __readfsqword ( Number ) ^ @@v8@@ ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 __fastcall dup_safer ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , off_8B36 , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; FILE * @@v11@@ ; char * @@v12@@ ; FILE * @@v13@@ ; char * @@v14@@ ; FILE * @@v15@@ ; char * @@v16@@ ; if ( @@a1@@ ) { @@v1@@ = program_name ; @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = program_name ; @@v4@@ = program_name ; @@v5@@ = program_name ; @@v6@@ = gettext ( String String String ) ; printf ( @@v6@@ , @@v5@@ , @@v4@@ , @@v3@@ ) ; @@v7@@ = stdout ; @@v8@@ = gettext ( String String String String String ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = stdout ; @@v10@@ = gettext ( String ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; @@v11@@ = stdout ; @@v12@@ = gettext ( String ) ; fputs_unlocked ( @@v12@@ , @@v11@@ ) ; @@v13@@ = stdout ; @@v14@@ = gettext ( String String String String String String ) ; fputs_unlocked ( @@v14@@ , @@v13@@ ) ; @@v15@@ = stdout ; @@v16@@ = gettext ( String String String ) ; fputs_unlocked ( @@v16@@ , @@v15@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
int __fastcall hash_print_statistics ( __int64 @@a1@@ , FILE * @@a2@@ ) { double @@v2@@ ; double @@v3@@ ; double @@v4@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v6@@ = hash_get_n_entries ( @@a1@@ ) ; @@v7@@ = hash_get_n_buckets ( @@a1@@ ) ; @@v8@@ = hash_get_n_buckets_used ( @@a1@@ ) ; @@v9@@ = hash_get_max_bucket_length ( @@a1@@ ) ; fprintf ( @@a2@@ , String , @@v6@@ ) ; fprintf ( @@a2@@ , String , @@v7@@ ) ; if ( @@v8@@ < Number ) @@v2@@ = ( double ) ( int ) ( @@v8@@ & Number | ( ( unsigned __int64 ) @@v8@@ >> Number ) ) + ( double ) ( int ) ( @@v8@@ & Number | ( ( unsigned __int64 ) @@v8@@ >> Number ) ) ; else @@v2@@ = ( double ) ( int ) @@v8@@ ; @@v3@@ = Number * @@v2@@ ; if ( @@v7@@ < Number ) @@v4@@ = ( double ) ( int ) ( @@v7@@ & Number | ( ( unsigned __int64 ) @@v7@@ >> Number ) ) + ( double ) ( int ) ( @@v7@@ & Number | ( ( unsigned __int64 ) @@v7@@ >> Number ) ) ; else @@v4@@ = ( double ) ( int ) @@v7@@ ; fprintf ( @@a2@@ , String , @@v8@@ , @@v3@@ / @@v4@@ ) ; return fprintf ( @@a2@@ , String , @@v9@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_20A0C8 ; @@v4@@ [ Number ] = qword_20A0D0 ; @@v4@@ [ Number ] = qword_20A0D8 ; @@v4@@ [ Number ] = qword_20A0E0 ; @@v4@@ [ Number ] = qword_20A0E8 ; @@v4@@ [ Number ] = qword_20A0F0 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , off_B198 , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
bool __fastcall is_prime ( unsigned __int64 @@a1@@ ) { unsigned __int64 @@v2@@ ; unsigned __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; @@v2@@ = Number L ; @@v4@@ = Number L ; while ( @@v4@@ < @@a1@@ && @@a1@@ % @@v2@@ ) { @@v3@@ = @@v2@@ + Number ; @@v4@@ += Number * @@v3@@ ; @@v2@@ = @@v3@@ + Number ; } return @@a1@@ % @@v2@@ != Number ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_20A0C8 ; @@v8@@ [ Number ] = qword_20A0D0 ; @@v8@@ [ Number ] = qword_20A0D8 ; @@v8@@ [ Number ] = qword_20A0E0 ; @@v8@@ [ Number ] = qword_20A0E8 ; @@v8@@ [ Number ] = qword_20A0F0 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
unsigned __int64 __fastcall compute_bucket_size ( __int64 @@a1@@ , __int64 @@a2@@ ) { float @@v2@@ ; unsigned __int64 @@result@@ ; unsigned __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; float @@v6@@ ; @@v4@@ = @@a1@@ ; if ( * ( _BYTE * ) ( @@a2@@ + Number ) != Number ) { if ( @@a1@@ < Number ) @@v2@@ = ( float ) ( @@a1@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@a1@@ >> Number ) ) + ( float ) ( @@a1@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@a1@@ >> Number ) ) ; else @@v2@@ = ( float ) ( int ) @@a1@@ ; @@v6@@ = @@v2@@ / * ( float * ) ( @@a2@@ + Number ) ; if ( @@v6@@ >= Number ) return Number L ; if ( @@v6@@ >= Number ) @@v4@@ = ( unsigned int ) ( int ) ( float ) ( @@v6@@ - Number ) ^ Number ; else @@v4@@ = ( unsigned int ) ( int ) @@v6@@ ; } @@v5@@ = next_prime ( @@v4@@ ) ; if ( @@v5@@ <= Number ) @@result@@ = @@v5@@ ; else @@result@@ = Number L ; return @@result@@ ; }
void * __fastcall xzalloc ( size_t @@a1@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@a1@@ ) ; return memset ( @@v1@@ , Number , @@a1@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall free_entry ( __int64 @@a1@@ , _QWORD * @@a2@@ ) { __int64 @@result@@ ; * @@a2@@ = Number L ; @@a2@@ [ Number ] = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@result@@ = @@a1@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( is_mul_ok ( @@a2@@ , * @@a1@@ ) ) { * @@a1@@ *= @@a2@@ ; @@result@@ = Number L ; } else { * @@a1@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
unsigned __int64 __fastcall rpl_vasprintf ( void * * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { unsigned __int64 @@result@@ ; unsigned __int64 @@v4@@ ; void * @@ptr@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = __readfsqword ( Number ) ; @@ptr@@ = ( void * ) vasnprintf ( Number L , & @@v4@@ , @@a2@@ , @@a3@@ ) ; if ( ! @@ptr@@ ) return Number ; if ( @@v4@@ <= Number ) { * @@a1@@ = @@ptr@@ ; @@result@@ = @@v4@@ ; } else { free ( @@ptr@@ ) ; * __errno_location ( ) = Number ; @@result@@ = Number ; } return @@result@@ ; }
__int64 __fastcall hash_find_entry ( __int64 @@a1@@ , __int64 @@a2@@ , _QWORD * @@a3@@ , char @@a4@@ ) { __int64 @@v4@@ ; __int64 @@result@@ ; __int64 @@v6@@ ; _QWORD * @@i@@ ; _QWORD * @@v10@@ ; __int64 @@v11@@ ; _QWORD * @@v12@@ ; __int64 @@v13@@ ; _QWORD * @@v14@@ ; @@v4@@ = * ( _QWORD * ) @@a1@@ ; @@v10@@ = ( _QWORD * ) ( @@v4@@ + Number * ( * ( __int64 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@a2@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@v10@@ >= * ( _QWORD * ) ( @@a1@@ + Number ) ) abort ( ) ; * @@a3@@ = @@v10@@ ; if ( ! * @@v10@@ ) return Number L ; if ( @@a2@@ == * @@v10@@ || ( * ( unsigned __int8 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@a2@@ , * @@v10@@ ) ) { @@v13@@ = * @@v10@@ ; if ( @@a4@@ ) { if ( @@v10@@ [ Number ] ) { @@v14@@ = ( _QWORD * ) @@v10@@ [ Number ] ; @@v6@@ = @@v14@@ [ Number ] ; * @@v10@@ = * @@v14@@ ; @@v10@@ [ Number ] = @@v6@@ ; free_entry ( @@a1@@ , @@v14@@ ) ; } else { * @@v10@@ = Number L ; } } @@result@@ = @@v13@@ ; } else { for ( @@i@@ = @@v10@@ ; ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { if ( ! @@i@@ [ Number ] ) return Number L ; if ( @@a2@@ == * ( _QWORD * ) @@i@@ [ Number ] || ( * ( unsigned __int8 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@a2@@ , * ( _QWORD * ) @@i@@ [ Number ] ) ) { break ; } } @@v11@@ = * ( _QWORD * ) @@i@@ [ Number ] ; if ( @@a4@@ ) { @@v12@@ = ( _QWORD * ) @@i@@ [ Number ] ; @@i@@ [ Number ] = @@v12@@ [ Number ] ; free_entry ( @@a1@@ , @@v12@@ ) ; } @@result@@ = @@v11@@ ; } return @@result@@ ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_2070E8 ; @@v4@@ [ Number ] = qword_2070F0 ; @@v4@@ [ Number ] = qword_2070F8 ; @@v4@@ [ Number ] = qword_207100 ; @@v4@@ [ Number ] = qword_207108 ; @@v4@@ [ Number ] = qword_207110 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
int getc_unlocked ( FILE * @@stream@@ ) { return getc_unlocked ( @@stream@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
void * __fastcall xzalloc ( size_t @@a1@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@a1@@ ) ; return memset ( @@v1@@ , Number , @@a1@@ ) ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
int fileno ( FILE * @@stream@@ ) { return fileno ( @@stream@@ ) ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
int __xstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _xstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
_BOOL8 __fastcall get_mtime ( char * @@a1@@ , __int64 * @@a2@@ ) { int @@v2@@ ; __int64 @@v3@@ ; bool @@v5@@ ; struct stat @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v2@@ = stat ( @@a1@@ , & @@v6@@ ) ; @@v5@@ = @@v2@@ == Number ; if ( ! @@v2@@ ) { * @@a2@@ = get_stat_mtime ( ( __int64 ) & @@v6@@ ) ; @@a2@@ [ Number ] = @@v3@@ ; } return @@v5@@ ; }
bool __fastcall is_printable_field ( unsigned __int64 @@a1@@ ) { return ( ( ( int ) * ( unsigned __int8 * ) ( printable_field + ( @@a1@@ >> Number ) ) >> ( @@a1@@ & Number ) ) & Number ) != Number ; }
char * nl_langinfo ( nl_item @@item@@ ) { return nl_langinfo ( @@item@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_20B128 ; @@v8@@ [ Number ] = qword_20B130 ; @@v8@@ [ Number ] = qword_20B138 ; @@v8@@ [ Number ] = qword_20B140 ; @@v8@@ [ Number ] = qword_20B148 ; @@v8@@ [ Number ] = qword_20B150 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
_BOOL8 __fastcall print_kth ( unsigned __int64 @@a1@@ , bool * @@a2@@ ) { bool @@v2@@ ; bool @@v4@@ ; @@v2@@ = eol_range_start && @@a1@@ >= eol_range_start || @@a1@@ <= max_range_endpoint && is_printable_field ( @@a1@@ ) ; @@v4@@ = ( unsigned __int8 ) ( @@v2@@ ^ complement ) != Number ; if ( @@a2@@ && @@v2@@ != complement ) * @@a2@@ = is_range_start_index ( @@a1@@ ) ; return @@v4@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( ) ; return @@ptr@@ ; }
int __fastcall cut_stream ( FILE * @@a1@@ ) { int @@result@@ ; if ( operating_mode == Number ) @@result@@ = cut_bytes ( @@a1@@ ) ; else @@result@@ = cut_fields ( @@a1@@ ) ; return @@result@@ ; }
unsigned __int64 __fastcall print_numbers ( const char * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , long double @@a4@@ , long double @@a5@@ , long double @@a6@@ ) { bool @@v9@@ ; bool @@v10@@ ; int @@v11@@ ; int @@v12@@ ; int @@v13@@ ; int @@v14@@ ; int @@v15@@ ; int @@v16@@ ; bool @@v19@@ ; bool @@v20@@ ; int @@v21@@ ; char * @@s2@@ ; char * @@s1@@ ; long double @@v24@@ ; long double @@v25@@ ; long double @@i@@ ; long double @@v27@@ ; unsigned __int64 @@v28@@ ; @@v28@@ = __readfsqword ( Number ) ; if ( @@a5@@ >= Number ) @@v9@@ = @@a4@@ > @@a6@@ ; else @@v9@@ = @@a6@@ > @@a4@@ ; @@v19@@ = @@v9@@ ; if ( ! @@v9@@ ) { @@v25@@ = @@a4@@ ; for ( @@i@@ = Number ; ; @@i@@ = @@i@@ + Number ) { @@v27@@ = @@v25@@ ; printf ( @@a1@@ ) ; if ( @@v19@@ ) break ; @@v25@@ = @@i@@ * @@a5@@ + @@a4@@ ; @@v10@@ = @@a5@@ >= Number ? @@v25@@ > @@a6@@ : @@a6@@ > @@v25@@ ; @@v19@@ = @@v10@@ ; if ( @@v10@@ ) { @@v20@@ = Number ; setlocale ( Number , String ) ; @@v21@@ = rpl_asprintf ( ( unsigned int ) & @@s2@@ , ( _DWORD ) @@a1@@ , ( _DWORD ) @@a1@@ , @@v11@@ , @@v12@@ , @@v13@@ , * ( _OWORD * ) & @@v25@@ ) ; setlocale ( Number , & byte_ACD7 ) ; if ( @@v21@@ < Number ) xalloc_die ( ) ; @@s2@@ [ @@v21@@ - @@a3@@ ] = Number ; if ( ( unsigned __int8 ) xstrtold ( & @@s2@@ [ @@a2@@ ] , Number L , & @@v24@@ , c_strtold ) && @@a6@@ == @@v24@@ ) { @@s1@@ = Number L ; if ( ( int ) rpl_asprintf ( ( unsigned int ) & @@s1@@ , ( _DWORD ) @@a1@@ , ( _DWORD ) @@a1@@ , @@v14@@ , @@v15@@ , @@v16@@ , * ( _OWORD * ) & @@v27@@ ) < Number ) xalloc_die ( ) ; @@v20@@ = strcmp ( @@s1@@ , @@s2@@ ) != Number ; free ( @@s1@@ ) ; } free ( @@s2@@ ) ; if ( ! @@v20@@ ) break ; } fputs_unlocked ( separator , stdout ) ; } fputc_unlocked ( Number , stdout ) ; } return __readfsqword ( Number ) ^ @@v28@@ ; }
int __cdecl __noreturn main ( int @@argc@@ , const char * * @@argv@@ , const char * * @@envp@@ ) { __int64 @@v3@@ ; char * @@v4@@ ; int * @@v5@@ ; char @@v6@@ ; int @@i@@ ; int @@v8@@ ; unsigned __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; char @@v11@@ [ Number ] ; unsigned __int64 @@v12@@ ; @@v12@@ = __readfsqword ( Number ) ; @@v10@@ = Number L ; set_program_name ( * @@argv@@ , @@argv@@ , @@envp@@ ) ; setlocale ( Number , & locale ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; have_read_stdin = Number ; count_bytes = Number ; break_spaces = Number ; while ( Number ) { @@v8@@ = getopt_long ( @@argc@@ , ( char * const * ) @@argv@@ , String , & longopts , Number L ) ; if ( @@v8@@ == Number ) { if ( @@argc@@ == optind ) { @@v6@@ = fold_file ( String , @@v10@@ ) ; } else { @@v6@@ = Number ; for ( @@i@@ = optind ; @@i@@ < @@argc@@ ; ++ @@i@@ ) @@v6@@ = ( unsigned __int8 ) ( @@v6@@ & fold_file ( @@argv@@ [ @@i@@ ] , @@v10@@ ) ) != Number ; } if ( have_read_stdin ) { if ( fclose ( stdin ) == Number ) { @@v5@@ = __errno_location ( ) ; error ( Number , * @@v5@@ , String ) ; } } exit ( ( unsigned __int8 ) @@v6@@ ^ Number ) ; } if ( @@v8@@ > Number ) { switch ( @@v8@@ ) { case String : break_spaces = Number ; break ; case String : goto LABEL_15 ; case String : count_bytes = Number ; break ; default : goto LABEL_22 ; } } else { if ( @@v8@@ < Number ) { if ( @@v8@@ == Number ) { version_etc ( ( _DWORD ) stdout , ( unsigned int ) String , ( unsigned int ) String , ( _DWORD ) Version , ( unsigned int ) String , Number , ( char ) @@argv@@ ) ; exit ( Number ) ; } if ( @@v8@@ == Number ) usage ( Number ) ; LABEL_22 : usage ( Number ) ; } if ( optarg ) { -- optarg ; } else { @@v11@@ [ Number ] = @@v8@@ ; @@v11@@ [ Number ] = Number ; optarg = ( __int64 ) @@v11@@ ; } LABEL_15 : if ( ( unsigned int ) xstrtoul ( optarg , Number L , Number L , & @@v9@@ , & locale ) || ! @@v9@@ || @@v9@@ > Number ) { @@v3@@ = quote ( optarg ) ; @@v4@@ = gettext ( String ) ; error ( Number , Number , @@v4@@ , @@v3@@ ) ; } @@v10@@ = @@v9@@ ; } } }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
__int64 __fastcall freadptrinc ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; @@result@@ = @@a1@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) += @@a2@@ ; return @@result@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
int __fastcall rpl_fseeko ( FILE * @@a1@@ , __off_t @@a2@@ , int @@a3@@ ) { __off_t @@v3@@ ; int @@v4@@ ; int @@result@@ ; if ( @@a1@@ -> _IO_read_end != @@a1@@ -> _IO_read_ptr || @@a1@@ -> _IO_write_ptr != @@a1@@ -> _IO_write_base || @@a1@@ -> _IO_save_base ) { goto LABEL_13 ; } if ( @@a3@@ == Number && @@a2@@ > Number ) @@v3@@ = Number L ; else @@v3@@ = @@a2@@ ; @@v4@@ = fileno ( @@a1@@ ) ; if ( lseek ( @@v4@@ , @@v3@@ , @@a3@@ ) == Number ) return Number ; @@a1@@ -> _flags &= Number ; if ( @@a3@@ == Number && @@a2@@ > Number ) LABEL_13 : @@result@@ = fseeko ( @@a1@@ , @@a2@@ , @@a3@@ ) ; else @@result@@ = Number ; return @@result@@ ; }
__int64 __fastcall hash_get_n_buckets ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
unsigned __int64 __fastcall hash_get_max_bucket_length ( __int64 @@a1@@ ) { _QWORD * @@i@@ ; unsigned __int64 @@v3@@ ; _QWORD * @@v4@@ ; unsigned __int64 @@j@@ ; @@v3@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { @@v4@@ = @@i@@ ; for ( @@j@@ = Number L ; ; ++ @@j@@ ) { @@v4@@ = ( _QWORD * ) @@v4@@ [ Number ] ; if ( ! @@v4@@ ) break ; } if ( @@j@@ > @@v3@@ ) @@v3@@ = @@j@@ ; } } return @@v3@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_207028 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_20D0E8 ; @@v4@@ [ Number ] = qword_20D0F0 ; @@v4@@ [ Number ] = qword_20D0F8 ; @@v4@@ [ Number ] = qword_20D100 ; @@v4@@ [ Number ] = qword_20D108 ; @@v4@@ [ Number ] = qword_20D110 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
__int64 __fastcall hash_get_next ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; _QWORD * @@v4@@ ; _QWORD * @@i@@ ; @@v2@@ = * @@a1@@ ; @@v4@@ = ( _QWORD * ) ( @@v2@@ + Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) ) ; if ( ( unsigned __int64 ) @@v4@@ >= @@a1@@ [ Number ] ) abort ( ) ; for ( @@i@@ = @@v4@@ ; @@i@@ ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { if ( @@a2@@ == * @@i@@ && @@i@@ [ Number ] ) return * ( _QWORD * ) @@i@@ [ Number ] ; } while ( Number ) { @@v4@@ += Number ; if ( ( unsigned __int64 ) @@v4@@ >= @@a1@@ [ Number ] ) break ; if ( * @@v4@@ ) return * @@v4@@ ; } return Number L ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
__int64 __fastcall xnrealloc ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { if ( ! is_mul_ok ( @@a3@@ , @@a2@@ ) ) xalloc_die ( ) ; return xrealloc ( @@a1@@ , @@a3@@ * @@a2@@ ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( ) ; return @@ptr@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall scan_zeros ( _QWORD * @@a1@@ ) { if ( ! @@a1@@ [ Number ] && * @@a1@@ ) { if ( head ) * ( _QWORD * ) ( zeros + Number ) = @@a1@@ ; else head = ( __int64 ) @@a1@@ ; zeros = ( __int64 ) @@a1@@ ; } return Number L ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return xmalloc ( @@a1@@ , @@a2@@ , @@a3@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
size_t * __fastcall hash_initialize ( __int64 @@a1@@ , void * @@a2@@ , unsigned __int64 ( __fastcall * @@a3@@ ) ( __int64 a1 , unsigned __int64 a2 ) , bool ( __fastcall * @@a4@@ ) ( __int64 a1 , __int64 a2 ) , size_t @@a5@@ ) { size_t * @@result@@ ; bool ( __fastcall * @@v7@@ ) ( __int64 , __int64 ) ; unsigned __int64 ( __fastcall * @@v8@@ ) ( __int64 , unsigned __int64 ) ; void * @@v9@@ ; size_t * @@ptr@@ ; @@v9@@ = @@a2@@ ; @@v8@@ = @@a3@@ ; @@v7@@ = @@a4@@ ; if ( ! @@a3@@ ) @@v8@@ = raw_hasher ; if ( ! @@a4@@ ) @@v7@@ = raw_comparator ; @@ptr@@ = ( size_t * ) malloc ( Number ) ; if ( ! @@ptr@@ ) return Number L ; if ( ! @@a2@@ ) @@v9@@ = & default_tuning ; @@ptr@@ [ Number ] = ( size_t ) @@v9@@ ; if ( ( unsigned __int8 ) check_tuning ( ( __int64 ) @@ptr@@ ) == Number && ( @@ptr@@ [ Number ] = compute_bucket_size ( @@a1@@ , ( __int64 ) @@v9@@ ) ) != Number && ( * @@ptr@@ = ( size_t ) calloc ( @@ptr@@ [ Number ] , Number ) ) != Number ) { @@ptr@@ [ Number ] = Number * @@ptr@@ [ Number ] + * @@ptr@@ ; @@ptr@@ [ Number ] = Number L ; @@ptr@@ [ Number ] = Number L ; @@ptr@@ [ Number ] = ( size_t ) @@v8@@ ; @@ptr@@ [ Number ] = ( size_t ) @@v7@@ ; @@ptr@@ [ Number ] = @@a5@@ ; @@ptr@@ [ Number ] = Number L ; @@result@@ = @@ptr@@ ; } else { free ( @@ptr@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
__int64 __fastcall walk_tree ( __int64 @@a1@@ , __int64 ( __fastcall * @@a2@@ ( ) ( item ) ) ( __int64 ) ) { __int64 @@result@@ ; @@result@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( @@result@@ ) @@result@@ = recurse_tree ( * ( _QWORD * ) ( @@a1@@ + Number ) , @@a2@@ ( ) ( item ) ) ; return @@result@@ ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall xstrtold ( _BYTE * @@a1@@ , _QWORD * @@a2@@ , long double * @@a3@@ , long double ( __fastcall * @@a4@@ ( ) ( constchar , char ) ) ( _BYTE * , _BYTE * * ) ) { unsigned __int8 @@v7@@ ; _BYTE * @@v8@@ ; long double @@v9@@ ; unsigned __int64 @@v10@@ ; @@v10@@ = __readfsqword ( Number ) ; @@v7@@ = Number ; * __errno_location ( ) = Number ; @@v9@@ = @@a4@@ ( ) ( constchar , char ) ( @@a1@@ , & @@v8@@ ) ; if ( @@a1@@ == @@v8@@ || ! @@a2@@ && * @@v8@@ ) { @@v7@@ = Number ; } else if ( Number != @@v9@@ && * __errno_location ( ) == Number ) { @@v7@@ = Number ; } if ( @@a2@@ ) * @@a2@@ = @@v8@@ ; * @@a3@@ = @@v9@@ ; return @@v7@@ ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
int __fastcall stat ( char * @@filename@@ , struct stat * @@stat_buf@@ ) { return __xstat ( Number , @@filename@@ , @@stat_buf@@ ) ; }
__int64 __fastcall bkm_scale_by_power ( unsigned __int64 * @@a1@@ , int @@a2@@ , int @@a3@@ ) { unsigned int @@i@@ ; for ( @@i@@ = Number ; @@a3@@ -- ; @@i@@ |= bkm_scale ( @@a1@@ , @@a2@@ ) ) { ; } return @@i@@ ; }
int raise ( int @@sig@@ ) { return raise ( @@sig@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
int isatty ( int @@fd@@ ) { return isatty ( @@fd@@ ) ; }
_BOOL8 __fastcall rpl_isnanl ( __int64 a1 , __int64 a2 , __int64 a3 , __int64 a4 , __int64 a5 , __int64 a6 , __int128 @@a7@@ ) { if ( ( WORD4 ( @@a7@@ ) & Number ) == Number ) return DWORD1 ( @@a7@@ ) >> Number ; if ( ( WORD4 ( @@a7@@ ) & Number ) == Number ) return ( DWORD1 ( @@a7@@ ) ^ Number | ( unsigned int ) @@a7@@ ) != Number ; return ( DWORD1 ( @@a7@@ ) & Number ) == Number ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
DIR * opendir ( const char * @@name@@ ) { return opendir ( @@name@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 __fastcall xsum_0 ( unsigned __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; if ( @@a1@@ + @@a2@@ < @@a1@@ ) @@result@@ = Number ; else @@result@@ = @@a1@@ + @@a2@@ ; return @@result@@ ; }
FILE * __fastcall freopen_safer ( const char * @@a1@@ , const char * @@a2@@ , FILE * @@a3@@ ) { int @@v3@@ ; FILE * @@streama@@ ; char @@v7@@ ; char @@v8@@ ; char @@v9@@ ; int @@v10@@ ; @@v7@@ = Number ; @@v8@@ = Number ; @@v9@@ = Number ; @@v3@@ = fileno ( @@a3@@ ) ; if ( @@v3@@ != Number ) { if ( @@v3@@ != Number ) { if ( ! @@v3@@ ) goto LABEL_10 ; if ( dup2 ( Number , Number ) != Number ) @@v9@@ = Number ; } if ( dup2 ( Number , Number ) != Number ) @@v8@@ = Number ; } if ( dup2 ( Number , Number ) ) @@v7@@ = Number ; LABEL_10 : if ( @@v7@@ && ( unsigned __int8 ) protect_fd ( Number ) != Number ) { @@streama@@ = Number L ; } else if ( @@v8@@ && ( unsigned __int8 ) protect_fd ( Number ) != Number ) { @@streama@@ = Number L ; } else if ( @@v9@@ && ( unsigned __int8 ) protect_fd ( Number ) != Number ) { @@streama@@ = Number L ; } else { @@streama@@ = freopen ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } @@v10@@ = * __errno_location ( ) ; if ( @@v9@@ ) close ( Number ) ; if ( @@v8@@ ) close ( Number ) ; if ( @@v7@@ ) close ( Number ) ; if ( ! @@streama@@ ) * __errno_location ( ) = @@v10@@ ; return @@streama@@ ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
int __lxstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _lxstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_20B028 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
int putchar_unlocked ( int @@c@@ ) { return putchar_unlocked ( @@c@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
int tolower ( int @@c@@ ) { return tolower ( @@c@@ ) ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; FILE * @@v11@@ ; char * @@v12@@ ; FILE * @@v13@@ ; char * @@v14@@ ; FILE * @@v15@@ ; char * @@v16@@ ; FILE * @@v17@@ ; char * @@v18@@ ; if ( @@a1@@ ) { @@v1@@ = program_name ; @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = program_name ; @@v4@@ = program_name ; @@v5@@ = program_name ; @@v6@@ = gettext ( String String String ) ; printf ( @@v6@@ , @@v5@@ , @@v4@@ , @@v3@@ ) ; @@v7@@ = stdout ; @@v8@@ = gettext ( String ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = stdout ; @@v10@@ = gettext ( String ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; @@v11@@ = stdout ; @@v12@@ = gettext ( String String String String String String ) ; fputs_unlocked ( @@v12@@ , @@v11@@ ) ; @@v13@@ = stdout ; @@v14@@ = gettext ( String ) ; fputs_unlocked ( @@v14@@ , @@v13@@ ) ; @@v15@@ = stdout ; @@v16@@ = gettext ( String ) ; fputs_unlocked ( @@v16@@ , @@v15@@ ) ; @@v17@@ = stdout ; @@v18@@ = gettext ( String ) ; fputs_unlocked ( @@v18@@ , @@v17@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_207028 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
unsigned int gnu_dev_minor ( unsigned __int64 @@dev@@ ) { return gnu_dev_minor ( @@dev@@ ) ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v4@@ ; @@v4@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v4@@ >= Number / @@a3@@ ) xalloc_die ( ) ; @@v4@@ += ( @@v4@@ + Number ) >> Number ; } else if ( ! @@v4@@ ) { @@v4@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v4@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v4@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall advance ( char @@a1@@ ) { __int64 @@result@@ ; @@result@@ = ( unsigned int ) ++ pos ; if ( @@a1@@ ) { @@result@@ = ( unsigned int ) argc ; if ( pos >= argc ) beyond ( ) ; } return @@result@@ ; }
void free ( void * @@ptr@@ ) { __imp_free ( @@ptr@@ ) ; }
__int64 __fastcall readtoken ( FILE * @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ , __int64 * @@a4@@ ) { __int64 @@v5@@ ; char @@v8@@ ; int @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@j@@ ; unsigned __int64 @@v14@@ ; @@v14@@ = __readfsqword ( Number ) ; if ( ! @@a2@@ && ! saved_delim_3296 ) abort ( ) ; @@v8@@ = Number ; if ( @@a2@@ != saved_delim_3296 && saved_delim_3296 ) { @@v8@@ = Number ; for ( @@i@@ = Number L ; @@i@@ < @@a3@@ ; ++ @@i@@ ) { if ( * ( _BYTE * ) ( @@a2@@ + @@i@@ ) != * ( _BYTE * ) ( saved_delim_3296 + @@i@@ ) ) { @@v8@@ = Number ; break ; } } } if ( @@v8@@ != Number ) { saved_delim_3296 = @@a2@@ ; memset ( isdelim_3297 , Number , sizeof ( isdelim_3297 ) ) ; for ( @@j@@ = Number L ; @@j@@ < @@a3@@ ; ++ @@j@@ ) isdelim_3297 [ * ( unsigned __int8 * ) ( @@a2@@ + @@j@@ ) ] = Number ; } do @@v9@@ = getc_unlocked ( @@a1@@ ) ; while ( @@v9@@ >= Number && isdelim_3297 [ @@v9@@ ] ) ; @@v11@@ = @@a4@@ [ Number ] ; @@v10@@ = * @@a4@@ ; @@i@@ = Number L ; while ( Number ) { if ( @@v9@@ < Number && ! @@i@@ ) return Number ; if ( @@i@@ == @@v10@@ ) @@v11@@ = x2nrealloc ( @@v11@@ , & @@v10@@ , Number L ) ; if ( @@v9@@ < Number ) { * ( _BYTE * ) ( @@v11@@ + @@i@@ ) = Number ; goto LABEL_28 ; } if ( isdelim_3297 [ @@v9@@ ] ) break ; @@v5@@ = @@i@@ ++ ; * ( _BYTE * ) ( @@v11@@ + @@v5@@ ) = @@v9@@ ; @@v9@@ = getc_unlocked ( @@a1@@ ) ; } * ( _BYTE * ) ( @@v11@@ + @@i@@ ) = Number ; LABEL_28 : @@a4@@ [ Number ] = @@v11@@ ; * @@a4@@ = @@v10@@ ; return @@i@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
_BOOL8 __fastcall posixtest ( int @@a1@@ ) { bool @@v2@@ ; if ( @@a1@@ == Number ) return two_arguments ( ) ; if ( @@a1@@ > Number ) { if ( @@a1@@ == Number ) return ( bool ) three_arguments ( ) ; if ( @@a1@@ == Number ) { if ( ! strcmp ( * ( const char * * ) ( Number L * pos + argv ) , String ) ) { advance ( Number ) ; return ( unsigned __int8 ) three_arguments ( ) == Number ; } if ( ! strcmp ( * ( const char * * ) ( Number L * pos + argv ) , String ) && ! strcmp ( * ( const char * * ) ( Number * ( pos + Number L ) + argv ) , String ) ) { advance ( Number ) ; @@v2@@ = two_arguments ( ) ; advance ( Number ) ; return @@v2@@ ; } } } else if ( @@a1@@ == Number ) { return one_argument ( ) ; } if ( @@a1@@ <= Number ) abort ( ) ; return ( bool ) expr ( ) ; }
__int64 __fastcall hash_get_n_buckets_used ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
_BYTE * __fastcall memchr2 ( const void * @@a1@@ , unsigned __int8 @@a2@@ , unsigned __int8 @@a3@@ , size_t @@a4@@ ) { size_t @@n@@ ; _BYTE * @@i@@ ; _BYTE * @@v7@@ ; _QWORD * @@v8@@ longword ; __int64 @@v9@@ ; __int64 @@v10@@ longword ; __int64 @@v11@@ longword ; __int64 @@v12@@ longword ; @@n@@ = @@a4@@ ; if ( @@a2@@ == @@a3@@ ) return memchr ( @@a1@@ , @@a2@@ , @@a4@@ ) ; for ( @@i@@ = @@a1@@ ; @@n@@ && ( ( unsigned __int8 ) @@i@@ & Number ) != Number ; ++ @@i@@ ) { if ( @@a2@@ == * @@i@@ || @@a3@@ == * @@i@@ ) { return @@i@@ ; } -- @@n@@ ; } @@v8@@ longword = @@i@@ ; @@v11@@ longword = ( @@a3@@ << Number ) | ( unsigned int ) @@a3@@ ; @@v9@@ = ( ( __int64 ) ( ( @@a2@@ << Number ) | ( unsigned int ) @@a2@@ ) << Number ) | ( @@a2@@ << Number ) | ( unsigned int ) @@a2@@ ; @@v10@@ longword = ( @@v9@@ << Number ) | @@v9@@ ; @@v12@@ longword = ( ( ( @@v11@@ longword << Number ) | @@v11@@ longword ) << Number ) | ( @@v11@@ longword << Number ) | @@v11@@ longword ; while ( @@n@@ > Number && ( ( ~ ( @@v12@@ longword ^ * @@v8@@ longword ) & ( ( @@v12@@ longword ^ * @@v8@@ longword ) - Number ) | ~ ( @@v10@@ longword ^ * @@v8@@ longword ) & ( ( @@v10@@ longword ^ * @@v8@@ longword ) - Number ) ) & Number ) == Number ) { ++ @@v8@@ longword ; @@n@@ -= Number L ; } @@v7@@ = @@v8@@ longword ; while ( @@n@@ ) { if ( @@a2@@ == * @@v7@@ || @@a3@@ == * @@v7@@ ) { return @@v7@@ ; } -- @@n@@ ; ++ @@v7@@ ; } return Number L ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
__int64 __fastcall hash_lookup ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; _QWORD * @@i@@ ; _QWORD * @@v5@@ ; @@v2@@ = * @@a1@@ ; @@v5@@ = ( _QWORD * ) ( @@v2@@ + Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) ) ; if ( ( unsigned __int64 ) @@v5@@ >= @@a1@@ [ Number ] ) abort ( ) ; if ( ! * @@v5@@ ) return Number L ; for ( @@i@@ = @@v5@@ ; @@i@@ ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { if ( @@a2@@ == * @@i@@ || ( ( unsigned __int8 ( __fastcall * ) ( __int64 , _QWORD ) ) @@a1@@ [ Number ] ) ( @@a2@@ , * @@i@@ ) ) { return * @@i@@ ; } } return Number L ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
_BOOL8 __fastcall dev_ino_compare ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { return * @@a1@@ == * @@a2@@ && @@a1@@ [ Number ] == @@a2@@ [ Number ] ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , off_6ECF , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
unsigned __int64 __fastcall hash_string ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ ) { unsigned __int64 @@v4@@ ; @@v4@@ = Number L ; while ( * @@a1@@ ) @@v4@@ = ( Number * @@v4@@ + ( unsigned __int8 ) * @@a1@@ ++ ) % @@a2@@ ; return @@v4@@ ; }
int fileno ( FILE * @@stream@@ ) { return fileno ( @@stream@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
unsigned __int64 __fastcall raw_hasher ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return rotr_sz ( @@a1@@ , Number ) % @@a2@@ ; }
__int64 __fastcall file_failure ( unsigned __int8 @@a1@@ , const char * @@a2@@ , __int64 @@a3@@ ) { __int64 @@v3@@ ; int * @@v4@@ ; @@v3@@ = quotearg_colon ( @@a3@@ ) ; @@v4@@ = __errno_location ( ) ; error ( Number , * @@v4@@ , @@a2@@ , @@v3@@ ) ; return set_exit_status ( @@a1@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 __fastcall unsigned_file_size ( __int64 @@a1@@ ) { return @@a1@@ ; }
__int64 __fastcall new_item ( __int64 @@a1@@ ) { __int64 @@v1@@ ; __int64 @@v3@@ ; @@v3@@ = xmalloc ( Number L ) ; if ( @@a1@@ ) @@v1@@ = xstrdup ( @@a1@@ ) ; else @@v1@@ = Number L ; * ( _QWORD * ) @@v3@@ = @@v1@@ ; * ( _QWORD * ) ( @@v3@@ + Number ) = Number L ; * ( _QWORD * ) ( @@v3@@ + Number ) = * ( _QWORD * ) ( @@v3@@ + Number ) ; * ( _DWORD * ) ( @@v3@@ + Number ) = Number ; * ( _QWORD * ) ( @@v3@@ + Number ) = Number L ; * ( _QWORD * ) ( @@v3@@ + Number ) = Number L ; * ( _QWORD * ) ( @@v3@@ + Number ) = Number L ; return @@v3@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
void __fastcall hash_free ( __int64 @@a1@@ ) { _QWORD * @@i@@ ; _QWORD * @@j@@ ; _QWORD * @@ptr@@ ; _QWORD * @@ptra@@ ; _QWORD * @@ptrb@@ ; _QWORD * @@v6@@ ; _QWORD * @@v7@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) && * ( _QWORD * ) ( @@a1@@ + Number ) ) { for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@ptr@@ = @@i@@ ; @@ptr@@ ; @@ptr@@ = ( _QWORD * ) @@ptr@@ [ Number ] ) { ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@ptr@@ ) ; } } } } for ( @@j@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@j@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@j@@ += Number ) { for ( @@ptra@@ = ( _QWORD * ) @@j@@ [ Number ] ; @@ptra@@ ; @@ptra@@ = @@v6@@ ) { @@v6@@ = ( _QWORD * ) @@ptra@@ [ Number ] ; free ( @@ptra@@ ) ; } } for ( @@ptrb@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; @@ptrb@@ ; @@ptrb@@ = @@v7@@ ) { @@v7@@ = ( _QWORD * ) @@ptrb@@ [ Number ] ; free ( @@ptrb@@ ) ; } free ( * ( void * * ) @@a1@@ ) ; free ( ( void * ) @@a1@@ ) ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
_BOOL8 __fastcall perm_related_errno ( int @@a1@@ ) { return @@a1@@ == Number || @@a1@@ == Number ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
__int64 __fastcall make_link_name ( const char * @@a1@@ , const char * @@a2@@ ) { size_t @@v3@@ ; char * @@dest@@ ; char * @@desta@@ ; __int64 @@n@@ ; if ( ! @@a2@@ ) return Number L ; if ( * @@a2@@ == Number ) return xstrdup ( @@a2@@ ) ; @@dest@@ = strrchr ( @@a1@@ , Number ) ; if ( ! @@dest@@ ) return xstrdup ( @@a2@@ ) ; @@n@@ = @@dest@@ - @@a1@@ + Number ; @@v3@@ = strlen ( @@a2@@ ) ; @@desta@@ = ( char * ) xmalloc ( @@v3@@ + @@n@@ + Number ) ; strncpy ( @@desta@@ , @@a1@@ , @@n@@ ) ; strcpy ( & @@desta@@ [ @@n@@ ] , @@a2@@ ) ; return ( __int64 ) @@desta@@ ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
__int64 __fastcall cmp_atime ( _QWORD * @@a1@@ , _QWORD * @@a2@@ , __int64 ( __fastcall * @@a3@@ ( ) ( constchar , constchar ) ) ( _QWORD , _QWORD ) ) { __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@result@@ ; unsigned int @@v10@@ ; @@v3@@ = get_stat_atime ( ( __int64 ) ( @@a1@@ + Number ) ) ; @@v5@@ = @@v4@@ ; @@v6@@ = get_stat_atime ( ( __int64 ) ( @@a2@@ + Number ) ) ; @@v10@@ = timespec_cmp ( @@v6@@ , @@v7@@ , @@v3@@ , @@v5@@ ) ; if ( @@v10@@ ) @@result@@ = @@v10@@ ; else @@result@@ = @@a3@@ ( ) ( constchar , constchar ) ( * @@a1@@ , * @@a2@@ ) ; return @@result@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
__int64 __fastcall cmp_name ( _QWORD * @@a1@@ , _QWORD * @@a2@@ , __int64 ( __fastcall * @@a3@@ ( ) ( constchar , constchar ) ) ( _QWORD , _QWORD ) ) { return @@a3@@ ( ) ( constchar , constchar ) ( * @@a1@@ , * @@a2@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_207028 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
int __fastcall lstat ( char * @@filename@@ , struct stat * @@stat_buf@@ ) { return __lxstat ( Number , @@filename@@ , @@stat_buf@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
__int64 __fastcall rev_strcmp_df_ctime ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_ctime ( @@a2@@ , @@a1@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) & strcmp ) ; }
struct tm * localtime ( const time_t * @@timer@@ ) { return localtime ( @@timer@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
int iswcntrl ( wint_t @@wc@@ ) { return iswcntrl ( @@wc@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return xmalloc ( @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall rev_xstrcoll_df_mtime ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_mtime ( @@a2@@ , @@a1@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) xstrcoll ) ; }
int sigemptyset ( sigset_t * @@set@@ ) { return sigemptyset ( @@set@@ ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
int __xstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _xstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_20B128 ; @@v4@@ [ Number ] = qword_20B130 ; @@v4@@ [ Number ] = qword_20B138 ; @@v4@@ [ Number ] = qword_20B140 ; @@v4@@ [ Number ] = qword_20B148 ; @@v4@@ [ Number ] = qword_20B150 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
int __fxstat ( int @@ver@@ , int @@fildes@@ , struct stat * @@stat_buf@@ ) { return _fxstat ( @@ver@@ , @@fildes@@ , @@stat_buf@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall rev_strcmp_df_atime ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_atime ( @@a2@@ , @@a1@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) & strcmp ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
void * malloc ( size_t @@size@@ ) { return __imp_malloc ( @@size@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@v2@@ ; @@v2@@ = malloc ( @@a1@@ ) ; if ( ! @@v2@@ && @@a1@@ ) xalloc_die ( ) ; return @@v2@@ ; }
__int64 __fastcall get_stat_atime ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int64 __fastcall xstrcoll_df_name ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_name ( @@a1@@ , @@a2@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) xstrcoll ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
__int64 abmon_init ( ) { char * @@v0@@ ; __int64 @@v2@@ ; int @@i@@ ; unsigned __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; unsigned __int64 @@v6@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; required_mon_width = Number L ; do { @@v5@@ = required_mon_width ; required_mon_width = Number L ; for ( @@i@@ = Number ; @@i@@ <= Number ; ++ @@i@@ ) { @@v4@@ = @@v5@@ ; @@v0@@ = nl_langinfo ( @@i@@ + Number ) ; @@v6@@ = mbsalign ( @@v0@@ , ( char * ) & abmon + Number * @@i@@ , Number L , & @@v4@@ , Number L , Number L ) ; if ( @@v6@@ == Number || @@v6@@ > Number ) { required_mon_width = Number L ; return Number L ; } @@v2@@ = required_mon_width ; if ( @@v4@@ >= required_mon_width ) @@v2@@ = @@v4@@ ; required_mon_width = @@v2@@ ; } } while ( @@v5@@ > required_mon_width ) ; return required_mon_width ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 __fastcall rev_strcmp_df_name ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_name ( @@a2@@ , @@a1@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) & strcmp ) ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_207108 ; @@v8@@ [ Number ] = qword_207110 ; @@v8@@ [ Number ] = qword_207118 ; @@v8@@ [ Number ] = qword_207120 ; @@v8@@ [ Number ] = qword_207128 ; @@v8@@ [ Number ] = qword_207130 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
__locale_t newlocale ( int @@category_mask@@ , const char * @@locale@@ , __locale_t @@base@@ ) { return newlocale ( @@category_mask@@ , @@locale@@ , @@base@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
unsigned __int64 process_signals ( ) { int @@sig@@ ; sigset_t @@oset@@ ; unsigned __int64 @@v3@@ ; @@v3@@ = __readfsqword ( Number ) ; while ( interrupt_signal || stop_signal_count ) { if ( used_color ) restore_default_color ( ) ; fflush_unlocked ( stdout ) ; sigprocmask ( Number , & caught_signals , & @@oset@@ ) ; @@sig@@ = interrupt_signal ; if ( stop_signal_count ) { -- stop_signal_count ; raise ( Number ) ; } else { signal ( interrupt_signal , Number L ) ; raise ( @@sig@@ ) ; } sigprocmask ( Number , & @@oset@@ , Number L ) ; } return __readfsqword ( Number ) ^ @@v3@@ ; }
__int64 __fastcall xstrcoll_df_version ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_version ( @@a1@@ , @@a2@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
int puts ( const char * @@s@@ ) { return puts ( @@s@@ ) ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
__int64 clear_files ( ) { __int64 @@result@@ ; unsigned __int64 @@i@@ ; void * * @@v2@@ ; for ( @@i@@ = Number L ; ; ++ @@i@@ ) { @@result@@ = cwd_n_used ; if ( @@i@@ >= cwd_n_used ) break ; @@v2@@ = ( void * * ) * ( ( _QWORD * ) sorted_file + @@i@@ ) ; free ( * @@v2@@ ) ; free ( @@v2@@ [ Number ] ) ; if ( @@v2@@ [ Number ] != & UNKNOWN_SECURITY_CONTEXT ) freecon ( ) ; } cwd_n_used = Number L ; any_has_acl = Number ; inode_number_width = Number ; block_size_width = Number ; nlink_width = Number ; owner_width = Number ; group_width = Number ; author_width = Number ; scontext_width = Number ; major_device_number_width = Number ; minor_device_number_width = Number ; file_size_width = Number ; return @@result@@ ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
__int64 __fastcall format_user_or_group ( const char * @@a1@@ , __int64 @@a2@@ , int @@a3@@ ) { int @@v3@@ ; __int64 @@result@@ ; int @@v7@@ ; int @@v8@@ ; size_t @@v9@@ ; if ( @@a1@@ ) { @@v8@@ = @@a3@@ - gnu_mbswidth ( @@a1@@ , Number L ) ; @@v3@@ = Number ; if ( @@v8@@ >= Number ) @@v3@@ = @@v8@@ ; @@v7@@ = @@v3@@ ; fputs_unlocked ( @@a1@@ , stdout ) ; @@v9@@ = strlen ( @@a1@@ ) + @@v7@@ ; do putchar_unlocked ( Number ) ; while ( @@v7@@ -- ) ; } else { printf ( String , @@a3@@ , @@a2@@ ) ; @@v9@@ = @@a3@@ ; } @@result@@ = dired_pos + @@v9@@ + Number ; dired_pos = @@result@@ ; return @@result@@ ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
__int64 __fastcall cmp_mtime ( _QWORD * @@a1@@ , _QWORD * @@a2@@ , __int64 ( __fastcall * @@a3@@ ( ) ( constchar , constchar ) ) ( _QWORD , _QWORD ) ) { __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@result@@ ; unsigned int @@v10@@ ; @@v3@@ = get_stat_mtime ( ( __int64 ) ( @@a1@@ + Number ) ) ; @@v5@@ = @@v4@@ ; @@v6@@ = get_stat_mtime ( ( __int64 ) ( @@a2@@ + Number ) ) ; @@v10@@ = timespec_cmp ( @@v6@@ , @@v7@@ , @@v3@@ , @@v5@@ ) ; if ( @@v10@@ ) @@result@@ = @@v10@@ ; else @@result@@ = @@a3@@ ( ) ( constchar , constchar ) ( * @@a1@@ , * @@a2@@ ) ; return @@result@@ ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
size_t __fastcall format_user_width ( unsigned int @@a1@@ ) { __int64 @@v1@@ ; if ( numeric_ids ) @@v1@@ = Number L ; else @@v1@@ = getuser ( @@a1@@ ) ; return format_user_or_group_width ( @@v1@@ , @@a1@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall strcmp_df_ctime ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_ctime ( @@a1@@ , @@a2@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) & strcmp ) ; }
int __fastcall record_relation ( __int64 @@a1@@ , __int64 @@a2@@ ) { int @@result@@ ; _QWORD * @@v3@@ ; @@result@@ = strcmp ( * ( const char * * ) @@a1@@ , * ( const char * * ) @@a2@@ ) ; if ( @@result@@ ) { ++ * ( _QWORD * ) ( @@a2@@ + Number ) ; @@v3@@ = ( _QWORD * ) xmalloc ( Number L ) ; * @@v3@@ = @@a2@@ ; @@v3@@ [ Number ] = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@result@@ = @@a1@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v3@@ ; } return @@result@@ ; }
size_t __fastcall print_file_name_and_frills ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { const char * @@v2@@ ; int @@v3@@ ; const char * @@v4@@ ; int @@v5@@ ; int @@v6@@ ; size_t @@v8@@ ; char @@v9@@ [ Number ] ; unsigned __int64 @@v10@@ ; @@v10@@ = __readfsqword ( Number ) ; if ( print_inode ) { @@v2@@ = format_inode ( ( __int64 ) @@v9@@ , Number , @@a1@@ ) ; if ( format == Number ) @@v3@@ = Number ; else @@v3@@ = inode_number_width ; printf ( String , @@v3@@ , @@v2@@ ) ; } if ( print_block_size ) { if ( * ( _BYTE * ) ( @@a1@@ + Number ) != Number ) @@v4@@ = String ; else @@v4@@ = ( const char * ) human_readable ( * ( _QWORD * ) ( @@a1@@ + Number ) , @@v9@@ , ( unsigned int ) human_output_opts , Number L , output_block_size ) ; if ( format == Number ) @@v5@@ = Number ; else @@v5@@ = block_size_width ; printf ( String , @@v5@@ , @@v4@@ ) ; } if ( print_scontext ) { if ( format == Number ) @@v6@@ = Number ; else @@v6@@ = scontext_width ; printf ( String , @@v6@@ , * ( const char * * ) ( @@a1@@ + Number ) ) ; } @@v8@@ = print_name_with_quoting ( ( __int64 * ) @@a1@@ , Number , Number L , @@a2@@ ) ; if ( indicator_style ) @@v8@@ += ( unsigned __int8 ) print_type_indicator ( * ( unsigned __int8 * ) ( @@a1@@ + Number ) , * ( unsigned int * ) ( @@a1@@ + Number ) , * ( unsigned int * ) ( @@a1@@ + Number ) ) ; return @@v8@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
__int64 __fastcall rev_strcmp_df_mtime ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_mtime ( @@a2@@ , @@a1@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) & strcmp ) ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
int __cdecl __noreturn main ( int @@argc@@ , const char * * @@argv@@ , const char * * @@envp@@ ) { __int64 @@v3@@ ; char * @@v4@@ ; const char * @@v5@@ ; unsigned __int8 @@v6@@ ; set_program_name ( * @@argv@@ , @@argv@@ , @@envp@@ ) ; setlocale ( Number , & shortopts ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; parse_long_options ( @@argc@@ , ( _DWORD ) @@argv@@ , ( unsigned int ) String , ( unsigned int ) String , ( _DWORD ) Version , ( unsigned int ) usage , String , Number L ) ; if ( getopt_long ( @@argc@@ , ( char * const * ) @@argv@@ , & shortopts , Number L , Number L ) != Number ) usage ( Number ) ; if ( @@argc@@ - optind > Number ) { @@v3@@ = quote ( @@argv@@ [ optind + Number ] ) ; @@v4@@ = gettext ( String ) ; error ( Number , Number , @@v4@@ , @@v3@@ ) ; usage ( Number ) ; } if ( @@argc@@ == optind ) @@v5@@ = String ; else @@v5@@ = @@argv@@ [ optind ] ; @@v6@@ = tsort ( @@v5@@ ) ; exit ( @@v6@@ ^ Number ) ; }
size_t __fastcall put_indicator ( __int64 @@a1@@ ) { if ( used_color != Number ) { used_color = Number ; prep_non_filename_text ( ) ; } return fwrite_unlocked ( * ( const void * * ) ( @@a1@@ + Number ) , * ( _QWORD * ) @@a1@@ , Number , stdout ) ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
__int64 __fastcall xstrcoll_df_size ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_size ( @@a1@@ , @@a2@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) xstrcoll ) ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
int print_horizontal ( ) { unsigned __int64 @@i@@ ; unsigned __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; @@v2@@ = Number L ; @@v5@@ = calculate_columns ( Number L ) ; @@v6@@ = column_info + Number * @@v5@@ - Number ; @@v7@@ = * ( _QWORD * ) sorted_file ; @@v3@@ = length_of_file_name_and_frills ( * ( _QWORD * ) sorted_file ) ; @@v4@@ = * * ( _QWORD * * ) ( @@v6@@ + Number ) ; print_file_name_and_frills ( @@v7@@ , Number L ) ; for ( @@i@@ = Number L ; @@i@@ < cwd_n_used ; ++ @@i@@ ) { if ( @@i@@ % @@v5@@ ) { indent ( @@v2@@ + @@v3@@ , @@v4@@ + @@v2@@ ) ; @@v2@@ += @@v4@@ ; } else { putchar_unlocked ( Number ) ; @@v2@@ = Number L ; } @@v8@@ = * ( ( _QWORD * ) sorted_file + @@i@@ ) ; print_file_name_and_frills ( @@v8@@ , @@v2@@ ) ; @@v3@@ = length_of_file_name_and_frills ( @@v8@@ ) ; @@v4@@ = * ( _QWORD * ) ( Number * ( @@i@@ % @@v5@@ ) + * ( _QWORD * ) ( @@v6@@ + Number ) ) ; } return putchar_unlocked ( Number ) ; }
__int64 __fastcall rev_xstrcoll_df_extension ( const char * * @@a1@@ , const char * * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_extension ( @@a2@@ , @@a1@@ , xstrcoll ) ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
__int64 sort_files ( ) { __int64 @@result@@ ; int @@v1@@ ; unsigned __int8 @@v2@@ ; if ( cwd_n_used + ( ( unsigned __int64 ) cwd_n_used >> Number ) > sorted_file_alloc ) { free ( sorted_file ) ; sorted_file = ( void * ) xnmalloc ( cwd_n_used , Number L ) ; sorted_file_alloc = Number * cwd_n_used ; } initialize_ordering_vector ( ) ; @@result@@ = ( unsigned int ) sort_type ; if ( sort_type != Number ) { if ( _setjmp ( failed_strcoll ) ) { @@v2@@ = Number ; if ( sort_type == Number ) __assert_fail ( String , String , Number , String ) ; initialize_ordering_vector ( ) ; } else { @@v2@@ = Number ; } if ( sort_type == Number ) @@v1@@ = time_type ; else @@v1@@ = Number ; @@result@@ = mpsort ( sorted_file , cwd_n_used , * ( & sort_functions [ Number * ( unsigned int ) ( @@v1@@ + sort_type ) ] + Number * @@v2@@ + Number * ( unsigned __int8 ) sort_reverse + ( unsigned __int8 ) directories_first ) ) ; } return @@result@@ ; }
char * __fastcall areadlink_with_size ( const char * @@a1@@ , unsigned __int64 @@a2@@ ) { __int64 @@v2@@ ; char * @@i@@ ; int @@v5@@ ; size_t @@size@@ ; char * @@buf@@ ; ssize_t @@v8@@ ; if ( @@a2@@ >= Number ) @@v2@@ = Number L ; else @@v2@@ = @@a2@@ + Number ; @@size@@ = @@v2@@ ; LABEL_5 : for ( @@i@@ = ( char * ) malloc ( @@size@@ ) ; ; @@i@@ = ( char * ) malloc ( Number ) ) { @@buf@@ = @@i@@ ; if ( ! @@i@@ ) return Number L ; @@v8@@ = readlink ( @@a1@@ , @@i@@ , @@size@@ ) ; if ( @@v8@@ < Number && * __errno_location ( ) != Number ) { @@v5@@ = * __errno_location ( ) ; free ( @@buf@@ ) ; * __errno_location ( ) = @@v5@@ ; return Number L ; } if ( @@v8@@ < @@size@@ ) { @@buf@@ [ @@v8@@ ] = Number ; return @@buf@@ ; } free ( @@buf@@ ) ; if ( @@size@@ <= Number ) { @@size@@ *= Number L ; goto LABEL_5 ; } if ( @@size@@ > Number ) break ; @@size@@ = Number ; } * __errno_location ( ) = Number ; return Number L ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_207028 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
size_t __fastcall format_user_or_group_width ( __int64 @@a1@@ , __int64 @@a2@@ ) { size_t @@result@@ ; int @@v3@@ ; char @@s@@ [ Number ] ; unsigned __int64 @@v5@@ ; @@v5@@ = __readfsqword ( Number ) ; if ( @@a1@@ ) { @@v3@@ = gnu_mbswidth ( @@a1@@ , Number L ) ; @@result@@ = Number L ; if ( @@v3@@ >= Number ) @@result@@ = ( unsigned int ) @@v3@@ ; } else { sprintf ( @@s@@ , String , @@a2@@ ) ; @@result@@ = strlen ( @@s@@ ) ; } return @@result@@ ; }
__int64 __fastcall wc_ensure_printable ( wint_t * @@a1@@ ) { unsigned __int8 @@v2@@ ; @@v2@@ = Number ; while ( * @@a1@@ ) { if ( ! iswprint ( * @@a1@@ ) ) { * @@a1@@ = Number ; @@v2@@ = Number ; } ++ @@a1@@ ; } return @@v2@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
_BYTE * __fastcall mbs_align_pad ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ ) { _BYTE * @@v3@@ ; __int64 @@v4@@ ; while ( Number ) { @@v4@@ = @@a3@@ -- ; if ( ! @@v4@@ || ( unsigned __int64 ) @@a1@@ >= @@a2@@ ) break ; @@v3@@ = @@a1@@ ++ ; * @@v3@@ = Number ; } * @@a1@@ = Number ; return @@a1@@ ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_2070E8 ; @@v8@@ [ Number ] = qword_2070F0 ; @@v8@@ [ Number ] = qword_2070F8 ; @@v8@@ [ Number ] = qword_207100 ; @@v8@@ [ Number ] = qword_207108 ; @@v8@@ [ Number ] = qword_207110 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
bool __fastcall print_type_indicator ( char @@a1@@ , __int16 @@a2@@ , int @@a3@@ ) { char @@v4@@ ; @@v4@@ = get_type_indicator ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( @@v4@@ ) { putchar_unlocked ( @@v4@@ ) ; ++ dired_pos ; } return @@v4@@ != Number ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ ) { return xmalloc ( @@a1@@ ) ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@v3@@ ; @@v3@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v3@@ ) xalloc_die ( ) ; return @@v3@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
unsigned __int64 print_many_per_line ( ) { __int64 @@v0@@ ; unsigned __int64 @@result@@ ; unsigned __int64 @@i@@ ; __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; unsigned __int64 @@j@@ ; unsigned __int64 @@v6@@ ; __int64 @@v7@@ ; unsigned __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; @@v6@@ = calculate_columns ( Number L ) ; @@v7@@ = column_info + Number * @@v6@@ - Number ; @@v8@@ = cwd_n_used / @@v6@@ + ( cwd_n_used % @@v6@@ != Number ) ; for ( @@i@@ = Number L ; ; ++ @@i@@ ) { @@result@@ = @@i@@ ; if ( @@i@@ >= @@v8@@ ) break ; @@v3@@ = Number L ; @@v4@@ = @@i@@ ; for ( @@j@@ = Number L ; ; @@j@@ += @@v11@@ ) { @@v9@@ = * ( ( _QWORD * ) sorted_file + @@v4@@ ) ; @@v10@@ = length_of_file_name_and_frills ( @@v9@@ ) ; @@v0@@ = @@v3@@ ++ ; @@v11@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( @@v7@@ + Number ) + Number * @@v0@@ ) ; print_file_name_and_frills ( @@v9@@ , @@j@@ ) ; @@v4@@ += @@v8@@ ; if ( @@v4@@ >= cwd_n_used ) break ; indent ( @@j@@ + @@v10@@ , @@v11@@ + @@j@@ ) ; } putchar_unlocked ( Number ) ; } return @@result@@ ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
__int64 __fastcall bkm_scale ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( * @@a1@@ >= ( __int64 ) Number / @@a2@@ ) { if ( Number / @@a2@@ >= * @@a1@@ ) { * @@a1@@ *= @@a2@@ ; @@result@@ = Number L ; } else { * @@a1@@ = Number ; @@result@@ = Number L ; } } else { * @@a1@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall xsum ( unsigned __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; if ( @@a1@@ + @@a2@@ < @@a1@@ ) @@result@@ = Number ; else @@result@@ = @@a1@@ + @@a2@@ ; return @@result@@ ; }
int __fastcall argmatch_valid ( __int64 @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { char * @@v3@@ ; __int64 @@i@@ ; void * @@s1@@ ; @@s1@@ = Number L ; @@v3@@ = gettext ( String ) ; fprintf ( stderr , @@v3@@ ) ; for ( @@i@@ = Number L ; * ( _QWORD * ) ( Number * @@i@@ + @@a1@@ ) ; ++ @@i@@ ) { if ( @@i@@ && ! memcmp ( @@s1@@ , ( const void * ) ( @@i@@ * @@a3@@ + @@a2@@ ) , @@a3@@ ) ) { fprintf ( stderr , String , * ( const char * * ) ( Number * @@i@@ + @@a1@@ ) ) ; } else { fprintf ( stderr , String , * ( const char * * ) ( Number * @@i@@ + @@a1@@ ) ) ; @@s1@@ = ( void * ) ( @@i@@ * @@a3@@ + @@a2@@ ) ; } } return putc_unlocked ( Number , stderr ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
_BYTE * __fastcall attach ( _BYTE * @@a1@@ , _BYTE * @@a2@@ , _BYTE * @@a3@@ ) { _BYTE * @@v3@@ ; _BYTE * @@v4@@ ; _BYTE * @@v5@@ ; _BYTE * @@v6@@ ; _BYTE * @@v7@@ ; _BYTE * @@result@@ ; _BYTE * @@v11@@ ; @@v11@@ = @@a2@@ ; if ( * @@a2@@ != Number || @@a2@@ [ Number ] ) { while ( * @@v11@@ ) { @@v3@@ = @@v11@@ ++ ; @@v4@@ = @@a1@@ ++ ; * @@v4@@ = * @@v3@@ ; } if ( @@v11@@ > @@a2@@ && * ( @@v11@@ - Number ) != Number ) { @@v5@@ = @@a1@@ ++ ; * @@v5@@ = Number ; } } while ( * @@a3@@ ) { @@v6@@ = @@a3@@ ++ ; @@v7@@ = @@a1@@ ++ ; * @@v7@@ = * @@v6@@ ; } @@result@@ = @@a1@@ ; * @@a1@@ = Number ; return @@result@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
__int64 __fastcall order ( unsigned __int8 @@a1@@ ) { if ( ( unsigned __int8 ) c_isdigit ( @@a1@@ ) ) return Number L ; if ( ( unsigned __int8 ) c_isalpha ( @@a1@@ ) ) return @@a1@@ ; if ( @@a1@@ == Number ) return Number ; return ( unsigned int ) @@a1@@ + Number ; }
__int64 decimal_point_char ( ) { __int64 @@result@@ ; char * @@v1@@ ; @@v1@@ = nl_langinfo ( Number ) ; if ( * @@v1@@ ) @@result@@ = ( unsigned __int8 ) * @@v1@@ ; else @@result@@ = Number L ; return @@result@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 __fastcall wc_truncate ( wchar_t * @@a1@@ , unsigned __int64 @@a2@@ ) { int @@v4@@ ; __int64 @@v5@@ ; @@v5@@ = Number L ; while ( * @@a1@@ ) { @@v4@@ = wcwidth ( * @@a1@@ ) ; if ( @@v4@@ == Number ) { * @@a1@@ = Number ; @@v4@@ = Number ; } if ( @@a2@@ < @@v4@@ + @@v5@@ ) break ; @@v5@@ += @@v4@@ ; ++ @@a1@@ ; } * @@a1@@ = Number ; return @@v5@@ ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
void * __fastcall mfile_name_concat ( _BYTE * @@a1@@ , _BYTE * @@a2@@ , _QWORD * @@a3@@ ) { _BOOL4 @@v3@@ ; const char * @@v6@@ ; size_t @@v7@@ ; size_t @@n@@ ; _BOOL8 @@v9@@ ; char * @@s@@ ; size_t @@v11@@ ; void * @@dest@@ ; _BYTE * @@v13@@ ; char * @@v14@@ ; @@v6@@ = last_component ( @@a1@@ ) ; @@v7@@ = base_len ( @@v6@@ ) ; @@n@@ = @@v6@@ - @@a1@@ + @@v7@@ ; @@v3@@ = @@v7@@ && @@v6@@ [ @@v7@@ - Number ] != Number ; @@v9@@ = @@v3@@ ; @@s@@ = longest_relative_suffix ( @@a2@@ ) ; @@v11@@ = strlen ( @@s@@ ) ; @@dest@@ = malloc ( @@v9@@ + @@n@@ + @@v11@@ + Number ) ; if ( ! @@dest@@ ) return Number L ; @@v13@@ = mempcpy ( @@dest@@ , @@a1@@ , @@n@@ ) ; * @@v13@@ = Number ; @@v14@@ = & @@v13@@ [ @@v9@@ ] ; if ( @@a3@@ ) * @@a3@@ = & @@v14@@ [ - ( * @@a2@@ == Number ) ] ; * ( _BYTE * ) mempcpy ( @@v14@@ , @@s@@ , @@v11@@ ) = Number ; return @@dest@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 __fastcall hash_lookup ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; _QWORD * @@i@@ ; _QWORD * @@v5@@ ; @@v2@@ = * @@a1@@ ; @@v5@@ = ( _QWORD * ) ( @@v2@@ + Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) ) ; if ( ( unsigned __int64 ) @@v5@@ >= @@a1@@ [ Number ] ) abort ( ) ; if ( ! * @@v5@@ ) return Number L ; for ( @@i@@ = @@v5@@ ; @@i@@ ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { if ( @@a2@@ == * @@i@@ || ( ( unsigned __int8 ( __fastcall * ) ( __int64 , _QWORD ) ) @@a1@@ [ Number ] ) ( @@a2@@ , * @@i@@ ) ) { return * @@i@@ ; } } return Number L ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
void __fastcall argmatch_invalid ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { char * @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; char * @@format@@ ; if ( @@a3@@ == Number ) @@v3@@ = gettext ( String ) ; else @@v3@@ = gettext ( String ) ; @@format@@ = @@v3@@ ; @@v4@@ = quote_n ( Number L , @@a1@@ ) ; @@v5@@ = quotearg_n_style ( Number L , Number L , @@a2@@ ) ; error ( Number , Number , @@format@@ , @@v5@@ , @@v4@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
__int64 __fastcall hash_do_for_each ( __int64 @@a1@@ , unsigned __int8 ( __fastcall * @@a2@@ ) ( _QWORD , __int64 ) , __int64 @@a3@@ ) { __int64 @@v5@@ ; _QWORD * @@i@@ ; _QWORD * @@j@@ ; @@v5@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = @@i@@ ; @@j@@ ; @@j@@ = ( _QWORD * ) @@j@@ [ Number ] ) { if ( @@a2@@ ( * @@j@@ , @@a3@@ ) != Number ) return @@v5@@ ; ++ @@v5@@ ; } } } return @@v5@@ ; }
const char * __fastcall get_default_format ( __int64 a1 , __int64 a2 , __int64 a3 , __int64 a4 , __int64 a5 , __int64 a6 , int a7 , int a8 , __int64 @@a9@@ , int @@a10@@ , int a11 , int a12 , int a13 , int @@a14@@ , int a15 , int a16 , __int64 @@a17@@ , int @@a18@@ ) { unsigned int @@v18@@ ; unsigned __int64 @@v19@@ ; unsigned int @@v21@@ ; unsigned __int64 @@v22@@ ; unsigned __int64 @@v23@@ ; @@v18@@ = @@a10@@ ; if ( @@a14@@ >= @@a10@@ ) @@v18@@ = @@a14@@ ; @@v21@@ = @@v18@@ ; if ( @@v18@@ != Number && @@a18@@ != Number ) { if ( ! equal_width ) { sprintf ( format_buf_5549 , String , @@v18@@ ) ; return format_buf_5549 ; } @@v23@@ = @@a9@@ + ( int ) ( @@v18@@ - @@a10@@ ) ; @@v22@@ = @@a17@@ + ( int ) ( @@v18@@ - @@a18@@ ) ; if ( @@a18@@ && ! @@v18@@ ) -- @@v22@@ ; if ( ! @@a18@@ && @@v18@@ ) ++ @@v22@@ ; @@v19@@ = @@a9@@ + ( int ) ( @@v18@@ - @@a10@@ ) ; if ( @@v22@@ >= @@v23@@ ) @@v19@@ = @@v22@@ ; if ( @@v19@@ <= Number ) { sprintf ( format_buf_5549 , String , ( unsigned int ) @@v19@@ , @@v21@@ ) ; return format_buf_5549 ; } } return String ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
__int64 __fastcall check_tuning ( __int64 @@a1@@ ) { __int64 @@v2@@ ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( ( _UNKNOWN * ) @@v2@@ == & default_tuning ) return Number L ; if ( * ( float * ) ( @@v2@@ + Number ) > Number && ( float ) ( Number - Number ) > * ( float * ) ( @@v2@@ + Number ) && * ( float * ) ( @@v2@@ + Number ) > ( float ) ( Number + Number ) && * ( float * ) @@v2@@ >= Number && * ( float * ) ( @@v2@@ + Number ) > ( float ) ( * ( float * ) @@v2@@ + Number ) && * ( float * ) ( @@v2@@ + Number ) <= Number && * ( float * ) ( @@v2@@ + Number ) > ( float ) ( * ( float * ) @@v2@@ + Number ) ) { return Number L ; } * ( _QWORD * ) ( @@a1@@ + Number ) = & default_tuning ; return Number L ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
unsigned __int8 * __fastcall find_int ( unsigned __int8 * @@a1@@ ) { const unsigned __int16 * @@v1@@ ; unsigned __int8 * @@v2@@ ; const unsigned __int16 * @@v3@@ ; __int64 @@v5@@ ; char * @@v6@@ ; unsigned __int8 * @@i@@ ; unsigned __int8 * @@v8@@ ; unsigned __int8 * @@v9@@ ; unsigned __int8 * @@v10@@ ; for ( @@i@@ = @@a1@@ ; ; ++ @@i@@ ) { @@v1@@ = * __ctype_b_loc ( ) ; if ( ( @@v1@@ [ ( unsigned __int8 ) to_uchar ( * @@i@@ ) ] & Number ) == Number ) break ; } if ( * @@i@@ == Number ) { @@v8@@ = @@i@@ + Number ; @@v10@@ = @@v8@@ ; } else { @@v10@@ = @@i@@ ; @@v8@@ = & @@i@@ [ * @@i@@ == Number ] ; } @@v2@@ = @@v8@@ ; @@v9@@ = @@v8@@ + Number ; if ( ( unsigned int ) ( ( char ) * @@v2@@ - Number ) > Number ) goto LABEL_16 ; while ( ( unsigned int ) ( ( char ) * @@v9@@ - Number ) <= Number ) ++ @@v9@@ ; while ( Number ) { @@v3@@ = * __ctype_b_loc ( ) ; if ( ( @@v3@@ [ ( unsigned __int8 ) to_uchar ( * @@v9@@ ) ] & Number ) == Number ) break ; ++ @@v9@@ ; } if ( * @@v9@@ ) { LABEL_16 : @@v5@@ = quote ( @@a1@@ ) ; @@v6@@ = gettext ( String ) ; test_syntax_error ( @@v6@@ , @@v5@@ ) ; } return @@v10@@ ; }
__int64 __fastcall file_name_concat ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v4@@ ; @@v4@@ = mfile_name_concat ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( ! @@v4@@ ) xalloc_die ( ) ; return @@v4@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
void __fastcall hash_free ( __int64 @@a1@@ ) { _QWORD * @@i@@ ; _QWORD * @@j@@ ; _QWORD * @@ptr@@ ; _QWORD * @@ptra@@ ; _QWORD * @@ptrb@@ ; _QWORD * @@v6@@ ; _QWORD * @@v7@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) && * ( _QWORD * ) ( @@a1@@ + Number ) ) { for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@ptr@@ = @@i@@ ; @@ptr@@ ; @@ptr@@ = ( _QWORD * ) @@ptr@@ [ Number ] ) { ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@ptr@@ ) ; } } } } for ( @@j@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@j@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@j@@ += Number ) { for ( @@ptra@@ = ( _QWORD * ) @@j@@ [ Number ] ; @@ptra@@ ; @@ptra@@ = @@v6@@ ) { @@v6@@ = ( _QWORD * ) @@ptra@@ [ Number ] ; free ( @@ptra@@ ) ; } } for ( @@ptrb@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; @@ptrb@@ ; @@ptrb@@ = @@v7@@ ) { @@v7@@ = ( _QWORD * ) @@ptrb@@ [ Number ] ; free ( @@ptrb@@ ) ; } free ( * ( void * * ) @@a1@@ ) ; free ( ( void * ) @@a1@@ ) ; }
long double __fastcall c_strtold ( const char * @@a1@@ , char * * @@a2@@ ) { struct __locale_struct * @@loc@@ ; @@loc@@ = ( struct __locale_struct * ) c_locale ( ) ; if ( @@loc@@ ) return strtold_l ( @@a1@@ , @@a2@@ , @@loc@@ ) ; if ( @@a2@@ ) * @@a2@@ = ( char * ) @@a1@@ ; return Number ; }
__int64 __fastcall hash_get_n_buckets ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
int __cdecl __noreturn main ( int @@argc@@ , const char * * @@argv@@ , const char * * @@envp@@ ) { __int64 @@v3@@ ; char * @@v4@@ ; bool @@v5@@ ; set_program_name ( * @@argv@@ , @@argv@@ , @@envp@@ ) ; setlocale ( Number , & locale ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; initialize_exit_failure ( Number ) ; atexit ( close_stdout ) ; argv = ( __int64 ) @@argv@@ ; argc = @@argc@@ ; pos = Number ; if ( @@argc@@ <= Number ) exit ( Number ) ; @@v5@@ = posixtest ( argc - Number ) ; if ( pos != argc ) { @@v3@@ = quote ( * ( _QWORD * ) ( Number L * pos + argv ) ) ; @@v4@@ = gettext ( String ) ; test_syntax_error ( @@v4@@ , @@v3@@ ) ; } exit ( ! @@v5@@ ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
__int64 __fastcall hash_get_n_entries ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
char * __fastcall group_number ( char * @@a1@@ , size_t @@a2@@ , unsigned __int8 * @@a3@@ , const char * @@a4@@ ) { char * @@i@@ ; size_t @@v5@@ ; char * @@v6@@ ; unsigned __int8 @@v10@@ ; size_t @@v11@@ ; size_t @@v12@@ ; size_t @@v13@@ ; char @@dest@@ [ Number ] ; unsigned __int64 @@v15@@ ; @@v15@@ = __readfsqword ( Number ) ; @@v11@@ = Number ; @@v13@@ = strlen ( @@a4@@ ) ; @@v12@@ = @@a2@@ ; memcpy ( @@dest@@ , @@a1@@ , @@a2@@ ) ; for ( @@i@@ = & @@a1@@ [ @@a2@@ ] ; ; memcpy ( @@i@@ , @@a4@@ , @@v13@@ ) ) { @@v10@@ = * @@a3@@ ; if ( * @@a3@@ ) { if ( @@v10@@ > Number ) @@v5@@ = @@v12@@ ; else @@v5@@ = @@v10@@ ; @@v11@@ = @@v5@@ ; ++ @@a3@@ ; } if ( @@v12@@ < @@v11@@ ) @@v11@@ = @@v12@@ ; @@v6@@ = & @@i@@ [ - @@v11@@ ] ; @@v12@@ -= @@v11@@ ; memcpy ( @@v6@@ , & @@dest@@ [ @@v12@@ ] , @@v11@@ ) ; if ( ! @@v12@@ ) break ; @@i@@ = & @@v6@@ [ - @@v13@@ ] ; } return @@v6@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall getuser ( __uid_t @@a1@@ ) { const char * @@v1@@ ; size_t @@v2@@ ; __int64 @@result@@ ; __int64 @@i@@ ; __int64 @@v5@@ ; struct passwd * @@v6@@ ; char * @@s@@ ; @@v5@@ = Number L ; for ( @@i@@ = user_alist ; @@i@@ ; @@i@@ = * ( _QWORD * ) ( @@i@@ + Number ) ) { if ( @@a1@@ == * ( _DWORD * ) @@i@@ ) { @@v5@@ = @@i@@ ; break ; } } if ( ! @@v5@@ ) { @@v6@@ = getpwuid ( @@a1@@ ) ; if ( @@v6@@ ) @@v1@@ = @@v6@@ -> pw_name ; else @@v1@@ = ( const char * ) & unk_19CC0 ; @@s@@ = ( char * ) @@v1@@ ; @@v2@@ = strlen ( @@v1@@ ) ; @@v5@@ = xmalloc ( @@v2@@ + Number ) ; * ( _DWORD * ) @@v5@@ = @@a1@@ ; strcpy ( ( char * ) ( @@v5@@ + Number ) , @@s@@ ) ; * ( _QWORD * ) ( @@v5@@ + Number ) = user_alist ; user_alist = @@v5@@ ; } if ( * ( _BYTE * ) ( @@v5@@ + Number ) ) @@result@@ = @@v5@@ + Number ; else @@result@@ = Number L ; return @@result@@ ; }
__int64 __fastcall hash_get_first ( unsigned __int64 * @@a1@@ ) { unsigned __int64 @@i@@ ; if ( ! @@a1@@ [ Number ] ) return Number L ; for ( @@i@@ = * @@a1@@ ; ; @@i@@ += Number L ) { if ( @@i@@ >= @@a1@@ [ Number ] ) abort ( ) ; if ( * ( _QWORD * ) @@i@@ ) break ; } return * ( _QWORD * ) @@i@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
unsigned __int64 __fastcall hash_string ( _BYTE * @@a1@@ , unsigned __int64 @@a2@@ ) { unsigned __int64 @@v4@@ ; @@v4@@ = Number L ; while ( * @@a1@@ ) @@v4@@ = ( Number * @@v4@@ + ( unsigned __int8 ) * @@a1@@ ++ ) % @@a2@@ ; return @@v4@@ ; }
void * __fastcall mpsort_into_tmp ( __int64 * @@a1@@ , unsigned __int64 @@a2@@ , _QWORD * @@a3@@ , __int64 ( __fastcall * @@a4@@ ) ( __int64 , __int64 ) ) { int @@i@@ ; _QWORD * @@v5@@ ; _QWORD * @@v6@@ ; _QWORD * @@dest@@ ; unsigned __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; unsigned __int64 @@v12@@ ; __int64 @@v13@@ ; __int64 @@v14@@ ; @@dest@@ = @@a3@@ ; @@v10@@ = Number L ; @@v11@@ = @@a2@@ >> Number ; @@v12@@ = @@a2@@ >> Number ; mpsort_with_tmp ( & @@a1@@ [ @@a2@@ >> Number ] , @@a2@@ - ( @@a2@@ >> Number ) , @@a3@@ , @@a4@@ ) ; mpsort_with_tmp ( @@a1@@ , @@a2@@ >> Number , @@dest@@ , @@a4@@ ) ; @@v13@@ = * @@a1@@ ; @@v14@@ = @@a1@@ [ @@a2@@ >> Number ] ; for ( @@i@@ = @@a4@@ ( * @@a1@@ , @@v14@@ ) ; ; @@i@@ = @@a4@@ ( @@v13@@ , @@v14@@ ) ) { while ( @@i@@ > Number ) { @@v6@@ = @@dest@@ ++ ; * @@v6@@ = @@v14@@ ; if ( ++ @@v12@@ == @@a2@@ ) return memcpy ( @@dest@@ , & @@a1@@ [ @@v10@@ ] , Number * ( @@v11@@ - @@v10@@ ) ) ; @@v14@@ = @@a1@@ [ @@v12@@ ] ; @@i@@ = @@a4@@ ( @@v13@@ , @@v14@@ ) ; } @@v5@@ = @@dest@@ ++ ; * @@v5@@ = @@v13@@ ; if ( ++ @@v10@@ == @@v11@@ ) break ; @@v13@@ = @@a1@@ [ @@v10@@ ] ; } @@v10@@ = @@v12@@ ; @@v11@@ = @@a2@@ ; return memcpy ( @@dest@@ , & @@a1@@ [ @@v10@@ ] , Number * ( @@v11@@ - @@v10@@ ) ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
bool __fastcall is_prime ( unsigned __int64 @@a1@@ ) { unsigned __int64 @@v2@@ ; unsigned __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; @@v2@@ = Number L ; @@v4@@ = Number L ; while ( @@v4@@ < @@a1@@ && @@a1@@ % @@v2@@ ) { @@v3@@ = @@v2@@ + Number ; @@v4@@ += Number * @@v3@@ ; @@v2@@ = @@v3@@ + Number ; } return @@a1@@ % @@v2@@ != Number ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_20D028 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
size_t * __fastcall hash_initialize ( __int64 @@a1@@ , void * @@a2@@ , unsigned __int64 ( __fastcall * @@a3@@ ) ( __int64 a1 , unsigned __int64 a2 ) , bool ( __fastcall * @@a4@@ ) ( __int64 a1 , __int64 a2 ) , size_t @@a5@@ ) { size_t * @@result@@ ; bool ( __fastcall * @@v7@@ ) ( __int64 , __int64 ) ; unsigned __int64 ( __fastcall * @@v8@@ ) ( __int64 , unsigned __int64 ) ; void * @@v9@@ ; size_t * @@ptr@@ ; @@v9@@ = @@a2@@ ; @@v8@@ = @@a3@@ ; @@v7@@ = @@a4@@ ; if ( ! @@a3@@ ) @@v8@@ = raw_hasher ; if ( ! @@a4@@ ) @@v7@@ = raw_comparator ; @@ptr@@ = ( size_t * ) malloc ( Number ) ; if ( ! @@ptr@@ ) return Number L ; if ( ! @@a2@@ ) @@v9@@ = & default_tuning ; @@ptr@@ [ Number ] = ( size_t ) @@v9@@ ; if ( ( unsigned __int8 ) check_tuning ( ( __int64 ) @@ptr@@ ) == Number && ( @@ptr@@ [ Number ] = compute_bucket_size ( @@a1@@ , ( __int64 ) @@v9@@ ) ) != Number && ( * @@ptr@@ = ( size_t ) calloc ( @@ptr@@ [ Number ] , Number ) ) != Number ) { @@ptr@@ [ Number ] = Number * @@ptr@@ [ Number ] + * @@ptr@@ ; @@ptr@@ [ Number ] = Number L ; @@ptr@@ [ Number ] = Number L ; @@ptr@@ [ Number ] = ( size_t ) @@v8@@ ; @@ptr@@ [ Number ] = ( size_t ) @@v7@@ ; @@ptr@@ [ Number ] = @@a5@@ ; @@ptr@@ [ Number ] = Number L ; @@result@@ = @@ptr@@ ; } else { free ( @@ptr@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall bkm_scale_by_power ( __int64 * @@a1@@ , int @@a2@@ , int @@a3@@ ) { unsigned int @@i@@ ; for ( @@i@@ = Number ; @@a3@@ -- ; @@i@@ |= bkm_scale ( @@a1@@ , @@a2@@ ) ) ; return @@i@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_20D028 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_2090A8 ; @@v4@@ [ Number ] = qword_2090B0 ; @@v4@@ [ Number ] = qword_2090B8 ; @@v4@@ [ Number ] = qword_2090C0 ; @@v4@@ [ Number ] = qword_2090C8 ; @@v4@@ [ Number ] = qword_2090D0 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
void * __fastcall allocate_entry ( __int64 @@a1@@ ) { __int64 @@v2@@ ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return malloc ( Number ) ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = * ( _QWORD * ) ( @@v2@@ + Number ) ; return ( void * ) @@v2@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 __fastcall umaxtostr ( unsigned __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v4@@ ; @@v4@@ = @@a2@@ + Number ; * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; do { * ( _BYTE * ) -- @@v4@@ = @@a1@@ % Number + Number ; @@a1@@ /= Number ; } while ( @@a1@@ ) ; return @@v4@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
__int64 __fastcall hash_rehash ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; unsigned __int64 @@nmemb@@ ; void * @@v4@@ ; __int64 @@v5@@ ; unsigned __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; __int64 @@v12@@ ; __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; @@v14@@ = __readfsqword ( Number ) ; @@nmemb@@ = compute_bucket_size ( @@a2@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ; if ( ! @@nmemb@@ ) return Number L ; if ( @@nmemb@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; @@v4@@ = calloc ( @@nmemb@@ , Number ) ; if ( ! @@v4@@ ) return Number L ; @@v6@@ = @@nmemb@@ ; @@v5@@ = ( __int64 ) @@v4@@ + Number * @@nmemb@@ ; @@v7@@ = Number L ; @@v8@@ = Number L ; @@v9@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v10@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v11@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v12@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v13@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( ( unsigned __int8 ) transfer_entries ( ( __int64 ) & @@v4@@ , @@a1@@ , Number ) ) { free ( * ( void * * ) @@a1@@ ) ; * ( _QWORD * ) @@a1@@ = @@v4@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v5@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v6@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v7@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v13@@ ; @@result@@ = Number L ; } else { * ( _QWORD * ) ( @@a1@@ + Number ) = @@v13@@ ; if ( ( unsigned __int8 ) transfer_entries ( @@a1@@ , ( __int64 ) & @@v4@@ , Number ) != Number || ( unsigned __int8 ) transfer_entries ( @@a1@@ , ( __int64 ) & @@v4@@ , Number ) != Number ) { abort ( ) ; } free ( @@v4@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@v2@@ ; @@v2@@ = malloc ( @@a1@@ ) ; if ( ! @@v2@@ && @@a1@@ ) xalloc_die ( ) ; return @@v2@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall human_options ( char * @@a1@@ , int * @@a2@@ , _QWORD * @@a3@@ ) { unsigned int @@v5@@ ; @@v5@@ = humblock ( @@a1@@ , @@a3@@ , @@a2@@ ) ; if ( ! * @@a3@@ ) { * @@a3@@ = default_block_size ( ) ; @@v5@@ = Number ; } return @@v5@@ ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) _frame_dummy_init_array_entry [ @@i@@ ] ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
int toupper ( int @@c@@ ) { return toupper ( @@c@@ ) ; }
__int64 __fastcall xsum4 ( unsigned __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ ) { __int64 @@v4@@ ; __int64 @@v5@@ ; @@v4@@ = xsum ( @@a1@@ , @@a2@@ ) ; @@v5@@ = xsum ( @@v4@@ , @@a3@@ ) ; return xsum ( @@v5@@ , @@a4@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
_BOOL8 __fastcall is_infinite_or_zerol ( long double @@a1@@ ) { return ( unsigned int ) rpl_isnanl ( * ( _TBYTE * ) & @@a1@@ ) || @@a1@@ == @@a1@@ + @@a1@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_21FE88 ; @@v4@@ [ Number ] = qword_21FE90 ; @@v4@@ [ Number ] = qword_21FE98 ; @@v4@@ [ Number ] = qword_21FEA0 ; @@v4@@ [ Number ] = qword_21FEA8 ; @@v4@@ [ Number ] = qword_21FEB0 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
__int64 __fastcall getgidbyname ( const char * @@a1@@ ) { __int64 @@result@@ ; size_t @@v2@@ ; __int64 @@i@@ ; __int64 @@j@@ ; __int64 @@v5@@ ; struct group * @@v6@@ ; for ( @@i@@ = group_alist ; @@i@@ ; @@i@@ = * ( _QWORD * ) ( @@i@@ + Number ) ) { if ( * ( _BYTE * ) ( @@i@@ + Number ) == * @@a1@@ && ! strcmp ( ( const char * ) ( @@i@@ + Number ) , @@a1@@ ) ) { return @@i@@ ; } } for ( @@j@@ = nogroup_alist ; @@j@@ ; @@j@@ = * ( _QWORD * ) ( @@j@@ + Number ) ) { if ( * ( _BYTE * ) ( @@j@@ + Number ) == * @@a1@@ && ! strcmp ( ( const char * ) ( @@j@@ + Number ) , @@a1@@ ) ) { return Number L ; } } @@v6@@ = getgrnam ( @@a1@@ ) ; @@v2@@ = strlen ( @@a1@@ ) ; @@v5@@ = xmalloc ( @@v2@@ + Number ) ; strcpy ( ( char * ) ( @@v5@@ + Number ) , @@a1@@ ) ; if ( @@v6@@ ) { * ( _DWORD * ) @@v5@@ = @@v6@@ -> gr_gid ; * ( _QWORD * ) ( @@v5@@ + Number ) = group_alist ; group_alist = @@v5@@ ; @@result@@ = @@v5@@ ; } else { * ( _QWORD * ) ( @@v5@@ + Number ) = nogroup_alist ; nogroup_alist = @@v5@@ ; @@result@@ = Number L ; } return @@result@@ ; }
struct passwd * getpwuid ( __uid_t @@uid@@ ) { return getpwuid ( @@uid@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
void __fastcall mpsort ( __int64 * @@a1@@ , unsigned __int64 @@a2@@ , __int64 ( __fastcall * @@a3@@ ) ( __int64 , __int64 ) ) { mpsort_with_tmp ( @@a1@@ , @@a2@@ , & @@a1@@ [ @@a2@@ ] , @@a3@@ ) ; }
_QWORD * __fastcall scan_arg ( _QWORD * @@a1@@ , unsigned __int8 * @@a2@@ ) { char * @@v2@@ ; const unsigned __int16 * @@v3@@ ; __int64 @@v4@@ ; int @@v5@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; unsigned __int8 * @@s@@ ; char * @@v10@@ ; char * @@v11@@ ; size_t @@v12@@ ; __int64 @@v13@@ ; long double @@v14@@ ; size_t @@v15@@ ; __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@s@@ = @@a2@@ ; @@v17@@ = __readfsqword ( Number ) ; if ( ( unsigned __int8 ) xstrtold ( @@a2@@ , Number L , & @@v14@@ , c_strtold ) != Number ) { @@v2@@ = gettext ( String ) ; error ( Number , Number , @@v2@@ , @@a2@@ ) ; usage ( Number ) ; } while ( Number ) { @@v3@@ = * __ctype_b_loc ( ) ; if ( ( @@v3@@ [ ( unsigned __int8 ) to_uchar ( * @@s@@ ) ] & Number ) == Number && * @@s@@ != Number ) break ; ++ @@s@@ ; } @@v15@@ = strlen ( ( const char * ) @@s@@ ) ; LODWORD ( @@v16@@ ) = Number ; if ( ! @@s@@ [ strcspn ( ( const char * ) @@s@@ , String ) ] && Number == @@v14@@ * Number ) { @@v11@@ = strchr ( ( const char * ) @@s@@ , Number ) ; if ( @@v11@@ ) { @@v12@@ = strcspn ( @@v11@@ + Number , String ) ; if ( @@v12@@ <= Number ) LODWORD ( @@v16@@ ) = @@v12@@ ; if ( @@v12@@ ) { LODWORD ( @@v4@@ ) = @@v11@@ == ( char * ) @@s@@ || ( unsigned int ) ( * ( @@v11@@ - Number ) - Number ) > Number ; @@v4@@ = ( int ) @@v4@@ ; } else { @@v4@@ = Number ; } @@v15@@ += @@v4@@ ; } else { LODWORD ( @@v16@@ ) = Number ; } @@v10@@ = strchr ( ( const char * ) @@s@@ , Number ) ; if ( ! @@v10@@ ) @@v10@@ = strchr ( ( const char * ) @@s@@ , Number ) ; if ( @@v10@@ ) { @@v13@@ = strtol ( @@v10@@ + Number , Number L , Number ) ; if ( @@v13@@ >= Number ) @@v5@@ = Number ; else @@v5@@ = - ( int ) @@v13@@ ; LODWORD ( @@v16@@ ) = @@v16@@ + @@v5@@ ; } } @@v6@@ = * ( ( _QWORD * ) & @@v14@@ + Number ) ; * @@a1@@ = * ( _QWORD * ) & @@v14@@ ; @@a1@@ [ Number ] = @@v6@@ ; @@v7@@ = @@v16@@ ; @@a1@@ [ Number ] = @@v15@@ ; @@a1@@ [ Number ] = @@v7@@ ; return @@a1@@ ; }
struct group * getgrgid ( __gid_t @@gid@@ ) { return getgrgid ( @@gid@@ ) ; }
__int64 __fastcall memcpy_uppcase ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { while ( @@a3@@ -- ) * ( _BYTE * ) ( @@a1@@ + @@a3@@ ) = toupper ( * ( unsigned __int8 * ) ( @@a2@@ + @@a3@@ ) ) ; return @@a1@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
int dirfd ( DIR * @@dirp@@ ) { return dirfd ( @@dirp@@ ) ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
__pid_t tcgetpgrp ( int @@fd@@ ) { return tcgetpgrp ( @@fd@@ ) ; }
int fflush_unlocked ( FILE * @@stream@@ ) { return fflush_unlocked ( @@stream@@ ) ; }
char * nl_langinfo ( nl_item @@item@@ ) { return nl_langinfo ( @@item@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v4@@ ; @@v4@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v4@@ >= Number / @@a3@@ ) xalloc_die ( ) ; @@v4@@ += ( @@v4@@ + Number ) >> Number ; } else if ( ! @@v4@@ ) { @@v4@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v4@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v4@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
_BOOL8 __fastcall dot_or_dotdot ( _BYTE * @@a1@@ ) { __int64 @@v1@@ ; char @@v4@@ ; if ( * @@a1@@ != Number ) return Number L ; if ( @@a1@@ [ Number ] == Number ) @@v1@@ = Number L ; else @@v1@@ = Number L ; @@v4@@ = @@a1@@ [ @@v1@@ ] ; return ! @@v4@@ || @@v4@@ == Number ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@v3@@ ; @@v3@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v3@@ ) xalloc_die ( ) ; return @@v3@@ ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
__int64 __fastcall get_stat_mtime ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
_BOOL8 __fastcall c_islower ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
__int64 __fastcall get_stat_mtime ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
void __fastcall dev_ino_free ( void * @@a1@@ ) { free ( @@a1@@ ) ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_21F238 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
_BOOL8 __fastcall c_isupper ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall c_tolower ( int @@a1@@ ) { __int64 @@result@@ ; if ( @@a1@@ <= Number || @@a1@@ > Number ) @@result@@ = ( unsigned int ) @@a1@@ ; else @@result@@ = ( unsigned int ) ( @@a1@@ + Number ) ; return @@result@@ ; }
__int64 __fastcall queue_directory ( __int64 @@a1@@ , __int64 @@a2@@ , char @@a3@@ ) { __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@result@@ ; __int64 @@v7@@ ; @@v7@@ = xmalloc ( Number L ) ; if ( @@a2@@ ) @@v3@@ = xstrdup ( @@a2@@ ) ; else @@v3@@ = Number L ; * ( _QWORD * ) ( @@v7@@ + Number ) = @@v3@@ ; if ( @@a1@@ ) @@v4@@ = xstrdup ( @@a1@@ ) ; else @@v4@@ = Number L ; * ( _QWORD * ) @@v7@@ = @@v4@@ ; * ( _BYTE * ) ( @@v7@@ + Number ) = @@a3@@ ; * ( _QWORD * ) ( @@v7@@ + Number ) = pending_dirs ; @@result@@ = @@v7@@ ; pending_dirs = @@v7@@ ; return @@result@@ ; }
_BOOL8 __fastcall binop ( const char * @@a1@@ ) { return ! strcmp ( @@a1@@ , String ) || ! strcmp ( @@a1@@ , String ) || ! strcmp ( @@a1@@ , String ) || ! strcmp ( @@a1@@ , String ) || ! strcmp ( @@a1@@ , String ) || ! strcmp ( @@a1@@ , String ) || ! strcmp ( @@a1@@ , String ) || ! strcmp ( @@a1@@ , String ) || ! strcmp ( @@a1@@ , String ) || ! strcmp ( @@a1@@ , String ) || ! strcmp ( @@a1@@ , String ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) _frame_dummy_init_array_entry [ @@i@@ ] ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_20D0E8 ; @@v8@@ [ Number ] = qword_20D0F0 ; @@v8@@ [ Number ] = qword_20D0F8 ; @@v8@@ [ Number ] = qword_20D100 ; @@v8@@ [ Number ] = qword_20D108 ; @@v8@@ [ Number ] = qword_20D110 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_21FE88 ; @@v8@@ [ Number ] = qword_21FE90 ; @@v8@@ [ Number ] = qword_21FE98 ; @@v8@@ [ Number ] = qword_21FEA0 ; @@v8@@ [ Number ] = qword_21FEA8 ; @@v8@@ [ Number ] = qword_21FEB0 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
_BOOL8 __fastcall is_directory ( __int64 @@a1@@ ) { return * ( _DWORD * ) ( @@a1@@ + Number ) == Number || * ( _DWORD * ) ( @@a1@@ + Number ) == Number ; }
int __fastcall fstat ( int @@fildes@@ , struct stat * @@stat_buf@@ ) { return __fxstat ( Number , @@fildes@@ , @@stat_buf@@ ) ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v4@@ ; @@v4@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v4@@ >= Number / @@a3@@ ) xalloc_die ( ) ; @@v4@@ += ( @@v4@@ + Number ) >> Number ; } else if ( ! @@v4@@ ) { @@v4@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v4@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v4@@ ) ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; FILE * @@v11@@ ; char * @@v12@@ ; FILE * @@v13@@ ; char * @@v14@@ ; FILE * @@v15@@ ; char * @@v16@@ ; FILE * @@v17@@ ; char * @@v18@@ ; FILE * @@v19@@ ; char * @@v20@@ ; FILE * @@v21@@ ; char * @@v22@@ ; FILE * @@v23@@ ; char * @@v24@@ ; FILE * @@v25@@ ; char * @@v26@@ ; FILE * @@v27@@ ; char * @@v28@@ ; FILE * @@v29@@ ; char * @@v30@@ ; FILE * @@v31@@ ; char * @@v32@@ ; char * @@v33@@ ; char * @@v34@@ ; if ( @@a1@@ ) { @@v1@@ = program_name ; @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@v5@@ = stdout ; @@v6@@ = gettext ( String ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = stdout ; @@v8@@ = gettext ( String ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = stdout ; @@v10@@ = gettext ( String ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; @@v11@@ = stdout ; @@v12@@ = gettext ( String String String ) ; fputs_unlocked ( @@v12@@ , @@v11@@ ) ; @@v13@@ = stdout ; @@v14@@ = gettext ( String String String String String ) ; fputs_unlocked ( @@v14@@ , @@v13@@ ) ; @@v15@@ = stdout ; @@v16@@ = gettext ( String String String String String String ) ; fputs_unlocked ( @@v16@@ , @@v15@@ ) ; @@v17@@ = stdout ; @@v18@@ = gettext ( String String String String String String String ) ; fputs_unlocked ( @@v18@@ , @@v17@@ ) ; @@v19@@ = stdout ; @@v20@@ = gettext ( String String String String ) ; fputs_unlocked ( @@v20@@ , @@v19@@ ) ; @@v21@@ = stdout ; @@v22@@ = gettext ( String String String String String ) ; fputs_unlocked ( @@v22@@ , @@v21@@ ) ; @@v23@@ = stdout ; @@v24@@ = gettext ( String String String String String ) ; fputs_unlocked ( @@v24@@ , @@v23@@ ) ; @@v25@@ = stdout ; @@v26@@ = gettext ( String String String String String ) ; fputs_unlocked ( @@v26@@ , @@v25@@ ) ; @@v27@@ = stdout ; @@v28@@ = gettext ( String String String String String ) ; fputs_unlocked ( @@v28@@ , @@v27@@ ) ; @@v29@@ = stdout ; @@v30@@ = gettext ( String String String String ) ; fputs_unlocked ( @@v30@@ , @@v29@@ ) ; @@v31@@ = stdout ; @@v32@@ = gettext ( String String String ) ; fputs_unlocked ( @@v32@@ , @@v31@@ ) ; @@v33@@ = gettext ( String ) ; @@v34@@ = gettext ( String String String String ) ; printf ( @@v34@@ , @@v33@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
__int64 __fastcall nstrftime ( char * @@a1@@ , __int64 @@a2@@ , char * @@a3@@ , __int64 @@a4@@ , int @@a5@@ , int @@a6@@ ) { return strftime_case_ ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
__int64 __fastcall extract_dirs_from_files ( __int64 @@a1@@ , char @@a2@@ ) { __int64 @@result@@ ; __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 * @@v8@@ ; void * @@ptr@@ ; if ( @@a1@@ && active_dir_set ) queue_directory ( Number L , @@a1@@ , Number ) ; @@v4@@ = cwd_n_used ; while ( @@v4@@ -- ) { @@v8@@ = ( __int64 * ) * ( ( _QWORD * ) sorted_file + @@v4@@ ) ; if ( is_directory ( ( __int64 ) @@v8@@ ) && ( ! @@a1@@ || ! basename_is_dot_or_dotdot ( * @@v8@@ ) ) ) { if ( @@a1@@ && * ( _BYTE * ) * @@v8@@ != Number ) { @@ptr@@ = ( void * ) file_name_concat ( @@a1@@ , * @@v8@@ , Number L ) ; queue_directory ( ( __int64 ) @@ptr@@ , @@v8@@ [ Number ] , @@a2@@ ) ; free ( @@ptr@@ ) ; } else { queue_directory ( * @@v8@@ , @@v8@@ [ Number ] , @@a2@@ ) ; } if ( * ( ( _DWORD * ) @@v8@@ + Number ) == Number ) free ( ( void * ) * @@v8@@ ) ; } } @@v5@@ = Number L ; @@v6@@ = Number L ; while ( @@v5@@ < cwd_n_used ) { @@v7@@ = * ( ( _QWORD * ) sorted_file + @@v5@@ ) ; * ( ( _QWORD * ) sorted_file + @@v6@@ ) = @@v7@@ ; @@v6@@ += * ( _DWORD * ) ( @@v7@@ + Number ) != Number ; ++ @@v5@@ ; } @@result@@ = @@v6@@ ; cwd_n_used = @@v6@@ ; return @@result@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@v2@@ ; @@v2@@ = malloc ( @@a1@@ ) ; if ( ! @@v2@@ && @@a1@@ ) xalloc_die ( ) ; return @@v2@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
unsigned __int64 __fastcall xmax ( unsigned __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { unsigned __int64 @@result@@ ; @@result@@ = @@a2@@ ; if ( @@a1@@ >= @@a2@@ ) @@result@@ = @@a1@@ ; return @@result@@ ; }
__int64 __fastcall bkm_scale_by_power ( unsigned __int64 * @@a1@@ , int @@a2@@ , int @@a3@@ ) { unsigned int @@i@@ ; for ( @@i@@ = Number ; @@a3@@ -- ; @@i@@ |= bkm_scale ( @@a1@@ , @@a2@@ ) ) { ; } return @@i@@ ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 __fastcall xstrcoll_df_ctime ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_ctime ( @@a1@@ , @@a2@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) xstrcoll ) ; }
_BOOL8 __fastcall c_isblank ( int @@a1@@ ) { return @@a1@@ == Number || @@a1@@ == Number ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
_BOOL8 __fastcall c_ispunct ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number && ( @@a1@@ <= Number || @@a1@@ > Number ) && ( ( int ) ( @@a1@@ & Number ) <= Number || ( int ) ( @@a1@@ & Number ) > Number ) ; }
__int64 __fastcall xstrcoll_df_mtime ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_mtime ( @@a1@@ , @@a2@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) xstrcoll ) ; }
unsigned __int64 __fastcall users ( const char * @@a1@@ , unsigned int @@a2@@ ) { int * @@v2@@ ; __int64 @@v4@@ ; void * @@ptr@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = __readfsqword ( Number ) ; if ( ( unsigned int ) read_utmp ( @@a1@@ , & @@v4@@ , & @@ptr@@ , @@a2@@ ) ) { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@a1@@ ) ; } list_entries_users ( @@v4@@ , ( __int64 ) @@ptr@@ ) ; free ( @@ptr@@ ) ; return __readfsqword ( Number ) ^ @@v6@@ ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_209028 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
int isatty ( int @@fd@@ ) { return isatty ( @@fd@@ ) ; }
__int64 __fastcall c_toupper ( int @@a1@@ ) { __int64 @@result@@ ; if ( @@a1@@ <= Number || @@a1@@ > Number ) @@result@@ = ( unsigned int ) @@a1@@ ; else @@result@@ = ( unsigned int ) ( @@a1@@ - Number ) ; return @@result@@ ; }
__int64 __fastcall strcmp_df_atime ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_atime ( @@a1@@ , @@a2@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) & strcmp ) ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 __fastcall rev_xstrcoll_df_size ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_size ( @@a2@@ , @@a1@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) xstrcoll ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
__int64 __fastcall strcmp_df_name ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_name ( @@a1@@ , @@a2@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) & strcmp ) ; }
void __fastcall __noreturn test_syntax_error ( const char * @@a1@@ , __int64 @@a2@@ ) { fprintf ( stderr , String , * ( const char * * ) argv ) ; fprintf ( stderr , @@a1@@ , @@a2@@ ) ; fputc_unlocked ( Number , stderr ) ; fflush_unlocked ( stderr ) ; exit ( Number ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
__int64 __fastcall rev_strcmp_df_extension ( const char * * @@a1@@ , const char * * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_extension ( @@a2@@ , @@a1@@ , ( __int64 ( __fastcall * ) ( const char * , const char * ) ) & strcmp ) ; }
__int64 __fastcall test_unop ( _BYTE * @@a1@@ ) { __int64 @@result@@ ; if ( * @@a1@@ != Number ) return Number L ; switch ( @@a1@@ [ Number ] ) { case String : case String : case String : case String : case String : case String : case String : case String : case String : case String : case String : case String : case String : case String : case String : case String : case String : case String : case String : case String : case String : case String : case String : case String : @@result@@ = Number L ; break ; default : @@result@@ = Number L ; break ; } return @@result@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return xmalloc ( @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
__int64 print_current_files ( ) { __int64 @@result@@ ; unsigned __int64 @@j@@ ; unsigned __int64 @@i@@ ; @@result@@ = ( unsigned int ) format ; switch ( format ) { case Number : for ( @@i@@ = Number L ; ; ++ @@i@@ ) { @@result@@ = cwd_n_used ; if ( @@i@@ >= cwd_n_used ) break ; print_long_format ( * ( ( _QWORD * ) sorted_file + @@i@@ ) ) ; putchar_unlocked ( Number ) ; ++ dired_pos ; } break ; case Number : for ( @@j@@ = Number L ; ; ++ @@j@@ ) { @@result@@ = cwd_n_used ; if ( @@j@@ >= cwd_n_used ) break ; print_file_name_and_frills ( * ( ( _QWORD * ) sorted_file + @@j@@ ) , Number L ) ; putchar_unlocked ( Number ) ; } break ; case Number : @@result@@ = print_many_per_line ( ) ; break ; case Number : @@result@@ = print_horizontal ( ) ; break ; case Number : @@result@@ = print_with_commas ( ) ; break ; default : return @@result@@ ; } return @@result@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
__int64 __fastcall format_group ( unsigned int @@a1@@ , int @@a2@@ , char @@a3@@ ) { const char * @@v3@@ ; if ( @@a3@@ != Number ) { @@v3@@ = String ; } else if ( numeric_ids ) { @@v3@@ = Number L ; } else { @@v3@@ = ( const char * ) getgroup ( @@a1@@ ) ; } return format_user_or_group ( @@v3@@ , @@a1@@ , @@a2@@ ) ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_2070C8 ; @@v8@@ [ Number ] = qword_2070D0 ; @@v8@@ [ Number ] = qword_2070D8 ; @@v8@@ [ Number ] = qword_2070E0 ; @@v8@@ [ Number ] = qword_2070E8 ; @@v8@@ [ Number ] = qword_2070F0 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
__int64 __fastcall fraccompare ( _BYTE * @@a1@@ , _BYTE * @@a2@@ , char @@a3@@ ) { _BYTE * @@v4@@ ; _BYTE * @@v5@@ ; @@v5@@ = @@a1@@ ; @@v4@@ = @@a2@@ ; if ( @@a3@@ == * @@a1@@ && @@a3@@ == * @@a2@@ ) { while ( * ++ @@v5@@ == * ++ @@v4@@ ) { if ( ( unsigned int ) ( ( char ) * @@v5@@ - Number ) > Number ) return Number L ; } if ( ( unsigned int ) ( ( char ) * @@v5@@ - Number ) <= Number && ( unsigned int ) ( ( char ) * @@v4@@ - Number ) <= Number ) { return ( unsigned int ) ( ( char ) * @@v5@@ - ( char ) * @@v4@@ ) ; } if ( ( unsigned int ) ( ( char ) * @@v5@@ - Number ) > Number ) { if ( ( unsigned int ) ( ( char ) * @@v4@@ - Number ) > Number ) return Number L ; LABEL_23 : while ( * @@v4@@ == Number ) ++ @@v4@@ ; return ( unsigned int ) - ( ( unsigned int ) ( ( char ) * @@v4@@ - Number ) <= Number ) ; } } else { @@v5@@ = @@a1@@ + Number ; if ( @@a3@@ != * @@a1@@ ) { @@v4@@ = @@a2@@ + Number ; if ( @@a3@@ != * @@a2@@ ) return Number L ; goto LABEL_23 ; } } while ( * @@v5@@ == Number ) ++ @@v5@@ ; return ( unsigned int ) ( ( char ) * @@v5@@ - Number ) <= Number ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
const char * __fastcall format_inode ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ ) { const char * @@result@@ ; if ( @@a2@@ <= Number ) __assert_fail ( String , String , Number , String ) ; if ( * ( _BYTE * ) ( @@a3@@ + Number ) && * ( _QWORD * ) ( @@a3@@ + Number ) ) @@result@@ = ( const char * ) umaxtostr ( * ( _QWORD * ) ( @@a3@@ + Number ) , @@a1@@ ) ; else @@result@@ = String ; return @@result@@ ; }
__int64 __fastcall read_utmp ( const char * @@a1@@ , _QWORD * @@a2@@ , _QWORD * @@a3@@ , char @@a4@@ ) { __int64 @@v4@@ ; _QWORD * @@v5@@ ; struct utmpx * @@v6@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; __int64 @@v12@@ ; struct utmpx * @@v13@@ ; unsigned __int64 @@v14@@ ; @@v14@@ = __readfsqword ( Number ) ; @@v11@@ = Number L ; @@v10@@ = Number L ; @@v12@@ = Number L ; utmpxname ( @@a1@@ ) ; setutxent ( ) ; while ( Number ) { @@v13@@ = getutxent ( ) ; if ( ! @@v13@@ ) break ; if ( desirable_utmp_entry ( ( __int64 ) @@v13@@ , @@a4@@ ) ) { if ( @@v11@@ == @@v10@@ ) @@v12@@ = x2nrealloc ( @@v12@@ , & @@v10@@ , Number L ) ; @@v4@@ = @@v11@@ ++ ; @@v5@@ = ( _QWORD * ) ( Number * @@v4@@ + @@v12@@ ) ; @@v6@@ = @@v13@@ ; * @@v5@@ = * ( _QWORD * ) & @@v13@@ -> ut_type ; @@v5@@ [ Number ] = * ( _QWORD * ) & @@v6@@ -> __unused [ Number ] ; qmemcpy ( ( void * ) ( ( unsigned __int64 ) ( @@v5@@ + Number ) & Number ) , ( const void * ) ( ( char * ) @@v6@@ - ( ( char * ) @@v5@@ - ( ( unsigned __int64 ) ( @@v5@@ + Number ) & Number ) ) ) , Number L * ( ( ( ( _DWORD ) @@v5@@ - ( ( ( _DWORD ) @@v5@@ + Number ) & Number ) + Number ) & Number ) >> Number ) ) ; } } endutxent ( ) ; * @@a2@@ = @@v11@@ ; * @@a3@@ = @@v12@@ ; return Number L ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
__int64 __fastcall length_of_file_name_and_frills ( __int64 @@a1@@ ) { const char * @@v1@@ ; __int64 @@v2@@ ; const char * @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; char @@v7@@ ; size_t @@v8@@ ; __int64 @@v9@@ ; char @@v10@@ [ Number ] ; unsigned __int64 @@v11@@ ; @@v11@@ = __readfsqword ( Number ) ; @@v9@@ = Number L ; if ( print_inode ) { if ( format == Number ) { @@v1@@ = ( const char * ) umaxtostr ( * ( _QWORD * ) ( @@a1@@ + Number ) , @@v10@@ ) ; @@v2@@ = strlen ( @@v1@@ ) + Number ; } else { @@v2@@ = inode_number_width + Number L ; } @@v9@@ += @@v2@@ ; } if ( print_block_size ) { if ( format == Number ) { if ( * ( _BYTE * ) ( @@a1@@ + Number ) != Number ) @@v3@@ = String ; else @@v3@@ = ( const char * ) human_readable ( * ( _QWORD * ) ( @@a1@@ + Number ) , @@v10@@ , ( unsigned int ) human_output_opts , Number L , output_block_size ) ; @@v4@@ = strlen ( @@v3@@ ) + Number ; } else { @@v4@@ = block_size_width + Number L ; } @@v9@@ += @@v4@@ ; } if ( print_scontext ) { if ( format == Number ) @@v5@@ = strlen ( * ( const char * * ) ( @@a1@@ + Number ) ) + Number ; else @@v5@@ = scontext_width + Number L ; @@v9@@ += @@v5@@ ; } quote_name ( Number L , * ( _QWORD * ) @@a1@@ , filename_quoting_options , & @@v8@@ ) ; @@v9@@ += @@v8@@ ; if ( indicator_style ) { @@v7@@ = get_type_indicator ( * ( _BYTE * ) ( @@a1@@ + Number ) , * ( _DWORD * ) ( @@a1@@ + Number ) , * ( _DWORD * ) ( @@a1@@ + Number ) ) ; @@v9@@ += @@v7@@ != Number ; } return @@v9@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_209028 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
int clock_gettime ( clockid_t @@clock_id@@ , struct timespec * @@tp@@ ) { return clock_gettime ( @@clock_id@@ , @@tp@@ ) ; }
unsigned __int64 __fastcall calculate_columns ( char @@a1@@ ) { __int64 @@v1@@ ; unsigned __int64 @@v2@@ ; __int64 @@v3@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@k@@ ; unsigned __int64 @@j@@ ; unsigned __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; @@v1@@ = max_idx ; if ( cwd_n_used <= ( unsigned __int64 ) max_idx ) @@v1@@ = cwd_n_used ; @@v8@@ = @@v1@@ ; init_column_info ( ) ; for ( @@i@@ = Number L ; @@i@@ < cwd_n_used ; ++ @@i@@ ) { @@v9@@ = length_of_file_name_and_frills ( * ( ( _QWORD * ) sorted_file + @@i@@ ) ) ; for ( @@j@@ = Number L ; @@j@@ < @@v8@@ ; ++ @@j@@ ) { if ( * ( _BYTE * ) ( column_info + Number * @@j@@ ) ) { @@v2@@ = @@a1@@ ? @@i@@ / ( ( cwd_n_used + @@j@@ ) / ( @@j@@ + Number ) ) : @@i@@ % ( @@j@@ + Number ) ; @@v3@@ = @@v2@@ == @@j@@ ? Number L : Number L ; @@v10@@ = @@v3@@ + @@v9@@ ; if ( ( unsigned __int64 ) ( @@v3@@ + @@v9@@ ) > * ( _QWORD * ) ( Number * @@v2@@ + * ( _QWORD * ) ( column_info + Number * @@j@@ + Number ) ) ) { * ( _QWORD * ) ( column_info + Number * @@j@@ + Number ) += @@v10@@ - * ( _QWORD * ) ( Number * @@v2@@ + * ( _QWORD * ) ( column_info + Number * @@j@@ + Number ) ) ; * ( _QWORD * ) ( * ( _QWORD * ) ( column_info + Number * @@j@@ + Number ) + Number * @@v2@@ ) = @@v10@@ ; * ( _BYTE * ) ( column_info + Number * @@j@@ ) = * ( _QWORD * ) ( column_info + Number * @@j@@ + Number ) < ( unsigned __int64 ) line_length ; } } } } for ( @@k@@ = @@v8@@ ; @@k@@ > Number && ! * ( _BYTE * ) ( column_info + Number * @@k@@ - Number ) ; -- @@k@@ ) { ; } return @@k@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
int _setjmp ( struct __jmp_buf_tag @@env@@ ( ( orgarrdim ( Number , Number ) ) ) [ Number ] ) { return setjmp ( @@env@@ ( ( orgarrdim ( Number , Number ) ) ) ) ; }
struct group * getgrnam ( const char * @@name@@ ) { return getgrnam ( @@name@@ ) ; }
struct dirent * readdir ( DIR * @@dirp@@ ) { return readdir ( @@dirp@@ ) ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_2090A8 ; @@v8@@ [ Number ] = qword_2090B0 ; @@v8@@ [ Number ] = qword_2090B8 ; @@v8@@ [ Number ] = qword_2090C0 ; @@v8@@ [ Number ] = qword_2090C8 ; @@v8@@ [ Number ] = qword_2090D0 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
time_t mktime ( struct tm * @@tp@@ ) { return mktime ( @@tp@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_2070C8 ; @@v4@@ [ Number ] = qword_2070D0 ; @@v4@@ [ Number ] = qword_2070D8 ; @@v4@@ [ Number ] = qword_2070E0 ; @@v4@@ [ Number ] = qword_2070E8 ; @@v4@@ [ Number ] = qword_2070F0 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
int toupper ( int @@c@@ ) { return toupper ( @@c@@ ) ; }
__int64 __fastcall filevercmp ( const char * @@a1@@ , const char * @@a2@@ ) { __int64 @@result@@ ; _BYTE * @@v3@@ ; _BYTE * @@v4@@ ; __int64 @@s2@@ ; __int64 @@s1@@ ; unsigned int @@v7@@ ; unsigned int @@v8@@ ; _BYTE * @@v9@@ ; _BYTE * @@v10@@ ; size_t @@n@@ ; _BYTE * @@v12@@ ; _BYTE * @@v13@@ ; _BYTE * @@v14@@ ; unsigned __int64 @@v15@@ ; @@s1@@ = ( __int64 ) @@a1@@ ; @@s2@@ = ( __int64 ) @@a2@@ ; @@v15@@ = __readfsqword ( Number ) ; @@v7@@ = strcmp ( @@a1@@ , @@a2@@ ) ; if ( ! @@v7@@ ) return Number L ; if ( ! * @@a1@@ ) return Number ; if ( ! * @@a2@@ ) return Number L ; if ( ! strcmp ( String , @@a1@@ ) ) return Number ; if ( ! strcmp ( String , @@a2@@ ) ) return Number L ; if ( ! strcmp ( String , @@a1@@ ) ) return Number ; if ( ! strcmp ( String , @@a2@@ ) ) return Number L ; if ( * @@a1@@ == Number && * @@a2@@ != Number ) return Number ; if ( * @@a1@@ != Number && * @@a2@@ == Number ) return Number L ; if ( * @@a1@@ == Number && * @@a2@@ == Number ) { @@s1@@ = ( __int64 ) ( @@a1@@ + Number ) ; @@s2@@ = ( __int64 ) ( @@a2@@ + Number ) ; } @@v9@@ = ( _BYTE * ) @@s1@@ ; @@v10@@ = ( _BYTE * ) @@s2@@ ; @@v13@@ = match_suffix ( & @@v9@@ ) ; @@v14@@ = match_suffix ( & @@v10@@ ) ; if ( @@v13@@ ) @@v3@@ = @@v13@@ ; else @@v3@@ = @@v9@@ ; @@n@@ = ( size_t ) & @@v3@@ [ - @@s1@@ ] ; if ( @@v14@@ ) @@v4@@ = @@v14@@ ; else @@v4@@ = @@v10@@ ; @@v12@@ = & @@v4@@ [ - @@s2@@ ] ; if ( ( @@v13@@ || @@v14@@ ) && ( _BYTE * ) @@n@@ == @@v12@@ && ! strncmp ( ( const char * ) @@s1@@ , ( const char * ) @@s2@@ , @@n@@ ) ) { @@n@@ = ( size_t ) & @@v9@@ [ - @@s1@@ ] ; @@v12@@ = & @@v10@@ [ - @@s2@@ ] ; } @@v8@@ = verrevcmp ( @@s1@@ , @@n@@ , @@s2@@ , ( unsigned __int64 ) @@v12@@ ) ; if ( @@v8@@ ) @@result@@ = @@v8@@ ; else @@result@@ = @@v7@@ ; return @@result@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
int fflush_unlocked ( FILE * @@stream@@ ) { return fflush_unlocked ( @@stream@@ ) ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
__int64 __fastcall gnu_mbswidth ( const char * @@a1@@ , unsigned int @@a2@@ ) { size_t @@v2@@ ; @@v2@@ = strlen ( @@a1@@ ) ; return mbsnwidth ( @@a1@@ , @@v2@@ , @@a2@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ ) { return xmalloc ( @@a1@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
__int64 __fastcall bad_cast ( __int64 @@a1@@ ) { return @@a1@@ ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
bool __fastcall is_char_class_member ( int @@a1@@ , unsigned __int8 @@a2@@ ) { int @@v3@@ ; switch ( @@a1@@ ) { case Number : @@v3@@ = ( * __ctype_b_loc ( ) ) [ @@a2@@ ] & Number ; break ; case Number : @@v3@@ = ( * __ctype_b_loc ( ) ) [ @@a2@@ ] & Number ; break ; case Number : @@v3@@ = ( * __ctype_b_loc ( ) ) [ @@a2@@ ] & Number ; break ; case Number : @@v3@@ = ( * __ctype_b_loc ( ) ) [ @@a2@@ ] & Number ; break ; case Number : @@v3@@ = ( * __ctype_b_loc ( ) ) [ @@a2@@ ] & Number ; break ; case Number : @@v3@@ = ( * __ctype_b_loc ( ) ) [ @@a2@@ ] & Number ; break ; case Number : @@v3@@ = ( * __ctype_b_loc ( ) ) [ @@a2@@ ] & Number ; break ; case Number : @@v3@@ = ( * __ctype_b_loc ( ) ) [ @@a2@@ ] & Number ; break ; case Number : @@v3@@ = ( * __ctype_b_loc ( ) ) [ @@a2@@ ] & Number ; break ; case Number : @@v3@@ = ( * __ctype_b_loc ( ) ) [ @@a2@@ ] & Number ; break ; case Number : @@v3@@ = ( * __ctype_b_loc ( ) ) [ @@a2@@ ] & Number ; break ; case Number : @@v3@@ = ( * __ctype_b_loc ( ) ) [ @@a2@@ ] & Number ; break ; default : abort ( ) ; } return @@v3@@ != Number ; }
unsigned int __fastcall dired_dump_obstack ( const char * @@a1@@ , __int64 @@a2@@ ) { unsigned int @@result@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@v4@@ ; __int64 @@v5@@ ; @@result@@ = ( unsigned int ) ( * ( _DWORD * ) ( @@a2@@ + Number ) - * ( _DWORD * ) ( @@a2@@ + Number ) ) >> Number ; @@v4@@ = @@result@@ ; if ( @@result@@ ) { @@v5@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( @@v5@@ == * ( _QWORD * ) ( @@a2@@ + Number ) ) * ( _BYTE * ) ( @@a2@@ + Number ) |= Number ; * ( _QWORD * ) ( @@a2@@ + Number ) = ( * ( int * ) ( @@a2@@ + Number ) + * ( _QWORD * ) ( @@a2@@ + Number ) ) & ~ * ( _DWORD * ) ( @@a2@@ + Number ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) - * ( _QWORD * ) ( @@a2@@ + Number ) > * ( _QWORD * ) ( @@a2@@ + Number ) - * ( _QWORD * ) ( @@a2@@ + Number ) ) * ( _QWORD * ) ( @@a2@@ + Number ) = * ( _QWORD * ) ( @@a2@@ + Number ) ; * ( _QWORD * ) ( @@a2@@ + Number ) = * ( _QWORD * ) ( @@a2@@ + Number ) ; fputs_unlocked ( @@a1@@ , stdout ) ; for ( @@i@@ = Number L ; @@i@@ < @@v4@@ ; ++ @@i@@ ) printf ( String , * ( _QWORD * ) ( Number * @@i@@ + @@v5@@ ) ) ; @@result@@ = putchar_unlocked ( Number ) ; } return @@result@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
int tolower ( int @@c@@ ) { return tolower ( @@c@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
_BOOL8 __fastcall is_colored ( unsigned int @@a1@@ ) { __int64 @@v3@@ ; char * @@s1@@ ; @@v3@@ = * ( ( _QWORD * ) & color_indicator + Number * @@a1@@ ) ; @@s1@@ = ( char * ) * ( & off_21F088 + Number * @@a1@@ ) ; return @@v3@@ && ( @@v3@@ != Number || * @@s1@@ != Number ) && ( @@v3@@ != Number || strncmp ( @@s1@@ , off_16E97 , Number ) ) ; }
__int64 __fastcall append_char_class ( __int64 @@a1@@ , const char * @@a2@@ , size_t @@a3@@ ) { int @@v4@@ ; __int64 @@v5@@ ; @@v4@@ = look_up_char_class ( @@a2@@ , @@a3@@ ) ; if ( @@v4@@ == Number ) return Number L ; @@v5@@ = xmalloc ( Number L ) ; * ( _QWORD * ) ( @@v5@@ + Number ) = Number L ; * ( _DWORD * ) @@v5@@ = Number ; * ( _DWORD * ) ( @@v5@@ + Number ) = @@v4@@ ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) __assert_fail ( String , String , Number , String ) ; * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L ) = @@v5@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v5@@ ; return Number L ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
int __lxstat ( int @@ver@@ , const char * @@filename@@ , struct stat * @@stat_buf@@ ) { return _lxstat ( @@ver@@ , @@filename@@ , @@stat_buf@@ ) ; }
__int64 __fastcall argmatch_to_argument ( const void * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; ++ @@i@@ ) { if ( ! memcmp ( @@a1@@ , ( const void * ) ( @@i@@ * @@a4@@ + @@a3@@ ) , @@a4@@ ) ) return * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; } return Number L ; }
_BOOL8 __fastcall basename_is_dot_or_dotdot ( __int64 @@a1@@ ) { _BYTE * @@v2@@ ; @@v2@@ = ( _BYTE * ) last_component ( @@a1@@ ) ; return dot_or_dotdot ( @@v2@@ ) ; }
int closedir ( DIR * @@dirp@@ ) { return closedir ( @@dirp@@ ) ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; char * @@v3@@ ; FILE * @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; FILE * @@v10@@ ; char * @@v11@@ ; FILE * @@v12@@ ; char * @@v13@@ ; FILE * @@v14@@ ; char * @@v15@@ ; FILE * @@v16@@ ; char * @@v17@@ ; @@v1@@ = program_name ; if ( @@a1@@ ) { @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = gettext ( String ) ; printf ( @@v3@@ , @@v1@@ ) ; @@v4@@ = stdout ; @@v5@@ = gettext ( String String String String String String String String String ) ; fputs_unlocked ( @@v5@@ , @@v4@@ ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; @@v8@@ = stdout ; @@v9@@ = gettext ( String ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = stdout ; @@v11@@ = gettext ( String String String String String String String String String String String String ) ; fputs_unlocked ( @@v11@@ , @@v10@@ ) ; @@v12@@ = stdout ; @@v13@@ = gettext ( String String String String String String String String String ) ; fputs_unlocked ( @@v13@@ , @@v12@@ ) ; @@v14@@ = stdout ; @@v15@@ = gettext ( String String String String String String String String ) ; fputs_unlocked ( @@v15@@ , @@v14@@ ) ; @@v16@@ = stdout ; @@v17@@ = gettext ( String String String String String String String String String ) ; fputs_unlocked ( @@v17@@ , @@v16@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
__int64 __fastcall find_bracketed_repeat ( _QWORD * @@a1@@ , __int64 @@a2@@ , _BYTE * @@a3@@ , _QWORD * @@a4@@ , unsigned __int64 * @@a5@@ ) { unsigned int @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; _BYTE * @@v12@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@v14@@ ; _BYTE * @@v15@@ ; void * @@ptr@@ ; unsigned __int64 @@v17@@ ; @@v17@@ = __readfsqword ( Number ) ; if ( ( unsigned __int64 ) ( @@a2@@ + Number ) >= @@a1@@ [ Number ] ) __assert_fail ( String , String , Number , String ) ; if ( ! es_match ( @@a1@@ , @@a2@@ + Number , Number ) ) return Number ; for ( @@i@@ = @@a2@@ + Number ; ; ++ @@i@@ ) { if ( @@i@@ >= @@a1@@ [ Number ] || * ( _BYTE * ) ( @@a1@@ [ Number ] + @@i@@ ) == Number ) { return Number ; } if ( * ( _BYTE * ) ( * @@a1@@ + @@i@@ ) == Number ) break ; } @@v14@@ = @@i@@ - @@a2@@ - Number ; * @@a3@@ = * ( _BYTE * ) ( * @@a1@@ + @@a2@@ ) ; if ( @@v14@@ ) { @@v15@@ = ( _BYTE * ) ( @@a2@@ + Number + * @@a1@@ ) ; if ( * @@v15@@ == Number ) @@v6@@ = Number ; else @@v6@@ = Number ; if ( ( unsigned int ) xstrtoumax ( @@v15@@ , & @@v12@@ , @@v6@@ , @@a4@@ , Number L ) || * @@a4@@ == Number || & @@v15@@ [ @@v14@@ ] != @@v12@@ ) { @@ptr@@ = ( void * ) make_printable_str ( ( __int64 ) @@v15@@ , @@v14@@ ) ; @@v7@@ = quote ( @@ptr@@ ) ; @@v8@@ = gettext ( String ) ; error ( Number , Number , @@v8@@ , @@v7@@ ) ; free ( @@ptr@@ ) ; return Number L ; } } else { * @@a4@@ = Number L ; } * @@a5@@ = @@i@@ ; return Number L ; }
_BYTE * __fastcall strmode ( __int16 @@a1@@ , _BYTE * @@a2@@ ) { char @@v2@@ ; char @@v3@@ ; char @@v4@@ ; char @@v5@@ ; char @@v6@@ ; char @@v7@@ ; char @@v8@@ ; char @@v9@@ ; char @@v10@@ ; _BYTE * @@result@@ ; * @@a2@@ = ftypelet ( @@a1@@ ) ; if ( ( @@a1@@ & Number ) != Number ) @@v2@@ = Number ; else @@v2@@ = Number ; @@a2@@ [ Number ] = @@v2@@ ; if ( ( @@a1@@ & Number ) != Number ) @@v3@@ = Number ; else @@v3@@ = Number ; @@a2@@ [ Number ] = @@v3@@ ; if ( ( @@a1@@ & Number ) != Number ) { if ( ( @@a1@@ & Number ) != Number ) @@v4@@ = Number ; else @@v4@@ = Number ; } else if ( ( @@a1@@ & Number ) != Number ) { @@v4@@ = Number ; } else { @@v4@@ = Number ; } @@a2@@ [ Number ] = @@v4@@ ; if ( ( @@a1@@ & Number ) != Number ) @@v5@@ = Number ; else @@v5@@ = Number ; @@a2@@ [ Number ] = @@v5@@ ; if ( ( @@a1@@ & Number ) != Number ) @@v6@@ = Number ; else @@v6@@ = Number ; @@a2@@ [ Number ] = @@v6@@ ; if ( ( @@a1@@ & Number ) != Number ) { if ( ( @@a1@@ & Number ) != Number ) @@v7@@ = Number ; else @@v7@@ = Number ; } else if ( ( @@a1@@ & Number ) != Number ) { @@v7@@ = Number ; } else { @@v7@@ = Number ; } @@a2@@ [ Number ] = @@v7@@ ; if ( ( @@a1@@ & Number ) != Number ) @@v8@@ = Number ; else @@v8@@ = Number ; @@a2@@ [ Number ] = @@v8@@ ; if ( ( @@a1@@ & Number ) != Number ) @@v9@@ = Number ; else @@v9@@ = Number ; @@a2@@ [ Number ] = @@v9@@ ; if ( ( @@a1@@ & Number ) != Number ) { if ( ( @@a1@@ & Number ) != Number ) @@v10@@ = Number ; else @@v10@@ = Number ; } else if ( ( @@a1@@ & Number ) != Number ) { @@v10@@ = Number ; } else { @@v10@@ = Number ; } @@a2@@ [ Number ] = @@v10@@ ; @@a2@@ [ Number ] = Number ; @@result@@ = @@a2@@ + Number ; @@a2@@ [ Number ] = Number ; return @@result@@ ; }
struct passwd * getpwnam ( const char * @@name@@ ) { return getpwnam ( @@name@@ ) ; }
__int64 __fastcall cmp_ctime ( _QWORD * @@a1@@ , _QWORD * @@a2@@ , __int64 ( __fastcall * @@a3@@ ( ) ( constchar , constchar ) ) ( _QWORD , _QWORD ) ) { __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@result@@ ; unsigned int @@v10@@ ; @@v3@@ = get_stat_ctime ( ( __int64 ) ( @@a1@@ + Number ) ) ; @@v5@@ = @@v4@@ ; @@v6@@ = get_stat_ctime ( ( __int64 ) ( @@a2@@ + Number ) ) ; @@v10@@ = timespec_cmp ( @@v6@@ , @@v7@@ , @@v3@@ , @@v5@@ ) ; if ( @@v10@@ ) @@result@@ = @@v10@@ ; else @@result@@ = @@a3@@ ( ) ( constchar , constchar ) ( * @@a1@@ , * @@a2@@ ) ; return @@result@@ ; }
int wcwidth ( wchar_t @@c@@ ) { return wcwidth ( @@c@@ ) ; }
__int64 __fastcall spec_init ( _QWORD * @@a1@@ ) { __int64 @@result@@ ; @@a1@@ [ Number ] = xmalloc ( Number L ) ; * @@a1@@ = @@a1@@ [ Number ] ; @@result@@ = * @@a1@@ ; * ( _QWORD * ) ( * @@a1@@ + Number L ) = Number L ; return @@result@@ ; }
__int64 __fastcall append_repeated_char ( __int64 @@a1@@ , char @@a2@@ , __int64 @@a3@@ ) { __int64 @@result@@ ; __int64 @@v5@@ ; @@v5@@ = xmalloc ( Number L ) ; * ( _QWORD * ) ( @@v5@@ + Number ) = Number L ; * ( _DWORD * ) @@v5@@ = Number ; * ( _BYTE * ) ( @@v5@@ + Number ) = @@a2@@ ; * ( _QWORD * ) ( @@v5@@ + Number ) = @@a3@@ ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) __assert_fail ( String , String , Number , String ) ; * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L ) = @@v5@@ ; @@result@@ = @@a1@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v5@@ ; return @@result@@ ; }
unsigned int gnu_dev_major ( unsigned __int64 @@dev@@ ) { return gnu_dev_major ( @@dev@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
__int64 __fastcall card_of_complement ( _QWORD * @@a1@@ ) { unsigned int @@v2@@ ; int @@v3@@ ; char @@v4@@ [ Number ] ; unsigned __int64 @@v5@@ ; @@v5@@ = __readfsqword ( Number ) ; @@v2@@ = Number ; memset ( @@v4@@ , Number , Number ) ; @@a1@@ [ Number ] = Number ; while ( Number ) { @@v3@@ = get_next ( @@a1@@ , Number L ) ; if ( @@v3@@ == Number ) break ; @@v2@@ -= ( unsigned __int8 ) @@v4@@ [ @@v3@@ ] ^ Number ; @@v4@@ [ @@v3@@ ] = Number ; } return @@v2@@ ; }
__int64 __fastcall cmp_extension ( const char * * @@a1@@ , const char * * @@a2@@ , __int64 ( __fastcall * @@a3@@ ( ) ( constchar , constchar ) ) ( const char * , const char * ) ) { const char * @@v3@@ ; const char * @@v4@@ ; __int64 @@result@@ ; unsigned int @@v7@@ ; char * @@v8@@ ; char * @@v9@@ ; @@v8@@ = strrchr ( * @@a1@@ , Number ) ; @@v9@@ = strrchr ( * @@a2@@ , Number ) ; if ( @@v9@@ ) @@v3@@ = @@v9@@ ; else @@v3@@ = & off_16E97 [ Number ] ; if ( @@v8@@ ) @@v4@@ = @@v8@@ ; else @@v4@@ = & off_16E97 [ Number ] ; @@v7@@ = @@a3@@ ( ) ( constchar , constchar ) ( @@v4@@ , @@v3@@ ) ; if ( @@v7@@ ) @@result@@ = @@v7@@ ; else @@result@@ = @@a3@@ ( ) ( constchar , constchar ) ( * @@a1@@ , * @@a2@@ ) ; return @@result@@ ; }
int __fastcall hash_print_statistics ( __int64 @@a1@@ , FILE * @@a2@@ ) { double @@v2@@ ; double @@v3@@ ; double @@v4@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@v6@@ = hash_get_n_entries ( @@a1@@ ) ; @@v7@@ = hash_get_n_buckets ( @@a1@@ ) ; @@v8@@ = hash_get_n_buckets_used ( @@a1@@ ) ; @@v9@@ = hash_get_max_bucket_length ( @@a1@@ ) ; fprintf ( @@a2@@ , String , @@v6@@ ) ; fprintf ( @@a2@@ , String , @@v7@@ ) ; if ( @@v8@@ < Number ) @@v2@@ = ( double ) ( int ) ( @@v8@@ & Number | ( ( unsigned __int64 ) @@v8@@ >> Number ) ) + ( double ) ( int ) ( @@v8@@ & Number | ( ( unsigned __int64 ) @@v8@@ >> Number ) ) ; else @@v2@@ = ( double ) ( int ) @@v8@@ ; @@v3@@ = Number * @@v2@@ ; if ( @@v7@@ < Number ) @@v4@@ = ( double ) ( int ) ( @@v7@@ & Number | ( ( unsigned __int64 ) @@v7@@ >> Number ) ) + ( double ) ( int ) ( @@v7@@ & Number | ( ( unsigned __int64 ) @@v7@@ >> Number ) ) ; else @@v4@@ = ( double ) ( int ) @@v7@@ ; fprintf ( @@a2@@ , String , @@v8@@ , @@v3@@ / @@v4@@ ) ; return fprintf ( @@a2@@ , String , @@v9@@ ) ; }
void __fastcall validate ( __int64 @@a1@@ , __int64 @@a2@@ ) { char * @@v2@@ ; char * @@v3@@ ; char * @@v4@@ ; char * @@v5@@ ; char * @@v6@@ ; char * @@v7@@ ; char * @@v8@@ ; get_s1_spec_stats ( ( _QWORD * ) @@a1@@ ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) { @@v2@@ = gettext ( String ) ; error ( Number , Number , @@v2@@ ) ; } if ( @@a2@@ ) { get_s2_spec_stats ( ( _QWORD * ) @@a2@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) > Number ) { @@v3@@ = gettext ( String ) ; error ( Number , Number , @@v3@@ ) ; } if ( translating ) { if ( * ( _BYTE * ) ( @@a2@@ + Number ) ) { @@v4@@ = gettext ( String ) ; error ( Number , Number , @@v4@@ ) ; } if ( * ( _QWORD * ) ( @@a1@@ + Number ) > * ( _QWORD * ) ( @@a2@@ + Number ) && truncate_set1 != Number ) { if ( ! * ( _QWORD * ) ( @@a2@@ + Number ) ) { @@v5@@ = gettext ( String ) ; error ( Number , Number , @@v5@@ ) ; } string2_extend ( @@a1@@ , @@a2@@ ) ; } if ( complement && * ( _BYTE * ) ( @@a1@@ + Number ) && ( * ( _QWORD * ) ( @@a2@@ + Number ) != * ( _QWORD * ) ( @@a1@@ + Number ) || ( unsigned __int8 ) homogeneous_spec_list ( ( _QWORD * ) @@a2@@ ) != Number ) ) { @@v6@@ = gettext ( String String ) ; error ( Number , Number , @@v6@@ ) ; } if ( * ( _BYTE * ) ( @@a2@@ + Number ) ) { @@v7@@ = gettext ( String String ) ; error ( Number , Number , @@v7@@ ) ; } } else if ( * ( _QWORD * ) ( @@a2@@ + Number ) ) { @@v8@@ = gettext ( String ) ; error ( Number , Number , @@v8@@ ) ; } } }
__int64 __fastcall get_stat_ctime ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int64 __fastcall strcmp_df_mtime ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_mtime ( @@a1@@ , @@a2@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) & strcmp ) ; }
__int64 __fastcall string2_extend ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; int @@i@@ ; __int64 @@v4@@ ; if ( ! translating ) __assert_fail ( String , String , Number , String ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) <= * ( _QWORD * ) ( @@a2@@ + Number ) ) __assert_fail ( String , String , Number , String ) ; if ( ! * ( _QWORD * ) ( @@a2@@ + Number ) ) __assert_fail ( String , String , Number , String ) ; @@v4@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; switch ( * ( _DWORD * ) @@v4@@ ) { case Number : case Number : append_repeated_char ( @@a2@@ , * ( _BYTE * ) ( @@v4@@ + Number ) , * ( _QWORD * ) ( @@a1@@ + Number ) - * ( _QWORD * ) ( @@a2@@ + Number ) ) ; break ; case Number : append_repeated_char ( @@a2@@ , * ( _BYTE * ) ( @@v4@@ + Number ) , * ( _QWORD * ) ( @@a1@@ + Number ) - * ( _QWORD * ) ( @@a2@@ + Number ) ) ; break ; case Number : for ( @@i@@ = Number ; @@i@@ >= Number && ! is_char_class_member ( * ( _DWORD * ) ( @@v4@@ + Number ) , @@i@@ ) ; -- @@i@@ ) { ; } if ( @@i@@ < Number ) __assert_fail ( String , String , Number , String ) ; append_repeated_char ( @@a2@@ , @@i@@ , * ( _QWORD * ) ( @@a1@@ + Number ) - * ( _QWORD * ) ( @@a2@@ + Number ) ) ; break ; case Number : abort ( ) ; default : abort ( ) ; } @@result@@ = @@a2@@ ; * ( _QWORD * ) ( @@a2@@ + Number ) = * ( _QWORD * ) ( @@a1@@ + Number ) ; return @@result@@ ; }
__int64 __fastcall next_prime ( unsigned __int64 @@a1@@ ) { __int64 @@v2@@ ; __int64 @@i@@ ; @@v2@@ = @@a1@@ ; if ( @@a1@@ <= Number ) @@v2@@ = Number L ; for ( @@i@@ = @@v2@@ | Number ; @@i@@ != Number && ! is_prime ( @@i@@ ) ; @@i@@ += Number L ) { ; } return @@i@@ ; }
unsigned __int64 __fastcall dev_ino_hash ( _QWORD * @@a1@@ , unsigned __int64 @@a2@@ ) { return * @@a1@@ % @@a2@@ ; }
__int64 __fastcall set_initialize ( _QWORD * @@a1@@ , char @@a2@@ , __int64 @@a3@@ ) { __int64 @@result@@ ; unsigned __int64 @@i@@ ; @@a1@@ [ Number ] = Number ; for ( @@result@@ = get_next ( @@a1@@ , Number L ) ; ( _DWORD ) @@result@@ != Number ; @@result@@ = get_next ( @@a1@@ , Number L ) ) { * ( _BYTE * ) ( ( int ) @@result@@ + @@a3@@ ) = Number ; } if ( @@a2@@ ) { for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { @@result@@ = * ( unsigned __int8 * ) ( @@a3@@ + @@i@@ ) == Number ; * ( _BYTE * ) ( @@a3@@ + @@i@@ ) = @@result@@ ; } } return @@result@@ ; }
__int64 __fastcall rev_xstrcoll_df_atime ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_atime ( @@a2@@ , @@a1@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) xstrcoll ) ; }
unsigned __int64 __fastcall read_and_delete ( __int64 @@a1@@ , __int64 @@a2@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@j@@ ; unsigned __int64 @@v7@@ ; do { @@v7@@ = plain_read ( @@a1@@ , @@a2@@ ) ; if ( ! @@v7@@ ) return Number L ; for ( @@i@@ = Number L ; @@i@@ < @@v7@@ && in_delete_set [ ( unsigned __int8 ) to_uchar ( * ( _BYTE * ) ( @@a1@@ + @@i@@ ) ) ] != Number ; ++ @@i@@ ) { ; } @@v4@@ = @@i@@ ; for ( @@j@@ = @@i@@ + Number ; @@j@@ < @@v7@@ ; ++ @@j@@ ) { if ( in_delete_set [ ( unsigned __int8 ) to_uchar ( * ( _BYTE * ) ( @@a1@@ + @@j@@ ) ) ] != Number ) { @@v3@@ = @@v4@@ ++ ; * ( _BYTE * ) ( @@v3@@ + @@a1@@ ) = * ( _BYTE * ) ( @@a1@@ + @@j@@ ) ; } } } while ( ! @@v4@@ ) ; return @@v4@@ ; }
_BOOL8 __fastcall visit_dir ( __int64 @@a1@@ , __int64 @@a2@@ ) { _QWORD * @@ptr@@ ; __int64 @@v4@@ ; @@ptr@@ = ( _QWORD * ) xmalloc ( Number L ) ; * @@ptr@@ = @@a2@@ ; @@ptr@@ [ Number ] = @@a1@@ ; @@v4@@ = hash_insert ( active_dir_set , @@ptr@@ ) ; if ( ! @@v4@@ ) xalloc_die ( ) ; if ( ( _QWORD * ) @@v4@@ != @@ptr@@ ) free ( @@ptr@@ ) ; return @@v4@@ != ( _QWORD ) @@ptr@@ ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
__int64 __fastcall rev_xstrcoll_df_name ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_name ( @@a2@@ , @@a1@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) xstrcoll ) ; }
__int64 __fastcall hash_clear ( __int64 @@a1@@ ) { __int64 @@result@@ ; _QWORD * @@i@@ ; _QWORD * @@j@@ ; _QWORD * @@v4@@ ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = ( _QWORD * ) @@i@@ [ Number ] ; @@j@@ ; @@j@@ = @@v4@@ ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@j@@ ) ; * @@j@@ = Number L ; @@v4@@ = ( _QWORD * ) @@j@@ [ Number ] ; @@j@@ [ Number ] = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@j@@ ; } if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) ( * ( void ( __fastcall * * ) ( _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@i@@ ) ; * @@i@@ = Number L ; @@i@@ [ Number ] = Number L ; } } * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; @@result@@ = @@a1@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; return @@result@@ ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( is_mul_ok ( @@a2@@ , * @@a1@@ ) ) { * @@a1@@ *= @@a2@@ ; @@result@@ = Number L ; } else { * @@a1@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
_QWORD * __fastcall add_ignore_pattern ( __int64 @@a1@@ ) { _QWORD * @@result@@ ; @@result@@ = ( _QWORD * ) xmalloc ( Number L ) ; * @@result@@ = @@a1@@ ; @@result@@ [ Number ] = ignore_patterns ; ignore_patterns = ( __int64 ) @@result@@ ; return @@result@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
__int64 __fastcall strcmp_df_extension ( const char * * @@a1@@ , const char * * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_extension ( @@a1@@ , @@a2@@ , ( __int64 ( __fastcall * ) ( const char * , const char * ) ) & strcmp ) ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
__int64 __fastcall patterns_match ( __int64 @@a1@@ , const char * @@a2@@ ) { while ( @@a1@@ ) { if ( ! fnmatch ( * ( const char * * ) @@a1@@ , @@a2@@ , Number ) ) return Number L ; @@a1@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; } return Number L ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall hash_find_entry ( __int64 @@a1@@ , __int64 @@a2@@ , _QWORD * @@a3@@ , char @@a4@@ ) { __int64 @@v4@@ ; __int64 @@result@@ ; __int64 @@v6@@ ; _QWORD * @@i@@ ; _QWORD * @@v10@@ ; __int64 @@v11@@ ; _QWORD * @@v12@@ ; __int64 @@v13@@ ; _QWORD * @@v14@@ ; @@v4@@ = * ( _QWORD * ) @@a1@@ ; @@v10@@ = ( _QWORD * ) ( @@v4@@ + Number * ( * ( __int64 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@a2@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@v10@@ >= * ( _QWORD * ) ( @@a1@@ + Number ) ) abort ( ) ; * @@a3@@ = @@v10@@ ; if ( ! * @@v10@@ ) return Number L ; if ( @@a2@@ == * @@v10@@ || ( * ( unsigned __int8 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@a2@@ , * @@v10@@ ) ) { @@v13@@ = * @@v10@@ ; if ( @@a4@@ ) { if ( @@v10@@ [ Number ] ) { @@v14@@ = ( _QWORD * ) @@v10@@ [ Number ] ; @@v6@@ = @@v14@@ [ Number ] ; * @@v10@@ = * @@v14@@ ; @@v10@@ [ Number ] = @@v6@@ ; free_entry ( @@a1@@ , @@v14@@ ) ; } else { * @@v10@@ = Number L ; } } @@result@@ = @@v13@@ ; } else { for ( @@i@@ = @@v10@@ ; ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { if ( ! @@i@@ [ Number ] ) return Number L ; if ( @@a2@@ == * ( _QWORD * ) @@i@@ [ Number ] || ( * ( unsigned __int8 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@a2@@ , * ( _QWORD * ) @@i@@ [ Number ] ) ) { break ; } } @@v11@@ = * ( _QWORD * ) @@i@@ [ Number ] ; if ( @@a4@@ ) { @@v12@@ = ( _QWORD * ) @@i@@ [ Number ] ; @@i@@ [ Number ] = @@v12@@ [ Number ] ; free_entry ( @@a1@@ , @@v12@@ ) ; } @@result@@ = @@v11@@ ; } return @@result@@ ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
__int64 __fastcall get_link_name ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@result@@ ; char * @@v4@@ ; * ( _QWORD * ) ( @@a2@@ + Number ) = areadlink_with_size ( @@a1@@ , * ( _QWORD * ) ( @@a2@@ + Number ) ) ; @@result@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( ! @@result@@ ) { @@v4@@ = gettext ( String ) ; @@result@@ = file_failure ( @@a3@@ , @@v4@@ , @@a1@@ ) ; } return @@result@@ ; }
__int64 long_time_expected_width ( ) { time_t @@timer@@ ; struct tm * @@v2@@ ; __int64 @@v3@@ ; char @@v4@@ [ Number ] ; unsigned __int64 @@v5@@ ; @@v5@@ = __readfsqword ( Number ) ; if ( width_8232 < Number ) { @@timer@@ = Number L ; @@v2@@ = localtime ( & @@timer@@ ) ; if ( @@v2@@ ) { @@v3@@ = align_nstrftime ( ( __int64 ) @@v4@@ , Number L , long_time_format , ( __int64 ) @@v2@@ , Number , Number ) ; if ( @@v3@@ ) width_8232 = mbsnwidth ( @@v4@@ , @@v3@@ , Number L ) ; } if ( width_8232 < Number ) width_8232 = Number ; } return ( unsigned int ) width_8232 ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
__int64 __fastcall cmp_size ( _QWORD * @@a1@@ , _QWORD * @@a2@@ , __int64 ( __fastcall * @@a3@@ ( ) ( constchar , constchar ) ) ( _QWORD , _QWORD ) ) { __int64 @@result@@ ; if ( @@a2@@ [ Number ] < @@a1@@ [ Number ] ) LODWORD ( @@result@@ ) = Number ; else LODWORD ( @@result@@ ) = @@a2@@ [ Number ] > @@a1@@ [ Number ] ; if ( ( _DWORD ) @@result@@ ) @@result@@ = ( unsigned int ) @@result@@ ; else @@result@@ = @@a3@@ ( ) ( constchar , constchar ) ( * @@a1@@ , * @@a2@@ ) ; return @@result@@ ; }
__int64 __fastcall format_user ( unsigned int @@a1@@ , int @@a2@@ , char @@a3@@ ) { const char * @@v3@@ ; if ( @@a3@@ != Number ) { @@v3@@ = String ; } else if ( numeric_ids ) { @@v3@@ = Number L ; } else { @@v3@@ = ( const char * ) getuser ( @@a1@@ ) ; } return format_user_or_group ( @@v3@@ , @@a1@@ , @@a2@@ ) ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
__int64 __fastcall humblock ( char * @@a1@@ , _QWORD * @@a2@@ , int * @@a3@@ ) { char * @@v5@@ ; int @@v6@@ ; int @@v7@@ ; unsigned int @@v8@@ ; __int64 @@v9@@ [ Number ] ; @@v5@@ = @@a1@@ ; @@v9@@ [ Number ] = __readfsqword ( Number ) ; @@v6@@ = Number ; if ( @@a1@@ || ( @@v5@@ = getenv ( String ) ) != Number L || ( @@v5@@ = getenv ( String ) ) != Number L ) { if ( * @@v5@@ == Number ) { @@v6@@ = Number ; ++ @@v5@@ ; } @@v7@@ = argmatch ( @@v5@@ , ( __int64 ) block_size_args , ( __int64 ) block_size_opts , Number ) ; if ( @@v7@@ < Number ) { @@v8@@ = xstrtoumax ( @@v5@@ , @@v9@@ , Number L , @@a2@@ , String ) ; if ( @@v8@@ ) { * @@a3@@ = Number ; return @@v8@@ ; } while ( * @@v5@@ <= Number || * @@v5@@ > Number ) { if ( @@v5@@ == ( char * ) @@v9@@ [ Number ] ) { @@v6@@ |= Number ; if ( * ( _BYTE * ) ( @@v9@@ [ Number ] - Number ) == Number ) @@v6@@ |= Number ; if ( * ( _BYTE * ) ( @@v9@@ [ Number ] - Number ) != Number || * ( _BYTE * ) ( @@v9@@ [ Number ] - Number ) == Number ) @@v6@@ |= Number ; break ; } ++ @@v5@@ ; } } else { @@v6@@ |= block_size_opts [ @@v7@@ ] ; * @@a2@@ = Number L ; } } else { * @@a2@@ = default_block_size ( ) ; } * @@a3@@ = @@v6@@ ; return Number L ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
size_t __fastcall format_group_width ( unsigned int @@a1@@ ) { __int64 @@v1@@ ; if ( numeric_ids ) @@v1@@ = Number L ; else @@v1@@ = getgroup ( @@a1@@ ) ; return format_user_or_group_width ( @@v1@@ , @@a1@@ ) ; }
__int64 __fastcall rev_xstrcoll_df_ctime ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_ctime ( @@a2@@ , @@a1@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) xstrcoll ) ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_20D3C8 ; @@v4@@ [ Number ] = qword_20D3D0 ; @@v4@@ [ Number ] = qword_20D3D8 ; @@v4@@ [ Number ] = qword_20D3E0 ; @@v4@@ [ Number ] = qword_20D3E8 ; @@v4@@ [ Number ] = qword_20D3F0 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
__int64 __fastcall imaxtostr ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = @@a1@@ ; @@v4@@ = @@a2@@ + Number ; * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; if ( @@a1@@ >= Number ) { do { * ( _BYTE * ) -- @@v4@@ = ( char ) @@v3@@ % Number + Number ; @@v3@@ /= Number L ; } while ( @@v3@@ ) ; } else { do { * ( _BYTE * ) -- @@v4@@ = Number - ( char ) @@v3@@ % Number ; @@v3@@ /= Number L ; } while ( @@v3@@ ) ; * ( _BYTE * ) -- @@v4@@ = Number ; } return @@v4@@ ; }
__int64 __fastcall xstrcoll_df_atime ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_atime ( @@a1@@ , @@a2@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) xstrcoll ) ; }
ssize_t __fastcall safe_read ( int @@a1@@ , void * @@a2@@ , size_t @@a3@@ ) { ssize_t @@result@@ ; ssize_t @@v5@@ ; LABEL_1 : for ( @@result@@ = read ( @@a1@@ , @@a2@@ , @@a3@@ ) ; ; @@result@@ = read ( @@a1@@ , @@a2@@ , Number ) ) { @@v5@@ = @@result@@ ; if ( @@result@@ >= Number ) break ; if ( * __errno_location ( ) == Number ) goto LABEL_1 ; if ( * __errno_location ( ) != Number || @@a3@@ <= Number ) return @@v5@@ ; @@a3@@ = Number L ; } return @@result@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
__int64 __fastcall get_type_indicator ( char @@a1@@ , __int16 @@a2@@ , int @@a3@@ ) { bool @@v3@@ ; bool @@v4@@ ; bool @@v5@@ ; bool @@v6@@ ; bool @@v7@@ ; bool @@v8@@ ; unsigned __int8 @@v10@@ ; if ( @@a1@@ ) @@v3@@ = ( @@a2@@ & Number ) == Number ; else @@v3@@ = @@a3@@ == Number ; if ( @@v3@@ ) { if ( @@a1@@ && indicator_style == Number && ( @@a2@@ & Number ) != Number ) @@v10@@ = Number ; else @@v10@@ = Number ; } else { if ( @@a1@@ ) { @@v4@@ = ( @@a2@@ & Number ) == Number ; } else { @@v5@@ = @@a3@@ == Number || @@a3@@ == Number ; @@v4@@ = @@v5@@ ; } if ( @@v4@@ ) { @@v10@@ = Number ; } else if ( indicator_style == Number ) { @@v10@@ = Number ; } else { if ( @@a1@@ ) @@v6@@ = ( @@a2@@ & Number ) == Number ; else @@v6@@ = @@a3@@ == Number ; if ( @@v6@@ ) { @@v10@@ = Number ; } else { if ( @@a1@@ ) @@v7@@ = ( @@a2@@ & Number ) == Number ; else @@v7@@ = @@a3@@ == Number ; if ( @@v7@@ ) { @@v10@@ = Number ; } else { if ( @@a1@@ ) @@v8@@ = ( @@a2@@ & Number ) == Number ; else @@v8@@ = @@a3@@ == Number ; if ( @@v8@@ ) @@v10@@ = Number ; else @@v10@@ = Number ; } } } } return @@v10@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
__int64 __fastcall strcmp_df_size ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_size ( @@a1@@ , @@a2@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) & strcmp ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_20B028 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
__int64 __fastcall rev_strcmp_df_size ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_size ( @@a2@@ , @@a1@@ , ( __int64 ( __fastcall * ) ( _QWORD , _QWORD ) ) & strcmp ) ; }
unsigned __int64 __fastcall indent ( unsigned __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { unsigned __int64 @@result@@ ; while ( Number ) { @@result@@ = @@a1@@ ; if ( @@a1@@ >= @@a2@@ ) break ; if ( tabsize && @@a2@@ / tabsize > ( @@a1@@ + Number ) / tabsize ) { putchar_unlocked ( Number ) ; @@a1@@ += tabsize - @@a1@@ % tabsize ; } else { putchar_unlocked ( Number ) ; ++ @@a1@@ ; } } return @@result@@ ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
struct passwd * getpwuid ( __uid_t @@uid@@ ) { return getpwuid ( @@uid@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall xstrcoll_df_extension ( const char * * @@a1@@ , const char * * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_extension ( @@a1@@ , @@a2@@ , xstrcoll ) ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
_BYTE * __fastcall match_suffix ( _BYTE * * @@a1@@ ) { char @@v2@@ ; _BYTE * @@v3@@ ; @@v3@@ = Number L ; @@v2@@ = Number ; while ( * * @@a1@@ ) { if ( @@v2@@ ) { @@v2@@ = Number ; if ( ( unsigned __int8 ) c_isalpha ( ( unsigned int ) ( char ) * * @@a1@@ ) != Number && * * @@a1@@ != Number ) { @@v3@@ = Number L ; } } else if ( * * @@a1@@ == Number ) { @@v2@@ = Number ; if ( ! @@v3@@ ) @@v3@@ = * @@a1@@ ; } else if ( ( unsigned __int8 ) c_isalnum ( ( unsigned int ) ( char ) * * @@a1@@ ) != Number && * * @@a1@@ != Number ) { @@v3@@ = Number L ; } ++ * @@a1@@ ; } return @@v3@@ ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
__int64 __fastcall rev_xstrcoll_df_version ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { bool @@v3@@ ; bool @@v4@@ ; @@v3@@ = is_directory ( ( __int64 ) @@a1@@ ) ; @@v4@@ = is_directory ( ( __int64 ) @@a2@@ ) ; if ( @@v3@@ && ! @@v4@@ ) return Number ; if ( ! @@v3@@ && @@v4@@ ) return Number L ; return cmp_version ( @@a2@@ , @@a1@@ ) ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
__int64 __fastcall rpl_wcswidth ( wchar_t * @@a1@@ , __int64 @@a2@@ ) { wchar_t * @@v2@@ ; __int64 @@v4@@ ; int @@i@@ ; int @@v8@@ ; for ( @@i@@ = Number ; ; @@i@@ += @@v8@@ ) { @@v4@@ = @@a2@@ -- ; if ( ! @@v4@@ || ! * @@a1@@ ) break ; @@v2@@ = @@a1@@ ++ ; @@v8@@ = wcwidth ( * @@v2@@ ) ; if ( @@v8@@ == Number ) return Number ; if ( @@i@@ > Number - @@v8@@ ) return Number ; } return ( unsigned int ) @@i@@ ; }
__int64 __fastcall align_nstrftime ( __int64 @@a1@@ , __int64 @@a2@@ , const char * @@a3@@ , __int64 @@a4@@ , unsigned int @@a5@@ , unsigned int @@a6@@ ) { char * @@v6@@ ; char * @@haystack@@ ; char * @@v12@@ ; char * @@v13@@ ; char * @@dest@@ ; char @@v15@@ [ Number ] ; unsigned __int64 @@v16@@ ; @@haystack@@ = ( char * ) @@a3@@ ; @@v16@@ = __readfsqword ( Number ) ; @@v12@@ = ( char * ) @@a3@@ ; if ( required_mon_width ) { @@v13@@ = strstr ( @@a3@@ , needle ) ; if ( @@v13@@ ) { if ( strlen ( @@haystack@@ ) <= Number ) { @@v12@@ = @@v15@@ ; @@v6@@ = ( char * ) mempcpy ( @@v15@@ , @@haystack@@ , @@v13@@ - @@haystack@@ ) ; @@dest@@ = stpcpy ( @@v6@@ , & abmon [ Number * * ( int * ) ( @@a4@@ + Number ) ] ) ; strcpy ( @@dest@@ , @@v13@@ + Number ) ; } } } return nstrftime ( @@a1@@ , @@a2@@ , @@v12@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
__int64 __fastcall umaxtostr ( unsigned __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v4@@ ; @@v4@@ = @@a2@@ + Number ; * ( _BYTE * ) ( @@a2@@ + Number ) = Number ; do { * ( _BYTE * ) -- @@v4@@ = @@a1@@ % Number + Number ; @@a1@@ /= Number ; } while ( @@a1@@ ) ; return @@v4@@ ; }
__int64 __fastcall argmatch ( const char * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { __int64 @@result@@ ; char @@v7@@ ; __int64 @@i@@ ; __int64 @@v9@@ ; size_t @@n@@ ; @@v9@@ = Number ; @@v7@@ = Number ; @@n@@ = strlen ( @@a1@@ ) ; for ( @@i@@ = Number L ; * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; ++ @@i@@ ) { if ( ! strncmp ( * ( const char * * ) ( Number * @@i@@ + @@a2@@ ) , @@a1@@ , @@n@@ ) ) { if ( @@n@@ == strlen ( * ( const char * * ) ( Number * @@i@@ + @@a2@@ ) ) ) return @@i@@ ; if ( @@v9@@ == Number ) { @@v9@@ = @@i@@ ; } else if ( ! @@a3@@ || memcmp ( ( const void * ) ( @@a4@@ * @@v9@@ + @@a3@@ ) , ( const void * ) ( @@i@@ * @@a4@@ + @@a3@@ ) , @@a4@@ ) ) { @@v7@@ = Number ; } } } if ( @@v7@@ ) @@result@@ = Number ; else @@result@@ = @@v9@@ ; return @@result@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
size_t __fastcall print_name_with_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , struct obstack * @@a3@@ , unsigned __int64 @@a4@@ ) { __int64 @@v4@@ ; bool @@v5@@ ; bool @@v9@@ ; __int64 @@v10@@ ; size_t @@v11@@ ; if ( @@a2@@ ) @@v4@@ = @@a1@@ [ Number ] ; else @@v4@@ = * @@a1@@ ; @@v10@@ = @@v4@@ ; @@v5@@ = print_with_color && ( unsigned __int8 ) print_color_indicator ( @@a1@@ , @@a2@@ ) ; @@v9@@ = @@v5@@ ; if ( @@a3@@ && dired ) { if ( @@a3@@ -> next_free + Number > @@a3@@ -> chunk_limit ) _obstack_newchunk ( @@a3@@ , Number ) ; memcpy ( @@a3@@ -> next_free , & dired_pos , Number ) ; @@a3@@ -> next_free += Number ; } @@v11@@ = quote_name ( stdout , @@v10@@ , filename_quoting_options , Number L ) ; dired_pos += @@v11@@ ; if ( @@a3@@ && dired ) { if ( @@a3@@ -> next_free + Number > @@a3@@ -> chunk_limit ) _obstack_newchunk ( @@a3@@ , Number ) ; memcpy ( @@a3@@ -> next_free , & dired_pos , Number ) ; @@a3@@ -> next_free += Number ; } if ( @@v9@@ ) { process_signals ( ) ; prep_non_filename_text ( ) ; if ( @@a4@@ / line_length != ( @@a4@@ + @@v11@@ - Number ) / line_length ) put_indicator ( & unk_21F1F0 ) ; } return @@v11@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( ) ; return @@ptr@@ ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
int putchar_unlocked ( int @@c@@ ) { return putchar_unlocked ( @@c@@ ) ; }
int print_with_commas ( ) { char @@v1@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; @@v3@@ = Number L ; for ( @@i@@ = Number L ; @@i@@ < cwd_n_used ; ++ @@i@@ ) { @@v4@@ = * ( ( _QWORD * ) sorted_file + @@i@@ ) ; @@v5@@ = length_of_file_name_and_frills ( @@v4@@ ) ; if ( @@i@@ ) { if ( @@v3@@ + @@v5@@ + Number >= line_length ) { @@v3@@ = Number L ; @@v1@@ = Number ; } else { @@v3@@ += Number L ; @@v1@@ = Number ; } putchar_unlocked ( Number ) ; putchar_unlocked ( @@v1@@ ) ; } print_file_name_and_frills ( @@v4@@ , @@v3@@ ) ; @@v3@@ += @@v5@@ ; } return putchar_unlocked ( Number ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
_BYTE * __fastcall filemodestring ( __int64 @@a1@@ , _BYTE * @@a2@@ ) { return strmode ( * ( _DWORD * ) ( @@a1@@ + Number ) , @@a2@@ ) ; }
void * __fastcall realloc_groupbuf ( void * @@a1@@ , unsigned __int64 @@a2@@ ) { if ( @@a2@@ <= Number ) return realloc ( @@a1@@ , Number * @@a2@@ ) ; * __errno_location ( ) = Number ; return Number L ; }
unsigned __int64 __fastcall xstrtol_error ( unsigned int @@a1@@ , int @@a2@@ , char @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , int @@a6@@ ) { char * @@v6@@ ; char * @@v10@@ ; char * @@msgid@@ ; char * @@v12@@ ; char @@v13@@ [ Number ] ; unsigned __int64 @@v14@@ ; @@v14@@ = __readfsqword ( Number ) ; @@v10@@ = ( char * ) & unk_1A278 ; if ( @@a1@@ > Number ) { if ( @@a1@@ != Number ) goto LABEL_6 ; @@msgid@@ = String ; } else if ( @@a1@@ >= Number ) { @@msgid@@ = String ; } else { if ( @@a1@@ != Number ) LABEL_6 : abort ( ) ; @@msgid@@ = String ; } if ( @@a2@@ >= Number ) { @@v12@@ = * ( char * * ) ( Number L * @@a2@@ + @@a4@@ ) ; } else { @@v10@@ = ( char * ) & unk_1A278 - @@a2@@ ; @@v13@@ [ Number ] = @@a3@@ ; @@v13@@ [ Number ] = Number ; @@v12@@ = @@v13@@ ; } @@v6@@ = gettext ( @@msgid@@ ) ; error ( @@a6@@ , Number , @@v6@@ , @@v10@@ , @@v12@@ , @@a5@@ ) ; return __readfsqword ( Number ) ^ @@v14@@ ; }
__int64 __fastcall hard_locale ( int @@a1@@ ) { unsigned __int8 @@v2@@ ; const char * @@s1@@ ; @@v2@@ = Number ; @@s1@@ = setlocale ( @@a1@@ , Number L ) ; if ( @@s1@@ && ( ! strcmp ( @@s1@@ , String ) || ! strcmp ( @@s1@@ , String ) ) ) @@v2@@ = Number ; return @@v2@@ ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; char * @@v3@@ ; FILE * @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; FILE * @@v10@@ ; char * @@v11@@ ; @@v1@@ = program_name ; if ( @@a1@@ ) { @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = gettext ( String ) ; printf ( @@v3@@ , @@v1@@ ) ; @@v4@@ = stdout ; @@v5@@ = gettext ( String String String String String String String String String String ) ; fputs_unlocked ( @@v5@@ , @@v4@@ ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; @@v8@@ = stdout ; @@v9@@ = gettext ( String ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = stdout ; @@v11@@ = gettext ( String ) ; fputs_unlocked ( @@v11@@ , @@v10@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
unsigned __int64 init_column_info ( ) { unsigned __int64 @@v0@@ ; unsigned __int64 @@result@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@j@@ ; unsigned __int64 @@v4@@ ; __int64 @@v5@@ ; unsigned __int64 @@k@@ ; unsigned __int64 @@v7@@ ; unsigned __int64 @@v8@@ ; @@v0@@ = max_idx ; if ( cwd_n_used <= ( unsigned __int64 ) max_idx ) @@v0@@ = cwd_n_used ; @@v7@@ = @@v0@@ ; if ( @@v0@@ > column_info_alloc_8572 ) { if ( @@v0@@ >= ( unsigned __int64 ) max_idx >> Number ) { column_info = xnrealloc ( column_info , max_idx , Number L ) ; @@v4@@ = max_idx ; } else { column_info = xnrealloc ( column_info , @@v0@@ , Number L ) ; @@v4@@ = Number * @@v7@@ ; } @@v8@@ = ( @@v4@@ - column_info_alloc_8572 ) * ( column_info_alloc_8572 + @@v4@@ + Number ) ; if ( column_info_alloc_8572 + @@v4@@ + Number < @@v4@@ || column_info_alloc_8572 + @@v4@@ + Number != @@v8@@ / ( @@v4@@ - column_info_alloc_8572 ) ) { xalloc_die ( ) ; } @@v5@@ = xnmalloc ( @@v8@@ >> Number , Number L ) ; for ( @@i@@ = column_info_alloc_8572 ; @@i@@ < @@v4@@ ; ++ @@i@@ ) { * ( _QWORD * ) ( column_info + Number * @@i@@ + Number ) = @@v5@@ ; @@v5@@ += Number * ( @@i@@ + Number ) ; } column_info_alloc_8572 = @@v4@@ ; } for ( @@j@@ = Number L ; ; ++ @@j@@ ) { @@result@@ = @@j@@ ; if ( @@j@@ >= @@v7@@ ) break ; * ( _BYTE * ) ( column_info + Number * @@j@@ ) = Number ; * ( _QWORD * ) ( column_info + Number * @@j@@ + Number ) = Number * ( @@j@@ + Number ) ; for ( @@k@@ = Number L ; @@k@@ <= @@j@@ ; ++ @@k@@ ) * ( _QWORD * ) ( Number * @@k@@ + * ( _QWORD * ) ( column_info + Number * @@j@@ + Number ) ) = Number L ; } return @@result@@ ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
_BOOL8 __fastcall c_iscntrl ( int @@a1@@ ) { return ( @@a1@@ & Number ) == Number || @@a1@@ == Number ; }
unsigned __int64 __fastcall hash_get_max_bucket_length ( __int64 @@a1@@ ) { _QWORD * @@i@@ ; unsigned __int64 @@v3@@ ; _QWORD * @@v4@@ ; unsigned __int64 @@j@@ ; @@v3@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { @@v4@@ = @@i@@ ; for ( @@j@@ = Number L ; ; ++ @@j@@ ) { @@v4@@ = ( _QWORD * ) @@v4@@ [ Number ] ; if ( ! @@v4@@ ) break ; } if ( @@j@@ > @@v3@@ ) @@v3@@ = @@j@@ ; } } return @@v3@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
_BOOL8 __fastcall c_isxdigit ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number || ( int ) ( @@a1@@ & Number ) > Number && ( int ) ( @@a1@@ & Number ) <= Number ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
__int64 __fastcall verrevcmp ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , unsigned __int64 @@a4@@ ) { int @@v4@@ ; int @@v5@@ ; unsigned int @@v9@@ ; int @@v10@@ ; unsigned __int64 @@v11@@ ; unsigned __int64 @@v12@@ ; @@v11@@ = Number L ; @@v12@@ = Number L ; while ( @@v11@@ < @@a2@@ || @@v12@@ < @@a4@@ ) { @@v9@@ = Number ; while ( @@v11@@ < @@a2@@ && ( unsigned __int8 ) c_isdigit ( ( unsigned int ) * ( char * ) ( @@a1@@ + @@v11@@ ) ) != Number || @@v12@@ < @@a4@@ && ( unsigned __int8 ) c_isdigit ( ( unsigned int ) * ( char * ) ( @@a3@@ + @@v12@@ ) ) != Number ) { if ( @@v11@@ == @@a2@@ ) @@v4@@ = Number ; else @@v4@@ = order ( * ( _BYTE * ) ( @@a1@@ + @@v11@@ ) ) ; @@v10@@ = @@v4@@ ; if ( @@v12@@ == @@a4@@ ) @@v5@@ = Number ; else @@v5@@ = order ( * ( _BYTE * ) ( @@a3@@ + @@v12@@ ) ) ; if ( @@v10@@ != @@v5@@ ) return ( unsigned int ) ( @@v10@@ - @@v5@@ ) ; ++ @@v11@@ ; ++ @@v12@@ ; } while ( * ( _BYTE * ) ( @@a1@@ + @@v11@@ ) == Number ) ++ @@v11@@ ; while ( * ( _BYTE * ) ( @@a3@@ + @@v12@@ ) == Number ) ++ @@v12@@ ; while ( ( unsigned __int8 ) c_isdigit ( ( unsigned int ) * ( char * ) ( @@a1@@ + @@v11@@ ) ) && ( unsigned __int8 ) c_isdigit ( ( unsigned int ) * ( char * ) ( @@a3@@ + @@v12@@ ) ) ) { if ( ! @@v9@@ ) @@v9@@ = * ( char * ) ( @@a1@@ + @@v11@@ ) - * ( char * ) ( @@a3@@ + @@v12@@ ) ; ++ @@v11@@ ; ++ @@v12@@ ; } if ( ( unsigned __int8 ) c_isdigit ( ( unsigned int ) * ( char * ) ( @@a1@@ + @@v11@@ ) ) ) return Number L ; if ( ( unsigned __int8 ) c_isdigit ( ( unsigned int ) * ( char * ) ( @@a3@@ + @@v12@@ ) ) ) return Number ; if ( @@v9@@ ) return @@v9@@ ; } return Number L ; }
__int64 __fastcall hash_get_next ( __int64 * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; _QWORD * @@v4@@ ; _QWORD * @@i@@ ; @@v2@@ = * @@a1@@ ; @@v4@@ = ( _QWORD * ) ( @@v2@@ + Number * ( ( __int64 ( __fastcall * ) ( __int64 , __int64 ) ) @@a1@@ [ Number ] ) ( @@a2@@ , @@a1@@ [ Number ] ) ) ; if ( ( unsigned __int64 ) @@v4@@ >= @@a1@@ [ Number ] ) abort ( ) ; for ( @@i@@ = @@v4@@ ; @@i@@ ; @@i@@ = ( _QWORD * ) @@i@@ [ Number ] ) { if ( @@a2@@ == * @@i@@ && @@i@@ [ Number ] ) return * ( _QWORD * ) @@i@@ [ Number ] ; } while ( Number ) { @@v4@@ += Number ; if ( ( unsigned __int64 ) @@v4@@ >= @@a1@@ [ Number ] ) break ; if ( * @@v4@@ ) return * @@v4@@ ; } return Number L ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
unsigned __int64 __fastcall raw_hasher ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return rotr_sz ( @@a1@@ , Number ) % @@a2@@ ; }
int __fastcall lstat ( char * @@filename@@ , struct stat * @@stat_buf@@ ) { return __lxstat ( Number , @@filename@@ , @@stat_buf@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_208038 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
__int64 __fastcall mbsnwidth ( char * @@a1@@ , __int64 @@a2@@ , char @@a3@@ ) { int @@v3@@ ; char * @@v5@@ ; unsigned __int8 @@v7@@ ; wchar_t @@pwc@@ ; unsigned int @@v9@@ ; int @@v10@@ ; char * @@v11@@ ; size_t @@v12@@ ; char * @@v13@@ ; mbstate_t @@s@@ [ Number ] ; @@s@@ [ Number ] = ( mbstate_t ) __readfsqword ( Number ) ; @@v11@@ = @@a1@@ ; @@v13@@ = & @@a1@@ [ @@a2@@ ] ; @@v9@@ = Number ; if ( __ctype_get_mb_cur_max ( ) > Number ) { while ( Number ) { LABEL_28 : if ( @@v11@@ >= @@v13@@ ) return @@v9@@ ; @@v3@@ = * @@v11@@ ; if ( @@v3@@ > Number ) { if ( @@v3@@ < Number || @@v3@@ > Number && ( unsigned int ) ( @@v3@@ - Number ) > Number ) { LABEL_11 : memset ( @@s@@ , Number , Number ) ; while ( Number ) { @@v12@@ = mbrtowc ( & @@pwc@@ , @@v11@@ , @@v13@@ - @@v11@@ , @@s@@ ) ; if ( @@v12@@ == Number ) { if ( ( @@a3@@ & Number ) == Number ) { ++ @@v11@@ ; ++ @@v9@@ ; goto LABEL_28 ; } return Number ; } if ( @@v12@@ == Number ) break ; if ( ! @@v12@@ ) @@v12@@ = Number L ; @@v10@@ = wcwidth ( @@pwc@@ ) ; if ( @@v10@@ < Number ) { if ( ( @@a3@@ & Number ) != Number ) return Number ; @@v9@@ += iswcntrl ( @@pwc@@ ) == Number ; } else { @@v9@@ += @@v10@@ ; } @@v11@@ += @@v12@@ ; if ( mbsinit ( @@s@@ ) ) goto LABEL_28 ; } if ( ( @@a3@@ & Number ) == Number ) { @@v11@@ = @@v13@@ ; ++ @@v9@@ ; continue ; } return Number ; } } else if ( @@v3@@ < Number && ( unsigned int ) ( @@v3@@ - Number ) > Number ) { goto LABEL_11 ; } ++ @@v11@@ ; ++ @@v9@@ ; } } while ( @@v11@@ < @@v13@@ ) { @@v5@@ = @@v11@@ ++ ; @@v7@@ = * @@v5@@ ; if ( ( ( * __ctype_b_loc ( ) ) [ @@v7@@ ] & Number ) != Number ) { ++ @@v9@@ ; } else { if ( ( @@a3@@ & Number ) != Number ) return Number ; @@v9@@ += ( ( * __ctype_b_loc ( ) ) [ @@v7@@ ] & Number ) == Number ; } } return @@v9@@ ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
unsigned __int64 __fastcall compute_bucket_size ( __int64 @@a1@@ , __int64 @@a2@@ ) { float @@v2@@ ; unsigned __int64 @@result@@ ; unsigned __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; float @@v6@@ ; @@v4@@ = @@a1@@ ; if ( * ( _BYTE * ) ( @@a2@@ + Number ) != Number ) { if ( @@a1@@ < Number ) @@v2@@ = ( float ) ( @@a1@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@a1@@ >> Number ) ) + ( float ) ( @@a1@@ & Number | ( unsigned int ) ( ( unsigned __int64 ) @@a1@@ >> Number ) ) ; else @@v2@@ = ( float ) ( int ) @@a1@@ ; @@v6@@ = @@v2@@ / * ( float * ) ( @@a2@@ + Number ) ; if ( @@v6@@ >= Number ) return Number L ; if ( @@v6@@ >= Number ) @@v4@@ = ( unsigned int ) ( int ) ( float ) ( @@v6@@ - Number ) ^ Number ; else @@v4@@ = ( unsigned int ) ( int ) @@v6@@ ; } @@v5@@ = next_prime ( @@v4@@ ) ; if ( @@v5@@ <= Number ) @@result@@ = @@v5@@ ; else @@result@@ = Number L ; return @@result@@ ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_208038 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall _xargmatch_internal ( __int64 @@a1@@ , const char * @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ , void ( * @@a6@@ ) ( void ) ) { __int64 @@v11@@ ; @@v11@@ = argmatch ( @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; if ( @@v11@@ >= Number ) return @@v11@@ ; argmatch_invalid ( @@a1@@ , ( __int64 ) @@a2@@ , @@v11@@ ) ; argmatch_valid ( @@a3@@ , @@a4@@ , @@a5@@ ) ; @@a6@@ ( ) ; return Number ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 __fastcall transfer_entries ( __int64 @@a1@@ , __int64 @@a2@@ , char @@a3@@ ) { __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 * @@i@@ ; _QWORD * @@j@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; _QWORD * @@v11@@ ; _QWORD * @@v12@@ ; _QWORD * @@v13@@ ; _QWORD * @@v14@@ ; for ( @@i@@ = * ( __int64 * * ) @@a2@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a2@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = ( _QWORD * ) @@i@@ [ Number ] ; @@j@@ ; @@j@@ = @@v14@@ ) { @@v9@@ = * @@j@@ ; @@v3@@ = * ( _QWORD * ) @@a1@@ ; @@v11@@ = ( _QWORD * ) ( @@v3@@ + Number * ( * ( __int64 ( __fastcall * * ) ( _QWORD , _QWORD ) ) ( @@a1@@ + Number ) ) ( * @@j@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@v11@@ >= * ( _QWORD * ) ( @@a1@@ + Number ) ) abort ( ) ; @@v14@@ = ( _QWORD * ) @@j@@ [ Number ] ; if ( * @@v11@@ ) { @@j@@ [ Number ] = @@v11@@ [ Number ] ; @@v11@@ [ Number ] = @@j@@ ; } else { * @@v11@@ = @@v9@@ ; ++ * ( _QWORD * ) ( @@a1@@ + Number ) ; free_entry ( @@a1@@ , @@j@@ ) ; } } @@v10@@ = * @@i@@ ; @@i@@ [ Number ] = Number L ; if ( ! @@a3@@ ) { @@v4@@ = * ( _QWORD * ) @@a1@@ ; @@v12@@ = ( _QWORD * ) ( @@v4@@ + Number * ( * ( __int64 ( __fastcall * * ) ( __int64 , _QWORD ) ) ( @@a1@@ + Number ) ) ( @@v10@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ) ; if ( ( unsigned __int64 ) @@v12@@ >= * ( _QWORD * ) ( @@a1@@ + Number ) ) abort ( ) ; if ( * @@v12@@ ) { @@v13@@ = allocate_entry ( @@a1@@ ) ; if ( ! @@v13@@ ) return Number L ; * @@v13@@ = @@v10@@ ; @@v13@@ [ Number ] = @@v12@@ [ Number ] ; @@v12@@ [ Number ] = @@v13@@ ; } else { * @@v12@@ = @@v10@@ ; ++ * ( _QWORD * ) ( @@a1@@ + Number ) ; } * @@i@@ = Number L ; -- * ( _QWORD * ) ( @@a2@@ + Number ) ; } } } return Number L ; }
int __fastcall userid_compare ( const void * @@a1@@ , const void * @@a2@@ ) { return strcmp ( * ( const char * * ) @@a1@@ , * ( const char * * ) @@a2@@ ) ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
__int64 __fastcall ftypelet ( __int16 @@a1@@ ) { switch ( @@a1@@ & Number ) { case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; case Number : return Number L ; } return Number L ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
_BYTE * __fastcall longest_relative_suffix ( _BYTE * @@a1@@ ) { while ( * @@a1@@ == Number ) ++ @@a1@@ ; return @@a1@@ ; }
__int64 __fastcall hash_get_n_buckets_used ( __int64 @@a1@@ ) { return * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
int __cdecl __noreturn main ( int @@argc@@ , const char * * @@argv@@ , const char * * @@envp@@ ) { __int64 @@v3@@ ; char * @@v4@@ ; set_program_name ( * @@argv@@ , @@argv@@ , @@envp@@ ) ; setlocale ( Number , & shortopts ) ; bindtextdomain ( String , String ) ; textdomain ( String ) ; atexit ( close_stdout ) ; parse_long_options ( @@argc@@ , ( _DWORD ) @@argv@@ , ( unsigned int ) String , ( unsigned int ) String , ( _DWORD ) Version , ( unsigned int ) usage , String , String , Number L ) ; if ( getopt_long ( @@argc@@ , ( char * const * ) @@argv@@ , & shortopts , Number L , Number L ) != Number ) usage ( Number ) ; if ( @@argc@@ == optind ) { users ( String , Number ) ; } else { if ( @@argc@@ - optind != Number ) { @@v3@@ = quote ( @@argv@@ [ optind + Number ] ) ; @@v4@@ = gettext ( String ) ; error ( Number , Number , @@v4@@ , @@v3@@ ) ; usage ( Number ) ; } users ( @@argv@@ [ optind ] , Number ) ; } exit ( Number ) ; }
_BOOL8 __fastcall hash_table_ok ( __int64 @@a1@@ ) { _QWORD * @@i@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; _QWORD * @@v5@@ ; @@v3@@ = Number L ; @@v4@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { @@v5@@ = @@i@@ ; ++ @@v3@@ ; ++ @@v4@@ ; while ( Number ) { @@v5@@ = ( _QWORD * ) @@v5@@ [ Number ] ; if ( ! @@v5@@ ) break ; ++ @@v4@@ ; } } } return @@v3@@ == * ( _QWORD * ) ( @@a1@@ + Number ) && @@v4@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ; }
__int64 __fastcall getuidbyname ( const char * @@a1@@ ) { __int64 @@result@@ ; size_t @@v2@@ ; __int64 @@i@@ ; __int64 @@j@@ ; __int64 @@v5@@ ; struct passwd * @@v6@@ ; for ( @@i@@ = user_alist ; @@i@@ ; @@i@@ = * ( _QWORD * ) ( @@i@@ + Number ) ) { if ( * ( _BYTE * ) ( @@i@@ + Number ) == * @@a1@@ && ! strcmp ( ( const char * ) ( @@i@@ + Number ) , @@a1@@ ) ) { return @@i@@ ; } } for ( @@j@@ = nouser_alist ; @@j@@ ; @@j@@ = * ( _QWORD * ) ( @@j@@ + Number ) ) { if ( * ( _BYTE * ) ( @@j@@ + Number ) == * @@a1@@ && ! strcmp ( ( const char * ) ( @@j@@ + Number ) , @@a1@@ ) ) { return Number L ; } } @@v6@@ = getpwnam ( @@a1@@ ) ; @@v2@@ = strlen ( @@a1@@ ) ; @@v5@@ = xmalloc ( @@v2@@ + Number ) ; strcpy ( ( char * ) ( @@v5@@ + Number ) , @@a1@@ ) ; if ( @@v6@@ ) { * ( _DWORD * ) @@v5@@ = @@v6@@ -> pw_uid ; * ( _QWORD * ) ( @@v5@@ + Number ) = user_alist ; user_alist = @@v5@@ ; @@result@@ = @@v5@@ ; } else { * ( _QWORD * ) ( @@v5@@ + Number ) = nouser_alist ; nouser_alist = @@v5@@ ; @@result@@ = Number L ; } return @@result@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
unsigned __int64 __fastcall hash_get_entries ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; _QWORD * @@i@@ ; _QWORD * @@j@@ ; @@v5@@ = Number L ; for ( @@i@@ = * ( _QWORD * * ) @@a1@@ ; ( unsigned __int64 ) @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ += Number ) { if ( * @@i@@ ) { for ( @@j@@ = @@i@@ ; @@j@@ ; @@j@@ = ( _QWORD * ) @@j@@ [ Number ] ) { if ( @@v5@@ >= @@a3@@ ) return @@v5@@ ; @@v4@@ = @@v5@@ ++ ; * ( _QWORD * ) ( @@a2@@ + Number * @@v4@@ ) = * @@j@@ ; } } } return @@v5@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
void __fastcall mpsort_with_tmp ( __int64 * @@a1@@ , unsigned __int64 @@a2@@ , __int64 * @@a3@@ , __int64 ( __fastcall * @@a4@@ ) ( __int64 , __int64 ) ) { int @@i@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; __int64 @@v12@@ ; __int64 @@v13@@ ; unsigned __int64 @@v14@@ ; __int64 @@v15@@ ; __int64 @@v16@@ ; if ( @@a2@@ > Number ) { @@v10@@ = Number L ; @@v14@@ = @@a2@@ >> Number ; @@v11@@ = @@a2@@ >> Number ; mpsort_with_tmp ( & @@a1@@ [ @@a2@@ >> Number ] , @@a2@@ - ( @@a2@@ >> Number ) , @@a3@@ , @@a4@@ ) ; if ( @@a2@@ >> Number > Number ) mpsort_into_tmp ( @@a1@@ , @@a2@@ >> Number , @@a3@@ , @@a4@@ ) ; else * @@a3@@ = * @@a1@@ ; @@v13@@ = * @@a3@@ ; @@v12@@ = @@a1@@ [ @@v11@@ ] ; @@v9@@ = Number L ; for ( @@i@@ = @@a4@@ ( * @@a3@@ , @@v12@@ ) ; ; @@i@@ = @@a4@@ ( @@v13@@ , @@v12@@ ) ) { while ( @@i@@ <= Number ) { @@v5@@ = @@v9@@ ++ ; @@a1@@ [ @@v5@@ ] = @@v13@@ ; if ( ++ @@v10@@ == @@v14@@ ) return ; @@v13@@ = @@a3@@ [ @@v10@@ ] ; @@i@@ = @@a4@@ ( @@v13@@ , @@v12@@ ) ; } @@v6@@ = @@v9@@ ++ ; @@a1@@ [ @@v6@@ ] = @@v12@@ ; if ( ++ @@v11@@ == @@a2@@ ) break ; @@v12@@ = @@a1@@ [ @@v11@@ ] ; } memcpy ( & @@a1@@ [ @@v9@@ ] , & @@a3@@ [ @@v10@@ ] , Number * ( @@v14@@ - @@v10@@ ) ) ; } else if ( @@a2@@ == Number ) { @@v15@@ = * @@a1@@ ; @@v16@@ = @@a1@@ [ Number ] ; if ( ( int ) @@a4@@ ( * @@a1@@ , @@v16@@ ) > Number ) { * @@a1@@ = @@v16@@ ; @@a1@@ [ Number ] = @@v15@@ ; } } }
__int64 __fastcall free_entry ( __int64 @@a1@@ , _QWORD * @@a2@@ ) { __int64 @@result@@ ; * @@a2@@ = Number L ; @@a2@@ [ Number ] = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@result@@ = @@a1@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; return @@result@@ ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
long double __fastcall adjust_value ( int @@a1@@ , long double @@a2@@ ) { _BOOL4 @@v7@@ ; unsigned __int64 @@v9@@ ; if ( @@a1@@ != Number && @@a2@@ < Number ) { if ( @@a2@@ >= Number ) @@v9@@ = ( __int64 ) ( @@a2@@ - Number ) ^ Number ; else @@v9@@ = ( __int64 ) @@a2@@ ; @@v7@@ = ! @@a1@@ && @@a2@@ != ( long double ) @@v9@@ ; @@a2@@ = ( long double ) ( @@v7@@ + @@v9@@ ) ; } return @@a2@@ ; }
bool __fastcall different ( const void * @@a1@@ , const void * @@a2@@ , unsigned __int64 @@a3@@ , unsigned __int64 @@a4@@ ) { bool @@v4@@ ; bool @@result@@ ; bool @@v6@@ ; __int64 @@v7@@ ; __int64 @@n@@ ; @@n@@ = @@a3@@ ; @@v7@@ = @@a4@@ ; if ( @@a3@@ > check_chars ) @@n@@ = check_chars ; if ( @@a4@@ > check_chars ) @@v7@@ = check_chars ; if ( ignore_case ) { @@v4@@ = @@n@@ != @@v7@@ || ( unsigned int ) memcasecmp ( @@a1@@ , @@a2@@ , @@n@@ ) ; @@result@@ = @@v4@@ ; } else if ( hard_LC_COLLATE ) { @@result@@ = ( unsigned int ) xmemcoll ( @@a1@@ , @@n@@ , @@a2@@ , @@v7@@ ) != Number ; } else { @@v6@@ = @@n@@ != @@v7@@ || memcmp ( @@a1@@ , @@a2@@ , @@n@@ ) ; @@result@@ = @@v6@@ ; } return @@result@@ ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_207028 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
unsigned __int64 __fastcall find_field ( __int64 @@a1@@ ) { const unsigned __int16 * @@v1@@ ; const unsigned __int16 * @@v2@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@j@@ ; unsigned __int64 @@v6@@ ; __int64 @@v7@@ ; unsigned __int64 @@v8@@ ; @@v7@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v8@@ = * ( _QWORD * ) ( @@a1@@ + Number ) - Number L ; @@v6@@ = Number L ; for ( @@i@@ = Number L ; @@i@@ < skip_fields ; ++ @@i@@ ) { while ( @@v6@@ < @@v8@@ ) { @@v1@@ = * __ctype_b_loc ( ) ; if ( ( @@v1@@ [ ( unsigned __int8 ) to_uchar ( * ( _BYTE * ) ( @@v7@@ + @@v6@@ ) ) ] & Number ) == Number ) break ; ++ @@v6@@ ; } while ( @@v6@@ < @@v8@@ ) { @@v2@@ = * __ctype_b_loc ( ) ; if ( ( @@v2@@ [ ( unsigned __int8 ) to_uchar ( * ( _BYTE * ) ( @@v7@@ + @@v6@@ ) ) ] & Number ) != Number ) break ; ++ @@v6@@ ; } } for ( @@j@@ = Number L ; @@j@@ < skip_chars && @@v6@@ < @@v8@@ ; ++ @@j@@ ) { ++ @@v6@@ ; } return * ( _QWORD * ) ( @@a1@@ + Number ) + @@v6@@ ; }
__int64 default_block_size ( ) { __int64 @@result@@ ; if ( getenv ( String ) ) @@result@@ = Number L ; else @@result@@ = Number L ; return @@result@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
__int64 __fastcall getgroup ( __gid_t @@a1@@ ) { const char * @@v1@@ ; size_t @@v2@@ ; __int64 @@result@@ ; __int64 @@i@@ ; __int64 @@v5@@ ; struct group * @@v6@@ ; char * @@s@@ ; @@v5@@ = Number L ; for ( @@i@@ = group_alist ; @@i@@ ; @@i@@ = * ( _QWORD * ) ( @@i@@ + Number ) ) { if ( @@a1@@ == * ( _DWORD * ) @@i@@ ) { @@v5@@ = @@i@@ ; break ; } } if ( ! @@v5@@ ) { @@v6@@ = getgrgid ( @@a1@@ ) ; if ( @@v6@@ ) @@v1@@ = @@v6@@ -> gr_name ; else @@v1@@ = ( const char * ) & unk_19CC0 ; @@s@@ = ( char * ) @@v1@@ ; @@v2@@ = strlen ( @@v1@@ ) ; @@v5@@ = xmalloc ( @@v2@@ + Number ) ; * ( _DWORD * ) @@v5@@ = @@a1@@ ; strcpy ( ( char * ) ( @@v5@@ + Number ) , @@s@@ ) ; * ( _QWORD * ) ( @@v5@@ + Number ) = group_alist ; group_alist = @@v5@@ ; } if ( * ( _BYTE * ) ( @@v5@@ + Number ) ) @@result@@ = @@v5@@ + Number ; else @@result@@ = Number L ; return @@result@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
int __fastcall argmatch_valid ( __int64 @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { char * @@v3@@ ; __int64 @@i@@ ; void * @@s1@@ ; @@s1@@ = Number L ; @@v3@@ = gettext ( String ) ; fprintf ( stderr , @@v3@@ ) ; for ( @@i@@ = Number L ; * ( _QWORD * ) ( Number * @@i@@ + @@a1@@ ) ; ++ @@i@@ ) { if ( @@i@@ && ! memcmp ( @@s1@@ , ( const void * ) ( @@i@@ * @@a3@@ + @@a2@@ ) , @@a3@@ ) ) { fprintf ( stderr , String , * ( const char * * ) ( Number * @@i@@ + @@a1@@ ) ) ; } else { fprintf ( stderr , String , * ( const char * * ) ( Number * @@i@@ + @@a1@@ ) ) ; @@s1@@ = ( void * ) ( @@i@@ * @@a3@@ + @@a2@@ ) ; } } return putc_unlocked ( Number , stderr ) ; }
__int64 __fastcall _xargmatch_internal ( __int64 @@a1@@ , const char * @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ , void ( * @@a6@@ ) ( void ) ) { __int64 @@v11@@ ; @@v11@@ = argmatch ( @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ ) ; if ( @@v11@@ >= Number ) return @@v11@@ ; argmatch_invalid ( @@a1@@ , ( __int64 ) @@a2@@ , @@v11@@ ) ; argmatch_valid ( @@a3@@ , @@a4@@ , @@a5@@ ) ; @@a6@@ ( ) ; return Number ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 __fastcall memcpy_lowcase ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { while ( @@a3@@ -- ) * ( _BYTE * ) ( @@a1@@ + @@a3@@ ) = tolower ( * ( unsigned __int8 * ) ( @@a2@@ + @@a3@@ ) ) ; return @@a1@@ ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
__int64 __fastcall memcasecmp ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int8 @@v5@@ ; int @@v6@@ ; unsigned int @@v7@@ ; unsigned __int64 @@i@@ ; for ( @@i@@ = Number L ; @@i@@ < @@a3@@ ; ++ @@i@@ ) { @@v5@@ = * ( _BYTE * ) ( @@a2@@ + @@i@@ ) ; @@v6@@ = toupper ( * ( unsigned __int8 * ) ( @@a1@@ + @@i@@ ) ) ; @@v7@@ = @@v6@@ - toupper ( @@v5@@ ) ; if ( @@v7@@ ) return @@v7@@ ; } return Number L ; }
__int64 __fastcall xnrealloc ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { if ( ! is_mul_ok ( @@a3@@ , @@a2@@ ) ) xalloc_die ( ) ; return xrealloc ( @@a1@@ , @@a3@@ * @@a2@@ ) ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
__int64 posix2_version ( ) { __int64 @@result@@ ; char * @@endptr@@ ; __int64 @@v2@@ ; char * @@nptr@@ ; __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; @@v5@@ = __readfsqword ( Number ) ; @@v2@@ = Number L ; @@nptr@@ = getenv ( String ) ; if ( @@nptr@@ ) { if ( * @@nptr@@ ) { @@v4@@ = strtol ( @@nptr@@ , & @@endptr@@ , Number ) ; if ( ! * @@endptr@@ ) @@v2@@ = @@v4@@ ; } } if ( @@v2@@ < ( __int64 ) Number ) return Number ; @@result@@ = Number ; if ( @@v2@@ <= Number ) @@result@@ = @@v2@@ ; return @@result@@ ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
void * __fastcall xzalloc ( size_t @@a1@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@a1@@ ) ; return memset ( @@v1@@ , Number , @@a1@@ ) ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( is_mul_ok ( @@a2@@ , * @@a1@@ ) ) { * @@a1@@ *= @@a2@@ ; @@result@@ = Number L ; } else { * @@a1@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_21F238 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
_BOOL8 __fastcall c_isalpha ( int @@a1@@ ) { return ( int ) ( @@a1@@ & Number ) > Number && ( int ) ( @@a1@@ & Number ) <= Number ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
__int64 __fastcall iso_week_days ( int @@a1@@ , int @@a2@@ ) { return ( unsigned int ) ( @@a1@@ - ( @@a1@@ - @@a2@@ + Number ) % Number + Number ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
_BOOL8 __fastcall c_isgraph ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ ) { return xmalloc ( @@a1@@ ) ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
_BOOL8 __fastcall c_isprint ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall look_up_char_class ( const char * @@a1@@ , size_t @@a2@@ ) { unsigned int @@i@@ ; for ( @@i@@ = Number ; @@i@@ <= Number ; ++ @@i@@ ) { if ( ! strncmp ( @@a1@@ , ( & char_class_name ) [ @@i@@ ] , @@a2@@ ) && @@a2@@ == strlen ( ( & char_class_name ) [ @@i@@ ] ) ) { return @@i@@ ; } } return Number L ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
__int64 __fastcall bkm_scale_by_power_0 ( unsigned __int64 * @@a1@@ , int @@a2@@ , int @@a3@@ ) { unsigned int @@i@@ ; for ( @@i@@ = Number ; @@a3@@ -- ; @@i@@ |= bkm_scale_0 ( @@a1@@ , @@a2@@ ) ) { ; } return @@i@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_209038 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
_BOOL8 __fastcall c_isascii ( int @@a1@@ ) { return @@a1@@ >= Number && @@a1@@ <= Number ; }
char * __fastcall make_printable_char ( unsigned __int8 @@a1@@ ) { char * @@s@@ ; @@s@@ = ( char * ) xmalloc ( Number L ) ; if ( ( ( * __ctype_b_loc ( ) ) [ @@a1@@ ] & Number ) != Number ) { * @@s@@ = @@a1@@ ; @@s@@ [ Number ] = Number ; } else { sprintf ( @@s@@ , String , @@a1@@ ) ; } return @@s@@ ; }
int utmpxname ( const char * @@file@@ ) { return utmpxname ( @@file@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
_BOOL8 __fastcall c_isalnum ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number || ( int ) ( @@a1@@ & Number ) > Number && ( int ) ( @@a1@@ & Number ) <= Number ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_209108 ; @@v4@@ [ Number ] = qword_209110 ; @@v4@@ [ Number ] = qword_209118 ; @@v4@@ [ Number ] = qword_209120 ; @@v4@@ [ Number ] = qword_209128 ; @@v4@@ [ Number ] = qword_209130 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
_BOOL8 __fastcall c_isdigit ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
int putchar_unlocked ( int @@c@@ ) { return putchar_unlocked ( @@c@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int64 __fastcall append_range ( __int64 @@a1@@ , unsigned __int8 @@a2@@ , unsigned __int8 @@a3@@ ) { char * @@v3@@ ; __int64 @@result@@ ; __int64 @@v6@@ ; char * @@ptr@@ ; char * @@v8@@ ; if ( @@a3@@ >= @@a2@@ ) { @@v6@@ = xmalloc ( Number L ) ; * ( _QWORD * ) ( @@v6@@ + Number ) = Number L ; * ( _DWORD * ) @@v6@@ = Number ; * ( _BYTE * ) ( @@v6@@ + Number ) = @@a2@@ ; * ( _BYTE * ) ( @@v6@@ + Number ) = @@a3@@ ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) __assert_fail ( String , String , Number , String ) ; * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L ) = @@v6@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v6@@ ; @@result@@ = Number L ; } else { @@ptr@@ = make_printable_char ( @@a2@@ ) ; @@v8@@ = make_printable_char ( @@a3@@ ) ; @@v3@@ = gettext ( String ) ; error ( Number , Number , @@v3@@ , @@ptr@@ , @@v8@@ ) ; free ( @@ptr@@ ) ; free ( @@v8@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
_BOOL8 __fastcall c_isspace ( int @@a1@@ ) { return @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
void __fastcall list_entries_users ( __int64 @@a1@@ , __int64 @@a2@@ ) { char @@v3@@ ; __int64 @@v5@@ ; char @@v6@@ ; unsigned __int64 @@i@@ ; size_t @@j@@ ; size_t @@nmemb@@ ; _QWORD * @@base@@ ; @@v5@@ = @@a1@@ ; @@base@@ = ( _QWORD * ) xnmalloc ( @@a1@@ , Number L ) ; @@nmemb@@ = Number L ; while ( @@v5@@ -- ) { if ( * ( _BYTE * ) ( @@a2@@ + Number ) && * ( _WORD * ) @@a2@@ == Number ) @@base@@ [ @@nmemb@@ ++ ] = extract_trimmed_name ( @@a2@@ ) ; @@a2@@ += Number L ; } qsort ( @@base@@ , @@nmemb@@ , Number , userid_compare ) ; for ( @@i@@ = Number L ; @@i@@ < @@nmemb@@ ; ++ @@i@@ ) { if ( @@i@@ >= @@nmemb@@ - Number ) @@v3@@ = Number ; else @@v3@@ = Number ; @@v6@@ = @@v3@@ ; fputs_unlocked ( ( const char * ) @@base@@ [ @@i@@ ] , stdout ) ; putchar_unlocked ( @@v6@@ ) ; } for ( @@j@@ = Number L ; @@j@@ < @@nmemb@@ ; ++ @@j@@ ) free ( ( void * ) @@base@@ [ @@j@@ ] ) ; free ( @@base@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return xmalloc ( @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall bkm_scale_0 ( unsigned __int64 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( is_mul_ok ( @@a2@@ , * @@a1@@ ) ) { * @@a1@@ *= @@a2@@ ; @@result@@ = Number L ; } else { * @@a1@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
_BOOL8 __fastcall star_digits_closebracket ( _QWORD * @@a1@@ , __int64 @@a2@@ ) { unsigned __int64 @@i@@ ; if ( ! es_match ( @@a1@@ , @@a2@@ , Number ) ) return Number L ; for ( @@i@@ = @@a2@@ + Number ; @@i@@ < @@a1@@ [ Number ] ; ++ @@i@@ ) { if ( ( unsigned int ) ( unsigned __int8 ) to_uchar ( * ( _BYTE * ) ( * @@a1@@ + @@i@@ ) ) - Number > Number || * ( _BYTE * ) ( @@a1@@ [ Number ] + @@i@@ ) ) { return es_match ( @@a1@@ , @@i@@ , Number ) ; } } return Number L ; }
int __fastcall stat ( char * @@filename@@ , struct stat * @@stat_buf@@ ) { return __xstat ( Number , @@filename@@ , @@stat_buf@@ ) ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( is_mul_ok ( @@a2@@ , * @@a1@@ ) ) { * @@a1@@ *= @@a2@@ ; @@result@@ = Number L ; } else { * @@a1@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
_BOOL8 __fastcall parse_str ( const char * @@a1@@ , __int64 @@a2@@ ) { bool @@v2@@ ; bool @@v4@@ ; void * @@v5@@ [ Number ] ; @@v5@@ [ Number ] = ( void * ) __readfsqword ( Number ) ; @@v2@@ = ( unsigned __int8 ) unquote ( @@a1@@ , @@v5@@ ) && ( unsigned __int8 ) build_spec_list ( ( __int64 * ) @@v5@@ , @@a2@@ ) ; @@v4@@ = @@v2@@ ; es_free ( @@v5@@ ) ; return @@v4@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) _frame_dummy_init_array_entry [ @@i@@ ] ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
__int64 __fastcall plain_read ( __int64 @@a1@@ , __int64 @@a2@@ ) { char * @@v2@@ ; int * @@v3@@ ; __int64 @@v5@@ ; @@v5@@ = safe_read ( Number L , @@a1@@ , @@a2@@ ) ; if ( @@v5@@ == Number ) { @@v2@@ = gettext ( String ) ; @@v3@@ = __errno_location ( ) ; error ( Number , * @@v3@@ , @@v2@@ ) ; } return @@v5@@ ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
int fileno ( FILE * @@stream@@ ) { return fileno ( @@stream@@ ) ; }
int putchar_unlocked ( int @@c@@ ) { return putchar_unlocked ( @@c@@ ) ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; char * @@v3@@ ; char * @@v4@@ ; FILE * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; @@v1@@ = program_name ; if ( @@a1@@ ) { @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = gettext ( String ) ; printf ( @@v3@@ , @@v1@@ ) ; @@v4@@ = gettext ( String String String ) ; printf ( @@v4@@ , String , String ) ; @@v5@@ = stdout ; @@v6@@ = gettext ( String ) ; fputs_unlocked ( @@v6@@ , @@v5@@ ) ; @@v7@@ = stdout ; @@v8@@ = gettext ( String ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
bool __fastcall hex_digits ( _BYTE * @@a1@@ ) { unsigned int @@i@@ ; for ( @@i@@ = Number ; @@i@@ < ( unsigned __int64 ) digest_hex_bytes ; ++ @@i@@ ) { if ( ( ( * __ctype_b_loc ( ) ) [ ( unsigned __int8 ) * @@a1@@ ] & Number ) == Number ) return Number ; ++ @@a1@@ ; } return * @@a1@@ == Number ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall digest_file ( const char * @@a1@@ , __int64 a2 , __int64 @@a3@@ ) { int @@v3@@ ; int @@v4@@ ; int * @@v5@@ ; int * @@v7@@ ; bool @@v9@@ ; FILE * @@stream@@ ; @@v3@@ = strcmp ( @@a1@@ , String ) ; @@v9@@ = @@v3@@ == Number ; if ( @@v3@@ ) { @@stream@@ = ( FILE * ) fopen_safer ( @@a1@@ , String ) ; if ( ! @@stream@@ ) goto LABEL_4 ; @@v4@@ = sha224_stream ( @@stream@@ , @@a3@@ ) ; } else { have_read_stdin = Number ; @@stream@@ = stdin ; @@v4@@ = sha224_stream ( stdin , @@a3@@ ) ; } if ( ! @@v4@@ ) { if ( @@v9@@ || ! fclose ( @@stream@@ ) ) return Number L ; LABEL_4 : @@v5@@ = __errno_location ( ) ; error ( Number , * @@v5@@ , String , @@a1@@ ) ; return Number L ; } @@v7@@ = __errno_location ( ) ; error ( Number , * @@v7@@ , String , @@a1@@ ) ; if ( @@stream@@ != stdin ) fclose ( @@stream@@ ) ; return Number L ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
_BOOL8 __fastcall desirable_utmp_entry ( __int64 @@a1@@ , char @@a2@@ ) { bool @@v2@@ ; @@v2@@ = * ( _BYTE * ) ( @@a1@@ + Number ) && * ( _WORD * ) @@a1@@ == Number ; if ( ( @@a2@@ & Number ) != Number && ! @@v2@@ ) return Number L ; return ( @@a2@@ & Number ) == Number || ! @@v2@@ || * ( int * ) ( @@a1@@ + Number ) > Number && ( kill ( * ( _DWORD * ) ( @@a1@@ + Number ) , Number ) >= Number || * __errno_location ( ) != Number ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_207028 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ ) { return xmalloc ( @@a1@@ ) ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_20D028 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
_BOOL8 __fastcall es_match ( _QWORD * @@a1@@ , __int64 @@a2@@ , char @@a3@@ ) { return @@a3@@ == * ( _BYTE * ) ( * @@a1@@ + @@a2@@ ) && * ( _BYTE * ) ( @@a1@@ [ Number ] + @@a2@@ ) != Number ; }
char * __fastcall extract_trimmed_name ( __int64 @@a1@@ ) { char * @@i@@ ; char * @@dest@@ ; @@dest@@ = ( char * ) xmalloc ( Number L ) ; strncpy ( @@dest@@ , ( const char * ) ( @@a1@@ + Number ) , Number ) ; @@dest@@ [ Number ] = Number ; for ( @@i@@ = & @@dest@@ [ strlen ( @@dest@@ ) ] ; @@dest@@ < @@i@@ && * ( @@i@@ - Number ) == Number ; * @@i@@ = Number ) { -- @@i@@ ; } return @@dest@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) _frame_dummy_init_array_entry [ @@i@@ ] ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_20D0E8 ; @@v4@@ [ Number ] = qword_20D0F0 ; @@v4@@ [ Number ] = qword_20D0F8 ; @@v4@@ [ Number ] = qword_20D100 ; @@v4@@ [ Number ] = qword_20D108 ; @@v4@@ [ Number ] = qword_20D110 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_20D028 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
__int64 __fastcall make_printable_str ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { char * @@v2@@ ; unsigned __int8 @@v4@@ ; char * @@dest@@ ; unsigned __int64 @@i@@ ; __int64 @@v7@@ ; char @@s@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v7@@ = xnmalloc ( @@a2@@ + Number , Number L ) ; @@dest@@ = ( char * ) @@v7@@ ; for ( @@i@@ = Number L ; @@i@@ < @@a2@@ ; ++ @@i@@ ) { @@v4@@ = * ( _BYTE * ) ( @@a1@@ + @@i@@ ) ; if ( @@v4@@ == Number ) { @@v2@@ = stpcpy ( @@dest@@ , String ) ; goto LABEL_24 ; } if ( @@v4@@ > Number ) { if ( @@v4@@ == Number ) { @@v2@@ = stpcpy ( @@dest@@ , String ) ; goto LABEL_24 ; } if ( @@v4@@ < Number ) { @@v2@@ = stpcpy ( @@dest@@ , String ) ; goto LABEL_24 ; } if ( @@v4@@ == Number ) { @@v2@@ = stpcpy ( @@dest@@ , String ) ; goto LABEL_24 ; } if ( @@v4@@ == Number ) { @@v2@@ = stpcpy ( @@dest@@ , String ) ; goto LABEL_24 ; } } else { if ( @@v4@@ == Number ) { @@v2@@ = stpcpy ( @@dest@@ , String ) ; goto LABEL_24 ; } if ( @@v4@@ > Number ) { @@v2@@ = stpcpy ( @@dest@@ , String ) ; goto LABEL_24 ; } if ( @@v4@@ == Number ) { @@v2@@ = stpcpy ( @@dest@@ , String ) ; goto LABEL_24 ; } } if ( ( ( * __ctype_b_loc ( ) ) [ @@v4@@ ] & Number ) != Number ) { @@s@@ [ Number ] = @@v4@@ ; @@s@@ [ Number ] = Number ; } else { sprintf ( @@s@@ , String , @@v4@@ ) ; } @@v2@@ = stpcpy ( @@dest@@ , @@s@@ ) ; LABEL_24 : @@dest@@ = @@v2@@ ; } return @@v7@@ ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall sha256_conclude_ctx ( __int64 @@a1@@ ) { __int64 @@v1@@ ; unsigned __int64 @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( @@v3@@ > Number ) @@v1@@ = Number L ; else @@v1@@ = Number L ; @@v4@@ = @@v1@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) += @@v3@@ ; if ( @@v3@@ > * ( unsigned int * ) ( @@a1@@ + Number ) ) ++ * ( _DWORD * ) ( @@a1@@ + Number ) ; set_uint32 ( ( _DWORD * ) ( Number * ( @@v1@@ - Number + Number ) + @@a1@@ ) , ( ( unsigned int ) ( * ( __int64 * ) ( @@a1@@ + Number ) >> Number ) >> Number ) | ( ( unsigned int ) ( * ( __int64 * ) ( @@a1@@ + Number ) >> Number ) >> Number ) & Number | ( ( unsigned int ) ( * ( __int64 * ) ( @@a1@@ + Number ) >> Number ) << Number ) & Number | ( ( unsigned int ) ( * ( __int64 * ) ( @@a1@@ + Number ) >> Number ) << Number ) ) ; set_uint32 ( ( _DWORD * ) ( Number * ( @@v4@@ - Number + Number ) + @@a1@@ ) , ( ( unsigned int ) ( Number * * ( _DWORD * ) ( @@a1@@ + Number ) ) >> Number ) | ( ( unsigned int ) ( Number * * ( _DWORD * ) ( @@a1@@ + Number ) ) >> Number ) & Number | ( * ( _DWORD * ) ( @@a1@@ + Number ) << Number ) & Number | ( * ( _DWORD * ) ( @@a1@@ + Number ) << Number ) ) ; memcpy ( ( void * ) ( @@a1@@ + Number + @@v3@@ ) , & fillbuf , Number * @@v4@@ - @@v3@@ - Number ) ; return sha256_process_block ( @@a1@@ + Number , Number * @@v4@@ , @@a1@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 __fastcall find_closing_delim ( _QWORD * @@a1@@ , unsigned __int64 @@a2@@ , char @@a3@@ , unsigned __int64 * @@a4@@ ) { while ( @@a2@@ < @@a1@@ [ Number ] - Number L ) { if ( @@a3@@ == * ( _BYTE * ) ( * @@a1@@ + @@a2@@ ) && * ( _BYTE * ) ( @@a2@@ + Number + * @@a1@@ ) == Number && * ( _BYTE * ) ( @@a1@@ [ Number ] + @@a2@@ ) != Number && * ( _BYTE * ) ( @@a2@@ + Number + @@a1@@ [ Number ] ) != Number ) { * @@a4@@ = @@a2@@ ; return Number L ; } ++ @@a2@@ ; } return Number L ; }
__int64 __fastcall sha224_buffer ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { char @@v5@@ [ Number ] ; unsigned __int64 @@v6@@ ; @@v6@@ = __readfsqword ( Number ) ; sha224_init_ctx ( ( __int64 ) @@v5@@ ) ; sha256_process_bytes ( @@a1@@ , @@a2@@ , @@v5@@ ) ; return sha224_finish_ctx ( ( __int64 ) @@v5@@ , @@a3@@ ) ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_20D0E8 ; @@v8@@ [ Number ] = qword_20D0F0 ; @@v8@@ [ Number ] = qword_20D0F8 ; @@v8@@ [ Number ] = qword_20D100 ; @@v8@@ [ Number ] = qword_20D108 ; @@v8@@ [ Number ] = qword_20D110 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 __fastcall sha256_finish_ctx ( __int64 @@a1@@ , __int64 @@a2@@ ) { sha256_conclude_ctx ( @@a1@@ ) ; return sha256_read_ctx ( @@a1@@ , @@a2@@ ) ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
__int64 __fastcall print_group_list ( __int64 @@a1@@ , __uid_t @@a2@@ , unsigned int @@a3@@ , unsigned int @@a4@@ , unsigned __int8 @@a5@@ ) { unsigned int @@v5@@ ; __int64 @@v6@@ ; char * @@v7@@ ; int * @@v8@@ ; char * @@v9@@ ; int * @@v10@@ ; __int64 @@result@@ ; unsigned __int8 @@v15@@ ; int @@i@@ ; int @@v17@@ ; void * @@ptr@@ ; struct passwd * @@v19@@ ; unsigned __int64 @@v20@@ ; @@v20@@ = __readfsqword ( Number ) ; @@v15@@ = Number ; @@v19@@ = getpwuid ( @@a2@@ ) ; if ( ! @@v19@@ ) @@v15@@ = Number ; if ( ( unsigned __int8 ) print_group ( @@a3@@ , @@a5@@ ) != Number ) @@v15@@ = Number ; if ( @@a4@@ != @@a3@@ ) { putchar_unlocked ( Number ) ; if ( ( unsigned __int8 ) print_group ( @@a4@@ , @@a5@@ ) != Number ) @@v15@@ = Number ; } if ( @@v19@@ ) @@v5@@ = @@v19@@ -> pw_gid ; else @@v5@@ = Number ; @@v17@@ = xgetgroups ( @@a1@@ , @@v5@@ , & @@ptr@@ ) ; if ( @@v17@@ >= Number ) { for ( @@i@@ = Number ; @@i@@ < @@v17@@ ; ++ @@i@@ ) { if ( @@a3@@ != * ( ( _DWORD * ) @@ptr@@ + @@i@@ ) && @@a4@@ != * ( ( _DWORD * ) @@ptr@@ + @@i@@ ) ) { putchar_unlocked ( Number ) ; if ( ( unsigned __int8 ) print_group ( * ( ( unsigned int * ) @@ptr@@ + @@i@@ ) , @@a5@@ ) != Number ) @@v15@@ = Number ; } } free ( @@ptr@@ ) ; @@result@@ = @@v15@@ ; } else { if ( @@a1@@ ) { @@v6@@ = quote ( @@a1@@ ) ; @@v7@@ = gettext ( String ) ; @@v8@@ = __errno_location ( ) ; error ( Number , * @@v8@@ , @@v7@@ , @@v6@@ ) ; } else { @@v9@@ = gettext ( String ) ; @@v10@@ = __errno_location ( ) ; error ( Number , * @@v10@@ , @@v9@@ ) ; } @@result@@ = Number L ; } return @@result@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 __fastcall sha256_buffer ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { char @@v5@@ [ Number ] ; unsigned __int64 @@v6@@ ; @@v6@@ = __readfsqword ( Number ) ; sha256_init_ctx ( ( __int64 ) @@v5@@ ) ; sha256_process_bytes ( @@a1@@ , @@a2@@ , @@v5@@ ) ; return sha256_finish_ctx ( ( __int64 ) @@v5@@ , @@a3@@ ) ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
__int64 __fastcall get_spec_stats ( __int64 @@a1@@ ) { int @@v1@@ ; char * @@v2@@ ; __int64 @@result@@ ; int @@j@@ ; int @@k@@ ; __int64 @@i@@ ; unsigned __int64 @@v7@@ ; __int64 @@v8@@ ; @@v7@@ = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; for ( @@i@@ = * ( _QWORD * ) ( * ( _QWORD * ) @@a1@@ + Number L ) ; @@i@@ ; @@i@@ = * ( _QWORD * ) ( @@i@@ + Number ) ) { @@v8@@ = Number L ; switch ( * ( _DWORD * ) @@i@@ ) { case Number : @@v8@@ = Number L ; break ; case Number : if ( * ( _BYTE * ) ( @@i@@ + Number ) < * ( _BYTE * ) ( @@i@@ + Number ) ) __assert_fail ( String , String , Number , String ) ; @@v8@@ = * ( unsigned __int8 * ) ( @@i@@ + Number ) - * ( unsigned __int8 * ) ( @@i@@ + Number ) + Number ; break ; case Number : * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; for ( @@j@@ = Number ; @@j@@ <= Number ; ++ @@j@@ ) { if ( is_char_class_member ( * ( _DWORD * ) ( @@i@@ + Number ) , @@j@@ ) ) ++ @@v8@@ ; } @@v1@@ = * ( _DWORD * ) ( @@i@@ + Number ) ; if ( @@v1@@ != Number && @@v1@@ != Number ) * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; break ; case Number : for ( @@k@@ = Number ; @@k@@ <= Number ; ++ @@k@@ ) { if ( is_equiv_class_member ( * ( _BYTE * ) ( @@i@@ + Number ) , @@k@@ ) ) ++ @@v8@@ ; } * ( _BYTE * ) ( @@a1@@ + Number ) = Number ; break ; case Number : if ( * ( _QWORD * ) ( @@i@@ + Number ) ) { @@v8@@ = * ( _QWORD * ) ( @@i@@ + Number ) ; } else { * ( _QWORD * ) ( @@a1@@ + Number ) = @@i@@ ; ++ * ( _QWORD * ) ( @@a1@@ + Number ) ; } break ; default : abort ( ) ; } if ( @@v7@@ > @@v7@@ + @@v8@@ || @@v7@@ + @@v8@@ == Number ) { @@v2@@ = gettext ( String ) ; error ( Number , Number , @@v2@@ ) ; } @@v7@@ += @@v8@@ ; } @@result@@ = @@a1@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v7@@ ; return @@result@@ ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 __fastcall rpl_fcntl ( int @@a1@@ , int @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , __m128 @@a7@@ , __m128 @@a8@@ , __m128 @@a9@@ , __m128 @@a10@@ , __m128 @@a11@@ , __m128 @@a12@@ , __m128 @@a13@@ , __m128 @@a14@@ ) { int @@v14@@ ; int @@v15@@ ; int @@v16@@ ; int @@v18@@ ; int @@v19@@ ; int @@v20@@ ; int @@v21@@ ; __int64 @@v22@@ ; __int64 @@v23@@ ; __int64 @@v24@@ ; __int64 @@v25@@ ; __m128 @@v26@@ ; __m128 @@v27@@ ; __m128 @@v28@@ ; __m128 @@v29@@ ; __m128 @@v30@@ ; __m128 @@v31@@ ; __m128 @@v32@@ ; __m128 @@v33@@ ; @@v22@@ = @@a3@@ ; @@v23@@ = @@a4@@ ; @@v24@@ = @@a5@@ ; @@v25@@ = @@a6@@ ; @@v26@@ = @@a7@@ ; @@v27@@ = @@a8@@ ; @@v28@@ = @@a9@@ ; @@v29@@ = @@a10@@ ; @@v30@@ = @@a11@@ ; @@v31@@ = @@a12@@ ; @@v32@@ = @@a13@@ ; @@v33@@ = @@a14@@ ; if ( @@a2@@ != Number ) return ( unsigned int ) fcntl ( @@a1@@ , @@a2@@ , @@v22@@ ) ; @@v19@@ = @@v22@@ ; if ( have_dupfd_cloexec_2895 < Number ) { @@v18@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v22@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; } else { @@v18@@ = fcntl ( @@a1@@ , Number , ( unsigned int ) @@v22@@ ) ; if ( @@v18@@ < Number && * __errno_location ( ) == Number ) { @@v18@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v19@@ , @@v14@@ , @@v15@@ , @@v16@@ ) ; if ( @@v18@@ < Number ) return ( unsigned int ) @@v18@@ ; have_dupfd_cloexec_2895 = Number ; } else { have_dupfd_cloexec_2895 = Number ; } } if ( @@v18@@ >= Number && have_dupfd_cloexec_2895 == Number ) { @@v20@@ = fcntl ( @@v18@@ , Number ) ; if ( @@v20@@ < Number || fcntl ( @@v18@@ , Number , @@v20@@ | Number ) == Number ) { @@v21@@ = * __errno_location ( ) ; close ( @@v18@@ ) ; * __errno_location ( ) = @@v21@@ ; @@v18@@ = Number ; } } return ( unsigned int ) @@v18@@ ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
__int64 __fastcall squeeze_filter ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 ( __fastcall * @@a3@@ ( ) ( char , sizet ) ) ( __int64 , __int64 ) ) { __int64 @@result@@ ; char * @@v4@@ ; int * @@v5@@ ; int @@v7@@ ; unsigned __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; __int64 @@n@@ ; unsigned __int64 @@v11@@ ; @@v7@@ = Number ; @@v8@@ = Number L ; @@v9@@ = Number L ; while ( Number ) { if ( @@v8@@ < @@v9@@ ) goto LABEL_5 ; @@result@@ = @@a3@@ ( ) ( char , sizet ) ( @@a1@@ , @@a2@@ ) ; @@v9@@ = @@result@@ ; if ( ! @@result@@ ) return @@result@@ ; @@v8@@ = Number L ; LABEL_5 : @@v11@@ = @@v8@@ ; if ( @@v7@@ == Number ) { while ( @@v8@@ < @@v9@@ && in_squeeze_set [ ( unsigned __int8 ) to_uchar ( * ( _BYTE * ) ( @@a1@@ + @@v8@@ ) ) ] != Number ) @@v8@@ += Number L ; if ( @@v8@@ == @@v9@@ && in_squeeze_set [ ( unsigned __int8 ) to_uchar ( * ( _BYTE * ) ( @@v8@@ - Number + @@a1@@ ) ) ] ) { -- @@v8@@ ; } if ( @@v8@@ < @@v9@@ ) { @@v7@@ = * ( char * ) ( @@a1@@ + @@v8@@ ) ; @@n@@ = @@v8@@ - @@v11@@ + Number ; if ( @@v8@@ && @@v7@@ == * ( char * ) ( @@v8@@ - Number + @@a1@@ ) ) @@n@@ = @@v8@@ - @@v11@@ ; ++ @@v8@@ ; } else { @@n@@ = @@v9@@ - @@v11@@ ; } if ( @@n@@ && @@n@@ != fwrite_unlocked ( ( const void * ) ( @@a1@@ + @@v11@@ ) , Number , @@n@@ , stdout ) ) { @@v4@@ = gettext ( String ) ; @@v5@@ = __errno_location ( ) ; error ( Number , * @@v5@@ , @@v4@@ ) ; } } if ( @@v7@@ != Number ) { while ( @@v8@@ < @@v9@@ && @@v7@@ == * ( char * ) ( @@a1@@ + @@v8@@ ) ) ++ @@v8@@ ; if ( @@v8@@ < @@v9@@ ) @@v7@@ = Number ; } } }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
__int64 __fastcall append_normal_char ( __int64 @@a1@@ , char @@a2@@ ) { __int64 @@result@@ ; __int64 @@v3@@ ; @@v3@@ = xmalloc ( Number L ) ; * ( _QWORD * ) ( @@v3@@ + Number ) = Number L ; * ( _DWORD * ) @@v3@@ = Number ; * ( _BYTE * ) ( @@v3@@ + Number ) = @@a2@@ ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) __assert_fail ( String , String , Number , String ) ; * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L ) = @@v3@@ ; @@result@@ = @@a1@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v3@@ ; return @@result@@ ; }
__int64 __fastcall bkm_scale_by_power ( unsigned __int64 * @@a1@@ , int @@a2@@ , int @@a3@@ ) { unsigned int @@i@@ ; for ( @@i@@ = Number ; @@a3@@ -- ; @@i@@ |= bkm_scale ( @@a1@@ , @@a2@@ ) ) ; return @@i@@ ; }
int setgid ( __gid_t @@gid@@ ) { return setgid ( @@gid@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
__int64 __fastcall append_equiv_class ( __int64 @@a1@@ , _BYTE * @@a2@@ , __int64 @@a3@@ ) { __int64 @@v4@@ ; if ( @@a3@@ != Number ) return Number L ; @@v4@@ = xmalloc ( Number L ) ; * ( _QWORD * ) ( @@v4@@ + Number ) = Number L ; * ( _DWORD * ) @@v4@@ = Number ; * ( _BYTE * ) ( @@v4@@ + Number ) = * @@a2@@ ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) __assert_fail ( String , String , Number , String ) ; * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L ) = @@v4@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v4@@ ; return Number L ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
_QWORD * __fastcall get_s2_spec_stats ( _QWORD * @@a1@@ , unsigned __int64 @@a2@@ ) { _QWORD * @@result@@ ; get_spec_stats ( ( __int64 ) @@a1@@ ) ; @@result@@ = ( _QWORD * ) @@a1@@ [ Number ] ; if ( @@a2@@ >= ( unsigned __int64 ) @@result@@ ) { @@result@@ = ( _QWORD * ) @@a1@@ [ Number ] ; if ( @@result@@ == ( _QWORD * ) ( ( char * ) & dword_0 + Number ) ) { * ( _QWORD * ) ( @@a1@@ [ Number ] + Number L ) = @@a2@@ - @@a1@@ [ Number ] ; @@result@@ = @@a1@@ ; @@a1@@ [ Number ] = @@a2@@ ; } } return @@result@@ ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
__int64 __fastcall getugroups ( int @@a1@@ , _DWORD * @@a2@@ , const char * @@a3@@ , int @@a4@@ ) { int @@v6@@ ; int @@j@@ ; int @@v8@@ ; const char * * @@i@@ ; struct group * @@v10@@ ; @@v6@@ = Number ; if ( @@a4@@ != Number ) { if ( @@a1@@ ) * @@a2@@ = @@a4@@ ; @@v6@@ = Number ; } setgrent ( ) ; while ( Number ) { * __errno_location ( ) = Number ; @@v10@@ = getgrent ( ) ; if ( ! @@v10@@ ) break ; for ( @@i@@ = ( const char * * ) @@v10@@ -> gr_mem ; * @@i@@ ; ++ @@i@@ ) { if ( ! strcmp ( @@a3@@ , * @@i@@ ) ) { for ( @@j@@ = Number ; @@j@@ < @@v6@@ && ( ! @@a2@@ || @@a2@@ [ @@j@@ ] != @@v10@@ -> gr_gid ) ; ++ @@j@@ ) { ; } if ( @@j@@ == @@v6@@ ) { if ( @@a1@@ ) { if ( @@v6@@ >= @@a1@@ ) goto LABEL_26 ; @@a2@@ [ @@v6@@ ] = @@v10@@ -> gr_gid ; } if ( @@v6@@ == Number ) { * __errno_location ( ) = Number ; goto LABEL_26 ; } ++ @@v6@@ ; } } } } if ( * __errno_location ( ) ) @@v6@@ = Number ; LABEL_26 : @@v8@@ = * __errno_location ( ) ; endgrent ( ) ; * __errno_location ( ) = @@v8@@ ; return ( unsigned int ) @@v6@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
__int64 __fastcall homogeneous_spec_list ( _QWORD * @@a1@@ ) { int @@v2@@ ; int @@v3@@ ; @@a1@@ [ Number ] = Number ; @@v2@@ = get_next ( @@a1@@ , Number L ) ; if ( @@v2@@ == Number ) return Number L ; while ( Number ) { @@v3@@ = get_next ( @@a1@@ , Number L ) ; if ( @@v3@@ == Number ) break ; if ( @@v3@@ != @@v2@@ ) return Number L ; } return Number L ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
int toupper ( int @@c@@ ) { return toupper ( @@c@@ ) ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
int fileno ( FILE * @@stream@@ ) { return fileno ( @@stream@@ ) ; }
unsigned __int64 __fastcall read_and_xlate ( __int64 @@a1@@ , __int64 @@a2@@ ) { unsigned __int64 @@i@@ ; unsigned __int64 @@v4@@ ; @@v4@@ = plain_read ( @@a1@@ , @@a2@@ ) ; for ( @@i@@ = Number L ; @@i@@ < @@v4@@ ; ++ @@i@@ ) * ( _BYTE * ) ( @@i@@ + @@a1@@ ) = xlate [ ( unsigned __int8 ) to_uchar ( * ( _BYTE * ) ( @@a1@@ + @@i@@ ) ) ] ; return @@v4@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_208028 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
int feof_unlocked ( FILE * @@stream@@ ) { return feof_unlocked ( @@stream@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall size_opt ( const char * @@a1@@ , const char * @@a2@@ ) { char * @@v2@@ ; __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; if ( ( unsigned int ) xstrtoul ( @@a1@@ , Number L , Number L , @@v4@@ , & locale ) > Number ) { @@v2@@ = gettext ( @@a2@@ ) ; error ( Number , Number , String , @@a1@@ , @@v2@@ ) ; } return @@v4@@ [ Number ] ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_2080E8 ; @@v8@@ [ Number ] = qword_2080F0 ; @@v8@@ [ Number ] = qword_2080F8 ; @@v8@@ [ Number ] = qword_208100 ; @@v8@@ [ Number ] = qword_208108 ; @@v8@@ [ Number ] = qword_208110 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , off_8E1E , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return xmalloc ( @@a1@@ , @@a2@@ , @@a3@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
void * __fastcall initbuffer ( void * @@a1@@ ) { return memset ( @@a1@@ , Number , Number ) ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
__int64 __fastcall readlinebuffer ( __int64 @@a1@@ , __int64 @@a2@@ ) { return readlinebuffer_delim ( @@a1@@ , @@a2@@ , Number L ) ; }
struct passwd * getpwnam ( const char * @@name@@ ) { return getpwnam ( @@name@@ ) ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
__int64 __fastcall bkm_scale ( unsigned __int64 * @@a1@@ , int @@a2@@ ) { __int64 @@result@@ ; if ( is_mul_ok ( @@a2@@ , * @@a1@@ ) ) { * @@a1@@ *= @@a2@@ ; @@result@@ = Number L ; } else { * @@a1@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_20B028 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
int __fastcall print_user ( __uid_t @@a1@@ ) { char * @@v1@@ ; int @@result@@ ; struct passwd * @@v3@@ ; @@v3@@ = Number L ; if ( use_name ) { @@v3@@ = getpwuid ( @@a1@@ ) ; if ( ! @@v3@@ ) { @@v1@@ = gettext ( String ) ; error ( Number , Number , @@v1@@ , @@a1@@ ) ; ok = Number ; } } if ( @@v3@@ ) @@result@@ = printf ( String , @@v3@@ -> pw_name ) ; else @@result@@ = printf ( String , @@a1@@ ) ; return @@result@@ ; }
__int64 * __fastcall readlinebuffer_delim ( __int64 * @@a1@@ , FILE * @@a2@@ , char @@a3@@ ) { _BYTE * @@v4@@ ; int @@v6@@ ; __int64 @@v7@@ ; _BYTE * @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; @@v7@@ = @@a1@@ [ Number ] ; @@v8@@ = ( _BYTE * ) @@v7@@ ; @@v9@@ = * @@a1@@ + @@v7@@ ; if ( feof_unlocked ( @@a2@@ ) ) return Number L ; while ( Number ) { @@v6@@ = getc_unlocked ( @@a2@@ ) ; if ( @@v6@@ == Number ) break ; LABEL_9 : if ( @@v8@@ == ( _BYTE * ) @@v9@@ ) { @@v10@@ = * @@a1@@ ; @@v7@@ = x2realloc ( @@v7@@ , @@a1@@ ) ; @@v8@@ = ( _BYTE * ) ( @@v7@@ + @@v10@@ ) ; @@a1@@ [ Number ] = @@v7@@ ; @@v9@@ = * @@a1@@ + @@v7@@ ; } @@v4@@ = @@v8@@ ++ ; * @@v4@@ = @@v6@@ ; if ( @@v6@@ == @@a3@@ ) goto LABEL_12 ; } if ( @@v8@@ == ( _BYTE * ) @@v7@@ || ferror_unlocked ( @@a2@@ ) ) return Number L ; if ( @@a3@@ != * ( @@v8@@ - Number ) ) { @@v6@@ = @@a3@@ ; goto LABEL_9 ; } LABEL_12 : @@a1@@ [ Number ] = ( __int64 ) & @@v8@@ [ - @@v7@@ ] ; return @@a1@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
int toupper ( int @@c@@ ) { return toupper ( @@c@@ ) ; }
__int64 __fastcall getugroups ( int @@a1@@ , _DWORD * @@a2@@ , const char * @@a3@@ , int @@a4@@ ) { int @@v6@@ ; int @@j@@ ; int @@v8@@ ; const char * * @@i@@ ; struct group * @@v10@@ ; @@v6@@ = Number ; if ( @@a4@@ != Number ) { if ( @@a1@@ ) * @@a2@@ = @@a4@@ ; @@v6@@ = Number ; } setgrent ( ) ; while ( Number ) { * __errno_location ( ) = Number ; @@v10@@ = getgrent ( ) ; if ( ! @@v10@@ ) break ; for ( @@i@@ = ( const char * * ) @@v10@@ -> gr_mem ; * @@i@@ ; ++ @@i@@ ) { if ( ! strcmp ( @@a3@@ , * @@i@@ ) ) { for ( @@j@@ = Number ; @@j@@ < @@v6@@ && ( ! @@a2@@ || @@a2@@ [ @@j@@ ] != @@v10@@ -> gr_gid ) ; ++ @@j@@ ) { ; } if ( @@j@@ == @@v6@@ ) { if ( @@a1@@ ) { if ( @@v6@@ >= @@a1@@ ) goto LABEL_26 ; @@a2@@ [ @@v6@@ ] = @@v10@@ -> gr_gid ; } if ( @@v6@@ == Number ) { * __errno_location ( ) = Number ; goto LABEL_26 ; } ++ @@v6@@ ; } } } } if ( * __errno_location ( ) ) @@v6@@ = Number ; LABEL_26 : @@v8@@ = * __errno_location ( ) ; endgrent ( ) ; * __errno_location ( ) = @@v8@@ ; return ( unsigned int ) @@v6@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
void __fastcall argmatch_invalid ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { char * @@v3@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; char * @@format@@ ; if ( @@a3@@ == Number ) @@v3@@ = gettext ( String ) ; else @@v3@@ = gettext ( String ) ; @@format@@ = @@v3@@ ; @@v4@@ = quote_n ( Number L , @@a1@@ ) ; @@v5@@ = quotearg_n_style ( Number L , Number L , @@a2@@ ) ; error ( Number , Number , @@format@@ , @@v5@@ , @@v4@@ ) ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_20D3C8 ; @@v8@@ [ Number ] = qword_20D3D0 ; @@v8@@ [ Number ] = qword_20D3D8 ; @@v8@@ [ Number ] = qword_20D3E0 ; @@v8@@ [ Number ] = qword_20D3E8 ; @@v8@@ [ Number ] = qword_20D3F0 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
char * nl_langinfo ( nl_item @@item@@ ) { return nl_langinfo ( @@item@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
__int64 __fastcall argmatch_to_argument ( const void * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; ++ @@i@@ ) { if ( ! memcmp ( @@a1@@ , ( const void * ) ( @@i@@ * @@a4@@ + @@a3@@ ) , @@a4@@ ) ) return * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; } return Number L ; }
wctype_t wctype ( const char * @@property@@ ) { return wctype ( @@property@@ ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
__int64 __fastcall protect_fd ( int @@a1@@ ) { int @@fd@@ ; @@fd@@ = open ( String , Number ) ; if ( @@fd@@ == @@a1@@ ) return Number L ; if ( @@fd@@ >= Number ) { close ( @@fd@@ ) ; * __errno_location ( ) = Number ; } return Number L ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 __fastcall copy_to_temp ( FILE * * @@a1@@ , char * * @@a2@@ , unsigned int @@a3@@ , __int64 @@a4@@ ) { size_t @@v4@@ ; size_t @@v5@@ ; __int64 @@v6@@ ; char * @@v7@@ ; int * @@v8@@ ; __int64 @@result@@ ; __int64 @@v10@@ ; char * @@v11@@ ; int * @@v12@@ ; __int64 @@v13@@ ; char * @@v14@@ ; int * @@v15@@ ; __int64 @@v16@@ ; char * @@v17@@ ; int * @@v18@@ ; int @@fd@@ ; char * @@name@@ ; FILE * @@stream@@ ; __int64 @@n@@ ; if ( ! template_5765 ) { tempdir_5766 = getenv ( String ) ; if ( ! tempdir_5766 ) tempdir_5766 = String ; @@v4@@ = strlen ( tempdir_5766 ) ; @@v5@@ = strlen ( String ) ; template_5765 = ( char * ) xmalloc ( @@v4@@ + @@v5@@ - Number ) ; sprintf ( template_5765 , String , tempdir_5766 ) ; } @@name@@ = template_5765 ; @@fd@@ = mkstemp_safer ( template_5765 ) ; if ( @@fd@@ >= Number ) { @@stream@@ = fdopen ( @@fd@@ , String ) ; if ( @@stream@@ ) { record_or_unlink_tempfile ( @@name@@ ) ; while ( Number ) { @@n@@ = safe_read ( @@a3@@ , G_buffer , read_size ) ; if ( ! @@n@@ ) break ; if ( @@n@@ == Number ) { @@v13@@ = quotearg_colon ( @@a4@@ ) ; @@v14@@ = gettext ( String ) ; @@v15@@ = __errno_location ( ) ; error ( Number , * @@v15@@ , @@v14@@ , @@v13@@ ) ; goto LABEL_17 ; } if ( @@n@@ != fwrite_unlocked ( G_buffer , Number , @@n@@ , @@stream@@ ) ) goto LABEL_14 ; } if ( ! fflush_unlocked ( @@stream@@ ) ) { * @@a1@@ = @@stream@@ ; * @@a2@@ = @@name@@ ; return Number L ; } LABEL_14 : @@v16@@ = quotearg_colon ( @@name@@ ) ; @@v17@@ = gettext ( String ) ; @@v18@@ = __errno_location ( ) ; error ( Number , * @@v18@@ , @@v17@@ , @@v16@@ ) ; LABEL_17 : fclose ( @@stream@@ ) ; @@result@@ = Number L ; } else { @@v10@@ = quote ( @@name@@ ) ; @@v11@@ = gettext ( String ) ; @@v12@@ = __errno_location ( ) ; error ( Number , * @@v12@@ , @@v11@@ , @@v10@@ ) ; close ( @@fd@@ ) ; unlink ( @@name@@ ) ; @@result@@ = Number L ; } } else { @@v6@@ = quote ( tempdir_5766 ) ; @@v7@@ = gettext ( String ) ; @@v8@@ = __errno_location ( ) ; error ( Number , * @@v8@@ , @@v7@@ , @@v6@@ ) ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
struct group * getgrgid ( __gid_t @@gid@@ ) { return getgrgid ( @@gid@@ ) ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
int __fastcall record_or_unlink_tempfile ( const char * @@a1@@ ) { return unlink ( @@a1@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , off_1C516 , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return xmalloc ( @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
__int64 __fastcall print_group ( __gid_t @@a1@@ , char @@a2@@ ) { char * @@v2@@ ; unsigned __int8 @@v4@@ ; struct group * @@v5@@ ; @@v5@@ = Number L ; @@v4@@ = Number ; if ( @@a2@@ ) { @@v5@@ = getgrgid ( @@a1@@ ) ; if ( ! @@v5@@ ) { @@v2@@ = gettext ( String ) ; error ( Number , Number , @@v2@@ , @@a1@@ ) ; @@v4@@ = Number ; } } if ( @@v5@@ ) printf ( String , @@v5@@ -> gr_name ) ; else printf ( String , @@a1@@ ) ; return @@v4@@ ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_209038 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
int getc_unlocked ( FILE * @@stream@@ ) { return getc_unlocked ( @@stream@@ ) ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_220028 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; char * @@v3@@ ; FILE * @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; FILE * @@v10@@ ; char * @@v11@@ ; FILE * @@v12@@ ; char * @@v13@@ ; FILE * @@v14@@ ; char * @@v15@@ ; FILE * @@v16@@ ; char * @@v17@@ ; FILE * @@v18@@ ; char * @@v19@@ ; FILE * @@v20@@ ; char * @@v21@@ ; @@v1@@ = program_name ; if ( @@a1@@ ) { @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = gettext ( String ) ; printf ( @@v3@@ , @@v1@@ ) ; @@v4@@ = stdout ; @@v5@@ = gettext ( String String String String String ) ; fputs_unlocked ( @@v5@@ , @@v4@@ ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; @@v8@@ = stdout ; @@v9@@ = gettext ( String String ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = stdout ; @@v11@@ = gettext ( String String String String String String String String ) ; fputs_unlocked ( @@v11@@ , @@v10@@ ) ; @@v12@@ = stdout ; @@v13@@ = gettext ( String ) ; fputs_unlocked ( @@v13@@ , @@v12@@ ) ; @@v14@@ = stdout ; @@v15@@ = gettext ( String ) ; fputs_unlocked ( @@v15@@ , @@v14@@ ) ; @@v16@@ = stdout ; @@v17@@ = gettext ( String ) ; fputs_unlocked ( @@v17@@ , @@v16@@ ) ; @@v18@@ = stdout ; @@v19@@ = gettext ( String String String ) ; fputs_unlocked ( @@v19@@ , @@v18@@ ) ; @@v20@@ = stdout ; @@v21@@ = gettext ( String String String String ) ; fputs_unlocked ( @@v21@@ , @@v20@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_222288 ; @@v8@@ [ Number ] = qword_222290 ; @@v8@@ [ Number ] = qword_222298 ; @@v8@@ [ Number ] = qword_2222A0 ; @@v8@@ [ Number ] = qword_2222A8 ; @@v8@@ [ Number ] = qword_2222B0 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_2080E8 ; @@v4@@ [ Number ] = qword_2080F0 ; @@v4@@ [ Number ] = qword_2080F8 ; @@v4@@ [ Number ] = qword_208100 ; @@v4@@ [ Number ] = qword_208108 ; @@v4@@ [ Number ] = qword_208110 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
__int64 __fastcall argmatch ( const char * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { __int64 @@result@@ ; char @@v7@@ ; __int64 @@i@@ ; __int64 @@v9@@ ; size_t @@n@@ ; @@v9@@ = Number ; @@v7@@ = Number ; @@n@@ = strlen ( @@a1@@ ) ; for ( @@i@@ = Number L ; * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; ++ @@i@@ ) { if ( ! strncmp ( * ( const char * * ) ( Number * @@i@@ + @@a2@@ ) , @@a1@@ , @@n@@ ) ) { if ( @@n@@ == strlen ( * ( const char * * ) ( Number * @@i@@ + @@a2@@ ) ) ) return @@i@@ ; if ( @@v9@@ == Number ) { @@v9@@ = @@i@@ ; } else if ( ! @@a3@@ || memcmp ( ( const void * ) ( @@a4@@ * @@v9@@ + @@a3@@ ) , ( const void * ) ( @@i@@ * @@a4@@ + @@a3@@ ) , @@a4@@ ) ) { @@v7@@ = Number ; } } } if ( @@v7@@ ) @@result@@ = Number ; else @@result@@ = @@v9@@ ; return @@result@@ ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
bool __fastcall bitset_contain ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { return ( ( * ( _QWORD * ) ( Number * ( @@a2@@ >> Number ) + @@a1@@ ) >> ( @@a2@@ & Number ) ) & Number L ) != Number ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_2080E8 ; @@v8@@ [ Number ] = qword_2080F0 ; @@v8@@ [ Number ] = qword_2080F8 ; @@v8@@ [ Number ] = qword_208100 ; @@v8@@ [ Number ] = qword_208108 ; @@v8@@ [ Number ] = qword_208110 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
__int64 __fastcall re_string_allocate ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , unsigned __int64 @@a4@@ , __int64 @@a5@@ , unsigned __int8 @@a6@@ , __int64 @@a7@@ ) { unsigned __int64 @@v7@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; unsigned int @@v13@@ ; unsigned __int64 @@v14@@ ; @@v11@@ = @@a4@@ ; if ( @@a4@@ < * ( int * ) ( @@a7@@ + Number ) ) @@v11@@ = * ( int * ) ( @@a7@@ + Number ) ; @@v7@@ = @@a3@@ + Number ; if ( @@v11@@ <= @@a3@@ + Number ) @@v7@@ = @@v11@@ ; @@v14@@ = @@v7@@ ; re_string_construct_common ( @@a2@@ , @@a3@@ , @@a1@@ , @@a5@@ , @@a6@@ , @@a7@@ ) ; @@v13@@ = re_string_realloc_buffers ( @@a1@@ , @@v14@@ ) ; if ( @@v13@@ ) return @@v13@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@a7@@ + Number ; * ( _BYTE * ) ( @@a1@@ + Number ) = ( * ( _BYTE * ) ( @@a7@@ + Number ) & Number ) != Number ; if ( * ( _BYTE * ) ( @@a1@@ + Number ) ) @@v9@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; else @@v9@@ = @@a2@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v9@@ ; if ( * ( _BYTE * ) ( @@a1@@ + Number ) || * ( int * ) ( @@a7@@ + Number ) > Number ) @@v10@@ = Number L ; else @@v10@@ = @@a3@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v10@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = * ( _QWORD * ) ( @@a1@@ + Number ) ; return Number L ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
__int64 __fastcall re_string_char_size_at ( __int64 @@a1@@ , __int64 @@a2@@ ) { int @@i@@ ; if ( * ( _DWORD * ) ( @@a1@@ + Number ) == Number ) return Number L ; for ( @@i@@ = Number ; ( unsigned __int64 ) ( @@a2@@ + @@i@@ ) < * ( _QWORD * ) ( @@a1@@ + Number ) && * ( _DWORD * ) ( Number * ( @@i@@ + @@a2@@ ) + * ( _QWORD * ) ( @@a1@@ + Number ) ) == Number ; ++ @@i@@ ) { ; } return ( unsigned int ) @@i@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
FILE * __fastcall freopen_safer ( const char * @@a1@@ , const char * @@a2@@ , FILE * @@a3@@ ) { int @@v3@@ ; FILE * @@streama@@ ; char @@v7@@ ; char @@v8@@ ; char @@v9@@ ; int @@v10@@ ; @@v7@@ = Number ; @@v8@@ = Number ; @@v9@@ = Number ; @@v3@@ = fileno ( @@a3@@ ) ; if ( @@v3@@ != Number ) { if ( @@v3@@ != Number ) { if ( ! @@v3@@ ) goto LABEL_10 ; if ( dup2 ( Number , Number ) != Number ) @@v9@@ = Number ; } if ( dup2 ( Number , Number ) != Number ) @@v8@@ = Number ; } if ( dup2 ( Number , Number ) ) @@v7@@ = Number ; LABEL_10 : if ( @@v7@@ && ( unsigned __int8 ) protect_fd ( Number ) != Number ) { @@streama@@ = Number L ; } else if ( @@v8@@ && ( unsigned __int8 ) protect_fd ( Number ) != Number ) { @@streama@@ = Number L ; } else if ( @@v9@@ && ( unsigned __int8 ) protect_fd ( Number ) != Number ) { @@streama@@ = Number L ; } else { @@streama@@ = freopen ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } @@v10@@ = * __errno_location ( ) ; if ( @@v9@@ ) close ( Number ) ; if ( @@v8@@ ) close ( Number ) ; if ( @@v7@@ ) close ( Number ) ; if ( ! @@streama@@ ) * __errno_location ( ) = @@v10@@ ; return @@streama@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
_QWORD * __fastcall build_upper_buffer ( _QWORD * @@a1@@ ) { unsigned __int64 @@v1@@ ; _QWORD * @@result@@ ; int @@c@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@v5@@ ; @@v1@@ = @@a1@@ [ Number ] ; if ( @@a1@@ [ Number ] <= @@v1@@ ) @@v1@@ = @@a1@@ [ Number ] ; @@v5@@ = @@v1@@ ; for ( @@i@@ = @@a1@@ [ Number ] ; @@i@@ < @@v5@@ ; ++ @@i@@ ) { @@c@@ = * ( unsigned __int8 * ) ( * @@a1@@ + @@a1@@ [ Number ] + @@i@@ ) ; if ( @@a1@@ [ Number ] ) @@c@@ = * ( unsigned __int8 * ) ( @@a1@@ [ Number ] + * ( unsigned __int8 * ) ( * @@a1@@ + @@a1@@ [ Number ] + @@i@@ ) ) ; if ( ( ( * __ctype_b_loc ( ) ) [ @@c@@ ] & Number ) != Number ) * ( _BYTE * ) ( @@a1@@ [ Number ] + @@i@@ ) = toupper ( @@c@@ ) ; else * ( _BYTE * ) ( @@a1@@ [ Number ] + @@i@@ ) = @@c@@ ; } @@a1@@ [ Number ] = @@i@@ ; @@result@@ = @@a1@@ ; @@a1@@ [ Number ] = @@i@@ ; return @@result@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
__int64 __fastcall re_string_construct_common ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , char @@a5@@ , __int64 @@a6@@ ) { bool @@v6@@ ; __int64 @@result@@ ; * ( _QWORD * ) @@a3@@ = @@a1@@ ; * ( _QWORD * ) ( @@a3@@ + Number ) = @@a2@@ ; * ( _QWORD * ) ( @@a3@@ + Number ) = @@a2@@ ; * ( _QWORD * ) ( @@a3@@ + Number ) = @@a4@@ ; * ( _BYTE * ) ( @@a3@@ + Number ) = @@a5@@ ; @@v6@@ = @@a4@@ || @@a5@@ ; * ( _BYTE * ) ( @@a3@@ + Number ) = @@v6@@ ; * ( _DWORD * ) ( @@a3@@ + Number ) = * ( _DWORD * ) ( @@a6@@ + Number ) ; * ( _BYTE * ) ( @@a3@@ + Number ) = ( * ( _BYTE * ) ( @@a6@@ + Number ) & Number ) != Number ; * ( _BYTE * ) ( @@a3@@ + Number ) = ( * ( _BYTE * ) ( @@a6@@ + Number ) & Number ) != Number ; * ( _QWORD * ) ( @@a3@@ + Number ) = * ( _QWORD * ) ( @@a3@@ + Number ) ; @@result@@ = @@a3@@ ; * ( _QWORD * ) ( @@a3@@ + Number ) = * ( _QWORD * ) ( @@a3@@ + Number ) ; return @@result@@ ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 __fastcall re_node_set_alloc ( _QWORD * @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = Number L ; @@a1@@ [ Number ] = malloc ( Number * @@a2@@ ) ; if ( @@a1@@ [ Number ] ) @@result@@ = Number L ; else @@result@@ = Number L ; return @@result@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
void __fastcall re_string_destruct ( __int64 @@a1@@ ) { free ( * ( void * * ) ( @@a1@@ + Number ) ) ; free ( * ( void * * ) ( @@a1@@ + Number ) ) ; if ( * ( _BYTE * ) ( @@a1@@ + Number ) ) free ( * ( void * * ) ( @@a1@@ + Number ) ) ; }
__int64 __fastcall re_node_set_insert_last ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v3@@ ; __int64 @@v4@@ ; void * @@v6@@ ; if ( * ( _QWORD * ) @@a1@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ) { * ( _QWORD * ) @@a1@@ = Number * ( * ( _QWORD * ) @@a1@@ + Number L ) ; @@v6@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number L * * ( _QWORD * ) @@a1@@ ) ; if ( ! @@v6@@ ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v6@@ ; } @@v3@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v4@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v4@@ + Number ; * ( _QWORD * ) ( @@v3@@ + Number * @@v4@@ ) = @@a2@@ ; return Number L ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_209108 ; @@v8@@ [ Number ] = qword_209110 ; @@v8@@ [ Number ] = qword_209118 ; @@v8@@ [ Number ] = qword_209120 ; @@v8@@ [ Number ] = qword_209128 ; @@v8@@ [ Number ] = qword_209130 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; char * @@v3@@ ; FILE * @@v4@@ ; char * @@v5@@ ; char * @@v6@@ ; FILE * @@v7@@ ; char * @@v8@@ ; FILE * @@v9@@ ; char * @@v10@@ ; FILE * @@v11@@ ; char * @@v12@@ ; FILE * @@v13@@ ; char * @@v14@@ ; char * @@v15@@ ; @@v1@@ = program_name ; if ( @@a1@@ ) { @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = gettext ( String String String String ) ; printf ( @@v3@@ , @@v1@@ , String , Number L ) ; @@v4@@ = stdout ; @@v5@@ = gettext ( String ) ; fputs_unlocked ( @@v5@@ , @@v4@@ ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , String ) ; @@v7@@ = stdout ; @@v8@@ = gettext ( String ) ; fputs_unlocked ( @@v8@@ , @@v7@@ ) ; @@v9@@ = stdout ; @@v10@@ = gettext ( String String String String String String ) ; fputs_unlocked ( @@v10@@ , @@v9@@ ) ; @@v11@@ = stdout ; @@v12@@ = gettext ( String ) ; fputs_unlocked ( @@v12@@ , @@v11@@ ) ; @@v13@@ = stdout ; @@v14@@ = gettext ( String ) ; fputs_unlocked ( @@v14@@ , @@v13@@ ) ; @@v15@@ = gettext ( String String String String String ) ; printf ( @@v15@@ , String ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
__int64 __fastcall re_node_set_init_2 ( _QWORD * @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { * @@a1@@ = Number L ; @@a1@@ [ Number ] = malloc ( Number ) ; if ( ! @@a1@@ [ Number ] ) return Number L ; if ( @@a2@@ == @@a3@@ ) { @@a1@@ [ Number ] = Number L ; * ( _QWORD * ) @@a1@@ [ Number ] = @@a2@@ ; } else { @@a1@@ [ Number ] = Number L ; if ( @@a2@@ >= @@a3@@ ) { * ( _QWORD * ) @@a1@@ [ Number ] = @@a3@@ ; * ( _QWORD * ) ( @@a1@@ [ Number ] + Number L ) = @@a2@@ ; } else { * ( _QWORD * ) @@a1@@ [ Number ] = @@a2@@ ; * ( _QWORD * ) ( @@a1@@ [ Number ] + Number L ) = @@a3@@ ; } } return Number L ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
unsigned __int64 __fastcall re_node_set_remove_at ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { unsigned __int64 @@result@@ ; unsigned __int64 @@v3@@ ; @@v3@@ = @@a2@@ ; @@result@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( @@a2@@ < @@result@@ ) { -- * ( _QWORD * ) ( @@a1@@ + Number ) ; while ( Number ) { @@result@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( @@v3@@ >= @@result@@ ) break ; * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@v3@@ ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * ( @@v3@@ + Number ) ) ; ++ @@v3@@ ; } } return @@result@@ ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
__int64 __fastcall re_node_set_compare ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v3@@ ; if ( ! @@a1@@ || ! @@a2@@ || * ( _QWORD * ) ( @@a1@@ + Number ) != * ( _QWORD * ) ( @@a2@@ + Number ) ) { return Number L ; } @@v3@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; while ( ( unsigned __int64 ) -- @@v3@@ <= Number ) { if ( * ( _QWORD * ) ( Number * @@v3@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) != * ( _QWORD * ) ( Number * @@v3@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) ) return Number L ; } return Number L ; }
FILE * __fastcall fopen_safer ( const char * @@a1@@ , const char * @@a2@@ ) { int @@v3@@ ; int @@fd@@ ; int @@v5@@ ; int @@v6@@ ; FILE * @@stream@@ ; @@stream@@ = fopen ( @@a1@@ , @@a2@@ ) ; if ( ! @@stream@@ ) return @@stream@@ ; @@v3@@ = fileno ( @@stream@@ ) ; if ( @@v3@@ < Number || @@v3@@ > Number ) return @@stream@@ ; @@fd@@ = dup_safer ( ( unsigned int ) @@v3@@ ) ; if ( @@fd@@ < Number ) { @@v6@@ = * __errno_location ( ) ; fclose ( @@stream@@ ) ; * __errno_location ( ) = @@v6@@ ; return Number L ; } if ( ! fclose ( @@stream@@ ) ) { @@stream@@ = fdopen ( @@fd@@ , @@a2@@ ) ; if ( @@stream@@ ) return @@stream@@ ; } @@v5@@ = * __errno_location ( ) ; close ( @@fd@@ ) ; * __errno_location ( ) = @@v5@@ ; return Number L ; }
__int64 __fastcall re_acquire_state_context ( _DWORD * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , unsigned int @@a4@@ ) { __int64 @@result@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ ; unsigned __int64 * @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; if ( * ( _QWORD * ) ( @@a3@@ + Number ) ) { @@v8@@ = calc_state_hash ( @@a3@@ , @@a4@@ ) ; @@v9@@ = ( unsigned __int64 * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number * ( @@v8@@ & * ( _QWORD * ) ( @@a2@@ + Number ) ) ) ; for ( @@i@@ = Number L ; @@i@@ < * @@v9@@ ; ++ @@i@@ ) { @@v11@@ = * ( _QWORD * ) ( Number * @@i@@ + @@v9@@ [ Number ] ) ; if ( @@v8@@ == * ( _QWORD * ) @@v11@@ && @@a4@@ == ( * ( _BYTE * ) ( @@v11@@ + Number ) & Number ) && ( unsigned __int8 ) re_node_set_compare ( * ( _QWORD * ) ( @@v11@@ + Number ) , @@a3@@ ) ) { return @@v11@@ ; } } @@v10@@ = create_cd_newstate ( @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ ) ; if ( ! @@v10@@ ) * @@a1@@ = Number ; @@result@@ = @@v10@@ ; } else { * @@a1@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
int putchar_unlocked ( int @@c@@ ) { return putchar_unlocked ( @@c@@ ) ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
char * __fastcall create_ci_newstate ( _QWORD * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { char * @@result@@ ; int @@v5@@ ; unsigned __int64 @@i@@ ; char * @@ptr@@ ; __int64 @@v8@@ ; @@ptr@@ = ( char * ) calloc ( Number , Number ) ; if ( ! @@ptr@@ ) return Number L ; if ( ( unsigned int ) re_node_set_init_copy ( @@ptr@@ + Number , @@a2@@ ) ) { free ( @@ptr@@ ) ; @@result@@ = Number L ; } else { * ( ( _QWORD * ) @@ptr@@ + Number ) = @@ptr@@ + Number ; for ( @@i@@ = Number L ; @@i@@ < * ( _QWORD * ) ( @@a2@@ + Number ) ; ++ @@i@@ ) { @@v8@@ = * @@a1@@ + Number L * * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) ; @@v5@@ = * ( unsigned __int8 * ) ( @@v8@@ + Number ) ; if ( @@v5@@ != Number || ( * ( _DWORD * ) ( @@v8@@ + Number ) & Number ) != Number ) { @@ptr@@ [ Number ] = ( Number * ( ( * ( _BYTE * ) ( @@v8@@ + Number ) & Number ) != Number || ( @@ptr@@ [ Number ] & Number ) != Number ) ) | @@ptr@@ [ Number ] & Number ; if ( @@v5@@ == Number ) { @@ptr@@ [ Number ] |= Number ; } else if ( @@v5@@ == Number ) { @@ptr@@ [ Number ] |= Number ; } else if ( @@v5@@ == Number || ( * ( _DWORD * ) ( @@v8@@ + Number ) & Number ) != Number ) { @@ptr@@ [ Number ] |= Number ; } } } if ( ( unsigned int ) register_state ( @@a1@@ , @@ptr@@ , @@a3@@ ) ) { free_state ( ( void * * ) @@ptr@@ ) ; @@ptr@@ = Number L ; } @@result@@ = @@ptr@@ ; } return @@result@@ ; }
size_t __fastcall rpl_regerror ( int @@a1@@ , __int64 a2 , _BYTE * @@a3@@ , size_t @@a4@@ ) { size_t @@n@@ ; const char * @@s@@ ; size_t @@v9@@ ; if ( @@a1@@ < Number || @@a1@@ > Number ) abort ( ) ; @@s@@ = gettext ( & _re_error_msgid [ _re_error_msgid_idx [ @@a1@@ ] ] ) ; @@v9@@ = strlen ( @@s@@ ) + Number ; if ( @@a4@@ ) { @@n@@ = @@v9@@ ; if ( @@v9@@ > @@a4@@ ) { @@n@@ = @@a4@@ - Number ; @@a3@@ [ @@a4@@ - Number ] = Number ; } memcpy ( @@a3@@ , @@s@@ , @@n@@ ) ; } return @@v9@@ ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
int feof_unlocked ( FILE * @@stream@@ ) { return feof_unlocked ( @@stream@@ ) ; }
__int64 __fastcall init_dfa ( void * * @@a1@@ , unsigned __int64 @@a2@@ ) { __int64 @@result@@ ; int @@v3@@ ; int @@i@@ ; int @@c@@ ; wint_t @@v6@@ ; size_t @@size@@ ; const char * @@s1@@ ; memset ( @@a1@@ , Number , Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = Number ; if ( @@a2@@ >= Number ) return Number L ; @@a1@@ [ Number ] = ( void * ) ( @@a2@@ + Number ) ; * @@a1@@ = malloc ( Number L * ( _QWORD ) @@a1@@ [ Number ] ) ; for ( @@size@@ = Number L ; @@size@@ <= @@a2@@ ; @@size@@ *= Number L ) ; @@a1@@ [ Number ] = calloc ( Number , @@size@@ ) ; @@a1@@ [ Number ] = ( void * ) ( @@size@@ - Number ) ; * ( ( _DWORD * ) @@a1@@ + Number ) = __ctype_get_mb_cur_max ( ) ; @@s1@@ = nl_langinfo ( Number ) ; if ( ! strcasecmp ( @@s1@@ , String ) || ! strcasecmp ( @@s1@@ , String ) ) * ( ( _BYTE * ) @@a1@@ + Number ) |= Number ; * ( ( _BYTE * ) @@a1@@ + Number ) &= Number ; if ( * ( ( int * ) @@a1@@ + Number ) > Number ) { if ( ( ( _BYTE ) @@a1@@ [ Number ] & Number ) != Number ) { @@a1@@ [ Number ] = & utf8_sb_map ; } else { @@a1@@ [ Number ] = calloc ( Number , Number ) ; if ( ! @@a1@@ [ Number ] ) return Number L ; @@v3@@ = Number ; @@c@@ = Number ; while ( @@v3@@ <= Number ) { for ( @@i@@ = Number ; @@i@@ <= Number ; ++ @@i@@ ) { @@v6@@ = btowc ( @@c@@ ) ; if ( @@v6@@ != Number ) * ( ( _QWORD * ) @@a1@@ [ Number ] + @@v3@@ ) |= Number L << @@i@@ ; if ( ( @@c@@ & Number ) == Number && @@v6@@ != @@c@@ ) * ( ( _BYTE * ) @@a1@@ + Number ) |= Number ; ++ @@c@@ ; } ++ @@v3@@ ; } } } if ( * @@a1@@ && @@a1@@ [ Number ] ) @@result@@ = Number L ; else @@result@@ = Number L ; return @@result@@ ; }
__int64 __fastcall postorder ( _QWORD * @@a1@@ , __int64 ( __fastcall * @@a2@@ ( ) ( void , bintreet0 ) ) ( __int64 , _QWORD * ) , __int64 @@a3@@ ) { unsigned int @@v5@@ ; _QWORD * @@v7@@ ; LABEL_5 : while ( @@a1@@ [ Number ] || @@a1@@ [ Number ] ) { if ( @@a1@@ [ Number ] ) @@a1@@ = ( _QWORD * ) @@a1@@ [ Number ] ; else @@a1@@ = ( _QWORD * ) @@a1@@ [ Number ] ; } while ( Number ) { @@v5@@ = @@a2@@ ( ) ( void , bintreet0 ) ( @@a3@@ , @@a1@@ ) ; if ( @@v5@@ ) return @@v5@@ ; if ( ! * @@a1@@ ) return Number L ; @@v7@@ = @@a1@@ ; @@a1@@ = ( _QWORD * ) * @@a1@@ ; if ( @@v7@@ != ( _QWORD * ) @@a1@@ [ Number ] && @@a1@@ [ Number ] ) { @@a1@@ = ( _QWORD * ) @@a1@@ [ Number ] ; goto LABEL_5 ; } } }
size_t __fastcall writeline ( __int64 @@a1@@ , char @@a2@@ , __int64 @@a3@@ ) { size_t @@result@@ ; if ( @@a3@@ ) { if ( @@a2@@ != Number ) @@result@@ = ( unsigned __int8 ) output_first_repeated ^ Number ; else @@result@@ = ( unsigned __int8 ) output_later_repeated ^ Number ; } else { @@result@@ = ( unsigned __int8 ) output_unique ^ Number ; } if ( ! ( _BYTE ) @@result@@ ) { if ( ! countmode ) printf ( String , @@a3@@ + Number ) ; @@result@@ = fwrite_unlocked ( * ( const void * * ) ( @@a1@@ + Number ) , Number , * ( _QWORD * ) ( @@a1@@ + Number ) , stdout ) ; } return @@result@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
__int64 __fastcall bad_cast ( __int64 @@a1@@ ) { return @@a1@@ ; }
void __fastcall freebuffer ( __int64 @@a1@@ ) { free ( * ( void * * ) ( @@a1@@ + Number ) ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall optimize_subexps ( __int64 @@a1@@ , __int64 @@a2@@ ) { unsigned __int64 @@v3@@ ; if ( * ( _BYTE * ) ( @@a2@@ + Number ) == Number && * ( _QWORD * ) ( @@a1@@ + Number ) ) { * ( _QWORD * ) ( @@a2@@ + Number ) = * ( _QWORD * ) ( Number L * ( int ) * ( _QWORD * ) ( @@a2@@ + Number ) + * ( _QWORD * ) ( @@a1@@ + Number ) ) ; * ( _QWORD * ) ( @@a1@@ + Number ) |= Number << * ( _QWORD * ) ( @@a2@@ + Number ) ; } else if ( * ( _BYTE * ) ( @@a2@@ + Number ) == Number && * ( _QWORD * ) ( @@a2@@ + Number ) && * ( _BYTE * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) == Number ) { @@v3@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) ; * ( _QWORD * ) ( @@a2@@ + Number ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) ) * * ( _QWORD * * ) ( @@a2@@ + Number ) = @@a2@@ ; * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@v3@@ ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L * * ( _QWORD * ) ( @@a2@@ + Number ) ) ; if ( @@v3@@ <= Number ) * ( _QWORD * ) ( @@a1@@ + Number ) &= ~ ( Number L << @@v3@@ ) ; } return Number L ; }
__int64 __fastcall calc_first ( _QWORD * @@a1@@ , _QWORD * @@a2@@ ) { __int64 @@v3@@ ; if ( * ( ( _BYTE * ) @@a2@@ + Number ) == Number ) { @@a2@@ [ Number ] = * ( _QWORD * ) ( @@a2@@ [ Number ] + Number L ) ; @@a2@@ [ Number ] = * ( _QWORD * ) ( @@a2@@ [ Number ] + Number L ) ; } else { @@a2@@ [ Number ] = @@a2@@ ; @@a2@@ [ Number ] = re_dfa_add_node ( ( __int64 ) @@a1@@ , @@a2@@ [ Number ] , @@a2@@ [ Number ] ) ; if ( @@a2@@ [ Number ] == Number ) return Number L ; if ( * ( ( _BYTE * ) @@a2@@ + Number ) == Number ) { @@v3@@ = Number L * @@a2@@ [ Number ] + * @@a1@@ ; * ( _DWORD * ) ( @@v3@@ + Number ) = ( ( @@a2@@ [ Number ] & Number ) << Number ) | * ( _DWORD * ) ( @@v3@@ + Number ) & Number ; } } return Number L ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall xmemcoll ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ ) { char * @@v4@@ ; char * @@v5@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; unsigned int @@v12@@ ; int @@errnum@@ ; @@v12@@ = memcoll ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; @@errnum@@ = * __errno_location ( ) ; if ( @@errnum@@ ) { @@v4@@ = gettext ( String ) ; error ( Number , @@errnum@@ , @@v4@@ ) ; @@v5@@ = gettext ( String ) ; error ( Number , Number , @@v5@@ ) ; @@v6@@ = quotearg_n_style_mem ( Number L , Number L , @@a3@@ , @@a4@@ ) ; @@v7@@ = quotearg_n_style_mem ( Number L , Number L , @@a1@@ , @@a2@@ ) ; @@v8@@ = gettext ( String ) ; error ( exit_failure , Number , @@v8@@ , @@v7@@ , @@v6@@ ) ; } return @@v12@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
__int64 __fastcall calc_inveclosure ( _QWORD * @@a1@@ ) { unsigned __int64 @@j@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@k@@ ; __int64 @@v5@@ ; for ( @@i@@ = Number L ; @@i@@ < @@a1@@ [ Number ] ; ++ @@i@@ ) memset ( ( void * ) ( @@a1@@ [ Number ] + Number * @@i@@ ) , Number , Number ) ; for ( @@j@@ = Number L ; @@j@@ < @@a1@@ [ Number ] ; ++ @@j@@ ) { @@v5@@ = * ( _QWORD * ) ( @@a1@@ [ Number ] + Number * @@j@@ + Number ) ; for ( @@k@@ = Number L ; @@k@@ < * ( _QWORD * ) ( @@a1@@ [ Number ] + Number * @@j@@ + Number ) ; ++ @@k@@ ) { if ( ( unsigned __int8 ) re_node_set_insert_last ( @@a1@@ [ Number ] + Number L * * ( _QWORD * ) ( Number * @@k@@ + @@v5@@ ) , @@j@@ ) != Number ) return Number L ; } } return Number L ; }
__int64 __fastcall search_duplicated_node ( _QWORD * @@a1@@ , __int64 @@a2@@ , int @@a3@@ ) { __int64 @@i@@ ; for ( @@i@@ = @@a1@@ [ Number ] - Number L ; ( * ( _BYTE * ) ( Number * @@i@@ + * @@a1@@ + Number ) & Number ) != Number && @@i@@ ; -- @@i@@ ) { if ( @@a2@@ == * ( _QWORD * ) ( Number * @@i@@ + @@a1@@ [ Number ] ) && @@a3@@ == ( ( * ( _DWORD * ) ( Number * @@i@@ + * @@a1@@ + Number ) >> Number ) & Number ) ) { return @@i@@ ; } } return Number ; }
__int64 __fastcall parse_reg_exp ( __int64 @@a1@@ , __int64 * @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , _DWORD * @@a6@@ ) { __int64 @@v11@@ ; __int64 @@v12@@ ; __int64 @@v13@@ ; @@v13@@ = * @@a2@@ ; @@v11@@ = parse_branch ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( * @@a6@@ && ! @@v11@@ ) return Number L ; while ( * ( _BYTE * ) ( @@a3@@ + Number ) == Number ) { fetch_token ( @@a3@@ , @@a1@@ , @@a4@@ | Number ) ; if ( * ( _BYTE * ) ( @@a3@@ + Number ) == Number || * ( _BYTE * ) ( @@a3@@ + Number ) == Number || @@a5@@ && * ( _BYTE * ) ( @@a3@@ + Number ) == Number ) { @@v12@@ = Number L ; } else { @@v12@@ = parse_branch ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( * @@a6@@ && ! @@v12@@ ) return Number L ; } @@v11@@ = create_tree ( @@v13@@ , @@v11@@ , @@v12@@ , Number L ) ; if ( ! @@v11@@ ) { * @@a6@@ = Number ; return Number L ; } } return @@v11@@ ; }
__int64 __fastcall sha224_read_ctx ( __int64 @@a1@@ , __int64 @@a2@@ ) { int @@i@@ ; for ( @@i@@ = Number ; @@i@@ <= Number ; ++ @@i@@ ) set_uint32 ( ( _DWORD * ) ( Number L * @@i@@ + @@a2@@ ) , HIBYTE ( * ( _DWORD * ) ( @@a1@@ + Number L * @@i@@ ) ) | ( * ( _DWORD * ) ( @@a1@@ + Number L * @@i@@ ) >> Number ) & Number | ( * ( _DWORD * ) ( @@a1@@ + Number L * @@i@@ ) << Number ) & Number | ( * ( _DWORD * ) ( @@a1@@ + Number L * @@i@@ ) << Number ) ) ; return @@a2@@ ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , off_A8A2 , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
__int64 __fastcall calc_eclosure ( __int64 @@a1@@ ) { char @@v2@@ ; unsigned int @@v3@@ ; __int64 @@i@@ ; char @@v5@@ [ Number ] ; void * @@ptr@@ ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@v2@@ = Number ; for ( @@i@@ = Number L ; ; ++ @@i@@ ) { if ( @@i@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ) { if ( @@v2@@ != Number ) return Number L ; @@v2@@ = Number ; @@i@@ = Number L ; } if ( ! * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@i@@ + Number ) ) break ; LABEL_11 : ; } @@v3@@ = calc_eclosure_iter ( @@v5@@ , @@a1@@ , @@i@@ , Number L ) ; if ( ! @@v3@@ ) { if ( ! * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@i@@ + Number ) ) { @@v2@@ = Number ; free ( @@ptr@@ ) ; } goto LABEL_11 ; } return @@v3@@ ; }
__int64 __fastcall parse_bracket_symbol ( __int64 @@a1@@ , _QWORD * @@a2@@ , char * @@a3@@ ) { __int64 @@v4@@ ; __int64 @@v5@@ ; int @@v6@@ ; char @@v9@@ ; char @@v10@@ ; int @@v11@@ ; @@v10@@ = * @@a3@@ ; @@v11@@ = Number ; if ( @@a2@@ [ Number ] <= @@a2@@ [ Number ] ) return Number L ; while ( Number ) { if ( @@v11@@ > Number ) return Number L ; if ( @@a3@@ [ Number ] == Number ) { @@v9@@ = re_string_fetch_byte_case ( ( __int64 ) @@a2@@ ) ; } else { @@v4@@ = @@a2@@ [ Number ] ; @@v5@@ = @@a2@@ [ Number ] ; @@a2@@ [ Number ] = @@v5@@ + Number ; @@v9@@ = * ( _BYTE * ) ( @@v4@@ + @@v5@@ ) ; } if ( @@a2@@ [ Number ] <= @@a2@@ [ Number ] ) return Number L ; if ( @@v9@@ == @@v10@@ && * ( _BYTE * ) ( @@a2@@ [ Number ] + @@a2@@ [ Number ] ) == Number ) { break ; } * ( _BYTE * ) ( @@v11@@ ++ + * ( _QWORD * ) ( @@a1@@ + Number ) ) = @@v9@@ ; } ++ @@a2@@ [ Number ] ; * ( _BYTE * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@v11@@ ) = Number ; @@v6@@ = ( unsigned __int8 ) @@a3@@ [ Number ] ; switch ( @@v6@@ ) { case Number : * ( _DWORD * ) @@a1@@ = Number ; break ; case Number : * ( _DWORD * ) @@a1@@ = Number ; break ; case Number : * ( _DWORD * ) @@a1@@ = Number ; break ; } return Number L ; }
__int64 __fastcall sha256_stream ( FILE * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v3@@ ; char * @@ptr@@ ; size_t @@v5@@ ; char @@v6@@ [ Number ] ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@ptr@@ = ( char * ) malloc ( Number ) ; if ( ! @@ptr@@ ) return Number L ; sha256_init_ctx ( ( __int64 ) @@v6@@ ) ; LABEL_4 : @@v3@@ = Number L ; while ( Number ) { @@v5@@ = fread_unlocked ( & @@ptr@@ [ @@v3@@ ] , Number , Number - @@v3@@ , @@a1@@ ) ; @@v3@@ += @@v5@@ ; if ( @@v3@@ == Number ) { sha256_process_block ( @@ptr@@ , Number , @@v6@@ ) ; goto LABEL_4 ; } if ( ! @@v5@@ ) break ; if ( feof_unlocked ( @@a1@@ ) ) goto LABEL_12 ; } if ( ferror_unlocked ( @@a1@@ ) ) { free ( @@ptr@@ ) ; return Number L ; } LABEL_12 : if ( @@v3@@ ) sha256_process_bytes ( @@ptr@@ , @@v3@@ , @@v6@@ ) ; sha256_finish_ctx ( ( __int64 ) @@v6@@ , @@a2@@ ) ; free ( @@ptr@@ ) ; return Number L ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
__int64 __fastcall hard_locale ( int @@a1@@ ) { unsigned __int8 @@v2@@ ; const char * @@s1@@ ; @@v2@@ = Number ; @@s1@@ = setlocale ( @@a1@@ , Number L ) ; if ( @@s1@@ && ( ! strcmp ( @@s1@@ , String ) || ! strcmp ( @@s1@@ , String ) ) ) @@v2@@ = Number ; return @@v2@@ ; }
__int64 __fastcall mark_opt_subexp ( __int64 @@a1@@ , __int64 @@a2@@ ) { if ( * ( _BYTE * ) ( @@a2@@ + Number ) == Number && @@a1@@ == * ( _QWORD * ) ( @@a2@@ + Number ) ) { * ( _BYTE * ) ( @@a2@@ + Number ) |= Number ; } return Number L ; }
__int64 __fastcall peek_token_bracket ( _BYTE * @@a1@@ , __int64 @@a2@@ , char @@a3@@ ) { char @@v4@@ ; char @@v5@@ ; unsigned int @@v6@@ ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) <= * ( _QWORD * ) ( @@a2@@ + Number ) ) { @@a1@@ [ Number ] = Number ; return Number L ; } @@v5@@ = * ( _BYTE * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + * ( _QWORD * ) ( @@a2@@ + Number ) ) ; * @@a1@@ = @@v5@@ ; if ( * ( int * ) ( @@a2@@ + Number ) > Number && * ( _QWORD * ) ( @@a2@@ + Number ) != * ( _QWORD * ) ( @@a2@@ + Number ) && * ( _DWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L * * ( _QWORD * ) ( @@a2@@ + Number ) ) == Number ) { @@a1@@ [ Number ] = Number ; return Number L ; } if ( @@v5@@ == Number && ( @@a3@@ & Number ) != Number && ( unsigned __int64 ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) < * ( _QWORD * ) ( @@a2@@ + Number ) ) { ++ * ( _QWORD * ) ( @@a2@@ + Number ) ; * @@a1@@ = * ( _BYTE * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + * ( _QWORD * ) ( @@a2@@ + Number ) ) ; @@a1@@ [ Number ] = Number ; return Number L ; } switch ( @@v5@@ ) { case String : if ( ( unsigned __int64 ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) >= * ( _QWORD * ) ( @@a2@@ + Number ) ) @@v4@@ = Number ; else @@v4@@ = * ( _BYTE * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) ; * @@a1@@ = @@v4@@ ; @@v6@@ = Number ; switch ( @@v4@@ ) { case String : if ( ( @@a3@@ & Number ) != Number ) { @@a1@@ [ Number ] = Number ; return @@v6@@ ; } break ; case String : @@a1@@ [ Number ] = Number ; return @@v6@@ ; case String : @@a1@@ [ Number ] = Number ; return @@v6@@ ; } @@a1@@ [ Number ] = Number ; * @@a1@@ = Number ; return Number ; case String : @@a1@@ [ Number ] = Number ; break ; case String : @@a1@@ [ Number ] = Number ; break ; case String : @@a1@@ [ Number ] = Number ; break ; default : @@a1@@ [ Number ] = Number ; break ; } return Number L ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
__int64 __fastcall rpl_re_match_2 ( int @@a1@@ , int @@a2@@ , int @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ , __int64 @@a7@@ , __int64 @@a8@@ ) { return re_search_2_stub ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ , Number L , @@a7@@ , @@a8@@ , Number ) ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
__int64 __fastcall memcoll ( const char * @@a1@@ , size_t @@a2@@ , const char * @@a3@@ , __int64 @@a4@@ ) { __int64 @@v4@@ ; __int64 @@v8@@ ; const char * @@s2@@ ; size_t @@n@@ ; const char * @@s1@@ ; char @@v12@@ ; char @@v13@@ ; unsigned int @@v14@@ ; size_t @@v15@@ ; size_t @@v16@@ ; @@s1@@ = @@a1@@ ; @@s2@@ = @@a3@@ ; if ( @@a2@@ == @@a4@@ && ! memcmp ( @@a1@@ , @@a3@@ , @@a2@@ ) ) { * __errno_location ( ) = Number ; @@v14@@ = Number ; } else { @@v12@@ = @@a1@@ [ @@a2@@ ] ; @@v13@@ = @@s2@@ [ @@a4@@ ] ; @@n@@ = @@a2@@ + Number ; @@a1@@ [ @@a2@@ ] = Number ; @@v4@@ = @@a4@@ ; @@v8@@ = @@a4@@ + Number ; @@s2@@ [ @@v4@@ ] = Number ; while ( Number ) { * __errno_location ( ) = Number ; @@v14@@ = strcoll ( @@s1@@ , @@s2@@ ) ; if ( @@v14@@ || * __errno_location ( ) ) break ; @@v15@@ = strlen ( @@s1@@ ) + Number ; @@v16@@ = strlen ( @@s2@@ ) + Number ; @@s1@@ += @@v15@@ ; @@s2@@ += @@v16@@ ; @@n@@ -= @@v15@@ ; @@v8@@ -= @@v16@@ ; if ( ! @@n@@ ) { if ( @@v8@@ ) @@v14@@ = Number ; break ; } if ( ! @@v8@@ ) { @@v14@@ = Number ; break ; } } @@s1@@ [ @@n@@ - Number ] = @@v12@@ ; @@s2@@ [ @@v8@@ - Number ] = @@v13@@ ; } return @@v14@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
__int64 __fastcall parse_bracket_element ( __int64 @@a1@@ , __int64 @@a2@@ , _BYTE * @@a3@@ , int @@a4@@ , __int64 a5 , char @@a6@@ , char @@a7@@ ) { __int64 @@result@@ ; int @@v11@@ ; char @@v12@@ [ Number ] ; unsigned __int64 @@v13@@ ; @@v13@@ = __readfsqword ( Number ) ; @@v11@@ = re_string_char_size_at ( @@a2@@ , * ( _QWORD * ) ( @@a2@@ + Number ) ) ; if ( @@v11@@ <= Number ) { * ( _QWORD * ) ( @@a2@@ + Number ) += @@a4@@ ; if ( @@a3@@ [ Number ] == Number || @@a3@@ [ Number ] == Number || @@a3@@ [ Number ] == Number ) { @@result@@ = parse_bracket_symbol ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } else if ( @@a3@@ [ Number ] == Number && @@a7@@ != Number && ( peek_token_bracket ( @@v12@@ , @@a2@@ , @@a6@@ ) , @@v12@@ [ Number ] != Number ) ) { @@result@@ = Number L ; } else { * ( _DWORD * ) @@a1@@ = Number ; * ( _BYTE * ) ( @@a1@@ + Number ) = * @@a3@@ ; @@result@@ = Number L ; } } else { * ( _DWORD * ) @@a1@@ = Number ; * ( _DWORD * ) ( @@a1@@ + Number ) = re_string_wchar_at ( @@a2@@ , * ( _QWORD * ) ( @@a2@@ + Number ) ) ; * ( _QWORD * ) ( @@a2@@ + Number ) += @@v11@@ ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall prune_impossible_nodes ( __int64 @@a1@@ ) { unsigned int @@v2@@ ; __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; _QWORD * @@v5@@ ; _QWORD * @@s@@ ; __int64 @@v7@@ ; char @@v8@@ [ Number ] ; void * @@ptr@@ ; unsigned __int64 @@v10@@ ; @@v10@@ = __readfsqword ( Number ) ; @@v7@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@s@@ = Number L ; @@v4@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v3@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; if ( @@v4@@ > Number ) return Number L ; @@v5@@ = malloc ( Number * ( @@v4@@ + Number ) ) ; if ( @@v5@@ ) { if ( * ( _QWORD * ) ( @@v7@@ + Number ) ) { @@s@@ = malloc ( Number * ( @@v4@@ + Number ) ) ; if ( @@s@@ ) { while ( Number ) { memset ( @@s@@ , Number , Number * ( @@v4@@ + Number ) ) ; sift_ctx_init ( @@v8@@ , @@v5@@ , @@s@@ , @@v3@@ , @@v4@@ ) ; @@v2@@ = sift_states_backward ( @@a1@@ , @@v8@@ ) ; free ( @@ptr@@ ) ; if ( @@v2@@ ) break ; if ( * @@v5@@ || * @@s@@ ) { @@v2@@ = merge_state_array ( @@v7@@ , @@v5@@ , @@s@@ , @@v4@@ + Number ) ; free ( @@s@@ ) ; @@s@@ = Number L ; if ( ! @@v2@@ ) goto LABEL_21 ; break ; } do { if ( -- @@v4@@ > Number ) { @@v2@@ = Number ; goto LABEL_22 ; } } while ( ! * ( _QWORD * ) ( Number * @@v4@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) || ( * ( _BYTE * ) ( * ( _QWORD * ) ( Number * @@v4@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) + Number L ) & Number ) == Number ) ; @@v3@@ = check_halt_state_context ( @@a1@@ , * ( _QWORD * ) ( Number * @@v4@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) , @@v4@@ ) ; } } else { @@v2@@ = Number ; } } else { sift_ctx_init ( @@v8@@ , @@v5@@ , Number L , @@v3@@ , @@v4@@ ) ; @@v2@@ = sift_states_backward ( @@a1@@ , @@v8@@ ) ; free ( @@ptr@@ ) ; if ( ! @@v2@@ ) { if ( * @@v5@@ ) { LABEL_21 : free ( * ( void * * ) ( @@a1@@ + Number ) ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v5@@ ; @@v5@@ = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v3@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v4@@ ; @@v2@@ = Number ; } else { @@v2@@ = Number ; } } } } else { @@v2@@ = Number ; } LABEL_22 : free ( @@v5@@ ) ; free ( @@s@@ ) ; return @@v2@@ ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
__int64 __fastcall create_token_tree ( __int64 @@a1@@ , __int64 * @@a2@@ , __int64 * @@a3@@ , _QWORD * @@a4@@ ) { __int64 @@v5@@ ; int @@v6@@ ; __int64 @@v7@@ ; _QWORD * @@v11@@ ; __int64 @@v12@@ ; if ( * ( _DWORD * ) ( @@a1@@ + Number ) == Number ) { @@v11@@ = malloc ( Number ) ; if ( ! @@v11@@ ) return Number L ; * @@v11@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v11@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = Number ; } @@v5@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v6@@ = * ( _DWORD * ) ( @@a1@@ + Number ) ; * ( _DWORD * ) ( @@a1@@ + Number ) = @@v6@@ + Number ; @@v12@@ = @@v5@@ + ( ( __int64 ) @@v6@@ << Number ) + Number ; * ( _QWORD * ) @@v12@@ = Number L ; * ( _QWORD * ) ( @@v12@@ + Number ) = @@a2@@ ; * ( _QWORD * ) ( @@v12@@ + Number ) = @@a3@@ ; @@v7@@ = @@a4@@ [ Number ] ; * ( _QWORD * ) ( @@v12@@ + Number ) = * @@a4@@ ; * ( _QWORD * ) ( @@v5@@ + ( ( __int64 ) @@v6@@ << Number ) + Number ) = @@v7@@ ; * ( _BYTE * ) ( @@v12@@ + Number ) &= Number ; * ( _BYTE * ) ( @@v12@@ + Number ) &= Number ; * ( _QWORD * ) ( @@v12@@ + Number ) = Number L ; * ( _QWORD * ) ( @@v12@@ + Number ) = Number L ; * ( _QWORD * ) ( @@v12@@ + Number ) = Number ; if ( @@a2@@ ) * @@a2@@ = @@v12@@ ; if ( @@a3@@ ) * @@a3@@ = @@v12@@ ; return @@v5@@ + ( ( __int64 ) @@v6@@ << Number ) + Number ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall rpl_regexec ( __int64 @@a1@@ , const char * @@a2@@ , __int64 @@a3@@ , __int64 * @@a4@@ , int @@a5@@ ) { int @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; if ( ( @@a5@@ & Number ) != Number ) return Number L ; if ( ( @@a5@@ & Number ) != Number ) { @@v10@@ = * @@a4@@ ; @@v11@@ = @@a4@@ [ Number ] ; } else { LODWORD ( @@v10@@ ) = Number ; LODWORD ( @@v11@@ ) = strlen ( @@a2@@ ) ; } if ( ( * ( _BYTE * ) ( @@a1@@ + Number ) & Number ) != Number ) @@v9@@ = re_search_internal ( @@a1@@ , ( _DWORD ) @@a2@@ , @@v11@@ , @@v10@@ , @@v11@@ , @@v11@@ , Number L , Number L , @@a5@@ ) ; else @@v9@@ = re_search_internal ( @@a1@@ , ( _DWORD ) @@a2@@ , @@v11@@ , @@v10@@ , @@v11@@ , @@v11@@ , @@a3@@ , ( __int64 ) @@a4@@ , @@a5@@ ) ; return @@v9@@ != Number ; }
__int64 __fastcall clean_state_log_if_needed ( _QWORD * @@a1@@ , unsigned __int64 @@a2@@ ) { unsigned int @@v3@@ ; unsigned __int64 @@v4@@ ; @@v4@@ = @@a1@@ [ Number ] ; if ( @@a2@@ >= @@a1@@ [ Number ] || @@a2@@ >= @@a1@@ [ Number ] && @@a1@@ [ Number ] < @@a1@@ [ Number ] ) { @@v3@@ = extend_buffers ( @@a1@@ ) ; if ( @@v3@@ ) return @@v3@@ ; } if ( @@v4@@ < @@a2@@ ) { memset ( ( void * ) ( Number * ( @@v4@@ + Number ) + @@a1@@ [ Number ] ) , Number , Number * ( @@a2@@ - @@v4@@ ) ) ; @@a1@@ [ Number ] = @@a2@@ ; } return Number L ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
__int64 __fastcall sha256_read_ctx ( __int64 @@a1@@ , __int64 @@a2@@ ) { int @@i@@ ; for ( @@i@@ = Number ; @@i@@ <= Number ; ++ @@i@@ ) set_uint32 ( ( _DWORD * ) ( Number L * @@i@@ + @@a2@@ ) , HIBYTE ( * ( _DWORD * ) ( @@a1@@ + Number L * @@i@@ ) ) | ( * ( _DWORD * ) ( @@a1@@ + Number L * @@i@@ ) >> Number ) & Number | ( * ( _DWORD * ) ( @@a1@@ + Number L * @@i@@ ) << Number ) & Number | ( * ( _DWORD * ) ( @@a1@@ + Number L * @@i@@ ) << Number ) ) ; return @@a2@@ ; }
_QWORD * __fastcall rpl_re_set_registers ( __int64 @@a1@@ , _QWORD * @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ ) { _QWORD * @@result@@ ; if ( @@a3@@ ) { * ( _BYTE * ) ( @@a1@@ + Number ) = * ( _BYTE * ) ( @@a1@@ + Number ) & Number | Number ; * @@a2@@ = @@a3@@ ; @@a2@@ [ Number ] = @@a4@@ ; @@result@@ = @@a2@@ ; @@a2@@ [ Number ] = @@a5@@ ; } else { * ( _BYTE * ) ( @@a1@@ + Number ) &= Number ; * @@a2@@ = Number L ; @@a2@@ [ Number ] = Number L ; @@result@@ = @@a2@@ ; @@a2@@ [ Number ] = @@a2@@ [ Number ] ; } return @@result@@ ; }
__int64 __fastcall add_epsilon_src_nodes ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { unsigned int @@v5@@ ; unsigned __int64 @@i@@ ; _QWORD * @@v7@@ ; unsigned __int64 @@v8@@ ; @@v8@@ = __readfsqword ( Number ) ; @@v5@@ = Number ; @@v7@@ = re_acquire_state ( & @@v5@@ , @@a1@@ , @@a2@@ ) ; if ( @@v5@@ ) return @@v5@@ ; if ( ! @@v7@@ [ Number ] ) { @@v5@@ = re_node_set_alloc ( @@v7@@ + Number , * ( _QWORD * ) ( @@a2@@ + Number ) ) ; if ( @@v5@@ ) return Number L ; for ( @@i@@ = Number L ; @@i@@ < * ( _QWORD * ) ( @@a2@@ + Number ) ; ++ @@i@@ ) re_node_set_merge ( ( __int64 ) ( @@v7@@ + Number ) , * ( _QWORD * ) ( @@a1@@ + Number ) + Number L * * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) ) ; } return re_node_set_add_intersect ( @@a2@@ , @@a3@@ , ( __int64 ) ( @@v7@@ + Number ) ) ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; FILE * @@v10@@ ; char * @@v11@@ ; FILE * @@v12@@ ; char * @@v13@@ ; if ( @@a1@@ ) { @@v1@@ = program_name ; @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = program_name ; @@v4@@ = program_name ; @@v5@@ = gettext ( String ) ; printf ( @@v5@@ , @@v4@@ , @@v3@@ ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String String String String String String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; @@v8@@ = stdout ; @@v9@@ = gettext ( String String ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = stdout ; @@v11@@ = gettext ( String ) ; fputs_unlocked ( @@v11@@ , @@v10@@ ) ; @@v12@@ = stdout ; @@v13@@ = gettext ( String ) ; fputs_unlocked ( @@v13@@ , @@v12@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 __fastcall sha224_stream ( FILE * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v3@@ ; char * @@ptr@@ ; size_t @@v5@@ ; char @@v6@@ [ Number ] ; unsigned __int64 @@v7@@ ; @@v7@@ = __readfsqword ( Number ) ; @@ptr@@ = ( char * ) malloc ( Number ) ; if ( ! @@ptr@@ ) return Number L ; sha224_init_ctx ( ( __int64 ) @@v6@@ ) ; LABEL_4 : @@v3@@ = Number L ; while ( Number ) { @@v5@@ = fread_unlocked ( & @@ptr@@ [ @@v3@@ ] , Number , Number - @@v3@@ , @@a1@@ ) ; @@v3@@ += @@v5@@ ; if ( @@v3@@ == Number ) { sha256_process_block ( @@ptr@@ , Number , @@v6@@ ) ; goto LABEL_4 ; } if ( ! @@v5@@ ) break ; if ( feof_unlocked ( @@a1@@ ) ) goto LABEL_12 ; } if ( ferror_unlocked ( @@a1@@ ) ) { free ( @@ptr@@ ) ; return Number L ; } LABEL_12 : if ( @@v3@@ ) sha256_process_bytes ( @@ptr@@ , @@v3@@ , @@v6@@ ) ; sha224_finish_ctx ( ( __int64 ) @@v6@@ , @@a2@@ ) ; free ( @@ptr@@ ) ; return Number L ; }
__int64 __fastcall check_halt_state_context ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { char @@v4@@ ; unsigned __int64 @@i@@ ; @@v4@@ = re_string_context_at ( @@a1@@ , @@a3@@ , * ( _DWORD * ) ( @@a1@@ + Number ) ) ; for ( @@i@@ = Number L ; @@i@@ < * ( _QWORD * ) ( @@a2@@ + Number ) ; ++ @@i@@ ) { if ( check_halt_node_context ( * ( _QWORD * * ) ( @@a1@@ + Number ) , * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) , @@v4@@ ) ) { return * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) ; } } return Number L ; }
__int64 __fastcall check_dst_limits_calc_pos ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ , unsigned __int64 @@a5@@ , __int64 @@a6@@ ) { __int64 @@result@@ ; int @@v7@@ ; int @@v8@@ ; __int64 @@v9@@ ; @@v9@@ = * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@a2@@ ; if ( @@a5@@ < * ( _QWORD * ) ( @@v9@@ + Number ) ) return Number ; if ( @@a5@@ > * ( _QWORD * ) ( @@v9@@ + Number ) ) return Number L ; if ( @@a5@@ == * ( _QWORD * ) ( @@v9@@ + Number ) ) @@v7@@ = Number ; else @@v7@@ = Number ; @@v8@@ = @@v7@@ | ( @@a5@@ == * ( _QWORD * ) ( @@v9@@ + Number ) ) ; if ( @@v8@@ ) @@result@@ = check_dst_limits_calc_pos_1 ( @@a1@@ , @@v8@@ , @@a3@@ , @@a4@@ , @@a6@@ ) ; else @@result@@ = Number L ; return @@result@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
void * __fastcall realloc_groupbuf ( void * @@a1@@ , unsigned __int64 @@a2@@ ) { if ( @@a2@@ <= Number ) return realloc ( @@a1@@ , Number * @@a2@@ ) ; * __errno_location ( ) = Number ; return Number L ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return xmalloc ( @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall pop_fail_stack ( _QWORD * @@a1@@ , _QWORD * @@a2@@ , __int64 @@a3@@ , void * @@a4@@ , __int64 @@a5@@ ) { _QWORD * @@v5@@ ; __int64 @@v6@@ ; __int64 @@v9@@ ; @@v9@@ = -- * @@a1@@ ; if ( * @@a1@@ > Number ) __assert_fail ( String , String , Number , String ) ; * @@a2@@ = * ( _QWORD * ) ( @@a1@@ [ Number ] + Number * @@v9@@ ) ; memcpy ( @@a4@@ , * ( const void * * ) ( @@a1@@ [ Number ] + Number * @@v9@@ + Number ) , Number * @@a3@@ ) ; free ( * ( void * * ) ( @@a5@@ + Number ) ) ; free ( * ( void * * ) ( @@a1@@ [ Number ] + Number * @@v9@@ + Number ) ) ; @@v5@@ = ( _QWORD * ) ( @@a1@@ [ Number ] + Number * @@v9@@ ) ; @@v6@@ = @@v5@@ [ Number ] ; * ( _QWORD * ) @@a5@@ = @@v5@@ [ Number ] ; * ( _QWORD * ) ( @@a5@@ + Number ) = @@v6@@ ; * ( _QWORD * ) ( @@a5@@ + Number ) = @@v5@@ [ Number ] ; return * ( _QWORD * ) ( @@a1@@ [ Number ] + Number * @@v9@@ + Number ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@ptr@@ ; }
__int64 __fastcall merge_state_array ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , unsigned __int64 @@a4@@ ) { _QWORD * @@v5@@ ; unsigned int @@v8@@ ; unsigned __int64 @@i@@ ; void * @@v10@@ [ Number ] ; @@v10@@ [ Number ] = ( void * ) __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ < @@a4@@ ; ++ @@i@@ ) { if ( * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ) { if ( * ( _QWORD * ) ( Number * @@i@@ + @@a3@@ ) ) { @@v8@@ = re_node_set_init_union ( @@v10@@ , * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) + Number L , * ( _QWORD * ) ( Number * @@i@@ + @@a3@@ ) + Number L ) ; if ( @@v8@@ ) return @@v8@@ ; @@v5@@ = ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; * @@v5@@ = re_acquire_state ( & @@v8@@ , @@a1@@ , ( __int64 ) @@v10@@ ) ; free ( @@v10@@ [ Number ] ) ; if ( @@v8@@ ) return @@v8@@ ; } } else { * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) = * ( _QWORD * ) ( Number * @@i@@ + @@a3@@ ) ; } } return Number L ; }
__int64 __fastcall bkm_scale_by_power ( unsigned __int64 * @@a1@@ , int @@a2@@ , int @@a3@@ ) { unsigned int @@i@@ ; for ( @@i@@ = Number ; @@a3@@ -- ; @@i@@ |= bkm_scale ( @@a1@@ , @@a2@@ ) ) { ; } return @@i@@ ; }
__int64 __fastcall transit_state ( _DWORD * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; unsigned __int8 @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; if ( ( * ( _BYTE * ) ( @@a3@@ + Number ) & Number ) != Number ) { * @@a1@@ = transit_state_mb ( @@a2@@ , @@a3@@ ) ; if ( * @@a1@@ ) return Number L ; } @@v4@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@v5@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; * ( _QWORD * ) ( @@a2@@ + Number ) = @@v5@@ + Number ; @@v9@@ = * ( _BYTE * ) ( @@v4@@ + @@v5@@ ) ; while ( Number ) { @@v10@@ = * ( _QWORD * ) ( @@a3@@ + Number ) ; if ( @@v10@@ ) return * ( _QWORD * ) ( Number L * @@v9@@ + @@v10@@ ) ; @@v11@@ = * ( _QWORD * ) ( @@a3@@ + Number ) ; if ( @@v11@@ ) break ; if ( ( unsigned __int8 ) build_trtable ( * ( _QWORD * ) ( @@a2@@ + Number ) , @@a3@@ ) != Number ) { * @@a1@@ = Number ; return Number L ; } } if ( ( re_string_context_at ( @@a2@@ , * ( _QWORD * ) ( @@a2@@ + Number ) - Number L , * ( _DWORD * ) ( @@a2@@ + Number ) ) & Number ) != Number ) @@v6@@ = Number * ( @@v9@@ + Number L ) ; else @@v6@@ = Number L * @@v9@@ ; return * ( _QWORD * ) ( @@v6@@ + @@v11@@ ) ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
__int64 __fastcall check_dst_limits_calc_pos_1 ( __int64 @@a1@@ , int @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ ) { int @@v5@@ ; __int64 @@result@@ ; __int64 @@v7@@ ; int @@v11@@ ; unsigned __int64 @@i@@ ; __int64 @@v13@@ ; _QWORD * @@v14@@ ; __int64 @@v15@@ ; __int64 @@v16@@ ; __int64 @@v17@@ ; @@v14@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; @@v15@@ = @@v14@@ [ Number ] + Number * @@a4@@ ; for ( @@i@@ = Number L ; ; ++ @@i@@ ) { if ( @@i@@ >= * ( _QWORD * ) ( @@v15@@ + Number ) ) return ( @@a2@@ >> Number ) & Number ; @@v16@@ = * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@v15@@ + Number ) ) ; @@v5@@ = * ( unsigned __int8 * ) ( Number * @@v16@@ + * @@v14@@ + Number ) ; if ( @@v5@@ == Number ) { if ( ( @@a2@@ & Number ) != Number && @@a3@@ == * ( _QWORD * ) ( Number * @@v16@@ + * @@v14@@ ) ) { return Number ; } continue ; } if ( @@v5@@ != Number ) break ; if ( ( @@a2@@ & Number ) != Number && @@a3@@ == * ( _QWORD * ) ( Number * @@v16@@ + * @@v14@@ ) ) { return Number L ; } LABEL_29 : ; } if ( @@v5@@ != Number || @@a5@@ == Number ) goto LABEL_29 ; @@v13@@ = * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@a5@@ ; while ( Number ) { if ( @@v16@@ != * ( _QWORD * ) @@v13@@ || @@a3@@ <= Number && ( ( * ( unsigned __int16 * ) ( @@v13@@ + Number ) >> @@a3@@ ) & Number L ) == Number ) { goto LABEL_21 ; } @@v17@@ = * * ( _QWORD * * ) ( @@v14@@ [ Number ] + Number * @@v16@@ + Number ) ; if ( @@v17@@ == @@a4@@ ) break ; @@v11@@ = check_dst_limits_calc_pos_1 ( @@a1@@ , @@a2@@ , @@a3@@ , @@v17@@ , @@a5@@ ) ; if ( @@v11@@ == Number ) return Number ; if ( ! @@v11@@ && ( @@a2@@ & Number ) != Number ) return Number L ; if ( @@a3@@ <= Number ) * ( _WORD * ) ( @@v13@@ + Number ) &= ~ ( unsigned __int16 ) ( Number L << @@a3@@ ) ; LABEL_21 : @@v7@@ = @@v13@@ ; @@v13@@ += Number L ; if ( ! * ( _BYTE * ) ( @@v7@@ + Number ) ) goto LABEL_29 ; } if ( ( @@a2@@ & Number ) != Number ) @@result@@ = Number ; else @@result@@ = Number L ; return @@result@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 __fastcall find_subexp_node ( _QWORD * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , int @@a4@@ ) { unsigned __int64 @@i@@ ; __int64 @@v6@@ ; for ( @@i@@ = Number L ; @@i@@ < * ( _QWORD * ) ( @@a2@@ + Number ) ; ++ @@i@@ ) { @@v6@@ = Number L * * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) + * @@a1@@ ; if ( @@a4@@ == * ( unsigned __int8 * ) ( @@v6@@ + Number ) && @@a3@@ == * ( _QWORD * ) @@v6@@ ) { return * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) ; } } return Number ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_208028 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
int tolower ( int @@c@@ ) { return tolower ( @@c@@ ) ; }
__int64 __fastcall select_plural ( __int64 @@a1@@ ) { return @@a1@@ ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall get_subexp_sub ( _QWORD * @@a1@@ , _QWORD * @@a2@@ , _QWORD * @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ ) { __int64 @@result@@ ; unsigned int @@v9@@ ; unsigned int @@v10@@ ; @@v9@@ = check_arrival ( ( _DWORD ) @@a1@@ , ( int ) @@a3@@ + Number , * @@a3@@ , @@a3@@ [ Number ] , @@a4@@ , @@a5@@ , Number ) ; if ( @@v9@@ ) return @@v9@@ ; @@v10@@ = match_ctx_add_entry ( @@a1@@ , @@a4@@ , @@a5@@ , * @@a2@@ , @@a3@@ [ Number ] ) ; if ( @@v10@@ ) @@result@@ = @@v10@@ ; else @@result@@ = clean_state_log_if_needed ( @@a1@@ , @@a5@@ + @@a3@@ [ Number ] - * @@a2@@ ) ; return @@result@@ ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_2080E8 ; @@v4@@ [ Number ] = qword_2080F0 ; @@v4@@ [ Number ] = qword_2080F8 ; @@v4@@ [ Number ] = qword_208100 ; @@v4@@ [ Number ] = qword_208108 ; @@v4@@ [ Number ] = qword_208110 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
__int64 __fastcall bsd_split_3 ( __int64 @@a1@@ , __int64 @@a2@@ , _QWORD * @@a3@@ , _QWORD * @@a4@@ ) { __int64 @@v5@@ ; __int64 @@i@@ ; __int64 @@v7@@ ; __int64 @@j@@ ; if ( ! @@a2@@ ) return Number L ; * @@a4@@ = @@a1@@ ; for ( @@i@@ = @@a2@@ - Number ; @@i@@ && * ( _BYTE * ) ( @@a1@@ + @@i@@ ) != Number ; -- @@i@@ ) { ; } if ( * ( _BYTE * ) ( @@a1@@ + @@i@@ ) != Number ) return Number L ; @@v5@@ = @@i@@ ; @@v7@@ = @@i@@ + Number ; * ( _BYTE * ) ( @@a1@@ + @@v5@@ ) = Number ; while ( * ( _BYTE * ) ( @@a1@@ + @@v7@@ ) == Number || * ( _BYTE * ) ( @@a1@@ + @@v7@@ ) == Number ) ++ @@v7@@ ; if ( * ( _BYTE * ) ( @@a1@@ + @@v7@@ ) != Number ) return Number L ; for ( @@j@@ = @@v7@@ + Number ; * ( _BYTE * ) ( @@a1@@ + @@j@@ ) == Number || * ( _BYTE * ) ( @@a1@@ + @@j@@ ) == Number ; ++ @@j@@ ) { ; } * @@a3@@ = @@j@@ + @@a1@@ ; return Number L ; }
__int64 __fastcall check_arrival_add_next_nodes ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ ) { _QWORD * @@v5@@ ; unsigned int @@v8@@ ; int @@v9@@ ; unsigned __int64 @@i@@ ; _QWORD * @@v11@@ ; __int64 @@v12@@ ; unsigned __int64 @@v13@@ ; __int64 @@v14@@ ; __int64 @@v15@@ ; char @@s@@ [ Number ] ; __int64 @@v17@@ ; void * @@ptr@@ ; unsigned __int64 @@v19@@ ; @@v19@@ = __readfsqword ( Number ) ; @@v11@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; @@v8@@ = Number ; memset ( @@s@@ , Number , Number ) ; for ( @@i@@ = Number L ; @@i@@ < * ( _QWORD * ) ( @@a3@@ + Number ) ; ++ @@i@@ ) { @@v9@@ = Number ; @@v12@@ = * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a3@@ + Number ) ) ; if ( ( * ( _BYTE * ) ( Number * @@v12@@ + * @@v11@@ + Number ) & Number ) != Number ) { @@v9@@ = check_node_accept_bytes ( @@v11@@ , @@v12@@ , @@a1@@ , @@a2@@ ) ; if ( @@v9@@ > Number ) { @@v13@@ = * ( _QWORD * ) ( Number * @@v12@@ + @@v11@@ [ Number ] ) ; @@v14@@ = @@v9@@ + @@a2@@ ; @@v15@@ = * ( _QWORD * ) ( Number * @@v14@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) ; @@v17@@ = Number L ; if ( @@v15@@ ) { @@v8@@ = re_node_set_merge ( ( __int64 ) @@s@@ , @@v15@@ + Number ) ; if ( @@v8@@ ) goto LABEL_6 ; } if ( ! re_node_set_insert ( ( __int64 ) @@s@@ , @@v13@@ ) ) goto LABEL_8 ; @@v5@@ = ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@v14@@ ) ; * @@v5@@ = re_acquire_state ( & @@v8@@ , ( __int64 ) @@v11@@ , ( __int64 ) @@s@@ ) ; if ( ! * ( _QWORD * ) ( Number * @@v14@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) ) { if ( @@v8@@ ) { LABEL_6 : free ( @@ptr@@ ) ; return @@v8@@ ; } } } } if ( ( @@v9@@ || ( unsigned __int8 ) check_node_accept ( @@a1@@ , * @@v11@@ + Number * @@v12@@ , @@a2@@ ) ) && ! re_node_set_insert ( @@a4@@ , * ( _QWORD * ) ( Number * @@v12@@ + @@v11@@ [ Number ] ) ) ) { LABEL_8 : free ( @@ptr@@ ) ; return Number L ; } } free ( @@ptr@@ ) ; return Number L ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall check_arrival_expand_ecl_sub ( _QWORD * @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ , unsigned int @@a5@@ ) { unsigned __int64 @@i@@ ; unsigned int @@v9@@ ; unsigned __int64 @@v10@@ ; @@v10@@ = @@a3@@ ; for ( @@i@@ = re_node_set_contains ( @@a2@@ , @@a3@@ ) ; ! @@i@@ ; @@i@@ = re_node_set_contains ( @@a2@@ , @@v10@@ ) ) { if ( @@a5@@ == * ( unsigned __int8 * ) ( Number * @@v10@@ + * @@a1@@ + Number ) && @@a4@@ == * ( _QWORD * ) ( Number * @@v10@@ + * @@a1@@ ) ) { if ( @@a5@@ == Number && ! re_node_set_insert ( @@a2@@ , @@v10@@ ) ) return Number L ; return Number L ; } if ( ! re_node_set_insert ( @@a2@@ , @@v10@@ ) ) return Number L ; if ( ! * ( _QWORD * ) ( @@a1@@ [ Number ] + Number * @@v10@@ + Number ) ) return Number L ; if ( * ( _QWORD * ) ( @@a1@@ [ Number ] + Number * @@v10@@ + Number ) == Number L ) { @@v9@@ = check_arrival_expand_ecl_sub ( @@a1@@ , @@a2@@ , * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ [ Number ] + Number * @@v10@@ + Number ) + Number L ) , @@a4@@ , @@a5@@ ) ; if ( @@v9@@ ) return @@v9@@ ; } @@v10@@ = * * ( _QWORD * * ) ( @@a1@@ [ Number ] + Number * @@v10@@ + Number ) ; } return Number L ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
void * __fastcall xmalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = malloc ( @@a1@@ ) ; if ( ! @@v4@@ && @@a1@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
__int64 __fastcall search_cur_bkref_entry ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { __int64 @@result@@ ; unsigned __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; @@v4@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v3@@ = Number L ; while ( @@v3@@ < @@v4@@ ) { if ( @@a2@@ <= * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * ( ( @@v3@@ + @@v4@@ ) >> Number ) + Number ) ) @@v4@@ = ( @@v3@@ + @@v4@@ ) >> Number ; else @@v3@@ = ( ( @@v3@@ + @@v4@@ ) >> Number ) + Number ; } if ( @@v3@@ < * ( _QWORD * ) ( @@a1@@ + Number ) && @@a2@@ == * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@v3@@ + Number ) ) { @@result@@ = @@v3@@ ; } else { @@result@@ = Number ; } return @@result@@ ; }
_QWORD * __fastcall match_ctx_clean ( _QWORD * @@a1@@ ) { _QWORD * @@result@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@j@@ ; void * @@v4@@ ; void * * @@ptr@@ ; for ( @@i@@ = Number L ; @@i@@ < @@a1@@ [ Number ] ; ++ @@i@@ ) { @@v4@@ = * ( void * * ) ( Number * @@i@@ + @@a1@@ [ Number ] ) ; for ( @@j@@ = Number L ; @@j@@ < * ( ( _QWORD * ) @@v4@@ + Number ) ; ++ @@j@@ ) { @@ptr@@ = * ( void * * * ) ( Number * @@j@@ + * ( ( _QWORD * ) @@v4@@ + Number ) ) ; free ( @@ptr@@ [ Number ] ) ; free ( @@ptr@@ ) ; } free ( * ( ( void * * ) @@v4@@ + Number ) ) ; if ( * ( ( _QWORD * ) @@v4@@ + Number ) ) { free ( * ( void * * ) ( * ( ( _QWORD * ) @@v4@@ + Number ) + Number L ) ) ; free ( * ( ( void * * ) @@v4@@ + Number ) ) ; } free ( @@v4@@ ) ; } @@a1@@ [ Number ] = Number L ; @@result@@ = @@a1@@ ; @@a1@@ [ Number ] = Number L ; return @@result@@ ; }
void * __fastcall xzalloc ( size_t @@a1@@ , __int64 @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a1@@ , @@a2@@ ) ; return memset ( @@v2@@ , Number , @@a1@@ ) ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
__int64 __fastcall xnrealloc ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { if ( ! is_mul_ok ( @@a3@@ , @@a2@@ ) ) xalloc_die ( ) ; return xrealloc ( @@a1@@ , @@a3@@ * @@a2@@ ) ; }
void * __fastcall sift_ctx_init ( _QWORD * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ ) { * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@a3@@ ; @@a1@@ [ Number ] = @@a4@@ ; @@a1@@ [ Number ] = @@a5@@ ; return memset ( @@a1@@ + Number , Number , Number ) ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
__int64 __fastcall bkm_scale_by_power ( unsigned __int64 * @@a1@@ , int @@a2@@ , int @@a3@@ ) { unsigned int @@i@@ ; for ( @@i@@ = Number ; @@a3@@ -- ; @@i@@ |= bkm_scale ( @@a1@@ , @@a2@@ ) ) { ; } return @@i@@ ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ ) { return xmalloc ( @@a1@@ ) ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v4@@ ; @@v4@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v4@@ >= Number / @@a3@@ ) xalloc_die ( ) ; @@v4@@ += ( @@v4@@ + Number ) >> Number ; } else if ( ! @@v4@@ ) { @@v4@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v4@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v4@@ ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@v2@@ ; @@v2@@ = malloc ( @@a1@@ ) ; if ( ! @@v2@@ && @@a1@@ ) xalloc_die ( ) ; return @@v2@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@v3@@ ; @@v3@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v3@@ ) xalloc_die ( ) ; return @@v3@@ ; }
int iswlower ( wint_t @@wc@@ ) { return iswlower ( @@wc@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
__int64 __fastcall fd_safer ( int @@a1@@ ) { unsigned int @@fd@@ ; unsigned int @@v3@@ ; int @@v4@@ ; @@fd@@ = @@a1@@ ; if ( @@a1@@ >= Number && @@a1@@ <= Number ) { @@v3@@ = dup_safer ( ( unsigned int ) @@a1@@ ) ; @@v4@@ = * __errno_location ( ) ; close ( @@a1@@ ) ; * __errno_location ( ) = @@v4@@ ; @@fd@@ = @@v3@@ ; } return @@fd@@ ; }
void * __fastcall xzalloc ( size_t @@a1@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@a1@@ ) ; return memset ( @@v1@@ , Number , @@a1@@ ) ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
int isatty ( int @@fd@@ ) { return isatty ( @@fd@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
int fclose ( FILE * @@stream@@ ) { return fclose ( @@stream@@ ) ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v3@@ ; unsigned __int64 @@v6@@ ; @@v6@@ = * @@a2@@ ; if ( @@a1@@ ) { @@v3@@ = Number % @@a3@@ ; if ( @@v6@@ >= Number / @@a3@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v3@@ ) ; @@v6@@ += ( @@v6@@ + Number ) >> Number ; } else if ( ! @@v6@@ ) { @@v6@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v6@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v6@@ ) ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { __int64 @@v2@@ ; void * @@v4@@ ; @@v4@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v4@@ ) xalloc_die ( @@a1@@ , @@a2@@ , @@v2@@ ) ; return @@v4@@ ; }
int fileno ( FILE * @@stream@@ ) { return fileno ( @@stream@@ ) ; }
__int64 __fastcall sha224_finish_ctx ( __int64 @@a1@@ , __int64 @@a2@@ ) { sha256_conclude_ctx ( @@a1@@ ) ; return sha224_read_ctx ( @@a1@@ , @@a2@@ ) ; }
int __fastcall __cxa_atexit ( void ( __fastcall * @@lpfunc@@ ) ( void * ) , void * @@obj@@ , void * @@lpdso_handle@@ ) { return _cxa_atexit ( @@lpfunc@@ , @@obj@@ , @@lpdso_handle@@ ) ; }
wint_t btowc ( int @@c@@ ) { return btowc ( @@c@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
int fflush_unlocked ( FILE * @@stream@@ ) { return fflush_unlocked ( @@stream@@ ) ; }
void __fastcall __noreturn start ( __int64 a1 , __int64 a2 , void ( * @@a3@@ ) ( void ) ) { __int64 @@v3@@ ; int @@v4@@ ; __int64 @@v5@@ ; char * @@retaddr@@ ; @@v4@@ = @@v5@@ ; @@v5@@ = @@v3@@ ; _libc_start_main ( ( int ( __fastcall * ) ( int , char * * , char * * ) ) main , @@v4@@ , & @@retaddr@@ , _libc_csu_init , _libc_csu_fini , @@a3@@ , & @@v5@@ ) ; __halt ( ) ; }
__int64 __fastcall rpl_fcntl ( int @@a1@@ , int @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ , __m128 @@a7@@ , __m128 @@a8@@ , __m128 @@a9@@ , __m128 @@a10@@ , __m128 @@a11@@ , __m128 @@a12@@ , __m128 @@a13@@ , __m128 @@a14@@ ) { int @@v14@@ ; int @@v15@@ ; int @@v16@@ ; int @@v18@@ ; int @@v19@@ ; int @@v20@@ ; int @@v21@@ ; __int64 @@v22@@ ; __int64 @@v23@@ ; __int64 @@v24@@ ; __int64 @@v25@@ ; __m128 @@v26@@ ; __m128 @@v27@@ ; __m128 @@v28@@ ; __m128 @@v29@@ ; __m128 @@v30@@ ; __m128 @@v31@@ ; __m128 @@v32@@ ; __m128 @@v33@@ ; @@v22@@ = @@a3@@ ; @@v23@@ = @@a4@@ ; @@v24@@ = @@a5@@ ; @@v25@@ = @@a6@@ ; @@v26@@ = @@a7@@ ; @@v27@@ = @@a8@@ ; @@v28@@ = @@a9@@ ; @@v29@@ = @@a10@@ ; @@v30@@ = @@a11@@ ; @@v31@@ = @@a12@@ ; @@v32@@ = @@a13@@ ; @@v33@@ = @@a14@@ ; if ( @@a2@@ != Number ) return ( unsigned int ) fcntl ( @@a1@@ , @@a2@@ , @@v22@@ ) ; @@v19@@ = @@v22@@ ; if ( have_dupfd_cloexec_2895 < Number ) { @@v18@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v22@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; } else { @@v18@@ = fcntl ( @@a1@@ , Number , ( unsigned int ) @@v22@@ ) ; if ( @@v18@@ < Number && * __errno_location ( ) == Number ) { @@v18@@ = ( ( __int64 ( __fastcall * ) ( _DWORD , _DWORD , _DWORD , _DWORD , _DWORD , _DWORD ) ) rpl_fcntl ) ( @@a1@@ , Number , @@v19@@ , @@v14@@ , @@v15@@ , @@v16@@ ) ; if ( @@v18@@ < Number ) return ( unsigned int ) @@v18@@ ; have_dupfd_cloexec_2895 = Number ; } else { have_dupfd_cloexec_2895 = Number ; } } if ( @@v18@@ >= Number && have_dupfd_cloexec_2895 == Number ) { @@v20@@ = fcntl ( @@v18@@ , Number ) ; if ( @@v20@@ < Number || fcntl ( @@v18@@ , Number , @@v20@@ | Number ) == Number ) { @@v21@@ = * __errno_location ( ) ; close ( @@v18@@ ) ; * __errno_location ( ) = @@v21@@ ; @@v18@@ = Number ; } } return ( unsigned int ) @@v18@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 __fastcall simple_cat ( __int64 @@a1@@ , __int64 @@a2@@ ) { const char * @@v2@@ ; int * @@v3@@ ; char * @@v5@@ ; int * @@v6@@ ; __int64 @@v7@@ ; while ( Number ) { @@v7@@ = safe_read ( ( unsigned int ) input_desc , @@a1@@ , @@a2@@ ) ; if ( @@v7@@ == Number ) { @@v2@@ = infile ; @@v3@@ = __errno_location ( ) ; error ( Number , * @@v3@@ , String , @@v2@@ ) ; return Number L ; } if ( ! @@v7@@ ) break ; if ( @@v7@@ != full_write ( Number L , @@a1@@ , @@v7@@ ) ) { @@v5@@ = gettext ( String ) ; @@v6@@ = __errno_location ( ) ; error ( Number , * @@v6@@ , @@v5@@ ) ; } } return Number L ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
int iswalnum ( wint_t @@wc@@ ) { return iswalnum ( @@wc@@ ) ; }
unsigned __int64 __fastcall sha256_process_bytes ( char * @@a1@@ , unsigned __int64 @@a2@@ , size_t * @@a3@@ ) { unsigned __int64 @@result@@ ; size_t @@v4@@ ; void * @@v5@@ ; size_t @@v7@@ ; char * @@src@@ ; size_t @@v9@@ ; size_t @@v10@@ ; size_t @@v11@@ ; size_t @@n@@ ; @@src@@ = @@a1@@ ; @@v7@@ = @@a2@@ ; @@result@@ = @@a3@@ [ Number ] ; if ( @@result@@ ) { @@v11@@ = @@a3@@ [ Number ] ; @@v4@@ = Number - @@v11@@ ; if ( @@a2@@ <= Number - @@v11@@ ) @@v4@@ = @@a2@@ ; @@n@@ = @@v4@@ ; memcpy ( ( char * ) @@a3@@ + @@v11@@ + Number , @@a1@@ , @@v4@@ ) ; @@a3@@ [ Number ] += @@n@@ ; if ( @@a3@@ [ Number ] > Number ) { sha256_process_block ( @@a3@@ + Number , @@a3@@ [ Number ] & Number , @@a3@@ ) ; @@a3@@ [ Number ] &= Number ; memcpy ( @@a3@@ + Number , ( char * ) @@a3@@ + ( ( @@v11@@ + @@n@@ ) & Number ) + Number , @@a3@@ [ Number ] ) ; } @@src@@ = & @@a1@@ [ @@n@@ ] ; @@result@@ = @@n@@ ; @@v7@@ = @@a2@@ - @@n@@ ; } if ( @@v7@@ > Number ) { @@result@@ = ( unsigned __int8 ) @@src@@ & Number ; if ( ( ( unsigned __int8 ) @@src@@ & Number ) != Number ) { while ( @@v7@@ > Number ) { @@v5@@ = memcpy ( @@a3@@ + Number , @@src@@ , Number ) ; @@result@@ = sha256_process_block ( @@v5@@ , Number L , @@a3@@ ) ; @@src@@ += Number ; @@v7@@ -= Number L ; } } else { sha256_process_block ( @@src@@ , @@v7@@ & Number , @@a3@@ ) ; @@result@@ = @@v7@@ & Number ; @@src@@ += @@v7@@ & Number ; @@v7@@ &= Number ; } } if ( @@v7@@ ) { @@v9@@ = @@a3@@ [ Number ] ; memcpy ( ( char * ) @@a3@@ + @@v9@@ + Number , @@src@@ , @@v7@@ ) ; @@v10@@ = @@v7@@ + @@v9@@ ; if ( @@v10@@ > Number ) { sha256_process_block ( @@a3@@ + Number , Number L , @@a3@@ ) ; @@v10@@ -= Number L ; memcpy ( @@a3@@ + Number , @@a3@@ + Number , @@v10@@ ) ; } @@result@@ = ( unsigned __int64 ) @@a3@@ ; @@a3@@ [ Number ] = @@v10@@ ; } return @@result@@ ; }
void * malloc ( size_t @@size@@ ) { return malloc ( @@size@@ ) ; }
size_t __fpending ( FILE * @@fp@@ ) { return _fpending ( @@fp@@ ) ; }
__int64 __fastcall dup_safer ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
char * nl_langinfo ( nl_item @@item@@ ) { return nl_langinfo ( @@item@@ ) ; }
_BOOL8 __fastcall tac_nonseekable ( unsigned int @@a1@@ , __int64 @@a2@@ ) { char * @@v2@@ ; int @@v3@@ ; bool @@v4@@ ; FILE * @@stream@@ ; char * @@v7@@ [ Number ] ; @@v7@@ [ Number ] = ( char * ) __readfsqword ( Number ) ; @@v4@@ = Number ; if ( ( unsigned __int8 ) copy_to_temp ( & @@stream@@ , @@v7@@ , @@a1@@ , @@a2@@ ) ) { @@v2@@ = @@v7@@ [ Number ] ; @@v3@@ = fileno ( @@stream@@ ) ; if ( ( unsigned __int8 ) tac_seekable ( @@v3@@ , ( __int64 ) @@v2@@ ) ) @@v4@@ = Number ; } return @@v4@@ ; }
char * __fastcall proper_name_utf8 ( const char * @@a1@@ , __int64 @@a2@@ ) { char * @@v2@@ ; char * @@result@@ ; size_t @@v4@@ ; size_t @@v5@@ ; char * @@ptr@@ ; char * @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; char * @@s1@@ ; char * @@s@@ ; size_t @@n@@ ; char * @@dest@@ ; char * @@v14@@ ; char * @@v15@@ ; char * @@v16@@ ; @@s1@@ = gettext ( @@a1@@ ) ; @@s@@ = ( char * ) locale_charset ( ) ; @@ptr@@ = Number L ; @@v7@@ = Number L ; @@v9@@ = Number L ; if ( ( unsigned int ) c_strcasecmp ( @@s@@ , String ) ) { @@ptr@@ = ( char * ) xstr_iconv ( @@a2@@ , String , @@s@@ ) ; @@v8@@ = ( __int64 ) @@ptr@@ ; @@n@@ = strlen ( @@s@@ ) ; @@dest@@ = ( char * ) xmalloc ( @@n@@ + Number ) ; memcpy ( @@dest@@ , @@s@@ , @@n@@ ) ; memcpy ( & @@dest@@ [ @@n@@ ] , String , Number ) ; @@v14@@ = ( char * ) xstr_iconv ( @@a2@@ , String , @@dest@@ ) ; free ( @@dest@@ ) ; if ( @@v14@@ ) { if ( strchr ( @@v14@@ , Number ) ) { free ( @@v14@@ ) ; } else { @@v7@@ = @@v14@@ ; @@v9@@ = ( __int64 ) @@v14@@ ; } } } else { @@v8@@ = @@a2@@ ; @@v9@@ = @@a2@@ ; } if ( @@v8@@ ) { @@v2@@ = ( char * ) @@v8@@ ; } else if ( @@v9@@ ) { @@v2@@ = ( char * ) @@v9@@ ; } else { @@v2@@ = ( char * ) @@a1@@ ; } @@v15@@ = @@v2@@ ; if ( ! strcmp ( @@s1@@ , @@a1@@ ) ) { if ( @@ptr@@ && @@ptr@@ != @@v15@@ ) free ( @@ptr@@ ) ; if ( @@v7@@ && @@v7@@ != @@v15@@ ) free ( @@v7@@ ) ; @@result@@ = @@v15@@ ; } else if ( ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@s1@@ , ( __int64 ) @@a1@@ ) || @@v8@@ && ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@s1@@ , @@v8@@ ) || @@v9@@ && ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@s1@@ , @@v9@@ ) ) { if ( @@ptr@@ ) free ( @@ptr@@ ) ; if ( @@v7@@ ) free ( @@v7@@ ) ; @@result@@ = @@s1@@ ; } else { @@v4@@ = strlen ( @@s1@@ ) ; @@v5@@ = strlen ( @@v15@@ ) ; @@v16@@ = ( char * ) xmalloc ( @@v4@@ + @@v5@@ + Number ) ; sprintf ( @@v16@@ , String , @@s1@@ , @@v15@@ ) ; if ( @@ptr@@ ) free ( @@ptr@@ ) ; if ( @@v7@@ ) free ( @@v7@@ ) ; @@result@@ = @@v16@@ ; } return @@result@@ ; }
void free ( void * @@ptr@@ ) { free ( @@ptr@@ ) ; }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
int __fxstat ( int @@ver@@ , int @@fildes@@ , struct stat * @@stat_buf@@ ) { return _fxstat ( @@ver@@ , @@fildes@@ , @@stat_buf@@ ) ; }
struct passwd * getpwuid ( __uid_t @@uid@@ ) { return getpwuid ( @@uid@@ ) ; }
__int64 __fastcall quote_n ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( @@a1@@ , Number L , @@a2@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
int tolower ( int @@c@@ ) { return tolower ( @@c@@ ) ; }
char * strdup ( const char * @@s@@ ) { return strdup ( @@s@@ ) ; }
struct passwd * getpwnam ( const char * @@name@@ ) { return getpwnam ( @@name@@ ) ; }
wint_t towlower ( wint_t @@wc@@ ) { return towlower ( @@wc@@ ) ; }
int setuid ( __uid_t @@uid@@ ) { return setuid ( @@uid@@ ) ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
int emit_ancillary_info ( ) { __int64 @@v0@@ ; char * @@v1@@ ; char * @@v2@@ ; FILE * @@v3@@ ; char * @@v4@@ ; __int64 @@v5@@ ; char * @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; const char * @@s1@@ ; @@v0@@ = last_component ( program_name ) ; @@v1@@ = gettext ( String ) ; printf ( @@v1@@ , @@v0@@ , String ) ; @@v2@@ = gettext ( String ) ; printf ( @@v2@@ , String , String ) ; @@v3@@ = stdout ; @@v4@@ = gettext ( String ) ; fputs_unlocked ( @@v4@@ , @@v3@@ ) ; @@s1@@ = setlocale ( Number , Number L ) ; if ( @@s1@@ && strncmp ( @@s1@@ , String , Number ) ) { @@v5@@ = last_component ( program_name ) ; @@v6@@ = gettext ( String ) ; printf ( @@v6@@ , @@v5@@ ) ; } @@v7@@ = last_component ( program_name ) ; @@v8@@ = gettext ( String ) ; return printf ( @@v8@@ , @@v7@@ ) ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; char * @@v3@@ ; FILE * @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; FILE * @@v10@@ ; char * @@v11@@ ; FILE * @@v12@@ ; char * @@v13@@ ; @@v1@@ = program_name ; if ( @@a1@@ ) { @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = gettext ( String ) ; printf ( @@v3@@ , @@v1@@ ) ; @@v4@@ = stdout ; @@v5@@ = gettext ( String String String ) ; fputs_unlocked ( @@v5@@ , @@v4@@ ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; @@v8@@ = stdout ; @@v9@@ = gettext ( String String String ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = stdout ; @@v11@@ = gettext ( String ) ; fputs_unlocked ( @@v11@@ , @@v10@@ ) ; @@v12@@ = stdout ; @@v13@@ = gettext ( String ) ; fputs_unlocked ( @@v13@@ , @@v12@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , String , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
int __fastcall version_etc_ar ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , __int64 * @@a5@@ ) { __int64 @@i@@ ; for ( @@i@@ = Number L ; @@a5@@ [ @@i@@ ] ; ++ @@i@@ ) ; return version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@i@@ ) ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_20C058 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
_BOOL8 __fastcall tac_file ( const char * @@a1@@ ) { int @@v1@@ ; __int64 @@v2@@ ; char * @@v3@@ ; int * @@v4@@ ; bool @@v6@@ ; __int64 @@v7@@ ; char * @@v8@@ ; int * @@v9@@ ; char * @@s1@@ ; bool @@v11@@ ; bool @@v12@@ ; int @@fd@@ ; @@s1@@ = ( char * ) @@a1@@ ; @@v1@@ = strcmp ( @@a1@@ , String ) ; @@v12@@ = @@v1@@ == Number ; if ( @@v1@@ ) { @@fd@@ = open ( @@a1@@ , Number ) ; if ( @@fd@@ < Number ) { @@v2@@ = quote ( @@a1@@ ) ; @@v3@@ = gettext ( String ) ; @@v4@@ = __errno_location ( ) ; error ( Number , * @@v4@@ , @@v3@@ , @@v2@@ ) ; return Number L ; } } else { have_read_stdin = Number ; @@fd@@ = Number ; @@s1@@ = gettext ( String ) ; } if ( lseek ( @@fd@@ , Number L , Number ) < Number || isatty ( @@fd@@ ) ) @@v6@@ = tac_nonseekable ( @@fd@@ , ( __int64 ) @@s1@@ ) ; else @@v6@@ = ( unsigned __int8 ) tac_seekable ( @@fd@@ , ( __int64 ) @@s1@@ ) != Number ; @@v11@@ = @@v6@@ ; if ( ! @@v12@@ ) { if ( close ( @@fd@@ ) ) { @@v7@@ = quotearg_colon ( @@s1@@ ) ; @@v8@@ = gettext ( String ) ; @@v9@@ = __errno_location ( ) ; error ( Number , * @@v9@@ , @@v8@@ , @@v7@@ ) ; @@v11@@ = Number ; } } return @@v11@@ ; }
__int64 __fastcall xstr_cd_iconv ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@v3@@ ; @@v3@@ = str_cd_iconv ( @@a1@@ , @@a2@@ ) ; if ( ! @@v3@@ && * __errno_location ( ) == Number ) xalloc_die ( ) ; return @@v3@@ ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
void * __fastcall bitset_empty ( void * @@a1@@ ) { return memset ( @@a1@@ , Number , Number ) ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
__int64 __fastcall re_string_wchar_at ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; if ( * ( _DWORD * ) ( @@a1@@ + Number ) == Number ) @@result@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ ) ; else @@result@@ = * ( unsigned int * ) ( Number * @@a2@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) ; return @@result@@ ; }
size_t __fastcall base_len ( const char * @@a1@@ ) { size_t @@i@@ ; for ( @@i@@ = strlen ( @@a1@@ ) ; @@i@@ > Number && @@a1@@ [ @@i@@ - Number ] == Number ; -- @@i@@ ) { ; } return @@i@@ ; }
ssize_t __fastcall safe_read ( int @@a1@@ , void * @@a2@@ , size_t @@a3@@ ) { ssize_t @@result@@ ; ssize_t @@v5@@ ; LABEL_1 : for ( @@result@@ = read ( @@a1@@ , @@a2@@ , @@a3@@ ) ; ; @@result@@ = read ( @@a1@@ , @@a2@@ , Number ) ) { @@v5@@ = @@result@@ ; if ( @@result@@ >= Number ) break ; if ( * __errno_location ( ) == Number ) goto LABEL_1 ; if ( * __errno_location ( ) != Number || @@a3@@ <= Number ) return @@v5@@ ; @@a3@@ = Number L ; } return @@result@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
__int64 __fastcall get_quoting_style ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; return * ( unsigned int * ) @@v1@@ ; }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( ) ; return @@ptr@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
unsigned __int64 __fastcall re_string_skip_chars ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , wchar_t * @@a3@@ ) { _BOOL4 @@v3@@ ; wchar_t @@pwc@@ ; wchar_t @@v7@@ ; unsigned __int64 @@i@@ ; size_t @@v9@@ ; size_t @@n@@ ; __int64 @@v11@@ ; unsigned __int64 @@v12@@ ; @@v12@@ = __readfsqword ( Number ) ; @@v7@@ = Number ; for ( @@i@@ = * ( _QWORD * ) ( @@a1@@ + Number ) + * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ < @@a2@@ ; @@i@@ += @@v9@@ ) { @@n@@ = * ( _QWORD * ) ( @@a1@@ + Number ) - @@i@@ ; @@v11@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v9@@ = mbrtowc ( & @@pwc@@ , ( const char * ) ( * ( _QWORD * ) @@a1@@ + @@i@@ ) , @@n@@ , ( mbstate_t * ) ( @@a1@@ + Number ) ) ; @@v3@@ = @@v9@@ == Number || @@v9@@ == Number ; if ( ! @@v3@@ && @@v9@@ ) { @@v7@@ = @@pwc@@ ; } else { if ( @@v9@@ && @@n@@ ) @@v7@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) @@a1@@ + @@i@@ ) ; else @@v7@@ = Number ; @@v9@@ = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v11@@ ; } } * @@a3@@ = @@v7@@ ; return @@i@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
__int64 __fastcall c_strcasecmp ( unsigned __int8 * @@a1@@ , unsigned __int8 * @@a2@@ ) { unsigned __int8 * @@v2@@ ; unsigned __int8 * @@v3@@ ; unsigned __int8 @@v5@@ ; unsigned __int8 @@v6@@ ; @@v2@@ = @@a1@@ ; @@v3@@ = @@a2@@ ; if ( @@a1@@ == @@a2@@ ) return Number L ; do { @@v5@@ = c_tolower ( * @@v2@@ ) ; @@v6@@ = c_tolower ( * @@v3@@ ) ; if ( ! @@v5@@ ) break ; ++ @@v2@@ ; ++ @@v3@@ ; } while ( @@v5@@ == @@v6@@ ) ; return @@v5@@ - ( unsigned int ) @@v6@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 * __fastcall set_quoting_style ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@result@@ ; if ( @@a1@@ ) @@result@@ = @@a1@@ ; else @@result@@ = & default_quoting_options ; * ( _DWORD * ) @@result@@ = @@a2@@ ; return @@result@@ ; }
char * __fastcall str_iconv ( char * @@a1@@ , char * @@a2@@ , char * @@a3@@ ) { char * @@result@@ ; int @@v5@@ ; int @@v6@@ ; iconv_t @@cd@@ ; void * @@ptr@@ ; char * @@v9@@ ; if ( * @@a1@@ && ( unsigned int ) c_strcasecmp ( ( unsigned __int8 * ) @@a2@@ , ( unsigned __int8 * ) @@a3@@ ) ) { @@cd@@ = iconv_open ( @@a3@@ , @@a2@@ ) ; if ( @@cd@@ == ( iconv_t ) Number ) return Number L ; @@ptr@@ = str_cd_iconv ( @@a1@@ , @@cd@@ ) ; if ( @@ptr@@ ) { if ( iconv_close ( @@cd@@ ) < Number ) { @@v5@@ = * __errno_location ( ) ; free ( @@ptr@@ ) ; * __errno_location ( ) = @@v5@@ ; return Number L ; } } else { @@v6@@ = * __errno_location ( ) ; iconv_close ( @@cd@@ ) ; * __errno_location ( ) = @@v6@@ ; } @@result@@ = ( char * ) @@ptr@@ ; } else { @@v9@@ = strdup ( @@a1@@ ) ; if ( ! @@v9@@ ) * __errno_location ( ) = Number ; @@result@@ = @@v9@@ ; } return @@result@@ ; }
__int64 __fastcall re_string_context_at ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , char @@a3@@ ) { __int64 @@result@@ ; int @@v4@@ ; wint_t @@wc@@ ; unsigned __int64 @@v6@@ ; if ( @@a2@@ > Number ) return * ( unsigned int * ) ( @@a1@@ + Number ) ; if ( @@a2@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ) { if ( ( @@a3@@ & Number ) != Number ) @@result@@ = Number L ; else @@result@@ = Number L ; } else if ( * ( int * ) ( @@a1@@ + Number ) <= Number ) { @@v4@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ ) ; if ( bitset_contain ( * ( _QWORD * ) ( @@a1@@ + Number ) , * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ ) ) ) { @@result@@ = Number L ; } else if ( @@v4@@ == Number && * ( _BYTE * ) ( @@a1@@ + Number ) ) { @@result@@ = Number L ; } else { @@result@@ = Number L ; } } else { @@v6@@ = @@a2@@ ; while ( * ( _DWORD * ) ( Number * @@v6@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) == Number ) { if ( -- @@v6@@ > Number ) return * ( unsigned int * ) ( @@a1@@ + Number ) ; } @@wc@@ = * ( _DWORD * ) ( Number * @@v6@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) ; if ( * ( _BYTE * ) ( @@a1@@ + Number ) && ( iswalnum ( @@wc@@ ) || @@wc@@ == Number ) ) { @@result@@ = Number L ; } else if ( @@wc@@ == Number && * ( _BYTE * ) ( @@a1@@ + Number ) ) { @@result@@ = Number L ; } else { @@result@@ = Number L ; } } return @@result@@ ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 * * quotearg_free ( ) { __int64 * * @@result@@ ; unsigned int @@i@@ ; void * * @@ptr@@ ; @@ptr@@ = ( void * * ) slotvec ; for ( @@i@@ = Number ; @@i@@ < nslots ; ++ @@i@@ ) free ( @@ptr@@ [ Number * @@i@@ + Number ] ) ; if ( @@ptr@@ [ Number ] != & slot0 ) { free ( @@ptr@@ [ Number ] ) ; slotvec0 = & qword_100 ; off_20C058 = & slot0 ; } @@result@@ = & slotvec0 ; if ( @@ptr@@ != ( void * * ) & slotvec0 ) { free ( @@ptr@@ ) ; @@result@@ = & slotvec0 ; slotvec = & slotvec0 ; } nslots = Number ; return @@result@@ ; }
_QWORD * __fastcall quoting_options_from_style ( _QWORD * @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v3@@ ; __int64 @@v4@@ ; __int64 @@v6@@ [ Number ] ; @@v6@@ [ Number ] = __readfsqword ( Number ) ; memset ( @@v6@@ , Number , Number ) ; @@v2@@ = @@v6@@ [ Number ] ; * @@a1@@ = @@a2@@ ; @@a1@@ [ Number ] = @@v2@@ ; @@v3@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v3@@ ; @@v4@@ = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; @@a1@@ [ Number ] = @@v4@@ ; @@a1@@ [ Number ] = @@v6@@ [ Number ] ; return @@a1@@ ; }
_BOOL8 __fastcall c_isalnum ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number || ( int ) ( @@a1@@ & Number ) > Number && ( int ) ( @@a1@@ & Number ) <= Number ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
__int64 __fastcall re_node_set_init_copy ( void * @@a1@@ , __int64 @@a2@@ ) { * ( ( _QWORD * ) @@a1@@ + Number ) = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) ) { * ( _QWORD * ) @@a1@@ = * ( ( _QWORD * ) @@a1@@ + Number ) ; * ( ( _QWORD * ) @@a1@@ + Number ) = malloc ( Number L * * ( _QWORD * ) @@a1@@ ) ; if ( ! * ( ( _QWORD * ) @@a1@@ + Number ) ) { * ( ( _QWORD * ) @@a1@@ + Number ) = Number L ; * ( _QWORD * ) @@a1@@ = * ( ( _QWORD * ) @@a1@@ + Number ) ; return Number L ; } memcpy ( * ( ( void * * ) @@a1@@ + Number ) , * ( const void * * ) ( @@a2@@ + Number ) , Number L * * ( _QWORD * ) ( @@a2@@ + Number ) ) ; } else { memset ( @@a1@@ , Number , Number ) ; } return Number L ; }
__int64 * __fastcall quotearg_n_style ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ ) { _QWORD @@v5@@ [ Number ] ; @@v5@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v5@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , Number , ( __int64 ) @@v5@@ ) ; }
_BOOL8 __fastcall c_isdigit ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ , @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 * __fastcall quotearg_n_options ( int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ , __int64 @@a4@@ ) { __int64 * * @@v4@@ ; __int64 * @@v5@@ ; bool @@v9@@ ; int @@v10@@ ; int @@v11@@ ; __int64 * * @@v12@@ ; __int64 * @@ptr@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v10@@ = * __errno_location ( ) ; @@v12@@ = slotvec ; if ( @@a1@@ < Number ) abort ( ) ; if ( @@a1@@ >= ( unsigned int ) nslots ) { @@v14@@ = ( unsigned int ) ( @@a1@@ + Number ) ; @@v9@@ = slotvec == & slotvec0 ; if ( slotvec == & slotvec0 ) @@v4@@ = Number L ; else @@v4@@ = slotvec ; @@v12@@ = ( __int64 * * ) xrealloc ( @@v4@@ , Number * @@v14@@ ) ; slotvec = @@v12@@ ; if ( @@v9@@ ) { @@v5@@ = ( __int64 * ) off_220028 ; * @@v12@@ = slotvec0 ; @@v12@@ [ Number ] = @@v5@@ ; } memset ( & @@v12@@ [ Number * ( unsigned int ) nslots ] , Number , Number * ( @@v14@@ - ( unsigned int ) nslots ) ) ; nslots = @@a1@@ + Number ; } @@v15@@ = ( unsigned __int64 ) @@v12@@ [ Number * @@a1@@ ] ; @@ptr@@ = @@v12@@ [ Number * @@a1@@ + Number ] ; @@v11@@ = * ( _DWORD * ) ( @@a4@@ + Number ) | Number ; @@v17@@ = quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v15@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; if ( @@v15@@ <= @@v17@@ ) { @@v16@@ = @@v17@@ + Number ; @@v12@@ [ Number * @@a1@@ ] = ( __int64 * ) ( @@v17@@ + Number ) ; if ( @@ptr@@ != ( __int64 * ) & slot0 ) free ( @@ptr@@ ) ; @@ptr@@ = ( __int64 * ) xcharalloc ( @@v16@@ ) ; @@v12@@ [ Number * @@a1@@ + Number ] = @@ptr@@ ; quotearg_buffer_restyled ( ( __int64 ) @@ptr@@ , @@v16@@ , @@a2@@ , @@a3@@ , * ( _DWORD * ) @@a4@@ , @@v11@@ , @@a4@@ + Number , * ( char * * ) ( @@a4@@ + Number ) , * ( char * * ) ( @@a4@@ + Number ) ) ; } * __errno_location ( ) = @@v10@@ ; return @@ptr@@ ; }
_BOOL8 __fastcall c_isgraph ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
__int64 * __fastcall quotearg_n_custom_mem ( int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , size_t @@a5@@ ) { __int64 @@v8@@ [ Number ] ; @@v8@@ [ Number ] = __readfsqword ( Number ) ; @@v8@@ [ Number ] = default_quoting_options ; @@v8@@ [ Number ] = qword_20C0E8 ; @@v8@@ [ Number ] = qword_20C0F0 ; @@v8@@ [ Number ] = qword_20C0F8 ; @@v8@@ [ Number ] = qword_20C100 ; @@v8@@ [ Number ] = qword_20C108 ; @@v8@@ [ Number ] = qword_20C110 ; set_custom_quoting ( @@v8@@ , @@a2@@ , @@a3@@ ) ; return quotearg_n_options ( @@a1@@ , @@a4@@ , @@a5@@ , ( __int64 ) @@v8@@ ) ; }
unsigned __int64 __fastcall re_node_set_contains ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { unsigned __int64 @@result@@ ; unsigned __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; if ( ( unsigned __int64 ) ( * ( _QWORD * ) ( @@a1@@ + Number ) - Number L ) > Number ) return Number L ; @@v3@@ = Number L ; @@v4@@ = * ( _QWORD * ) ( @@a1@@ + Number ) - Number L ; while ( @@v3@@ < @@v4@@ ) { if ( @@a2@@ <= * ( _QWORD * ) ( Number * ( ( @@v3@@ + @@v4@@ ) >> Number ) + * ( _QWORD * ) ( @@a1@@ + Number ) ) ) @@v4@@ = ( @@v3@@ + @@v4@@ ) >> Number ; else @@v3@@ = ( ( @@v3@@ + @@v4@@ ) >> Number ) + Number ; } if ( @@a2@@ == * ( _QWORD * ) ( Number * @@v3@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) ) @@result@@ = @@v3@@ + Number ; else @@result@@ = Number L ; return @@result@@ ; }
__int64 * __fastcall quotearg_style_mem ( unsigned int @@a1@@ , __int64 @@a2@@ , size_t @@a3@@ ) { return quotearg_n_style_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
_BOOL8 __fastcall c_isxdigit ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number || ( int ) ( @@a1@@ & Number ) > Number && ( int ) ( @@a1@@ & Number ) <= Number ; }
_QWORD * __fastcall bitset_clear ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { _QWORD * @@result@@ ; @@result@@ = ( _QWORD * ) ( Number * ( @@a2@@ >> Number ) + @@a1@@ ) ; * @@result@@ &= ~ ( Number L << ( @@a2@@ & Number ) ) ; return @@result@@ ; }
__int64 __fastcall x2nrealloc ( __int64 @@a1@@ , unsigned __int64 * @@a2@@ , unsigned __int64 @@a3@@ ) { unsigned __int64 @@v4@@ ; @@v4@@ = * @@a2@@ ; if ( @@a1@@ ) { if ( @@v4@@ >= Number / @@a3@@ ) xalloc_die ( ) ; @@v4@@ += ( @@v4@@ + Number ) >> Number ; } else if ( ! @@v4@@ ) { @@v4@@ = ( Number / @@a3@@ == Number ) + Number / @@a3@@ ; } * @@a2@@ = @@v4@@ ; return xrealloc ( @@a1@@ , @@a3@@ * @@v4@@ ) ; }
__int64 __fastcall register_state ( _QWORD * @@a1@@ , _QWORD * @@a2@@ , __int64 @@a3@@ ) { __int64 @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; unsigned __int64 @@i@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; void * @@v12@@ ; __int64 @@v13@@ ; * @@a2@@ = @@a3@@ ; if ( ( unsigned int ) re_node_set_alloc ( @@a2@@ + Number , @@a2@@ [ Number ] ) ) return Number L ; for ( @@i@@ = Number L ; @@i@@ < @@a2@@ [ Number ] ; ++ @@i@@ ) { @@v13@@ = * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ [ Number ] ) ; if ( ( * ( _BYTE * ) ( Number * @@v13@@ + * @@a1@@ + Number ) & Number ) == Number && ( unsigned __int8 ) re_node_set_insert_last ( ( __int64 ) ( @@a2@@ + Number ) , @@v13@@ ) != Number ) { return Number L ; } } @@v10@@ = @@a1@@ [ Number ] + Number * ( @@a3@@ & @@a1@@ [ Number ] ) ; if ( * ( _QWORD * ) ( @@v10@@ + Number ) <= * ( _QWORD * ) @@v10@@ ) { @@v4@@ = * ( _QWORD * ) @@v10@@ + Number L ; @@v11@@ = Number * @@v4@@ ; @@v12@@ = realloc ( * ( void * * ) ( @@v10@@ + Number ) , Number * @@v4@@ ) ; if ( ! @@v12@@ ) return Number L ; * ( _QWORD * ) ( @@v10@@ + Number ) = @@v12@@ ; * ( _QWORD * ) ( @@v10@@ + Number ) = @@v11@@ ; } @@v5@@ = * ( _QWORD * ) ( @@v10@@ + Number ) ; @@v6@@ = ( * ( _QWORD * ) @@v10@@ ) ++ ; * ( _QWORD * ) ( @@v5@@ + Number * @@v6@@ ) = @@a2@@ ; return Number L ; }
int unlink ( const char * @@name@@ ) { return unlink ( @@name@@ ) ; }
bool __fastcall is_basic_2 ( unsigned __int8 @@a1@@ ) { return ( ( * ( ( _DWORD * ) & is_basic_table + ( @@a1@@ >> Number ) ) >> ( @@a1@@ & Number ) ) & Number ) != Number ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
_QWORD * __fastcall bitset_mask ( __int64 @@a1@@ , __int64 @@a2@@ ) { _QWORD * @@result@@ ; int @@i@@ ; for ( @@i@@ = Number ; @@i@@ <= Number ; ++ @@i@@ ) { @@result@@ = ( _QWORD * ) ( Number L * @@i@@ + @@a1@@ ) ; * @@result@@ &= * ( _QWORD * ) ( Number L * @@i@@ + @@a2@@ ) ; } return @@result@@ ; }
void * __fastcall xcalloc ( size_t @@a1@@ , size_t @@a2@@ ) { void * @@v3@@ ; @@v3@@ = calloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@v3@@ ) xalloc_die ( ) ; return @@v3@@ ; }
int close ( int @@fd@@ ) { return close ( @@fd@@ ) ; }
int __fastcall fstat ( int @@fildes@@ , struct stat * @@stat_buf@@ ) { return __fxstat ( Number , @@fildes@@ , @@stat_buf@@ ) ; }
int iswalnum ( wint_t @@wc@@ ) { return iswalnum ( @@wc@@ ) ; }
wint_t towupper ( wint_t @@wc@@ ) { return towupper ( @@wc@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
__int64 __fastcall mb_copy ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; if ( * ( _QWORD * ) @@a2@@ == @@a2@@ + Number ) { memcpy ( ( void * ) ( @@a1@@ + Number ) , ( const void * ) ( @@a2@@ + Number ) , * ( _QWORD * ) ( @@a2@@ + Number ) ) ; * ( _QWORD * ) @@a1@@ = @@a1@@ + Number ; } else { * ( _QWORD * ) @@a1@@ = * ( _QWORD * ) @@a2@@ ; } * ( _QWORD * ) ( @@a1@@ + Number ) = * ( _QWORD * ) ( @@a2@@ + Number ) ; * ( _BYTE * ) ( @@a1@@ + Number ) = * ( _BYTE * ) ( @@a2@@ + Number ) ; @@result@@ = * ( unsigned __int8 * ) ( @@a1@@ + Number ) ; if ( ( _BYTE ) @@result@@ ) { @@result@@ = @@a1@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = * ( _DWORD * ) ( @@a2@@ + Number ) ; } return @@result@@ ; }
_BOOL8 __fastcall c_isascii ( int @@a1@@ ) { return @@a1@@ >= Number && @@a1@@ <= Number ; }
__int64 __fastcall re_string_realloc_buffers ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { void * @@v3@@ ; void * @@v4@@ ; void * @@v5@@ ; if ( * ( int * ) ( @@a1@@ + Number ) > Number ) { if ( ! is_mul_ok ( Number , @@a2@@ ) ) return Number L ; @@v3@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number * @@a2@@ ) ; if ( ! @@v3@@ ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v3@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) { @@v4@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number * @@a2@@ ) ; if ( ! @@v4@@ ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v4@@ ; } } if ( * ( _BYTE * ) ( @@a1@@ + Number ) ) { @@v5@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , @@a2@@ ) ; if ( ! @@v5@@ ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v5@@ ; } * ( _QWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; return Number L ; }
size_t __fastcall output ( char * @@a1@@ , __int64 @@a2@@ ) { size_t @@result@@ ; char * @@src@@ ; size_t @@v4@@ ; size_t @@n@@ ; @@src@@ = @@a1@@ ; @@v4@@ = @@a2@@ - ( _QWORD ) @@a1@@ ; @@n@@ = Number - bytes_in_buffer_5723 ; if ( @@a1@@ ) { while ( @@v4@@ >= @@n@@ ) { memcpy ( ( char * ) & buffer_5722 + bytes_in_buffer_5723 , @@src@@ , @@n@@ ) ; @@v4@@ -= @@n@@ ; @@src@@ += @@n@@ ; fwrite_unlocked ( & buffer_5722 , Number , Number , stdout ) ; bytes_in_buffer_5723 = Number L ; @@n@@ = Number ; } memcpy ( ( char * ) & buffer_5722 + bytes_in_buffer_5723 , @@src@@ , @@v4@@ ) ; @@result@@ = bytes_in_buffer_5723 + @@v4@@ ; bytes_in_buffer_5723 += @@v4@@ ; } else { @@result@@ = fwrite_unlocked ( & buffer_5722 , Number , bytes_in_buffer_5723 , stdout ) ; bytes_in_buffer_5723 = Number L ; } return @@result@@ ; }
void __fastcall free_dfa_content ( __int64 @@a1@@ ) { unsigned __int64 @@i@@ ; unsigned __int64 @@j@@ ; unsigned __int64 @@k@@ ; unsigned __int64 @@l@@ ; __int64 @@v5@@ ; if ( * ( _QWORD * ) @@a1@@ ) { for ( @@i@@ = Number L ; @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; ++ @@i@@ ) free_token ( Number * @@i@@ + * ( _QWORD * ) @@a1@@ ) ; } free ( * ( void * * ) ( @@a1@@ + Number ) ) ; for ( @@j@@ = Number L ; @@j@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; ++ @@j@@ ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) free ( * ( void * * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@j@@ + Number ) ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) free ( * ( void * * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@j@@ + Number ) ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) free ( * ( void * * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@j@@ + Number ) ) ; } free ( * ( void * * ) ( @@a1@@ + Number ) ) ; free ( * ( void * * ) ( @@a1@@ + Number ) ) ; free ( * ( void * * ) ( @@a1@@ + Number ) ) ; free ( * ( void * * ) @@a1@@ ) ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) { for ( @@k@@ = Number L ; @@k@@ <= * ( _QWORD * ) ( @@a1@@ + Number ) ; ++ @@k@@ ) { @@v5@@ = * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@k@@ ; for ( @@l@@ = Number L ; @@l@@ < * ( _QWORD * ) @@v5@@ ; ++ @@l@@ ) free_state ( * ( void * * * ) ( Number * @@l@@ + * ( _QWORD * ) ( @@v5@@ + Number ) ) ) ; free ( * ( void * * ) ( @@v5@@ + Number ) ) ; } } free ( * ( void * * ) ( @@a1@@ + Number ) ) ; if ( * ( _UNKNOWN * * ) ( @@a1@@ + Number ) != & utf8_sb_map ) free ( * ( void * * ) ( @@a1@@ + Number ) ) ; free ( * ( void * * ) ( @@a1@@ + Number ) ) ; free ( ( void * ) @@a1@@ ) ; }
_BOOL8 __fastcall c_isalpha ( int @@a1@@ ) { return ( int ) ( @@a1@@ & Number ) > Number && ( int ) ( @@a1@@ & Number ) <= Number ; }
char * __fastcall set_program_name ( const char * @@a1@@ ) { char * @@v1@@ ; char * @@result@@ ; char * @@s@@ ; char * @@v4@@ ; char * @@s1@@ ; @@s@@ = ( char * ) @@a1@@ ; if ( ! @@a1@@ ) { fwrite ( String , Number , Number , stderr ) ; abort ( ) ; } @@v4@@ = strrchr ( @@a1@@ , Number ) ; if ( @@v4@@ ) @@v1@@ = @@v4@@ + Number ; else @@v1@@ = ( char * ) @@a1@@ ; @@s1@@ = @@v1@@ ; if ( @@v1@@ - @@a1@@ > Number && ! strncmp ( @@v1@@ - Number , String , Number ) ) { @@s@@ = @@s1@@ ; if ( ! strncmp ( @@s1@@ , String , Number ) ) { @@s@@ = @@s1@@ + Number ; program_invocation_short_name = ( __int64 ) ( @@s1@@ + Number ) ; } } program_name = ( __int64 ) @@s@@ ; @@result@@ = @@s@@ ; program_invocation_name = ( __int64 ) @@s@@ ; return @@result@@ ; }
__int64 __fastcall re_string_peek_byte_case ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; __int64 @@v3@@ ; if ( ! * ( _BYTE * ) ( @@a1@@ + Number ) ) return * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ ) ; if ( * ( int * ) ( @@a1@@ + Number ) > Number && ( * ( _DWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ ) ) == Number || * ( _QWORD * ) ( @@a1@@ + Number ) != * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ + Number && * ( _DWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ + Number ) ) == Number ) ) { return * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ ) ; } @@v3@@ = * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ ; if ( * ( _BYTE * ) ( @@a1@@ + Number ) ) @@v3@@ = * ( _QWORD * ) ( Number * @@v3@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) ; if ( * ( _BYTE * ) ( @@a1@@ + Number ) && ( * ( _BYTE * ) ( * ( _QWORD * ) @@a1@@ + * ( _QWORD * ) ( @@a1@@ + Number ) + @@v3@@ ) & Number ) != Number ) { @@result@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ ) ; } else { @@result@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) @@a1@@ + * ( _QWORD * ) ( @@a1@@ + Number ) + @@v3@@ ) ; } return @@result@@ ; }
_BOOL8 __fastcall c_isupper ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
__int64 __fastcall mkstemp_safer ( char * @@a1@@ ) { unsigned int @@v1@@ ; @@v1@@ = mkstemp ( @@a1@@ ) ; return fd_safer ( @@v1@@ ) ; }
__int64 __fastcall lower_subexps ( __int64 @@a1@@ , __int64 @@a2@@ ) { unsigned int @@v3@@ ; __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; @@v5@@ = __readfsqword ( Number ) ; @@v4@@ = @@a1@@ ; @@v3@@ = Number ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) ) { if ( * ( _BYTE * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) == Number ) { * ( _QWORD * ) ( @@a2@@ + Number ) = lower_subexp ( & @@v3@@ , @@v4@@ , * ( _QWORD * ) ( @@a2@@ + Number ) ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) ) * * ( _QWORD * * ) ( @@a2@@ + Number ) = @@a2@@ ; } } if ( * ( _QWORD * ) ( @@a2@@ + Number ) ) { if ( * ( _BYTE * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) == Number ) { * ( _QWORD * ) ( @@a2@@ + Number ) = lower_subexp ( & @@v3@@ , @@v4@@ , * ( _QWORD * ) ( @@a2@@ + Number ) ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) ) * * ( _QWORD * * ) ( @@a2@@ + Number ) = @@a2@@ ; } } return @@v3@@ ; }
__int64 __fastcall re_node_set_init_1 ( _QWORD * @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; * @@a1@@ = Number L ; @@a1@@ [ Number ] = Number L ; @@a1@@ [ Number ] = malloc ( Number ) ; if ( @@a1@@ [ Number ] ) { * ( _QWORD * ) @@a1@@ [ Number ] = @@a2@@ ; @@result@@ = Number L ; } else { @@a1@@ [ Number ] = Number L ; * @@a1@@ = @@a1@@ [ Number ] ; @@result@@ = Number L ; } return @@result@@ ; }
void __fastcall freea ( unsigned __int64 @@a1@@ ) { _QWORD * @@i@@ ; if ( @@a1@@ && * ( _DWORD * ) ( @@a1@@ - Number ) == Number ) { for ( @@i@@ = & mmalloca_results [ @@a1@@ % Number ] ; * @@i@@ ; @@i@@ = ( _QWORD * ) ( * @@i@@ - Number L ) ) { if ( @@a1@@ == * @@i@@ ) { * @@i@@ = * ( _QWORD * ) ( @@a1@@ - Number ) ; free ( ( void * ) ( @@a1@@ - Number ) ) ; return ; } } } }
__int64 __fastcall set_char_quoting ( __int64 * @@a1@@ , unsigned __int8 @@a2@@ , char @@a3@@ ) { __int64 * @@v3@@ ; unsigned int @@v5@@ ; if ( @@a1@@ ) @@v3@@ = @@a1@@ ; else @@v3@@ = & default_quoting_options ; @@v5@@ = ( * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) >> ( @@a2@@ & Number ) ) & Number ; * ( ( _DWORD * ) @@v3@@ + ( @@a2@@ >> Number ) + Number ) ^= ( @@v5@@ ^ @@a3@@ & Number ) << ( @@a2@@ & Number ) ; return @@v5@@ ; }
__int64 __fastcall calc_state_hash ( __int64 @@a1@@ , unsigned int @@a2@@ ) { __int64 @@v3@@ ; unsigned __int64 @@i@@ ; @@v3@@ = * ( _QWORD * ) ( @@a1@@ + Number ) + @@a2@@ ; for ( @@i@@ = Number L ; @@i@@ < * ( _QWORD * ) ( @@a1@@ + Number ) ; ++ @@i@@ ) @@v3@@ += * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) ; return @@v3@@ ; }
__int64 __fastcall link_nfa_nodes ( __int64 @@a1@@ , __int64 @@a2@@ ) { __int64 @@result@@ ; unsigned int @@v3@@ ; unsigned __int64 @@v4@@ ; unsigned __int64 @@v5@@ ; __int64 @@v6@@ ; @@v6@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@v3@@ = Number ; switch ( * ( _BYTE * ) ( @@a2@@ + Number ) ) { case Number : if ( * ( _QWORD * ) ( @@a2@@ + Number ) ) __assert_fail ( String , String , Number , String ) ; return @@result@@ ; case Number : * ( _QWORD * ) ( Number * @@v6@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) ; if ( * ( _BYTE * ) ( @@a2@@ + Number ) == Number ) re_node_set_init_1 ( ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@v6@@ ) , * ( _QWORD * ) ( Number * @@v6@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) ) ; break ; case Number : case Number : case Number : @@v3@@ = re_node_set_init_1 ( ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@v6@@ ) , * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) ) ; break ; case Number : case Number : * ( _BYTE * ) ( @@a1@@ + Number ) |= Number ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) ) @@v4@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) + Number L ) ; else @@v4@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) ) @@v5@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) + Number L ) ; else @@v5@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) ; if ( @@v4@@ > Number ) __assert_fail ( String , String , Number , String ) ; if ( @@v5@@ > Number ) __assert_fail ( String , String , Number , String ) ; @@v3@@ = re_node_set_init_2 ( ( _QWORD * ) ( Number * @@v6@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) , @@v4@@ , @@v5@@ ) ; break ; case Number : return @@v3@@ ; default : if ( ( * ( _BYTE * ) ( @@a2@@ + Number ) & Number ) != Number ) __assert_fail ( String , String , Number , String ) ; * ( _QWORD * ) ( Number * @@v6@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) ; break ; } return @@v3@@ ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
char * __fastcall rpl_re_compile_pattern ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { char * @@result@@ ; int @@v4@@ ; * ( _BYTE * ) ( @@a3@@ + Number ) = ( Number * ( ( rpl_re_syntax_options & Number ) != Number ) ) | * ( _BYTE * ) ( @@a3@@ + Number ) & Number ; * ( _BYTE * ) ( @@a3@@ + Number ) |= Number ; @@v4@@ = re_compile_internal ( @@a3@@ , @@a1@@ , @@a2@@ , rpl_re_syntax_options ) ; if ( @@v4@@ ) @@result@@ = gettext ( & _re_error_msgid [ _re_error_msgid_idx [ @@v4@@ ] ] ) ; else @@result@@ = Number L ; return @@result@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 __fastcall parse ( __int64 @@a1@@ , __int64 * @@a2@@ , __int64 @@a3@@ , _DWORD * @@a4@@ ) { __int64 @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; char @@v11@@ [ Number ] ; unsigned __int64 @@v12@@ ; @@v12@@ = __readfsqword ( Number ) ; @@v8@@ = * @@a2@@ ; * ( _QWORD * ) ( * @@a2@@ + Number ) = @@a3@@ ; fetch_token ( ( __int64 ) @@v11@@ , @@a1@@ , @@a3@@ | Number ) ; @@v9@@ = parse_reg_exp ( @@a1@@ , @@a2@@ , @@v11@@ , @@a3@@ , Number L , @@a4@@ ) ; if ( * @@a4@@ && ! @@v9@@ ) return Number L ; @@v10@@ = create_tree ( @@v8@@ , Number L , Number L , Number L ) ; if ( @@v9@@ ) @@v7@@ = create_tree ( @@v8@@ , @@v9@@ , @@v10@@ , Number L ) ; else @@v7@@ = @@v10@@ ; if ( @@v10@@ && @@v7@@ ) return @@v7@@ ; * @@a4@@ = Number ; return Number L ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_222288 ; @@v4@@ [ Number ] = qword_222290 ; @@v4@@ [ Number ] = qword_222298 ; @@v4@@ [ Number ] = qword_2222A0 ; @@v4@@ [ Number ] = qword_2222A8 ; @@v4@@ [ Number ] = qword_2222B0 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
__int64 __fastcall rpl_re_compile_fastmap ( __int64 @@a1@@ ) { _QWORD * @@v2@@ ; void * @@s@@ ; @@v2@@ = * ( _QWORD * * ) @@a1@@ ; @@s@@ = * ( void * * ) ( @@a1@@ + Number ) ; memset ( @@s@@ , Number , Number ) ; re_compile_fastmap_iter ( @@a1@@ , @@v2@@ [ Number ] , @@s@@ ) ; if ( @@v2@@ [ Number ] != @@v2@@ [ Number ] ) re_compile_fastmap_iter ( @@a1@@ , @@v2@@ [ Number ] , @@s@@ ) ; if ( @@v2@@ [ Number ] != @@v2@@ [ Number ] ) re_compile_fastmap_iter ( @@a1@@ , @@v2@@ [ Number ] , @@s@@ ) ; if ( @@v2@@ [ Number ] != @@v2@@ [ Number ] ) re_compile_fastmap_iter ( @@a1@@ , @@v2@@ [ Number ] , @@s@@ ) ; * ( _BYTE * ) ( @@a1@@ + Number ) |= Number ; return Number L ; }
__int64 __fastcall build_collating_symbol ( __int64 @@a1@@ , __int64 a2 , __int64 a3 , const char * @@a4@@ ) { if ( strlen ( @@a4@@ ) != Number ) return Number L ; bitset_set ( @@a1@@ , * ( unsigned __int8 * ) @@a4@@ ) ; return Number L ; }
_QWORD * __fastcall bitset_set ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { _QWORD * @@result@@ ; @@result@@ = ( _QWORD * ) ( Number * ( @@a2@@ >> Number ) + @@a1@@ ) ; * @@result@@ |= Number L << ( @@a2@@ & Number ) ; return @@result@@ ; }
void * __fastcall bitset_set_all ( void * @@a1@@ ) { return memset ( @@a1@@ , Number , Number ) ; }
__int64 __fastcall init_word_char ( __int64 @@a1@@ ) { __int64 @@result@@ ; int @@v2@@ ; int @@i@@ ; int @@v4@@ ; @@result@@ = @@a1@@ ; * ( _BYTE * ) ( @@a1@@ + Number ) |= Number ; @@v2@@ = Number ; @@v4@@ = Number ; while ( @@v2@@ <= Number ) { for ( @@i@@ = Number ; @@i@@ <= Number ; ++ @@i@@ ) { @@result@@ = ( * __ctype_b_loc ( ) ) [ @@v4@@ ] & Number ; if ( ( _DWORD ) @@result@@ || @@v4@@ == Number ) { @@result@@ = @@a1@@ ; * ( _QWORD * ) ( @@a1@@ + Number * ( @@v2@@ + Number L ) + Number ) |= Number L << @@i@@ ; } ++ @@v4@@ ; } ++ @@v2@@ ; } return @@result@@ ; }
_QWORD * __fastcall bitset_merge ( __int64 @@a1@@ , __int64 @@a2@@ ) { _QWORD * @@result@@ ; int @@i@@ ; for ( @@i@@ = Number ; @@i@@ <= Number ; ++ @@i@@ ) { @@result@@ = ( _QWORD * ) ( Number L * @@i@@ + @@a1@@ ) ; * @@result@@ |= * ( _QWORD * ) ( Number L * @@i@@ + @@a2@@ ) ; } return @@result@@ ; }
__int64 __fastcall build_charclass_op ( __int64 @@a1@@ , __int64 @@a2@@ , const char * @@a3@@ , _BYTE * @@a4@@ , char @@a5@@ , _DWORD * @@a6@@ ) { int @@v11@@ ; __int64 @@v12@@ ; void * @@ptr@@ ; _BYTE * @@v14@@ ; __int64 @@v15@@ ; __int64 @@v16@@ ; void * @@v17@@ ; char @@v18@@ ; unsigned __int64 @@v19@@ ; @@v19@@ = __readfsqword ( Number ) ; @@v12@@ = Number L ; @@ptr@@ = calloc ( Number , Number ) ; @@v14@@ = calloc ( Number , Number ) ; if ( ! @@ptr@@ || ! @@v14@@ ) { * @@a6@@ = Number ; return Number L ; } if ( @@a5@@ ) @@v14@@ [ Number ] |= Number ; @@v11@@ = build_charclass ( @@a2@@ , ( __int64 ) @@ptr@@ , ( __int64 ) @@v14@@ , & @@v12@@ , @@a3@@ , Number ) ; if ( @@v11@@ ) { free ( @@ptr@@ ) ; free_charset ( @@v14@@ ) ; * @@a6@@ = @@v11@@ ; return Number L ; } while ( * @@a4@@ ) bitset_set ( ( __int64 ) @@ptr@@ , ( unsigned __int8 ) * @@a4@@ ++ ) ; if ( @@a5@@ ) bitset_not ( ( __int64 ) @@ptr@@ ) ; if ( * ( int * ) ( @@a1@@ + Number ) > Number ) bitset_mask ( ( __int64 ) @@ptr@@ , * ( _QWORD * ) ( @@a1@@ + Number ) ) ; @@v18@@ = Number ; @@v17@@ = @@ptr@@ ; @@v15@@ = create_token_tree ( @@a1@@ , Number L , Number L , & @@v17@@ ) ; if ( @@v15@@ ) { if ( * ( int * ) ( @@a1@@ + Number ) <= Number ) { free_charset ( @@v14@@ ) ; return @@v15@@ ; } @@v18@@ = Number ; @@v17@@ = @@v14@@ ; * ( _BYTE * ) ( @@a1@@ + Number ) |= Number ; @@v16@@ = create_token_tree ( @@a1@@ , Number L , Number L , & @@v17@@ ) ; if ( @@v16@@ ) { @@v15@@ = create_tree ( @@a1@@ , @@v15@@ , @@v16@@ , Number L ) ; if ( @@v16@@ ) return @@v15@@ ; } } free ( @@ptr@@ ) ; free_charset ( @@v14@@ ) ; * @@a6@@ = Number ; return Number L ; }
__int64 __fastcall re_string_construct ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ , __int64 @@a4@@ , unsigned __int8 @@a5@@ , __int64 @@a6@@ ) { __int64 @@v7@@ ; unsigned int @@v12@@ ; unsigned int @@v13@@ ; unsigned int @@v14@@ ; memset ( ( void * ) @@a1@@ , Number , Number ) ; re_string_construct_common ( @@a2@@ , @@a3@@ , @@a1@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( @@a3@@ ) { @@v12@@ = re_string_realloc_buffers ( @@a1@@ , @@a3@@ + Number ) ; if ( @@v12@@ ) return @@v12@@ ; } if ( * ( _BYTE * ) ( @@a1@@ + Number ) ) @@v7@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; else @@v7@@ = @@a2@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v7@@ ; if ( ! @@a5@@ ) { if ( * ( int * ) ( @@a6@@ + Number ) <= Number ) { if ( @@a4@@ ) { re_string_translate_buffer ( @@a1@@ ) ; } else { * ( _QWORD * ) ( @@a1@@ + Number ) = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = * ( _QWORD * ) ( @@a1@@ + Number ) ; } } else { build_wcs_buffer ( @@a1@@ ) ; } return Number L ; } if ( * ( int * ) ( @@a6@@ + Number ) <= Number ) { build_upper_buffer ( @@a1@@ ) ; return Number L ; } do { @@v13@@ = build_wcs_upper_buffer ( @@a1@@ ) ; if ( @@v13@@ ) return @@v13@@ ; if ( @@a3@@ <= * ( _QWORD * ) ( @@a1@@ + Number ) || * ( _QWORD * ) ( @@a1@@ + Number ) > ( unsigned __int64 ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + * ( int * ) ( @@a6@@ + Number ) ) ) { return Number L ; } @@v14@@ = re_string_realloc_buffers ( @@a1@@ , Number L * * ( _QWORD * ) ( @@a1@@ + Number ) ) ; } while ( ! @@v14@@ ) ; return @@v14@@ ; }
__int64 __fastcall lower_subexp ( _DWORD * @@a1@@ , __int64 * @@a2@@ , __int64 @@a3@@ ) { __int64 @@result@@ ; __int64 @@v4@@ ; _BOOL4 @@v5@@ ; _BOOL4 @@v6@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; __int64 @@v12@@ ; __int64 @@v13@@ ; @@v8@@ = * @@a2@@ ; @@v9@@ = * ( _QWORD * ) ( @@a3@@ + Number ) ; if ( ( @@a2@@ [ Number ] & Number ) != Number && * ( _QWORD * ) ( @@a3@@ + Number ) && ( * ( _QWORD * ) ( @@a3@@ + Number ) > Number || ( ( * ( _QWORD * ) ( @@v8@@ + Number ) >> * ( _QWORD * ) ( @@a3@@ + Number ) ) & Number L ) == Number ) ) { return * ( _QWORD * ) ( @@a3@@ + Number ) ; } @@v10@@ = create_tree ( @@v8@@ , Number L , Number L , Number L ) ; @@v11@@ = create_tree ( @@v8@@ , Number L , Number L , Number L ) ; if ( @@v9@@ ) @@v4@@ = create_tree ( @@v8@@ , @@v9@@ , @@v11@@ , Number L ) ; else @@v4@@ = @@v11@@ ; @@v12@@ = @@v4@@ ; @@v13@@ = create_tree ( @@v8@@ , @@v10@@ , @@v4@@ , Number L ) ; @@v5@@ = ! @@v13@@ || ! @@v12@@ ; @@v6@@ = @@v5@@ || ! @@v10@@ ; if ( ! @@v6@@ && @@v11@@ ) { * ( _QWORD * ) ( @@v11@@ + Number ) = * ( _QWORD * ) ( @@a3@@ + Number ) ; * ( _QWORD * ) ( @@v10@@ + Number ) = * ( _QWORD * ) ( @@v11@@ + Number ) ; * ( _BYTE * ) ( @@v11@@ + Number ) = ( Number * ( ( * ( _BYTE * ) ( @@a3@@ + Number ) & Number ) != Number ) ) | * ( _BYTE * ) ( @@v11@@ + Number ) & Number ; * ( _BYTE * ) ( @@v10@@ + Number ) = ( Number * ( ( * ( _BYTE * ) ( @@v11@@ + Number ) & Number ) != Number ) ) | * ( _BYTE * ) ( @@v10@@ + Number ) & Number ; @@result@@ = @@v13@@ ; } else { * @@a1@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall re_string_fetch_byte_case ( __int64 @@a1@@ ) { __int64 @@v1@@ ; __int64 @@v2@@ ; __int64 @@result@@ ; __int64 @@v4@@ ; __int64 @@v5@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; unsigned int @@v13@@ ; if ( * ( _BYTE * ) ( @@a1@@ + Number ) ) { if ( * ( _BYTE * ) ( @@a1@@ + Number ) ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) == * ( _QWORD * ) ( @@a1@@ + Number ) || * ( _DWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L * * ( _QWORD * ) ( @@a1@@ + Number ) ) != Number ) { @@v13@@ = * ( unsigned __int8 * ) ( * ( _QWORD * ) @@a1@@ + * ( _QWORD * ) ( @@a1@@ + Number ) + * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L * * ( _QWORD * ) ( @@a1@@ + Number ) ) ) ; if ( ( @@v13@@ & Number ) != Number ) { @@v6@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v7@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v7@@ + Number ; @@result@@ = * ( unsigned __int8 * ) ( @@v6@@ + @@v7@@ ) ; } else { @@v8@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v8@@ + ( int ) re_string_char_size_at ( @@a1@@ , @@v8@@ ) ; @@result@@ = @@v13@@ ; } } else { @@v4@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v5@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v5@@ + Number ; @@result@@ = * ( unsigned __int8 * ) ( @@v4@@ + @@v5@@ ) ; } } else { @@v9@@ = * ( _QWORD * ) @@a1@@ ; @@v10@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v11@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v11@@ + Number ; @@result@@ = * ( unsigned __int8 * ) ( @@v9@@ + @@v10@@ + @@v11@@ ) ; } } else { @@v1@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v2@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v2@@ + Number ; @@result@@ = * ( unsigned __int8 * ) ( @@v1@@ + @@v2@@ ) ; } return @@result@@ ; }
__int64 __fastcall rpl_re_search ( int @@a1@@ , int @@a2@@ , int @@a3@@ , int @@a4@@ , int @@a5@@ , __int64 @@a6@@ ) { return re_search_stub ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a3@@ , @@a6@@ , Number ) ; }
__int64 __fastcall duplicate_node ( _QWORD * @@a1@@ , __int64 @@a2@@ , __int16 @@a3@@ ) { __int64 @@v5@@ ; @@v5@@ = re_dfa_add_node ( ( __int64 ) @@a1@@ , * ( _QWORD * ) ( Number * @@a2@@ + * @@a1@@ ) , * ( _QWORD * ) ( Number * @@a2@@ + * @@a1@@ + Number ) ) ; if ( @@v5@@ != Number ) { * ( _DWORD * ) ( * @@a1@@ + Number * @@v5@@ + Number ) = ( ( @@a3@@ & Number ) << Number ) | * ( _DWORD * ) ( * @@a1@@ + Number * @@v5@@ + Number ) & Number ; * ( _DWORD * ) ( Number * @@v5@@ + * @@a1@@ + Number ) = ( ( ( ( * ( _DWORD * ) ( Number * @@a2@@ + * @@a1@@ + Number ) >> Number ) & Number | ( * ( _DWORD * ) ( Number * @@v5@@ + * @@a1@@ + Number ) >> Number ) & Number ) & Number ) << Number ) | * ( _DWORD * ) ( Number * @@v5@@ + * @@a1@@ + Number ) & Number ; * ( _BYTE * ) ( Number * @@v5@@ + * @@a1@@ + Number ) |= Number ; * ( _QWORD * ) ( @@a1@@ [ Number ] + Number * @@v5@@ ) = @@a2@@ ; } return @@v5@@ ; }
__int64 __fastcall rpl_re_search_2 ( int @@a1@@ , int @@a2@@ , int @@a3@@ , int @@a4@@ , int @@a5@@ , int @@a6@@ , __int64 @@a7@@ , __int64 @@a8@@ , __int64 @@a9@@ ) { return re_search_2_stub ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ , @@a7@@ , @@a8@@ , @@a9@@ , Number ) ; }
__int64 __fastcall parse_sub_exp ( __int64 @@a1@@ , __int64 * @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , _DWORD * @@a6@@ ) { unsigned __int64 @@v6@@ ; __int64 @@result@@ ; __int64 @@v12@@ ; __int64 @@v13@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; @@v14@@ = * @@a2@@ ; @@v6@@ = @@a2@@ [ Number ] ; @@a2@@ [ Number ] = @@v6@@ + Number ; @@v15@@ = @@v6@@ ; fetch_token ( @@a3@@ , @@a1@@ , @@a4@@ | Number ) ; if ( * ( _BYTE * ) ( @@a3@@ + Number ) == Number ) { @@v12@@ = Number L ; } else { @@v12@@ = parse_reg_exp ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( ! * @@a6@@ && * ( _BYTE * ) ( @@a3@@ + Number ) != Number ) * @@a6@@ = Number ; if ( * @@a6@@ ) return Number L ; } if ( @@v15@@ <= Number ) * ( _QWORD * ) ( @@v14@@ + Number ) |= Number << @@v15@@ ; @@v13@@ = create_tree ( @@v14@@ , @@v12@@ , Number L , Number L ) ; if ( @@v13@@ ) { * ( _QWORD * ) ( @@v13@@ + Number ) = @@v15@@ ; @@result@@ = @@v13@@ ; } else { * @@a6@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
_BOOL8 __fastcall check_halt_node_context ( _QWORD * @@a1@@ , __int64 @@a2@@ , char @@a3@@ ) { if ( * ( _BYTE * ) ( Number * @@a2@@ + * @@a1@@ + Number ) != Number ) return Number L ; if ( ( ( * ( _DWORD * ) ( Number * @@a2@@ + * @@a1@@ + Number ) >> Number ) & Number ) == Number ) return Number L ; return ( ( * ( _DWORD * ) ( Number * @@a2@@ + * @@a1@@ + Number ) & Number ) == Number || ( @@a3@@ & Number ) != Number ) && ( ( * ( _DWORD * ) ( Number * @@a2@@ + * @@a1@@ + Number ) & Number ) == Number || ( @@a3@@ & Number ) == Number ) && ( ( * ( _DWORD * ) ( Number * @@a2@@ + * @@a1@@ + Number ) & Number ) == Number || ( @@a3@@ & Number ) != Number ) && ( ( * ( _DWORD * ) ( Number * @@a2@@ + * @@a1@@ + Number ) & Number ) == Number || ( @@a3@@ & Number ) != Number ) ; }
bool __fastcall re_node_set_insert ( __int64 @@a1@@ , unsigned __int64 @@a2@@ ) { __int64 @@i@@ ; void * @@v4@@ ; if ( ! * ( _QWORD * ) @@a1@@ ) return ( unsigned int ) re_node_set_init_1 ( ( _QWORD * ) @@a1@@ , @@a2@@ ) == Number ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) { * * ( _QWORD * * ) ( @@a1@@ + Number ) = @@a2@@ ; ++ * ( _QWORD * ) ( @@a1@@ + Number ) ; return Number ; } if ( * ( _QWORD * ) @@a1@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ) { * ( _QWORD * ) @@a1@@ *= Number L ; @@v4@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number L * * ( _QWORD * ) @@a1@@ ) ; if ( ! @@v4@@ ) return Number ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v4@@ ; } if ( @@a2@@ >= * * ( _QWORD * * ) ( @@a1@@ + Number ) ) { for ( @@i@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@a2@@ < * ( _QWORD * ) ( Number * @@i@@ - Number + * ( _QWORD * ) ( @@a1@@ + Number ) ) ; -- @@i@@ ) { * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@i@@ ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@i@@ - Number ) ; } } else { for ( @@i@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@i@@ ; -- @@i@@ ) * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@i@@ ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@i@@ - Number ) ; } * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@i@@ ) = @@a2@@ ; ++ * ( _QWORD * ) ( @@a1@@ + Number ) ; return Number ; }
__int64 __fastcall create_tree ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , char @@a4@@ ) { char @@v5@@ [ Number ] ; unsigned __int64 @@v6@@ ; @@v6@@ = __readfsqword ( Number ) ; @@v5@@ [ Number ] = @@a4@@ ; return create_token_tree ( @@a1@@ , @@a2@@ , @@a3@@ , @@v5@@ ) ; }
__int64 __fastcall free_fail_stack_return ( __int64 @@a1@@ ) { unsigned __int64 @@i@@ ; if ( @@a1@@ ) { for ( @@i@@ = Number L ; @@i@@ < * ( _QWORD * ) @@a1@@ ; ++ @@i@@ ) { free ( * ( void * * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@i@@ + Number ) ) ; free ( * ( void * * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@i@@ + Number ) ) ; } free ( * ( void * * ) ( @@a1@@ + Number ) ) ; } return Number L ; }
__int64 __fastcall rpl_re_match ( int @@a1@@ , int @@a2@@ , int @@a3@@ , int @@a4@@ , __int64 @@a5@@ ) { return re_search_stub ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , Number , @@a3@@ , @@a5@@ , Number ) ; }
_QWORD * __fastcall re_acquire_state ( _DWORD * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { _QWORD * @@result@@ ; unsigned __int64 @@i@@ ; __int64 @@v6@@ ; unsigned __int64 * @@v7@@ ; __int64 @@v8@@ ; _QWORD * @@v9@@ ; if ( * ( _QWORD * ) ( @@a3@@ + Number ) ) { @@v6@@ = calc_state_hash ( @@a3@@ , Number ) ; @@v7@@ = ( unsigned __int64 * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number * ( @@v6@@ & * ( _QWORD * ) ( @@a2@@ + Number ) ) ) ; for ( @@i@@ = Number L ; @@i@@ < * @@v7@@ ; ++ @@i@@ ) { @@v9@@ = * ( _QWORD * * ) ( Number * @@i@@ + @@v7@@ [ Number ] ) ; if ( @@v6@@ == * @@v9@@ && ( unsigned __int8 ) re_node_set_compare ( ( __int64 ) ( @@v9@@ + Number ) , @@a3@@ ) ) { return @@v9@@ ; } } @@v8@@ = create_ci_newstate ( @@a2@@ , @@a3@@ , @@v6@@ ) ; if ( ! @@v8@@ ) * @@a1@@ = Number ; @@result@@ = ( _QWORD * ) @@v8@@ ; } else { * @@a1@@ = Number ; @@result@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall rpl_re_set_syntax ( __int64 @@a1@@ ) { __int64 @@v2@@ ; @@v2@@ = rpl_re_syntax_options ; rpl_re_syntax_options = @@a1@@ ; return @@v2@@ ; }
__int64 __fastcall re_search_2_stub ( int @@a1@@ , const void * @@a2@@ , size_t @@a3@@ , const void * @@a4@@ , size_t @@a5@@ , int @@a6@@ , __int64 @@a7@@ , __int64 @@a8@@ , __int64 @@a9@@ , unsigned __int8 @@a10@@ ) { __int64 @@v11@@ ; char * @@dest@@ ; size_t @@size@@ ; __int64 @@v18@@ ; @@size@@ = @@a3@@ + @@a5@@ ; @@dest@@ = Number L ; if ( @@a3@@ + @@a5@@ < @@a3@@ ) return Number ; if ( @@a5@@ ) { if ( @@a3@@ ) { @@dest@@ = ( char * ) malloc ( @@size@@ ) ; if ( ! @@dest@@ ) return Number ; memcpy ( @@dest@@ , @@a2@@ , @@a3@@ ) ; memcpy ( & @@dest@@ [ @@a3@@ ] , @@a4@@ , @@a5@@ ) ; @@v11@@ = re_search_stub ( @@a1@@ , ( _DWORD ) @@dest@@ , @@size@@ , @@a6@@ , @@a7@@ , @@a9@@ , @@a8@@ , @@a10@@ ) ; } else { @@v11@@ = re_search_stub ( @@a1@@ , ( _DWORD ) @@a4@@ , @@size@@ , @@a6@@ , @@a7@@ , @@a9@@ , @@a8@@ , @@a10@@ ) ; } } else { @@v11@@ = re_search_stub ( @@a1@@ , ( _DWORD ) @@a2@@ , @@size@@ , @@a6@@ , @@a7@@ , @@a9@@ , @@a8@@ , @@a10@@ ) ; } @@v18@@ = @@v11@@ ; free ( @@dest@@ ) ; return @@v18@@ ; }
_QWORD * __fastcall update_regs ( _QWORD * @@a1@@ , _QWORD * @@a2@@ , void * @@a3@@ , __int64 @@a4@@ , _QWORD * @@a5@@ , unsigned __int64 @@a6@@ ) { _QWORD * @@result@@ ; int @@v7@@ ; unsigned __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; @@result@@ = ( _QWORD * ) * ( unsigned __int8 * ) ( Number * @@a4@@ + * @@a1@@ + Number ) ; @@v7@@ = * ( unsigned __int8 * ) ( Number * @@a4@@ + * @@a1@@ + Number ) ; if ( @@v7@@ == Number ) { @@v9@@ = * ( _QWORD * ) ( Number * @@a4@@ + * @@a1@@ ) + Number L ; @@result@@ = ( _QWORD * ) @@v9@@ ; if ( @@v9@@ < @@a6@@ ) { @@a2@@ [ Number * @@v9@@ ] = @@a5@@ ; @@result@@ = & @@a2@@ [ Number * @@v9@@ ] ; @@result@@ [ Number ] = Number ; } } else if ( @@v7@@ == Number ) { @@v8@@ = * ( _QWORD * ) ( Number * @@a4@@ + * @@a1@@ ) + Number L ; @@result@@ = ( _QWORD * ) @@v8@@ ; if ( @@v8@@ < @@a6@@ ) { if ( ( unsigned __int64 ) @@a5@@ <= @@a2@@ [ Number * @@v8@@ ] ) { if ( ( * ( _BYTE * ) ( Number * @@a4@@ + * @@a1@@ + Number ) & Number ) == Number || * ( ( _QWORD * ) @@a3@@ + Number * @@v8@@ ) == Number ) { @@result@@ = @@a5@@ ; @@a2@@ [ Number * @@v8@@ + Number ] = @@a5@@ ; } else { @@result@@ = memcpy ( @@a2@@ , @@a3@@ , Number * @@a6@@ ) ; } } else { @@a2@@ [ Number * @@v8@@ + Number ] = @@a5@@ ; @@result@@ = memcpy ( @@a3@@ , @@a2@@ , Number * @@a6@@ ) ; } } } return @@result@@ ; }
__int64 __fastcall rpl_regcomp ( __int64 @@a1@@ , const char * @@a2@@ , int @@a3@@ ) { __int64 @@v3@@ ; size_t @@v5@@ ; unsigned int @@v7@@ ; __int64 @@v8@@ ; unsigned __int64 @@v9@@ ; if ( ( @@a3@@ & Number ) != Number ) @@v3@@ = Number L ; else @@v3@@ = Number L ; @@v8@@ = @@v3@@ ; * ( _QWORD * ) @@a1@@ = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = malloc ( Number ) ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; @@v9@@ = ( @@a3@@ << Number ) & Number | ( unsigned __int64 ) @@v8@@ ; if ( ( @@a3@@ & Number ) != Number ) { @@v9@@ = @@v9@@ & Number | Number ; * ( _BYTE * ) ( @@a1@@ + Number ) |= Number ; } else { * ( _BYTE * ) ( @@a1@@ + Number ) &= Number ; } * ( _BYTE * ) ( @@a1@@ + Number ) = ( Number * ( ( @@a3@@ & Number ) != Number ) ) | * ( _BYTE * ) ( @@a1@@ + Number ) & Number ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; @@v5@@ = strlen ( @@a2@@ ) ; @@v7@@ = re_compile_internal ( @@a1@@ , @@a2@@ , @@v5@@ , @@v9@@ ) ; if ( @@v7@@ == Number ) @@v7@@ = Number ; if ( @@v7@@ ) { free ( * ( void * * ) ( @@a1@@ + Number ) ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number L ; } else { rpl_re_compile_fastmap ( @@a1@@ ) ; } return @@v7@@ ; }
__int64 __fastcall push_fail_stack ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , const void * @@a5@@ , __int64 @@a6@@ ) { __int64 @@v6@@ ; __int64 @@v8@@ ; __int64 @@v13@@ ; void * @@v14@@ ; @@v6@@ = ( * ( _QWORD * ) @@a1@@ ) ++ ; @@v13@@ = @@v6@@ ; if ( * ( _QWORD * ) @@a1@@ == * ( _QWORD * ) ( @@a1@@ + Number ) ) { @@v14@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number L * * ( _QWORD * ) ( @@a1@@ + Number ) ) ; if ( ! @@v14@@ ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) *= Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v14@@ ; } * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@v13@@ ) = @@a2@@ ; * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@v13@@ + Number ) = @@a3@@ ; @@v8@@ = * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@v13@@ ; * ( _QWORD * ) ( @@v8@@ + Number ) = malloc ( Number * @@a4@@ ) ; if ( ! * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@v13@@ + Number ) ) return Number L ; memcpy ( * ( void * * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@v13@@ + Number ) , @@a5@@ , Number * @@a4@@ ) ; return ( unsigned int ) re_node_set_init_copy ( ( void * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@v13@@ + Number ) , @@a6@@ ) ; }
__int64 __fastcall update_cur_sifted_state ( _QWORD * @@a1@@ , _QWORD * @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ ) { __int64 @@v4@@ ; __int64 @@result@@ ; _QWORD * @@v6@@ ; unsigned int @@v9@@ ; __int64 @@v10@@ ; __int64 @@v11@@ ; unsigned __int64 @@v12@@ ; @@v12@@ = __readfsqword ( Number ) ; @@v10@@ = @@a1@@ [ Number ] ; @@v9@@ = Number ; if ( * ( _QWORD * ) ( Number * @@a3@@ + @@a1@@ [ Number ] ) ) @@v4@@ = * ( _QWORD * ) ( Number * @@a3@@ + @@a1@@ [ Number ] ) + Number L ; else @@v4@@ = Number L ; @@v11@@ = @@v4@@ ; if ( * ( _QWORD * ) ( @@a4@@ + Number ) ) { if ( @@v11@@ ) { @@v9@@ = add_epsilon_src_nodes ( @@v10@@ , @@a4@@ , @@v11@@ ) ; if ( @@v9@@ ) return @@v9@@ ; if ( @@a2@@ [ Number ] ) { @@v9@@ = check_subexp_limits ( @@v10@@ , @@a4@@ , @@v11@@ , @@a2@@ + Number , @@a1@@ [ Number ] , @@a3@@ ) ; if ( @@v9@@ ) return @@v9@@ ; } } @@v6@@ = ( _QWORD * ) ( * @@a2@@ + Number * @@a3@@ ) ; * @@v6@@ = re_acquire_state ( & @@v9@@ , @@v10@@ , @@a4@@ ) ; if ( @@v9@@ ) return @@v9@@ ; } else { * ( _QWORD * ) ( Number * @@a3@@ + * @@a2@@ ) = Number L ; } if ( @@v11@@ && ( * ( _BYTE * ) ( * ( _QWORD * ) ( Number * @@a3@@ + @@a1@@ [ Number ] ) + Number L ) & Number ) != Number && ( @@v9@@ = sift_states_bkref ( @@a1@@ , @@a2@@ , @@a3@@ , @@v11@@ ) ) != Number ) { @@result@@ = @@v9@@ ; } else { @@result@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall free_workarea_compile ( __int64 * @@a1@@ ) { __int64 @@result@@ ; _QWORD * @@ptr@@ ; __int64 @@v3@@ ; _QWORD * @@v4@@ ; @@v3@@ = * @@a1@@ ; for ( @@ptr@@ = * ( _QWORD * * ) ( * @@a1@@ + Number ) ; @@ptr@@ ; @@ptr@@ = @@v4@@ ) { @@v4@@ = ( _QWORD * ) * @@ptr@@ ; free ( @@ptr@@ ) ; } * ( _QWORD * ) ( @@v3@@ + Number ) = Number L ; * ( _DWORD * ) ( @@v3@@ + Number ) = Number ; * ( _QWORD * ) ( @@v3@@ + Number ) = Number L ; free ( * ( void * * ) ( @@v3@@ + Number ) ) ; @@result@@ = @@v3@@ ; * ( _QWORD * ) ( @@v3@@ + Number ) = Number L ; return @@result@@ ; }
__int64 __fastcall build_sifted_states ( __int64 @@a1@@ , _QWORD * @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ ) { int @@v7@@ ; unsigned __int64 @@i@@ ; _QWORD * @@v9@@ ; __int64 @@v10@@ ; unsigned __int64 @@v11@@ ; @@v9@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; @@v10@@ = * ( _QWORD * ) ( Number * @@a3@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) + Number L ; for ( @@i@@ = Number L ; @@i@@ < * ( _QWORD * ) ( @@v10@@ + Number ) ; ++ @@i@@ ) { @@v11@@ = * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@v10@@ + Number ) ) ; @@v7@@ = Number ; if ( ( * ( _BYTE * ) ( Number * @@v11@@ + * @@v9@@ + Number ) & Number ) != Number ) @@v7@@ = sift_states_iter_mb ( @@a1@@ , @@a2@@ , @@v11@@ , @@a3@@ , @@a2@@ [ Number ] ) ; if ( ! @@v7@@ && ( unsigned __int8 ) check_node_accept ( @@a1@@ , * @@v9@@ + Number * @@v11@@ , @@a3@@ ) && * ( _QWORD * ) ( Number * ( @@a3@@ + Number ) + * @@a2@@ ) && re_node_set_contains ( * ( _QWORD * ) ( Number * ( @@a3@@ + Number ) + * @@a2@@ ) + Number L , * ( _QWORD * ) ( Number * @@v11@@ + @@v9@@ [ Number ] ) ) ) { @@v7@@ = Number ; } if ( @@v7@@ && ( ! @@a2@@ [ Number ] || ! ( unsigned __int8 ) check_dst_limits ( @@a1@@ , @@a2@@ + Number , * ( _QWORD * ) ( Number * @@v11@@ + @@v9@@ [ Number ] ) , @@v7@@ + @@a3@@ , @@v11@@ , @@a3@@ ) ) && ! re_node_set_insert ( @@a4@@ , @@v11@@ ) ) { return Number L ; } } return Number L ; }
__int64 __fastcall sift_states_iter_mb ( __int64 @@a1@@ , _QWORD * @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , unsigned __int64 @@a5@@ ) { int @@v9@@ ; __int64 @@v10@@ ; @@v10@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v9@@ = check_node_accept_bytes ( @@v10@@ , @@a3@@ , @@a1@@ , @@a4@@ ) ; if ( @@v9@@ > Number && @@a5@@ >= @@v9@@ + @@a4@@ && ( ! * ( _QWORD * ) ( Number * ( @@v9@@ + @@a4@@ ) + * @@a2@@ ) || ! re_node_set_contains ( * ( _QWORD * ) ( Number * ( @@v9@@ + @@a4@@ ) + * @@a2@@ ) + Number L , * ( _QWORD * ) ( Number * @@a3@@ + * ( _QWORD * ) ( @@v10@@ + Number ) ) ) ) ) { @@v9@@ = Number ; } return ( unsigned int ) @@v9@@ ; }
__int64 __fastcall preorder ( _QWORD * @@a1@@ , __int64 ( __fastcall * @@a2@@ ) ( __int64 , _QWORD * ) , __int64 @@a3@@ ) { __int64 @@result@@ ; _QWORD * @@v5@@ ; _QWORD * @@v6@@ ; @@v5@@ = @@a1@@ ; LODWORD ( @@result@@ ) = @@a2@@ ( @@a3@@ , @@a1@@ ) ; while ( ! ( _DWORD ) @@result@@ ) { if ( @@v5@@ [ Number ] ) { @@v5@@ = ( _QWORD * ) @@v5@@ [ Number ] ; LODWORD ( @@result@@ ) = @@a2@@ ( @@a3@@ , @@v5@@ ) ; } else { @@v6@@ = Number L ; while ( @@v6@@ == ( _QWORD * ) @@v5@@ [ Number ] || ! @@v5@@ [ Number ] ) { @@v6@@ = @@v5@@ ; @@v5@@ = ( _QWORD * ) * @@v5@@ ; if ( ! @@v5@@ ) return Number L ; } @@v5@@ = ( _QWORD * ) @@v5@@ [ Number ] ; LODWORD ( @@result@@ ) = @@a2@@ ( @@a3@@ , @@v5@@ ) ; } } return ( unsigned int ) @@result@@ ; }
__int64 __fastcall check_dst_limits ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , __int64 @@a6@@ ) { unsigned __int64 @@i@@ ; _QWORD * @@v12@@ ; __int64 @@v13@@ ; __int64 @@v14@@ ; __int64 @@v15@@ ; __int64 @@v16@@ ; @@v12@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; @@v13@@ = search_cur_bkref_entry ( @@a1@@ , @@a4@@ ) ; @@v14@@ = search_cur_bkref_entry ( @@a1@@ , @@a6@@ ) ; for ( @@i@@ = Number L ; @@i@@ < * ( _QWORD * ) ( @@a2@@ + Number ) ; ++ @@i@@ ) { @@v15@@ = * ( _QWORD * ) ( * @@v12@@ + Number L * * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L * * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) ) ) ; @@v16@@ = ( int ) check_dst_limits_calc_pos ( @@a1@@ , * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) , @@v15@@ , @@a3@@ , @@a4@@ , @@v13@@ ) ; if ( ( int ) check_dst_limits_calc_pos ( @@a1@@ , * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) , @@v15@@ , @@a5@@ , @@a6@@ , @@v14@@ ) != @@v16@@ ) return Number L ; } return Number L ; }
__int64 __fastcall check_subexp_matching_top ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { unsigned int @@v5@@ ; unsigned __int64 @@i@@ ; _QWORD * @@v7@@ ; __int64 @@v8@@ ; @@v7@@ = * ( _QWORD * * ) ( @@a1@@ + Number ) ; for ( @@i@@ = Number L ; @@i@@ < * ( _QWORD * ) ( @@a2@@ + Number ) ; ++ @@i@@ ) { @@v8@@ = * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) ; if ( * ( _BYTE * ) ( Number * @@v8@@ + * @@v7@@ + Number ) == Number && * ( _QWORD * ) ( Number * @@v8@@ + * @@v7@@ ) <= Number && ( ( @@v7@@ [ Number ] >> * ( _QWORD * ) ( Number * @@v8@@ + * @@v7@@ ) ) & Number L ) != Number ) { @@v5@@ = match_ctx_add_subtop ( @@a1@@ , @@v8@@ , @@a3@@ ) ; if ( @@v5@@ ) return @@v5@@ ; } } return Number L ; }
__int64 __fastcall calc_next ( __int64 a1 , __int64 @@a2@@ ) { int @@v2@@ ; @@v2@@ = * ( unsigned __int8 * ) ( @@a2@@ + Number ) ; if ( @@v2@@ == Number ) { * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) = @@a2@@ ; } else if ( @@v2@@ == Number ) { * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) = * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) ; * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) = * ( _QWORD * ) ( @@a2@@ + Number ) ; } else { if ( * ( _QWORD * ) ( @@a2@@ + Number ) ) * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( * ( _QWORD * ) ( @@a2@@ + Number ) ) * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number L ) = * ( _QWORD * ) ( @@a2@@ + Number ) ; } return Number L ; }
__int64 __fastcall check_arrival_expand_ecl ( _QWORD * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , unsigned int @@a4@@ ) { __int64 @@v5@@ ; unsigned int @@v8@@ ; unsigned int @@v9@@ ; unsigned __int64 @@i@@ ; __int64 @@v11@@ ; __int64 @@v12@@ ; __int64 @@v13@@ [ Number ] ; void * @@ptr@@ ; unsigned __int64 @@v15@@ ; @@v15@@ = __readfsqword ( Number ) ; @@v8@@ = re_node_set_alloc ( @@v13@@ , * ( _QWORD * ) ( @@a2@@ + Number ) ) ; if ( @@v8@@ ) return @@v8@@ ; for ( @@i@@ = Number L ; @@i@@ < * ( _QWORD * ) ( @@a2@@ + Number ) ; ++ @@i@@ ) { @@v11@@ = * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) ; @@v12@@ = @@a1@@ [ Number ] + Number * @@v11@@ ; if ( find_subexp_node ( @@a1@@ , @@v12@@ , @@a3@@ , @@a4@@ ) == Number ) { @@v9@@ = re_node_set_merge ( ( __int64 ) @@v13@@ , @@v12@@ ) ; if ( @@v9@@ ) goto LABEL_6 ; } else { @@v9@@ = check_arrival_expand_ecl_sub ( @@a1@@ , @@v13@@ , @@v11@@ , @@a3@@ , @@a4@@ ) ; if ( @@v9@@ ) { LABEL_6 : free ( @@ptr@@ ) ; return @@v9@@ ; } } } free ( * ( void * * ) ( @@a2@@ + Number ) ) ; @@v5@@ = @@v13@@ [ Number ] ; * ( _QWORD * ) @@a2@@ = @@v13@@ [ Number ] ; * ( _QWORD * ) ( @@a2@@ + Number ) = @@v5@@ ; * ( _QWORD * ) ( @@a2@@ + Number ) = @@ptr@@ ; return Number L ; }
__int64 __fastcall merge_state_with_log ( _DWORD * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v4@@ ; __int64 * @@v5@@ ; __int64 @@v6@@ ; unsigned int @@v7@@ ; __int64 @@v8@@ ; __int64 @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; __int64 @@v12@@ [ Number ] ; void * @@ptr@@ ; unsigned __int64 @@v14@@ ; @@v6@@ = @@a3@@ ; @@v14@@ = __readfsqword ( Number ) ; @@v9@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@v10@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; if ( @@v10@@ <= * ( _QWORD * ) ( @@a2@@ + Number ) ) { if ( * ( _QWORD * ) ( Number * @@v10@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) ) { @@v8@@ = Number L ; @@v11@@ = * ( _QWORD * ) ( * ( _QWORD * ) ( Number * @@v10@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) + Number L ) ; if ( @@a3@@ ) { @@v8@@ = * ( _QWORD * ) ( @@a3@@ + Number ) ; * @@a1@@ = re_node_set_init_union ( @@v12@@ , @@v8@@ , @@v11@@ ) ; if ( * @@a1@@ ) return Number L ; } else { @@v4@@ = * ( _QWORD * ) ( @@v11@@ + Number ) ; @@v12@@ [ Number ] = * ( _QWORD * ) @@v11@@ ; @@v12@@ [ Number ] = @@v4@@ ; @@ptr@@ = * ( void * * ) ( @@v11@@ + Number ) ; } @@v7@@ = re_string_context_at ( @@a2@@ , * ( _QWORD * ) ( @@a2@@ + Number ) - Number L , * ( _DWORD * ) ( @@a2@@ + Number ) ) ; @@v5@@ = ( __int64 * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number * @@v10@@ ) ; * @@v5@@ = re_acquire_state_context ( @@a1@@ , @@v9@@ , ( __int64 ) @@v12@@ , @@v7@@ ) ; @@v6@@ = * @@v5@@ ; if ( @@v8@@ ) free ( @@ptr@@ ) ; } else { * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number * @@v10@@ ) = @@a3@@ ; } } else { * ( _QWORD * ) ( * ( _QWORD * ) ( @@a2@@ + Number ) + Number * @@v10@@ ) = @@a3@@ ; * ( _QWORD * ) ( @@a2@@ + Number ) = @@v10@@ ; } if ( * ( _QWORD * ) ( @@v9@@ + Number ) && @@v6@@ ) { * @@a1@@ = check_subexp_matching_top ( @@a2@@ , @@v6@@ + Number , @@v10@@ ) ; if ( * @@a1@@ ) return Number L ; if ( ( * ( _BYTE * ) ( @@v6@@ + Number ) & Number ) != Number ) { * @@a1@@ = transit_state_bkref ( @@a2@@ , @@v6@@ + Number ) ; if ( * @@a1@@ ) return Number L ; @@v6@@ = * ( _QWORD * ) ( Number * @@v10@@ + * ( _QWORD * ) ( @@a2@@ + Number ) ) ; } } return @@v6@@ ; }
__int64 __fastcall parse_branch ( __int64 @@a1@@ , __int64 * @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ , __int64 @@a5@@ , _DWORD * @@a6@@ ) { __int64 @@v11@@ ; __int64 @@v12@@ ; __int64 @@v13@@ ; @@v12@@ = * @@a2@@ ; @@v11@@ = parse_expression ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( * @@a6@@ && ! @@v11@@ ) return Number L ; while ( * ( _BYTE * ) ( @@a3@@ + Number ) != Number && * ( _BYTE * ) ( @@a3@@ + Number ) != Number && ( ! @@a5@@ || * ( _BYTE * ) ( @@a3@@ + Number ) != Number ) ) { @@v13@@ = parse_expression ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@a5@@ , @@a6@@ ) ; if ( * @@a6@@ && ! @@v13@@ ) return Number L ; if ( @@v11@@ && @@v13@@ ) { @@v11@@ = create_tree ( @@v12@@ , @@v11@@ , @@v13@@ , Number L ) ; if ( ! @@v11@@ ) { * @@a6@@ = Number ; return Number L ; } } else if ( ! @@v11@@ ) { @@v11@@ = @@v13@@ ; } } return @@v11@@ ; }
__int64 __fastcall match_ctx_init ( __int64 @@a1@@ , int @@a2@@ , unsigned __int64 @@a3@@ ) { * ( _DWORD * ) ( @@a1@@ + Number ) = @@a2@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = Number ; if ( ! @@a3@@ ) goto LABEL_7 ; if ( ! is_mul_ok ( Number , @@a3@@ ) ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = malloc ( Number * @@a3@@ ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = malloc ( Number * @@a3@@ ) ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) || ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; LABEL_7 : * ( _QWORD * ) ( @@a1@@ + Number ) = @@a3@@ ; * ( _DWORD * ) ( @@a1@@ + Number ) = Number ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@a3@@ ; return Number L ; }
__int64 __fastcall build_equiv_class ( __int64 @@a1@@ , __int64 a2 , __int64 a3 , const char * @@a4@@ ) { if ( strlen ( @@a4@@ ) != Number ) return Number L ; bitset_set ( @@a1@@ , * ( unsigned __int8 * ) @@a4@@ ) ; return Number L ; }
_QWORD * __fastcall match_ctx_add_sublast ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v5@@ ; void * @@v6@@ ; _QWORD * @@v7@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) == * ( _QWORD * ) ( @@a1@@ + Number ) ) { @@v5@@ = Number L * * ( _QWORD * ) ( @@a1@@ + Number ) + Number ; @@v6@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number * @@v5@@ ) ; if ( ! @@v6@@ ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v6@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v5@@ ; } @@v7@@ = calloc ( Number , Number ) ; if ( @@v7@@ ) { * ( _QWORD * ) ( Number L * * ( _QWORD * ) ( @@a1@@ + Number ) + * ( _QWORD * ) ( @@a1@@ + Number ) ) = @@v7@@ ; * @@v7@@ = @@a2@@ ; @@v7@@ [ Number ] = @@a3@@ ; ++ * ( _QWORD * ) ( @@a1@@ + Number ) ; } return @@v7@@ ; }
_BOOL8 __fastcall check_node_accept ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { int @@v3@@ ; _BOOL8 @@result@@ ; char @@v6@@ ; char @@v7@@ ; @@v6@@ = * ( _BYTE * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + @@a3@@ ) ; @@v3@@ = * ( unsigned __int8 * ) ( @@a2@@ + Number ) ; if ( @@v3@@ == Number ) { if ( ! bitset_contain ( * ( _QWORD * ) @@a2@@ , ( unsigned __int8 ) @@v6@@ ) ) return Number L ; } else if ( * ( unsigned __int8 * ) ( @@a2@@ + Number ) > Number ) { if ( @@v3@@ != Number ) { if ( @@v3@@ != Number ) return Number L ; if ( @@v6@@ < Number ) return Number L ; } if ( @@v6@@ == Number && ( * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L ) & Number ) == Number || ! @@v6@@ && ( * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L ) & Number ) != Number ) { return Number L ; } } else { if ( @@v3@@ != Number ) return Number L ; if ( @@v6@@ != * ( _BYTE * ) @@a2@@ ) return Number L ; } @@result@@ = Number ; if ( ( * ( _DWORD * ) ( @@a2@@ + Number ) & Number ) != Number ) { if ( ( @@v7@@ = re_string_context_at ( @@a1@@ , @@a3@@ , * ( _DWORD * ) ( @@a1@@ + Number ) ) , ( ( * ( _DWORD * ) ( @@a2@@ + Number ) >> Number ) & Number ) != Number ) && ( @@v7@@ & Number ) == Number || ( ( * ( _DWORD * ) ( @@a2@@ + Number ) >> Number ) & Number ) != Number && ( @@v7@@ & Number ) != Number || ( ( * ( _DWORD * ) ( @@a2@@ + Number ) >> Number ) & Number ) != Number && ( @@v7@@ & Number ) == Number || ( ( * ( _DWORD * ) ( @@a2@@ + Number ) >> Number ) & Number ) != Number && ( @@v7@@ & Number ) == Number ) { @@result@@ = Number ; } } return @@result@@ ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
__int64 __fastcall fetch_number ( __int64 @@a1@@ , unsigned __int8 * @@a2@@ , __int64 @@a3@@ ) { unsigned __int64 @@v4@@ ; unsigned __int8 @@v6@@ ; __int64 @@i@@ ; for ( @@i@@ = Number ; ; @@i@@ = @@v4@@ ) { fetch_token ( ( __int64 ) @@a2@@ , @@a1@@ , @@a3@@ ) ; @@v6@@ = * @@a2@@ ; if ( @@a2@@ [ Number ] == Number ) return Number ; if ( @@a2@@ [ Number ] == Number || @@v6@@ == Number ) break ; if ( @@a2@@ [ Number ] != Number || @@v6@@ <= Number || @@v6@@ > Number || @@i@@ == Number ) { @@v4@@ = Number ; } else if ( @@i@@ == Number ) { @@v4@@ = @@v6@@ - Number ; } else { @@v4@@ = Number * @@i@@ + @@v6@@ - Number ; } if ( @@v4@@ > Number ) @@v4@@ = Number ; } return @@i@@ ; }
__int64 ( * * init_proc ( ) ) ( void ) { __int64 ( * * @@result@@ ( ) ( void ) ) ( void ) ; @@result@@ ( ) ( void ) = & _gmon_start__ ; if ( & _gmon_start__ ) @@result@@ ( ) ( void ) = ( __int64 ( * * ) ( void ) ) _gmon_start__ ( ) ; return @@result@@ ( ) ( void ) ; }
__int64 __fastcall match_ctx_add_subtop ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v3@@ ; void * * @@v5@@ ; __int64 @@v6@@ ; __int64 @@v7@@ ; __int64 @@v9@@ ; void * @@v10@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) == * ( _QWORD * ) ( @@a1@@ + Number ) ) { @@v3@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v9@@ = Number * @@v3@@ ; @@v10@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number * @@v3@@ ) ; if ( ! @@v10@@ ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v10@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v9@@ ; } @@v5@@ = ( void * * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L * * ( _QWORD * ) ( @@a1@@ + Number ) ) ; * @@v5@@ = calloc ( Number , Number ) ; if ( ! * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L * * ( _QWORD * ) ( @@a1@@ + Number ) ) ) return Number L ; * ( _QWORD * ) ( * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L * * ( _QWORD * ) ( @@a1@@ + Number ) ) + Number L ) = @@a2@@ ; @@v6@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; @@v7@@ = * ( _QWORD * ) ( @@a1@@ + Number ) ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v7@@ + Number ; * * ( _QWORD * * ) ( @@v6@@ + Number * @@v7@@ ) = @@a3@@ ; return Number L ; }
int getc_unlocked ( FILE * @@stream@@ ) { return getc_unlocked ( @@stream@@ ) ; }
void __fastcall free_token ( __int64 @@a1@@ ) { if ( * ( _BYTE * ) ( @@a1@@ + Number ) != Number || ( * ( _BYTE * ) ( @@a1@@ + Number ) & Number ) != Number ) { if ( * ( _BYTE * ) ( @@a1@@ + Number ) == Number && ( * ( _BYTE * ) ( @@a1@@ + Number ) & Number ) == Number ) free ( * ( void * * ) @@a1@@ ) ; } else { free_charset ( * ( void * * * ) @@a1@@ ) ; } }
size_t strlen ( const char * @@s@@ ) { return strlen ( @@s@@ ) ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
int ferror_unlocked ( FILE * @@stream@@ ) { return ferror_unlocked ( @@stream@@ ) ; }
void __noreturn exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
__int64 __fastcall dup_safer ( int @@a1@@ , __int64 a2 , __int64 a3 , int @@a4@@ , int @@a5@@ , int @@a6@@ ) { return rpl_fcntl ( @@a1@@ , Number , Number , @@a4@@ , @@a5@@ , @@a6@@ ) ; }
void * _do_global_dtors_aux ( ) { void * @@result@@ ; if ( ! completed_7698 ) { if ( & __cxa_finalize ) _cxa_finalize ( _dso_handle ) ; @@result@@ = deregister_tm_clones ( ) ; completed_7698 = Number ; } return @@result@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
char * gettext ( const char * @@msgid@@ ) { return gettext ( @@msgid@@ ) ; }
int iconv_close ( iconv_t @@cd@@ ) { return iconv_close ( @@cd@@ ) ; }
int mbsinit ( const mbstate_t * @@ps@@ ) { return mbsinit ( @@ps@@ ) ; }
__int64 __fastcall duplicate_tree ( __int64 * * @@a1@@ , __int64 @@a2@@ ) { __int64 @@v2@@ ; __int64 @@v4@@ ; __int64 * @@v5@@ ; __int64 * @@v6@@ ; __int64 * @@v7@@ ; __int64 * @@v8@@ ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; @@v6@@ = & @@v4@@ ; @@v7@@ = * @@a1@@ ; @@v5@@ = ( __int64 * ) @@a1@@ ; while ( Number ) { @@v2@@ = create_token_tree ( @@a2@@ , Number L , Number L , @@v5@@ + Number ) ; * @@v6@@ = @@v2@@ ; if ( ! * @@v6@@ ) break ; * ( _QWORD * ) * @@v6@@ = @@v7@@ ; * ( _BYTE * ) ( * @@v6@@ + Number ) |= Number ; @@v7@@ = ( __int64 * ) * @@v6@@ ; if ( @@v5@@ [ Number ] ) { @@v5@@ = ( __int64 * ) @@v5@@ [ Number ] ; @@v6@@ = @@v7@@ + Number ; } else { @@v8@@ = Number L ; while ( @@v8@@ == ( __int64 * ) @@v5@@ [ Number ] || ! @@v5@@ [ Number ] ) { @@v8@@ = @@v5@@ ; @@v5@@ = ( __int64 * ) * @@v5@@ ; @@v7@@ = ( __int64 * ) * @@v7@@ ; if ( ! @@v5@@ ) return @@v4@@ ; } @@v5@@ = ( __int64 * ) @@v5@@ [ Number ] ; @@v6@@ = @@v7@@ + Number ; } } return Number L ; }
char * next_line_num ( ) { char * @@result@@ ; _BYTE * @@v1@@ ; _BYTE * @@v2@@ ; @@v2@@ = line_num_end ; while ( Number ) { @@result@@ = ( char * ) ( unsigned __int8 ) ( * @@v2@@ ) ++ ; if ( ( char ) @@result@@ <= Number ) break ; @@v1@@ = @@v2@@ -- ; * @@v1@@ = Number ; if ( @@v2@@ < line_num_start ) { if ( line_num_start <= line_buf ) { line_buf [ Number ] = Number ; } else { line_num_start = ( char * ) line_num_start - Number ; * ( _BYTE * ) line_num_start = Number ; } @@result@@ = line_num_print ; if ( line_num_start < line_num_print ) @@result@@ = -- line_num_print ; return @@result@@ ; } } return @@result@@ ; }
__int64 __fastcall io_blksize ( __int64 a1 , __int64 a2 , __int64 a3 , __int64 a4 , __int64 a5 , __int64 a6 , int a7 , int a8 , int a9 , int a10 , int a11 , int a12 , int a13 , __int64 @@a14@@ ) { __int64 @@result@@ ; if ( @@a14@@ <= Number || ( unsigned __int64 ) @@a14@@ > Number || @@a14@@ <= Number ) { @@result@@ = Number ; } else { @@result@@ = @@a14@@ ; } return @@result@@ ; }
bool __fastcall is_basic ( unsigned __int8 @@a1@@ ) { return ( ( * ( ( _DWORD * ) & is_basic_table + ( @@a1@@ >> Number ) ) >> ( @@a1@@ & Number ) ) & Number ) != Number ; }
bool __fastcall is_basic_0 ( unsigned __int8 @@a1@@ ) { return ( ( * ( ( _DWORD * ) & is_basic_table + ( @@a1@@ >> Number ) ) >> ( @@a1@@ & Number ) ) & Number ) != Number ; }
__int64 __fastcall full_write ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v5@@ ; __int64 @@v7@@ ; @@v5@@ = Number L ; while ( @@a3@@ ) { @@v7@@ = safe_write ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( @@v7@@ == Number ) break ; if ( ! @@v7@@ ) { * __errno_location ( ) = Number ; return @@v5@@ ; } @@v5@@ += @@v7@@ ; @@a2@@ += @@v7@@ ; @@a3@@ -= @@v7@@ ; } return @@v5@@ ; }
_BYTE * __fastcall last_component ( _BYTE * @@a1@@ ) { char @@v2@@ ; _BYTE * @@i@@ ; @@v2@@ = Number ; while ( * @@a1@@ == Number ) ++ @@a1@@ ; for ( @@i@@ = @@a1@@ ; * @@i@@ ; ++ @@i@@ ) { if ( * @@i@@ == Number ) { @@v2@@ = Number ; } else if ( @@v2@@ ) { @@a1@@ = @@i@@ ; @@v2@@ = Number ; } } return @@a1@@ ; }
const char * __fastcall proper_name ( const char * @@a1@@ ) { size_t @@v2@@ ; size_t @@v3@@ ; char * @@s@@ ; char * @@v5@@ ; @@s@@ = gettext ( @@a1@@ ) ; if ( @@s@@ == @@a1@@ ) return @@a1@@ ; if ( ( unsigned __int8 ) mbsstr_trimmed_wordbounded ( @@s@@ , ( __int64 ) @@a1@@ ) ) return @@s@@ ; @@v2@@ = strlen ( @@s@@ ) ; @@v3@@ = strlen ( @@a1@@ ) ; @@v5@@ = ( char * ) xmalloc ( @@v2@@ + @@v3@@ + Number ) ; sprintf ( @@v5@@ , String , @@s@@ , @@a1@@ ) ; return @@v5@@ ; }
__int64 __fastcall re_copy_regs ( __int64 @@a1@@ , __int64 @@a2@@ , unsigned __int64 @@a3@@ , int @@a4@@ ) { _QWORD * @@v5@@ ; unsigned int @@v7@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@v9@@ ; void * @@ptr@@ ; void * @@v11@@ ; @@v7@@ = Number ; @@v9@@ = @@a3@@ + Number ; if ( @@a4@@ ) { if ( @@a4@@ == Number ) { if ( @@v9@@ > * ( _QWORD * ) @@a1@@ ) { @@ptr@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number * @@v9@@ ) ; if ( ! @@ptr@@ ) return Number L ; @@v11@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number * @@v9@@ ) ; if ( ! @@v11@@ ) { free ( @@ptr@@ ) ; return Number L ; } * ( _QWORD * ) ( @@a1@@ + Number ) = @@ptr@@ ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v11@@ ; * ( _QWORD * ) @@a1@@ = @@v9@@ ; } } else { if ( @@a4@@ != Number ) __assert_fail ( String , String , Number , String ) ; if ( @@a3@@ > * ( _QWORD * ) @@a1@@ ) __assert_fail ( String , String , Number , String ) ; @@v7@@ = Number ; } } else { * ( _QWORD * ) ( @@a1@@ + Number ) = malloc ( Number * @@v9@@ ) ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = malloc ( Number * @@v9@@ ) ; if ( ! * ( _QWORD * ) ( @@a1@@ + Number ) ) { free ( * ( void * * ) ( @@a1@@ + Number ) ) ; return Number L ; } * ( _QWORD * ) @@a1@@ = @@v9@@ ; } for ( @@i@@ = Number L ; @@i@@ < @@a3@@ ; ++ @@i@@ ) { * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@i@@ ) = * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ ) ; * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number * @@i@@ ) = * ( _QWORD * ) ( Number * @@i@@ + @@a2@@ + Number ) ; } while ( @@i@@ < * ( _QWORD * ) @@a1@@ ) { @@v5@@ = ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) ; * @@v5@@ = Number ; * ( _QWORD * ) ( Number * @@i@@ ++ + * ( _QWORD * ) ( @@a1@@ + Number ) ) = * @@v5@@ ; } return @@v7@@ ; }
__int64 __fastcall clone_quoting_options ( __int64 * @@a1@@ ) { __int64 * @@v1@@ ; int @@v3@@ ; __int64 @@v4@@ ; @@v3@@ = * __errno_location ( ) ; if ( @@a1@@ ) @@v1@@ = @@a1@@ ; else @@v1@@ = & default_quoting_options ; @@v4@@ = xmemdup ( @@v1@@ , Number L ) ; * __errno_location ( ) = @@v3@@ ; return @@v4@@ ; }
unsigned __int64 __fastcall version_etc_va ( FILE * @@a1@@ , const char * @@a2@@ , const char * @@a3@@ , const char * @@a4@@ , unsigned int * @@a5@@ ) { __int64 * @@v5@@ ; unsigned __int64 @@i@@ ; __int64 @@v8@@ [ Number ] ; unsigned __int64 @@v9@@ ; @@v9@@ = __readfsqword ( Number ) ; for ( @@i@@ = Number L ; @@i@@ <= Number ; ++ @@i@@ ) { if ( * @@a5@@ > Number ) { @@v5@@ = ( __int64 * ) * ( ( _QWORD * ) @@a5@@ + Number ) ; * ( ( _QWORD * ) @@a5@@ + Number ) = @@v5@@ + Number ; } else { @@v5@@ = ( __int64 * ) ( * ( ( _QWORD * ) @@a5@@ + Number ) + * @@a5@@ ) ; * @@a5@@ += Number ; } @@v8@@ [ @@i@@ ] = * @@v5@@ ; if ( ! @@v8@@ [ @@i@@ ] ) break ; } version_etc_arn ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , @@v8@@ , @@i@@ ) ; return __readfsqword ( Number ) ^ @@v9@@ ; }
__int64 __fastcall set_quoting_flags ( __int64 * @@a1@@ , int @@a2@@ ) { __int64 * @@v3@@ ; unsigned int @@v4@@ ; @@v3@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v3@@ = & default_quoting_options ; @@v4@@ = * ( ( _DWORD * ) @@v3@@ + Number ) ; * ( ( _DWORD * ) @@v3@@ + Number ) = @@a2@@ ; return @@v4@@ ; }
__int64 __fastcall quotearg_alloc ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_alloc_mem ( @@a1@@ , @@a2@@ , Number L , @@a3@@ ) ; }
__int64 close_stdout ( ) { const char * @@v0@@ ; int * @@v1@@ ; int * @@v2@@ ; __int64 @@result@@ ; char * @@v4@@ ; if ( ( unsigned int ) close_stream ( stdout ) && ( ignore_EPIPE != Number || * __errno_location ( ) != Number ) ) { @@v4@@ = gettext ( String ) ; if ( file_name ) { @@v0@@ = ( const char * ) quotearg_colon ( file_name ) ; @@v1@@ = __errno_location ( ) ; error ( Number , * @@v1@@ , String , @@v0@@ , @@v4@@ ) ; } else { @@v2@@ = __errno_location ( ) ; error ( Number , * @@v2@@ , off_9E16 , @@v4@@ ) ; } _exit ( exit_failure ) ; } @@result@@ = close_stream ( stderr ) ; if ( ( _DWORD ) @@result@@ ) _exit ( exit_failure ) ; return @@result@@ ; }
__int64 __fastcall sift_states_backward ( __int64 @@a1@@ , __int64 @@a2@@ ) { int @@v3@@ ; unsigned int @@v4@@ ; unsigned int @@v5@@ ; int @@v6@@ ; __int64 @@v7@@ ; void * @@v8@@ [ Number ] ; void * @@ptr@@ ; unsigned __int64 @@v10@@ ; @@v10@@ = __readfsqword ( Number ) ; @@v6@@ = Number ; @@v7@@ = * ( _QWORD * ) ( @@a2@@ + Number ) ; @@v4@@ = re_node_set_init_1 ( @@v8@@ , * ( _QWORD * ) ( @@a2@@ + Number ) ) ; if ( @@v4@@ ) return @@v4@@ ; @@v5@@ = update_cur_sifted_state ( @@a1@@ , @@a2@@ , @@v7@@ , @@v8@@ ) ; if ( ! @@v5@@ ) { while ( @@v7@@ ) { if ( * ( _QWORD * ) ( Number * @@v7@@ + * ( _QWORD * ) @@a2@@ ) ) @@v3@@ = Number ; else @@v3@@ = @@v6@@ + Number ; @@v6@@ = @@v3@@ ; if ( @@v3@@ > * ( _DWORD * ) ( @@a1@@ + Number ) ) { memset ( * ( void * * ) @@a2@@ , Number , Number * @@v7@@ ) ; free ( @@ptr@@ ) ; return Number L ; } @@v8@@ [ Number ] = Number L ; -- @@v7@@ ; if ( ! * ( _QWORD * ) ( Number * @@v7@@ + * ( _QWORD * ) ( @@a1@@ + Number ) ) || ( @@v5@@ = build_sifted_states ( @@a1@@ , @@a2@@ , @@v7@@ , @@v8@@ ) ) == Number ) { @@v5@@ = update_cur_sifted_state ( @@a1@@ , @@a2@@ , @@v7@@ , @@v8@@ ) ; if ( ! @@v5@@ ) continue ; } goto LABEL_15 ; } @@v5@@ = Number ; } LABEL_15 : free ( @@ptr@@ ) ; return @@v5@@ ; }
__int64 __fastcall quotearg_alloc_mem ( __int64 @@a1@@ , size_t @@a2@@ , _QWORD * @@a3@@ , __int64 * @@a4@@ ) { __int64 * @@v4@@ ; int @@v7@@ ; int @@v8@@ ; __int64 * @@v9@@ ; unsigned __int64 @@v10@@ ; __int64 @@v11@@ ; if ( @@a4@@ ) @@v4@@ = @@a4@@ ; else @@v4@@ = & default_quoting_options ; @@v9@@ = @@v4@@ ; @@v7@@ = * __errno_location ( ) ; @@v8@@ = * ( ( _DWORD * ) @@v9@@ + Number ) | ( @@a3@@ == Number L ) ; @@v10@@ = quotearg_buffer_restyled ( Number L , Number L , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) + Number ; @@v11@@ = xcharalloc ( @@v10@@ ) ; quotearg_buffer_restyled ( @@v11@@ , @@v10@@ , @@a1@@ , @@a2@@ , * ( _DWORD * ) @@v9@@ , @@v8@@ , ( __int64 ) ( @@v9@@ + Number ) , ( char * ) @@v9@@ [ Number ] , ( char * ) @@v9@@ [ Number ] ) ; * __errno_location ( ) = @@v7@@ ; if ( @@a3@@ ) * @@a3@@ = @@v10@@ - Number ; return @@v11@@ ; }
__int64 * __fastcall set_custom_quoting ( __int64 * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 * @@result@@ ; __int64 * @@v4@@ ; @@v4@@ = @@a1@@ ; if ( ! @@a1@@ ) @@v4@@ = & default_quoting_options ; * ( _DWORD * ) @@v4@@ = Number ; if ( ! @@a2@@ || ! @@a3@@ ) abort ( ) ; @@v4@@ [ Number ] = @@a2@@ ; @@result@@ = @@v4@@ ; @@v4@@ [ Number ] = @@a3@@ ; return @@result@@ ; }
__int64 * __fastcall quotearg ( __int64 @@a1@@ ) { return quotearg_n ( Number , @@a1@@ ) ; }
__int64 * __fastcall quotearg_style ( unsigned int @@a1@@ , __int64 @@a2@@ ) { return quotearg_n_style ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 * __fastcall quotearg_colon ( __int64 @@a1@@ ) { return quotearg_char ( @@a1@@ , Number ) ; }
__int64 * __fastcall quotearg_char_mem ( __int64 @@a1@@ , size_t @@a2@@ , unsigned __int8 @@a3@@ ) { __int64 @@v4@@ [ Number ] ; @@v4@@ [ Number ] = __readfsqword ( Number ) ; @@v4@@ [ Number ] = default_quoting_options ; @@v4@@ [ Number ] = qword_20C0E8 ; @@v4@@ [ Number ] = qword_20C0F0 ; @@v4@@ [ Number ] = qword_20C0F8 ; @@v4@@ [ Number ] = qword_20C100 ; @@v4@@ [ Number ] = qword_20C108 ; @@v4@@ [ Number ] = qword_20C110 ; set_char_quoting ( @@v4@@ , @@a3@@ , Number ) ; return quotearg_n_options ( Number , @@a1@@ , @@a2@@ , ( __int64 ) @@v4@@ ) ; }
ssize_t __fastcall safe_write ( int @@a1@@ , const void * @@a2@@ , size_t @@a3@@ ) { ssize_t @@result@@ ; ssize_t @@v5@@ ; LABEL_1 : for ( @@result@@ = write ( @@a1@@ , @@a2@@ , @@a3@@ ) ; ; @@result@@ = write ( @@a1@@ , @@a2@@ , Number ) ) { @@v5@@ = @@result@@ ; if ( @@result@@ >= Number ) break ; if ( * __errno_location ( ) == Number ) goto LABEL_1 ; if ( * __errno_location ( ) != Number || @@a3@@ <= Number ) return @@v5@@ ; @@a3@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall sub_epsilon_src_nodes ( _QWORD * @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , __int64 @@a4@@ ) { __int64 @@v4@@ ; unsigned int @@v8@@ ; unsigned __int64 @@i@@ ; unsigned __int64 @@j@@ ; __int64 @@v11@@ ; unsigned __int64 @@v12@@ ; unsigned __int64 @@v13@@ ; __int64 @@v14@@ ; unsigned __int64 @@v15@@ ; unsigned __int64 @@v16@@ ; char @@s@@ [ Number ] ; void * @@ptr@@ ; unsigned __int64 @@v19@@ ; @@v19@@ = __readfsqword ( Number ) ; @@v11@@ = @@a1@@ [ Number ] + Number * @@a2@@ ; memset ( @@s@@ , Number , Number ) ; for ( @@i@@ = Number L ; @@i@@ < * ( _QWORD * ) ( @@v11@@ + Number ) ; ++ @@i@@ ) { @@v14@@ = * ( _QWORD * ) ( Number * @@i@@ + * ( _QWORD * ) ( @@v11@@ + Number ) ) ; if ( @@v14@@ != @@a2@@ && ( * ( _BYTE * ) ( Number * @@v14@@ + * @@a1@@ + Number ) & Number ) != Number ) { @@v15@@ = * * ( _QWORD * * ) ( @@a1@@ [ Number ] + Number * @@v14@@ + Number ) ; @@v4@@ = * ( _QWORD * ) ( @@a1@@ [ Number ] + Number * @@v14@@ + Number ) <= Number ? Number : * ( _QWORD * ) ( * ( _QWORD * ) ( @@a1@@ [ Number ] + Number * @@v14@@ + Number ) + Number L ) ; if ( ( @@v16@@ = @@v4@@ , ! re_node_set_contains ( @@v11@@ , @@v15@@ ) ) && re_node_set_contains ( @@a3@@ , @@v15@@ ) || @@v16@@ - Number <= Number && ! re_node_set_contains ( @@v11@@ , @@v16@@ ) && re_node_set_contains ( @@a3@@ , @@v16@@ ) ) { @@v8@@ = re_node_set_add_intersect ( ( __int64 ) @@s@@ , @@a4@@ , @@a1@@ [ Number ] + Number * @@v14@@ ) ; if ( @@v8@@ ) { free ( @@ptr@@ ) ; return @@v8@@ ; } } } } for ( @@j@@ = Number L ; @@j@@ < * ( _QWORD * ) ( @@v11@@ + Number ) ; ++ @@j@@ ) { @@v12@@ = * ( _QWORD * ) ( Number * @@j@@ + * ( _QWORD * ) ( @@v11@@ + Number ) ) ; if ( ! re_node_set_contains ( ( __int64 ) @@s@@ , @@v12@@ ) ) { @@v13@@ = re_node_set_contains ( @@a3@@ , @@v12@@ ) - Number ; re_node_set_remove_at ( @@a3@@ , @@v13@@ ) ; } } free ( @@ptr@@ ) ; return Number L ; }
__int64 * __fastcall quotearg_custom_mem ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { return quotearg_n_custom_mem ( Number , @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ ) ; }
void * __fastcall xzalloc ( size_t @@a1@@ ) { void * @@v1@@ ; @@v1@@ = xmalloc ( @@a1@@ ) ; return memset ( @@v1@@ , Number , @@a1@@ ) ; }
__int64 __fastcall xcharalloc ( __int64 @@a1@@ ) { return xmalloc ( @@a1@@ ) ; }
void * __fastcall xmalloc ( size_t @@a1@@ ) { void * @@v2@@ ; @@v2@@ = malloc ( @@a1@@ ) ; if ( ! @@v2@@ && @@a1@@ ) xalloc_die ( ) ; return @@v2@@ ; }
__int64 __fastcall find_recover_state ( _DWORD * @@a1@@ , _QWORD * @@a2@@ ) { __int64 @@v3@@ ; unsigned __int64 @@v4@@ ; __int64 @@v5@@ ; do { @@v4@@ = @@a2@@ [ Number ] ; @@v3@@ = @@a2@@ [ Number ] ; do { if ( ++ @@v3@@ > @@v4@@ ) return Number L ; ++ @@a2@@ [ Number ] ; } while ( ! * ( _QWORD * ) ( Number * @@v3@@ + @@a2@@ [ Number ] ) ) ; @@v5@@ = merge_state_with_log ( @@a1@@ , ( __int64 ) @@a2@@ , Number L ) ; } while ( ! * @@a1@@ && ! @@v5@@ ) ; return @@v5@@ ; }
void * __fastcall xstrdup ( const char * @@a1@@ ) { size_t @@v1@@ ; @@v1@@ = strlen ( @@a1@@ ) ; return xmemdup ( @@a1@@ , @@v1@@ + Number ) ; }
const char * locale_charset ( ) { const char * @@s1@@ ; char * @@s2@@ ; char * @@s2a@@ ; @@s1@@ = nl_langinfo ( Number ) ; if ( ! @@s1@@ ) @@s1@@ = ( const char * ) & unk_A1D5 ; for ( @@s2@@ = ( char * ) get_charset_aliases ( ) ; * @@s2@@ ; @@s2@@ = & @@s2a@@ [ strlen ( @@s2a@@ ) + Number ] ) { if ( ! strcmp ( @@s1@@ , @@s2@@ ) || * @@s2@@ == Number && ! @@s2@@ [ Number ] ) { @@s1@@ = & @@s2@@ [ strlen ( @@s2@@ ) + Number ] ; break ; } @@s2a@@ = & @@s2@@ [ strlen ( @@s2@@ ) + Number ] ; } if ( ! * @@s1@@ ) @@s1@@ = String ; return @@s1@@ ; }
__int64 __fastcall extend_buffers ( __int64 @@a1@@ ) { unsigned int @@v2@@ ; unsigned int @@v3@@ ; void * @@v4@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) > Number ) return Number L ; @@v2@@ = re_string_realloc_buffers ( @@a1@@ , Number L * * ( _QWORD * ) ( @@a1@@ + Number ) ) ; if ( @@v2@@ ) return @@v2@@ ; if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) { @@v4@@ = realloc ( * ( void * * ) ( @@a1@@ + Number ) , Number * ( * ( _QWORD * ) ( @@a1@@ + Number ) + Number L ) ) ; if ( ! @@v4@@ ) return Number L ; * ( _QWORD * ) ( @@a1@@ + Number ) = @@v4@@ ; } if ( * ( _BYTE * ) ( @@a1@@ + Number ) ) { if ( * ( int * ) ( @@a1@@ + Number ) <= Number ) { build_upper_buffer ( ( _QWORD * ) @@a1@@ ) ; } else { @@v3@@ = build_wcs_upper_buffer ( @@a1@@ ) ; if ( @@v3@@ ) return @@v3@@ ; } } else if ( * ( int * ) ( @@a1@@ + Number ) <= Number ) { if ( * ( _QWORD * ) ( @@a1@@ + Number ) ) re_string_translate_buffer ( ( _QWORD * ) @@a1@@ ) ; } else { build_wcs_buffer ( @@a1@@ ) ; } return Number L ; }
__int64 __fastcall close_stream ( FILE * @@a1@@ ) { bool @@v2@@ ; bool @@v3@@ ; bool @@v4@@ ; @@v2@@ = __fpending ( @@a1@@ ) != Number ; @@v3@@ = ferror_unlocked ( @@a1@@ ) != Number ; @@v4@@ = fclose ( @@a1@@ ) != Number ; if ( ! @@v3@@ && ( ! @@v4@@ || ! @@v2@@ && * __errno_location ( ) == Number ) ) return Number L ; if ( ! @@v4@@ ) * __errno_location ( ) = Number ; return Number ; }
__int64 __fastcall knuth_morris_pratt_unibyte ( _BYTE * @@a1@@ , char * @@a2@@ , _QWORD * @@a3@@ ) { void * @@v3@@ ; unsigned __int64 @@v4@@ ; _QWORD * @@v6@@ ; char * @@s@@ ; _BYTE * @@v8@@ ; char @@v9@@ ; unsigned __int64 @@i@@ ; __int64 @@v11@@ ; __int64 @@v12@@ ; _BYTE * @@v13@@ ; _BYTE * @@v14@@ ; size_t @@v15@@ ; unsigned __int64 @@v16@@ ; unsigned __int64 @@v17@@ ; @@v8@@ = @@a1@@ ; @@s@@ = @@a2@@ ; @@v6@@ = @@a3@@ ; @@v17@@ = __readfsqword ( Number ) ; @@v15@@ = strlen ( @@a2@@ ) ; if ( @@v15@@ > Number ) { @@v4@@ = Number L ; } else if ( Number * @@v15@@ > Number ) { @@v4@@ = mmalloca ( Number * @@v15@@ ) ; } else { @@v3@@ = alloca ( Number * ( ( Number * ( @@v15@@ + Number ) + Number ) / Number ) ) ; @@v4@@ = Number * ( ( ( unsigned __int64 ) & @@v6@@ + Number ) >> Number ) + Number ; } @@v16@@ = @@v4@@ ; if ( ! @@v4@@ ) return Number L ; * ( _QWORD * ) ( @@v16@@ + Number ) = Number L ; @@v11@@ = Number L ; for ( @@i@@ = Number L ; @@i@@ < @@v15@@ ; ++ @@i@@ ) { @@v9@@ = @@s@@ [ @@i@@ - Number ] ; while ( Number ) { if ( @@v9@@ == @@s@@ [ @@v11@@ ] ) { ++ @@v11@@ ; * ( _QWORD * ) ( @@v16@@ + Number * @@i@@ ) = @@i@@ - @@v11@@ ; goto LABEL_15 ; } if ( ! @@v11@@ ) break ; @@v11@@ -= * ( _QWORD * ) ( Number * @@v11@@ + @@v16@@ ) ; } * ( _QWORD * ) ( @@v16@@ + Number * @@i@@ ) = @@i@@ ; LABEL_15 : ; } * @@v6@@ = Number L ; @@v12@@ = Number L ; @@v13@@ = @@v8@@ ; @@v14@@ = @@v8@@ ; while ( * @@v14@@ ) { if ( @@s@@ [ @@v12@@ ] == * @@v14@@ ) { ++ @@v12@@ ; ++ @@v14@@ ; if ( @@v12@@ == @@v15@@ ) { * @@v6@@ = @@v13@@ ; break ; } } else if ( @@v12@@ ) { @@v13@@ += * ( _QWORD * ) ( Number * @@v12@@ + @@v16@@ ) ; @@v12@@ -= * ( _QWORD * ) ( Number * @@v12@@ + @@v16@@ ) ; } else { ++ @@v13@@ ; ++ @@v14@@ ; } } freea ( @@v16@@ ) ; return Number L ; }
void __fastcall match_ctx_free ( __int64 @@a1@@ ) { match_ctx_clean ( ( _QWORD * ) @@a1@@ ) ; free ( * ( void * * ) ( @@a1@@ + Number ) ) ; free ( * ( void * * ) ( @@a1@@ + Number ) ) ; }
_BOOL8 __fastcall c_ispunct ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number && ( @@a1@@ <= Number || @@a1@@ > Number ) && ( ( int ) ( @@a1@@ & Number ) <= Number || ( int ) ( @@a1@@ & Number ) > Number ) ; }
_BOOL8 __fastcall c_iscntrl ( int @@a1@@ ) { return ( @@a1@@ & Number ) == Number || @@a1@@ == Number ; }
_BOOL8 __fastcall c_islower ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
__int64 __fastcall c_toupper ( int @@a1@@ ) { __int64 @@result@@ ; if ( @@a1@@ <= Number || @@a1@@ > Number ) @@result@@ = ( unsigned int ) @@a1@@ ; else @@result@@ = ( unsigned int ) ( @@a1@@ - Number ) ; return @@result@@ ; }
_BOOL8 __fastcall c_isprint ( int @@a1@@ ) { return @@a1@@ > Number && @@a1@@ <= Number ; }
ssize_t __fastcall safe_read ( int @@a1@@ , void * @@a2@@ , size_t @@a3@@ ) { ssize_t @@result@@ ; ssize_t @@v5@@ ; LABEL_1 : for ( @@result@@ = read ( @@a1@@ , @@a2@@ , @@a3@@ ) ; ; @@result@@ = read ( @@a1@@ , @@a2@@ , Number ) ) { @@v5@@ = @@result@@ ; if ( @@result@@ >= Number ) break ; if ( * __errno_location ( ) == Number ) goto LABEL_1 ; if ( * __errno_location ( ) != Number || @@a3@@ <= Number ) return @@v5@@ ; @@a3@@ = Number L ; } return @@result@@ ; }
__int64 __fastcall c_tolower ( int @@a1@@ ) { __int64 @@result@@ ; if ( @@a1@@ <= Number || @@a1@@ > Number ) @@result@@ = ( unsigned int ) @@a1@@ ; else @@result@@ = ( unsigned int ) ( @@a1@@ + Number ) ; return @@result@@ ; }
void __fastcall _libc_csu_init ( unsigned int @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { signed __int64 @@v4@@ ; __int64 @@i@@ ; @@v4@@ = & _do_global_dtors_aux_fini_array_entry - & _frame_dummy_init_array_entry ; init_proc ( ) ; if ( @@v4@@ ) { for ( @@i@@ = Number L ; @@i@@ != @@v4@@ ; ++ @@i@@ ) ( ( void ( __fastcall * ) ( _QWORD , __int64 , __int64 ) ) * ( & _frame_dummy_init_array_entry + @@i@@ ) ) ( @@a1@@ , @@a2@@ , @@a3@@ ) ; } }
void * __fastcall xrealloc ( void * @@a1@@ , size_t @@a2@@ ) { void * @@ptr@@ ; @@ptr@@ = realloc ( @@a1@@ , @@a2@@ ) ; if ( ! @@ptr@@ && @@a2@@ ) xalloc_die ( ) ; return @@ptr@@ ; }
size_t __fastcall mbslen ( const char * @@a1@@ ) { __int64 @@v3@@ ; char @@v4@@ [ Number ] ; int @@v5@@ ; char @@i@@ ; const char * @@v7@@ ; __int64 @@v8@@ ; char @@v9@@ ; int @@v10@@ ; unsigned __int64 @@v11@@ ; @@v11@@ = __readfsqword ( Number ) ; if ( __ctype_get_mb_cur_max ( ) <= Number ) return strlen ( @@a1@@ ) ; @@v3@@ = Number L ; @@v7@@ = @@a1@@ ; @@v4@@ [ Number ] = Number ; memset ( & @@v5@@ , Number , Number ) ; for ( @@i@@ = Number ; ; @@i@@ = Number ) { mbuiter_multi_next_1 ( ( __int64 ) @@v4@@ ) ; if ( @@v9@@ == Number && ! @@v10@@ ) break ; ++ @@v3@@ ; @@v7@@ += @@v8@@ ; } return @@v3@@ ; }
char * getenv ( const char * @@name@@ ) { return getenv ( @@name@@ ) ; }
void __noreturn _exit ( int @@status@@ ) { exit ( @@status@@ ) ; }
char * textdomain ( const char * @@domainname@@ ) { return textdomain ( @@domainname@@ ) ; }
int printf ( const char * @@format@@ , ... ) { return printf ( @@format@@ ) ; }
int iswspace ( wint_t @@wc@@ ) { return iswspace ( @@wc@@ ) ; }
int iswprint ( wint_t @@wc@@ ) { return iswprint ( @@wc@@ ) ; }
void __fastcall __noreturn usage ( int @@a1@@ ) { __int64 @@v1@@ ; char * @@v2@@ ; char * @@v3@@ ; FILE * @@v4@@ ; char * @@v5@@ ; FILE * @@v6@@ ; char * @@v7@@ ; FILE * @@v8@@ ; char * @@v9@@ ; FILE * @@v10@@ ; char * @@v11@@ ; FILE * @@v12@@ ; char * @@v13@@ ; __int64 @@v14@@ ; __int64 @@v15@@ ; char * @@v16@@ ; @@v1@@ = program_name ; if ( @@a1@@ ) { @@v2@@ = gettext ( String ) ; fprintf ( stderr , @@v2@@ , @@v1@@ ) ; } else { @@v3@@ = gettext ( String ) ; printf ( @@v3@@ , @@v1@@ ) ; @@v4@@ = stdout ; @@v5@@ = gettext ( String String String String String String String String ) ; fputs_unlocked ( @@v5@@ , @@v4@@ ) ; @@v6@@ = stdout ; @@v7@@ = gettext ( String String String String ) ; fputs_unlocked ( @@v7@@ , @@v6@@ ) ; @@v8@@ = stdout ; @@v9@@ = gettext ( String ) ; fputs_unlocked ( @@v9@@ , @@v8@@ ) ; @@v10@@ = stdout ; @@v11@@ = gettext ( String ) ; fputs_unlocked ( @@v11@@ , @@v10@@ ) ; @@v12@@ = stdout ; @@v13@@ = gettext ( String ) ; fputs_unlocked ( @@v13@@ , @@v12@@ ) ; @@v14@@ = program_name ; @@v15@@ = program_name ; @@v16@@ = gettext ( String String String String ) ; printf ( @@v16@@ , @@v15@@ , @@v14@@ ) ; emit_ancillary_info ( ) ; } exit ( @@a1@@ ) ; }
__int64 __fastcall strnlen1 ( const void * @@a1@@ , size_t @@a2@@ ) { __int64 @@result@@ ; _BYTE * @@v3@@ ; @@v3@@ = memchr ( @@a1@@ , Number , @@a2@@ ) ; if ( @@v3@@ ) @@result@@ = @@v3@@ - ( _BYTE * ) @@a1@@ + Number ; else @@result@@ = @@a2@@ ; return @@result@@ ; }
__int64 __fastcall xstr_iconv ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { __int64 @@v4@@ ; @@v4@@ = str_iconv ( @@a1@@ , @@a2@@ , @@a3@@ ) ; if ( ! @@v4@@ && * __errno_location ( ) == Number ) xalloc_die ( ) ; return @@v4@@ ; }
__int64 __fastcall quote ( __int64 @@a1@@ ) { return quote_n ( Number , @@a1@@ ) ; }
char * __fastcall gettext_quote ( const char * @@a1@@ , int @@a2@@ ) { char * @@v3@@ ; @@v3@@ = gettext ( @@a1@@ ) ; if ( @@v3@@ == @@a1@@ && @@a2@@ == Number ) @@v3@@ = ( char * ) String ; return @@v3@@ ; }
unsigned __int64 __fastcall quotearg_buffer ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ , __int64 * @@a5@@ ) { __int64 * @@v5@@ ; int @@v9@@ ; __int64 * @@v10@@ ; unsigned __int64 @@v11@@ ; if ( @@a5@@ ) @@v5@@ = @@a5@@ ; else @@v5@@ = & default_quoting_options ; @@v10@@ = @@v5@@ ; @@v9@@ = * __errno_location ( ) ; @@v11@@ = quotearg_buffer_restyled ( @@a1@@ , @@a2@@ , @@a3@@ , @@a4@@ , * ( _DWORD * ) @@v10@@ , * ( ( _DWORD * ) @@v10@@ + Number ) , ( __int64 ) ( @@v10@@ + Number ) , ( char * ) @@v10@@ [ Number ] , ( char * ) @@v10@@ [ Number ] ) ; * __errno_location ( ) = @@v9@@ ; return @@v11@@ ; }
__int64 * __fastcall quotearg_mem ( __int64 @@a1@@ , size_t @@a2@@ ) { return quotearg_n_mem ( Number , @@a1@@ , @@a2@@ ) ; }
__int64 * __fastcall quotearg_n_style_mem ( int @@a1@@ , unsigned int @@a2@@ , __int64 @@a3@@ , size_t @@a4@@ ) { _QWORD @@v7@@ [ Number ] ; @@v7@@ [ Number ] = __readfsqword ( Number ) ; quoting_options_from_style ( @@v7@@ , @@a2@@ ) ; return quotearg_n_options ( @@a1@@ , @@a3@@ , @@a4@@ , ( __int64 ) @@v7@@ ) ; }
__int64 * __fastcall quotearg_char ( __int64 @@a1@@ , unsigned __int8 @@a2@@ ) { return quotearg_char_mem ( @@a1@@ , Number , @@a2@@ ) ; }
__int64 __fastcall quotearg_custom ( __int64 @@a1@@ , __int64 @@a2@@ , __int64 @@a3@@ ) { return quotearg_n_custom ( Number , @@a1@@ , @@a2@@ , @@a3@@ ) ; }
__int64 __fastcall xnrealloc ( __int64 @@a1@@ , unsigned __int64 @@a2@@ , unsigned __int64 @@a3@@ ) { if ( ! is_mul_ok ( @@a3@@ , @@a2@@ ) ) xalloc_die ( ) ; return xrealloc ( @@a1@@ , @@a3@@ * @@a2@@ ) ; }
void * __fastcall xmemdup ( const void * @@a1@@ , size_t @@a2@@ ) { void * @@v2@@ ; @@v2@@ = xmalloc ( @@a2@@ ) ; return memcpy ( @@v2@@ , @@a1@@ , @@a2@@ ) ; }
bool __fastcall is_basic_1 ( unsigned __int8 @@a1@@ ) { return ( ( * ( ( _DWORD * ) & is_basic_table + ( @@a1@@ >> Number ) ) >> ( @@a1@@ & Number ) ) & Number ) != Number ; }
__int64 __fastcall mem_cd_iconv ( char * @@a1@@ , size_t @@a2@@ , void * @@a3@@ , void * * @@a4@@ , size_t * @@a5@@ ) { int @@v9@@ ; char * @@inbuf@@ ; size_t @@inbytesleft@@ ; char * @@outbuf@@ ; size_t @@outbytesleft@@ ; void * @@ptr@@ ; size_t @@v15@@ ; size_t @@v16@@ ; size_t @@v17@@ ; size_t @@size@@ ; size_t @@v19@@ ; size_t @@v20@@ ; char @@v21@@ $D1F1B2789FC85C59BE59CF61C76BFA1E [ Number ] ; unsigned __int64 @@v22@@ ; @@v22@@ = __readfsqword ( Number ) ; iconv ( @@a3@@ , Number L , Number L , Number L , Number L ) ; @@v15@@ = Number L ; @@inbuf@@ = @@a1@@ ; @@inbytesleft@@ = @@a2@@ ; while ( @@inbytesleft@@ ) { @@outbuf@@ = @@v21@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; @@outbytesleft@@ = Number L ; @@v16@@ = iconv ( @@a3@@ , & @@inbuf@@ , & @@inbytesleft@@ , & @@outbuf@@ , & @@outbytesleft@@ ) ; if ( @@v16@@ == Number && * __errno_location ( ) != Number ) { if ( * __errno_location ( ) != Number ) return Number ; break ; } @@v15@@ += @@outbuf@@ - @@v21@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; } @@outbuf@@ = @@v21@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; @@outbytesleft@@ = Number L ; @@v17@@ = iconv ( @@a3@@ , Number L , Number L , & @@outbuf@@ , & @@outbytesleft@@ ) ; if ( @@v17@@ == Number ) return Number ; @@v15@@ += @@outbuf@@ - @@v21@@ $D1F1B2789FC85C59BE59CF61C76BFA1E ; @@size@@ = @@v15@@ ; if ( ! @@v15@@ ) { * @@a5@@ = Number L ; return Number L ; } if ( * @@a4@@ && @@size@@ <= * @@a5@@ ) { @@ptr@@ = * @@a4@@ ; } else { @@ptr@@ = malloc ( @@size@@ ) ; if ( ! @@ptr@@ ) { * __errno_location ( ) = Number ; return Number ; } } iconv ( @@a3@@ , Number L , Number L , Number L , Number L ) ; @@inbuf@@ = @@a1@@ ; @@inbytesleft@@ = @@a2@@ ; @@outbuf@@ = ( char * ) @@ptr@@ ; @@outbytesleft@@ = @@size@@ ; while ( @@inbytesleft@@ ) { @@v19@@ = iconv ( @@a3@@ , & @@inbuf@@ , & @@inbytesleft@@ , & @@outbuf@@ , & @@outbytesleft@@ ) ; if ( @@v19@@ == Number ) { if ( * __errno_location ( ) != Number ) goto LABEL_26 ; break ; } } @@v20@@ = iconv ( @@a3@@ , Number L , Number L , & @@outbuf@@ , & @@outbytesleft@@ ) ; if ( @@v20@@ != Number ) { if ( @@outbytesleft@@ ) abort ( ) ; * @@a4@@ = @@ptr@@ ; * @@a5@@ = @@size@@ ; return Number L ; } LABEL_26 : if ( @@ptr@@ != * @@a4@@ ) { @@v9@@ = * __errno_location ( ) ; free ( @@ptr@@ ) ; * __errno_location ( ) = @@v9@@ ; } return Number ; }
_BOOL8 __fastcall c_isblank ( int @@a1@@ ) { return @@a1@@ == Number || @@a1@@ == Number ; }
_BOOL8 __fastcall c_isspace ( int @@a1@@ ) { return @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number || @@a1@@ == Number ; }
unsigned __int64 __fastcall mmalloca ( unsigned __int64 @@a1@@ ) { char * @@v2@@ ; unsigned __int64 @@v3@@ ; if ( @@a1@@ + Number < @@a1@@ ) return Number L ; @@v2@@ = ( char * ) malloc ( @@a1@@ + Number ) ; if ( ! @@v2@@ ) return Number L ; @@v3@@ = ( unsigned __int64 ) ( @@v2@@ + Number ) ; * ( _DWORD * ) ( @@v3@@ - Number ) = Number ; * ( _QWORD * ) ( @@v3@@ - Number ) = mmalloca_results [ @@v3@@ % Number ] ; mmalloca_results [ @@v3@@ % Number ] = @@v3@@ ; return @@v3@@ ; }
